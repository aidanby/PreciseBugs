{"buggy_code": ["/*\n * Copyright (C) 2004 IBM Corporation\n *\n * Authors:\n * Leendert van Doorn <leendert@watson.ibm.com>\n * Dave Safford <safford@watson.ibm.com>\n * Reiner Sailer <sailer@watson.ibm.com>\n * Kylene Hall <kjhall@us.ibm.com>\n *\n * Maintained by: <tpmdd-devel@lists.sourceforge.net>\n *\n * Device driver for TCG/TCPA TPM (trusted platform module).\n * Specifications at www.trustedcomputinggroup.org\t \n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2 of the\n * License.\n * \n * Note, the TPM chip is not interrupt driven (only polling)\n * and can have very long timeouts (minutes!). Hence the unusual\n * calls to msleep.\n *\n */\n\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n\n#include \"tpm.h\"\n\nenum tpm_const {\n\tTPM_MINOR = 224,\t/* officially assigned */\n\tTPM_BUFSIZE = 4096,\n\tTPM_NUM_DEVICES = 256,\n};\n\nenum tpm_duration {\n\tTPM_SHORT = 0,\n\tTPM_MEDIUM = 1,\n\tTPM_LONG = 2,\n\tTPM_UNDEFINED,\n};\n\n#define TPM_MAX_ORDINAL 243\n#define TPM_MAX_PROTECTED_ORDINAL 12\n#define TPM_PROTECTED_ORDINAL_MASK 0xFF\n\n/*\n * Bug workaround - some TPM's don't flush the most\n * recently changed pcr on suspend, so force the flush\n * with an extend to the selected _unused_ non-volatile pcr.\n */\nstatic int tpm_suspend_pcr;\nmodule_param_named(suspend_pcr, tpm_suspend_pcr, uint, 0644);\nMODULE_PARM_DESC(suspend_pcr,\n\t\t \"PCR to use for dummy writes to faciltate flush on suspend.\");\n\nstatic LIST_HEAD(tpm_chip_list);\nstatic DEFINE_SPINLOCK(driver_lock);\nstatic DECLARE_BITMAP(dev_mask, TPM_NUM_DEVICES);\n\n/*\n * Array with one entry per ordinal defining the maximum amount\n * of time the chip could take to return the result.  The ordinal\n * designation of short, medium or long is defined in a table in\n * TCG Specification TPM Main Part 2 TPM Structures Section 17. The\n * values of the SHORT, MEDIUM, and LONG durations are retrieved\n * from the chip during initialization with a call to tpm_get_timeouts.\n */\nstatic const u8 tpm_protected_ordinal_duration[TPM_MAX_PROTECTED_ORDINAL] = {\n\tTPM_UNDEFINED,\t\t/* 0 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 5 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 10 */\n\tTPM_SHORT,\n};\n\nstatic const u8 tpm_ordinal_duration[TPM_MAX_ORDINAL] = {\n\tTPM_UNDEFINED,\t\t/* 0 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 5 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 10 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_LONG,\n\tTPM_MEDIUM,\t\t/* 15 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_SHORT,\t\t/* 20 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\t\t/* 25 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t/* 30 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 35 */\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 40 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 45 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_LONG,\n\tTPM_MEDIUM,\t\t/* 50 */\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 55 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 60 */\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t/* 65 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 70 */\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 75 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t/* 80 */\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 85 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 90 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 95 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 100 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 105 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 110 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 115 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t/* 120 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 125 */\n\tTPM_SHORT,\n\tTPM_LONG,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 130 */\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\t\t/* 135 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 140 */\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 145 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 150 */\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 155 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 160 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 165 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t/* 170 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 175 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 180 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\t\t/* 185 */\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 190 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 195 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 200 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 205 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t/* 210 */\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\t\t/* 215 */\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 220 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 225 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 230 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 235 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 240 */\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n};\n\nstatic void user_reader_timeout(unsigned long ptr)\n{\n\tstruct tpm_chip *chip = (struct tpm_chip *) ptr;\n\n\tschedule_work(&chip->work);\n}\n\nstatic void timeout_work(struct work_struct *work)\n{\n\tstruct tpm_chip *chip = container_of(work, struct tpm_chip, work);\n\n\tmutex_lock(&chip->buffer_mutex);\n\tatomic_set(&chip->data_pending, 0);\n\tmemset(chip->data_buffer, 0, TPM_BUFSIZE);\n\tmutex_unlock(&chip->buffer_mutex);\n}\n\n/*\n * Returns max number of jiffies to wait\n */\nunsigned long tpm_calc_ordinal_duration(struct tpm_chip *chip,\n\t\t\t\t\t   u32 ordinal)\n{\n\tint duration_idx = TPM_UNDEFINED;\n\tint duration = 0;\n\n\tif (ordinal < TPM_MAX_ORDINAL)\n\t\tduration_idx = tpm_ordinal_duration[ordinal];\n\telse if ((ordinal & TPM_PROTECTED_ORDINAL_MASK) <\n\t\t TPM_MAX_PROTECTED_ORDINAL)\n\t\tduration_idx =\n\t\t    tpm_protected_ordinal_duration[ordinal &\n\t\t\t\t\t\t   TPM_PROTECTED_ORDINAL_MASK];\n\n\tif (duration_idx != TPM_UNDEFINED)\n\t\tduration = chip->vendor.duration[duration_idx];\n\tif (duration <= 0)\n\t\treturn 2 * 60 * HZ;\n\telse\n\t\treturn duration;\n}\nEXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);\n\n/*\n * Internal kernel interface to transmit TPM commands\n */\nstatic ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\n\t\t\t    size_t bufsiz)\n{\n\tssize_t rc;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\n\tcount = be32_to_cpu(*((__be32 *) (buf + 2)));\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(chip->dev,\n\t\t\t\"invalid count value %x %zx \\n\", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\n\tmutex_lock(&chip->tpm_mutex);\n\n\tif ((rc = chip->vendor.send(chip, (u8 *) buf, count)) < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_send: error %zd\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (chip->vendor.irq)\n\t\tgoto out_recv;\n\n\tstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\n\tdo {\n\t\tu8 status = chip->vendor.status(chip);\n\t\tif ((status & chip->vendor.req_complete_mask) ==\n\t\t    chip->vendor.req_complete_val)\n\t\t\tgoto out_recv;\n\n\t\tif ((status == chip->vendor.req_canceled)) {\n\t\t\tdev_err(chip->dev, \"Operation Canceled\\n\");\n\t\t\trc = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmsleep(TPM_TIMEOUT);\t/* CHECK */\n\t\trmb();\n\t} while (time_before(jiffies, stop));\n\n\tchip->vendor.cancel(chip);\n\tdev_err(chip->dev, \"Operation Timed out\\n\");\n\trc = -ETIME;\n\tgoto out;\n\nout_recv:\n\trc = chip->vendor.recv(chip, (u8 *) buf, bufsiz);\n\tif (rc < 0)\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_recv: error %zd\\n\", rc);\nout:\n\tmutex_unlock(&chip->tpm_mutex);\n\treturn rc;\n}\n\n#define TPM_DIGEST_SIZE 20\n#define TPM_ERROR_SIZE 10\n#define TPM_RET_CODE_IDX 6\n\nenum tpm_capabilities {\n\tTPM_CAP_FLAG = cpu_to_be32(4),\n\tTPM_CAP_PROP = cpu_to_be32(5),\n\tCAP_VERSION_1_1 = cpu_to_be32(0x06),\n\tCAP_VERSION_1_2 = cpu_to_be32(0x1A)\n};\n\nenum tpm_sub_capabilities {\n\tTPM_CAP_PROP_PCR = cpu_to_be32(0x101),\n\tTPM_CAP_PROP_MANUFACTURER = cpu_to_be32(0x103),\n\tTPM_CAP_FLAG_PERM = cpu_to_be32(0x108),\n\tTPM_CAP_FLAG_VOL = cpu_to_be32(0x109),\n\tTPM_CAP_PROP_OWNER = cpu_to_be32(0x111),\n\tTPM_CAP_PROP_TIS_TIMEOUT = cpu_to_be32(0x115),\n\tTPM_CAP_PROP_TIS_DURATION = cpu_to_be32(0x120),\n\n};\n\nstatic ssize_t transmit_cmd(struct tpm_chip *chip, struct tpm_cmd_t *cmd,\n\t\t\t    int len, const char *desc)\n{\n\tint err;\n\n\tlen = tpm_transmit(chip,(u8 *) cmd, len);\n\tif (len <  0)\n\t\treturn len;\n\tif (len == TPM_ERROR_SIZE) {\n\t\terr = be32_to_cpu(cmd->header.out.return_code);\n\t\tdev_dbg(chip->dev, \"A TPM error (%d) occurred %s\\n\", err, desc);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n#define TPM_INTERNAL_RESULT_SIZE 200\n#define TPM_TAG_RQU_COMMAND cpu_to_be16(193)\n#define TPM_ORD_GET_CAP cpu_to_be32(101)\n\nstatic const struct tpm_input_header tpm_getcap_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(22),\n\t.ordinal = TPM_ORD_GET_CAP\n};\n\nssize_t tpm_getcap(struct device *dev, __be32 subcap_id, cap_t *cap,\n\t\t   const char *desc)\n{\n\tstruct tpm_cmd_t tpm_cmd;\n\tint rc;\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\tif (subcap_id == CAP_VERSION_1_1 || subcap_id == CAP_VERSION_1_2) {\n\t\ttpm_cmd.params.getcap_in.cap = subcap_id;\n\t\t/*subcap field not necessary */\n\t\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(0);\n\t\ttpm_cmd.header.in.length -= cpu_to_be32(sizeof(__be32));\n\t} else {\n\t\tif (subcap_id == TPM_CAP_FLAG_PERM ||\n\t\t    subcap_id == TPM_CAP_FLAG_VOL)\n\t\t\ttpm_cmd.params.getcap_in.cap = TPM_CAP_FLAG;\n\t\telse\n\t\t\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\t\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\t\ttpm_cmd.params.getcap_in.subcap = subcap_id;\n\t}\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);\n\tif (!rc)\n\t\t*cap = tpm_cmd.params.getcap_out.cap;\n\treturn rc;\n}\n\nvoid tpm_gen_interrupt(struct tpm_chip *chip)\n{\n\tstruct\ttpm_cmd_t tpm_cmd;\n\tssize_t rc;\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the timeouts\");\n}\nEXPORT_SYMBOL_GPL(tpm_gen_interrupt);\n\nvoid tpm_get_timeouts(struct tpm_chip *chip)\n{\n\tstruct tpm_cmd_t tpm_cmd;\n\tstruct timeout_t *timeout_cap;\n\tstruct duration_t *duration_cap;\n\tssize_t rc;\n\tu32 timeout;\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the timeouts\");\n\tif (rc)\n\t\tgoto duration;\n\n\tif (be32_to_cpu(tpm_cmd.header.out.length)\n\t    != 4 * sizeof(u32))\n\t\tgoto duration;\n\n\ttimeout_cap = &tpm_cmd.params.getcap_out.cap.timeout;\n\t/* Don't overwrite default if value is 0 */\n\ttimeout = be32_to_cpu(timeout_cap->a);\n\tif (timeout)\n\t\tchip->vendor.timeout_a = usecs_to_jiffies(timeout);\n\ttimeout = be32_to_cpu(timeout_cap->b);\n\tif (timeout)\n\t\tchip->vendor.timeout_b = usecs_to_jiffies(timeout);\n\ttimeout = be32_to_cpu(timeout_cap->c);\n\tif (timeout)\n\t\tchip->vendor.timeout_c = usecs_to_jiffies(timeout);\n\ttimeout = be32_to_cpu(timeout_cap->d);\n\tif (timeout)\n\t\tchip->vendor.timeout_d = usecs_to_jiffies(timeout);\n\nduration:\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the durations\");\n\tif (rc)\n\t\treturn;\n\n\tif (be32_to_cpu(tpm_cmd.header.out.return_code)\n\t    != 3 * sizeof(u32))\n\t\treturn;\n\tduration_cap = &tpm_cmd.params.getcap_out.cap.duration;\n\tchip->vendor.duration[TPM_SHORT] =\n\t    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_short));\n\t/* The Broadcom BCM0102 chipset in a Dell Latitude D820 gets the above\n\t * value wrong and apparently reports msecs rather than usecs. So we\n\t * fix up the resulting too-small TPM_SHORT value to make things work.\n\t */\n\tif (chip->vendor.duration[TPM_SHORT] < (HZ/100))\n\t\tchip->vendor.duration[TPM_SHORT] = HZ;\n\n\tchip->vendor.duration[TPM_MEDIUM] =\n\t    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_medium));\n\tchip->vendor.duration[TPM_LONG] =\n\t    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_long));\n}\nEXPORT_SYMBOL_GPL(tpm_get_timeouts);\n\nvoid tpm_continue_selftest(struct tpm_chip *chip)\n{\n\tu8 data[] = {\n\t\t0, 193,\t\t\t/* TPM_TAG_RQU_COMMAND */\n\t\t0, 0, 0, 10,\t\t/* length */\n\t\t0, 0, 0, 83,\t\t/* TPM_ORD_GetCapability */\n\t};\n\n\ttpm_transmit(chip, data, sizeof(data));\n}\nEXPORT_SYMBOL_GPL(tpm_continue_selftest);\n\nssize_t tpm_show_enabled(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_PERM, &cap,\n\t\t\t \"attempting to determine the permanent enabled state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", !cap.perm_flags.disable);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_enabled);\n\nssize_t tpm_show_active(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_PERM, &cap,\n\t\t\t \"attempting to determine the permanent active state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", !cap.perm_flags.deactivated);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_active);\n\nssize_t tpm_show_owned(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_OWNER, &cap,\n\t\t\t \"attempting to determine the owner state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", cap.owned);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_owned);\n\nssize_t tpm_show_temp_deactivated(struct device * dev,\n\t\t\t\tstruct device_attribute * attr, char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_VOL, &cap,\n\t\t\t \"attempting to determine the temporary state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", cap.stclear_flags.deactivated);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_temp_deactivated);\n\n/*\n * tpm_chip_find_get - return tpm_chip for given chip number\n */\nstatic struct tpm_chip *tpm_chip_find_get(int chip_num)\n{\n\tstruct tpm_chip *pos, *chip = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (chip_num != TPM_ANY_NUM && chip_num != pos->dev_num)\n\t\t\tcontinue;\n\n\t\tif (try_module_get(pos->dev->driver->owner)) {\n\t\t\tchip = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn chip;\n}\n\n#define TPM_ORDINAL_PCRREAD cpu_to_be32(21)\n#define READ_PCR_RESULT_SIZE 30\nstatic struct tpm_input_header pcrread_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(14),\n\t.ordinal = TPM_ORDINAL_PCRREAD\n};\n\nint __tpm_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)\n{\n\tint rc;\n\tstruct tpm_cmd_t cmd;\n\n\tcmd.header.in = pcrread_header;\n\tcmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);\n\trc = transmit_cmd(chip, &cmd, READ_PCR_RESULT_SIZE,\n\t\t\t  \"attempting to read a pcr value\");\n\n\tif (rc == 0)\n\t\tmemcpy(res_buf, cmd.params.pcrread_out.pcr_result,\n\t\t       TPM_DIGEST_SIZE);\n\treturn rc;\n}\n\n/**\n * tpm_pcr_read - read a pcr value\n * @chip_num: \ttpm idx # or ANY\n * @pcr_idx:\tpcr idx to retrieve\n * @res_buf: \tTPM_PCR value\n * \t\tsize of res_buf is 20 bytes (or NULL if you don't care)\n *\n * The TPM driver should be built-in, but for whatever reason it\n * isn't, protect against the chip disappearing, by incrementing\n * the module usage count.\n */\nint tpm_pcr_read(u32 chip_num, int pcr_idx, u8 *res_buf)\n{\n\tstruct tpm_chip *chip;\n\tint rc;\n\n\tchip = tpm_chip_find_get(chip_num);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\trc = __tpm_pcr_read(chip, pcr_idx, res_buf);\n\ttpm_chip_put(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pcr_read);\n\n/**\n * tpm_pcr_extend - extend pcr value with hash\n * @chip_num: \ttpm idx # or AN&\n * @pcr_idx:\tpcr idx to extend\n * @hash: \thash value used to extend pcr value\n *\n * The TPM driver should be built-in, but for whatever reason it\n * isn't, protect against the chip disappearing, by incrementing\n * the module usage count.\n */\n#define TPM_ORD_PCR_EXTEND cpu_to_be32(20)\n#define EXTEND_PCR_RESULT_SIZE 34\nstatic struct tpm_input_header pcrextend_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(34),\n\t.ordinal = TPM_ORD_PCR_EXTEND\n};\n\nint tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)\n{\n\tstruct tpm_cmd_t cmd;\n\tint rc;\n\tstruct tpm_chip *chip;\n\n\tchip = tpm_chip_find_get(chip_num);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\tcmd.header.in = pcrextend_header;\n\tcmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);\n\tmemcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);\n\trc = transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\n\t\t\t  \"attempting extend a PCR value\");\n\n\ttpm_chip_put(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pcr_extend);\n\nint tpm_send(u32 chip_num, void *cmd, size_t buflen)\n{\n\tstruct tpm_chip *chip;\n\tint rc;\n\n\tchip = tpm_chip_find_get(chip_num);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\trc = transmit_cmd(chip, cmd, buflen, \"attempting tpm_cmd\");\n\n\ttpm_chip_put(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_send);\n\nssize_t tpm_show_pcrs(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tcap_t cap;\n\tu8 digest[TPM_DIGEST_SIZE];\n\tssize_t rc;\n\tint i, j, num_pcrs;\n\tchar *str = buf;\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_PCR, &cap,\n\t\t\t\"attempting to determine the number of PCRS\");\n\tif (rc)\n\t\treturn 0;\n\n\tnum_pcrs = be32_to_cpu(cap.num_pcrs);\n\tfor (i = 0; i < num_pcrs; i++) {\n\t\trc = __tpm_pcr_read(chip, i, digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tstr += sprintf(str, \"PCR-%02d: \", i);\n\t\tfor (j = 0; j < TPM_DIGEST_SIZE; j++)\n\t\t\tstr += sprintf(str, \"%02X \", digest[j]);\n\t\tstr += sprintf(str, \"\\n\");\n\t}\n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(tpm_show_pcrs);\n\n#define  READ_PUBEK_RESULT_SIZE 314\n#define TPM_ORD_READPUBEK cpu_to_be32(124)\nstruct tpm_input_header tpm_readpubek_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(30),\n\t.ordinal = TPM_ORD_READPUBEK\n};\n\nssize_t tpm_show_pubek(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tu8 *data;\n\tstruct tpm_cmd_t tpm_cmd;\n\tssize_t err;\n\tint i, rc;\n\tchar *str = buf;\n\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_cmd.header.in = tpm_readpubek_header;\n\terr = transmit_cmd(chip, &tpm_cmd, READ_PUBEK_RESULT_SIZE,\n\t\t\t\"attempting to read the PUBEK\");\n\tif (err)\n\t\tgoto out;\n\n\t/* \n\t   ignore header 10 bytes\n\t   algorithm 32 bits (1 == RSA )\n\t   encscheme 16 bits\n\t   sigscheme 16 bits\n\t   parameters (RSA 12->bytes: keybit, #primes, expbit)  \n\t   keylenbytes 32 bits\n\t   256 byte modulus\n\t   ignore checksum 20 bytes\n\t */\n\tdata = tpm_cmd.params.readpubek_out_buffer;\n\tstr +=\n\t    sprintf(str,\n\t\t    \"Algorithm: %02X %02X %02X %02X\\nEncscheme: %02X %02X\\n\"\n\t\t    \"Sigscheme: %02X %02X\\nParameters: %02X %02X %02X %02X\"\n\t\t    \" %02X %02X %02X %02X %02X %02X %02X %02X\\n\"\n\t\t    \"Modulus length: %d\\nModulus: \\n\",\n\t\t    data[10], data[11], data[12], data[13], data[14],\n\t\t    data[15], data[16], data[17], data[22], data[23],\n\t\t    data[24], data[25], data[26], data[27], data[28],\n\t\t    data[29], data[30], data[31], data[32], data[33],\n\t\t    be32_to_cpu(*((__be32 *) (data + 34))));\n\n\tfor (i = 0; i < 256; i++) {\n\t\tstr += sprintf(str, \"%02X \", data[i + 38]);\n\t\tif ((i + 1) % 16 == 0)\n\t\t\tstr += sprintf(str, \"\\n\");\n\t}\nout:\n\trc = str - buf;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_pubek);\n\n\nssize_t tpm_show_caps(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\tchar *str = buf;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_MANUFACTURER, &cap,\n\t\t\t\"attempting to determine the manufacturer\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str, \"Manufacturer: 0x%x\\n\",\n\t\t       be32_to_cpu(cap.manufacturer_id));\n\n\trc = tpm_getcap(dev, CAP_VERSION_1_1, &cap,\n\t\t        \"attempting to determine the 1.1 version\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str,\n\t\t       \"TCG version: %d.%d\\nFirmware version: %d.%d\\n\",\n\t\t       cap.tpm_version.Major, cap.tpm_version.Minor,\n\t\t       cap.tpm_version.revMajor, cap.tpm_version.revMinor);\n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(tpm_show_caps);\n\nssize_t tpm_show_caps_1_2(struct device * dev,\n\t\t\t  struct device_attribute * attr, char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\tchar *str = buf;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_MANUFACTURER, &cap,\n\t\t\t\"attempting to determine the manufacturer\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str, \"Manufacturer: 0x%x\\n\",\n\t\t       be32_to_cpu(cap.manufacturer_id));\n\trc = tpm_getcap(dev, CAP_VERSION_1_2, &cap,\n\t\t\t \"attempting to determine the 1.2 version\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str,\n\t\t       \"TCG version: %d.%d\\nFirmware version: %d.%d\\n\",\n\t\t       cap.tpm_version_1_2.Major, cap.tpm_version_1_2.Minor,\n\t\t       cap.tpm_version_1_2.revMajor,\n\t\t       cap.tpm_version_1_2.revMinor);\n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(tpm_show_caps_1_2);\n\nssize_t tpm_store_cancel(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tif (chip == NULL)\n\t\treturn 0;\n\n\tchip->vendor.cancel(chip);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(tpm_store_cancel);\n\n/*\n * Device file system interface to the TPM\n *\n * It's assured that the chip will be opened just once,\n * by the check of is_open variable, which is protected\n * by driver_lock.\n */\nint tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_open);\n\n/*\n * Called on file close\n */\nint tpm_release(struct inode *inode, struct file *file)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tfile->private_data = NULL;\n\tatomic_set(&chip->data_pending, 0);\n\tkfree(chip->data_buffer);\n\tclear_bit(0, &chip->is_open);\n\tput_device(chip->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_release);\n\nssize_t tpm_write(struct file *file, const char __user *buf,\n\t\t  size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tsize_t in_size = size, out_size;\n\n\t/* cannot perform a write until the read has cleared\n\t   either via tpm_read or a user_read_timer timeout */\n\twhile (atomic_read(&chip->data_pending) != 0)\n\t\tmsleep(TPM_TIMEOUT);\n\n\tmutex_lock(&chip->buffer_mutex);\n\n\tif (in_size > TPM_BUFSIZE)\n\t\tin_size = TPM_BUFSIZE;\n\n\tif (copy_from_user\n\t    (chip->data_buffer, (void __user *) buf, in_size)) {\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\t/* atomic tpm command send and result receive */\n\tout_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);\n\n\tatomic_set(&chip->data_pending, out_size);\n\tmutex_unlock(&chip->buffer_mutex);\n\n\t/* Set a timeout by which the reader must come claim the result */\n\tmod_timer(&chip->user_read_timer, jiffies + (60 * HZ));\n\n\treturn in_size;\n}\nEXPORT_SYMBOL_GPL(tpm_write);\n\nssize_t tpm_read(struct file *file, char __user *buf,\n\t\t size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tssize_t ret_size;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tret_size = atomic_read(&chip->data_pending);\n\tatomic_set(&chip->data_pending, 0);\n\tif (ret_size > 0) {\t/* relay data */\n\t\tif (size < ret_size)\n\t\t\tret_size = size;\n\n\t\tmutex_lock(&chip->buffer_mutex);\n\t\tif (copy_to_user(buf, chip->data_buffer, ret_size))\n\t\t\tret_size = -EFAULT;\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t}\n\n\treturn ret_size;\n}\nEXPORT_SYMBOL_GPL(tpm_read);\n\nvoid tpm_remove_hardware(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip == NULL) {\n\t\tdev_err(dev, \"No device data found\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock(&driver_lock);\n\tlist_del_rcu(&chip->list);\n\tspin_unlock(&driver_lock);\n\tsynchronize_rcu();\n\n\tmisc_deregister(&chip->vendor.miscdev);\n\tsysfs_remove_group(&dev->kobj, chip->vendor.attr_group);\n\ttpm_bios_log_teardown(chip->bios_dir);\n\n\t/* write it this way to be explicit (chip->dev == dev) */\n\tput_device(chip->dev);\n}\nEXPORT_SYMBOL_GPL(tpm_remove_hardware);\n\n#define TPM_ORD_SAVESTATE cpu_to_be32(152)\n#define SAVESTATE_RESULT_SIZE 10\n\nstatic struct tpm_input_header savestate_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(10),\n\t.ordinal = TPM_ORD_SAVESTATE\n};\n\n/*\n * We are about to suspend. Save the TPM state\n * so that it can be restored.\n */\nint tpm_pm_suspend(struct device *dev, pm_message_t pm_state)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct tpm_cmd_t cmd;\n\tint rc;\n\n\tu8 dummy_hash[TPM_DIGEST_SIZE] = { 0 };\n\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\t/* for buggy tpm, flush pcrs with extend to selected dummy */\n\tif (tpm_suspend_pcr) {\n\t\tcmd.header.in = pcrextend_header;\n\t\tcmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);\n\t\tmemcpy(cmd.params.pcrextend_in.hash, dummy_hash,\n\t\t       TPM_DIGEST_SIZE);\n\t\trc = transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\n\t\t\t\t  \"extending dummy pcr before suspend\");\n\t}\n\n\t/* now do the actual savestate */\n\tcmd.header.in = savestate_header;\n\trc = transmit_cmd(chip, &cmd, SAVESTATE_RESULT_SIZE,\n\t\t\t  \"sending savestate before suspend\");\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pm_suspend);\n\n/*\n * Resume from a power safe. The BIOS already restored\n * the TPM state.\n */\nint tpm_pm_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_pm_resume);\n\n/* In case vendor provided release function, call it too.*/\n\nvoid tpm_dev_vendor_release(struct tpm_chip *chip)\n{\n\tif (chip->vendor.release)\n\t\tchip->vendor.release(chip->dev);\n\n\tclear_bit(chip->dev_num, dev_mask);\n\tkfree(chip->vendor.miscdev.name);\n}\nEXPORT_SYMBOL_GPL(tpm_dev_vendor_release);\n\n\n/*\n * Once all references to platform device are down to 0,\n * release all allocated structures.\n */\nvoid tpm_dev_release(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_dev_vendor_release(chip);\n\n\tchip->release(dev);\n\tkfree(chip);\n}\nEXPORT_SYMBOL_GPL(tpm_dev_release);\n\n/*\n * Called from tpm_<specific>.c probe function only for devices \n * the driver has determined it should claim.  Prior to calling\n * this function the specific probe function has called pci_enable_device\n * upon errant exit from this function specific probe function should call\n * pci_disable_device\n */\nstruct tpm_chip *tpm_register_hardware(struct device *dev,\n\t\t\t\t\tconst struct tpm_vendor_specific *entry)\n{\n#define DEVNAME_SIZE 7\n\n\tchar *devname;\n\tstruct tpm_chip *chip;\n\n\t/* Driver specific per-device data */\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tdevname = kmalloc(DEVNAME_SIZE, GFP_KERNEL);\n\n\tif (chip == NULL || devname == NULL)\n\t\tgoto out_free;\n\n\tmutex_init(&chip->buffer_mutex);\n\tmutex_init(&chip->tpm_mutex);\n\tINIT_LIST_HEAD(&chip->list);\n\n\tINIT_WORK(&chip->work, timeout_work);\n\n\tsetup_timer(&chip->user_read_timer, user_reader_timeout,\n\t\t\t(unsigned long)chip);\n\n\tmemcpy(&chip->vendor, entry, sizeof(struct tpm_vendor_specific));\n\n\tchip->dev_num = find_first_zero_bit(dev_mask, TPM_NUM_DEVICES);\n\n\tif (chip->dev_num >= TPM_NUM_DEVICES) {\n\t\tdev_err(dev, \"No available tpm device numbers\\n\");\n\t\tgoto out_free;\n\t} else if (chip->dev_num == 0)\n\t\tchip->vendor.miscdev.minor = TPM_MINOR;\n\telse\n\t\tchip->vendor.miscdev.minor = MISC_DYNAMIC_MINOR;\n\n\tset_bit(chip->dev_num, dev_mask);\n\n\tscnprintf(devname, DEVNAME_SIZE, \"%s%d\", \"tpm\", chip->dev_num);\n\tchip->vendor.miscdev.name = devname;\n\n\tchip->vendor.miscdev.parent = dev;\n\tchip->dev = get_device(dev);\n\tchip->release = dev->release;\n\tdev->release = tpm_dev_release;\n\tdev_set_drvdata(dev, chip);\n\n\tif (misc_register(&chip->vendor.miscdev)) {\n\t\tdev_err(chip->dev,\n\t\t\t\"unable to misc_register %s, minor %d\\n\",\n\t\t\tchip->vendor.miscdev.name,\n\t\t\tchip->vendor.miscdev.minor);\n\t\tput_device(chip->dev);\n\t\treturn NULL;\n\t}\n\n\tif (sysfs_create_group(&dev->kobj, chip->vendor.attr_group)) {\n\t\tmisc_deregister(&chip->vendor.miscdev);\n\t\tput_device(chip->dev);\n\n\t\treturn NULL;\n\t}\n\n\tchip->bios_dir = tpm_bios_log_setup(devname);\n\n\t/* Make chip available */\n\tspin_lock(&driver_lock);\n\tlist_add_rcu(&chip->list, &tpm_chip_list);\n\tspin_unlock(&driver_lock);\n\n\treturn chip;\n\nout_free:\n\tkfree(chip);\n\tkfree(devname);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tpm_register_hardware);\n\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * Copyright (C) 2004 IBM Corporation\n *\n * Authors:\n * Leendert van Doorn <leendert@watson.ibm.com>\n * Dave Safford <safford@watson.ibm.com>\n * Reiner Sailer <sailer@watson.ibm.com>\n * Kylene Hall <kjhall@us.ibm.com>\n *\n * Maintained by: <tpmdd-devel@lists.sourceforge.net>\n *\n * Device driver for TCG/TCPA TPM (trusted platform module).\n * Specifications at www.trustedcomputinggroup.org\t \n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2 of the\n * License.\n * \n * Note, the TPM chip is not interrupt driven (only polling)\n * and can have very long timeouts (minutes!). Hence the unusual\n * calls to msleep.\n *\n */\n\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n\n#include \"tpm.h\"\n\nenum tpm_const {\n\tTPM_MINOR = 224,\t/* officially assigned */\n\tTPM_BUFSIZE = 4096,\n\tTPM_NUM_DEVICES = 256,\n};\n\nenum tpm_duration {\n\tTPM_SHORT = 0,\n\tTPM_MEDIUM = 1,\n\tTPM_LONG = 2,\n\tTPM_UNDEFINED,\n};\n\n#define TPM_MAX_ORDINAL 243\n#define TPM_MAX_PROTECTED_ORDINAL 12\n#define TPM_PROTECTED_ORDINAL_MASK 0xFF\n\n/*\n * Bug workaround - some TPM's don't flush the most\n * recently changed pcr on suspend, so force the flush\n * with an extend to the selected _unused_ non-volatile pcr.\n */\nstatic int tpm_suspend_pcr;\nmodule_param_named(suspend_pcr, tpm_suspend_pcr, uint, 0644);\nMODULE_PARM_DESC(suspend_pcr,\n\t\t \"PCR to use for dummy writes to faciltate flush on suspend.\");\n\nstatic LIST_HEAD(tpm_chip_list);\nstatic DEFINE_SPINLOCK(driver_lock);\nstatic DECLARE_BITMAP(dev_mask, TPM_NUM_DEVICES);\n\n/*\n * Array with one entry per ordinal defining the maximum amount\n * of time the chip could take to return the result.  The ordinal\n * designation of short, medium or long is defined in a table in\n * TCG Specification TPM Main Part 2 TPM Structures Section 17. The\n * values of the SHORT, MEDIUM, and LONG durations are retrieved\n * from the chip during initialization with a call to tpm_get_timeouts.\n */\nstatic const u8 tpm_protected_ordinal_duration[TPM_MAX_PROTECTED_ORDINAL] = {\n\tTPM_UNDEFINED,\t\t/* 0 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 5 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 10 */\n\tTPM_SHORT,\n};\n\nstatic const u8 tpm_ordinal_duration[TPM_MAX_ORDINAL] = {\n\tTPM_UNDEFINED,\t\t/* 0 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 5 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 10 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_LONG,\n\tTPM_MEDIUM,\t\t/* 15 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_SHORT,\t\t/* 20 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\t\t/* 25 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t/* 30 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 35 */\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 40 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 45 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_LONG,\n\tTPM_MEDIUM,\t\t/* 50 */\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 55 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 60 */\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t/* 65 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 70 */\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 75 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t/* 80 */\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 85 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 90 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 95 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 100 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 105 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 110 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 115 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t/* 120 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 125 */\n\tTPM_SHORT,\n\tTPM_LONG,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 130 */\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\t\t/* 135 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 140 */\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 145 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 150 */\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 155 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 160 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 165 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t/* 170 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 175 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t/* 180 */\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\t\t/* 185 */\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 190 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 195 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 200 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 205 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t/* 210 */\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\t\t/* 215 */\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t/* 220 */\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t/* 225 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 230 */\n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t/* 235 */\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t/* 240 */\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n};\n\nstatic void user_reader_timeout(unsigned long ptr)\n{\n\tstruct tpm_chip *chip = (struct tpm_chip *) ptr;\n\n\tschedule_work(&chip->work);\n}\n\nstatic void timeout_work(struct work_struct *work)\n{\n\tstruct tpm_chip *chip = container_of(work, struct tpm_chip, work);\n\n\tmutex_lock(&chip->buffer_mutex);\n\tatomic_set(&chip->data_pending, 0);\n\tmemset(chip->data_buffer, 0, TPM_BUFSIZE);\n\tmutex_unlock(&chip->buffer_mutex);\n}\n\n/*\n * Returns max number of jiffies to wait\n */\nunsigned long tpm_calc_ordinal_duration(struct tpm_chip *chip,\n\t\t\t\t\t   u32 ordinal)\n{\n\tint duration_idx = TPM_UNDEFINED;\n\tint duration = 0;\n\n\tif (ordinal < TPM_MAX_ORDINAL)\n\t\tduration_idx = tpm_ordinal_duration[ordinal];\n\telse if ((ordinal & TPM_PROTECTED_ORDINAL_MASK) <\n\t\t TPM_MAX_PROTECTED_ORDINAL)\n\t\tduration_idx =\n\t\t    tpm_protected_ordinal_duration[ordinal &\n\t\t\t\t\t\t   TPM_PROTECTED_ORDINAL_MASK];\n\n\tif (duration_idx != TPM_UNDEFINED)\n\t\tduration = chip->vendor.duration[duration_idx];\n\tif (duration <= 0)\n\t\treturn 2 * 60 * HZ;\n\telse\n\t\treturn duration;\n}\nEXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);\n\n/*\n * Internal kernel interface to transmit TPM commands\n */\nstatic ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\n\t\t\t    size_t bufsiz)\n{\n\tssize_t rc;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\n\tcount = be32_to_cpu(*((__be32 *) (buf + 2)));\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(chip->dev,\n\t\t\t\"invalid count value %x %zx \\n\", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\n\tmutex_lock(&chip->tpm_mutex);\n\n\tif ((rc = chip->vendor.send(chip, (u8 *) buf, count)) < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_send: error %zd\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (chip->vendor.irq)\n\t\tgoto out_recv;\n\n\tstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\n\tdo {\n\t\tu8 status = chip->vendor.status(chip);\n\t\tif ((status & chip->vendor.req_complete_mask) ==\n\t\t    chip->vendor.req_complete_val)\n\t\t\tgoto out_recv;\n\n\t\tif ((status == chip->vendor.req_canceled)) {\n\t\t\tdev_err(chip->dev, \"Operation Canceled\\n\");\n\t\t\trc = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmsleep(TPM_TIMEOUT);\t/* CHECK */\n\t\trmb();\n\t} while (time_before(jiffies, stop));\n\n\tchip->vendor.cancel(chip);\n\tdev_err(chip->dev, \"Operation Timed out\\n\");\n\trc = -ETIME;\n\tgoto out;\n\nout_recv:\n\trc = chip->vendor.recv(chip, (u8 *) buf, bufsiz);\n\tif (rc < 0)\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_recv: error %zd\\n\", rc);\nout:\n\tmutex_unlock(&chip->tpm_mutex);\n\treturn rc;\n}\n\n#define TPM_DIGEST_SIZE 20\n#define TPM_ERROR_SIZE 10\n#define TPM_RET_CODE_IDX 6\n\nenum tpm_capabilities {\n\tTPM_CAP_FLAG = cpu_to_be32(4),\n\tTPM_CAP_PROP = cpu_to_be32(5),\n\tCAP_VERSION_1_1 = cpu_to_be32(0x06),\n\tCAP_VERSION_1_2 = cpu_to_be32(0x1A)\n};\n\nenum tpm_sub_capabilities {\n\tTPM_CAP_PROP_PCR = cpu_to_be32(0x101),\n\tTPM_CAP_PROP_MANUFACTURER = cpu_to_be32(0x103),\n\tTPM_CAP_FLAG_PERM = cpu_to_be32(0x108),\n\tTPM_CAP_FLAG_VOL = cpu_to_be32(0x109),\n\tTPM_CAP_PROP_OWNER = cpu_to_be32(0x111),\n\tTPM_CAP_PROP_TIS_TIMEOUT = cpu_to_be32(0x115),\n\tTPM_CAP_PROP_TIS_DURATION = cpu_to_be32(0x120),\n\n};\n\nstatic ssize_t transmit_cmd(struct tpm_chip *chip, struct tpm_cmd_t *cmd,\n\t\t\t    int len, const char *desc)\n{\n\tint err;\n\n\tlen = tpm_transmit(chip,(u8 *) cmd, len);\n\tif (len <  0)\n\t\treturn len;\n\tif (len == TPM_ERROR_SIZE) {\n\t\terr = be32_to_cpu(cmd->header.out.return_code);\n\t\tdev_dbg(chip->dev, \"A TPM error (%d) occurred %s\\n\", err, desc);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n#define TPM_INTERNAL_RESULT_SIZE 200\n#define TPM_TAG_RQU_COMMAND cpu_to_be16(193)\n#define TPM_ORD_GET_CAP cpu_to_be32(101)\n\nstatic const struct tpm_input_header tpm_getcap_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(22),\n\t.ordinal = TPM_ORD_GET_CAP\n};\n\nssize_t tpm_getcap(struct device *dev, __be32 subcap_id, cap_t *cap,\n\t\t   const char *desc)\n{\n\tstruct tpm_cmd_t tpm_cmd;\n\tint rc;\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\tif (subcap_id == CAP_VERSION_1_1 || subcap_id == CAP_VERSION_1_2) {\n\t\ttpm_cmd.params.getcap_in.cap = subcap_id;\n\t\t/*subcap field not necessary */\n\t\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(0);\n\t\ttpm_cmd.header.in.length -= cpu_to_be32(sizeof(__be32));\n\t} else {\n\t\tif (subcap_id == TPM_CAP_FLAG_PERM ||\n\t\t    subcap_id == TPM_CAP_FLAG_VOL)\n\t\t\ttpm_cmd.params.getcap_in.cap = TPM_CAP_FLAG;\n\t\telse\n\t\t\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\t\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\t\ttpm_cmd.params.getcap_in.subcap = subcap_id;\n\t}\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);\n\tif (!rc)\n\t\t*cap = tpm_cmd.params.getcap_out.cap;\n\treturn rc;\n}\n\nvoid tpm_gen_interrupt(struct tpm_chip *chip)\n{\n\tstruct\ttpm_cmd_t tpm_cmd;\n\tssize_t rc;\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the timeouts\");\n}\nEXPORT_SYMBOL_GPL(tpm_gen_interrupt);\n\nvoid tpm_get_timeouts(struct tpm_chip *chip)\n{\n\tstruct tpm_cmd_t tpm_cmd;\n\tstruct timeout_t *timeout_cap;\n\tstruct duration_t *duration_cap;\n\tssize_t rc;\n\tu32 timeout;\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the timeouts\");\n\tif (rc)\n\t\tgoto duration;\n\n\tif (be32_to_cpu(tpm_cmd.header.out.length)\n\t    != 4 * sizeof(u32))\n\t\tgoto duration;\n\n\ttimeout_cap = &tpm_cmd.params.getcap_out.cap.timeout;\n\t/* Don't overwrite default if value is 0 */\n\ttimeout = be32_to_cpu(timeout_cap->a);\n\tif (timeout)\n\t\tchip->vendor.timeout_a = usecs_to_jiffies(timeout);\n\ttimeout = be32_to_cpu(timeout_cap->b);\n\tif (timeout)\n\t\tchip->vendor.timeout_b = usecs_to_jiffies(timeout);\n\ttimeout = be32_to_cpu(timeout_cap->c);\n\tif (timeout)\n\t\tchip->vendor.timeout_c = usecs_to_jiffies(timeout);\n\ttimeout = be32_to_cpu(timeout_cap->d);\n\tif (timeout)\n\t\tchip->vendor.timeout_d = usecs_to_jiffies(timeout);\n\nduration:\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the durations\");\n\tif (rc)\n\t\treturn;\n\n\tif (be32_to_cpu(tpm_cmd.header.out.return_code)\n\t    != 3 * sizeof(u32))\n\t\treturn;\n\tduration_cap = &tpm_cmd.params.getcap_out.cap.duration;\n\tchip->vendor.duration[TPM_SHORT] =\n\t    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_short));\n\t/* The Broadcom BCM0102 chipset in a Dell Latitude D820 gets the above\n\t * value wrong and apparently reports msecs rather than usecs. So we\n\t * fix up the resulting too-small TPM_SHORT value to make things work.\n\t */\n\tif (chip->vendor.duration[TPM_SHORT] < (HZ/100))\n\t\tchip->vendor.duration[TPM_SHORT] = HZ;\n\n\tchip->vendor.duration[TPM_MEDIUM] =\n\t    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_medium));\n\tchip->vendor.duration[TPM_LONG] =\n\t    usecs_to_jiffies(be32_to_cpu(duration_cap->tpm_long));\n}\nEXPORT_SYMBOL_GPL(tpm_get_timeouts);\n\nvoid tpm_continue_selftest(struct tpm_chip *chip)\n{\n\tu8 data[] = {\n\t\t0, 193,\t\t\t/* TPM_TAG_RQU_COMMAND */\n\t\t0, 0, 0, 10,\t\t/* length */\n\t\t0, 0, 0, 83,\t\t/* TPM_ORD_GetCapability */\n\t};\n\n\ttpm_transmit(chip, data, sizeof(data));\n}\nEXPORT_SYMBOL_GPL(tpm_continue_selftest);\n\nssize_t tpm_show_enabled(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_PERM, &cap,\n\t\t\t \"attempting to determine the permanent enabled state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", !cap.perm_flags.disable);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_enabled);\n\nssize_t tpm_show_active(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_PERM, &cap,\n\t\t\t \"attempting to determine the permanent active state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", !cap.perm_flags.deactivated);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_active);\n\nssize_t tpm_show_owned(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_OWNER, &cap,\n\t\t\t \"attempting to determine the owner state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", cap.owned);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_owned);\n\nssize_t tpm_show_temp_deactivated(struct device * dev,\n\t\t\t\tstruct device_attribute * attr, char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_VOL, &cap,\n\t\t\t \"attempting to determine the temporary state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", cap.stclear_flags.deactivated);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_temp_deactivated);\n\n/*\n * tpm_chip_find_get - return tpm_chip for given chip number\n */\nstatic struct tpm_chip *tpm_chip_find_get(int chip_num)\n{\n\tstruct tpm_chip *pos, *chip = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (chip_num != TPM_ANY_NUM && chip_num != pos->dev_num)\n\t\t\tcontinue;\n\n\t\tif (try_module_get(pos->dev->driver->owner)) {\n\t\t\tchip = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn chip;\n}\n\n#define TPM_ORDINAL_PCRREAD cpu_to_be32(21)\n#define READ_PCR_RESULT_SIZE 30\nstatic struct tpm_input_header pcrread_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(14),\n\t.ordinal = TPM_ORDINAL_PCRREAD\n};\n\nint __tpm_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)\n{\n\tint rc;\n\tstruct tpm_cmd_t cmd;\n\n\tcmd.header.in = pcrread_header;\n\tcmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);\n\trc = transmit_cmd(chip, &cmd, READ_PCR_RESULT_SIZE,\n\t\t\t  \"attempting to read a pcr value\");\n\n\tif (rc == 0)\n\t\tmemcpy(res_buf, cmd.params.pcrread_out.pcr_result,\n\t\t       TPM_DIGEST_SIZE);\n\treturn rc;\n}\n\n/**\n * tpm_pcr_read - read a pcr value\n * @chip_num: \ttpm idx # or ANY\n * @pcr_idx:\tpcr idx to retrieve\n * @res_buf: \tTPM_PCR value\n * \t\tsize of res_buf is 20 bytes (or NULL if you don't care)\n *\n * The TPM driver should be built-in, but for whatever reason it\n * isn't, protect against the chip disappearing, by incrementing\n * the module usage count.\n */\nint tpm_pcr_read(u32 chip_num, int pcr_idx, u8 *res_buf)\n{\n\tstruct tpm_chip *chip;\n\tint rc;\n\n\tchip = tpm_chip_find_get(chip_num);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\trc = __tpm_pcr_read(chip, pcr_idx, res_buf);\n\ttpm_chip_put(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pcr_read);\n\n/**\n * tpm_pcr_extend - extend pcr value with hash\n * @chip_num: \ttpm idx # or AN&\n * @pcr_idx:\tpcr idx to extend\n * @hash: \thash value used to extend pcr value\n *\n * The TPM driver should be built-in, but for whatever reason it\n * isn't, protect against the chip disappearing, by incrementing\n * the module usage count.\n */\n#define TPM_ORD_PCR_EXTEND cpu_to_be32(20)\n#define EXTEND_PCR_RESULT_SIZE 34\nstatic struct tpm_input_header pcrextend_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(34),\n\t.ordinal = TPM_ORD_PCR_EXTEND\n};\n\nint tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)\n{\n\tstruct tpm_cmd_t cmd;\n\tint rc;\n\tstruct tpm_chip *chip;\n\n\tchip = tpm_chip_find_get(chip_num);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\tcmd.header.in = pcrextend_header;\n\tcmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);\n\tmemcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);\n\trc = transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\n\t\t\t  \"attempting extend a PCR value\");\n\n\ttpm_chip_put(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pcr_extend);\n\nint tpm_send(u32 chip_num, void *cmd, size_t buflen)\n{\n\tstruct tpm_chip *chip;\n\tint rc;\n\n\tchip = tpm_chip_find_get(chip_num);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\trc = transmit_cmd(chip, cmd, buflen, \"attempting tpm_cmd\");\n\n\ttpm_chip_put(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_send);\n\nssize_t tpm_show_pcrs(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tcap_t cap;\n\tu8 digest[TPM_DIGEST_SIZE];\n\tssize_t rc;\n\tint i, j, num_pcrs;\n\tchar *str = buf;\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_PCR, &cap,\n\t\t\t\"attempting to determine the number of PCRS\");\n\tif (rc)\n\t\treturn 0;\n\n\tnum_pcrs = be32_to_cpu(cap.num_pcrs);\n\tfor (i = 0; i < num_pcrs; i++) {\n\t\trc = __tpm_pcr_read(chip, i, digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tstr += sprintf(str, \"PCR-%02d: \", i);\n\t\tfor (j = 0; j < TPM_DIGEST_SIZE; j++)\n\t\t\tstr += sprintf(str, \"%02X \", digest[j]);\n\t\tstr += sprintf(str, \"\\n\");\n\t}\n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(tpm_show_pcrs);\n\n#define  READ_PUBEK_RESULT_SIZE 314\n#define TPM_ORD_READPUBEK cpu_to_be32(124)\nstruct tpm_input_header tpm_readpubek_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(30),\n\t.ordinal = TPM_ORD_READPUBEK\n};\n\nssize_t tpm_show_pubek(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tu8 *data;\n\tstruct tpm_cmd_t tpm_cmd;\n\tssize_t err;\n\tint i, rc;\n\tchar *str = buf;\n\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_cmd.header.in = tpm_readpubek_header;\n\terr = transmit_cmd(chip, &tpm_cmd, READ_PUBEK_RESULT_SIZE,\n\t\t\t\"attempting to read the PUBEK\");\n\tif (err)\n\t\tgoto out;\n\n\t/* \n\t   ignore header 10 bytes\n\t   algorithm 32 bits (1 == RSA )\n\t   encscheme 16 bits\n\t   sigscheme 16 bits\n\t   parameters (RSA 12->bytes: keybit, #primes, expbit)  \n\t   keylenbytes 32 bits\n\t   256 byte modulus\n\t   ignore checksum 20 bytes\n\t */\n\tdata = tpm_cmd.params.readpubek_out_buffer;\n\tstr +=\n\t    sprintf(str,\n\t\t    \"Algorithm: %02X %02X %02X %02X\\nEncscheme: %02X %02X\\n\"\n\t\t    \"Sigscheme: %02X %02X\\nParameters: %02X %02X %02X %02X\"\n\t\t    \" %02X %02X %02X %02X %02X %02X %02X %02X\\n\"\n\t\t    \"Modulus length: %d\\nModulus: \\n\",\n\t\t    data[10], data[11], data[12], data[13], data[14],\n\t\t    data[15], data[16], data[17], data[22], data[23],\n\t\t    data[24], data[25], data[26], data[27], data[28],\n\t\t    data[29], data[30], data[31], data[32], data[33],\n\t\t    be32_to_cpu(*((__be32 *) (data + 34))));\n\n\tfor (i = 0; i < 256; i++) {\n\t\tstr += sprintf(str, \"%02X \", data[i + 38]);\n\t\tif ((i + 1) % 16 == 0)\n\t\t\tstr += sprintf(str, \"\\n\");\n\t}\nout:\n\trc = str - buf;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_show_pubek);\n\n\nssize_t tpm_show_caps(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\tchar *str = buf;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_MANUFACTURER, &cap,\n\t\t\t\"attempting to determine the manufacturer\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str, \"Manufacturer: 0x%x\\n\",\n\t\t       be32_to_cpu(cap.manufacturer_id));\n\n\trc = tpm_getcap(dev, CAP_VERSION_1_1, &cap,\n\t\t        \"attempting to determine the 1.1 version\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str,\n\t\t       \"TCG version: %d.%d\\nFirmware version: %d.%d\\n\",\n\t\t       cap.tpm_version.Major, cap.tpm_version.Minor,\n\t\t       cap.tpm_version.revMajor, cap.tpm_version.revMinor);\n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(tpm_show_caps);\n\nssize_t tpm_show_caps_1_2(struct device * dev,\n\t\t\t  struct device_attribute * attr, char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\tchar *str = buf;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_MANUFACTURER, &cap,\n\t\t\t\"attempting to determine the manufacturer\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str, \"Manufacturer: 0x%x\\n\",\n\t\t       be32_to_cpu(cap.manufacturer_id));\n\trc = tpm_getcap(dev, CAP_VERSION_1_2, &cap,\n\t\t\t \"attempting to determine the 1.2 version\");\n\tif (rc)\n\t\treturn 0;\n\tstr += sprintf(str,\n\t\t       \"TCG version: %d.%d\\nFirmware version: %d.%d\\n\",\n\t\t       cap.tpm_version_1_2.Major, cap.tpm_version_1_2.Minor,\n\t\t       cap.tpm_version_1_2.revMajor,\n\t\t       cap.tpm_version_1_2.revMinor);\n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(tpm_show_caps_1_2);\n\nssize_t tpm_store_cancel(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tif (chip == NULL)\n\t\treturn 0;\n\n\tchip->vendor.cancel(chip);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(tpm_store_cancel);\n\n/*\n * Device file system interface to the TPM\n *\n * It's assured that the chip will be opened just once,\n * by the check of is_open variable, which is protected\n * by driver_lock.\n */\nint tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_open);\n\n/*\n * Called on file close\n */\nint tpm_release(struct inode *inode, struct file *file)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tfile->private_data = NULL;\n\tatomic_set(&chip->data_pending, 0);\n\tkfree(chip->data_buffer);\n\tclear_bit(0, &chip->is_open);\n\tput_device(chip->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_release);\n\nssize_t tpm_write(struct file *file, const char __user *buf,\n\t\t  size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tsize_t in_size = size, out_size;\n\n\t/* cannot perform a write until the read has cleared\n\t   either via tpm_read or a user_read_timer timeout */\n\twhile (atomic_read(&chip->data_pending) != 0)\n\t\tmsleep(TPM_TIMEOUT);\n\n\tmutex_lock(&chip->buffer_mutex);\n\n\tif (in_size > TPM_BUFSIZE)\n\t\tin_size = TPM_BUFSIZE;\n\n\tif (copy_from_user\n\t    (chip->data_buffer, (void __user *) buf, in_size)) {\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\t/* atomic tpm command send and result receive */\n\tout_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);\n\n\tatomic_set(&chip->data_pending, out_size);\n\tmutex_unlock(&chip->buffer_mutex);\n\n\t/* Set a timeout by which the reader must come claim the result */\n\tmod_timer(&chip->user_read_timer, jiffies + (60 * HZ));\n\n\treturn in_size;\n}\nEXPORT_SYMBOL_GPL(tpm_write);\n\nssize_t tpm_read(struct file *file, char __user *buf,\n\t\t size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tssize_t ret_size;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tret_size = atomic_read(&chip->data_pending);\n\tatomic_set(&chip->data_pending, 0);\n\tif (ret_size > 0) {\t/* relay data */\n\t\tif (size < ret_size)\n\t\t\tret_size = size;\n\n\t\tmutex_lock(&chip->buffer_mutex);\n\t\tif (copy_to_user(buf, chip->data_buffer, ret_size))\n\t\t\tret_size = -EFAULT;\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t}\n\n\treturn ret_size;\n}\nEXPORT_SYMBOL_GPL(tpm_read);\n\nvoid tpm_remove_hardware(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip == NULL) {\n\t\tdev_err(dev, \"No device data found\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock(&driver_lock);\n\tlist_del_rcu(&chip->list);\n\tspin_unlock(&driver_lock);\n\tsynchronize_rcu();\n\n\tmisc_deregister(&chip->vendor.miscdev);\n\tsysfs_remove_group(&dev->kobj, chip->vendor.attr_group);\n\ttpm_bios_log_teardown(chip->bios_dir);\n\n\t/* write it this way to be explicit (chip->dev == dev) */\n\tput_device(chip->dev);\n}\nEXPORT_SYMBOL_GPL(tpm_remove_hardware);\n\n#define TPM_ORD_SAVESTATE cpu_to_be32(152)\n#define SAVESTATE_RESULT_SIZE 10\n\nstatic struct tpm_input_header savestate_header = {\n\t.tag = TPM_TAG_RQU_COMMAND,\n\t.length = cpu_to_be32(10),\n\t.ordinal = TPM_ORD_SAVESTATE\n};\n\n/*\n * We are about to suspend. Save the TPM state\n * so that it can be restored.\n */\nint tpm_pm_suspend(struct device *dev, pm_message_t pm_state)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct tpm_cmd_t cmd;\n\tint rc;\n\n\tu8 dummy_hash[TPM_DIGEST_SIZE] = { 0 };\n\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\t/* for buggy tpm, flush pcrs with extend to selected dummy */\n\tif (tpm_suspend_pcr) {\n\t\tcmd.header.in = pcrextend_header;\n\t\tcmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);\n\t\tmemcpy(cmd.params.pcrextend_in.hash, dummy_hash,\n\t\t       TPM_DIGEST_SIZE);\n\t\trc = transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\n\t\t\t\t  \"extending dummy pcr before suspend\");\n\t}\n\n\t/* now do the actual savestate */\n\tcmd.header.in = savestate_header;\n\trc = transmit_cmd(chip, &cmd, SAVESTATE_RESULT_SIZE,\n\t\t\t  \"sending savestate before suspend\");\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pm_suspend);\n\n/*\n * Resume from a power safe. The BIOS already restored\n * the TPM state.\n */\nint tpm_pm_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_pm_resume);\n\n/* In case vendor provided release function, call it too.*/\n\nvoid tpm_dev_vendor_release(struct tpm_chip *chip)\n{\n\tif (chip->vendor.release)\n\t\tchip->vendor.release(chip->dev);\n\n\tclear_bit(chip->dev_num, dev_mask);\n\tkfree(chip->vendor.miscdev.name);\n}\nEXPORT_SYMBOL_GPL(tpm_dev_vendor_release);\n\n\n/*\n * Once all references to platform device are down to 0,\n * release all allocated structures.\n */\nvoid tpm_dev_release(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_dev_vendor_release(chip);\n\n\tchip->release(dev);\n\tkfree(chip);\n}\nEXPORT_SYMBOL_GPL(tpm_dev_release);\n\n/*\n * Called from tpm_<specific>.c probe function only for devices \n * the driver has determined it should claim.  Prior to calling\n * this function the specific probe function has called pci_enable_device\n * upon errant exit from this function specific probe function should call\n * pci_disable_device\n */\nstruct tpm_chip *tpm_register_hardware(struct device *dev,\n\t\t\t\t\tconst struct tpm_vendor_specific *entry)\n{\n#define DEVNAME_SIZE 7\n\n\tchar *devname;\n\tstruct tpm_chip *chip;\n\n\t/* Driver specific per-device data */\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tdevname = kmalloc(DEVNAME_SIZE, GFP_KERNEL);\n\n\tif (chip == NULL || devname == NULL)\n\t\tgoto out_free;\n\n\tmutex_init(&chip->buffer_mutex);\n\tmutex_init(&chip->tpm_mutex);\n\tINIT_LIST_HEAD(&chip->list);\n\n\tINIT_WORK(&chip->work, timeout_work);\n\n\tsetup_timer(&chip->user_read_timer, user_reader_timeout,\n\t\t\t(unsigned long)chip);\n\n\tmemcpy(&chip->vendor, entry, sizeof(struct tpm_vendor_specific));\n\n\tchip->dev_num = find_first_zero_bit(dev_mask, TPM_NUM_DEVICES);\n\n\tif (chip->dev_num >= TPM_NUM_DEVICES) {\n\t\tdev_err(dev, \"No available tpm device numbers\\n\");\n\t\tgoto out_free;\n\t} else if (chip->dev_num == 0)\n\t\tchip->vendor.miscdev.minor = TPM_MINOR;\n\telse\n\t\tchip->vendor.miscdev.minor = MISC_DYNAMIC_MINOR;\n\n\tset_bit(chip->dev_num, dev_mask);\n\n\tscnprintf(devname, DEVNAME_SIZE, \"%s%d\", \"tpm\", chip->dev_num);\n\tchip->vendor.miscdev.name = devname;\n\n\tchip->vendor.miscdev.parent = dev;\n\tchip->dev = get_device(dev);\n\tchip->release = dev->release;\n\tdev->release = tpm_dev_release;\n\tdev_set_drvdata(dev, chip);\n\n\tif (misc_register(&chip->vendor.miscdev)) {\n\t\tdev_err(chip->dev,\n\t\t\t\"unable to misc_register %s, minor %d\\n\",\n\t\t\tchip->vendor.miscdev.name,\n\t\t\tchip->vendor.miscdev.minor);\n\t\tput_device(chip->dev);\n\t\treturn NULL;\n\t}\n\n\tif (sysfs_create_group(&dev->kobj, chip->vendor.attr_group)) {\n\t\tmisc_deregister(&chip->vendor.miscdev);\n\t\tput_device(chip->dev);\n\n\t\treturn NULL;\n\t}\n\n\tchip->bios_dir = tpm_bios_log_setup(devname);\n\n\t/* Make chip available */\n\tspin_lock(&driver_lock);\n\tlist_add_rcu(&chip->list, &tpm_chip_list);\n\tspin_unlock(&driver_lock);\n\n\treturn chip;\n\nout_free:\n\tkfree(chip);\n\tkfree(devname);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tpm_register_hardware);\n\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/char/tpm/tpm.c"], "buggy_code_start_loc": [983], "buggy_code_end_loc": [984], "fixing_code_start_loc": [983], "fixing_code_end_loc": [984], "type": "CWE-200", "message": "The tpm_open function in drivers/char/tpm/tpm.c in the Linux kernel before 2.6.39 does not initialize a certain buffer, which allows local users to obtain potentially sensitive information from kernel memory via unspecified vectors.", "other": {"cve": {"id": "CVE-2011-1160", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.147", "lastModified": "2023-02-13T04:29:23.597", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tpm_open function in drivers/char/tpm/tpm.c in the Linux kernel before 2.6.39 does not initialize a certain buffer, which allows local users to obtain potentially sensitive information from kernel memory via unspecified vectors."}, {"lang": "es", "value": "La funci\u00f3n de tpm_open en drivers/char/tpm/tpm.c en el kernel de Linux anteriores a v2.6.39 no se inicializa un b\u00fafer concreto, lo que permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel a trav\u00e9s de vectores no especificados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:*:*:*:*:*:*:*", "matchCriteriaId": "7462DB6D-E0A6-4DBB-8E21-66B875184FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DDCB342-4F5F-4BF1-9624-882BBC57330D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc2:*:*:*:*:*:*", "matchCriteriaId": "C3AB4113-BF83-4587-8A85-0E4FECEE7D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc3:*:*:*:*:*:*", "matchCriteriaId": "4B57F5AD-A697-4090-89B9-81BC12993A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc4:*:*:*:*:*:*", "matchCriteriaId": "CA141BCB-A705-4DF5-9EED-746B62C86111"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc5:*:*:*:*:*:*", "matchCriteriaId": "E9ECE134-58A3-4B9D-B9B3-F836C0EDD64C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc6:*:*:*:*:*:*", "matchCriteriaId": "56186720-6B4C-4D71-85C5-7EAC5C5D84A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc7:*:*:*:*:*:*", "matchCriteriaId": "9BBB4630-CBED-43B9-B203-BE65BBF011AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD375A78-63D7-441A-9FB0-7BC878AB4EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5BEFFDD-02BB-4A05-8372-891DBDB9AC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.2:*:*:*:*:*:*:*", "matchCriteriaId": "766E193D-819C-42EA-8411-AE0013AC15FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.3:*:*:*:*:*:*:*", "matchCriteriaId": "3B39B6AF-6A83-48C2-BED2-79228F8513A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.4:*:*:*:*:*:*:*", "matchCriteriaId": "CD8A68D1-DFE9-4ADB-9FB8-4D69AB4CAFF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.5:*:*:*:*:*:*:*", "matchCriteriaId": "0D6EF951-AF15-4C30-A3A5-3392AA61813C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.6:*:*:*:*:*:*:*", "matchCriteriaId": "15154FA0-65DC-4855-AC70-3ACF92313F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.7:*:*:*:*:*:*:*", "matchCriteriaId": "F4B3A9F4-A61F-4919-A173-3E459F0C5AF8"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=1309d7afbed112f0e8e90be9af975550caa0076b", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/03/15/13", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=684671", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/1309d7afbed112f0e8e90be9af975550caa0076b", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1309d7afbed112f0e8e90be9af975550caa0076b"}}