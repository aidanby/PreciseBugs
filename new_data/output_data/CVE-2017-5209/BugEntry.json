{"buggy_code": ["/*\n * base64.c\n * base64 encode/decode implementation\n *\n * Copyright (c) 2011 Nikias Bassen, All Rights Reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include <string.h>\n#include \"base64.h\"\n\nstatic const char base64_str[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nstatic const char base64_pad = '=';\n\nstatic const signed char base64_table[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,\n\t-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n\t-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nsize_t base64encode(char *outbuf, const unsigned char *buf, size_t size)\n{\n\tif (!outbuf || !buf || (size <= 0)) {\n\t\treturn 0;\n\t}\n\n\tsize_t n = 0;\n\tsize_t m = 0;\n\tunsigned char input[3];\n\tunsigned int output[4];\n\twhile (n < size) {\n\t\tinput[0] = buf[n];\n\t\tinput[1] = (n+1 < size) ? buf[n+1] : 0;\n\t\tinput[2] = (n+2 < size) ? buf[n+2] : 0;\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 3) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 15) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 63;\n\t\toutbuf[m++] = base64_str[(int)output[0]];\n\t\toutbuf[m++] = base64_str[(int)output[1]];\n\t\toutbuf[m++] = (n+1 < size) ? base64_str[(int)output[2]] : base64_pad;\n\t\toutbuf[m++] = (n+2 < size) ? base64_str[(int)output[3]] : base64_pad;\n\t\tn+=3;\n\t}\n\toutbuf[m] = 0; // 0-termination!\n\treturn m;\n}\n\nstatic int base64decode_block(unsigned char *target, const char *data, size_t data_size)\n{\n\tint w1,w2,w3,w4;\n\tint i;\n\tsize_t n;\n\n\tif (!data || (data_size <= 0)) {\n\t\treturn 0;\n\t}\n\n\tn = 0;\n\ti = 0;\n\twhile (n < data_size-3) {\n\t\tw1 = base64_table[(int)data[n]];\n\t\tw2 = base64_table[(int)data[n+1]];\n\t\tw3 = base64_table[(int)data[n+2]];\n\t\tw4 = base64_table[(int)data[n+3]];\n\n\t\tif (w2 >= 0) {\n\t\t\ttarget[i++] = (char)((w1*4 + (w2 >> 4)) & 255);\n\t\t}\n\t\tif (w3 >= 0) {\n\t\t\ttarget[i++] = (char)((w2*16 + (w3 >> 2)) & 255);\n\t\t}\n\t\tif (w4 >= 0) {\n\t\t\ttarget[i++] = (char)((w3*64 + w4) & 255);\n\t\t}\n\t\tn+=4;\n\t}\n\treturn i;\n}\n\nunsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}\n"], "fixing_code": ["/*\n * base64.c\n * base64 encode/decode implementation\n *\n * Copyright (c) 2011 Nikias Bassen, All Rights Reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include <string.h>\n#include \"base64.h\"\n\nstatic const char base64_str[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nstatic const char base64_pad = '=';\n\nstatic const signed char base64_table[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,\n\t-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n\t-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nsize_t base64encode(char *outbuf, const unsigned char *buf, size_t size)\n{\n\tif (!outbuf || !buf || (size <= 0)) {\n\t\treturn 0;\n\t}\n\n\tsize_t n = 0;\n\tsize_t m = 0;\n\tunsigned char input[3];\n\tunsigned int output[4];\n\twhile (n < size) {\n\t\tinput[0] = buf[n];\n\t\tinput[1] = (n+1 < size) ? buf[n+1] : 0;\n\t\tinput[2] = (n+2 < size) ? buf[n+2] : 0;\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 3) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 15) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 63;\n\t\toutbuf[m++] = base64_str[(int)output[0]];\n\t\toutbuf[m++] = base64_str[(int)output[1]];\n\t\toutbuf[m++] = (n+1 < size) ? base64_str[(int)output[2]] : base64_pad;\n\t\toutbuf[m++] = (n+2 < size) ? base64_str[(int)output[3]] : base64_pad;\n\t\tn+=3;\n\t}\n\toutbuf[m] = 0; // 0-termination!\n\treturn m;\n}\n\nunsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tint wv, w1, w2, w3, w4;\n\tint tmpval[4];\n\tint tmpcnt = 0;\n\n\tdo {\n\t\twhile (ptr < buf+len && (*ptr == ' ' || *ptr == '\\t' || *ptr == '\\n' || *ptr == '\\r')) {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((wv = base64_table[(int)(unsigned char)*ptr++]) == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\ttmpval[tmpcnt++] = wv;\n\t\tif (tmpcnt == 4) {\n\t\t\ttmpcnt = 0;\n\t\t\tw1 = tmpval[0];\n\t\t\tw2 = tmpval[1];\n\t\t\tw3 = tmpval[2];\n\t\t\tw4 = tmpval[3];\n\n\t\t\tif (w2 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w1 << 2) + (w2 >> 4)) & 0xFF);\n\t\t\t}\n\t\t\tif (w3 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w2 << 4) + (w3 >> 2)) & 0xFF);\n\t\t\t}\n\t\t\tif (w4 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w3 << 6) + w4) & 0xFF);\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}\n"], "filenames": ["src/base64.c"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [127], "fixing_code_start_loc": [31], "fixing_code_end_loc": [113], "type": "CWE-125", "message": "The base64decode function in base64.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via split encoded Apple Property List data.", "other": {"cve": {"id": "CVE-2017-5209", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-11T16:59:00.377", "lastModified": "2020-04-02T10:15:14.157", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The base64decode function in base64.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via split encoded Apple Property List data."}, {"lang": "es", "value": "La funci\u00f3n base64decode en base64.c en libimobiledevice libplist hasta la versi\u00f3n 1.12 permite a atacantes obtener informaci\u00f3n sensible de la memoria de proceso o provocar una denegaci\u00f3n de servicio (sobrelectura del b\u00fafer) a trav\u00e9s de datos split codificados Apple Property List."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libimobiledevice:libplist:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.12", "matchCriteriaId": "4201391B-6535-4AE4-87AD-4112C3F2B48A"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95385", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/libimobiledevice/libplist/commit/3a55ddd3c4c11ce75a86afbefd085d8d397ff957", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00002.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libimobiledevice/libplist/commit/3a55ddd3c4c11ce75a86afbefd085d8d397ff957"}}