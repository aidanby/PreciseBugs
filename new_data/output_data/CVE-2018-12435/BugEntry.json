{"buggy_code": ["\n.. highlight:: none\n\nSecurity Advisories\n========================================\n\nIf you think you have found a security bug in Botan please contact\nJack Lloyd (jack@randombit.net). If you would like to encrypt your\nmail please use::\n\n  pub   rsa3072/57123B60 2015-03-23\n        Key fingerprint = 4E60 C735 51AF 2188 DF0A  5A62 78E9 8043 5712 3B60\n        uid         Jack Lloyd <jack@randombit.net>\n\nThis key can be found in the file ``doc/pgpkey.txt`` or online at\nhttps://keybase.io/jacklloyd and on most PGP keyservers.\n\n2018\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2018-04-10 (CVE-2018-9860): Memory overread in TLS CBC decryption\n\n  An off by one error in TLS CBC decryption meant that for a particular\n  malformed ciphertext, the receiver would miscompute a length field and HMAC\n  exactly 64K bytes of data following the record buffer as if it was part of the\n  message. This cannot be used to leak information since the MAC comparison will\n  subsequently fail and the connection will be closed. However it might be used\n  for denial of service. Found by OSS-Fuzz.\n\n  Bug introduced in 1.11.32, fixed in 2.6.0\n\n* 2018-03-29 (CVE-2018-9127): Invalid wildcard match\n\n  RFC 6125 wildcard matching was incorrectly implemented, so that a wildcard\n  certificate such as ``b*.domain.com`` would match any hosts ``*b*.domain.com``\n  instead of just server names beginning with ``b``. The host and certificate\n  would still have to be in the same domain name. Reported by Fabian Wei\u00dfberg of\n  Rohde and Schwarz Cybersecurity.\n\n  Bug introduced in 2.2.0, fixed in 2.5.0\n\n2017\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2017-10-02 (CVE-2017-14737): Potential side channel using cache information\n\n  In the Montgomery exponentiation code, a table of precomputed values\n  is used. An attacker able to analyze which cache lines were accessed\n  (perhaps via an active attack such as Prime+Probe) could recover\n  information about the exponent. Identified in \"CacheD: Identifying\n  Cache-Based Timing Channels in Production Software\" by Wang, Wang,\n  Liu, Zhang, and Wu (Usenix Security 2017).\n\n  Fixed in 1.10.17 and 2.3.0, all prior versions affected.\n\n* 2017-07-16: Failure to fully zeroize memory before free\n\n  The secure_allocator type attempts to zeroize memory before freeing it. Due to\n  a error sometimes only a portion of the memory would be zeroed, because of a\n  confusion between the number of elements vs the number of bytes that those\n  elements use. So byte vectors would always be fully zeroed (since the two\n  notions result in the same value), but for example with an array of 32-bit\n  integers, only the first 1/4 of the elements would be zeroed before being\n  deallocated. This may result in information leakage, if an attacker can access\n  memory on the heap. Reported by Roman Pozlevich.\n\n  Bug introduced in 1.11.10, fixed in 2.2.0\n\n* 2017-04-04 (CVE-2017-2801): Incorrect comparison in X.509 DN strings\n\n  Botan's implementation of X.509 name comparisons had a flaw which\n  could result in an out of bound memory read while processing a\n  specially formed DN. This could potentially be exploited for\n  information disclosure or denial of service, or result in incorrect\n  validation results. Found independently by Aleksandar Nikolic of\n  Cisco Talos, and OSS-Fuzz automated fuzzing infrastructure.\n\n  Bug introduced in 1.6.0 or earlier, fixed in 2.1.0 and 1.10.16\n\n* 2017-03-23 (CVE-2017-7252): Incorrect bcrypt computation\n\n  Botan's implementation of bcrypt password hashing scheme truncated long\n  passwords at 56 characters, instead of at bcrypt's standard 72 characters\n  limit. Passwords with lengths between these two bounds could be cracked more\n  easily than should be the case due to the final password bytes being ignored.\n  Found and reported by Solar Designer.\n\n  Bug introduced in 1.11.0, fixed in 2.1.0.\n\n2016\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2016-11-27 (CVE-2016-9132) Integer overflow in BER decoder\n\n  While decoding BER length fields, an integer overflow could occur. This could\n  occur while parsing untrusted inputs such as X.509 certificates. The overflow\n  does not seem to lead to any obviously exploitable condition, but exploitation\n  cannot be positively ruled out. Only 32-bit platforms are likely affected; to\n  cause an overflow on 64-bit the parsed data would have to be many gigabytes.\n  Bug found by Falko Strenzke, cryptosource GmbH.\n\n  Fixed in 1.10.14 and 1.11.34, all prior versions affected.\n\n* 2016-10-26 (CVE-2016-8871) OAEP side channel\n\n  A side channel in OAEP decoding could be used to distinguish RSA ciphertexts\n  that did or did not have a leading 0 byte. For an attacker capable of\n  precisely measuring the time taken for OAEP decoding, this could be used as an\n  oracle allowing decryption of arbitrary RSA ciphertexts. Remote exploitation\n  seems difficult as OAEP decoding is always paired with RSA decryption, which\n  takes substantially more (and variable) time, and so will tend to mask the\n  timing channel. This attack does seems well within reach of a local attacker\n  capable of a cache or branch predictor based side channel attack. Finding,\n  analysis, and patch by Juraj Somorovsky.\n\n  Introduced in 1.11.29, fixed in 1.11.33\n\n* 2016-08-30 (CVE-2016-6878) Undefined behavior in Curve25519\n\n  On systems without a native 128-bit integer type, the Curve25519 code invoked\n  undefined behavior. This was known to produce incorrect results on 32-bit ARM\n  when compiled by Clang.\n\n  Introduced in 1.11.12, fixed in 1.11.31\n\n* 2016-08-30 (CVE-2016-6879) Bad result from X509_Certificate::allowed_usage\n\n  If allowed_usage was called with more than one Key_Usage set in the enum\n  value, the function would return true if *any* of the allowed usages were set,\n  instead of if *all* of the allowed usages are set.  This could be used to\n  bypass an application key usage check. Credit to Daniel Neus of Rohde &\n  Schwarz Cybersecurity for finding this issue.\n\n  Introduced in 1.11.0, fixed in 1.11.31\n\n* 2016-03-17 (CVE-2016-2849): ECDSA side channel\n\n  ECDSA (and DSA) signature algorithms perform a modular inverse on the\n  signature nonce `k`.  The modular inverse algorithm used had input dependent\n  loops, and it is possible a side channel attack could recover sufficient\n  information about the nonce to eventually recover the ECDSA secret key. Found\n  by Sean Devlin.\n\n  Introduced in 1.7.15, fixed in 1.10.13 and 1.11.29\n\n* 2016-03-17 (CVE-2016-2850): Failure to enforce TLS policy\n\n  TLS v1.2 allows negotiating which signature algorithms and hash functions each\n  side is willing to accept. However received signatures were not actually\n  checked against the specified policy.  This had the effect of allowing a\n  server to use an MD5 or SHA-1 signature, even though the default policy\n  prohibits it. The same issue affected client cert authentication.\n\n  The TLS client also failed to verify that the ECC curve the server chose to\n  use was one which was acceptable by the client policy.\n\n  Introduced in 1.11.0, fixed in 1.11.29\n\n* 2016-02-01 (CVE-2016-2196): Overwrite in P-521 reduction\n\n  The P-521 reduction function would overwrite zero to one word\n  following the allocated block. This could potentially result\n  in remote code execution or a crash. Found with AFL\n\n  Introduced in 1.11.10, fixed in 1.11.27\n\n* 2016-02-01 (CVE-2016-2195): Heap overflow on invalid ECC point\n\n  The PointGFp constructor did not check that the affine coordinate\n  arguments were less than the prime, but then in curve multiplication\n  assumed that both arguments if multiplied would fit into an integer\n  twice the size of the prime.\n\n  The bigint_mul and bigint_sqr functions received the size of the\n  output buffer, but only used it to dispatch to a faster algorithm in\n  cases where there was sufficient output space to call an unrolled\n  multiplication function.\n\n  The result is a heap overflow accessible via ECC point decoding,\n  which accepted untrusted inputs. This is likely exploitable for\n  remote code execution.\n\n  On systems which use the mlock pool allocator, it would allow an\n  attacker to overwrite memory held in secure_vector objects. After\n  this point the write will hit the guard page at the end of the\n  mmap'ed region so it probably could not be used for code execution\n  directly, but would allow overwriting adjacent key material.\n\n  Found by Alex Gaynor fuzzing with AFL\n\n  Introduced in 1.9.18, fixed in 1.11.27 and 1.10.11\n\n* 2016-02-01 (CVE-2016-2194): Infinite loop in modular square root algorithm\n\n  The ressol function implements the Tonelli-Shanks algorithm for\n  finding square roots could be sent into a nearly infinite loop due\n  to a misplaced conditional check. This could occur if a composite\n  modulus is provided, as this algorithm is only defined for primes.\n  This function is exposed to attacker controlled input via the OS2ECP\n  function during ECC point decompression. Found by AFL\n\n  Introduced in 1.7.15, fixed in 1.11.27 and 1.10.11\n\n2015\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2015-11-04: TLS certificate authentication bypass\n\n  When the bugs affecting X.509 path validation were fixed in 1.11.22, a check\n  in Credentials_Manager::verify_certificate_chain was accidentally removed\n  which caused path validation failures not to be signaled to the TLS layer.  So\n  for affected versions, certificate authentication in TLS is bypassed. As a\n  workaround, applications can override the call and implement the correct\n  check. Reported by Florent Le Coz in GH #324\n\n  Introduced in 1.11.22, fixed in 1.11.24\n\n* 2015-10-26 (CVE-2015-7824): Padding oracle attack on TLS\n\n  A padding oracle attack was possible against TLS CBC ciphersuites because if a\n  certain length check on the packet fields failed, a different alert type than\n  one used for message authentication failure would be returned to the sender.\n  This check triggering would leak information about the value of the padding\n  bytes and could be used to perform iterative decryption.\n\n  As with most such oracle attacks, the danger depends on the underlying\n  protocol - HTTP servers are particularly vulnerable. The current analysis\n  suggests that to exploit it an attacker would first have to guess several\n  bytes of plaintext, but again this is quite possible in many situations\n  including HTTP.\n\n  Found in a review by Sirrix AG and 3curity GmbH.\n\n  Introduced in 1.11.0, fixed in 1.11.22\n\n* 2015-10-26 (CVE-2015-7825): Infinite loop during certificate path validation\n\n  When evaluating a certificate path, if a loop in the certificate chain\n  was encountered (for instance where C1 certifies C2, which certifies C1)\n  an infinite loop would occur eventually resulting in memory exhaustion.\n  Found in a review by Sirrix AG and 3curity GmbH.\n\n  Introduced in 1.11.6, fixed in 1.11.22\n\n* 2015-10-26 (CVE-2015-7826): Acceptance of invalid certificate names\n\n  RFC 6125 specifies how to match a X.509v3 certificate against a DNS name\n  for application usage.\n\n  Otherwise valid certificates using wildcards would be accepted as matching\n  certain hostnames that should they should not according to RFC 6125. For\n  example a certificate issued for ``*.example.com`` should match\n  ``foo.example.com`` but not ``example.com`` or ``bar.foo.example.com``. Previously\n  Botan would accept such a certificate as also valid for ``bar.foo.example.com``.\n\n  RFC 6125 also requires that when matching a X.509 certificate against a DNS\n  name, the CN entry is only compared if no subjectAlternativeName entry is\n  available. Previously X509_Certificate::matches_dns_name would always check\n  both names.\n\n  Found in a review by Sirrix AG and 3curity GmbH.\n\n  Introduced in 1.11.0, fixed in 1.11.22\n\n* 2015-10-26 (CVE-2015-7827): PKCS #1 v1.5 decoding was not constant time\n\n  During RSA decryption, how long decoding of PKCS #1 v1.5 padding took was\n  input dependent. If these differences could be measured by an attacker, it\n  could be used to mount a Bleichenbacher million-message attack. PKCS #1 v1.5\n  decoding has been rewritten to use a sequence of operations which do not\n  contain any input-dependent indexes or jumps. Notations for checking constant\n  time blocks with ctgrind (https://github.com/agl/ctgrind) were added to PKCS\n  #1 decoding among other areas. Found in a review by Sirrix AG and 3curity GmbH.\n\n  Fixed in 1.11.22 and 1.10.13. Affected all previous versions.\n\n* 2015-08-03 (CVE-2015-5726): Crash in BER decoder\n\n  The BER decoder would crash due to reading from offset 0 of an empty vector if\n  it encountered a BIT STRING which did not contain any data at all. This can be\n  used to easily crash applications reading untrusted ASN.1 data, but does not\n  seem exploitable for code execution. Found with afl.\n\n  Fixed in 1.11.19 and 1.10.10, affected all previous versions of 1.10 and 1.11\n\n* 2015-08-03 (CVE-2015-5727): Excess memory allocation in BER decoder\n\n  The BER decoder would allocate a fairly arbitrary amount of memory in a length\n  field, even if there was no chance the read request would succeed.  This might\n  cause the process to run out of memory or invoke the OOM killer. Found with afl.\n\n  Fixed in 1.11.19 and 1.10.10, affected all previous versions of 1.10 and 1.11\n\n2014\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2014-04-10 (CVE-2014-9742): Insufficient randomness in Miller-Rabin primality check\n\n  A bug in the Miller-Rabin primality test resulted in only a single random base\n  being used instead of a sequence of such bases. This increased the probability\n  that a non-prime would be accepted by is_prime or that a randomly generated\n  prime might actually be composite.  The probability of a random 1024 bit\n  number being incorrectly classed as prime with a single base is around 2^-40.\n  Reported by Jeff Marrison.\n\n  Introduced in 1.8.3, fixed in 1.10.8 and 1.11.9\n", "/*\n* DSA\n* (C) 1999-2010,2014,2016 Jack Lloyd\n* (C) 2016 Ren\u00e9 Korthaus\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#include <botan/dsa.h>\n#include <botan/keypair.h>\n#include <botan/reducer.h>\n#include <botan/rng.h>\n#include <botan/internal/pk_ops_impl.h>\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n  #include <botan/emsa.h>\n  #include <botan/rfc6979.h>\n#endif\n\nnamespace Botan {\n\n/*\n* DSA_PublicKey Constructor\n*/\nDSA_PublicKey::DSA_PublicKey(const DL_Group& grp, const BigInt& y1)\n   {\n   m_group = grp;\n   m_y = y1;\n   }\n\n/*\n* Create a DSA private key\n*/\nDSA_PrivateKey::DSA_PrivateKey(RandomNumberGenerator& rng,\n                               const DL_Group& grp,\n                               const BigInt& x_arg)\n   {\n   m_group = grp;\n\n   if(x_arg == 0)\n      m_x = BigInt::random_integer(rng, 2, group_q());\n   else\n      m_x = x_arg;\n\n   m_y = m_group.power_g_p(m_x);\n   }\n\nDSA_PrivateKey::DSA_PrivateKey(const AlgorithmIdentifier& alg_id,\n                               const secure_vector<uint8_t>& key_bits) :\n   DL_Scheme_PrivateKey(alg_id, key_bits, DL_Group::ANSI_X9_57)\n   {\n   m_y = m_group.power_g_p(m_x);\n   }\n\n/*\n* Check Private DSA Parameters\n*/\nbool DSA_PrivateKey::check_key(RandomNumberGenerator& rng, bool strong) const\n   {\n   if(!DL_Scheme_PrivateKey::check_key(rng, strong) || m_x >= group_q())\n      return false;\n\n   if(!strong)\n      return true;\n\n   return KeyPair::signature_consistency_check(rng, *this, \"EMSA1(SHA-256)\");\n   }\n\nnamespace {\n\n/**\n* Object that can create a DSA signature\n*/\nclass DSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n   {\n   public:\n      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }\n\n      size_t max_input_bits() const override { return m_group.get_q().bits(); }\n\n      secure_vector<uint8_t> raw_sign(const uint8_t msg[], size_t msg_len,\n                                   RandomNumberGenerator& rng) override;\n   private:\n      const DL_Group m_group;\n      const BigInt& m_x;\n      Modular_Reducer m_mod_q;\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n      std::string m_rfc6979_hash;\n#endif\n   };\n\nsecure_vector<uint8_t>\nDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt i(msg, msg_len, q.bits());\n\n   while(i >= q)\n      i -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }\n\n/**\n* Object that can verify a DSA signature\n*/\nclass DSA_Verification_Operation final : public PK_Ops::Verification_with_EMSA\n   {\n   public:\n      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}\n\n      size_t max_input_bits() const override { return m_group.get_q().bits(); }\n\n      bool with_recovery() const override { return false; }\n\n      bool verify(const uint8_t msg[], size_t msg_len,\n                  const uint8_t sig[], size_t sig_len) override;\n   private:\n      const DL_Group m_group;\n      const BigInt& m_y;\n\n      Modular_Reducer m_mod_q;\n   };\n\nbool DSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                        const uint8_t sig[], size_t sig_len)\n   {\n   const BigInt& q = m_group.get_q();\n   const size_t q_bytes = q.bytes();\n\n   if(sig_len != 2*q_bytes || msg_len > q_bytes)\n      return false;\n\n   BigInt r(sig, q_bytes);\n   BigInt s(sig + q_bytes, q_bytes);\n   BigInt i(msg, msg_len, q.bits());\n\n   if(r <= 0 || r >= q || s <= 0 || s >= q)\n      return false;\n\n   s = inverse_mod(s, q);\n\n   const BigInt sr = m_mod_q.multiply(s, r);\n   const BigInt si = m_mod_q.multiply(s, i);\n\n   s = m_group.multi_exponentiate(si, m_y, sr);\n\n   return (m_mod_q.reduce(s) == r);\n   }\n\n}\n\nstd::unique_ptr<PK_Ops::Verification>\nDSA_PublicKey::create_verification_op(const std::string& params,\n                                      const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Verification>(new DSA_Verification_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\nstd::unique_ptr<PK_Ops::Signature>\nDSA_PrivateKey::create_signature_op(RandomNumberGenerator& /*rng*/,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\n}\n", "/*\n* ECC Domain Parameters\n*\n* (C) 2007 Falko Strenzke, FlexSecure GmbH\n* (C) 2008,2018 Jack Lloyd\n* (C) 2018 Tobias Niemann\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#include <botan/ec_group.h>\n#include <botan/internal/point_mul.h>\n#include <botan/ber_dec.h>\n#include <botan/der_enc.h>\n#include <botan/oids.h>\n#include <botan/pem.h>\n#include <botan/reducer.h>\n#include <botan/mutex.h>\n#include <vector>\n\nnamespace Botan {\n\nclass EC_Group_Data final\n   {\n   public:\n\n      EC_Group_Data(const BigInt& p,\n                    const BigInt& a,\n                    const BigInt& b,\n                    const BigInt& g_x,\n                    const BigInt& g_y,\n                    const BigInt& order,\n                    const BigInt& cofactor,\n                    const OID& oid) :\n         m_curve(p, a, b),\n         m_base_point(m_curve, g_x, g_y),\n         m_g_x(g_x),\n         m_g_y(g_y),\n         m_order(order),\n         m_cofactor(cofactor),\n         m_mod_order(order),\n         m_base_mult(m_base_point, m_mod_order),\n         m_oid(oid),\n         m_p_bits(p.bits()),\n         m_order_bits(order.bits()),\n         m_a_is_minus_3(a == p - 3),\n         m_a_is_zero(a.is_zero())\n         {\n         }\n\n      bool match(const BigInt& p, const BigInt& a, const BigInt& b,\n                 const BigInt& g_x, const BigInt& g_y,\n                 const BigInt& order, const BigInt& cofactor) const\n         {\n         return (this->p() == p &&\n                 this->a() == a &&\n                 this->b() == b &&\n                 this->order() == order &&\n                 this->cofactor() == cofactor &&\n                 this->g_x() == g_x &&\n                 this->g_y() == g_y);\n         }\n\n      const OID& oid() const { return m_oid; }\n      const BigInt& p() const { return m_curve.get_p(); }\n      const BigInt& a() const { return m_curve.get_a(); }\n      const BigInt& b() const { return m_curve.get_b(); }\n      const BigInt& order() const { return m_order; }\n      const BigInt& cofactor() const { return m_cofactor; }\n      const BigInt& g_x() const { return m_g_x; }\n      const BigInt& g_y() const { return m_g_y; }\n\n      size_t p_bits() const { return m_p_bits; }\n      size_t p_bytes() const { return (m_p_bits + 7) / 8; }\n\n      size_t order_bits() const { return m_order_bits; }\n      size_t order_bytes() const { return (m_order_bits + 7) / 8; }\n\n      const CurveGFp& curve() const { return m_curve; }\n      const PointGFp& base_point() const { return m_base_point; }\n\n      bool a_is_minus_3() const { return m_a_is_minus_3; }\n      bool a_is_zero() const { return m_a_is_zero; }\n\n      BigInt mod_order(const BigInt& x) const { return m_mod_order.reduce(x); }\n\n      BigInt multiply_mod_order(const BigInt& x, const BigInt& y) const\n         {\n         return m_mod_order.multiply(x, y);\n         }\n\n      BigInt inverse_mod_order(const BigInt& x) const\n         {\n         return inverse_mod(x, m_order);\n         }\n\n      PointGFp blinded_base_point_multiply(const BigInt& k,\n                                           RandomNumberGenerator& rng,\n                                           std::vector<BigInt>& ws) const\n         {\n         return m_base_mult.mul(k, rng, m_order, ws);\n         }\n\n   private:\n      CurveGFp m_curve;\n      PointGFp m_base_point;\n\n      BigInt m_g_x;\n      BigInt m_g_y;\n      BigInt m_order;\n      BigInt m_cofactor;\n      Modular_Reducer m_mod_order;\n      PointGFp_Base_Point_Precompute m_base_mult;\n      OID m_oid;\n      size_t m_p_bits;\n      size_t m_order_bits;\n      bool m_a_is_minus_3;\n      bool m_a_is_zero;\n   };\n\nclass EC_Group_Data_Map final\n   {\n   public:\n      EC_Group_Data_Map() {}\n\n      size_t clear()\n         {\n         lock_guard_type<mutex_type> lock(m_mutex);\n         size_t count = m_registered_curves.size();\n         m_registered_curves.clear();\n         return count;\n         }\n\n      std::shared_ptr<EC_Group_Data> lookup(const OID& oid)\n         {\n         lock_guard_type<mutex_type> lock(m_mutex);\n\n         for(auto i : m_registered_curves)\n            {\n            if(i->oid() == oid)\n               return i;\n            }\n\n         // Not found, check hardcoded data\n         std::shared_ptr<EC_Group_Data> data = EC_Group::EC_group_info(oid);\n\n         if(data)\n            {\n            m_registered_curves.push_back(data);\n            return data;\n            }\n\n         // Nope, unknown curve\n         return std::shared_ptr<EC_Group_Data>();\n         }\n\n      std::shared_ptr<EC_Group_Data> lookup_or_create(const BigInt& p,\n                                                      const BigInt& a,\n                                                      const BigInt& b,\n                                                      const BigInt& g_x,\n                                                      const BigInt& g_y,\n                                                      const BigInt& order,\n                                                      const BigInt& cofactor,\n                                                      const OID& oid)\n         {\n         lock_guard_type<mutex_type> lock(m_mutex);\n\n         for(auto i : m_registered_curves)\n            {\n            if(oid.has_value())\n               {\n               if(i->oid() == oid)\n                  return i;\n               else if(i->oid().has_value())\n                  continue;\n               }\n\n            if(i->match(p, a, b, g_x, g_y, order, cofactor))\n               return i;\n            }\n\n         // Not found - if OID is set try looking up that way\n\n         if(oid.has_value())\n            {\n            // Not located in existing store - try hardcoded data set\n            std::shared_ptr<EC_Group_Data> data = EC_Group::EC_group_info(oid);\n\n            if(data)\n               {\n               m_registered_curves.push_back(data);\n               return data;\n               }\n            }\n\n         // Not found or no OID, add data and return\n         return add_curve(p, a, b, g_x, g_y, order, cofactor, oid);\n         }\n\n   private:\n\n      std::shared_ptr<EC_Group_Data> add_curve(const BigInt& p,\n                                               const BigInt& a,\n                                               const BigInt& b,\n                                               const BigInt& g_x,\n                                               const BigInt& g_y,\n                                               const BigInt& order,\n                                               const BigInt& cofactor,\n                                               const OID& oid)\n         {\n         std::shared_ptr<EC_Group_Data> d =\n            std::make_shared<EC_Group_Data>(p, a, b, g_x, g_y, order, cofactor, oid);\n\n         // This function is always called with the lock held\n         m_registered_curves.push_back(d);\n         return d;\n         }\n\n      mutex_type m_mutex;\n      std::vector<std::shared_ptr<EC_Group_Data>> m_registered_curves;\n   };\n\n//static\nEC_Group_Data_Map& EC_Group::ec_group_data()\n   {\n   /*\n   * This exists purely to ensure the allocator is constructed before g_ec_data,\n   * which ensures that its destructor runs after ~g_ec_data is complete.\n   */\n\n   static Allocator_Initializer g_init_allocator;\n   static EC_Group_Data_Map g_ec_data;\n   return g_ec_data;\n   }\n\n//static\nsize_t EC_Group::clear_registered_curve_data()\n   {\n   return ec_group_data().clear();\n   }\n\n//static\nstd::shared_ptr<EC_Group_Data>\nEC_Group::load_EC_group_info(const char* p_str,\n                             const char* a_str,\n                             const char* b_str,\n                             const char* g_x_str,\n                             const char* g_y_str,\n                             const char* order_str,\n                             const OID& oid)\n   {\n   const BigInt p(p_str);\n   const BigInt a(a_str);\n   const BigInt b(b_str);\n   const BigInt g_x(g_x_str);\n   const BigInt g_y(g_y_str);\n   const BigInt order(order_str);\n   const BigInt cofactor(1); // implicit\n\n   return std::make_shared<EC_Group_Data>(p, a, b, g_x, g_y, order, cofactor, oid);\n   }\n\n//static\nstd::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n\n      if(p.bits() < 64 || p.is_negative() || a.is_negative() || b.is_negative() || order <= 0 || cofactor <= 0)\n         throw Decoding_Error(\"Invalid ECC parameters\");\n\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second, order, cofactor, OID());\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }\n\nEC_Group::EC_Group()\n   {\n   }\n\nEC_Group::~EC_Group()\n   {\n   // shared_ptr possibly freed here\n   }\n\nEC_Group::EC_Group(const OID& domain_oid)\n   {\n   this->m_data = ec_group_data().lookup(domain_oid);\n   if(!this->m_data)\n      throw Invalid_Argument(\"Unknown EC_Group \" + domain_oid.as_string());\n   }\n\nEC_Group::EC_Group(const std::string& str)\n   {\n   if(str == \"\")\n      return; // no initialization / uninitialized\n\n   try\n      {\n      OID oid = OIDS::lookup(str);\n      if(oid.empty() == false)\n         m_data = ec_group_data().lookup(oid);\n      }\n   catch(Invalid_OID&)\n      {\n      }\n\n   if(m_data == nullptr)\n      {\n      if(str.size() > 30 && str.substr(0, 29) == \"-----BEGIN EC PARAMETERS-----\")\n         {\n         // OK try it as PEM ...\n         secure_vector<uint8_t> ber = PEM_Code::decode_check_label(str, \"EC PARAMETERS\");\n         this->m_data = BER_decode_EC_group(ber.data(), ber.size());\n         }\n      }\n\n   if(m_data == nullptr)\n      throw Invalid_Argument(\"Unknown ECC group '\" + str + \"'\");\n   }\n\n//static\nstd::string EC_Group::PEM_for_named_group(const std::string& name)\n   {\n   try\n      {\n      EC_Group group(name);\n      return group.PEM_encode();\n      }\n   catch(...)\n      {\n      return \"\";\n      }\n   }\n\nEC_Group::EC_Group(const BigInt& p,\n                   const BigInt& a,\n                   const BigInt& b,\n                   const BigInt& base_x,\n                   const BigInt& base_y,\n                   const BigInt& order,\n                   const BigInt& cofactor,\n                   const OID& oid)\n   {\n   m_data = ec_group_data().lookup_or_create(p, a, b, base_x, base_y, order, cofactor, oid);\n   }\n\nEC_Group::EC_Group(const std::vector<uint8_t>& ber)\n   {\n   m_data = BER_decode_EC_group(ber.data(), ber.size());\n   }\n\nconst EC_Group_Data& EC_Group::data() const\n   {\n   if(m_data == nullptr)\n      throw Invalid_State(\"EC_Group uninitialized\");\n   return *m_data;\n   }\n\nconst CurveGFp& EC_Group::get_curve() const\n   {\n   return data().curve();\n   }\n\nbool EC_Group::a_is_minus_3() const\n   {\n   return data().a_is_minus_3();\n   }\n\nbool EC_Group::a_is_zero() const\n   {\n   return data().a_is_zero();\n   }\n\nsize_t EC_Group::get_p_bits() const\n   {\n   return data().p_bits();\n   }\n\nsize_t EC_Group::get_p_bytes() const\n   {\n   return data().p_bytes();\n   }\n\nsize_t EC_Group::get_order_bits() const\n   {\n   return data().order_bits();\n   }\n\nsize_t EC_Group::get_order_bytes() const\n   {\n   return data().order_bytes();\n   }\n\nconst BigInt& EC_Group::get_p() const\n   {\n   return data().p();\n   }\n\nconst BigInt& EC_Group::get_a() const\n   {\n   return data().a();\n   }\n\nconst BigInt& EC_Group::get_b() const\n   {\n   return data().b();\n   }\n\nconst PointGFp& EC_Group::get_base_point() const\n   {\n   return data().base_point();\n   }\n\nconst BigInt& EC_Group::get_order() const\n   {\n   return data().order();\n   }\n\nconst BigInt& EC_Group::get_g_x() const\n   {\n   return data().g_x();\n   }\n\nconst BigInt& EC_Group::get_g_y() const\n   {\n   return data().g_y();\n   }\n\nconst BigInt& EC_Group::get_cofactor() const\n   {\n   return data().cofactor();\n   }\n\nBigInt EC_Group::mod_order(const BigInt& k) const\n   {\n   return data().mod_order(k);\n   }\n\nBigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y) const\n   {\n   return data().multiply_mod_order(x, y);\n   }\n\nBigInt EC_Group::inverse_mod_order(const BigInt& x) const\n   {\n   return data().inverse_mod_order(x);\n   }\n\nconst OID& EC_Group::get_curve_oid() const\n   {\n   return data().oid();\n   }\n\nPointGFp EC_Group::OS2ECP(const uint8_t bits[], size_t len) const\n   {\n   return Botan::OS2ECP(bits, len, data().curve());\n   }\n\nPointGFp EC_Group::point(const BigInt& x, const BigInt& y) const\n   {\n   // TODO: randomize the representation?\n   return PointGFp(data().curve(), x, y);\n   }\n\nPointGFp EC_Group::point_multiply(const BigInt& x, const PointGFp& pt, const BigInt& y) const\n   {\n   PointGFp_Multi_Point_Precompute xy_mul(get_base_point(), pt);\n   return xy_mul.multi_exp(x, y);\n   }\n\nPointGFp EC_Group::blinded_base_point_multiply(const BigInt& k,\n                                               RandomNumberGenerator& rng,\n                                               std::vector<BigInt>& ws) const\n   {\n   return data().blinded_base_point_multiply(k, rng, ws);\n   }\n\nBigInt EC_Group::blinded_base_point_multiply_x(const BigInt& k,\n                                               RandomNumberGenerator& rng,\n                                               std::vector<BigInt>& ws) const\n   {\n   const PointGFp pt = data().blinded_base_point_multiply(k, rng, ws);\n\n   if(pt.is_zero())\n      return 0;\n   return pt.get_affine_x();\n   }\n\nBigInt EC_Group::random_scalar(RandomNumberGenerator& rng) const\n   {\n   return BigInt::random_integer(rng, 1, get_order());\n   }\n\nPointGFp EC_Group::blinded_var_point_multiply(const PointGFp& point,\n                                              const BigInt& k,\n                                              RandomNumberGenerator& rng,\n                                              std::vector<BigInt>& ws) const\n   {\n   PointGFp_Var_Point_Precompute mul(point);\n   mul.randomize_repr(rng, ws);\n   return mul.mul(k, rng, get_order(), ws);\n   }\n\nPointGFp EC_Group::zero_point() const\n   {\n   return PointGFp(data().curve());\n   }\n\nstd::vector<uint8_t>\nEC_Group::DER_encode(EC_Group_Encoding form) const\n   {\n   std::vector<uint8_t> output;\n\n   DER_Encoder der(output);\n\n   if(form == EC_DOMPAR_ENC_EXPLICIT)\n      {\n      const size_t ecpVers1 = 1;\n      const OID curve_type(\"1.2.840.10045.1.1\"); // prime field\n\n      const size_t p_bytes = get_p_bytes();\n\n      der.start_cons(SEQUENCE)\n            .encode(ecpVers1)\n            .start_cons(SEQUENCE)\n               .encode(curve_type)\n               .encode(get_p())\n            .end_cons()\n            .start_cons(SEQUENCE)\n               .encode(BigInt::encode_1363(get_a(), p_bytes),\n                       OCTET_STRING)\n               .encode(BigInt::encode_1363(get_b(), p_bytes),\n                       OCTET_STRING)\n            .end_cons()\n              .encode(get_base_point().encode(PointGFp::UNCOMPRESSED), OCTET_STRING)\n            .encode(get_order())\n            .encode(get_cofactor())\n         .end_cons();\n      }\n   else if(form == EC_DOMPAR_ENC_OID)\n      {\n      const OID oid = get_curve_oid();\n      if(oid.empty())\n         {\n         throw Encoding_Error(\"Cannot encode EC_Group as OID because OID not set\");\n         }\n      der.encode(oid);\n      }\n   else if(form == EC_DOMPAR_ENC_IMPLICITCA)\n      {\n      der.encode_null();\n      }\n   else\n      {\n      throw Internal_Error(\"EC_Group::DER_encode: Unknown encoding\");\n      }\n\n   return output;\n   }\n\nstd::string EC_Group::PEM_encode() const\n   {\n   const std::vector<uint8_t> der = DER_encode(EC_DOMPAR_ENC_EXPLICIT);\n   return PEM_Code::encode(der, \"EC PARAMETERS\");\n   }\n\nbool EC_Group::operator==(const EC_Group& other) const\n   {\n   if(m_data == other.m_data)\n      return true; // same shared rep\n\n   /*\n   * No point comparing order/cofactor as they are uniquely determined\n   * by the curve equation (p,a,b) and the base point.\n   */\n   return (get_p() == other.get_p() &&\n           get_a() == other.get_a() &&\n           get_b() == other.get_b() &&\n           get_g_x() == other.get_g_x() &&\n           get_g_y() == other.get_g_y());\n   }\n\nbool EC_Group::verify_public_element(const PointGFp& point) const\n   {\n   //check that public point is not at infinity\n   if(point.is_zero())\n      return false;\n\n   //check that public point is on the curve\n   if(point.on_the_curve() == false)\n      return false;\n\n   //check that public point has order q\n   if((point * get_order()).is_zero() == false)\n      return false;\n\n   if(get_cofactor() > 1)\n      {\n      if((point * get_cofactor()).is_zero())\n         return false;\n      }\n\n   return true;\n   }\n\nbool EC_Group::verify_group(RandomNumberGenerator& rng,\n                            bool) const\n   {\n   //compute the discriminant\n   Modular_Reducer p(get_p());\n   BigInt discriminant = p.multiply(4, get_a());\n   discriminant += p.multiply(27, get_b());\n   discriminant = p.reduce(discriminant);\n   //check the discriminant\n   if(discriminant == 0)\n      {\n      return false;\n      }\n   //check for valid cofactor\n   if(get_cofactor() < 1)\n      {\n      return false;\n      }\n\n   const PointGFp base_point = get_base_point();\n\n   //check if the base point is on the curve\n   if(!base_point.on_the_curve())\n      {\n      return false;\n      }\n   if((base_point * get_cofactor()).is_zero())\n      {\n      return false;\n      }\n\n   const BigInt& order = get_order();\n\n   //check if order is prime\n   if(!is_prime(order, rng, 128))\n      {\n      return false;\n      }\n   //check if order of the base point is correct\n   if(!(base_point * order).is_zero())\n      {\n      return false;\n      }\n   return true;\n   }\n\n}\n", "/*\n* ECC Domain Parameters\n*\n* (C) 2007 Falko Strenzke, FlexSecure GmbH\n*     2008-2010 Jack Lloyd\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#ifndef BOTAN_ECC_DOMAIN_PARAMETERS_H_\n#define BOTAN_ECC_DOMAIN_PARAMETERS_H_\n\n#include <botan/point_gfp.h>\n#include <botan/asn1_oid.h>\n#include <memory>\n#include <set>\n\nnamespace Botan {\n\n/**\n* This class represents elliptic curce domain parameters\n*/\nenum EC_Group_Encoding {\n   EC_DOMPAR_ENC_EXPLICIT = 0,\n   EC_DOMPAR_ENC_IMPLICITCA = 1,\n   EC_DOMPAR_ENC_OID = 2\n};\n\nclass CurveGFp;\n\nclass EC_Group_Data;\nclass EC_Group_Data_Map;\n\n/**\n* Class representing an elliptic curve\n*\n* The internal representation is stored in a shared_ptr, so copying an\n* EC_Group is inexpensive.\n*/\nclass BOTAN_PUBLIC_API(2,0) EC_Group final\n   {\n   public:\n\n      /**\n      * Construct Domain paramers from specified parameters\n      * @param curve elliptic curve\n      * @param base_point a base point\n      * @param order the order of the base point\n      * @param cofactor the cofactor\n      */\n      BOTAN_DEPRECATED(\"Use version taking all BigInts\")\n      EC_Group(const CurveGFp& curve,\n               const PointGFp& base_point,\n               const BigInt& order,\n               const BigInt& cofactor) :\n         EC_Group(curve.get_p(),\n                  curve.get_a(),\n                  curve.get_b(),\n                  base_point.get_affine_x(),\n                  base_point.get_affine_y(),\n                  order,\n                  cofactor) {}\n\n      /**\n      * Construct Domain paramers from specified parameters\n      * @param p the elliptic curve p\n      * @param a the elliptic curve a param\n      * @param b the elliptic curve b param\n      * @param base_x the x coordinate of the base point\n      * @param base_y the y coordinate of the base point\n      * @param order the order of the base point\n      * @param cofactor the cofactor\n      * @param oid an optional OID used to identify this curve\n      */\n      EC_Group(const BigInt& p,\n               const BigInt& a,\n               const BigInt& b,\n               const BigInt& base_x,\n               const BigInt& base_y,\n               const BigInt& order,\n               const BigInt& cofactor,\n               const OID& oid = OID());\n\n      /**\n      * Decode a BER encoded ECC domain parameter set\n      * @param ber_encoding the bytes of the BER encoding\n      */\n      explicit EC_Group(const std::vector<uint8_t>& ber_encoding);\n\n      /**\n      * Create an EC domain by OID (or throw if unknown)\n      * @param oid the OID of the EC domain to create\n      */\n      explicit EC_Group(const OID& oid);\n\n      /**\n      * Create an EC domain from PEM encoding (as from PEM_encode), or\n      * from an OID name (eg \"secp256r1\", or \"1.2.840.10045.3.1.7\")\n      * @param pem_or_oid PEM-encoded data, or an OID\n      */\n      explicit EC_Group(const std::string& pem_or_oid);\n\n      /**\n      * Create an uninitialized EC_Group\n      */\n      EC_Group();\n\n      ~EC_Group();\n\n      /**\n      * Create the DER encoding of this domain\n      * @param form of encoding to use\n      * @returns bytes encododed as DER\n      */\n      std::vector<uint8_t> DER_encode(EC_Group_Encoding form) const;\n\n      /**\n      * Return the PEM encoding (always in explicit form)\n      * @return string containing PEM data\n      */\n      std::string PEM_encode() const;\n\n      /**\n      * Return domain parameter curve\n      * @result domain parameter curve\n      */\n      BOTAN_DEPRECATED(\"Avoid CurveGFp\") const CurveGFp& get_curve() const;\n\n      /**\n      * Return if a == -3 mod p\n      */\n      bool a_is_minus_3() const;\n\n      /**\n      * Return if a == 0 mod p\n      */\n      bool a_is_zero() const;\n\n      /**\n      * Return the size of p in bits (same as get_p().bits())\n      */\n      size_t get_p_bits() const;\n\n      /**\n      * Return the size of p in bits (same as get_p().bytes())\n      */\n      size_t get_p_bytes() const;\n\n      /**\n      * Return the size of group order in bits (same as get_order().bits())\n      */\n      size_t get_order_bits() const;\n\n      /**\n      * Return the size of p in bytes (same as get_order().bytes())\n      */\n      size_t get_order_bytes() const;\n\n      /**\n      * Return the prime modulus of the field\n      */\n      const BigInt& get_p() const;\n\n      /**\n      * Return the a parameter of the elliptic curve equation\n      */\n      const BigInt& get_a() const;\n\n      /**\n      * Return the b parameter of the elliptic curve equation\n      */\n      const BigInt& get_b() const;\n\n      /**\n      * Return group base point\n      * @result base point\n      */\n      const PointGFp& get_base_point() const;\n\n      /**\n      * Return the x coordinate of the base point\n      */\n      const BigInt& get_g_x() const;\n\n      /**\n      * Return the y coordinate of the base point\n      */\n      const BigInt& get_g_y() const;\n\n      /**\n      * Return the order of the base point\n      * @result order of the base point\n      */\n      const BigInt& get_order() const;\n\n      /*\n      * Reduce x modulo the order\n      */\n      BigInt mod_order(const BigInt& x) const;\n\n      /*\n      * Return inverse of x modulo the order\n      */\n      BigInt inverse_mod_order(const BigInt& x) const;\n\n      /*\n      * Reduce (x*y) modulo the order\n      */\n      BigInt multiply_mod_order(const BigInt& x, const BigInt& y) const;\n\n      /**\n      * Return the cofactor\n      * @result the cofactor\n      */\n      const BigInt& get_cofactor() const;\n\n      /**\n      * Check if y is a plausible point on the curve\n      *\n      * In particular, checks that it is a point on the curve, not infinity,\n      * and that it has order matching the group.\n      */\n      bool verify_public_element(const PointGFp& y) const;\n\n      /**\n      * Return the OID of these domain parameters\n      * @result the OID as a string\n      */\n      std::string BOTAN_DEPRECATED(\"Use get_curve_oid\") get_oid() const { return get_curve_oid().as_string(); }\n\n      /**\n      * Return the OID of these domain parameters\n      * @result the OID\n      */\n      const OID& get_curve_oid() const;\n\n      /**\n      * Return a point on this curve with the affine values x, y\n      */\n      PointGFp point(const BigInt& x, const BigInt& y) const;\n\n      /**\n      * Multi exponentiate. Not constant time.\n      * @return base_point*x + pt*y\n      */\n      PointGFp point_multiply(const BigInt& x, const PointGFp& pt, const BigInt& y) const;\n\n      /**\n      * Blinded point multiplication, attempts resistance to side channels\n      * @param k the scalar\n      * @param rng a random number generator\n      * @param ws a temp workspace\n      * @return base_point*k\n      */\n      PointGFp blinded_base_point_multiply(const BigInt& k,\n                                           RandomNumberGenerator& rng,\n                                           std::vector<BigInt>& ws) const;\n\n      /**\n      * Blinded point multiplication, attempts resistance to side channels\n      * Returns just the x coordinate of the point\n      *\n      * @param k the scalar\n      * @param rng a random number generator\n      * @param ws a temp workspace\n      * @return x coordinate of base_point*k\n      */\n      BigInt blinded_base_point_multiply_x(const BigInt& k,\n                                           RandomNumberGenerator& rng,\n                                           std::vector<BigInt>& ws) const;\n\n      /**\n      * Blinded point multiplication, attempts resistance to side channels\n      * @param point input point\n      * @param k the scalar\n      * @param rng a random number generator\n      * @param ws a temp workspace\n      * @return point*k\n      */\n      PointGFp blinded_var_point_multiply(const PointGFp& point,\n                                          const BigInt& k,\n                                          RandomNumberGenerator& rng,\n                                          std::vector<BigInt>& ws) const;\n\n      /**\n      * Return a random scalar ie an integer in [1,order)\n      */\n      BigInt random_scalar(RandomNumberGenerator& rng) const;\n\n      /**\n      * Return the zero (or infinite) point on this curve\n      */\n      PointGFp zero_point() const;\n\n      PointGFp OS2ECP(const uint8_t bits[], size_t len) const;\n\n      template<typename Alloc>\n      PointGFp OS2ECP(const std::vector<uint8_t, Alloc>& vec) const\n         {\n         return this->OS2ECP(vec.data(), vec.size());\n         }\n\n      bool initialized() const { return (m_data != nullptr); }\n\n      /**\n       * Verify EC_Group domain\n       * @returns true if group is valid. false otherwise\n       */\n      bool verify_group(RandomNumberGenerator& rng,\n                        bool strong = false) const;\n\n      bool operator==(const EC_Group& other) const;\n\n      /**\n      * Return PEM representation of named EC group\n      * Deprecated: Use EC_Group(name).PEM_encode() if this is needed\n      */\n      static std::string BOTAN_DEPRECATED(\"See header comment\") PEM_for_named_group(const std::string& name);\n\n      /**\n      * Return a set of known named EC groups\n      */\n      static const std::set<std::string>& known_named_groups();\n\n      /*\n      * For internal use only\n      */\n      static std::shared_ptr<EC_Group_Data> EC_group_info(const OID& oid);\n\n      static size_t clear_registered_curve_data();\n\n   private:\n      static EC_Group_Data_Map& ec_group_data();\n\n      static std::shared_ptr<EC_Group_Data> BER_decode_EC_group(const uint8_t bits[], size_t len);\n\n      static std::shared_ptr<EC_Group_Data>\n         load_EC_group_info(const char* p,\n                            const char* a,\n                            const char* b,\n                            const char* g_x,\n                            const char* g_y,\n                            const char* order,\n                            const OID& oid);\n\n      // Member data\n      const EC_Group_Data& data() const;\n      std::shared_ptr<EC_Group_Data> m_data;\n   };\n\ninline bool operator!=(const EC_Group& lhs,\n                       const EC_Group& rhs)\n   {\n   return !(lhs == rhs);\n   }\n\n// For compatibility with 1.8\ntypedef EC_Group EC_Domain_Params;\n\n}\n\n#endif\n", "/*\n* ECDSA implemenation\n* (C) 2007 Manuel Hartl, FlexSecure GmbH\n*     2007 Falko Strenzke, FlexSecure GmbH\n*     2008-2010,2015,2016,2018 Jack Lloyd\n*     2016 Ren\u00e9 Korthaus\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#include <botan/ecdsa.h>\n#include <botan/internal/pk_ops_impl.h>\n#include <botan/internal/point_mul.h>\n#include <botan/keypair.h>\n#include <botan/reducer.h>\n#include <botan/emsa.h>\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n  #include <botan/rfc6979.h>\n#endif\n\n#if defined(BOTAN_HAS_BEARSSL)\n  #include <botan/internal/bearssl.h>\n#endif\n\n#if defined(BOTAN_HAS_OPENSSL)\n  #include <botan/internal/openssl.h>\n#endif\n\nnamespace Botan {\n\nbool ECDSA_PrivateKey::check_key(RandomNumberGenerator& rng,\n                                 bool strong) const\n   {\n   if(!public_point().on_the_curve())\n      return false;\n\n   if(!strong)\n      return true;\n\n   return KeyPair::signature_consistency_check(rng, *this, \"EMSA1(SHA-256)\");\n   }\n\nnamespace {\n\n/**\n* ECDSA signature operation\n*/\nclass ECDSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n   {\n   public:\n\n      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }\n\n      size_t max_input_bits() const override { return m_group.get_order_bits(); }\n\n      secure_vector<uint8_t> raw_sign(const uint8_t msg[], size_t msg_len,\n                                      RandomNumberGenerator& rng) override;\n\n   private:\n      const EC_Group m_group;\n      const BigInt& m_x;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n      std::string m_rfc6979_hash;\n#endif\n\n      std::vector<BigInt> m_ws;\n   };\n\nsecure_vector<uint8_t>\nECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                    RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len, m_group.get_order_bits());\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   const BigInt k = generate_rfc6979_nonce(m_x, m_group.get_order(), m, m_rfc6979_hash);\n#else\n   const BigInt k = m_group.random_scalar(rng);\n#endif\n\n   const BigInt k_inv = m_group.inverse_mod_order(k);\n   const BigInt r = m_group.mod_order(\n      m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n\n   const BigInt xrm = m_group.mod_order(m_group.multiply_mod_order(m_x, r) + m);\n   const BigInt s = m_group.multiply_mod_order(k_inv, xrm);\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"During ECDSA signature generated zero r/s\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, m_group.get_order_bytes());\n   }\n\n/**\n* ECDSA verification operation\n*/\nclass ECDSA_Verification_Operation final : public PK_Ops::Verification_with_EMSA\n   {\n   public:\n      ECDSA_Verification_Operation(const ECDSA_PublicKey& ecdsa,\n                                   const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_gy_mul(m_group.get_base_point(), ecdsa.public_point())\n         {\n         }\n\n      size_t max_input_bits() const override { return m_group.get_order_bits(); }\n\n      bool with_recovery() const override { return false; }\n\n      bool verify(const uint8_t msg[], size_t msg_len,\n                  const uint8_t sig[], size_t sig_len) override;\n   private:\n      const EC_Group m_group;\n      const PointGFp_Multi_Point_Precompute m_gy_mul;\n   };\n\nbool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                          const uint8_t sig[], size_t sig_len)\n   {\n   if(sig_len != m_group.get_order_bytes() * 2)\n      return false;\n\n   const BigInt e(msg, msg_len, m_group.get_order_bits());\n\n   const BigInt r(sig, sig_len / 2);\n   const BigInt s(sig + sig_len / 2, sig_len / 2);\n\n   if(r <= 0 || r >= m_group.get_order() || s <= 0 || s >= m_group.get_order())\n      return false;\n\n   const BigInt w = m_group.inverse_mod_order(s);\n\n   const BigInt u1 = m_group.multiply_mod_order(e, w);\n   const BigInt u2 = m_group.multiply_mod_order(r, w);\n   const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n\n   if(R.is_zero())\n      return false;\n\n   const BigInt v = m_group.mod_order(R.get_affine_x());\n   return (v == r);\n   }\n\n}\n\nstd::unique_ptr<PK_Ops::Verification>\nECDSA_PublicKey::create_verification_op(const std::string& params,\n                                        const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_ver_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_ver_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Verification>(new ECDSA_Verification_Operation(*this, params));\n\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\nstd::unique_ptr<PK_Ops::Signature>\nECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& /*rng*/,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\n}\n"], "fixing_code": ["\n.. highlight:: none\n\nSecurity Advisories\n========================================\n\nIf you think you have found a security bug in Botan please contact\nJack Lloyd (jack@randombit.net). If you would like to encrypt your\nmail please use::\n\n  pub   rsa3072/57123B60 2015-03-23\n        Key fingerprint = 4E60 C735 51AF 2188 DF0A  5A62 78E9 8043 5712 3B60\n        uid         Jack Lloyd <jack@randombit.net>\n\nThis key can be found in the file ``doc/pgpkey.txt`` or online at\nhttps://keybase.io/jacklloyd and on most PGP keyservers.\n\n2018\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2018-06-13 (CVE-2018-0495): ECDSA side channel\n\n  A side channel in the ECDSA signature operation could allow a local attacker\n  to recover the secret key. Found by Keegan Ryan of NCC Group.\n\n  Fixed in 2.7.0. Due to a slight difference in code structure, versions before\n  2.5.0 are not affected by this issue.\n\n* 2018-04-10 (CVE-2018-9860): Memory overread in TLS CBC decryption\n\n  An off by one error in TLS CBC decryption meant that for a particular\n  malformed ciphertext, the receiver would miscompute a length field and HMAC\n  exactly 64K bytes of data following the record buffer as if it was part of the\n  message. This cannot be used to leak information since the MAC comparison will\n  subsequently fail and the connection will be closed. However it might be used\n  for denial of service. Found by OSS-Fuzz.\n\n  Bug introduced in 1.11.32, fixed in 2.6.0\n\n* 2018-03-29 (CVE-2018-9127): Invalid wildcard match\n\n  RFC 6125 wildcard matching was incorrectly implemented, so that a wildcard\n  certificate such as ``b*.domain.com`` would match any hosts ``*b*.domain.com``\n  instead of just server names beginning with ``b``. The host and certificate\n  would still have to be in the same domain name. Reported by Fabian Wei\u00dfberg of\n  Rohde and Schwarz Cybersecurity.\n\n  Bug introduced in 2.2.0, fixed in 2.5.0\n\n2017\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2017-10-02 (CVE-2017-14737): Potential side channel using cache information\n\n  In the Montgomery exponentiation code, a table of precomputed values\n  is used. An attacker able to analyze which cache lines were accessed\n  (perhaps via an active attack such as Prime+Probe) could recover\n  information about the exponent. Identified in \"CacheD: Identifying\n  Cache-Based Timing Channels in Production Software\" by Wang, Wang,\n  Liu, Zhang, and Wu (Usenix Security 2017).\n\n  Fixed in 1.10.17 and 2.3.0, all prior versions affected.\n\n* 2017-07-16: Failure to fully zeroize memory before free\n\n  The secure_allocator type attempts to zeroize memory before freeing it. Due to\n  a error sometimes only a portion of the memory would be zeroed, because of a\n  confusion between the number of elements vs the number of bytes that those\n  elements use. So byte vectors would always be fully zeroed (since the two\n  notions result in the same value), but for example with an array of 32-bit\n  integers, only the first 1/4 of the elements would be zeroed before being\n  deallocated. This may result in information leakage, if an attacker can access\n  memory on the heap. Reported by Roman Pozlevich.\n\n  Bug introduced in 1.11.10, fixed in 2.2.0\n\n* 2017-04-04 (CVE-2017-2801): Incorrect comparison in X.509 DN strings\n\n  Botan's implementation of X.509 name comparisons had a flaw which\n  could result in an out of bound memory read while processing a\n  specially formed DN. This could potentially be exploited for\n  information disclosure or denial of service, or result in incorrect\n  validation results. Found independently by Aleksandar Nikolic of\n  Cisco Talos, and OSS-Fuzz automated fuzzing infrastructure.\n\n  Bug introduced in 1.6.0 or earlier, fixed in 2.1.0 and 1.10.16\n\n* 2017-03-23 (CVE-2017-7252): Incorrect bcrypt computation\n\n  Botan's implementation of bcrypt password hashing scheme truncated long\n  passwords at 56 characters, instead of at bcrypt's standard 72 characters\n  limit. Passwords with lengths between these two bounds could be cracked more\n  easily than should be the case due to the final password bytes being ignored.\n  Found and reported by Solar Designer.\n\n  Bug introduced in 1.11.0, fixed in 2.1.0.\n\n2016\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2016-11-27 (CVE-2016-9132) Integer overflow in BER decoder\n\n  While decoding BER length fields, an integer overflow could occur. This could\n  occur while parsing untrusted inputs such as X.509 certificates. The overflow\n  does not seem to lead to any obviously exploitable condition, but exploitation\n  cannot be positively ruled out. Only 32-bit platforms are likely affected; to\n  cause an overflow on 64-bit the parsed data would have to be many gigabytes.\n  Bug found by Falko Strenzke, cryptosource GmbH.\n\n  Fixed in 1.10.14 and 1.11.34, all prior versions affected.\n\n* 2016-10-26 (CVE-2016-8871) OAEP side channel\n\n  A side channel in OAEP decoding could be used to distinguish RSA ciphertexts\n  that did or did not have a leading 0 byte. For an attacker capable of\n  precisely measuring the time taken for OAEP decoding, this could be used as an\n  oracle allowing decryption of arbitrary RSA ciphertexts. Remote exploitation\n  seems difficult as OAEP decoding is always paired with RSA decryption, which\n  takes substantially more (and variable) time, and so will tend to mask the\n  timing channel. This attack does seems well within reach of a local attacker\n  capable of a cache or branch predictor based side channel attack. Finding,\n  analysis, and patch by Juraj Somorovsky.\n\n  Introduced in 1.11.29, fixed in 1.11.33\n\n* 2016-08-30 (CVE-2016-6878) Undefined behavior in Curve25519\n\n  On systems without a native 128-bit integer type, the Curve25519 code invoked\n  undefined behavior. This was known to produce incorrect results on 32-bit ARM\n  when compiled by Clang.\n\n  Introduced in 1.11.12, fixed in 1.11.31\n\n* 2016-08-30 (CVE-2016-6879) Bad result from X509_Certificate::allowed_usage\n\n  If allowed_usage was called with more than one Key_Usage set in the enum\n  value, the function would return true if *any* of the allowed usages were set,\n  instead of if *all* of the allowed usages are set.  This could be used to\n  bypass an application key usage check. Credit to Daniel Neus of Rohde &\n  Schwarz Cybersecurity for finding this issue.\n\n  Introduced in 1.11.0, fixed in 1.11.31\n\n* 2016-03-17 (CVE-2016-2849): ECDSA side channel\n\n  ECDSA (and DSA) signature algorithms perform a modular inverse on the\n  signature nonce `k`.  The modular inverse algorithm used had input dependent\n  loops, and it is possible a side channel attack could recover sufficient\n  information about the nonce to eventually recover the ECDSA secret key. Found\n  by Sean Devlin.\n\n  Introduced in 1.7.15, fixed in 1.10.13 and 1.11.29\n\n* 2016-03-17 (CVE-2016-2850): Failure to enforce TLS policy\n\n  TLS v1.2 allows negotiating which signature algorithms and hash functions each\n  side is willing to accept. However received signatures were not actually\n  checked against the specified policy.  This had the effect of allowing a\n  server to use an MD5 or SHA-1 signature, even though the default policy\n  prohibits it. The same issue affected client cert authentication.\n\n  The TLS client also failed to verify that the ECC curve the server chose to\n  use was one which was acceptable by the client policy.\n\n  Introduced in 1.11.0, fixed in 1.11.29\n\n* 2016-02-01 (CVE-2016-2196): Overwrite in P-521 reduction\n\n  The P-521 reduction function would overwrite zero to one word\n  following the allocated block. This could potentially result\n  in remote code execution or a crash. Found with AFL\n\n  Introduced in 1.11.10, fixed in 1.11.27\n\n* 2016-02-01 (CVE-2016-2195): Heap overflow on invalid ECC point\n\n  The PointGFp constructor did not check that the affine coordinate\n  arguments were less than the prime, but then in curve multiplication\n  assumed that both arguments if multiplied would fit into an integer\n  twice the size of the prime.\n\n  The bigint_mul and bigint_sqr functions received the size of the\n  output buffer, but only used it to dispatch to a faster algorithm in\n  cases where there was sufficient output space to call an unrolled\n  multiplication function.\n\n  The result is a heap overflow accessible via ECC point decoding,\n  which accepted untrusted inputs. This is likely exploitable for\n  remote code execution.\n\n  On systems which use the mlock pool allocator, it would allow an\n  attacker to overwrite memory held in secure_vector objects. After\n  this point the write will hit the guard page at the end of the\n  mmap'ed region so it probably could not be used for code execution\n  directly, but would allow overwriting adjacent key material.\n\n  Found by Alex Gaynor fuzzing with AFL\n\n  Introduced in 1.9.18, fixed in 1.11.27 and 1.10.11\n\n* 2016-02-01 (CVE-2016-2194): Infinite loop in modular square root algorithm\n\n  The ressol function implements the Tonelli-Shanks algorithm for\n  finding square roots could be sent into a nearly infinite loop due\n  to a misplaced conditional check. This could occur if a composite\n  modulus is provided, as this algorithm is only defined for primes.\n  This function is exposed to attacker controlled input via the OS2ECP\n  function during ECC point decompression. Found by AFL\n\n  Introduced in 1.7.15, fixed in 1.11.27 and 1.10.11\n\n2015\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2015-11-04: TLS certificate authentication bypass\n\n  When the bugs affecting X.509 path validation were fixed in 1.11.22, a check\n  in Credentials_Manager::verify_certificate_chain was accidentally removed\n  which caused path validation failures not to be signaled to the TLS layer.  So\n  for affected versions, certificate authentication in TLS is bypassed. As a\n  workaround, applications can override the call and implement the correct\n  check. Reported by Florent Le Coz in GH #324\n\n  Introduced in 1.11.22, fixed in 1.11.24\n\n* 2015-10-26 (CVE-2015-7824): Padding oracle attack on TLS\n\n  A padding oracle attack was possible against TLS CBC ciphersuites because if a\n  certain length check on the packet fields failed, a different alert type than\n  one used for message authentication failure would be returned to the sender.\n  This check triggering would leak information about the value of the padding\n  bytes and could be used to perform iterative decryption.\n\n  As with most such oracle attacks, the danger depends on the underlying\n  protocol - HTTP servers are particularly vulnerable. The current analysis\n  suggests that to exploit it an attacker would first have to guess several\n  bytes of plaintext, but again this is quite possible in many situations\n  including HTTP.\n\n  Found in a review by Sirrix AG and 3curity GmbH.\n\n  Introduced in 1.11.0, fixed in 1.11.22\n\n* 2015-10-26 (CVE-2015-7825): Infinite loop during certificate path validation\n\n  When evaluating a certificate path, if a loop in the certificate chain\n  was encountered (for instance where C1 certifies C2, which certifies C1)\n  an infinite loop would occur eventually resulting in memory exhaustion.\n  Found in a review by Sirrix AG and 3curity GmbH.\n\n  Introduced in 1.11.6, fixed in 1.11.22\n\n* 2015-10-26 (CVE-2015-7826): Acceptance of invalid certificate names\n\n  RFC 6125 specifies how to match a X.509v3 certificate against a DNS name\n  for application usage.\n\n  Otherwise valid certificates using wildcards would be accepted as matching\n  certain hostnames that should they should not according to RFC 6125. For\n  example a certificate issued for ``*.example.com`` should match\n  ``foo.example.com`` but not ``example.com`` or ``bar.foo.example.com``. Previously\n  Botan would accept such a certificate as also valid for ``bar.foo.example.com``.\n\n  RFC 6125 also requires that when matching a X.509 certificate against a DNS\n  name, the CN entry is only compared if no subjectAlternativeName entry is\n  available. Previously X509_Certificate::matches_dns_name would always check\n  both names.\n\n  Found in a review by Sirrix AG and 3curity GmbH.\n\n  Introduced in 1.11.0, fixed in 1.11.22\n\n* 2015-10-26 (CVE-2015-7827): PKCS #1 v1.5 decoding was not constant time\n\n  During RSA decryption, how long decoding of PKCS #1 v1.5 padding took was\n  input dependent. If these differences could be measured by an attacker, it\n  could be used to mount a Bleichenbacher million-message attack. PKCS #1 v1.5\n  decoding has been rewritten to use a sequence of operations which do not\n  contain any input-dependent indexes or jumps. Notations for checking constant\n  time blocks with ctgrind (https://github.com/agl/ctgrind) were added to PKCS\n  #1 decoding among other areas. Found in a review by Sirrix AG and 3curity GmbH.\n\n  Fixed in 1.11.22 and 1.10.13. Affected all previous versions.\n\n* 2015-08-03 (CVE-2015-5726): Crash in BER decoder\n\n  The BER decoder would crash due to reading from offset 0 of an empty vector if\n  it encountered a BIT STRING which did not contain any data at all. This can be\n  used to easily crash applications reading untrusted ASN.1 data, but does not\n  seem exploitable for code execution. Found with afl.\n\n  Fixed in 1.11.19 and 1.10.10, affected all previous versions of 1.10 and 1.11\n\n* 2015-08-03 (CVE-2015-5727): Excess memory allocation in BER decoder\n\n  The BER decoder would allocate a fairly arbitrary amount of memory in a length\n  field, even if there was no chance the read request would succeed.  This might\n  cause the process to run out of memory or invoke the OOM killer. Found with afl.\n\n  Fixed in 1.11.19 and 1.10.10, affected all previous versions of 1.10 and 1.11\n\n2014\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n* 2014-04-10 (CVE-2014-9742): Insufficient randomness in Miller-Rabin primality check\n\n  A bug in the Miller-Rabin primality test resulted in only a single random base\n  being used instead of a sequence of such bases. This increased the probability\n  that a non-prime would be accepted by is_prime or that a randomly generated\n  prime might actually be composite.  The probability of a random 1024 bit\n  number being incorrectly classed as prime with a single base is around 2^-40.\n  Reported by Jeff Marrison.\n\n  Introduced in 1.8.3, fixed in 1.10.8 and 1.11.9\n", "/*\n* DSA\n* (C) 1999-2010,2014,2016 Jack Lloyd\n* (C) 2016 Ren\u00e9 Korthaus\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#include <botan/dsa.h>\n#include <botan/keypair.h>\n#include <botan/reducer.h>\n#include <botan/rng.h>\n#include <botan/internal/pk_ops_impl.h>\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n  #include <botan/emsa.h>\n  #include <botan/rfc6979.h>\n#endif\n\nnamespace Botan {\n\n/*\n* DSA_PublicKey Constructor\n*/\nDSA_PublicKey::DSA_PublicKey(const DL_Group& grp, const BigInt& y1)\n   {\n   m_group = grp;\n   m_y = y1;\n   }\n\n/*\n* Create a DSA private key\n*/\nDSA_PrivateKey::DSA_PrivateKey(RandomNumberGenerator& rng,\n                               const DL_Group& grp,\n                               const BigInt& x_arg)\n   {\n   m_group = grp;\n\n   if(x_arg == 0)\n      m_x = BigInt::random_integer(rng, 2, group_q());\n   else\n      m_x = x_arg;\n\n   m_y = m_group.power_g_p(m_x);\n   }\n\nDSA_PrivateKey::DSA_PrivateKey(const AlgorithmIdentifier& alg_id,\n                               const secure_vector<uint8_t>& key_bits) :\n   DL_Scheme_PrivateKey(alg_id, key_bits, DL_Group::ANSI_X9_57)\n   {\n   m_y = m_group.power_g_p(m_x);\n   }\n\n/*\n* Check Private DSA Parameters\n*/\nbool DSA_PrivateKey::check_key(RandomNumberGenerator& rng, bool strong) const\n   {\n   if(!DL_Scheme_PrivateKey::check_key(rng, strong) || m_x >= group_q())\n      return false;\n\n   if(!strong)\n      return true;\n\n   return KeyPair::signature_consistency_check(rng, *this, \"EMSA1(SHA-256)\");\n   }\n\nnamespace {\n\n/**\n* Object that can create a DSA signature\n*/\nclass DSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n   {\n   public:\n      DSA_Signature_Operation(const DSA_PrivateKey& dsa,\n                              const std::string& emsa,\n                              RandomNumberGenerator& rng) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n\n         m_b = BigInt::random_integer(rng, 2, dsa.group_q());\n         m_b_inv = inverse_mod(m_b, dsa.group_q());\n         }\n\n      size_t max_input_bits() const override { return m_group.get_q().bits(); }\n\n      secure_vector<uint8_t> raw_sign(const uint8_t msg[], size_t msg_len,\n                                   RandomNumberGenerator& rng) override;\n   private:\n      const DL_Group m_group;\n      const BigInt& m_x;\n      Modular_Reducer m_mod_q;\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n      std::string m_rfc6979_hash;\n#endif\n\n      BigInt m_b, m_b_inv;\n   };\n\nsecure_vector<uint8_t>\nDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt m(msg, msg_len, q.bits());\n\n   while(m >= q)\n      m -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, m, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   const BigInt k_inv = inverse_mod(k, q);\n\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   /*\n   * Blind the input message and compute x*r+m as (x*r*b + m*b)/b\n   */\n   m_b = m_mod_q.square(m_b);\n   m_b_inv = m_mod_q.square(m_b_inv);\n\n   m = m_mod_q.multiply(m_b, m);\n   const BigInt xr = m_mod_q.multiply(m_mod_q.multiply(m_x, m_b), r);\n\n   const BigInt s = m_mod_q.multiply(m_b_inv, m_mod_q.multiply(k_inv, xr + m));\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }\n\n/**\n* Object that can verify a DSA signature\n*/\nclass DSA_Verification_Operation final : public PK_Ops::Verification_with_EMSA\n   {\n   public:\n      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {\n         }\n\n      size_t max_input_bits() const override { return m_group.get_q().bits(); }\n\n      bool with_recovery() const override { return false; }\n\n      bool verify(const uint8_t msg[], size_t msg_len,\n                  const uint8_t sig[], size_t sig_len) override;\n   private:\n      const DL_Group m_group;\n      const BigInt& m_y;\n\n      Modular_Reducer m_mod_q;\n   };\n\nbool DSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                        const uint8_t sig[], size_t sig_len)\n   {\n   const BigInt& q = m_group.get_q();\n   const size_t q_bytes = q.bytes();\n\n   if(sig_len != 2*q_bytes || msg_len > q_bytes)\n      return false;\n\n   BigInt r(sig, q_bytes);\n   BigInt s(sig + q_bytes, q_bytes);\n   BigInt i(msg, msg_len, q.bits());\n\n   if(r <= 0 || r >= q || s <= 0 || s >= q)\n      return false;\n\n   s = inverse_mod(s, q);\n\n   const BigInt sr = m_mod_q.multiply(s, r);\n   const BigInt si = m_mod_q.multiply(s, i);\n\n   s = m_group.multi_exponentiate(si, m_y, sr);\n\n   return (m_mod_q.reduce(s) == r);\n   }\n\n}\n\nstd::unique_ptr<PK_Ops::Verification>\nDSA_PublicKey::create_verification_op(const std::string& params,\n                                      const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Verification>(new DSA_Verification_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\nstd::unique_ptr<PK_Ops::Signature>\nDSA_PrivateKey::create_signature_op(RandomNumberGenerator& rng,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params, rng));\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\n}\n", "/*\n* ECC Domain Parameters\n*\n* (C) 2007 Falko Strenzke, FlexSecure GmbH\n* (C) 2008,2018 Jack Lloyd\n* (C) 2018 Tobias Niemann\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#include <botan/ec_group.h>\n#include <botan/internal/point_mul.h>\n#include <botan/ber_dec.h>\n#include <botan/der_enc.h>\n#include <botan/oids.h>\n#include <botan/pem.h>\n#include <botan/reducer.h>\n#include <botan/mutex.h>\n#include <vector>\n\nnamespace Botan {\n\nclass EC_Group_Data final\n   {\n   public:\n\n      EC_Group_Data(const BigInt& p,\n                    const BigInt& a,\n                    const BigInt& b,\n                    const BigInt& g_x,\n                    const BigInt& g_y,\n                    const BigInt& order,\n                    const BigInt& cofactor,\n                    const OID& oid) :\n         m_curve(p, a, b),\n         m_base_point(m_curve, g_x, g_y),\n         m_g_x(g_x),\n         m_g_y(g_y),\n         m_order(order),\n         m_cofactor(cofactor),\n         m_mod_order(order),\n         m_base_mult(m_base_point, m_mod_order),\n         m_oid(oid),\n         m_p_bits(p.bits()),\n         m_order_bits(order.bits()),\n         m_a_is_minus_3(a == p - 3),\n         m_a_is_zero(a.is_zero())\n         {\n         }\n\n      bool match(const BigInt& p, const BigInt& a, const BigInt& b,\n                 const BigInt& g_x, const BigInt& g_y,\n                 const BigInt& order, const BigInt& cofactor) const\n         {\n         return (this->p() == p &&\n                 this->a() == a &&\n                 this->b() == b &&\n                 this->order() == order &&\n                 this->cofactor() == cofactor &&\n                 this->g_x() == g_x &&\n                 this->g_y() == g_y);\n         }\n\n      const OID& oid() const { return m_oid; }\n      const BigInt& p() const { return m_curve.get_p(); }\n      const BigInt& a() const { return m_curve.get_a(); }\n      const BigInt& b() const { return m_curve.get_b(); }\n      const BigInt& order() const { return m_order; }\n      const BigInt& cofactor() const { return m_cofactor; }\n      const BigInt& g_x() const { return m_g_x; }\n      const BigInt& g_y() const { return m_g_y; }\n\n      size_t p_bits() const { return m_p_bits; }\n      size_t p_bytes() const { return (m_p_bits + 7) / 8; }\n\n      size_t order_bits() const { return m_order_bits; }\n      size_t order_bytes() const { return (m_order_bits + 7) / 8; }\n\n      const CurveGFp& curve() const { return m_curve; }\n      const PointGFp& base_point() const { return m_base_point; }\n\n      bool a_is_minus_3() const { return m_a_is_minus_3; }\n      bool a_is_zero() const { return m_a_is_zero; }\n\n      BigInt mod_order(const BigInt& x) const { return m_mod_order.reduce(x); }\n\n      BigInt square_mod_order(const BigInt& x) const\n         {\n         return m_mod_order.square(x);\n         }\n\n      BigInt multiply_mod_order(const BigInt& x, const BigInt& y) const\n         {\n         return m_mod_order.multiply(x, y);\n         }\n\n      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n         {\n         return m_mod_order.multiply(m_mod_order.multiply(x, y), z);\n         }\n\n      BigInt inverse_mod_order(const BigInt& x) const\n         {\n         return inverse_mod(x, m_order);\n         }\n\n      PointGFp blinded_base_point_multiply(const BigInt& k,\n                                           RandomNumberGenerator& rng,\n                                           std::vector<BigInt>& ws) const\n         {\n         return m_base_mult.mul(k, rng, m_order, ws);\n         }\n\n   private:\n      CurveGFp m_curve;\n      PointGFp m_base_point;\n\n      BigInt m_g_x;\n      BigInt m_g_y;\n      BigInt m_order;\n      BigInt m_cofactor;\n      Modular_Reducer m_mod_order;\n      PointGFp_Base_Point_Precompute m_base_mult;\n      OID m_oid;\n      size_t m_p_bits;\n      size_t m_order_bits;\n      bool m_a_is_minus_3;\n      bool m_a_is_zero;\n   };\n\nclass EC_Group_Data_Map final\n   {\n   public:\n      EC_Group_Data_Map() {}\n\n      size_t clear()\n         {\n         lock_guard_type<mutex_type> lock(m_mutex);\n         size_t count = m_registered_curves.size();\n         m_registered_curves.clear();\n         return count;\n         }\n\n      std::shared_ptr<EC_Group_Data> lookup(const OID& oid)\n         {\n         lock_guard_type<mutex_type> lock(m_mutex);\n\n         for(auto i : m_registered_curves)\n            {\n            if(i->oid() == oid)\n               return i;\n            }\n\n         // Not found, check hardcoded data\n         std::shared_ptr<EC_Group_Data> data = EC_Group::EC_group_info(oid);\n\n         if(data)\n            {\n            m_registered_curves.push_back(data);\n            return data;\n            }\n\n         // Nope, unknown curve\n         return std::shared_ptr<EC_Group_Data>();\n         }\n\n      std::shared_ptr<EC_Group_Data> lookup_or_create(const BigInt& p,\n                                                      const BigInt& a,\n                                                      const BigInt& b,\n                                                      const BigInt& g_x,\n                                                      const BigInt& g_y,\n                                                      const BigInt& order,\n                                                      const BigInt& cofactor,\n                                                      const OID& oid)\n         {\n         lock_guard_type<mutex_type> lock(m_mutex);\n\n         for(auto i : m_registered_curves)\n            {\n            if(oid.has_value())\n               {\n               if(i->oid() == oid)\n                  return i;\n               else if(i->oid().has_value())\n                  continue;\n               }\n\n            if(i->match(p, a, b, g_x, g_y, order, cofactor))\n               return i;\n            }\n\n         // Not found - if OID is set try looking up that way\n\n         if(oid.has_value())\n            {\n            // Not located in existing store - try hardcoded data set\n            std::shared_ptr<EC_Group_Data> data = EC_Group::EC_group_info(oid);\n\n            if(data)\n               {\n               m_registered_curves.push_back(data);\n               return data;\n               }\n            }\n\n         // Not found or no OID, add data and return\n         return add_curve(p, a, b, g_x, g_y, order, cofactor, oid);\n         }\n\n   private:\n\n      std::shared_ptr<EC_Group_Data> add_curve(const BigInt& p,\n                                               const BigInt& a,\n                                               const BigInt& b,\n                                               const BigInt& g_x,\n                                               const BigInt& g_y,\n                                               const BigInt& order,\n                                               const BigInt& cofactor,\n                                               const OID& oid)\n         {\n         std::shared_ptr<EC_Group_Data> d =\n            std::make_shared<EC_Group_Data>(p, a, b, g_x, g_y, order, cofactor, oid);\n\n         // This function is always called with the lock held\n         m_registered_curves.push_back(d);\n         return d;\n         }\n\n      mutex_type m_mutex;\n      std::vector<std::shared_ptr<EC_Group_Data>> m_registered_curves;\n   };\n\n//static\nEC_Group_Data_Map& EC_Group::ec_group_data()\n   {\n   /*\n   * This exists purely to ensure the allocator is constructed before g_ec_data,\n   * which ensures that its destructor runs after ~g_ec_data is complete.\n   */\n\n   static Allocator_Initializer g_init_allocator;\n   static EC_Group_Data_Map g_ec_data;\n   return g_ec_data;\n   }\n\n//static\nsize_t EC_Group::clear_registered_curve_data()\n   {\n   return ec_group_data().clear();\n   }\n\n//static\nstd::shared_ptr<EC_Group_Data>\nEC_Group::load_EC_group_info(const char* p_str,\n                             const char* a_str,\n                             const char* b_str,\n                             const char* g_x_str,\n                             const char* g_y_str,\n                             const char* order_str,\n                             const OID& oid)\n   {\n   const BigInt p(p_str);\n   const BigInt a(a_str);\n   const BigInt b(b_str);\n   const BigInt g_x(g_x_str);\n   const BigInt g_y(g_y_str);\n   const BigInt order(order_str);\n   const BigInt cofactor(1); // implicit\n\n   return std::make_shared<EC_Group_Data>(p, a, b, g_x, g_y, order, cofactor, oid);\n   }\n\n//static\nstd::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n\n      if(p.bits() < 64 || p.is_negative() || a.is_negative() || b.is_negative() || order <= 0 || cofactor <= 0)\n         throw Decoding_Error(\"Invalid ECC parameters\");\n\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second, order, cofactor, OID());\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }\n\nEC_Group::EC_Group()\n   {\n   }\n\nEC_Group::~EC_Group()\n   {\n   // shared_ptr possibly freed here\n   }\n\nEC_Group::EC_Group(const OID& domain_oid)\n   {\n   this->m_data = ec_group_data().lookup(domain_oid);\n   if(!this->m_data)\n      throw Invalid_Argument(\"Unknown EC_Group \" + domain_oid.as_string());\n   }\n\nEC_Group::EC_Group(const std::string& str)\n   {\n   if(str == \"\")\n      return; // no initialization / uninitialized\n\n   try\n      {\n      OID oid = OIDS::lookup(str);\n      if(oid.empty() == false)\n         m_data = ec_group_data().lookup(oid);\n      }\n   catch(Invalid_OID&)\n      {\n      }\n\n   if(m_data == nullptr)\n      {\n      if(str.size() > 30 && str.substr(0, 29) == \"-----BEGIN EC PARAMETERS-----\")\n         {\n         // OK try it as PEM ...\n         secure_vector<uint8_t> ber = PEM_Code::decode_check_label(str, \"EC PARAMETERS\");\n         this->m_data = BER_decode_EC_group(ber.data(), ber.size());\n         }\n      }\n\n   if(m_data == nullptr)\n      throw Invalid_Argument(\"Unknown ECC group '\" + str + \"'\");\n   }\n\n//static\nstd::string EC_Group::PEM_for_named_group(const std::string& name)\n   {\n   try\n      {\n      EC_Group group(name);\n      return group.PEM_encode();\n      }\n   catch(...)\n      {\n      return \"\";\n      }\n   }\n\nEC_Group::EC_Group(const BigInt& p,\n                   const BigInt& a,\n                   const BigInt& b,\n                   const BigInt& base_x,\n                   const BigInt& base_y,\n                   const BigInt& order,\n                   const BigInt& cofactor,\n                   const OID& oid)\n   {\n   m_data = ec_group_data().lookup_or_create(p, a, b, base_x, base_y, order, cofactor, oid);\n   }\n\nEC_Group::EC_Group(const std::vector<uint8_t>& ber)\n   {\n   m_data = BER_decode_EC_group(ber.data(), ber.size());\n   }\n\nconst EC_Group_Data& EC_Group::data() const\n   {\n   if(m_data == nullptr)\n      throw Invalid_State(\"EC_Group uninitialized\");\n   return *m_data;\n   }\n\nconst CurveGFp& EC_Group::get_curve() const\n   {\n   return data().curve();\n   }\n\nbool EC_Group::a_is_minus_3() const\n   {\n   return data().a_is_minus_3();\n   }\n\nbool EC_Group::a_is_zero() const\n   {\n   return data().a_is_zero();\n   }\n\nsize_t EC_Group::get_p_bits() const\n   {\n   return data().p_bits();\n   }\n\nsize_t EC_Group::get_p_bytes() const\n   {\n   return data().p_bytes();\n   }\n\nsize_t EC_Group::get_order_bits() const\n   {\n   return data().order_bits();\n   }\n\nsize_t EC_Group::get_order_bytes() const\n   {\n   return data().order_bytes();\n   }\n\nconst BigInt& EC_Group::get_p() const\n   {\n   return data().p();\n   }\n\nconst BigInt& EC_Group::get_a() const\n   {\n   return data().a();\n   }\n\nconst BigInt& EC_Group::get_b() const\n   {\n   return data().b();\n   }\n\nconst PointGFp& EC_Group::get_base_point() const\n   {\n   return data().base_point();\n   }\n\nconst BigInt& EC_Group::get_order() const\n   {\n   return data().order();\n   }\n\nconst BigInt& EC_Group::get_g_x() const\n   {\n   return data().g_x();\n   }\n\nconst BigInt& EC_Group::get_g_y() const\n   {\n   return data().g_y();\n   }\n\nconst BigInt& EC_Group::get_cofactor() const\n   {\n   return data().cofactor();\n   }\n\nBigInt EC_Group::mod_order(const BigInt& k) const\n   {\n   return data().mod_order(k);\n   }\n\nBigInt EC_Group::square_mod_order(const BigInt& x) const\n   {\n   return data().square_mod_order(x);\n   }\n\nBigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y) const\n   {\n   return data().multiply_mod_order(x, y);\n   }\n\nBigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n   {\n   return data().multiply_mod_order(x, y, z);\n   }\n\nBigInt EC_Group::inverse_mod_order(const BigInt& x) const\n   {\n   return data().inverse_mod_order(x);\n   }\n\nconst OID& EC_Group::get_curve_oid() const\n   {\n   return data().oid();\n   }\n\nPointGFp EC_Group::OS2ECP(const uint8_t bits[], size_t len) const\n   {\n   return Botan::OS2ECP(bits, len, data().curve());\n   }\n\nPointGFp EC_Group::point(const BigInt& x, const BigInt& y) const\n   {\n   // TODO: randomize the representation?\n   return PointGFp(data().curve(), x, y);\n   }\n\nPointGFp EC_Group::point_multiply(const BigInt& x, const PointGFp& pt, const BigInt& y) const\n   {\n   PointGFp_Multi_Point_Precompute xy_mul(get_base_point(), pt);\n   return xy_mul.multi_exp(x, y);\n   }\n\nPointGFp EC_Group::blinded_base_point_multiply(const BigInt& k,\n                                               RandomNumberGenerator& rng,\n                                               std::vector<BigInt>& ws) const\n   {\n   return data().blinded_base_point_multiply(k, rng, ws);\n   }\n\nBigInt EC_Group::blinded_base_point_multiply_x(const BigInt& k,\n                                               RandomNumberGenerator& rng,\n                                               std::vector<BigInt>& ws) const\n   {\n   const PointGFp pt = data().blinded_base_point_multiply(k, rng, ws);\n\n   if(pt.is_zero())\n      return 0;\n   return pt.get_affine_x();\n   }\n\nBigInt EC_Group::random_scalar(RandomNumberGenerator& rng) const\n   {\n   return BigInt::random_integer(rng, 1, get_order());\n   }\n\nPointGFp EC_Group::blinded_var_point_multiply(const PointGFp& point,\n                                              const BigInt& k,\n                                              RandomNumberGenerator& rng,\n                                              std::vector<BigInt>& ws) const\n   {\n   PointGFp_Var_Point_Precompute mul(point);\n   mul.randomize_repr(rng, ws);\n   return mul.mul(k, rng, get_order(), ws);\n   }\n\nPointGFp EC_Group::zero_point() const\n   {\n   return PointGFp(data().curve());\n   }\n\nstd::vector<uint8_t>\nEC_Group::DER_encode(EC_Group_Encoding form) const\n   {\n   std::vector<uint8_t> output;\n\n   DER_Encoder der(output);\n\n   if(form == EC_DOMPAR_ENC_EXPLICIT)\n      {\n      const size_t ecpVers1 = 1;\n      const OID curve_type(\"1.2.840.10045.1.1\"); // prime field\n\n      const size_t p_bytes = get_p_bytes();\n\n      der.start_cons(SEQUENCE)\n            .encode(ecpVers1)\n            .start_cons(SEQUENCE)\n               .encode(curve_type)\n               .encode(get_p())\n            .end_cons()\n            .start_cons(SEQUENCE)\n               .encode(BigInt::encode_1363(get_a(), p_bytes),\n                       OCTET_STRING)\n               .encode(BigInt::encode_1363(get_b(), p_bytes),\n                       OCTET_STRING)\n            .end_cons()\n              .encode(get_base_point().encode(PointGFp::UNCOMPRESSED), OCTET_STRING)\n            .encode(get_order())\n            .encode(get_cofactor())\n         .end_cons();\n      }\n   else if(form == EC_DOMPAR_ENC_OID)\n      {\n      const OID oid = get_curve_oid();\n      if(oid.empty())\n         {\n         throw Encoding_Error(\"Cannot encode EC_Group as OID because OID not set\");\n         }\n      der.encode(oid);\n      }\n   else if(form == EC_DOMPAR_ENC_IMPLICITCA)\n      {\n      der.encode_null();\n      }\n   else\n      {\n      throw Internal_Error(\"EC_Group::DER_encode: Unknown encoding\");\n      }\n\n   return output;\n   }\n\nstd::string EC_Group::PEM_encode() const\n   {\n   const std::vector<uint8_t> der = DER_encode(EC_DOMPAR_ENC_EXPLICIT);\n   return PEM_Code::encode(der, \"EC PARAMETERS\");\n   }\n\nbool EC_Group::operator==(const EC_Group& other) const\n   {\n   if(m_data == other.m_data)\n      return true; // same shared rep\n\n   /*\n   * No point comparing order/cofactor as they are uniquely determined\n   * by the curve equation (p,a,b) and the base point.\n   */\n   return (get_p() == other.get_p() &&\n           get_a() == other.get_a() &&\n           get_b() == other.get_b() &&\n           get_g_x() == other.get_g_x() &&\n           get_g_y() == other.get_g_y());\n   }\n\nbool EC_Group::verify_public_element(const PointGFp& point) const\n   {\n   //check that public point is not at infinity\n   if(point.is_zero())\n      return false;\n\n   //check that public point is on the curve\n   if(point.on_the_curve() == false)\n      return false;\n\n   //check that public point has order q\n   if((point * get_order()).is_zero() == false)\n      return false;\n\n   if(get_cofactor() > 1)\n      {\n      if((point * get_cofactor()).is_zero())\n         return false;\n      }\n\n   return true;\n   }\n\nbool EC_Group::verify_group(RandomNumberGenerator& rng,\n                            bool) const\n   {\n   //compute the discriminant\n   Modular_Reducer p(get_p());\n   BigInt discriminant = p.multiply(4, get_a());\n   discriminant += p.multiply(27, get_b());\n   discriminant = p.reduce(discriminant);\n   //check the discriminant\n   if(discriminant == 0)\n      {\n      return false;\n      }\n   //check for valid cofactor\n   if(get_cofactor() < 1)\n      {\n      return false;\n      }\n\n   const PointGFp base_point = get_base_point();\n\n   //check if the base point is on the curve\n   if(!base_point.on_the_curve())\n      {\n      return false;\n      }\n   if((base_point * get_cofactor()).is_zero())\n      {\n      return false;\n      }\n\n   const BigInt& order = get_order();\n\n   //check if order is prime\n   if(!is_prime(order, rng, 128))\n      {\n      return false;\n      }\n   //check if order of the base point is correct\n   if(!(base_point * order).is_zero())\n      {\n      return false;\n      }\n   return true;\n   }\n\n}\n", "/*\n* ECC Domain Parameters\n*\n* (C) 2007 Falko Strenzke, FlexSecure GmbH\n*     2008-2010 Jack Lloyd\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#ifndef BOTAN_ECC_DOMAIN_PARAMETERS_H_\n#define BOTAN_ECC_DOMAIN_PARAMETERS_H_\n\n#include <botan/point_gfp.h>\n#include <botan/asn1_oid.h>\n#include <memory>\n#include <set>\n\nnamespace Botan {\n\n/**\n* This class represents elliptic curce domain parameters\n*/\nenum EC_Group_Encoding {\n   EC_DOMPAR_ENC_EXPLICIT = 0,\n   EC_DOMPAR_ENC_IMPLICITCA = 1,\n   EC_DOMPAR_ENC_OID = 2\n};\n\nclass CurveGFp;\n\nclass EC_Group_Data;\nclass EC_Group_Data_Map;\n\n/**\n* Class representing an elliptic curve\n*\n* The internal representation is stored in a shared_ptr, so copying an\n* EC_Group is inexpensive.\n*/\nclass BOTAN_PUBLIC_API(2,0) EC_Group final\n   {\n   public:\n\n      /**\n      * Construct Domain paramers from specified parameters\n      * @param curve elliptic curve\n      * @param base_point a base point\n      * @param order the order of the base point\n      * @param cofactor the cofactor\n      */\n      BOTAN_DEPRECATED(\"Use version taking all BigInts\")\n      EC_Group(const CurveGFp& curve,\n               const PointGFp& base_point,\n               const BigInt& order,\n               const BigInt& cofactor) :\n         EC_Group(curve.get_p(),\n                  curve.get_a(),\n                  curve.get_b(),\n                  base_point.get_affine_x(),\n                  base_point.get_affine_y(),\n                  order,\n                  cofactor) {}\n\n      /**\n      * Construct Domain paramers from specified parameters\n      * @param p the elliptic curve p\n      * @param a the elliptic curve a param\n      * @param b the elliptic curve b param\n      * @param base_x the x coordinate of the base point\n      * @param base_y the y coordinate of the base point\n      * @param order the order of the base point\n      * @param cofactor the cofactor\n      * @param oid an optional OID used to identify this curve\n      */\n      EC_Group(const BigInt& p,\n               const BigInt& a,\n               const BigInt& b,\n               const BigInt& base_x,\n               const BigInt& base_y,\n               const BigInt& order,\n               const BigInt& cofactor,\n               const OID& oid = OID());\n\n      /**\n      * Decode a BER encoded ECC domain parameter set\n      * @param ber_encoding the bytes of the BER encoding\n      */\n      explicit EC_Group(const std::vector<uint8_t>& ber_encoding);\n\n      /**\n      * Create an EC domain by OID (or throw if unknown)\n      * @param oid the OID of the EC domain to create\n      */\n      explicit EC_Group(const OID& oid);\n\n      /**\n      * Create an EC domain from PEM encoding (as from PEM_encode), or\n      * from an OID name (eg \"secp256r1\", or \"1.2.840.10045.3.1.7\")\n      * @param pem_or_oid PEM-encoded data, or an OID\n      */\n      explicit EC_Group(const std::string& pem_or_oid);\n\n      /**\n      * Create an uninitialized EC_Group\n      */\n      EC_Group();\n\n      ~EC_Group();\n\n      /**\n      * Create the DER encoding of this domain\n      * @param form of encoding to use\n      * @returns bytes encododed as DER\n      */\n      std::vector<uint8_t> DER_encode(EC_Group_Encoding form) const;\n\n      /**\n      * Return the PEM encoding (always in explicit form)\n      * @return string containing PEM data\n      */\n      std::string PEM_encode() const;\n\n      /**\n      * Return domain parameter curve\n      * @result domain parameter curve\n      */\n      BOTAN_DEPRECATED(\"Avoid CurveGFp\") const CurveGFp& get_curve() const;\n\n      /**\n      * Return if a == -3 mod p\n      */\n      bool a_is_minus_3() const;\n\n      /**\n      * Return if a == 0 mod p\n      */\n      bool a_is_zero() const;\n\n      /**\n      * Return the size of p in bits (same as get_p().bits())\n      */\n      size_t get_p_bits() const;\n\n      /**\n      * Return the size of p in bits (same as get_p().bytes())\n      */\n      size_t get_p_bytes() const;\n\n      /**\n      * Return the size of group order in bits (same as get_order().bits())\n      */\n      size_t get_order_bits() const;\n\n      /**\n      * Return the size of p in bytes (same as get_order().bytes())\n      */\n      size_t get_order_bytes() const;\n\n      /**\n      * Return the prime modulus of the field\n      */\n      const BigInt& get_p() const;\n\n      /**\n      * Return the a parameter of the elliptic curve equation\n      */\n      const BigInt& get_a() const;\n\n      /**\n      * Return the b parameter of the elliptic curve equation\n      */\n      const BigInt& get_b() const;\n\n      /**\n      * Return group base point\n      * @result base point\n      */\n      const PointGFp& get_base_point() const;\n\n      /**\n      * Return the x coordinate of the base point\n      */\n      const BigInt& get_g_x() const;\n\n      /**\n      * Return the y coordinate of the base point\n      */\n      const BigInt& get_g_y() const;\n\n      /**\n      * Return the order of the base point\n      * @result order of the base point\n      */\n      const BigInt& get_order() const;\n\n      /*\n      * Reduce x modulo the order\n      */\n      BigInt mod_order(const BigInt& x) const;\n\n      /*\n      * Return inverse of x modulo the order\n      */\n      BigInt inverse_mod_order(const BigInt& x) const;\n\n      /*\n      * Reduce (x*x) modulo the order\n      */\n      BigInt square_mod_order(const BigInt& x) const;\n\n      /*\n      * Reduce (x*y) modulo the order\n      */\n      BigInt multiply_mod_order(const BigInt& x, const BigInt& y) const;\n\n      /*\n      * Reduce (x*y*z) modulo the order\n      */\n      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const;\n\n      /**\n      * Return the cofactor\n      * @result the cofactor\n      */\n      const BigInt& get_cofactor() const;\n\n      /**\n      * Check if y is a plausible point on the curve\n      *\n      * In particular, checks that it is a point on the curve, not infinity,\n      * and that it has order matching the group.\n      */\n      bool verify_public_element(const PointGFp& y) const;\n\n      /**\n      * Return the OID of these domain parameters\n      * @result the OID as a string\n      */\n      std::string BOTAN_DEPRECATED(\"Use get_curve_oid\") get_oid() const { return get_curve_oid().as_string(); }\n\n      /**\n      * Return the OID of these domain parameters\n      * @result the OID\n      */\n      const OID& get_curve_oid() const;\n\n      /**\n      * Return a point on this curve with the affine values x, y\n      */\n      PointGFp point(const BigInt& x, const BigInt& y) const;\n\n      /**\n      * Multi exponentiate. Not constant time.\n      * @return base_point*x + pt*y\n      */\n      PointGFp point_multiply(const BigInt& x, const PointGFp& pt, const BigInt& y) const;\n\n      /**\n      * Blinded point multiplication, attempts resistance to side channels\n      * @param k the scalar\n      * @param rng a random number generator\n      * @param ws a temp workspace\n      * @return base_point*k\n      */\n      PointGFp blinded_base_point_multiply(const BigInt& k,\n                                           RandomNumberGenerator& rng,\n                                           std::vector<BigInt>& ws) const;\n\n      /**\n      * Blinded point multiplication, attempts resistance to side channels\n      * Returns just the x coordinate of the point\n      *\n      * @param k the scalar\n      * @param rng a random number generator\n      * @param ws a temp workspace\n      * @return x coordinate of base_point*k\n      */\n      BigInt blinded_base_point_multiply_x(const BigInt& k,\n                                           RandomNumberGenerator& rng,\n                                           std::vector<BigInt>& ws) const;\n\n      /**\n      * Blinded point multiplication, attempts resistance to side channels\n      * @param point input point\n      * @param k the scalar\n      * @param rng a random number generator\n      * @param ws a temp workspace\n      * @return point*k\n      */\n      PointGFp blinded_var_point_multiply(const PointGFp& point,\n                                          const BigInt& k,\n                                          RandomNumberGenerator& rng,\n                                          std::vector<BigInt>& ws) const;\n\n      /**\n      * Return a random scalar ie an integer in [1,order)\n      */\n      BigInt random_scalar(RandomNumberGenerator& rng) const;\n\n      /**\n      * Return the zero (or infinite) point on this curve\n      */\n      PointGFp zero_point() const;\n\n      PointGFp OS2ECP(const uint8_t bits[], size_t len) const;\n\n      template<typename Alloc>\n      PointGFp OS2ECP(const std::vector<uint8_t, Alloc>& vec) const\n         {\n         return this->OS2ECP(vec.data(), vec.size());\n         }\n\n      bool initialized() const { return (m_data != nullptr); }\n\n      /**\n       * Verify EC_Group domain\n       * @returns true if group is valid. false otherwise\n       */\n      bool verify_group(RandomNumberGenerator& rng,\n                        bool strong = false) const;\n\n      bool operator==(const EC_Group& other) const;\n\n      /**\n      * Return PEM representation of named EC group\n      * Deprecated: Use EC_Group(name).PEM_encode() if this is needed\n      */\n      static std::string BOTAN_DEPRECATED(\"See header comment\") PEM_for_named_group(const std::string& name);\n\n      /**\n      * Return a set of known named EC groups\n      */\n      static const std::set<std::string>& known_named_groups();\n\n      /*\n      * For internal use only\n      */\n      static std::shared_ptr<EC_Group_Data> EC_group_info(const OID& oid);\n\n      static size_t clear_registered_curve_data();\n\n   private:\n      static EC_Group_Data_Map& ec_group_data();\n\n      static std::shared_ptr<EC_Group_Data> BER_decode_EC_group(const uint8_t bits[], size_t len);\n\n      static std::shared_ptr<EC_Group_Data>\n         load_EC_group_info(const char* p,\n                            const char* a,\n                            const char* b,\n                            const char* g_x,\n                            const char* g_y,\n                            const char* order,\n                            const OID& oid);\n\n      // Member data\n      const EC_Group_Data& data() const;\n      std::shared_ptr<EC_Group_Data> m_data;\n   };\n\ninline bool operator!=(const EC_Group& lhs,\n                       const EC_Group& rhs)\n   {\n   return !(lhs == rhs);\n   }\n\n// For compatibility with 1.8\ntypedef EC_Group EC_Domain_Params;\n\n}\n\n#endif\n", "/*\n* ECDSA implemenation\n* (C) 2007 Manuel Hartl, FlexSecure GmbH\n*     2007 Falko Strenzke, FlexSecure GmbH\n*     2008-2010,2015,2016,2018 Jack Lloyd\n*     2016 Ren\u00e9 Korthaus\n*\n* Botan is released under the Simplified BSD License (see license.txt)\n*/\n\n#include <botan/ecdsa.h>\n#include <botan/internal/pk_ops_impl.h>\n#include <botan/internal/point_mul.h>\n#include <botan/keypair.h>\n#include <botan/reducer.h>\n#include <botan/emsa.h>\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n  #include <botan/rfc6979.h>\n#endif\n\n#if defined(BOTAN_HAS_BEARSSL)\n  #include <botan/internal/bearssl.h>\n#endif\n\n#if defined(BOTAN_HAS_OPENSSL)\n  #include <botan/internal/openssl.h>\n#endif\n\nnamespace Botan {\n\nbool ECDSA_PrivateKey::check_key(RandomNumberGenerator& rng,\n                                 bool strong) const\n   {\n   if(!public_point().on_the_curve())\n      return false;\n\n   if(!strong)\n      return true;\n\n   return KeyPair::signature_consistency_check(rng, *this, \"EMSA1(SHA-256)\");\n   }\n\nnamespace {\n\n/**\n* ECDSA signature operation\n*/\nclass ECDSA_Signature_Operation final : public PK_Ops::Signature_with_EMSA\n   {\n   public:\n\n      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa,\n                                RandomNumberGenerator& rng) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n\n         m_b = m_group.random_scalar(rng);\n         m_b_inv = m_group.inverse_mod_order(m_b);\n         }\n\n      size_t max_input_bits() const override { return m_group.get_order_bits(); }\n\n      secure_vector<uint8_t> raw_sign(const uint8_t msg[], size_t msg_len,\n                                      RandomNumberGenerator& rng) override;\n\n   private:\n      const EC_Group m_group;\n      const BigInt& m_x;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n      std::string m_rfc6979_hash;\n#endif\n\n      std::vector<BigInt> m_ws;\n\n      BigInt m_b, m_b_inv;\n   };\n\nsecure_vector<uint8_t>\nECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                    RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len, m_group.get_order_bits());\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   const BigInt k = generate_rfc6979_nonce(m_x, m_group.get_order(), m, m_rfc6979_hash);\n#else\n   const BigInt k = m_group.random_scalar(rng);\n#endif\n\n   const BigInt r = m_group.mod_order(\n      m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n\n   const BigInt k_inv = m_group.inverse_mod_order(k);\n\n   /*\n   * Blind the input message and compute x*r+m as (x*r*b + m*b)/b\n   */\n   m_b = m_group.square_mod_order(m_b);\n   m_b_inv = m_group.square_mod_order(m_b_inv);\n\n   m = m_group.multiply_mod_order(m_b, m);\n   const BigInt xr = m_group.multiply_mod_order(m_x, m_b, r);\n\n   const BigInt s = m_group.multiply_mod_order(k_inv, xr + m, m_b_inv);\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"During ECDSA signature generated zero r/s\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, m_group.get_order_bytes());\n   }\n\n/**\n* ECDSA verification operation\n*/\nclass ECDSA_Verification_Operation final : public PK_Ops::Verification_with_EMSA\n   {\n   public:\n      ECDSA_Verification_Operation(const ECDSA_PublicKey& ecdsa,\n                                   const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_gy_mul(m_group.get_base_point(), ecdsa.public_point())\n         {\n         }\n\n      size_t max_input_bits() const override { return m_group.get_order_bits(); }\n\n      bool with_recovery() const override { return false; }\n\n      bool verify(const uint8_t msg[], size_t msg_len,\n                  const uint8_t sig[], size_t sig_len) override;\n   private:\n      const EC_Group m_group;\n      const PointGFp_Multi_Point_Precompute m_gy_mul;\n   };\n\nbool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                          const uint8_t sig[], size_t sig_len)\n   {\n   if(sig_len != m_group.get_order_bytes() * 2)\n      return false;\n\n   const BigInt e(msg, msg_len, m_group.get_order_bits());\n\n   const BigInt r(sig, sig_len / 2);\n   const BigInt s(sig + sig_len / 2, sig_len / 2);\n\n   if(r <= 0 || r >= m_group.get_order() || s <= 0 || s >= m_group.get_order())\n      return false;\n\n   const BigInt w = m_group.inverse_mod_order(s);\n\n   const BigInt u1 = m_group.multiply_mod_order(m_group.mod_order(e), w);\n   const BigInt u2 = m_group.multiply_mod_order(r, w);\n   const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n\n   if(R.is_zero())\n      return false;\n\n   const BigInt v = m_group.mod_order(R.get_affine_x());\n   return (v == r);\n   }\n\n}\n\nstd::unique_ptr<PK_Ops::Verification>\nECDSA_PublicKey::create_verification_op(const std::string& params,\n                                        const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_ver_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_ver_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Verification>(new ECDSA_Verification_Operation(*this, params));\n\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\nstd::unique_ptr<PK_Ops::Signature>\nECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& rng,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params, rng));\n\n   throw Provider_Not_Found(algo_name(), provider);\n   }\n\n}\n"], "filenames": ["doc/security.rst", "src/lib/pubkey/dsa/dsa.cpp", "src/lib/pubkey/ec_group/ec_group.cpp", "src/lib/pubkey/ec_group/ec_group.h", "src/lib/pubkey/ecdsa/ecdsa.cpp"], "buggy_code_start_loc": [19, 77, 86, 206, 54], "buggy_code_end_loc": [19, 202, 482, 209, 237], "fixing_code_start_loc": [20, 77, 87, 207, 54], "fixing_code_end_loc": [28, 220, 503, 220, 252], "type": "CWE-200", "message": "Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host.", "other": {"cve": {"id": "CVE-2018-12435", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-15T02:29:00.377", "lastModified": "2018-08-22T19:57:41.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host."}, {"lang": "es", "value": "Botan versi\u00f3n 2.5.0 hasta 2.6.0 anterior a 2.7.0, permite un ataque de canal lateral de memoria cach\u00e9 en firmas ECDSA, tambi\u00e9n se conoce como Problema del Retorno de N\u00famero Oculto o ROHNP, relacionado con los archivos  dsa/dsa.cpp, ec_group/ec_group.cpp, y ecdsa/ecdsa.cpp. Para descubrir una clave ECDSA, el atacante requiere acceso a la m\u00e1quina local o a una m\u00e1quina virtual diferente en el mismo host f\u00edsico."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:botan_project:botan:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndIncluding": "2.7.0", "matchCriteriaId": "416ED13A-040B-4ED0-ACAD-9EC53C2EBE6C"}]}]}], "references": [{"url": "https://botan.randombit.net/security.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/randombit/botan/commit/48fc8df51d99f9d8ba251219367b3d629cc848e3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.nccgroup.trust/us/our-research/technical-advisory-return-of-the-hidden-number-problem/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/randombit/botan/commit/48fc8df51d99f9d8ba251219367b3d629cc848e3"}}