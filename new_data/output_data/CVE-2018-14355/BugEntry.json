{"buggy_code": ["/**\n * @file\n * IMAP helper functions\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012-2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_util IMAP helper functions\n *\n * IMAP helper functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n/**\n * imap_expand_path - Canonicalise an IMAP path\n * @param path Buffer containing path\n * @param len  Buffer length\n * @retval  0 Success\n * @retval -1 Error\n *\n * IMAP implementation of mutt_expand_path. Rewrite an IMAP path in canonical\n * and absolute form.  The buffer is rewritten in place with the canonical IMAP\n * path.\n *\n * Function can fail if imap_parse_path() or url_tostring() fail,\n * of if the buffer isn't large enough.\n */\nint imap_expand_path(char *path, size_t len)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  struct Url url;\n  char fixedpath[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path(path, &mx) < 0)\n    return -1;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  mutt_account_tourl(&mx.account, &url);\n  imap_fix_path(idata, mx.mbox, fixedpath, sizeof(fixedpath));\n  url.path = fixedpath;\n\n  rc = url_tostring(&url, path, len, U_DECODE_PASSWD);\n  FREE(&mx.mbox);\n\n  return rc;\n}\n\n/**\n * imap_get_parent - Get an IMAP folder's parent\n * @param output Buffer for the result\n * @param mbox   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n * @param delim  Path delimiter\n */\nvoid imap_get_parent(char *output, const char *mbox, size_t olen, char delim)\n{\n  int n;\n\n  /* Make a copy of the mailbox name, but only if the pointers are different */\n  if (mbox != output)\n    mutt_str_strfcpy(output, mbox, olen);\n\n  n = mutt_str_strlen(output);\n\n  /* Let's go backwards until the next delimiter\n   *\n   * If output[n] is a '/', the first n-- will allow us\n   * to ignore it. If it isn't, then output looks like\n   * \"/aaaaa/bbbb\". There is at least one \"b\", so we can't skip\n   * the \"/\" after the 'a's.\n   *\n   * If output == '/', then n-- => n == 0, so the loop ends\n   * immediately\n   */\n  for (n--; n >= 0 && output[n] != delim; n--)\n    ;\n\n  /* We stopped before the beginning. There is a trailing\n   * slash.\n   */\n  if (n > 0)\n  {\n    /* Strip the trailing delimiter.  */\n    output[n] = '\\0';\n  }\n  else\n  {\n    output[0] = (n == 0) ? delim : '\\0';\n  }\n}\n\n/**\n * imap_get_parent_path - Get the path of the parent folder\n * @param output Buffer for the result\n * @param path   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n *\n * Provided an imap path, returns in output the parent directory if\n * existent. Else returns the same path.\n */\nvoid imap_get_parent_path(char *output, const char *path, size_t olen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Gets the parent mbox in mbox */\n  imap_get_parent(mbox, mbox, sizeof(mbox), idata->delim);\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(output, olen, &mx, mbox);\n  FREE(&mx.mbox);\n}\n\n/**\n * imap_clean_path - Cleans an IMAP path using imap_fix_path\n * @param path Path to be cleaned\n * @param plen Length of the buffer\n *\n * Does it in place.\n */\nvoid imap_clean_path(char *path, size_t plen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n    return;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n    return;\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(path, plen, &mx, mbox);\n}\n\n#ifdef USE_HCACHE\n/**\n * imap_hcache_namer - Generate a filename for the header cache\n * @param path Path for the header cache file\n * @param dest Buffer for result\n * @param dlen Length of buffer\n * @retval num Chars written to dest\n */\nstatic int imap_hcache_namer(const char *path, char *dest, size_t dlen)\n{\n  return snprintf(dest, dlen, \"%s.hcache\", path);\n}\n\n/**\n * imap_hcache_open - Open a header cache\n * @param idata Server data\n * @param path  Path to the header cache\n * @retval ptr HeaderCache\n * @retval NULL Failure\n */\nheader_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}\n\n/**\n * imap_hcache_close - Close the header cache\n * @param idata Server data\n */\nvoid imap_hcache_close(struct ImapData *idata)\n{\n  if (!idata->hcache)\n    return;\n\n  mutt_hcache_close(idata->hcache);\n  idata->hcache = NULL;\n}\n\n/**\n * imap_hcache_get - Get a header cache entry by its UID\n * @param idata Server data\n * @param uid   UID to find\n * @retval ptr Email Header\n * @retval NULL Failure\n */\nstruct Header *imap_hcache_get(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n  void *uv = NULL;\n  struct Header *h = NULL;\n\n  if (!idata->hcache)\n    return NULL;\n\n  sprintf(key, \"/%u\", uid);\n  uv = mutt_hcache_fetch(idata->hcache, key, imap_hcache_keylen(key));\n  if (uv)\n  {\n    if (*(unsigned int *) uv == idata->uid_validity)\n      h = mutt_hcache_restore(uv);\n    else\n      mutt_debug(3, \"hcache uidvalidity mismatch: %u\\n\", *(unsigned int *) uv);\n    mutt_hcache_free(idata->hcache, &uv);\n  }\n\n  return h;\n}\n\n/**\n * imap_hcache_put - Add an entry to the header cache\n * @param idata Server data\n * @param h     Email Header\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_put(struct ImapData *idata, struct Header *h)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", HEADER_DATA(h)->uid);\n  return mutt_hcache_store(idata->hcache, key, imap_hcache_keylen(key), h, idata->uid_validity);\n}\n\n/**\n * imap_hcache_del - Delete an item from the header cache\n * @param idata Server data\n * @param uid   UID of entry to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_del(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete(idata->hcache, key, imap_hcache_keylen(key));\n}\n#endif\n\n/**\n * imap_parse_path - Parse an IMAP mailbox name into name,host,port\n * @param path Mailbox path to parse\n * @param mx   An IMAP mailbox\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given an IMAP mailbox name, return host, port and a path IMAP servers will\n * recognize.  mx.mbox is malloc'd, caller must free it\n */\nint imap_parse_path(const char *path, struct ImapMbox *mx)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n  struct servent *service = NULL;\n  struct Url url;\n  char *c = NULL;\n\n  if (!ImapPort)\n  {\n    service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n  if (!ImapsPort)\n  {\n    service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n\n  /* Defaults */\n  memset(&mx->account, 0, sizeof(mx->account));\n  mx->account.port = ImapPort;\n  mx->account.type = MUTT_ACCT_TYPE_IMAP;\n\n  c = mutt_str_strdup(path);\n  url_parse(&url, c);\n  if (url.scheme == U_IMAP || url.scheme == U_IMAPS)\n  {\n    if (mutt_account_fromurl(&mx->account, &url) < 0 || !*mx->account.host)\n    {\n      url_free(&url);\n      FREE(&c);\n      return -1;\n    }\n\n    mx->mbox = mutt_str_strdup(url.path);\n\n    if (url.scheme == U_IMAPS)\n      mx->account.flags |= MUTT_ACCT_SSL;\n\n    url_free(&url);\n    FREE(&c);\n  }\n  /* old PINE-compatibility code */\n  else\n  {\n    url_free(&url);\n    FREE(&c);\n    char tmp[128];\n    if (sscanf(path, \"{%127[^}]}\", tmp) != 1)\n      return -1;\n\n    c = strchr(path, '}');\n    if (!c)\n      return -1;\n    else\n    {\n      /* walk past closing '}' */\n      mx->mbox = mutt_str_strdup(c + 1);\n    }\n\n    c = strrchr(tmp, '@');\n    if (c)\n    {\n      *c = '\\0';\n      mutt_str_strfcpy(mx->account.user, tmp, sizeof(mx->account.user));\n      mutt_str_strfcpy(tmp, c + 1, sizeof(tmp));\n      mx->account.flags |= MUTT_ACCT_USER;\n    }\n\n    const int n = sscanf(tmp, \"%127[^:/]%127s\", mx->account.host, tmp);\n    if (n < 1)\n    {\n      mutt_debug(1, \"NULL host in %s\\n\", path);\n      FREE(&mx->mbox);\n      return -1;\n    }\n\n    if (n > 1)\n    {\n      if (sscanf(tmp, \":%hu%127s\", &(mx->account.port), tmp) >= 1)\n        mx->account.flags |= MUTT_ACCT_PORT;\n      if (sscanf(tmp, \"/%s\", tmp) == 1)\n      {\n        if (mutt_str_strncmp(tmp, \"ssl\", 3) == 0)\n          mx->account.flags |= MUTT_ACCT_SSL;\n        else\n        {\n          mutt_debug(1, \"Unknown connection type in %s\\n\", path);\n          FREE(&mx->mbox);\n          return -1;\n        }\n      }\n    }\n  }\n\n  if ((mx->account.flags & MUTT_ACCT_SSL) && !(mx->account.flags & MUTT_ACCT_PORT))\n    mx->account.port = ImapsPort;\n\n  return 0;\n}\n\n/**\n * imap_mxcmp - Compare mailbox names, giving priority to INBOX\n * @param mx1 First mailbox name\n * @param mx2 Second mailbox name\n * @retval <0 First mailbox precedes Second mailbox\n * @retval  0 Mailboxes are the same\n * @retval >0 Second mailbox precedes First mailbox\n *\n * Like a normal sort function except that \"INBOX\" will be sorted to the\n * beginning of the list.\n */\nint imap_mxcmp(const char *mx1, const char *mx2)\n{\n  char *b1 = NULL;\n  char *b2 = NULL;\n  int rc;\n\n  if (!mx1 || !*mx1)\n    mx1 = \"INBOX\";\n  if (!mx2 || !*mx2)\n    mx2 = \"INBOX\";\n  if ((mutt_str_strcasecmp(mx1, \"INBOX\") == 0) &&\n      (mutt_str_strcasecmp(mx2, \"INBOX\") == 0))\n  {\n    return 0;\n  }\n\n  b1 = mutt_mem_malloc(strlen(mx1) + 1);\n  b2 = mutt_mem_malloc(strlen(mx2) + 1);\n\n  imap_fix_path(NULL, mx1, b1, strlen(mx1) + 1);\n  imap_fix_path(NULL, mx2, b2, strlen(mx2) + 1);\n\n  rc = mutt_str_strcmp(b1, b2);\n  FREE(&b1);\n  FREE(&b2);\n\n  return rc;\n}\n\n/**\n * imap_pretty_mailbox - Prettify an IMAP mailbox name\n * @param path Mailbox name to be tidied\n *\n * Called by mutt_pretty_mailbox() to make IMAP paths look nice.\n */\nvoid imap_pretty_mailbox(char *path)\n{\n  struct ImapMbox home, target;\n  struct Url url;\n  char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n\n  if (imap_parse_path(path, &target) < 0)\n    return;\n\n  tlen = mutt_str_strlen(target.mbox);\n  /* check whether we can do '=' substitution */\n  if (mx_is_imap(Folder) && !imap_parse_path(Folder, &home))\n  {\n    hlen = mutt_str_strlen(home.mbox);\n    if (tlen && mutt_account_match(&home.account, &target.account) &&\n        (mutt_str_strncmp(home.mbox, target.mbox, hlen) == 0))\n    {\n      if (hlen == 0)\n        home_match = true;\n      else if (ImapDelimChars)\n      {\n        for (delim = ImapDelimChars; *delim != '\\0'; delim++)\n          if (target.mbox[hlen] == *delim)\n            home_match = true;\n      }\n    }\n    FREE(&home.mbox);\n  }\n\n  /* do the '=' substitution */\n  if (home_match)\n  {\n    *path++ = '=';\n    /* copy remaining path, skipping delimiter */\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target.mbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n  }\n  else\n  {\n    mutt_account_tourl(&target.account, &url);\n    url.path = target.mbox;\n    /* FIXME: That hard-coded constant is bogus. But we need the actual\n     *   size of the buffer from mutt_pretty_mailbox. And these pretty\n     *   operations usually shrink the result. Still... */\n    url_tostring(&url, path, 1024, 0);\n  }\n\n  FREE(&target.mbox);\n}\n\n/**\n * imap_continue - display a message and ask the user if they want to go on\n * @param msg  Location of the error\n * @param resp Message for user\n * @retval num Result: #MUTT_YES, #MUTT_NO, #MUTT_ABORT\n */\nint imap_continue(const char *msg, const char *resp)\n{\n  imap_error(msg, resp);\n  return mutt_yesorno(_(\"Continue?\"), 0);\n}\n\n/**\n * imap_error - show an error and abort\n * @param where Location of the error\n * @param msg   Message for user\n */\nvoid imap_error(const char *where, const char *msg)\n{\n  mutt_error(\"%s [%s]\\n\", where, msg);\n}\n\n/**\n * imap_new_idata - Allocate and initialise a new ImapData structure\n * @retval NULL Failure (no mem)\n * @retval ptr New ImapData\n */\nstruct ImapData *imap_new_idata(void)\n{\n  struct ImapData *idata = mutt_mem_calloc(1, sizeof(struct ImapData));\n\n  idata->cmdbuf = mutt_buffer_new();\n  idata->cmdslots = ImapPipelineDepth + 2;\n  idata->cmds = mutt_mem_calloc(idata->cmdslots, sizeof(*idata->cmds));\n\n  STAILQ_INIT(&idata->flags);\n  STAILQ_INIT(&idata->mboxcache);\n\n  return idata;\n}\n\n/**\n * imap_free_idata - Release and clear storage in an ImapData structure\n * @param idata Server data\n */\nvoid imap_free_idata(struct ImapData **idata)\n{\n  if (!idata)\n    return;\n\n  FREE(&(*idata)->capstr);\n  mutt_list_free(&(*idata)->flags);\n  imap_mboxcache_free(*idata);\n  mutt_buffer_free(&(*idata)->cmdbuf);\n  FREE(&(*idata)->buf);\n  mutt_bcache_close(&(*idata)->bcache);\n  FREE(&(*idata)->cmds);\n  FREE(idata);\n}\n\n/**\n * imap_fix_path - Fix up the imap path\n * @param idata   Server data\n * @param mailbox Mailbox path\n * @param path    Buffer for the result\n * @param plen    Length of buffer\n * @retval ptr Fixed-up path\n *\n * This is necessary because the rest of neomutt assumes a hierarchy delimiter of\n * '/', which is not necessarily true in IMAP.  Additionally, the filesystem\n * converts multiple hierarchy delimiters into a single one, ie \"///\" is equal\n * to \"/\".  IMAP servers are not required to do this.\n * Moreover, IMAP servers may dislike the path ending with the delimiter.\n */\nchar *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen)\n{\n  int i = 0;\n  char delim = '\\0';\n\n  if (idata)\n    delim = idata->delim;\n\n  while (mailbox && *mailbox && i < plen - 1)\n  {\n    if ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) || (delim && *mailbox == delim))\n    {\n      /* use connection delimiter if known. Otherwise use user delimiter */\n      if (!idata)\n        delim = *mailbox;\n\n      while (*mailbox && ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) ||\n                          (delim && *mailbox == delim)))\n      {\n        mailbox++;\n      }\n      path[i] = delim;\n    }\n    else\n    {\n      path[i] = *mailbox;\n      mailbox++;\n    }\n    i++;\n  }\n  if (i && path[--i] != delim)\n    i++;\n  path[i] = '\\0';\n\n  return path;\n}\n\n/**\n * imap_cachepath - Generate a cache path for a mailbox\n * @param idata   Server data\n * @param mailbox Mailbox name\n * @param dest    Buffer to store cache path\n * @param dlen    Length of buffer\n */\nvoid imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)\n{\n  char *s = NULL;\n  const char *p = mailbox;\n\n  for (s = dest; p && *p && dlen; dlen--)\n  {\n    if (*p == idata->delim)\n    {\n      *s = '/';\n      /* simple way to avoid collisions with UIDs */\n      if (*(p + 1) >= '0' && *(p + 1) <= '9')\n      {\n        if (--dlen)\n          *++s = '_';\n      }\n    }\n    else\n      *s = *p;\n    p++;\n    s++;\n  }\n  *s = '\\0';\n}\n\n/**\n * imap_get_literal_count - write number of bytes in an IMAP literal into bytes\n * @param[in]  buf   Number as a string\n * @param[out] bytes Resulting number\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_get_literal_count(const char *buf, unsigned int *bytes)\n{\n  char *pc = NULL;\n  char *pn = NULL;\n\n  if (!buf || !(pc = strchr(buf, '{')))\n    return -1;\n\n  pc++;\n  pn = pc;\n  while (isdigit((unsigned char) *pc))\n    pc++;\n  *pc = '\\0';\n  if (mutt_str_atoui(pn, bytes) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_get_qualifier - Get the qualifier from a tagged response\n * @param buf Command string to process\n * @retval ptr Start of the qualifier\n *\n * In a tagged response, skip tag and status for the qualifier message.\n * Used by imap_copy_message for TRYCREATE\n */\nchar *imap_get_qualifier(char *buf)\n{\n  char *s = buf;\n\n  /* skip tag */\n  s = imap_next_word(s);\n  /* skip OK/NO/BAD response */\n  s = imap_next_word(s);\n\n  return s;\n}\n\n/**\n * imap_next_word - Find where the next IMAP word begins\n * @param s Command string to process\n * @retval ptr Next IMAP word\n */\nchar *imap_next_word(char *s)\n{\n  int quoted = 0;\n\n  while (*s)\n  {\n    if (*s == '\\\\')\n    {\n      s++;\n      if (*s)\n        s++;\n      continue;\n    }\n    if (*s == '\\\"')\n      quoted = quoted ? 0 : 1;\n    if (!quoted && ISSPACE(*s))\n      break;\n    s++;\n  }\n\n  SKIPWS(s);\n  return s;\n}\n\n/**\n * imap_qualify_path - Make an absolute IMAP folder target\n * @param dest Buffer for the result\n * @param len  Length of buffer\n * @param mx   Imap mailbox\n * @param path Path relative to the mailbox\n *\n * given ImapMbox and relative path.\n */\nvoid imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n{\n  struct Url url;\n\n  mutt_account_tourl(&mx->account, &url);\n  url.path = path;\n\n  url_tostring(&url, dest, len, 0);\n}\n\n/**\n * imap_quote_string - quote string according to IMAP rules\n * @param dest Buffer for the result\n * @param dlen Length of the buffer\n * @param src  String to be quoted\n *\n * Surround string with quotes, escape \" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\"')\n    s++;\n  else\n    return;\n\n  while (*s)\n  {\n    if (*s == '\\\"')\n    {\n      *d = '\\0';\n      return;\n    }\n    if (*s == '\\\\')\n    {\n      s++;\n    }\n    if (*s)\n    {\n      *d = *s;\n      d++;\n      s++;\n    }\n  }\n  *d = '\\0';\n}\n\n/**\n * imap_munge_mbox_name - Quote awkward characters in a mailbox name\n * @param idata Server data\n * @param dest  Buffer to store safe mailbox name\n * @param dlen  Length of buffer\n * @param src   Mailbox name\n */\nvoid imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}\n\n/**\n * imap_unmunge_mbox_name - Remove quoting from a mailbox name\n * @param idata Server data\n * @param s     Mailbox name\n *\n * The string will be altered in-place.\n */\nvoid imap_unmunge_mbox_name(struct ImapData *idata, char *s)\n{\n  imap_unquote_string(s);\n\n  char *buf = mutt_str_strdup(s);\n  if (buf)\n  {\n    imap_utf_decode(idata, &buf);\n    strncpy(s, buf, strlen(s));\n  }\n\n  FREE(&buf);\n}\n\n/**\n * imap_keepalive - poll the current folder to keep the connection alive\n */\nvoid imap_keepalive(void)\n{\n  struct Connection *conn = NULL;\n  struct ImapData *idata = NULL;\n  time_t now = time(NULL);\n\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    if (conn->account.type == MUTT_ACCT_TYPE_IMAP)\n    {\n      idata = conn->data;\n      if (idata->state >= IMAP_AUTHENTICATED && now >= idata->lastread + ImapKeepalive)\n      {\n        imap_check(idata, 1);\n      }\n    }\n  }\n}\n\n/**\n * imap_wait_keepalive - Wait for a process to change state\n * @param pid Process ID to listen to\n * @retval num 'wstatus' from waitpid()\n */\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n\n  bool imap_passive = ImapPassive;\n\n  ImapPassive = true;\n  OptKeepQuiet = true;\n\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n\n  sigaction(SIGALRM, &act, &oldalrm);\n\n  alarm(ImapKeepalive);\n  while (waitpid(pid, &rc, 0) < 0 && errno == EINTR)\n  {\n    alarm(0); /* cancel a possibly pending alarm */\n    imap_keepalive();\n    alarm(ImapKeepalive);\n  }\n\n  alarm(0); /* cancel a possibly pending alarm */\n\n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n  OptKeepQuiet = false;\n  if (!imap_passive)\n    ImapPassive = false;\n\n  return rc;\n}\n\n/**\n * imap_allow_reopen - Allow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_allow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_disallow_reopen - Disallow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_disallow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen &= ~IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_account_match - Compare two Accounts\n * @param a1 First Account\n * @param a2 Second Account\n * @retval true Accounts match\n */\nint imap_account_match(const struct Account *a1, const struct Account *a2)\n{\n  struct ImapData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);\n  struct ImapData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);\n  const struct Account *a1_canon = a1_idata == NULL ? a1 : &a1_idata->conn->account;\n  const struct Account *a2_canon = a2_idata == NULL ? a2 : &a2_idata->conn->account;\n\n  return mutt_account_match(a1_canon, a2_canon);\n}\n"], "fixing_code": ["/**\n * @file\n * IMAP helper functions\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012-2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_util IMAP helper functions\n *\n * IMAP helper functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n/**\n * imap_expand_path - Canonicalise an IMAP path\n * @param path Buffer containing path\n * @param len  Buffer length\n * @retval  0 Success\n * @retval -1 Error\n *\n * IMAP implementation of mutt_expand_path. Rewrite an IMAP path in canonical\n * and absolute form.  The buffer is rewritten in place with the canonical IMAP\n * path.\n *\n * Function can fail if imap_parse_path() or url_tostring() fail,\n * of if the buffer isn't large enough.\n */\nint imap_expand_path(char *path, size_t len)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  struct Url url;\n  char fixedpath[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path(path, &mx) < 0)\n    return -1;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  mutt_account_tourl(&mx.account, &url);\n  imap_fix_path(idata, mx.mbox, fixedpath, sizeof(fixedpath));\n  url.path = fixedpath;\n\n  rc = url_tostring(&url, path, len, U_DECODE_PASSWD);\n  FREE(&mx.mbox);\n\n  return rc;\n}\n\n/**\n * imap_get_parent - Get an IMAP folder's parent\n * @param output Buffer for the result\n * @param mbox   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n * @param delim  Path delimiter\n */\nvoid imap_get_parent(char *output, const char *mbox, size_t olen, char delim)\n{\n  int n;\n\n  /* Make a copy of the mailbox name, but only if the pointers are different */\n  if (mbox != output)\n    mutt_str_strfcpy(output, mbox, olen);\n\n  n = mutt_str_strlen(output);\n\n  /* Let's go backwards until the next delimiter\n   *\n   * If output[n] is a '/', the first n-- will allow us\n   * to ignore it. If it isn't, then output looks like\n   * \"/aaaaa/bbbb\". There is at least one \"b\", so we can't skip\n   * the \"/\" after the 'a's.\n   *\n   * If output == '/', then n-- => n == 0, so the loop ends\n   * immediately\n   */\n  for (n--; n >= 0 && output[n] != delim; n--)\n    ;\n\n  /* We stopped before the beginning. There is a trailing\n   * slash.\n   */\n  if (n > 0)\n  {\n    /* Strip the trailing delimiter.  */\n    output[n] = '\\0';\n  }\n  else\n  {\n    output[0] = (n == 0) ? delim : '\\0';\n  }\n}\n\n/**\n * imap_get_parent_path - Get the path of the parent folder\n * @param output Buffer for the result\n * @param path   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n *\n * Provided an imap path, returns in output the parent directory if\n * existent. Else returns the same path.\n */\nvoid imap_get_parent_path(char *output, const char *path, size_t olen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Gets the parent mbox in mbox */\n  imap_get_parent(mbox, mbox, sizeof(mbox), idata->delim);\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(output, olen, &mx, mbox);\n  FREE(&mx.mbox);\n}\n\n/**\n * imap_clean_path - Cleans an IMAP path using imap_fix_path\n * @param path Path to be cleaned\n * @param plen Length of the buffer\n *\n * Does it in place.\n */\nvoid imap_clean_path(char *path, size_t plen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n    return;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n    return;\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(path, plen, &mx, mbox);\n}\n\n#ifdef USE_HCACHE\n/**\n * imap_hcache_namer - Generate a filename for the header cache\n * @param path Path for the header cache file\n * @param dest Buffer for result\n * @param dlen Length of buffer\n * @retval num Chars written to dest\n */\nstatic int imap_hcache_namer(const char *path, char *dest, size_t dlen)\n{\n  return snprintf(dest, dlen, \"%s.hcache\", path);\n}\n\n/**\n * imap_hcache_open - Open a header cache\n * @param idata Server data\n * @param path  Path to the header cache\n * @retval ptr HeaderCache\n * @retval NULL Failure\n */\nheader_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}\n\n/**\n * imap_hcache_close - Close the header cache\n * @param idata Server data\n */\nvoid imap_hcache_close(struct ImapData *idata)\n{\n  if (!idata->hcache)\n    return;\n\n  mutt_hcache_close(idata->hcache);\n  idata->hcache = NULL;\n}\n\n/**\n * imap_hcache_get - Get a header cache entry by its UID\n * @param idata Server data\n * @param uid   UID to find\n * @retval ptr Email Header\n * @retval NULL Failure\n */\nstruct Header *imap_hcache_get(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n  void *uv = NULL;\n  struct Header *h = NULL;\n\n  if (!idata->hcache)\n    return NULL;\n\n  sprintf(key, \"/%u\", uid);\n  uv = mutt_hcache_fetch(idata->hcache, key, imap_hcache_keylen(key));\n  if (uv)\n  {\n    if (*(unsigned int *) uv == idata->uid_validity)\n      h = mutt_hcache_restore(uv);\n    else\n      mutt_debug(3, \"hcache uidvalidity mismatch: %u\\n\", *(unsigned int *) uv);\n    mutt_hcache_free(idata->hcache, &uv);\n  }\n\n  return h;\n}\n\n/**\n * imap_hcache_put - Add an entry to the header cache\n * @param idata Server data\n * @param h     Email Header\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_put(struct ImapData *idata, struct Header *h)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", HEADER_DATA(h)->uid);\n  return mutt_hcache_store(idata->hcache, key, imap_hcache_keylen(key), h, idata->uid_validity);\n}\n\n/**\n * imap_hcache_del - Delete an item from the header cache\n * @param idata Server data\n * @param uid   UID of entry to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_del(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete(idata->hcache, key, imap_hcache_keylen(key));\n}\n#endif\n\n/**\n * imap_parse_path - Parse an IMAP mailbox name into name,host,port\n * @param path Mailbox path to parse\n * @param mx   An IMAP mailbox\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given an IMAP mailbox name, return host, port and a path IMAP servers will\n * recognize.  mx.mbox is malloc'd, caller must free it\n */\nint imap_parse_path(const char *path, struct ImapMbox *mx)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n  struct servent *service = NULL;\n  struct Url url;\n  char *c = NULL;\n\n  if (!ImapPort)\n  {\n    service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n  if (!ImapsPort)\n  {\n    service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n\n  /* Defaults */\n  memset(&mx->account, 0, sizeof(mx->account));\n  mx->account.port = ImapPort;\n  mx->account.type = MUTT_ACCT_TYPE_IMAP;\n\n  c = mutt_str_strdup(path);\n  url_parse(&url, c);\n  if (url.scheme == U_IMAP || url.scheme == U_IMAPS)\n  {\n    if (mutt_account_fromurl(&mx->account, &url) < 0 || !*mx->account.host)\n    {\n      url_free(&url);\n      FREE(&c);\n      return -1;\n    }\n\n    mx->mbox = mutt_str_strdup(url.path);\n\n    if (url.scheme == U_IMAPS)\n      mx->account.flags |= MUTT_ACCT_SSL;\n\n    url_free(&url);\n    FREE(&c);\n  }\n  /* old PINE-compatibility code */\n  else\n  {\n    url_free(&url);\n    FREE(&c);\n    char tmp[128];\n    if (sscanf(path, \"{%127[^}]}\", tmp) != 1)\n      return -1;\n\n    c = strchr(path, '}');\n    if (!c)\n      return -1;\n    else\n    {\n      /* walk past closing '}' */\n      mx->mbox = mutt_str_strdup(c + 1);\n    }\n\n    c = strrchr(tmp, '@');\n    if (c)\n    {\n      *c = '\\0';\n      mutt_str_strfcpy(mx->account.user, tmp, sizeof(mx->account.user));\n      mutt_str_strfcpy(tmp, c + 1, sizeof(tmp));\n      mx->account.flags |= MUTT_ACCT_USER;\n    }\n\n    const int n = sscanf(tmp, \"%127[^:/]%127s\", mx->account.host, tmp);\n    if (n < 1)\n    {\n      mutt_debug(1, \"NULL host in %s\\n\", path);\n      FREE(&mx->mbox);\n      return -1;\n    }\n\n    if (n > 1)\n    {\n      if (sscanf(tmp, \":%hu%127s\", &(mx->account.port), tmp) >= 1)\n        mx->account.flags |= MUTT_ACCT_PORT;\n      if (sscanf(tmp, \"/%s\", tmp) == 1)\n      {\n        if (mutt_str_strncmp(tmp, \"ssl\", 3) == 0)\n          mx->account.flags |= MUTT_ACCT_SSL;\n        else\n        {\n          mutt_debug(1, \"Unknown connection type in %s\\n\", path);\n          FREE(&mx->mbox);\n          return -1;\n        }\n      }\n    }\n  }\n\n  if ((mx->account.flags & MUTT_ACCT_SSL) && !(mx->account.flags & MUTT_ACCT_PORT))\n    mx->account.port = ImapsPort;\n\n  return 0;\n}\n\n/**\n * imap_mxcmp - Compare mailbox names, giving priority to INBOX\n * @param mx1 First mailbox name\n * @param mx2 Second mailbox name\n * @retval <0 First mailbox precedes Second mailbox\n * @retval  0 Mailboxes are the same\n * @retval >0 Second mailbox precedes First mailbox\n *\n * Like a normal sort function except that \"INBOX\" will be sorted to the\n * beginning of the list.\n */\nint imap_mxcmp(const char *mx1, const char *mx2)\n{\n  char *b1 = NULL;\n  char *b2 = NULL;\n  int rc;\n\n  if (!mx1 || !*mx1)\n    mx1 = \"INBOX\";\n  if (!mx2 || !*mx2)\n    mx2 = \"INBOX\";\n  if ((mutt_str_strcasecmp(mx1, \"INBOX\") == 0) &&\n      (mutt_str_strcasecmp(mx2, \"INBOX\") == 0))\n  {\n    return 0;\n  }\n\n  b1 = mutt_mem_malloc(strlen(mx1) + 1);\n  b2 = mutt_mem_malloc(strlen(mx2) + 1);\n\n  imap_fix_path(NULL, mx1, b1, strlen(mx1) + 1);\n  imap_fix_path(NULL, mx2, b2, strlen(mx2) + 1);\n\n  rc = mutt_str_strcmp(b1, b2);\n  FREE(&b1);\n  FREE(&b2);\n\n  return rc;\n}\n\n/**\n * imap_pretty_mailbox - Prettify an IMAP mailbox name\n * @param path Mailbox name to be tidied\n *\n * Called by mutt_pretty_mailbox() to make IMAP paths look nice.\n */\nvoid imap_pretty_mailbox(char *path)\n{\n  struct ImapMbox home, target;\n  struct Url url;\n  char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n\n  if (imap_parse_path(path, &target) < 0)\n    return;\n\n  tlen = mutt_str_strlen(target.mbox);\n  /* check whether we can do '=' substitution */\n  if (mx_is_imap(Folder) && !imap_parse_path(Folder, &home))\n  {\n    hlen = mutt_str_strlen(home.mbox);\n    if (tlen && mutt_account_match(&home.account, &target.account) &&\n        (mutt_str_strncmp(home.mbox, target.mbox, hlen) == 0))\n    {\n      if (hlen == 0)\n        home_match = true;\n      else if (ImapDelimChars)\n      {\n        for (delim = ImapDelimChars; *delim != '\\0'; delim++)\n          if (target.mbox[hlen] == *delim)\n            home_match = true;\n      }\n    }\n    FREE(&home.mbox);\n  }\n\n  /* do the '=' substitution */\n  if (home_match)\n  {\n    *path++ = '=';\n    /* copy remaining path, skipping delimiter */\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target.mbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n  }\n  else\n  {\n    mutt_account_tourl(&target.account, &url);\n    url.path = target.mbox;\n    /* FIXME: That hard-coded constant is bogus. But we need the actual\n     *   size of the buffer from mutt_pretty_mailbox. And these pretty\n     *   operations usually shrink the result. Still... */\n    url_tostring(&url, path, 1024, 0);\n  }\n\n  FREE(&target.mbox);\n}\n\n/**\n * imap_continue - display a message and ask the user if they want to go on\n * @param msg  Location of the error\n * @param resp Message for user\n * @retval num Result: #MUTT_YES, #MUTT_NO, #MUTT_ABORT\n */\nint imap_continue(const char *msg, const char *resp)\n{\n  imap_error(msg, resp);\n  return mutt_yesorno(_(\"Continue?\"), 0);\n}\n\n/**\n * imap_error - show an error and abort\n * @param where Location of the error\n * @param msg   Message for user\n */\nvoid imap_error(const char *where, const char *msg)\n{\n  mutt_error(\"%s [%s]\\n\", where, msg);\n}\n\n/**\n * imap_new_idata - Allocate and initialise a new ImapData structure\n * @retval NULL Failure (no mem)\n * @retval ptr New ImapData\n */\nstruct ImapData *imap_new_idata(void)\n{\n  struct ImapData *idata = mutt_mem_calloc(1, sizeof(struct ImapData));\n\n  idata->cmdbuf = mutt_buffer_new();\n  idata->cmdslots = ImapPipelineDepth + 2;\n  idata->cmds = mutt_mem_calloc(idata->cmdslots, sizeof(*idata->cmds));\n\n  STAILQ_INIT(&idata->flags);\n  STAILQ_INIT(&idata->mboxcache);\n\n  return idata;\n}\n\n/**\n * imap_free_idata - Release and clear storage in an ImapData structure\n * @param idata Server data\n */\nvoid imap_free_idata(struct ImapData **idata)\n{\n  if (!idata)\n    return;\n\n  FREE(&(*idata)->capstr);\n  mutt_list_free(&(*idata)->flags);\n  imap_mboxcache_free(*idata);\n  mutt_buffer_free(&(*idata)->cmdbuf);\n  FREE(&(*idata)->buf);\n  mutt_bcache_close(&(*idata)->bcache);\n  FREE(&(*idata)->cmds);\n  FREE(idata);\n}\n\n/**\n * imap_fix_path - Fix up the imap path\n * @param idata   Server data\n * @param mailbox Mailbox path\n * @param path    Buffer for the result\n * @param plen    Length of buffer\n * @retval ptr Fixed-up path\n *\n * This is necessary because the rest of neomutt assumes a hierarchy delimiter of\n * '/', which is not necessarily true in IMAP.  Additionally, the filesystem\n * converts multiple hierarchy delimiters into a single one, ie \"///\" is equal\n * to \"/\".  IMAP servers are not required to do this.\n * Moreover, IMAP servers may dislike the path ending with the delimiter.\n */\nchar *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen)\n{\n  int i = 0;\n  char delim = '\\0';\n\n  if (idata)\n    delim = idata->delim;\n\n  while (mailbox && *mailbox && i < plen - 1)\n  {\n    if ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) || (delim && *mailbox == delim))\n    {\n      /* use connection delimiter if known. Otherwise use user delimiter */\n      if (!idata)\n        delim = *mailbox;\n\n      while (*mailbox && ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) ||\n                          (delim && *mailbox == delim)))\n      {\n        mailbox++;\n      }\n      path[i] = delim;\n    }\n    else\n    {\n      path[i] = *mailbox;\n      mailbox++;\n    }\n    i++;\n  }\n  if (i && path[--i] != delim)\n    i++;\n  path[i] = '\\0';\n\n  return path;\n}\n\n/**\n * imap_cachepath - Generate a cache path for a mailbox\n * @param idata   Server data\n * @param mailbox Mailbox name\n * @param dest    Buffer to store cache path\n * @param dlen    Length of buffer\n */\nvoid imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)\n{\n  char *s = NULL;\n  const char *p = mailbox;\n\n  for (s = dest; p && *p && dlen; dlen--)\n  {\n    if (*p == idata->delim)\n    {\n      *s = '/';\n      /* simple way to avoid collisions with UIDs */\n      if (*(p + 1) >= '0' && *(p + 1) <= '9')\n      {\n        if (--dlen)\n          *++s = '_';\n      }\n    }\n    else\n      *s = *p;\n    p++;\n    s++;\n  }\n  *s = '\\0';\n}\n\n/**\n * imap_get_literal_count - write number of bytes in an IMAP literal into bytes\n * @param[in]  buf   Number as a string\n * @param[out] bytes Resulting number\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_get_literal_count(const char *buf, unsigned int *bytes)\n{\n  char *pc = NULL;\n  char *pn = NULL;\n\n  if (!buf || !(pc = strchr(buf, '{')))\n    return -1;\n\n  pc++;\n  pn = pc;\n  while (isdigit((unsigned char) *pc))\n    pc++;\n  *pc = '\\0';\n  if (mutt_str_atoui(pn, bytes) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_get_qualifier - Get the qualifier from a tagged response\n * @param buf Command string to process\n * @retval ptr Start of the qualifier\n *\n * In a tagged response, skip tag and status for the qualifier message.\n * Used by imap_copy_message for TRYCREATE\n */\nchar *imap_get_qualifier(char *buf)\n{\n  char *s = buf;\n\n  /* skip tag */\n  s = imap_next_word(s);\n  /* skip OK/NO/BAD response */\n  s = imap_next_word(s);\n\n  return s;\n}\n\n/**\n * imap_next_word - Find where the next IMAP word begins\n * @param s Command string to process\n * @retval ptr Next IMAP word\n */\nchar *imap_next_word(char *s)\n{\n  int quoted = 0;\n\n  while (*s)\n  {\n    if (*s == '\\\\')\n    {\n      s++;\n      if (*s)\n        s++;\n      continue;\n    }\n    if (*s == '\\\"')\n      quoted = quoted ? 0 : 1;\n    if (!quoted && ISSPACE(*s))\n      break;\n    s++;\n  }\n\n  SKIPWS(s);\n  return s;\n}\n\n/**\n * imap_qualify_path - Make an absolute IMAP folder target\n * @param dest Buffer for the result\n * @param len  Length of buffer\n * @param mx   Imap mailbox\n * @param path Path relative to the mailbox\n *\n * given ImapMbox and relative path.\n */\nvoid imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n{\n  struct Url url;\n\n  mutt_account_tourl(&mx->account, &url);\n  url.path = path;\n\n  url_tostring(&url, dest, len, 0);\n}\n\n/**\n * imap_quote_string - quote string according to IMAP rules\n * @param dest Buffer for the result\n * @param dlen Length of the buffer\n * @param src  String to be quoted\n *\n * Surround string with quotes, escape \" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\"')\n    s++;\n  else\n    return;\n\n  while (*s)\n  {\n    if (*s == '\\\"')\n    {\n      *d = '\\0';\n      return;\n    }\n    if (*s == '\\\\')\n    {\n      s++;\n    }\n    if (*s)\n    {\n      *d = *s;\n      d++;\n      s++;\n    }\n  }\n  *d = '\\0';\n}\n\n/**\n * imap_munge_mbox_name - Quote awkward characters in a mailbox name\n * @param idata Server data\n * @param dest  Buffer to store safe mailbox name\n * @param dlen  Length of buffer\n * @param src   Mailbox name\n */\nvoid imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}\n\n/**\n * imap_unmunge_mbox_name - Remove quoting from a mailbox name\n * @param idata Server data\n * @param s     Mailbox name\n *\n * The string will be altered in-place.\n */\nvoid imap_unmunge_mbox_name(struct ImapData *idata, char *s)\n{\n  imap_unquote_string(s);\n\n  char *buf = mutt_str_strdup(s);\n  if (buf)\n  {\n    imap_utf_decode(idata, &buf);\n    strncpy(s, buf, strlen(s));\n  }\n\n  FREE(&buf);\n}\n\n/**\n * imap_keepalive - poll the current folder to keep the connection alive\n */\nvoid imap_keepalive(void)\n{\n  struct Connection *conn = NULL;\n  struct ImapData *idata = NULL;\n  time_t now = time(NULL);\n\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    if (conn->account.type == MUTT_ACCT_TYPE_IMAP)\n    {\n      idata = conn->data;\n      if (idata->state >= IMAP_AUTHENTICATED && now >= idata->lastread + ImapKeepalive)\n      {\n        imap_check(idata, 1);\n      }\n    }\n  }\n}\n\n/**\n * imap_wait_keepalive - Wait for a process to change state\n * @param pid Process ID to listen to\n * @retval num 'wstatus' from waitpid()\n */\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n\n  bool imap_passive = ImapPassive;\n\n  ImapPassive = true;\n  OptKeepQuiet = true;\n\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n\n  sigaction(SIGALRM, &act, &oldalrm);\n\n  alarm(ImapKeepalive);\n  while (waitpid(pid, &rc, 0) < 0 && errno == EINTR)\n  {\n    alarm(0); /* cancel a possibly pending alarm */\n    imap_keepalive();\n    alarm(ImapKeepalive);\n  }\n\n  alarm(0); /* cancel a possibly pending alarm */\n\n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n  OptKeepQuiet = false;\n  if (!imap_passive)\n    ImapPassive = false;\n\n  return rc;\n}\n\n/**\n * imap_allow_reopen - Allow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_allow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_disallow_reopen - Disallow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_disallow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen &= ~IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_account_match - Compare two Accounts\n * @param a1 First Account\n * @param a2 Second Account\n * @retval true Accounts match\n */\nint imap_account_match(const struct Account *a1, const struct Account *a2)\n{\n  struct ImapData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);\n  struct ImapData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);\n  const struct Account *a1_canon = a1_idata == NULL ? a1 : &a1_idata->conn->account;\n  const struct Account *a2_canon = a2_idata == NULL ? a2 : &a2_idata->conn->account;\n\n  return mutt_account_match(a1_canon, a2_canon);\n}\n"], "filenames": ["imap/util.c"], "buggy_code_start_loc": [247], "buggy_code_end_loc": [247], "fixing_code_start_loc": [248], "fixing_code_end_loc": [254], "type": "CWE-22", "message": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/util.c mishandles \"..\" directory traversal in a mailbox name.", "other": {"cve": {"id": "CVE-2018-14355", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.590", "lastModified": "2020-05-20T01:19:28.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/util.c mishandles \"..\" directory traversal in a mailbox name."}, {"lang": "es", "value": "Se ha descubierto un problema en Mutt en versiones anteriores a la 1.10.1 y NeoMutt en versiones anteriores al 2018-07-16. imap/util.c gestiona de manera incorrecta un salto de directorio \"..\" en un nombre de mailbox."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "2FA2C3A6-423C-4BE5-8FA7-0241384D58D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}], "references": [{"url": "http://www.mutt.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/57971dba06346b2d7179294f4528b8d4427a7c5d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/commit/31eef6c766f47df8281942d19f76e35f475c781d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/57971dba06346b2d7179294f4528b8d4427a7c5d"}}