{"buggy_code": ["<?php\n\nnamespace Bolt;\n\nuse Bolt\\Collection\\Arr;\nuse Bolt\\Collection\\Bag;\nuse Bolt\\Common\\Deprecated;\nuse Bolt\\Controller\\Zone;\nuse Bolt\\Filesystem\\Exception\\FileNotFoundException;\nuse Bolt\\Filesystem\\Exception\\IOException;\nuse Bolt\\Filesystem\\Exception\\ParseException;\nuse Bolt\\Filesystem\\Handler\\DirectoryInterface;\nuse Bolt\\Filesystem\\Handler\\Image;\nuse Bolt\\Filesystem\\Handler\\JsonFile;\nuse Bolt\\Filesystem\\Handler\\ParsableInterface;\nuse Bolt\\Helpers\\Html;\nuse Bolt\\Helpers\\Str;\nuse Bolt\\Storage\\Database;\nuse Bolt\\Translation\\Translator;\nuse Bolt\\Translation\\Translator as Trans;\nuse Cocur\\Slugify\\Slugify;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse Silex;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Webmozart\\PathUtil\\Path;\n\n/**\n * Class for our config object.\n *\n * @deprecated Deprecated since 3.0, to be removed in 4.0.\n *\n * @author Bob den Otter, bob@twokings.nl\n */\nclass Config\n{\n    /** @var Silex\\Application */\n    protected $app;\n    /** @var array */\n    protected $data;\n    /** @var array */\n    protected $defaultConfig = [];\n    /** @var array */\n    protected $reservedFieldNames = [\n        'datechanged',\n        'datecreated',\n        'datedepublish',\n        'datepublish',\n        'id',\n        'link',\n        'ownerid',\n        'slug',\n        'status',\n        'templatefields',\n        'username',\n    ];\n\n    /** @var int */\n    protected $cachetimestamp;\n\n    /**\n     * Use {@see Config::getFields} instead.\n     * Will be made protected in Bolt 3.0.\n     *\n     * @var \\Bolt\\Storage\\Field\\Manager\n     */\n    public $fields;\n\n    /** @var bool @deprecated Deprecated since 3.2, to be removed in 4.0 */\n    public $notify_update;\n\n    /** @var array */\n    private $exceptions;\n\n    /** @var JsonFile */\n    private $cacheFile;\n\n    private $passed;\n\n    /**\n     * @param Silex\\Application $app\n     */\n    public function __construct(Silex\\Application $app)\n    {\n        $this->app = $app;\n    }\n\n    /**\n     * @return array|null\n     */\n    public function getExceptions()\n    {\n        return $this->exceptions;\n    }\n\n    public function initialize()\n    {\n        $this->fields = new Storage\\Field\\Manager();\n        $this->defaultConfig = $this->getDefaults();\n\n        $this->cacheFile = $this->app['filesystem']->getFile('cache://config-cache.json');\n\n        $data = $this->loadCache();\n        if ($data === null) {\n            $data = $this->getConfig();\n\n            // If we have to reload the config, we will also want to make sure\n            // the DB integrity is checked.\n            $this->app['schema.timer']->setCheckRequired();\n        }\n\n        $this->data = $data;\n\n        $this->loadTheme();\n\n        $this->setCKPath();\n        $this->parseTemplatefields();\n    }\n\n    /**\n     * Checks if cache is valid for theme; if not invalidate and load it.\n     */\n    private function loadTheme()\n    {\n        if ($this->isThemeCacheValid()) {\n            return;\n        }\n        $this->invalidateCache();\n\n        $themeDir = $this->app['filesystem']->getDir('themes://' . $this->get('general/theme'));\n\n        $this->data['theme'] = $this->parseTheme($themeDir, $this->data['general']);\n    }\n\n    /**\n     * Read and parse a YAML configuration file.\n     *\n     * @param string             $filename  The name of the YAML file to read\n     * @param DirectoryInterface $directory The (optional) directory to the YAML file\n     *\n     * @return array\n     */\n    protected function parseConfigYaml($filename, DirectoryInterface $directory = null)\n    {\n        $directory = $directory ?: $this->app['filesystem']->getDir('config://');\n\n        try {\n            $file = $directory->get($filename);\n        } catch (FileNotFoundException $e) {\n            // Copy in dist files if applicable\n            $distFiles = ['config.yml', 'contenttypes.yml', 'menu.yml', 'permissions.yml', 'routing.yml', 'taxonomy.yml'];\n            if ($directory->getMountPoint() !== 'config' || !in_array($filename, $distFiles)) {\n                return [];\n            }\n\n            $this->app['filesystem']->copy(\"bolt://app/config/$filename.dist\", \"config://$filename\");\n            $file = $directory->get($filename);\n        }\n\n        if (!$file instanceof ParsableInterface) {\n            throw new \\LogicException('File is not parsable.');\n        }\n\n        $yml = $file->parse() ?: [];\n\n        // Unset the repeated nodes key after parse\n        unset($yml['__nodes']);\n\n        return $yml;\n    }\n\n    /**\n     * Set a config value, using a path.\n     *\n     * For example:\n     * $app['config']->set('general/branding/name', 'Bolt');\n     *\n     * @param string $path\n     * @param mixed  $value\n     *\n     * @return bool\n     */\n    public function set($path, $value)\n    {\n        Arr::set($this->data, $path, $value);\n\n        return true;\n    }\n\n    /**\n     * Get a config value, using a path.\n     *\n     * For example:\n     * $var = $config->get('general/wysiwyg/ck/contentsCss');\n     *\n     * @param string            $path\n     * @param string|array|bool $default\n     *\n     * @return mixed\n     */\n    public function get($path, $default = null)\n    {\n        return Arr::get($this->data, $path, $default);\n    }\n\n    /**\n     * Replaces placeholders in config values %foo% will be resolved to $app['foo'] from the container.\n     *\n     * @internal This is only public so that it can be called from the service provider boot method.\n     * Do not access this directly since the API is liable to be changed at short notice.\n     *\n     * @param mixed $value\n     *\n     * @return mixed\n     */\n    public function doReplacements($value = null)\n    {\n        if ($value === null) {\n            $this->data = $this->doReplacements($this->data);\n\n            return;\n        }\n\n        if (!is_array($value) && ('%' !== substr($value, 0, 1) && '%' !== substr($value, -1, 1))) {\n            return $value;\n        }\n\n        if (is_array($value)) {\n            foreach ($value as $k => $v) {\n                if ($v === null) {\n                    continue;\n                }\n                $value[$k] = $this->doReplacements($v);\n            }\n\n            return $value;\n        }\n\n        if (is_string($value)) {\n            $serviceName = substr($value, 1, strlen($value) - 2);\n\n            // First we pass the raw variable name to getenv to see if an environment variable is set\n            $env = getenv($serviceName);\n            if ($env !== false) {\n                return $env;\n            }\n\n            if (strpos($serviceName, ':') !== false) {\n                list($serviceName, $params) = explode(':', $serviceName);\n            } else {\n                $params = [];\n            }\n\n            if (!isset($this->app[$serviceName])) {\n                return null;\n            }\n\n            $service = $this->app[$serviceName];\n\n            if (is_callable($service)) {\n                return call_user_func($service, $params);\n            }\n\n            return $service;\n        }\n\n        return $value;\n    }\n\n    /**\n     * Load the configuration from the various YML files.\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        $config = [];\n\n        $config['general'] = $this->parseGeneral();\n        $config['taxonomy'] = $this->parseTaxonomy();\n        $config['contenttypes'] = $this->parseContentTypes($config['general']);\n        $config['menu'] = $this->parseConfigYaml('menu.yml');\n        $config['routing'] = $this->parseConfigYaml('routing.yml');\n        $config['permissions'] = $this->parseConfigYaml('permissions.yml');\n        $config['extensions'] = $this->parseConfigYaml('extensions.yml');\n\n        return $config;\n    }\n\n    /**\n     * Read and parse the config.yml and config_local.yml configuration files.\n     *\n     * @return array\n     */\n    protected function parseGeneral()\n    {\n        // Read the config and merge it. (note: We use temp variables to prevent\n        // \"Only variables should be passed by reference\")\n        $tempconfig = $this->parseConfigYaml('config.yml');\n        $tempconfiglocal = $this->parseConfigYaml('config_local.yml');\n        $general = Arr::replaceRecursive($tempconfig, $tempconfiglocal);\n\n        // Merge the array with the defaults. Setting the required values that aren't already set.\n        $general = Arr::replaceRecursive($this->defaultConfig, $general);\n\n        if (isset($general['accept_file_types']) === true) {\n            if (is_array($general['accept_file_types']) === false) {\n                // Make sure old settings for 'accept_file_types' are not still picked up. Before 1.5.4 we used to store them\n                // as a regex-like string, and we switched to an array. If we find the old style, fall back to the defaults.\n                unset($general['accept_file_types']);\n            }\n\n            // To remove unacceptable / unwanted extensions from the list of Acceptable File Types\n            $removeFromAllowedFileTypes = explode('|', 'sh|asp|cgi|php|php3|ph3|php4|ph4|php5|ph5|phtm|phtml');\n\n            // Create a bag with lowercased extensions\n            $bag = Bag::from($general['accept_file_types']);\n            $bag = $bag->map(function ($key, $ext) use ($removeFromAllowedFileTypes) {\n                if (!in_array(mb_strtolower($ext), $removeFromAllowedFileTypes)) {\n                    return mb_strtolower($ext);\n                } else {\n                    return null;\n                }\n            })->clean();\n\n            $general['accept_file_types'] = array_values($bag->toArray());\n        }\n\n        // Make sure Bolt's mount point is OK:\n        $general['branding']['path'] = '/' . Str::makeSafe($general['branding']['path']);\n\n        // Set the link in branding, if provided_by is set.\n        $general['branding']['provided_link'] = Html::providerLink(\n            $general['branding']['provided_by']\n        );\n\n        $general['database'] = $this->parseDatabase($general['database']);\n\n        return $general;\n    }\n\n    /**\n     * Read and parse the taxonomy.yml configuration file.\n     *\n     * @param array|null $taxonomies\n     *\n     * @return array\n     */\n    protected function parseTaxonomy(array $taxonomies = null)\n    {\n        $taxonomies = $taxonomies ?: $this->parseConfigYaml('taxonomy.yml');\n        $slugify = Slugify::create();\n\n        foreach ($taxonomies as $key => $taxonomy) {\n            if (!isset($taxonomy['name'])) {\n                $taxonomy['name'] = ucwords(str_replace('-', ' ', Common\\Str::humanize($taxonomy['slug'])));\n            }\n            if (!isset($taxonomy['singular_name'])) {\n                if (isset($taxonomy['singular_slug'])) {\n                    $taxonomy['singular_name'] = ucwords(str_replace('-', ' ', Common\\Str::humanize($taxonomy['singular_slug'])));\n                } else {\n                    $taxonomy['singular_name'] = ucwords(str_replace('-', ' ', Common\\Str::humanize($taxonomy['slug'])));\n                }\n            }\n            if (!isset($taxonomy['slug'])) {\n                $taxonomy['slug'] = $slugify->slugify($taxonomy['name']);\n            }\n            if (!isset($taxonomy['singular_slug'])) {\n                $taxonomy['singular_slug'] = $slugify->slugify($taxonomy['singular_name']);\n            }\n            if (!isset($taxonomy['has_sortorder'])) {\n                $taxonomy['has_sortorder'] = false;\n            }\n            if (!isset($taxonomy['allow_spaces'])) {\n                $taxonomy['allow_spaces'] = false;\n            }\n\n            // Make sure the options are $key => $value pairs, and not have implied integers for keys.\n            if (!empty($taxonomy['options']) && is_array($taxonomy['options'])) {\n                $options = [];\n                foreach ($taxonomy['options'] as $optionKey => $optionValue) {\n                    if (is_numeric($optionKey)) {\n                        $optionKey = $optionValue;\n                    }\n                    $optionKey = $slugify->slugify($optionKey);\n                    $options[$optionKey] = $optionValue;\n                }\n                $taxonomy['options'] = $options;\n            }\n\n            if (!isset($taxonomy['behaves_like'])) {\n                $taxonomy['behaves_like'] = 'tags';\n            }\n            // If taxonomy is like tags, set 'tagcloud' to true by default.\n            if (($taxonomy['behaves_like'] === 'tags') && (!isset($taxonomy['tagcloud']))) {\n                $taxonomy['tagcloud'] = true;\n            } else {\n                $taxonomy += ['tagcloud' => false];\n            }\n\n            $taxonomies[$key] = $taxonomy;\n        }\n\n        return $taxonomies;\n    }\n\n    /**\n     * Read and parse the contenttypes.yml configuration file.\n     *\n     * @param array $generalConfig\n     *\n     * @return array\n     */\n    protected function parseContentTypes(array $generalConfig)\n    {\n        $contentTypes = [];\n        $tempContentTypes = $this->parseConfigYaml('contenttypes.yml');\n        foreach ($tempContentTypes as $key => $contentType) {\n            try {\n                $contentType = $this->parseContentType($key, $contentType, $generalConfig);\n                $contentTypes[$key] = $contentType;\n            } catch (InvalidArgumentException $e) {\n                $this->exceptions[] = $e->getMessage();\n            }\n        }\n\n        return $contentTypes;\n    }\n\n    /**\n     * Read and parse the current theme's config.yml configuration file.\n     *\n     * @param DirectoryInterface $themeDir\n     * @param array              $generalConfig\n     *\n     * @return array\n     */\n    protected function parseTheme(DirectoryInterface $themeDir, array $generalConfig)\n    {\n        $themeConfig = $this->parseConfigYaml('theme.yml', $themeDir);\n\n        /** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */\n        if (empty($themeConfig)) {\n            $themeConfig = $this->parseConfigYaml('config.yml', $themeDir);\n        }\n\n        if ((isset($themeConfig['templatefields'])) && (is_array($themeConfig['templatefields']))) {\n            $templateContentTypes = [];\n\n            foreach ($themeConfig['templatefields'] as $template => $templateFields) {\n                $fieldsContenttype = [\n                    'fields'        => $templateFields,\n                    'singular_name' => 'Template Fields ' . $template,\n                ];\n\n                try {\n                    $templateContentTypes[$template] = $this->parseContentType(\n                        $template,\n                        $fieldsContenttype,\n                        $generalConfig\n                    );\n                } catch (InvalidArgumentException $e) {\n                    $this->exceptions[] = $e->getMessage();\n                }\n            }\n\n            $themeConfig['templatefields'] = $templateContentTypes;\n        }\n\n        return $themeConfig;\n    }\n\n    /**\n     * This method pulls the templatefields config from the theme config and appends it\n     * to the contenttypes configuration.\n     */\n    protected function parseTemplatefields()\n    {\n        $theme = $this->data['theme'];\n\n        if (isset($theme['templatefields'])) {\n            foreach ($this->data['contenttypes'] as $key => $ct) {\n                foreach ($ct['fields'] as $field) {\n                    if (isset($field['type']) && $field['type'] === 'templateselect') {\n                        $this->data['contenttypes'][$key]['templatefields'] = $theme['templatefields'];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Parse a single Contenttype configuration array.\n     *\n     * @param string $key\n     * @param array  $contentType\n     * @param array  $generalConfig\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function parseContentType($key, $contentType, $generalConfig)\n    {\n        // If the slug isn't set, and the 'key' isn't numeric, use that as the slug.\n        if (!isset($contentType['slug']) && !is_numeric($key)) {\n            $contentType['slug'] = Slugify::create()->slugify($key);\n        }\n\n        // If neither 'name' nor 'slug' is set, we need to warn the user. Same goes for when\n        // neither 'singular_name' nor 'singular_slug' is set.\n        if (!isset($contentType['name']) && !isset($contentType['slug'])) {\n            $error = sprintf(\"In contenttype <code>%s</code>, neither 'name' nor 'slug' is set. Please edit <code>contenttypes.yml</code>, and correct this.\", $key);\n            throw new InvalidArgumentException($error);\n        }\n        if (!isset($contentType['singular_name']) && !isset($contentType['singular_slug'])) {\n            $error = sprintf(\"In contenttype <code>%s</code>, neither 'singular_name' nor 'singular_slug' is set. Please edit <code>contenttypes.yml</code>, and correct this.\", $key);\n            throw new InvalidArgumentException($error);\n        }\n\n        // Contenttypes without fields make no sense.\n        if (!isset($contentType['fields'])) {\n            $error = sprintf(\"In contenttype <code>%s</code>, no 'fields' are set. Please edit <code>contenttypes.yml</code>, and correct this.\", $key);\n            throw new InvalidArgumentException($error);\n        }\n\n        if (!isset($contentType['slug'])) {\n            $contentType['slug'] = Slugify::create()->slugify($contentType['name']);\n        }\n        if (!isset($contentType['name'])) {\n            $contentType['name'] = ucwords(preg_replace('/[^a-z0-9]/i', ' ', $contentType['slug']));\n        }\n        if (!isset($contentType['singular_slug'])) {\n            $contentType['singular_slug'] = Slugify::create()->slugify($contentType['singular_name']);\n        }\n        if (!isset($contentType['singular_name'])) {\n            $contentType['singular_name'] = ucwords(preg_replace('/[^a-z0-9]/i', ' ', $contentType['singular_slug']));\n        }\n        if (!isset($contentType['show_on_dashboard'])) {\n            $contentType['show_on_dashboard'] = true;\n        }\n        if (!isset($contentType['show_in_menu'])) {\n            $contentType['show_in_menu'] = true;\n        }\n        if (!isset($contentType['sort'])) {\n            $contentType['sort'] = false;\n        }\n        if (!isset($contentType['default_status'])) {\n            $contentType['default_status'] = 'draft';\n        }\n        if (!isset($contentType['viewless'])) {\n            $contentType['viewless'] = false;\n        }\n        if (!isset($contentType['liveeditor'])) {\n            $contentType['liveeditor'] = true;\n        }\n        // Override contenttype setting with view and config settings\n        if (($contentType['viewless']) || (!$generalConfig['liveeditor'])) {\n            $contentType['liveeditor'] = false;\n        }\n        // Allow explicit setting of a Contenttype's table name suffix. We default\n        // to slug if not present as it has been this way since Bolt v1.2.1\n        if (!isset($contentType['tablename'])) {\n            $contentType['tablename'] = Slugify::create()->slugify($contentType['slug'], '_');\n        } else {\n            $contentType['tablename'] = Slugify::create()->slugify($contentType['tablename'], '_');\n        }\n        if (!isset($contentType['allow_numeric_slugs'])) {\n            $contentType['allow_numeric_slugs'] = false;\n        }\n        if (!isset($contentType['singleton'])) {\n            $contentType['singleton'] = false;\n        }\n\n        list($fields, $groups) = $this->parseFieldsAndGroups($contentType['fields'], $generalConfig);\n        $contentType['fields'] = $fields;\n        $contentType['groups'] = $groups;\n\n        // Make sure taxonomy is an array.\n        if (isset($contentType['taxonomy'])) {\n            $contentType['taxonomy'] = (array) $contentType['taxonomy'];\n        }\n\n        // when adding relations, make sure they're added by their slug. Not their 'name' or 'singular name'.\n        if (!empty($contentType['relations']) && is_array($contentType['relations'])) {\n            foreach (array_keys($contentType['relations']) as $relkey) {\n                if ($relkey != Slugify::create()->slugify($relkey)) {\n                    $contentType['relations'][Slugify::create()->slugify($relkey)] = $contentType['relations'][$relkey];\n                    unset($contentType['relations'][$relkey]);\n                }\n            }\n        }\n\n        return $contentType;\n    }\n\n    /**\n     * Parse a Contenttype's filed and determine the grouping.\n     *\n     * @param array $fields\n     * @param array $generalConfig\n     *\n     * @return array\n     */\n    protected function parseFieldsAndGroups(array $fields, array $generalConfig)\n    {\n        $acceptableFileTypes = $generalConfig['accept_file_types'];\n\n        $currentGroup = 'ungrouped';\n        $groups = [];\n        $hasGroups = false;\n\n        foreach ($fields as $key => $field) {\n            unset($fields[$key]);\n            $key = str_replace('-', '_', strtolower(Str::makeSafe($key, true)));\n            if (!isset($field['type']) || empty($field['type'])) {\n                $error = sprintf('Field \"%s\" has no \"type\" set.', $key);\n\n                throw new InvalidArgumentException($error);\n            }\n\n            // If field is a \"file\" type, make sure the 'extensions' are set, and it's an array.\n            if ($field['type'] == 'file' || $field['type'] == 'filelist') {\n                if (empty($field['extensions'])) {\n                    $field['extensions'] = $acceptableFileTypes;\n                }\n\n                $field['extensions'] = (array) $field['extensions'];\n            }\n\n            // If field is an \"image\" type, make sure the 'extensions' are set, and it's an array.\n            if ($field['type'] == 'image' || $field['type'] == 'imagelist') {\n                if (empty($field['extensions'])) {\n                    $field['extensions'] = array_intersect(\n                        Image\\Type::getExtensions(),\n                        $acceptableFileTypes\n                    );\n                }\n\n                $field['extensions'] = (array) $field['extensions'];\n            }\n\n            // Make indexed arrays into associative for select fields\n            // e.g.: [ 'yes', 'no' ] => { 'yes': 'yes', 'no': 'no' }\n            if ($field['type'] === 'select' && isset($field['values']) && Arr::isIndexed($field['values'])) {\n                $field['values'] = array_combine($field['values'], $field['values']);\n            }\n\n            if (!empty($field['group'])) {\n                $hasGroups = true;\n            }\n\n            // Make sure we have these keys and every field has a group set.\n            $field = array_replace(\n                [\n                    'class'   => '',\n                    'default' => '',\n                    'group'   => $currentGroup,\n                    'label'   => '',\n                    'variant' => '',\n                ],\n                $field\n            );\n\n            // Collect group data for rendering.\n            // Make sure that once you started with group all following have that group, too.\n            $currentGroup = $field['group'];\n            $groups[$currentGroup] = 1;\n\n            $fields[$key] = $field;\n\n            // Repeating fields checks\n            if ($field['type'] === 'repeater') {\n                $fields[$key] = $this->parseFieldRepeaters($fields, $key);\n                if ($fields[$key] === null) {\n                    unset($fields[$key]);\n                }\n            }\n        }\n\n        // Make sure the 'uses' of the slug is an array.\n        if (isset($fields['slug']) && isset($fields['slug']['uses'])) {\n            $fields['slug']['uses'] = (array) $fields['slug']['uses'];\n        }\n\n        return [$fields, $hasGroups ? array_keys($groups) : []];\n    }\n\n    /**\n     * Basic validation of repeater fields.\n     *\n     * @param array  $fields\n     * @param string $key\n     *\n     * @return array\n     */\n    private function parseFieldRepeaters(array $fields, $key)\n    {\n        $blacklist = ['repeater', 'slug', 'templatefield'];\n        $repeater = $fields[$key];\n\n        if (!isset($repeater['fields']) || !is_array($repeater['fields'])) {\n            return;\n        }\n\n        foreach ($repeater['fields'] as $repeaterKey => $repeaterField) {\n            if (!isset($repeaterField['type']) || in_array($repeaterField['type'], $blacklist)) {\n                unset($repeater['fields'][$repeaterKey]);\n            }\n        }\n\n        return $repeater;\n    }\n\n    /**\n     * Parse and fine-tune the database configuration.\n     *\n     * @param array $options\n     *\n     * @return array\n     */\n    protected function parseDatabase(array $options)\n    {\n        // Make sure prefix ends with underscore\n        if (substr($options['prefix'], strlen($options['prefix']) - 1) !== '_') {\n            $options['prefix'] .= '_';\n        }\n\n        // Parse master connection parameters\n        $master = $this->parseConnectionParams($options);\n        // Merge master connection into options\n        $options = array_replace($options, $master);\n\n        // Add platform specific random functions\n        $driver = \\Bolt\\Common\\Str::replaceFirst($options['driver'], 'pdo_', '');\n        if ($driver === 'sqlite') {\n            $options['driver'] = 'pdo_sqlite';\n            $options['randomfunction'] = 'RANDOM()';\n        } elseif (in_array($driver, ['mysql', 'mysqli'])) {\n            $options['driver'] = 'pdo_mysql';\n            $options['randomfunction'] = 'RAND()';\n        } elseif (in_array($driver, ['pgsql', 'postgres', 'postgresql'])) {\n            $options['driver'] = 'pdo_pgsql';\n            $options['randomfunction'] = 'RANDOM()';\n        }\n\n        // Specify the wrapper class for the connection\n        $options['wrapperClass'] = Database\\Connection::class;\n\n        // Parse SQLite separately since it has to figure out database path\n        if ($driver === 'sqlite') {\n            return $this->parseSqliteOptions($options);\n        }\n\n        // If no slaves return with single connection\n        if (empty($options['slaves'])) {\n            return $options;\n        }\n\n        // Specify we want a master slave connection\n        $options['wrapperClass'] = Database\\MasterSlaveConnection::class;\n\n        // Add master connection where MasterSlaveConnection looks for it.\n        $options['master'] = $master;\n\n        // Parse each slave connection parameters\n        foreach ($options['slaves'] as $name => $slave) {\n            $options['slaves'][$name] = $this->parseConnectionParams($slave, $master);\n        }\n\n        return $options;\n    }\n\n    /**\n     * Fine-tune Sqlite configuration parameters.\n     *\n     * @param array $config\n     *\n     * @return array\n     */\n    protected function parseSqliteOptions(array $config)\n    {\n        if (isset($config['memory']) && $config['memory']) {\n            // If in-memory, no need to parse paths\n            unset($config['path']);\n\n            return $config;\n        }\n        // Prevent SQLite driver from trying to use in-memory connection\n        unset($config['memory']);\n\n        // Get path from config or use database path\n        $path = isset($config['path']) ? $config['path'] : $this->app['path_resolver']->resolve('database');\n        if (Path::isRelative($path)) {\n            $path = $this->app['path_resolver']->resolve($path);\n        }\n\n        // If path has filename with extension, use that\n        if (Path::hasExtension($path)) {\n            $config['path'] = $path;\n\n            return $config;\n        }\n\n        // Use database name for filename\n        $filename = basename($config['dbname']);\n        if (!Path::hasExtension($filename)) {\n            $filename .= '.db';\n        }\n\n        // Join filename with database path\n        $config['path'] = Path::join($path, $filename);\n\n        return $config;\n    }\n\n    /**\n     * Parses params to valid connection parameters.\n     *\n     * - Defaults are merged into the params\n     * - Bolt keys are converted to Doctrine keys\n     * - Invalid keys are filtered out\n     *\n     * @param array|string $params\n     * @param array        $defaults\n     *\n     * @return array\n     */\n    protected function parseConnectionParams($params, $defaults = [])\n    {\n        // Handle host shortcut\n        if (is_string($params)) {\n            $params = ['host' => $params];\n        }\n\n        // Convert keys from Bolt\n        $replacements = [\n            'databasename' => 'dbname',\n            'username'     => 'user',\n        ];\n        foreach ($replacements as $old => $new) {\n            if (isset($params[$old])) {\n                $params[$new] = $params[$old];\n                unset($params[$old]);\n            }\n        }\n\n        // Merge in defaults\n        $params = array_replace($defaults, $params);\n\n        // Filter out invalid keys\n        $validKeys = [\n            'user', 'password', 'host', 'port', 'dbname', 'charset',      // common\n            'path', 'memory',                                             // Qqlite\n            'unix_socket', 'driverOptions', 'collate',                    // MySql\n            'sslmode',                                                    // PostgreSQL\n            'servicename', 'service', 'pooled', 'instancename', 'server', // Oracle\n            'persistent',                                                 // SQL Anywhere\n        ];\n        $params = array_intersect_key($params, array_flip($validKeys));\n\n        return $params;\n    }\n\n    /**\n     * Sanity check for slashes in in taxonomy slugs.\n     *\n     * @return bool\n     */\n    private function checkTaxonomy()\n    {\n        foreach ($this->data['taxonomy'] as $key => $taxonomy) {\n            if (empty($taxonomy['options']) || !is_array($taxonomy['options'])) {\n                continue;\n            }\n\n            foreach ($taxonomy['options'] as $optionKey => $optionValue) {\n                if (strpos($optionKey, '/') === false) {\n                    continue;\n                }\n\n                $this->passed = false;\n                $error = Trans::__(\n                    'general.phrase.invalid-taxonomy-slug',\n                    ['%taxonomy%' => $key, '%option%' => $optionValue]\n                );\n                $this->app['logger.flash']->error($error);\n            }\n        }\n\n        return $this->passed;\n    }\n\n    /**\n     * Sanity checks for doubles in in contenttypes.\n     *\n     * @return bool\n     */\n    public function checkConfig()\n    {\n        $slugs = [];\n        if ($this->passed === null) {\n            $this->passed = true;\n        } else {\n            return $this->passed;\n        }\n\n        foreach ($this->data['contenttypes'] as $key => $ct) {\n            // Make sure that there are no hyphens in the contenttype name, advise to change to underscores\n            if (strpos($key, '-') !== false) {\n                $error = Trans::__(\n                    'contenttypes.generic.invalid-hyphen',\n                    [\n                        '%contenttype%' => $key,\n                    ]\n                );\n                $this->app['logger.flash']->error($error);\n                unset($this->data['contenttypes'][$key]);\n\n                $this->passed = false;\n            }\n\n            /**\n             * Make sure any field that has a 'uses' parameter actually points to a field that exists.\n             *\n             * For example, this will show a notice:\n             * entries:\n             *   name: Entries\n             *     singular_name: Entry\n             *     fields:\n             *       title:\n             *         type: text\n             *         class: large\n             *       slug:\n             *         type: slug\n             *         uses: name\n             */\n            foreach ($ct['fields'] as $fieldname => $field) {\n                // Verify that the contenttype doesn't try to add fields that are reserved.\n                if ($fieldname != 'slug' && in_array($fieldname, $this->reservedFieldNames)) {\n                    $error = Trans::__(\n                        'contenttypes.generic.reserved-name',\n                        ['%contenttype%' => $key, '%field%' => $fieldname]\n                    );\n                    $this->app['logger.flash']->danger($error);\n\n                    $this->passed = false;\n                }\n\n                // Check 'uses'. If it's an array, split it up, and check the separate parts. We also need to check\n                // for the fields that are always present, like 'id'.\n                if (!empty($field['uses']) && is_array($field['uses'])) {\n                    foreach ((array) $field['uses'] as $useField) {\n                        if (!empty($field['uses']) && empty($ct['fields'][$useField]) && !in_array($useField, $this->reservedFieldNames)) {\n                            $error = Trans::__(\n                                'contenttypes.generic.wrong-use-field',\n                                ['%contenttype%' => $key, '%field%' => $fieldname, '%uses%' => $useField]\n                            );\n                            $this->app['logger.flash']->warning($error);\n\n                            $this->passed = false;\n                        }\n                    }\n                }\n\n                // Check if all the used fields are existing field types.\n                // Note: Check is disabled for now, because of the load order. At this point\n                // in the execution, field types added by extensions are not yet initialised,\n                // giving \"false positives\". See https://github.com/bolt/bolt/pull/7260\n                /*\n                if (!isset($field['type']) || !$this->fields->has($field['type'])) {\n                    $error = Trans::__(\n                        'contenttypes.generic.no-proper-type',\n                        [\n                            '%contenttype%' => $key,\n                            '%field%'       => $fieldname,\n                            '%type%'        => $field['type'],\n                        ]\n                    );\n                    $this->app['logger.flash']->warning($error);\n\n                    unset($ct['fields'][$fieldname]);\n                    $this->passed = false;\n                }\n                */\n\n                // Make sure that there are no consecutive underscores in field names\n                if (strpos($fieldname, '__') !== false) {\n                    $error = Trans::__(\n                        'contenttypes.generic.consecutive-underscores',\n                        [\n                            '%contenttype%' => $key,\n                            '%field%'       => $fieldname,\n                            '%type%'        => $field['type'],\n                        ]\n                    );\n                    $this->app['logger.flash']->warning($error);\n\n                    unset($ct['fields'][$fieldname]);\n                    $this->passed = false;\n                }\n            }\n\n            /**\n             * Make sure any contenttype that has a 'relation' defined points to a contenttype that exists.\n             */\n            if (isset($ct['relations'])) {\n                foreach ($ct['relations'] as $relKey => $relData) {\n                    // For BC we check if relation uses hyphen and re-map to underscores\n                    if (strpos($relKey, '-') !== false) {\n                        $newRelKey = str_replace('-', '_', strtolower(Str::makeSafe($relKey, true)));\n                        unset($this->data['contenttypes'][$key]['relations'][$relKey]);\n                        $this->data['contenttypes'][$key]['relations'][$newRelKey] = $relData;\n                        $relKey = $newRelKey;\n                    }\n                    if (!isset($this->data['contenttypes'][$relKey])) {\n                        $error = Trans::__(\n                            'contenttypes.generic.invalid-relation',\n                            ['%contenttype%' => $key, '%relation%' => $relKey]\n                        );\n                        $this->app['logger.flash']->error($error);\n\n                        unset($this->data['contenttypes'][$key]['relations'][$relKey]);\n                        $this->passed = false;\n                    }\n                    if (array_key_exists($relKey, $ct['fields'])) {\n                        $error = Trans::__(\n                            'general.phrase.clashing-relation',\n                            ['%contenttype%' => $key, '%relation%' => $relKey]\n                        );\n                        $this->app['logger.flash']->error($error);\n                    }\n                }\n            }\n\n            // Keep a running score of used slugs.\n            if (!isset($slugs[$ct['slug']])) {\n                $slugs[$ct['slug']] = 0;\n            }\n            ++$slugs[$ct['slug']];\n            if (!isset($slugs[$ct['singular_slug']])) {\n                $slugs[$ct['singular_slug']] = 0;\n            }\n            if ($ct['singular_slug'] != $ct['slug']) {\n                ++$slugs[$ct['singular_slug']];\n            }\n        }\n\n        // Sanity checks for taxonomy.yml\n        foreach ($this->data['taxonomy'] as $key => $taxo) {\n            // Show some helpful warnings if slugs or keys are not set correctly.\n            if ($taxo['slug'] != $key) {\n                $error = Trans::__(\n                    \"The identifier and slug for '%taxonomytype%' are the not the same ('%slug%' vs. '%taxonomytype%'). Please edit taxonomy.yml, and make them match to prevent inconsistencies between database storage and your templates.\",\n                    ['%taxonomytype%' => $key, '%slug%' => $taxo['slug']]\n                );\n                $this->app['logger.flash']->warning($error);\n\n                $this->passed = false;\n            }\n        }\n\n        // if there aren't any other errors, check for duplicates across contenttypes.\n        if (!$this->app['logger.flash']->has('error')) {\n            foreach ($slugs as $slug => $count) {\n                if ($count > 1) {\n                    $error = Trans::__(\n                        \"The slug '%slug%' is used in more than one contenttype. Please edit contenttypes.yml, and make them distinct.\",\n                        ['%slug%' => $slug]\n                    );\n                    $this->app['logger.flash']->warning($error);\n\n                    $this->passed = false;\n                }\n            }\n        }\n\n        return $this->checkTaxonomy();\n    }\n\n    /**\n     * A getter to access the fields manager.\n     *\n     * @return \\Bolt\\Storage\\Field\\Manager\n     **/\n    public function getFields()\n    {\n        return $this->fields;\n    }\n\n    /**\n     * Assume sensible defaults for a number of options.\n     */\n    protected function getDefaults()\n    {\n        return [\n            'database'    => [\n                'driver'         => 'sqlite',\n                'host'           => 'localhost',\n                'slaves'         => [],\n                'dbname'         => 'bolt',\n                'prefix'         => 'bolt_',\n                'charset'        => 'utf8',\n                'collate'        => 'utf8_unicode_ci',\n                'randomfunction' => '',\n            ],\n            'sitename'                    => 'Default Bolt site',\n            'locale'                      => null,\n            'recordsperpage'              => 10,\n            'recordsperdashboardwidget'   => 5,\n            'systemlog'                   => [\n                'enabled' => true,\n            ],\n            'changelog'                   => [\n                'enabled' => false,\n            ],\n            'debuglog'                    => [\n                'enabled'  => false,\n                'level'    => 'DEBUG',\n                'filename' => 'bolt-debug.log',\n            ],\n            'debug'                       => null,\n            'debug_show_loggedoff'        => false,\n            'debug_error_level'           => null,\n            'production_error_level'      => null,\n            'debug_enable_whoops'         => false, /** @deprecated. Deprecated since 3.2, to be removed in 4.0 */\n            'debug_error_use_symfony'     => false,\n            'debug_permission_audit_mode' => false,\n            'debug_trace_argument_limit'  => 4,\n            'strict_variables'            => null,\n            'theme'                       => 'base-2016',\n            'listing_template'            => 'listing.twig',\n            'listing_records'             => '5',\n            'listing_sort'                => 'datepublish DESC',\n            'caching'                     => [\n                'config'    => true,\n                'templates' => true,\n                'request'   => false,\n                'duration'  => 10,\n            ],\n            'wysiwyg'                     => [\n                'images'      => false,\n                'tables'      => false,\n                'fontcolor'   => false,\n                'align'       => false,\n                'subsuper'    => false,\n                'embed'       => false,\n                'anchor'      => false,\n                'underline'   => false,\n                'strike'      => false,\n                'blockquote'  => false,\n                'codesnippet' => false,\n                'specialchar' => false,\n                'styles'      => false,\n                'ck'          => [\n                    'autoParagraph'           => true,\n                    'contentsCss'             => [\n                        ['css/ckeditor-contents.css', 'bolt'],\n                        ['css/ckeditor.css', 'bolt'],\n                    ],\n                    'filebrowserWindowWidth'  => 640,\n                    'filebrowserWindowHeight' => 480,\n                ],\n            ],\n            'liveeditor'                  => true,\n            'canonical'                   => null,\n            'developer_notices'           => false,\n            'cookies_use_remoteaddr'      => true,\n            'cookies_use_browseragent'    => false,\n            'cookies_use_httphost'        => true,\n            'cookies_lifetime'            => 14 * 24 * 3600,\n            'enforce_ssl'                 => false,\n            'thumbnails'                  => [\n                'default_thumbnail' => [160, 120],\n                'default_image'     => [1000, 750],\n                'quality'           => 75,\n                'cropping'          => 'crop',\n                'notfound_image'    => 'bolt_assets://img/default_notfound.png',\n                'error_image'       => 'bolt_assets://img/default_error.png',\n                'only_aliases'      => false,\n            ],\n            'accept_file_types'           => explode(',', 'twig,html,js,css,scss,gif,jpg,jpeg,png,ico,zip,tgz,txt,md,doc,docx,pdf,epub,xls,xlsx,csv,ppt,pptx,mp3,ogg,wav,m4a,mp4,m4v,ogv,wmv,avi,webm,svg'),\n            'hash_strength'               => 10,\n            'branding'                    => [\n                'name'        => 'Bolt',\n                'path'        => '/bolt',\n                'provided_by' => [],\n            ],\n            'maintenance_mode'            => false,\n            'headers'                     => [\n                'x_frame_options' => true,\n            ],\n            'htmlcleaner'                 => [\n                'allowed_tags'       => explode(',', 'div,span,p,br,hr,s,u,strong,em,i,b,li,ul,ol,mark,blockquote,pre,code,tt,h1,h2,h3,h4,h5,h6,dd,dl,dh,table,tbody,thead,tfoot,th,td,tr,a,img,address,abbr,iframe'),\n                'allowed_attributes' => explode(',', 'id,class,style,name,value,href,src,alt,title,width,height,frameborder,allowfullscreen,scrolling'),\n            ],\n            'performance'                 => [\n                'http_cache'    => [\n                    'options' => [],\n                ],\n                'timed_records' => [\n                    'interval' => 3600,\n                    'use_cron' => false,\n                ],\n            ],\n        ];\n    }\n\n    /**\n     * Build an array of Twig paths.\n     *\n     * @return string[]\n     */\n    public function getTwigPath()\n    {\n        Deprecated::method(3.3);\n\n        $themepath = $this->app['resources']->getPath('templatespath');\n\n        $twigpath = [];\n\n        if (file_exists($themepath)) {\n            $twigpath[] = $themepath;\n        } else {\n            // If the template path doesn't exist, flash error on the dashboard.\n            $relativethemepath = basename($this->get('general/theme'));\n            $theme = $this->get('theme');\n            if (isset($theme['template_directory'])) {\n                $relativethemepath .= '/' . $this->get('theme/template_directory');\n            }\n\n            $error = \"Template folder 'theme/\" . $relativethemepath . \"' does not exist, or is not writable.\";\n            $this->app['logger.flash']->danger($error);\n        }\n\n        // We add these later, because the order is important: By having theme/ourtheme first,\n        // files in that folder will take precedence. For instance when overriding the menu template.\n        $twigpath[] = $this->app['resources']->getPath('src/../app/theme_defaults');\n\n        return $twigpath;\n    }\n\n    /**\n     * @deprecated Deprecated since 3.3, to be removed in 4.0.\n     */\n    public function setCKPath()\n    {\n    }\n\n    /**\n     * Attempt to load cached configuration files.\n     *\n     * @throws RuntimeException\n     *\n     * @return array|null\n     */\n    protected function loadCache()\n    {\n        if ($this->isCacheValid() === false) {\n            return null;\n        }\n\n        $data = null;\n\n        try {\n            $data = $this->cacheFile->parse();\n        } catch (ParseException $e) {\n            // JSON is invalid, remove the file\n            $this->invalidateCache();\n        } catch (IOException $e) {\n            $part = Translator::__(\n                'Try logging in with your ftp-client and make the file readable. ' .\n                'Else try to go <a>back</a> to the last page.'\n            );\n            $message = '<p>' . Translator::__('general.phrase.file-not-readable-following-colon') . '</p>' .\n                '<pre>' . htmlspecialchars($this->cacheFile->getFullPath()) . '</pre>' .\n                '<p>' . str_replace('<a>', '<a href=\"javascript:history.go(-1)\">', $part) . '</p>';\n\n            throw new RuntimeException(Translator::__('page.file-management.message.file-not-readable' . $message), $e->getCode(), $e);\n        }\n\n        // Check if we loaded actual data.\n        if (count($data) < 4 || empty($data['general'])) {\n            return null;\n        }\n\n        // Yup, all seems to be right.\n        return $data;\n    }\n\n    /**\n     * Check if the cached config file exists, and is newer than the authoritative source.\n     *\n     * @return bool\n     */\n    private function isCacheValid()\n    {\n        if (!$this->cacheFile->exists()) {\n            return false;\n        }\n\n        $cachedConfigTimestamp = $this->cacheFile->getTimestamp();\n\n        /** @var \\Bolt\\Filesystem\\Filesystem $configFs */\n        $configFs = $this->app['filesystem']->getFilesystem('config');\n\n        $configFiles = [\n            'config.yml',\n            'config_local.yml',\n            'contenttypes.yml',\n            'extensions.yml',\n            'menu.yml',\n            'permissions.yml',\n            'routing.yml',\n            'taxonomy.yml',\n        ];\n        foreach ($configFiles as $configFile) {\n            $timestamp = $configFs->has($configFile) ? $configFs->get($configFile)->getTimestamp() : 0;\n            if ($timestamp > $cachedConfigTimestamp) {\n                // The configuration file timestamp is *newer* than the cache file's \u2026 invalidate!\n                $this->invalidateCache();\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if the cache is still valid with theme file as well.\n     *\n     * @return bool\n     */\n    private function isThemeCacheValid()\n    {\n        if (!$this->cacheFile->exists()) {\n            return false;\n        }\n\n        $themeDir = $this->app['filesystem']->getDir('themes://' . $this->get('general/theme'));\n\n        // Check the timestamp for the theme's configuration file\n        $timestampTheme = 0;\n        $themeFile = $themeDir->getFile('theme.yml');\n        if ($themeFile->exists()) {\n            $timestampTheme = $themeFile->getTimestamp();\n        } elseif (($themeFile = $themeDir->getFile('config.yml')) && $themeFile->exists()) {\n            /** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */\n            $timestampTheme = $themeFile->getTimestamp();\n        }\n\n        return $this->cacheFile->getTimestamp() > $timestampTheme;\n    }\n\n    /**\n     * Invalidate (remove) the cache file.\n     */\n    private function invalidateCache()\n    {\n        try {\n            $this->cacheFile->delete();\n        } catch (IOException $e) {\n            // We were unable to remove the file\u2026 time to retire this class\n        }\n    }\n\n    /**\n     * @internal Do not use\n     *\n     * @param bool $force\n     */\n    public function cacheConfig($force = false)\n    {\n        if ($this->cacheFile->exists() && $force === false) {\n            return;\n        }\n        $this->cacheFile->dump($this->data);\n    }\n\n    /**\n     * @deprecated Deprecated since 3.2, to be removed in 4.0. Now handled in a listener.\n     */\n    protected function saveCache()\n    {\n    }\n\n    /**\n     * @deprecated Deprecated since 3.2, to be removed in 4.0.\n     */\n    protected function checkValidCache()\n    {\n    }\n\n    /**\n     * Get a timestamp, corrected to the timezone.\n     *\n     * @param mixed $when\n     *\n     * @return string Timestamp\n     */\n    public function getTimestamp($when)\n    {\n        Deprecated::method(3.3);\n\n        $timezone = $this->get('general/timezone');\n        $now = date_format(new \\DateTime($when, new \\DateTimeZone($timezone)), 'Y-m-d H:i:s');\n\n        return $now;\n    }\n\n    /**\n     * Get the current timestamp, corrected to the timezone.\n     *\n     * @return string Current timestamp\n     */\n    public function getCurrentTimestamp()\n    {\n        Deprecated::method(3.3);\n\n        $timezone = $this->get('general/timezone');\n        $now = date_format(new \\DateTime($timezone), 'Y-m-d H:i:s');\n\n        return $now;\n    }\n\n    /**\n     * Use {@see Zone} instead with a {@see Request}.\n     *\n     * Going forward, decisions determined by current request\n     * should be done in an app or route middleware.\n     * Application should be setup agnostic to the current request.\n     *\n     * Route middlewares apply only to a certain route or group of routes.\n     * See {@see \\Bolt\\Controller\\Async\\AsyncBase::before} for an example.\n     *\n     * App middlewares apply to all routes.\n     * See classes in \\Bolt\\EventListener for examples of these.\n     * These middlewares could also be filtered by checking for Zone inside of listener.\n     *\n     * @deprecated Deprecated since 3.0, to be removed in 4.0.\n     *\n     * @return string\n     */\n    public function getWhichEnd()\n    {\n        Deprecated::method(3.0);\n\n        $zone = $this->determineZone();\n        $this->app['end'] = $zone; // This is also deprecated\n\n        return $zone;\n    }\n\n    private function determineZone()\n    {\n        if (PHP_SAPI === 'cli') {\n            return 'cli';\n        }\n        /** @var \\Symfony\\Component\\HttpFoundation\\RequestStack $stack */\n        $stack = $this->app['request_stack'];\n        $request = $stack->getCurrentRequest() ?: Request::createFromGlobals();\n\n        if ($zone = Zone::get($request)) {\n            return $zone;\n        }\n\n        /** @var \\Bolt\\EventListener\\ZoneGuesser $guesser */\n        $guesser = $this->app['listener.zone_guesser'];\n\n        return $guesser->setZone($request);\n    }\n}\n", "<?php\n\nnamespace Bolt\\Controller\\Async;\n\nuse Bolt\\Filesystem\\Exception\\ExceptionInterface;\nuse Bolt\\Filesystem\\Exception\\FileExistsException;\nuse Bolt\\Filesystem\\Exception\\FileNotFoundException;\nuse Bolt\\Filesystem\\Exception\\IOException;\nuse Bolt\\Filesystem\\Listing;\nuse Bolt\\Helpers\\Str;\nuse Bolt\\Translation\\Translator as Trans;\nuse Silex\\ControllerCollection;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Csrf\\CsrfToken;\nuse Webmozart\\PathUtil\\Path;\n\n/**\n * Async controller for filesystem management async routes.\n *\n * @author Gawain Lynch <gawain.lynch@gmail.com>\n * @author Carson Full <carsonfull@gmail.com>\n */\nclass FilesystemManager extends AsyncBase\n{\n    protected function addRoutes(ControllerCollection $ctr)\n    {\n        $ctr->get('/browse/{namespace}/{path}', 'browse')\n            ->assert('path', '.*')\n            ->value('namespace', 'files')\n            ->value('path', '')\n            ->bind('asyncbrowse');\n\n        $ctr->get('/file/autocomplete', 'filesAutoComplete')\n            ->bind('file/autocomplete');\n\n        $ctr->post('/file/create', 'createFile')\n            ->bind('file/create');\n\n        $ctr->post('/file/delete', 'deleteFile')\n            ->bind('file/delete');\n\n        $ctr->post('/file/duplicate', 'duplicateFile')\n            ->bind('file/duplicate');\n\n        $ctr->post('/file/rename', 'renameFile')\n            ->bind('file/rename');\n\n        $ctr->post('/folder/create', 'createFolder')\n            ->bind('createfolder');\n\n        $ctr->post('/folder/rename', 'renameFolder')\n            ->bind('renamefolder');\n\n        $ctr->post('/folder/remove', 'removeFolder')\n            ->bind('removefolder');\n\n        $ctr->get('/recordbrowser', 'recordBrowser')\n            ->bind('recordbrowser');\n    }\n\n    /**\n     * List browse on the server, so we can insert them in the file input.\n     *\n     * @param Request $request\n     * @param string  $namespace\n     * @param string  $path\n     *\n     * @return \\Bolt\\Response\\TemplateResponse\n     */\n    public function browse(Request $request, $namespace, $path)\n    {\n        $directory = $this->filesystem()->getDir(\"$namespace://$path\");\n        $listing = new Listing($directory);\n        $showHidden = $this->isAllowed('files:hidden');\n\n        try {\n            $directories = $listing->getDirectories($showHidden);\n            $files = $listing->getFiles($showHidden);\n        } catch (IOException $e) {\n            $this->logException(Trans::__('page.file-management.message.folder-not-found', ['%s' => $path]), $e);\n            $directories = [];\n            $files = [];\n        }\n\n        $context = [\n            'directory'   => $directory,\n            'directories' => $directories,\n            'files'       => $files,\n            'multiselect' => $request->query->getBoolean('multiselect'),\n        ];\n\n        return $this->render('@bolt/async/browse.twig', ['context' => $context]);\n    }\n\n    /**\n     * Create a new folder.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function createFolder(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parentPath = Str::makeSafe($request->request->get('parent'), false, '()[]!@$^-_=+{},.~');\n        $folderName = Str::makeSafe($request->request->get('foldername'), false, '()[]!@$^-_=+{},.~');\n\n        try {\n            $dir = $this->filesystem()->getDir(\"$namespace://$parentPath/$folderName\");\n            $dir->create();\n\n            return $this->json($dir->getPath(), Response::HTTP_OK);\n        } catch (IOException $e) {\n            $msg = Trans::__('Unable to create directory: %DIR%', ['%DIR%' => $folderName]);\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Create an empty file.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function createFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parentPath = Str::makeSafe($request->request->get('parentPath'), false, '()[]!@$^-_=+{},.~');\n        $filename = Str::makeSafe($request->request->get('filename'), false, '()[]!@$^-_=+{},.~');\n\n        if ($this->validateFileExtension($filename) === false) {\n            return $this->json(\n                sprintf(\"File extension not allowed: %s\", $filename),\n                Response::HTTP_BAD_REQUEST\n            );\n        }\n\n        try {\n            $file = $this->filesystem()->getFile(\"$namespace://$parentPath/$filename\");\n            $file->put('');\n\n            return $this->json($file->getPath(), Response::HTTP_OK);\n        } catch (IOException $e) {\n            $msg = Trans::__('Unable to create file: %FILE%', ['%FILE%' => $filename]);\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Delete a file on the server.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function deleteFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $filename = $request->request->get('filename');\n\n        try {\n            $this->filesystem()->delete(\"$namespace://$filename\");\n\n            return $this->json($filename, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to delete file: %FILE%', ['%FILE%' => $filename]);\n            $this->logException($msg, $e);\n\n            return $this->json(\n                $msg,\n                $e instanceof FileNotFoundException ? Response::HTTP_NOT_FOUND : Response::HTTP_INTERNAL_SERVER_ERROR\n            );\n        }\n    }\n\n    /**\n     * Duplicate a file on the server.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function duplicateFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $filename = $request->request->get('filename');\n\n        $filesystem = $this->filesystem()->getFilesystem($namespace);\n\n        // If the filename doesn't have an extension $extensionPos will be equal to its length, so that $fileBase will\n        // contain the entire filename. This also accounts for dotfiles.\n        $extensionPos = strrpos($filename, '.') ?: strlen($filename);\n\n        $fileBase = substr($filename, 0, $extensionPos) . '_copy';\n        $fileExtension = substr($filename, $extensionPos);\n\n        $n = 0;\n\n        // Increase $n until filename_copy$n.ext doesn't exist\n        do {\n            ++$n;\n            $destination = $fileBase . $n . $fileExtension;\n        } while ($filesystem->has($destination));\n\n        try {\n            $filesystem->copy($filename, $destination);\n\n            return $this->json($destination, Response::HTTP_OK);\n        } catch (IOException $e) {\n            $msg = Trans::__('Unable to duplicate file: %FILE%', ['%FILE%' => $filename]);\n\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Return autocomplete data for a file name.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function filesAutoComplete(Request $request)\n    {\n        $term = $request->query->get('term', '.*');\n        $dir = Path::getDirectory($term);\n        $term = Path::getFilename($term);\n        $term = preg_quote($term);\n\n        $extensions = implode('|', explode(',', $request->query->get('ext', '.*')));\n        $regex = sprintf('/.*(%s).*\\.(%s)$/', $term, $extensions);\n\n        $files = $this->filesystem()\n            ->find()\n            ->in('files://' . $dir)\n            ->name($regex)\n        ;\n\n        $result = [];\n        /** @var \\Bolt\\Filesystem\\Handler\\File $file */\n        foreach ($files as $file) {\n            $result[] = $file->toJs();\n        }\n\n        return $this->json($result);\n    }\n\n    /**\n     * List records to easily insert links through the WYSIWYG editor.\n     *\n     * @return \\Bolt\\Response\\TemplateResponse\n     */\n    public function recordBrowser()\n    {\n        $results = [];\n\n        foreach ($this->app['config']->get('contenttypes') as $contenttype) {\n            if ($contenttype['viewless']) {\n                // Skip viewless ContentTypes\n                continue;\n            }\n\n            $slug = $contenttype['slug'];\n            $records = $this->getContent($slug, ['published' => true, 'hydrate' => false]);\n            foreach ($records as $record) {\n                $results[$slug][] = [\n                    'title' => $record->getTitle(),\n                    'id'    => $record->id,\n                    'link'  => $record->link(),\n                ];\n            }\n        }\n\n        $context = ['results' => $results];\n\n        return $this->render('@bolt/recordbrowser/recordbrowser.twig', ['context' => $context]);\n    }\n\n    /**\n     * Delete a folder recursively if writeable.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function removeFolder(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parent = $request->request->get('parent');\n        $folderName = $request->request->get('foldername');\n\n        try {\n            $this->filesystem()->deleteDir(\"$namespace://$parent/$folderName\");\n\n            return $this->json($folderName, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to delete directory: %DIR%', ['%DIR%' => $folderName]);\n\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Rename a file within the files directory tree.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function renameFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parent = $request->request->get('parent');\n        $oldName = $request->request->get('oldname');\n        $newName = $request->request->get('newname');\n\n        if (!$this->isExtensionChangedAndIsChangeAllowed($oldName, $newName)) {\n            return $this->json(Trans::__('general.phrase.only-root-change-file-extensions'), Response::HTTP_FORBIDDEN);\n        }\n\n        if ($this->validateFileExtension($newName) === false) {\n            return $this->json(\n                sprintf(\"File extension not allowed: %s\", $newName),\n                Response::HTTP_BAD_REQUEST\n            );\n        }\n\n        try {\n            $this->filesystem()->rename(\"$namespace://$parent/$oldName\", \"$parent/$newName\");\n\n            return $this->json($newName, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to rename file: %FILE%', ['%FILE%' => $oldName]);\n            $this->logException($msg, $e);\n\n            if ($e instanceof FileExistsException) {\n                $status = Response::HTTP_CONFLICT;\n            } elseif ($e instanceof FileNotFoundException) {\n                $status = Response::HTTP_NOT_FOUND;\n            } else {\n                $status = Response::HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            return $this->json($msg, $status);\n        }\n    }\n\n    /**\n     * Rename a folder within the files directory tree.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function renameFolder(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parent = $request->request->get('parent');\n        $oldName = $request->request->get('oldname');\n        $newName = $request->request->get('newname');\n\n        try {\n            $dir = $this->filesystem()->getDir(\"$namespace://$parent/$oldName\");\n            if (!$dir) {\n                return $this->json(\n                    sprintf(\"Only directories are allowed to be renamed with this method\"),\n                    Response::HTTP_BAD_REQUEST\n                );\n            }\n            $this->filesystem()->rename(\"$namespace://$parent/$oldName\", \"$parent/$newName\");\n\n            return $this->json($newName, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to rename directory: %DIR%', ['%DIR%' => $oldName]);\n            $this->logException($msg, $e);\n\n            if ($e instanceof FileExistsException) {\n                $status = Response::HTTP_CONFLICT;\n            } elseif ($e instanceof FileNotFoundException) {\n                $status = Response::HTTP_NOT_FOUND;\n            } else {\n                $status = Response::HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            return $this->json($msg, $status);\n        }\n    }\n\n    /**\n     * Check that file extensions are not being changed.\n     *\n     * @param string $oldName\n     * @param string $newName\n     *\n     * @return bool\n     */\n    private function isExtensionChangedAndIsChangeAllowed($oldName, $newName)\n    {\n        $user = $this->getUser();\n        if ($this->users()->hasRole($user['id'], 'root') || $this->users()->hasRole($user['id'], 'admin')) {\n            return true;\n        }\n\n        $oldFile = new \\SplFileInfo($oldName);\n        $newFile = new \\SplFileInfo($newName);\n\n        return $oldFile->getExtension() === $newFile->getExtension();\n    }\n\n    /**\n     * Log an exception to the system log.\n     *\n     * @param string     $message   A formatted error message\n     * @param \\Exception $exception The exception that has been thrown\n     *\n     * @return bool Whether the record has been processed\n     */\n    private function logException($message, $exception)\n    {\n        return $this->app['logger.system']->error(\n            $message . ': ' . $exception->getMessage(),\n            ['event' => 'exception', 'exception' => $exception]\n        );\n    }\n\n    /**\n     * @param string $filename\n     *\n     * @return bool\n     */\n    private function validateFileExtension($filename)\n    {\n        // no UNIX-hidden files\n        if ($filename[0] === '.') {\n            return false;\n        }\n        // only whitelisted extensions\n        $extension = pathinfo($filename, PATHINFO_EXTENSION);\n        $allowedExtensions = $this->getAllowedUploadExtensions();\n\n        return $extension === '' || in_array(mb_strtolower($extension), $allowedExtensions);\n    }\n\n    /**\n     * Get the array of configured acceptable file extensions.\n     *\n     * @return array\n     */\n    private function getAllowedUploadExtensions()\n    {\n        return $this->app['config']->get('general/accept_file_types');\n    }\n\n    /**\n     * Check if the passed in token was valid\n     *\n     * @param Request $request\n     */\n    private function checkToken(Request $request)\n    {\n        $token = new CsrfToken('bolt', $request->request->get('token'));\n\n        if (! $this->app['csrf']->isTokenValid($token)) {\n            $msg = 'Token not valid';\n            $this->abort(Response::HTTP_UNAUTHORIZED, $msg);\n        }\n    }\n}\n", "<?php\n\nnamespace Bolt\\Controller;\n\nuse Bolt\\Asset\\File\\JavaScript;\nuse Bolt\\Asset\\File\\Stylesheet;\nuse Bolt\\Asset\\Snippet\\Snippet;\nuse Bolt\\Asset\\Target;\nuse Bolt\\Helpers\\Input;\nuse Bolt\\Response\\TemplateResponse;\nuse Bolt\\Storage\\Entity\\Content;\nuse Bolt\\Storage\\Entity\\Relations;\nuse Bolt\\Storage\\Entity\\Taxonomy;\nuse Bolt\\Storage\\EntityManager;\nuse Bolt\\Storage\\Mapping\\ContentType;\nuse Bolt\\Storage\\Query\\QueryResultset;\nuse Bolt\\Storage\\Repository\\TaxonomyRepository;\nuse Bolt\\Translation\\Translator as Trans;\nuse Silex\\ControllerCollection;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Exception\\MethodNotAllowedHttpException;\n\n/**\n * Standard Frontend actions.\n *\n * This file acts as a grouping for the default front-end controllers.\n *\n * For overriding the default behavior here, please reference\n * https://docs.bolt.cm/templating/templates-routes#routing or the routing.yml\n * file in your configuration.\n */\nclass Frontend extends ConfigurableBase\n{\n    protected function getConfigurationRoutes()\n    {\n        return $this->app['config']->get('routing', []);\n    }\n\n    protected function addRoutes(ControllerCollection $c)\n    {\n        $c->value(Zone::KEY, Zone::FRONTEND);\n        parent::addRoutes($c);\n    }\n\n    /**\n     * The default before filter for the controllers in this file.\n     *\n     * Refer to the routing.yml config file for overridding.\n     *\n     * @param Request $request The Symfony Request\n     *\n     * @return null|TemplateResponse|RedirectResponse\n     */\n    public function before(Request $request)\n    {\n        // Start the 'stopwatch' for the profiler.\n        $this->app['stopwatch']->start('bolt.frontend.before');\n\n        // If there are no users in the users table, or the table doesn't exist.\n        // Repair the DB, and let's add a new user.\n        if (!$this->hasUsers()) {\n            $this->flashes()->info(Trans::__('general.phrase.users-none-create-first'));\n\n            return $this->redirectToRoute('userfirst');\n        }\n\n        // If we are in maintenance mode and current user is not logged in, show maintenance notice.\n        if ($this->getOption('general/maintenance_mode') && !$this->isAllowed('maintenance-mode')) {\n            $twig = $this->app['twig'];\n            $template = $this->templateChooser()->maintenance();\n\n            $html = $twig->resolveTemplate($template)->render([]);\n            $response = new TemplateResponse($template, [], $html, Response::HTTP_SERVICE_UNAVAILABLE);\n\n            return $response;\n        }\n\n        // Stop the 'stopwatch' for the profiler.\n        $this->app['stopwatch']->stop('bolt.frontend.before');\n\n        return null;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function after(Request $request, Response $response)\n    {\n        if ($this->session()->isStarted()) {\n            $response->setPrivate();\n        } else {\n            $sharedMaxAge = $this->getOption('general/caching/duration', 10) * 60;\n            $response\n                ->setPublic()\n                ->setSharedMaxAge($sharedMaxAge)\n            ;\n        }\n    }\n\n    /**\n     * Controller for the \"Homepage\" route. Usually the front page of the website.\n     *\n     * @param Request $request\n     *\n     * @return TemplateResponse\n     */\n    public function homepage(Request $request)\n    {\n        $homepage = $this->getOption('theme/homepage') ?: $this->getOption('general/homepage');\n        $listingParameters = $this->getListingParameters($homepage, true);\n        $content = $this->getContent($homepage, $listingParameters);\n\n        $template = $this->templateChooser()->homepage($content);\n        $globals = [];\n\n        if (is_array($content) && count($content) > 0) {\n            $first = current($content);\n            $globals[$first->contenttype['slug']] = $content;\n            $globals['records'] = $content;\n        } elseif (is_object($content)) {\n            $globals['record'] = $content;\n            $globals[$content->contenttype['singular_slug']] = $content;\n            $globals['records'] = [$content->id => $content];\n        }\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Controller for a single record page, like '/page/about/' or '/entry/lorum'.\n     *\n     * @param Request $request         The request\n     * @param string  $contenttypeslug The content type slug\n     * @param string  $slug            The content slug\n     *\n     * @return TemplateResponse\n     */\n    public function record(Request $request, $contenttypeslug, $slug = '')\n    {\n        $contenttype = $this->getContentType($contenttypeslug);\n\n        // If the ContentType is 'viewless', don't show the record page.\n        if (isset($contenttype['viewless']) && $contenttype['viewless'] === true) {\n            $this->abort(Response::HTTP_NOT_FOUND, \"Page $contenttypeslug/$slug not found.\");\n\n            return null;\n        }\n\n        // Perhaps we don't have a slug. Let's see if we can pick up the 'id', instead.\n        if (empty($slug)) {\n            $slug = $request->get('id');\n        }\n\n        $slug = $this->app['slugify']->slugify($slug);\n\n        // First, try to get it by slug.\n        $content = $this->getContent($contenttype['slug'], ['slug' => $slug, 'returnsingle' => true, 'log_not_found' => !is_numeric($slug)]);\n\n        if (is_numeric($slug) && !$content) {\n            // And otherwise try getting it by ID\n            $content = $this->getContent($contenttype['slug'], ['id' => $slug, 'returnsingle' => true]);\n        }\n\n        // No content, no page!\n        if (!$content) {\n            $this->abort(Response::HTTP_NOT_FOUND, \"Page $contenttypeslug/$slug not found.\");\n\n            return null;\n        }\n\n        // Then, select which template to use, based on our 'cascading templates rules'\n        $template = $this->templateChooser()->record($content);\n\n        // Setting the editlink\n        $this->app['editlink'] = $this->generateUrl('editcontent', ['contenttypeslug' => $contenttype['slug'], 'id' => $content->id]);\n        $this->app['edittitle'] = $content->getTitle();\n\n        // Make sure we can also access it as {{ page.title }} for pages, etc. We set these in the global scope,\n        // So that they're also available in menu's and templates rendered by extensions.\n        $globals = [\n            'record'                      => $content,\n            $contenttype['singular_slug'] => $content,\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * The controller for previewing a content from posted data.\n     *\n     * @param Request $request         The Symfony Request\n     * @param string  $contenttypeslug The content type slug\n     *\n     * @throws \\Exception\n     *\n     * @return TemplateResponse\n     */\n    public function preview(Request $request, $contenttypeslug)\n    {\n        if (!$request->isMethod('POST')) {\n            throw new MethodNotAllowedHttpException(['POST'], 'This route only accepts POST requests.');\n        }\n\n        $contenttype = $this->getContentType($contenttypeslug);\n        $formValues = $request->request->all();\n\n        $storage = $this->storage();\n        if ($storage instanceof EntityManager) {\n            /** @var EntityManager $storage */\n            /** @var Content $content */\n            $content = $storage->create($contenttypeslug, $formValues);\n\n            /** @var Collection\\Relations $related */\n            $related = $storage->createCollection(Relations::class);\n            $related->setFromPost($formValues, $content);\n            $content->setRelation($related);\n\n            /** @var Collection\\Taxonomy $taxonomies */\n            $taxonomies = $storage->createCollection(Taxonomy::class);\n            $taxonomies->setFromPost($formValues, $content);\n            $content->setTaxonomy($taxonomies);\n\n        } else {\n            $content = $storage->getContentObject($contenttypeslug, [], false);\n            $content->setFromPost($formValues, $contenttype);\n        }\n\n        $this->fixBlockFieldsForPreview($content);\n        $this->fixHTMLFieldsForPreview($content);\n\n        $liveEditor = $request->get('_live-editor-preview');\n        if (!empty($liveEditor)) {\n            $jsFile = (new JavaScript('js/ckeditor/ckeditor.js', 'bolt'))\n                ->setPriority(1)\n                ->setLate(false);\n            $cssFile = (new Stylesheet('css/liveeditor.css', 'bolt'))\n                ->setPriority(5)\n                ->setLate(false);\n            $snippet = (new Snippet())\n                ->setCallback('<script>window.boltIsEditing = true;</script>')\n                ->setLocation(Target::BEFORE_HEAD_JS);\n\n            $this->app['asset.queue.snippet']->add($snippet);\n            $this->app['asset.queue.file']->add($jsFile);\n            $this->app['asset.queue.file']->add($cssFile);\n        }\n\n        // Then, select which template to use, based on our 'cascading templates rules'\n        $template = $this->templateChooser()->record($content);\n\n        // Make sure we can also access it as {{ page.title }} for pages, etc. We set these in the global scope,\n        // So that they're also available in menu's and templates rendered by extensions.\n        $globals = [\n            'record'                      => $content,\n            $contenttype['singular_slug'] => $content,\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Helper function to prefill `block` fields with an additional `block` field per item.\n     *\n     * This is needed to make previewing content with block fields fully working.\n     */\n    private function fixBlockFieldsForPreview($record)\n    {\n        foreach ($record->contenttype['fields'] as $fieldSlug => $fieldSettings) {\n            if ($fieldSettings['type'] === 'block') {\n                $fieldValue = $this->getBlockFieldValue($record, $fieldSlug);\n                if ($fieldValue) {\n                    $newArray = [];\n                    foreach ($fieldValue as $item) {\n                        if (!empty($item)) {\n                            foreach ($item as $k => &$v) {\n                                $v['block'] = $k;\n                            }\n                            $newArray[] = $v;\n                        }\n                    }\n                    $this->setFieldValue($record, $fieldSlug, $newArray);\n                }\n            }\n        }\n\n        return $record;\n    }\n\n    /**\n     * Helper function to make sure HTML-like fields are Twig_Markup, and image fields are\n     * an image. Like they are in a \"real\" page.\n     *\n     * This is needed to make previewing content with block fields fully working.\n     * See: https://github.com/bolt/bolt/issues/7753\n     */\n    private function fixHTMLFieldsForPreview($record)\n    {\n        foreach ($record->contenttype['fields'] as $fieldSlug => $fieldSettings) {\n            if (in_array($fieldSettings['type'], ['html', 'text', 'textarea', 'markdown'])) {\n                $fieldValue = new \\Twig_Markup($this->getFieldValue($record, $fieldSlug), \"UTF-8\");\n\n                $this->setFieldValue($record, $fieldSlug, $fieldValue);\n            }\n            if ($fieldSettings['type'] === 'image') {\n                $fieldValue = $this->getFieldValue($record, $fieldSlug);\n\n                if (is_array($fieldValue) && isset($fieldValue['file'])) {\n                    $this->setFieldValue($record, $fieldSlug, $fieldValue['file']);\n                }\n            }\n        }\n\n        return $record;\n    }\n\n    private function getBlockFieldValue($record, $field)\n    {\n        if ($record instanceof Content) {\n            $value = $record->get($field);\n            if (is_array($value)) {\n                return $value;\n            }\n        } elseif (isset($record->values[$field]) && is_array($record->values[$field])) {\n            return $record->values[$field];\n        }\n\n        return null;\n    }\n\n    private function getFieldValue($record, $field)\n    {\n        if ($record instanceof Content) {\n            return $record->get($field);\n        } elseif (isset($record->values[$field]) && is_array($record->values[$field])) {\n            return $record->values[$field];\n        }\n\n        return null;\n    }\n\n    private function setFieldValue($record, $field, $value)\n    {\n        if ($record instanceof Content) {\n            $record->set($field, $value);\n        } else {\n            $record->values[$field] = $value;\n        }\n    }\n\n    /**\n     * The listing page controller.\n     *\n     * @param Request $request         The Symfony Request\n     * @param string  $contenttypeslug The content type slug\n     *\n     * @return TemplateResponse\n     */\n    public function listing(Request $request, $contenttypeslug)\n    {\n        $listingParameters = $this->getListingParameters($contenttypeslug);\n        $content = $this->getContent($contenttypeslug, $listingParameters);\n        $contenttype = $this->getContentType($contenttypeslug);\n\n        $template = $this->templateChooser()->listing($contenttype);\n\n        // Make sure we can also access it as {{ pages }} for pages, etc. We set these in the global scope,\n        // So that they're also available in menu's and templates rendered by extensions.\n        $globals = [\n            'records'        => $content,\n            $contenttypeslug => $content,\n            'contenttype'    => $contenttype['name'],\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * The taxonomy listing page controller.\n     *\n     * @param Request $request      The Symfony Request\n     * @param string  $taxonomytype The taxonomy type slug\n     * @param string  $slug         The taxonomy slug\n     *\n     * @throws \\Bolt\\Exception\\InvalidRepositoryException\n     *\n     * @return TemplateResponse|false\n     */\n    public function taxonomy(Request $request, $taxonomytype, $slug)\n    {\n        $taxonomy = $this->app['config']->get('taxonomy/' . $taxonomytype);\n        // No taxonomytype, no possible content.\n        if (empty($taxonomy)) {\n            return false;\n        }\n        $taxonomyslug = $taxonomy['slug'];\n\n        // First, get some content\n        $context = $taxonomy['singular_slug'] . '_' . $slug;\n        $page = $this->app['pager']->getCurrentPage($context);\n        // Theme value takes precedence over default config @see https://github.com/bolt/bolt/issues/3951\n        $amount = $this->getOption('theme/listing_records', false) ?: $this->getOption('general/listing_records');\n\n        // Handle case where listing records has been override for specific taxonomy\n        if (array_key_exists('listing_records', $taxonomy) && is_int($taxonomy['listing_records'])) {\n            $amount = $taxonomy['listing_records'];\n        }\n\n        $order = $this->getOption('theme/listing_sort', false) ?: $this->getOption('general/listing_sort');\n        $isLegacy = $this->getOption('general/compatibility/setcontent_legacy', true);\n        if ($isLegacy) {\n            $content = $this->storage()->getContentByTaxonomy($taxonomytype, $slug, ['limit' => $amount, 'order' => $order, 'page' => $page]);\n        } else {\n            $page = $this->app['pager']->getCurrentPage('taxonomy');\n            $appCt = array_keys($this->app['query.search_config']->getSearchableTypes());\n            /** @var TaxonomyRepository $repo */\n            $repo = $this->app['storage']->getRepository(Taxonomy::class);\n            $query = $repo->queryContentByTaxonomy($appCt, [$taxonomytype => $slug])\n                ->setFirstResult(($page - 1) * $amount)\n                ->setMaxResults($amount)\n            ;\n\n            $results = $repo->getContentByTaxonomy($query);\n            $set = new QueryResultset();\n            foreach ($results->getCollection() as $record) {\n                $set->add([$record]);\n            }\n            $content = $this->app['twig.records.view']->createView($set);\n        }\n\n        if (!$this->isTaxonomyValid($content, $slug, $taxonomy)) {\n            $this->abort(Response::HTTP_NOT_FOUND, \"No slug '$slug' in taxonomy '$taxonomyslug'\");\n        }\n\n        $template = $this->templateChooser()->taxonomy($taxonomyslug);\n\n        // Get a display value for slug. This should be moved from 'slug' context key to 'name' in v4.0.\n        $name = $slug;\n        if ($taxonomy['behaves_like'] !== 'tags' && isset($taxonomy['options'][$slug])) {\n            $name = $taxonomy['options'][$slug];\n        }\n\n        $globals = [\n            'records'      => $content,\n            'slug'         => $name,\n            'taxonomy'     => $this->getOption('taxonomy/' . $taxonomyslug),\n            'taxonomytype' => $taxonomyslug,\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Check if the taxonomy is valid.\n     *\n     * @see https://github.com/bolt/bolt/pull/2310\n     *\n     * @param array|false $content\n     * @param string      $slug\n     * @param array       $taxonomy\n     *\n     * @return bool\n     */\n    protected function isTaxonomyValid($content, $slug, array $taxonomy)\n    {\n        if ($taxonomy['behaves_like'] === 'tags' && !$content) {\n            return false;\n        }\n\n        $isNotTag = in_array($taxonomy['behaves_like'], ['categories', 'grouping']);\n        $options = isset($taxonomy['options']) ? array_keys($taxonomy['options']) : [];\n        $isTax = in_array($slug, $options);\n        if ($isNotTag && !$isTax) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * The search result page controller.\n     *\n     * @param Request $request      The Symfony Request\n     * @param array   $contenttypes The content type slug(s) you want to search for\n     *\n     * @return TemplateResponse\n     */\n    public function search(Request $request, array $contenttypes = null)\n    {\n        $q = '';\n        $context = __FUNCTION__;\n\n        if ($request->query->has('q')) {\n            $q = $request->query->get('q');\n        } elseif ($request->query->has($context)) {\n            $q = $request->query->get($context);\n        }\n        $q = Input::cleanPostedData($q, false);\n\n        $page = $this->app['pager']->getCurrentPage($context);\n\n        // Theme value takes precedence over default config @see https://github.com/bolt/bolt/issues/3951\n        $pageSize = $this->getOption('theme/search_results_records', false);\n        if ($pageSize === false && !$pageSize = $this->getOption('general/search_results_records', false)) {\n            $pageSize = $this->getOption('theme/listing_records', false) ?: $this->getOption('general/listing_records', 10);\n        }\n\n        $offset = ($page - 1) * $pageSize;\n        $limit = $pageSize;\n\n        // set-up filters from URL\n        $filters = [];\n        foreach ($request->query->all() as $key => $value) {\n            if (strpos($key, '_') > 0) {\n                list($contenttypeslug, $field) = explode('_', $key, 2);\n                if (isset($filters[$contenttypeslug])) {\n                    $filters[$contenttypeslug][$field] = $value;\n                } else {\n                    $contenttype = $this->getContentType($contenttypeslug);\n                    if (is_array($contenttype)) {\n                        $filters[$contenttypeslug] = [\n                            $field => $value,\n                        ];\n                    }\n                }\n            }\n        }\n        if (count($filters) == 0) {\n            $filters = null;\n        }\n\n        $isLegacy = $this->getOption('general/compatibility/setcontent_legacy', true);\n        if ($isLegacy) {\n            $result = $this->storage()->searchContent($q, $contenttypes, $filters, $limit, $offset);\n\n            /** @var \\Bolt\\Pager\\PagerManager $manager */\n            $manager = $this->app['pager'];\n            $manager\n                ->createPager($context)\n                ->setCount($result['no_of_results'])\n                ->setTotalpages(ceil($result['no_of_results'] / $pageSize))\n                ->setCurrent($page)\n                ->setShowingFrom($offset + 1)\n                ->setShowingTo($offset + ($result ? count($result['results']) : 0));\n            ;\n\n            $manager->setLink($this->generateUrl('search', ['q' => $q]) . '&page_search=');\n        } else {\n            $appCt = array_keys($this->app['query.search_config']->getSearchableTypes());\n            $textQuery = '(' . join(',', $appCt) . ')/search';\n            $params = [\n                'filter' => $q,\n                'page'   => $page,\n                'limit'  => $pageSize,\n            ];\n            $searchResult = $this->getContent($textQuery, $params);\n\n            $result = [\n                'results' => $searchResult->getSortedResults(),\n                'query'   => [\n                    'sanitized_q' => strip_tags($q),\n                ],\n            ];\n        }\n\n        $globals = [\n            'records'      => $result['results'],\n            $context       => $result['query']['sanitized_q'],\n            'searchresult' => $result,\n        ];\n\n        $template = $this->templateChooser()->search();\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Renders the specified template from the current theme in response to a request without\n     * loading any content.\n     *\n     * @param string $template The template name\n     *\n     * @return TemplateResponse\n     */\n    public function template($template)\n    {\n        // Add the template extension if it is missing\n        if (!preg_match('/\\\\.twig$/i', $template)) {\n            $template .= '.twig';\n        }\n\n        return $this->render($template);\n    }\n\n    /**\n     * Returns an array of the parameters used in getContent for listing pages.\n     *\n     * @param string $contentTypeSlug The content type slug\n     * @param bool   $allowViewless   Allow viewless contenttype\n     *\n     * @return array Parameters to use in getContent\n     */\n    private function getListingParameters($contentTypeSlug, $allowViewless = false)\n    {\n        $contentType = $this->getContentType(current(explode('/', $contentTypeSlug)));\n\n        // If there is no ContentType, don't get parameters for it\n        if ($contentType === false) {\n            return [];\n        }\n\n        // If the ContentType is 'viewless', don't show the listing / record page.\n        if ($contentType['viewless'] && !$allowViewless) {\n            $this->abort(Response::HTTP_NOT_FOUND, 'Page ' . $contentType['slug'] . ' not found.');\n        }\n\n        // Build the pager\n        $page = $this->app['pager']->getCurrentPage($contentType['slug']);\n        $order = isset($contentType['listing_sort']) ? $contentType['listing_sort'] : $this->getListingOrder($contentType);\n\n        // CT value takes precedence over theme & config.yml\n        if (!empty($contentType['listing_records'])) {\n            $amount = $contentType['listing_records'];\n        } else {\n            $amount = $this->getOption('theme/listing_records') ?: $this->getOption('general/listing_records');\n        }\n\n        return ['limit' => $amount, 'order' => $order, 'page' => $page, 'paging' => true];\n    }\n\n    /**\n     * Return the listing order.\n     *\n     * If the ContentType's sort is false (default in Config::parseContentType),\n     * either:\n     *  - we let `getContent()` sort by itself\n     *  - we explicitly set it to sort on the general/listing_sort setting\n     *\n     * @param ContentType|array $contentType\n     *\n     * @return null|string\n     */\n    private function getListingOrder($contentType)\n    {\n        // An empty default isn't set in config yet, arrays got to hate them.\n        if (isset($contentType['taxonomy'])) {\n            $taxonomies = $this->getOption('taxonomy');\n            foreach ($contentType['taxonomy'] as $taxonomyName) {\n                if ($taxonomies[$taxonomyName]['has_sortorder']) {\n                    // Let getContent() handle it\n                    return null;\n                }\n            }\n        }\n\n        return $this->getOption('theme/listing_sort') ?: $this->getOption('general/listing_sort');\n    }\n}\n", "<?php\n\nnamespace Bolt\\Tests\\Controller\\Async;\n\nuse Bolt\\Common\\Json;\nuse Bolt\\Filesystem\\Handler\\HandlerInterface;\nuse Bolt\\Response\\TemplateView;\nuse Bolt\\Storage\\Entity\\Users;\nuse Bolt\\Tests\\Controller\\ControllerUnitTest;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;\nuse Symfony\\Component\\Security\\Csrf\\CsrfToken;\nuse Symfony\\Component\\Security\\Csrf\\CsrfTokenManager;\nuse Symfony\\Component\\Security\\Csrf\\TokenStorage\\SessionTokenStorage;\n\n/**\n * Class to test correct operation of src/Controller/Async/FileManager.\n *\n * @author Gawain Lynch <gawain.lynch@gmail.com>\n **/\nclass FilesystemManagerTest extends ControllerUnitTest\n{\n    const FILESYSTEM = 'files';\n\n    const FILE_NAME = '__phpunit_test_file_delete_me';\n    const FILE_NAME_NOT_ALLOWED = '__phpunit_test_file_delete_me.exe';\n    const FILE_NAME_2 = '__phpunit_test_file_2_delete_me';\n    const FOLDER_NAME = '__phpunit_test_folder_delete_me';\n    const FOLDER_NAME_2 = '__phpunit_test_folder_2_delete_me';\n\n    private $oldFiles = [];\n\n    /** @var CsrfToken */\n    private $token;\n\n    protected function setUp()\n    {\n        $tokenManager = new CsrfTokenManager(null, new SessionTokenStorage(new Session(new MockArraySessionStorage())));\n        $this->setService('csrf', $tokenManager);\n        $this->token = $tokenManager->refreshToken('bolt');\n    }\n\n    /**\n     * Store the list of files in the files folder so we can delete any added files after we're done testing.\n     *\n     * @before\n     */\n    public function storeFileList()\n    {\n        $this->oldFiles = $this->getService('filesystem')->listContents(self::FILESYSTEM . '://');\n    }\n\n    /**\n     * Remove any files added during the test.\n     *\n     * @after\n     */\n    public function restoreFileList()\n    {\n        $newFiles = array_udiff(\n            $this->getService('filesystem')->listContents(self::FILESYSTEM . '://'),\n            $this->oldFiles,\n            function (HandlerInterface $file1, HandlerInterface $file2) {\n                return strcmp($file2->getPath(), $file2->getPath());\n            }\n        );\n        /** @var HandlerInterface $file */\n        foreach ($newFiles as $file) {\n            $file->delete();\n        }\n    }\n\n    public function testBrowse()\n    {\n        $this->setRequest(Request::create('/async/browse'));\n        $response = $this->controller()->browse($this->getRequest(), self::FILESYSTEM, '/');\n\n        $this->assertInstanceOf(TemplateView::class, $response);\n        $this->assertEquals('@bolt/async/browse.twig', $response->getTemplate());\n    }\n\n    public function testCreateFolder()\n    {\n        $this->setRequest(Request::create('/async/folder/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parent'     => '',\n            'foldername' => self::FOLDER_NAME,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFolder($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        // Test whether the new folder actually exists\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FOLDER_NAME));\n    }\n\n    public function testRemoveFolder()\n    {\n        $this->setRequest(Request::create('/async/folder/delete', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parent'     => '',\n            'foldername' => self::FOLDER_NAME,\n            'token'      => $this->token,\n        ]));\n\n        // The folder should exist before deleting\n        $this->controller()->createFolder($this->getRequest());\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FOLDER_NAME));\n\n        $response = $this->controller()->removeFolder($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FOLDER_NAME));\n    }\n\n    public function testCreateFile()\n    {\n        $this->setRequest(Request::create('/async/file/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parentPath' => '',\n            'filename'   => self::FILE_NAME,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFile($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        // Test whether the new file actually exists\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n    }\n\n    public function testCreateFileInvalidExtension()\n    {\n        $this->setRequest(Request::create('/async/file/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parentPath' => '',\n            'filename'   => self::FILE_NAME_NOT_ALLOWED,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFile($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_BAD_REQUEST, $response->getStatusCode());\n\n        // Test whether the new file is not saved\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME_NOT_ALLOWED));\n    }\n\n    /**\n     * Duplicating a file five times should create FILENAME_copy1-5.EXT. This should work for both regular filenames\n     * and dotfiles.\n     */\n    public function testDuplicateFile()\n    {\n        $filenames = ['__phpunit_test_file_delete_me.extension', '.__phpunit_test_dotfile_delete_me'];\n\n        foreach ($filenames as $filename) {\n            // Create the file\n            $this->getService('filesystem')->put(self::FILESYSTEM . '://' . $filename, '');\n\n            $extensionPos = strrpos($filename, '.') ?: strlen($filename);\n            $fileBase = substr($filename, 0, $extensionPos) . '_copy';\n            $fileExtension = substr($filename, $extensionPos);\n\n            for ($i = 1; $i <= 5; ++$i) {\n                $destination = $fileBase . $i . $fileExtension;\n\n                // The file shouldn't exist yet\n                $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $destination));\n\n                $this->setRequest(Request::create('/async/file/duplicate', 'POST', [\n                    'namespace' => self::FILESYSTEM,\n                    'filename'  => $filename,\n                    'token'      => $this->token,\n                ]));\n\n                $response = $this->controller()->duplicateFile($this->getRequest());\n                $this->assertInstanceOf(JsonResponse::class, $response);\n                $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n                // The copy should now have been created\n                $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $destination));\n            }\n        }\n    }\n\n    public function testDeleteFile()\n    {\n        $this->setRequest(Request::create('/async/file/delete', 'POST', [\n            'namespace' => 'files',\n            'filename'  => self::FILE_NAME,\n            'token'      => $this->token,\n        ]));\n\n        // The file should still exist before deleting\n        $this->controller()->createFile($this->getRequest());\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n\n        $response = $this->controller()->deleteFile($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        // The file shouldn't exist anymore\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n\n        // Attempting to delete the same file twice (or simply attempting to remove a file that doesn't exist) should\n        // return a 404 Not Found status code\n        $response = $this->controller()->deleteFile($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_NOT_FOUND, $response->getStatusCode());\n    }\n\n    /**\n     * Test renaming both files and folders, since the controller actions have the same signature and output.\n     */\n    public function testRename()\n    {\n        $definitions = [\n            'file'   => ['old' => self::FILE_NAME, 'new' => self::FILE_NAME_2],\n            'folder' => ['old' => self::FOLDER_NAME, 'new' => self::FOLDER_NAME_2],\n        ];\n        foreach ($definitions as $object => $data) {\n            $this->createObject($object, $data['old']);\n\n            // Rename the object\n            $response = $this->renameObject($object, $data['old'], $data['new']);\n\n            $this->assertInstanceOf(JsonResponse::class, $response);\n            $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n            $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $data['old']));\n            $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $data['new']));\n        }\n    }\n\n    /**\n     * Test the error handling when attempting to rename non existent files and folders and when attemtping to rename to\n     * a filename that already exists.\n     */\n    public function testInvalidRename()\n    {\n        $definitions = [\n            'file'   => ['old' => self::FILE_NAME, 'new' => self::FILE_NAME_2],\n            'folder' => ['old' => self::FOLDER_NAME, 'new' => self::FOLDER_NAME_2],\n        ];\n        foreach ($definitions as $object => $data) {\n            /*\n             * Object doesn't exist\n             */\n            $this->createObject($object, $data['old']);\n            $response = $this->renameObject($object, $data['old'] . '_nonexistent', $data['new']);\n\n            $this->assertInstanceOf(JsonResponse::class, $response);\n            $this->assertEquals(Response::HTTP_NOT_FOUND, $response->getStatusCode());\n\n            /*\n             * Destination already exists\n             */\n            // Create the objects\n            foreach ([$data['old'], $data['new']] as $filename) {\n                $this->createObject($object, $filename);\n            }\n\n            $response = $this->renameObject($object, $data['old'], $data['new']);\n            $this->assertInstanceOf(JsonResponse::class, $response);\n            $this->assertEquals(Response::HTTP_CONFLICT, $response->getStatusCode());\n        }\n    }\n\n    public function testRenameToInvalidExtension()\n    {\n        $this->createObject('file', self::FILE_NAME);\n        $response = $this->renameObject('file', self::FILE_NAME, self::FILE_NAME_NOT_ALLOWED);\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_FORBIDDEN, $response->getStatusCode());\n\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME_NOT_ALLOWED));\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n    }\n\n    public function testFilesAutoComplete()\n    {\n        // First create a bunch of files named FOLDER/$i.EXTENSION\n        $prefix = 'autocomplete';\n        $extensions = ['ext1', 'ext2'];\n        $count = 5;\n\n        for ($i = 1; $i <= $count; ++$i) {\n            foreach ($extensions as $extension) {\n                $this->getService('filesystem')->put(self::FILESYSTEM . '://' . $prefix . $i . '.' . $extension, '');\n            }\n        }\n\n        // Querying should return all files\n        $this->setRequest(Request::create('/async/file/autocomplete', 'GET', [\n            'term' => $prefix,\n            'ext'  => '.*',\n        ]));\n\n        $response = $this->controller()->filesAutoComplete($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n        $this->assertCount($count * count($extensions), Json::parse($response->getContent()));\n\n        // Filtering by one extension should return only $count files\n        $this->setRequest(Request::create('/async/file/autocomplete', 'GET', [\n            'term' => $prefix,\n            'ext'  => $extensions[0],\n        ]));\n\n        $response = $this->controller()->filesAutoComplete($this->getRequest());\n        $this->assertCount($count, Json::parse($response->getContent()));\n    }\n\n    public function testFileBrowser()\n    {\n        //$this->setSessionUser(new Entity\\Users($this->getService('users')->getUser('admin')));\n        $this->setRequest(Request::create('/async/recordbrowser'));\n\n        $response = $this->controller()->recordBrowser();\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('@bolt/recordbrowser/recordbrowser.twig', $response->getTemplate());\n    }\n\n    /**\n     * @param string $object The type of the object, either 'file' or 'folder'\n     * @param string $name   The name of the new object\n     */\n    private function createObject($object, $name)\n    {\n        $this->setRequest(Request::create(\"/async/$object/create\", 'POST', [\n            'namespace'  => 'files',\n            'parent'     => '',\n            'filename'   => $name,\n            'foldername' => $name,\n            'token'      => $this->token,\n        ]));\n        switch ($object) {\n            case 'file':\n                $this->controller()->createFile($this->getRequest());\n                break;\n            case 'folder':\n                $this->controller()->createFolder($this->getRequest());\n                break;\n        }\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $name));\n    }\n\n    /**\n     * @param string $object The type of the object, either 'file' or 'folder'\n     * @param string $old\n     * @param string $new\n     *\n     * @return JsonResponse\n     */\n    private function renameObject($object, $old, $new)\n    {\n        $this->setRequest(Request::create(\"/async/$object/rename\", 'POST', [\n            'namespace' => 'files',\n            'parent'    => '',\n            'oldname'   => $old,\n            'newname'   => $new,\n            'token'     => $this->token,\n        ]));\n        switch ($object) {\n            case 'file':\n                $response = $this->controller()->renameFile($this->getRequest());\n                break;\n            case 'folder':\n                $response = $this->controller()->renameFolder($this->getRequest());\n                break;\n        }\n\n        return $response;\n    }\n\n    /**\n     * @return \\Bolt\\Controller\\Async\\FilesystemManager\n     */\n    protected function controller()\n    {\n        return $this->getService('controller.async.filesystem_manager');\n    }\n}\n", "<?php\n\nnamespace Bolt\\Tests\\Controller;\n\nuse Bolt\\Controller\\Zone;\nuse Bolt\\Legacy\\Content;\nuse Bolt\\Response\\TemplateResponse;\nuse Bolt\\Response\\TemplateView;\nuse Bolt\\TemplateChooser;\nuse Bolt\\Twig\\Runtime\\HtmlRuntime;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\n\n/**\n * Class to test correct operation of src/Controller/Frontend.\n *\n *\n * @author Ross Riley <riley.ross@gmail.com>\n * @author Carson Full <carsonfull@gmail.com>\n * @author Gawain Lynch <gawain.lynch@gmail.com>\n **/\nclass FrontendTest extends ControllerUnitTest\n{\n    /**\n     * @covers \\Bolt\\Controller\\Zone::get\n     * @covers \\Bolt\\Controller\\Zone::isFrontend\n     */\n    public function testControllerZone()\n    {\n        $app = $this->getApp();\n        $this->setRequest(Request::create('/'));\n\n        $request = $this->getRequest();\n        $kernel = $this->createMock(HttpKernelInterface::class);\n        $app['dispatcher']->dispatch(KernelEvents::REQUEST, new GetResponseEvent($kernel, $request, HttpKernelInterface::MASTER_REQUEST));\n\n        $this->assertEquals('frontend', Zone::get($request));\n        $this->assertTrue(Zone::isFrontend($request));\n    }\n\n    public function testDefaultHomepageTemplate()\n    {\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyDefaultHomepage()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/compatibility/template_view', false);\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    public function testConfiguredConfigHomepageTemplate()\n    {\n        $this->getService('filesystem')->put('theme://custom-home.twig', '');\n        $this->getService('config')->set('general/homepage_template', 'custom-home.twig');\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('custom-home.twig', $response->getTemplate());\n    }\n\n    public function testConfiguredThemeHomepageTemplate()\n    {\n        $this->getService('filesystem')->put('theme://custom-theme-home.twig', '');\n        $this->getService('config')->set('theme/homepage_template', 'custom-theme-home.twig');\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('custom-theme-home.twig', $response->getTemplate());\n    }\n\n    public function testHomepageContent()\n    {\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n        $globals = $this->getTwigGlobals();\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertInstanceOf(Content::class, $globals['record']);\n    }\n\n    public function testMultipleHomepages()\n    {\n        $app = $this->getApp();\n        $this->setRequest(Request::create('/'));\n        $app['config']->set('general/homepage', 'pages');\n\n        $this->controller()->homepage($this->getRequest());\n\n        $globals = $this->getTwigGlobals();\n        foreach ($globals['records'] as $record) {\n            $this->assertInstanceOf(Content::class, $record);\n        }\n    }\n\n    public function testRecord()\n    {\n        $response = $this->getRecordResponse();\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('page.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyRecord()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $response = $this->getRecordResponse();\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('page.twig', $response->getTemplate());\n    }\n\n    private function getRecordResponse()\n    {\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $request = Request::create('/pages/test');\n        $this->setRequest($request);\n        $content = new Content($this->getApp(), $contentType);\n        $content->setValues(['slug' => 'test', 'title' => 'test']);\n        $this->getService('storage')->saveContent($content);\n\n        $response = $this->controller()->record($request, 'pages', 'test');\n\n        return $response;\n    }\n\n    public function testCanonicalUrlForHomepage()\n    {\n        $expected = 'http://foo.dev/';\n\n        /** @var \\Silex\\Application $app */\n        $app = $this->getApp();\n        $app['config']->set('general/homepage', 'page/1');\n\n        $this->setRequest(Request::create($expected));\n        $app['request_context']->fromRequest($this->getRequest());\n\n        $kernel = $this->createMock(HttpKernelInterface::class);\n        $event = new GetResponseEvent($kernel, $this->getRequest(), HttpKernelInterface::MASTER_REQUEST);\n        $app['canonical']->onRequest($event);\n\n        $templates = $this->getMockBuilder(TemplateChooser::class)\n            ->setMethods(['record'])\n            ->setConstructorArgs([$app['config']])\n            ->getMock()\n        ;\n        $templates->expects($this->any())\n            ->method('record')\n            ->will($this->returnValue('index.twig'));\n        $this->setService('templatechooser', $templates);\n\n        // Route for /page/1 instead of homepage\n        $this->controller()->record($this->getRequest(), 'page', '1');\n\n        $this->assertEquals($expected, $app['canonical']->getUrl(), 'Canonical url should be homepage');\n    }\n\n    public function testCanonicalUrlForNumericRecord()\n    {\n        /** @var \\Silex\\Application $app */\n        $app = $this->getApp();\n        $this->setService('twig.runtime.bolt_html', $this->getHtmlRuntime());\n\n        $this->setRequest(Request::create('/pages/5'));\n        $app['request_context']->fromRequest($this->getRequest());\n\n        $contentType = $app['storage']->getContentType('pages');\n        $content1 = new Content($app, $contentType);\n        $content1->id = 5;\n        $content1['slug'] = 'foo';\n\n        $storage = $this->getMockStorage(['getContent']);\n        $this->setService('storage', $storage);\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n\n        $storage->expects($this->at(1))\n            ->method('getContent')\n            ->will($this->returnValue($content1));\n\n        $kernel = $this->createMock(HttpKernelInterface::class);\n        $event = new GetResponseEvent($kernel, $this->getRequest(), HttpKernelInterface::MASTER_REQUEST);\n        $app['canonical']->onRequest($event);\n\n        // Route for /page/5 instead of /page/foo\n        $this->controller()->record($this->getRequest(), 'pages', 5);\n\n        $this->assertEquals('http://localhost/page/foo', $app['canonical']->getUrl(), 'Canonical url should use record slug instead of record ID');\n    }\n\n    public function testNumericRecord()\n    {\n        $this->setService('twig.runtime.bolt_html', $this->getHtmlRuntime());\n\n        $this->setRequest(Request::create('/pages/', 'GET', ['id' => 5]));\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $content1 = new Content($this->getApp(), $contentType);\n\n        $storage = $this->getMockStorage(['getContent']);\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n\n        $storage->expects($this->at(1))\n            ->method('getContent')\n            ->will($this->returnValue($content1));\n\n        $this->setService('storage', $storage);\n\n        $response = $this->controller()->record($this->getRequest(), 'pages', 5);\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('page.twig', $response->getTemplate());\n    }\n\n    /**\n     * @return HtmlRuntime\n     */\n    private function getHtmlRuntime()\n    {\n        $app = $this->getApp();\n\n        return new HtmlRuntime(\n            $app['config'],\n            $app['markdown'],\n            $app['menu'],\n            $app['storage']\n        );\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testNoRecord()\n    {\n        $this->setRequest(Request::create('/pages/', 'GET', ['id' => 5]));\n        $storage = $this->getMockStorage();\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n        $this->setService('storage', $storage);\n\n        $this->controller()->record($this->getRequest(), 'pages');\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testRecordNoTemplate()\n    {\n        $this->setRequest(Request::create('/pages/', 'GET', ['id' => 5]));\n        $storage = $this->getMockStorage();\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n        $this->setService('storage', $storage);\n\n        $this->controller()->record($this->getRequest(), 'pages');\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testViewlessRecord()\n    {\n        $this->setRequest(Request::create('/pages/test'));\n\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $contentType['viewless'] = true;\n\n        $storage = $this->getMockStorage();\n        $storage->expects($this->once())\n            ->method('getContentType')\n            ->will($this->returnValue($contentType));\n        $this->setService('storage', $storage);\n\n        $this->controller()->record($this->getRequest(), 'pages', 'test');\n    }\n\n    public function testPreview()\n    {\n        $this->setRequest(Request::create('/pages', 'POST'));\n        $this->controller()->listing($this->getRequest(), 'pages/test');\n\n        $templates = $this->getMockBuilder(TemplateChooser::class)\n            ->setMethods(['record'])\n            ->setConstructorArgs([$this->getApp()['config']])\n            ->getMock()\n        ;\n        $templates\n            ->expects($this->any())\n            ->method('record')\n            ->will($this->returnValue('record.twig'))\n        ;\n        $this->setService('templatechooser', $templates);\n\n        $response = $this->controller()->preview($this->getRequest(), 'pages');\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('record.twig', $response->getTemplate());\n    }\n\n    public function testListing()\n    {\n        $this->setRequest(Request::create('/pages'));\n        $response = $this->controller()->listing($this->getRequest(), 'pages');\n\n        $this->assertSame('listing.twig', $response->getTemplate());\n        $this->assertTrue($response instanceof TemplateView);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyListing()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/pages'));\n        $response = $this->controller()->listing($this->getRequest(), 'pages');\n\n        $this->assertSame('listing.twig', $response->getTemplate());\n        $this->assertTrue($response instanceof TemplateResponse);\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testViewlessListing()\n    {\n        $this->setRequest(Request::create('/'));\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $contentType['viewless'] = true;\n\n        $storage = $this->getMockStorage();\n        $storage->expects($this->once())\n            ->method('getContentType')\n            ->will($this->returnValue($contentType));\n        $this->setService('storage', $storage);\n\n        $response = $this->controller()->listing($this->getRequest(), 'pages');\n        $this->assertTrue($response instanceof TemplateView);\n    }\n\n    public function testBadTaxonomy()\n    {\n        $this->setRequest(Request::create('/faketaxonomy/main'));\n\n        $response = $this->controller()->taxonomy($this->getRequest(), 'faketaxonomy', 'main');\n        $this->assertFalse($response);\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage No slug\n     */\n    public function testNoContent404()\n    {\n        $this->setRequest(Request::create('/tags/fake'));\n\n        $this->controller()->taxonomy($this->getRequest(), 'tags', 'fake');\n    }\n\n    public function testTaxonomyListing()\n    {\n        $this->setRequest(Request::create('/categories/news'));\n        $this->getService('config')->set('taxonomy/categories/singular_slug', 'categories');\n\n        $response = $this->controller()->taxonomy($this->getRequest(), 'categories', 'news');\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('listing.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyTaxonomyListing()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/categories/news'));\n        $this->getService('config')->set('taxonomy/categories/singular_slug', 'categories');\n\n        $response = $this->controller()->taxonomy($this->getRequest(), 'categories', 'news');\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('listing.twig', $response->getTemplate());\n    }\n\n    public function testSimpleTemplateRender()\n    {\n        $this->setRequest(Request::create('/example'));\n\n        $response = $this->controller()->template('index');\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyTemplate()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/example'));\n\n        $response = $this->controller()->template('index');\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    /**\n     * @expectedException \\Twig\\Error\\LoaderError\n     * @expectedExceptionMessage Template \"nonexistent.twig\" is not defined.\n     */\n    public function testFailingTemplateRender()\n    {\n        $this->controller()->template('nonexistent');\n    }\n\n    public function testSearchListing()\n    {\n        $this->setRequest(Request::create('/search', 'GET', ['q' => 'Lorem']));\n\n        $response = $this->controller()->search($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('search.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacySearch()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/search', 'GET', ['q' => 'Lorem']));\n\n        $response = $this->controller()->search($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('search.twig', $response->getTemplate());\n    }\n\n    public function testSearchWithFilters()\n    {\n        $this->setRequest(Request::create('/search', 'GET', [\n            'search'          => 'Lorem',\n            'pages_title'     => 1,\n            'showcases_title' => 1,\n            'pages_body'      => 1,\n        ]));\n\n        $response = $this->controller()->search($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('search.twig', $response->getTemplate());\n    }\n\n    public function testBeforeHandlerForFirstUser()\n    {\n        $this->setRequest(Request::create('/'));\n\n        $users = $this->getMockUsers();\n\n        $users->expects($this->once())\n            ->method('getUsers')\n            ->will($this->returnValue(false));\n        $this->setService('users', $users);\n\n        $response = $this->controller()->before($this->getRequest());\n\n        $this->assertInstanceOf(RedirectResponse::class, $response);\n        $this->assertEquals('/bolt/userfirst', $response->getTargetUrl());\n    }\n\n    public function testBeforeHandlerForMaintenanceMode()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/maintenance_mode', true);\n\n        $permissions = $this->getMockPermissions();\n        $permissions->expects($this->any())\n            ->method('isAllowed')\n            ->will($this->returnValue(false));\n        $this->setService('permissions', $permissions);\n\n        $response = $this->controller()->before($this->getRequest());\n        $this->assertEquals(503, $response->getStatusCode());\n    }\n\n    public function testBeforeHandlerForPrivilegedMaintenanceMode()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/maintenance_mode', true);\n\n        $permissions = $this->getMockPermissions();\n        $permissions->expects($this->any())\n            ->method('isAllowed')\n            ->will($this->returnValue(true));\n        $this->setService('permissions', $permissions);\n\n        $response = $this->controller()->before($this->getRequest());\n\n        $this->assertNull($response);\n    }\n\n    public function testNormalBeforeHandler()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/maintenance_mode', false);\n\n        $response = $this->controller()->before($this->getRequest());\n\n        $this->assertNull($response);\n    }\n\n    /**\n     * @return \\Bolt\\Controller\\Frontend\n     */\n    protected function controller()\n    {\n        return $this->getService('controller.frontend');\n    }\n\n    protected function getTwigGlobals()\n    {\n        $app = $this->getApp();\n\n        return $app['twig']->getGlobals();\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Bolt;\n\nuse Bolt\\Collection\\Arr;\nuse Bolt\\Collection\\Bag;\nuse Bolt\\Common\\Deprecated;\nuse Bolt\\Controller\\Zone;\nuse Bolt\\Filesystem\\Exception\\FileNotFoundException;\nuse Bolt\\Filesystem\\Exception\\IOException;\nuse Bolt\\Filesystem\\Exception\\ParseException;\nuse Bolt\\Filesystem\\Handler\\DirectoryInterface;\nuse Bolt\\Filesystem\\Handler\\Image;\nuse Bolt\\Filesystem\\Handler\\JsonFile;\nuse Bolt\\Filesystem\\Handler\\ParsableInterface;\nuse Bolt\\Helpers\\Html;\nuse Bolt\\Helpers\\Str;\nuse Bolt\\Storage\\Database;\nuse Bolt\\Translation\\Translator;\nuse Bolt\\Translation\\Translator as Trans;\nuse Cocur\\Slugify\\Slugify;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse Silex;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Webmozart\\PathUtil\\Path;\n\n/**\n * Class for our config object.\n *\n * @deprecated Deprecated since 3.0, to be removed in 4.0.\n *\n * @author Bob den Otter, bob@twokings.nl\n */\nclass Config\n{\n    /** @var Silex\\Application */\n    protected $app;\n    /** @var array */\n    protected $data;\n    /** @var array */\n    protected $defaultConfig = [];\n    /** @var array */\n    protected $reservedFieldNames = [\n        'datechanged',\n        'datecreated',\n        'datedepublish',\n        'datepublish',\n        'id',\n        'link',\n        'ownerid',\n        'slug',\n        'status',\n        'templatefields',\n        'username',\n    ];\n\n    /** @var int */\n    protected $cachetimestamp;\n\n    /**\n     * Use {@see Config::getFields} instead.\n     * Will be made protected in Bolt 3.0.\n     *\n     * @var \\Bolt\\Storage\\Field\\Manager\n     */\n    public $fields;\n\n    /** @var bool @deprecated Deprecated since 3.2, to be removed in 4.0 */\n    public $notify_update;\n\n    /** @var array */\n    private $exceptions;\n\n    /** @var JsonFile */\n    private $cacheFile;\n\n    private $passed;\n\n    /**\n     * @param Silex\\Application $app\n     */\n    public function __construct(Silex\\Application $app)\n    {\n        $this->app = $app;\n    }\n\n    /**\n     * @return array|null\n     */\n    public function getExceptions()\n    {\n        return $this->exceptions;\n    }\n\n    public function initialize()\n    {\n        $this->fields = new Storage\\Field\\Manager();\n        $this->defaultConfig = $this->getDefaults();\n\n        $this->cacheFile = $this->app['filesystem']->getFile('cache://config-cache.json');\n\n        $data = $this->loadCache();\n        if ($data === null) {\n            $data = $this->getConfig();\n\n            // If we have to reload the config, we will also want to make sure\n            // the DB integrity is checked.\n            $this->app['schema.timer']->setCheckRequired();\n        }\n\n        $this->data = $data;\n\n        $this->loadTheme();\n\n        $this->setCKPath();\n        $this->parseTemplatefields();\n    }\n\n    /**\n     * Checks if cache is valid for theme; if not invalidate and load it.\n     */\n    private function loadTheme()\n    {\n        if ($this->isThemeCacheValid()) {\n            return;\n        }\n        $this->invalidateCache();\n\n        $themeDir = $this->app['filesystem']->getDir('themes://' . $this->get('general/theme'));\n\n        $this->data['theme'] = $this->parseTheme($themeDir, $this->data['general']);\n    }\n\n    /**\n     * Read and parse a YAML configuration file.\n     *\n     * @param string             $filename  The name of the YAML file to read\n     * @param DirectoryInterface $directory The (optional) directory to the YAML file\n     *\n     * @return array\n     */\n    protected function parseConfigYaml($filename, DirectoryInterface $directory = null)\n    {\n        $directory = $directory ?: $this->app['filesystem']->getDir('config://');\n\n        try {\n            $file = $directory->get($filename);\n        } catch (FileNotFoundException $e) {\n            // Copy in dist files if applicable\n            $distFiles = ['config.yml', 'contenttypes.yml', 'menu.yml', 'permissions.yml', 'routing.yml', 'taxonomy.yml'];\n            if ($directory->getMountPoint() !== 'config' || !in_array($filename, $distFiles)) {\n                return [];\n            }\n\n            $this->app['filesystem']->copy(\"bolt://app/config/$filename.dist\", \"config://$filename\");\n            $file = $directory->get($filename);\n        }\n\n        if (!$file instanceof ParsableInterface) {\n            throw new \\LogicException('File is not parsable.');\n        }\n\n        $yml = $file->parse() ?: [];\n\n        // Unset the repeated nodes key after parse\n        unset($yml['__nodes']);\n\n        return $yml;\n    }\n\n    /**\n     * Set a config value, using a path.\n     *\n     * For example:\n     * $app['config']->set('general/branding/name', 'Bolt');\n     *\n     * @param string $path\n     * @param mixed  $value\n     *\n     * @return bool\n     */\n    public function set($path, $value)\n    {\n        Arr::set($this->data, $path, $value);\n\n        return true;\n    }\n\n    /**\n     * Get a config value, using a path.\n     *\n     * For example:\n     * $var = $config->get('general/wysiwyg/ck/contentsCss');\n     *\n     * @param string            $path\n     * @param string|array|bool $default\n     *\n     * @return mixed\n     */\n    public function get($path, $default = null)\n    {\n        return Arr::get($this->data, $path, $default);\n    }\n\n    /**\n     * Replaces placeholders in config values %foo% will be resolved to $app['foo'] from the container.\n     *\n     * @internal This is only public so that it can be called from the service provider boot method.\n     * Do not access this directly since the API is liable to be changed at short notice.\n     *\n     * @param mixed $value\n     *\n     * @return mixed\n     */\n    public function doReplacements($value = null)\n    {\n        if ($value === null) {\n            $this->data = $this->doReplacements($this->data);\n\n            return;\n        }\n\n        if (!is_array($value) && ('%' !== substr($value, 0, 1) && '%' !== substr($value, -1, 1))) {\n            return $value;\n        }\n\n        if (is_array($value)) {\n            foreach ($value as $k => $v) {\n                if ($v === null) {\n                    continue;\n                }\n                $value[$k] = $this->doReplacements($v);\n            }\n\n            return $value;\n        }\n\n        if (is_string($value)) {\n            $serviceName = substr($value, 1, strlen($value) - 2);\n\n            // First we pass the raw variable name to getenv to see if an environment variable is set\n            $env = getenv($serviceName);\n            if ($env !== false) {\n                return $env;\n            }\n\n            if (strpos($serviceName, ':') !== false) {\n                list($serviceName, $params) = explode(':', $serviceName);\n            } else {\n                $params = [];\n            }\n\n            if (!isset($this->app[$serviceName])) {\n                return null;\n            }\n\n            $service = $this->app[$serviceName];\n\n            if (is_callable($service)) {\n                return call_user_func($service, $params);\n            }\n\n            return $service;\n        }\n\n        return $value;\n    }\n\n    /**\n     * Load the configuration from the various YML files.\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        $config = [];\n\n        $config['general'] = $this->parseGeneral();\n        $config['taxonomy'] = $this->parseTaxonomy();\n        $config['contenttypes'] = $this->parseContentTypes($config['general']);\n        $config['menu'] = $this->parseConfigYaml('menu.yml');\n        $config['routing'] = $this->parseConfigYaml('routing.yml');\n        $config['permissions'] = $this->parseConfigYaml('permissions.yml');\n        $config['extensions'] = $this->parseConfigYaml('extensions.yml');\n\n        return $config;\n    }\n\n    /**\n     * Read and parse the config.yml and config_local.yml configuration files.\n     *\n     * @return array\n     */\n    protected function parseGeneral()\n    {\n        // Read the config and merge it. (note: We use temp variables to prevent\n        // \"Only variables should be passed by reference\")\n        $tempconfig = $this->parseConfigYaml('config.yml');\n        $tempconfiglocal = $this->parseConfigYaml('config_local.yml');\n        $general = Arr::replaceRecursive($tempconfig, $tempconfiglocal);\n\n        // Merge the array with the defaults. Setting the required values that aren't already set.\n        $general = Arr::replaceRecursive($this->defaultConfig, $general);\n\n        if (isset($general['accept_file_types']) === true) {\n            if (is_array($general['accept_file_types']) === false) {\n                // Make sure old settings for 'accept_file_types' are not still picked up. Before 1.5.4 we used to store them\n                // as a regex-like string, and we switched to an array. If we find the old style, fall back to the defaults.\n                unset($general['accept_file_types']);\n            }\n\n            // To remove unacceptable / unwanted extensions from the list of Acceptable File Types\n            $removeFromAllowedFileTypes = explode('|', 'sh|asp|cgi|php|php3|ph3|php4|ph4|php5|ph5|phtm|phtml|exe');\n\n            // Create a bag with lowercased extensions\n            $bag = Bag::from($general['accept_file_types']);\n            $bag = $bag->map(function ($key, $ext) use ($removeFromAllowedFileTypes) {\n                if (!in_array(mb_strtolower($ext), $removeFromAllowedFileTypes)) {\n                    return mb_strtolower($ext);\n                } else {\n                    return null;\n                }\n            })->clean();\n\n            $general['accept_file_types'] = array_values($bag->toArray());\n        }\n\n        // Make sure Bolt's mount point is OK:\n        $general['branding']['path'] = '/' . Str::makeSafe($general['branding']['path']);\n\n        // Set the link in branding, if provided_by is set.\n        $general['branding']['provided_link'] = Html::providerLink(\n            $general['branding']['provided_by']\n        );\n\n        $general['database'] = $this->parseDatabase($general['database']);\n\n        return $general;\n    }\n\n    /**\n     * Read and parse the taxonomy.yml configuration file.\n     *\n     * @param array|null $taxonomies\n     *\n     * @return array\n     */\n    protected function parseTaxonomy(array $taxonomies = null)\n    {\n        $taxonomies = $taxonomies ?: $this->parseConfigYaml('taxonomy.yml');\n        $slugify = Slugify::create();\n\n        foreach ($taxonomies as $key => $taxonomy) {\n            if (!isset($taxonomy['name'])) {\n                $taxonomy['name'] = ucwords(str_replace('-', ' ', Common\\Str::humanize($taxonomy['slug'])));\n            }\n            if (!isset($taxonomy['singular_name'])) {\n                if (isset($taxonomy['singular_slug'])) {\n                    $taxonomy['singular_name'] = ucwords(str_replace('-', ' ', Common\\Str::humanize($taxonomy['singular_slug'])));\n                } else {\n                    $taxonomy['singular_name'] = ucwords(str_replace('-', ' ', Common\\Str::humanize($taxonomy['slug'])));\n                }\n            }\n            if (!isset($taxonomy['slug'])) {\n                $taxonomy['slug'] = $slugify->slugify($taxonomy['name']);\n            }\n            if (!isset($taxonomy['singular_slug'])) {\n                $taxonomy['singular_slug'] = $slugify->slugify($taxonomy['singular_name']);\n            }\n            if (!isset($taxonomy['has_sortorder'])) {\n                $taxonomy['has_sortorder'] = false;\n            }\n            if (!isset($taxonomy['allow_spaces'])) {\n                $taxonomy['allow_spaces'] = false;\n            }\n\n            // Make sure the options are $key => $value pairs, and not have implied integers for keys.\n            if (!empty($taxonomy['options']) && is_array($taxonomy['options'])) {\n                $options = [];\n                foreach ($taxonomy['options'] as $optionKey => $optionValue) {\n                    if (is_numeric($optionKey)) {\n                        $optionKey = $optionValue;\n                    }\n                    $optionKey = $slugify->slugify($optionKey);\n                    $options[$optionKey] = $optionValue;\n                }\n                $taxonomy['options'] = $options;\n            }\n\n            if (!isset($taxonomy['behaves_like'])) {\n                $taxonomy['behaves_like'] = 'tags';\n            }\n            // If taxonomy is like tags, set 'tagcloud' to true by default.\n            if (($taxonomy['behaves_like'] === 'tags') && (!isset($taxonomy['tagcloud']))) {\n                $taxonomy['tagcloud'] = true;\n            } else {\n                $taxonomy += ['tagcloud' => false];\n            }\n\n            $taxonomies[$key] = $taxonomy;\n        }\n\n        return $taxonomies;\n    }\n\n    /**\n     * Read and parse the contenttypes.yml configuration file.\n     *\n     * @param array $generalConfig\n     *\n     * @return array\n     */\n    protected function parseContentTypes(array $generalConfig)\n    {\n        $contentTypes = [];\n        $tempContentTypes = $this->parseConfigYaml('contenttypes.yml');\n        foreach ($tempContentTypes as $key => $contentType) {\n            try {\n                $contentType = $this->parseContentType($key, $contentType, $generalConfig);\n                $contentTypes[$key] = $contentType;\n            } catch (InvalidArgumentException $e) {\n                $this->exceptions[] = $e->getMessage();\n            }\n        }\n\n        return $contentTypes;\n    }\n\n    /**\n     * Read and parse the current theme's config.yml configuration file.\n     *\n     * @param DirectoryInterface $themeDir\n     * @param array              $generalConfig\n     *\n     * @return array\n     */\n    protected function parseTheme(DirectoryInterface $themeDir, array $generalConfig)\n    {\n        $themeConfig = $this->parseConfigYaml('theme.yml', $themeDir);\n\n        /** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */\n        if (empty($themeConfig)) {\n            $themeConfig = $this->parseConfigYaml('config.yml', $themeDir);\n        }\n\n        if ((isset($themeConfig['templatefields'])) && (is_array($themeConfig['templatefields']))) {\n            $templateContentTypes = [];\n\n            foreach ($themeConfig['templatefields'] as $template => $templateFields) {\n                $fieldsContenttype = [\n                    'fields'        => $templateFields,\n                    'singular_name' => 'Template Fields ' . $template,\n                ];\n\n                try {\n                    $templateContentTypes[$template] = $this->parseContentType(\n                        $template,\n                        $fieldsContenttype,\n                        $generalConfig\n                    );\n                } catch (InvalidArgumentException $e) {\n                    $this->exceptions[] = $e->getMessage();\n                }\n            }\n\n            $themeConfig['templatefields'] = $templateContentTypes;\n        }\n\n        return $themeConfig;\n    }\n\n    /**\n     * This method pulls the templatefields config from the theme config and appends it\n     * to the contenttypes configuration.\n     */\n    protected function parseTemplatefields()\n    {\n        $theme = $this->data['theme'];\n\n        if (isset($theme['templatefields'])) {\n            foreach ($this->data['contenttypes'] as $key => $ct) {\n                foreach ($ct['fields'] as $field) {\n                    if (isset($field['type']) && $field['type'] === 'templateselect') {\n                        $this->data['contenttypes'][$key]['templatefields'] = $theme['templatefields'];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Parse a single Contenttype configuration array.\n     *\n     * @param string $key\n     * @param array  $contentType\n     * @param array  $generalConfig\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function parseContentType($key, $contentType, $generalConfig)\n    {\n        // If the slug isn't set, and the 'key' isn't numeric, use that as the slug.\n        if (!isset($contentType['slug']) && !is_numeric($key)) {\n            $contentType['slug'] = Slugify::create()->slugify($key);\n        }\n\n        // If neither 'name' nor 'slug' is set, we need to warn the user. Same goes for when\n        // neither 'singular_name' nor 'singular_slug' is set.\n        if (!isset($contentType['name']) && !isset($contentType['slug'])) {\n            $error = sprintf(\"In contenttype <code>%s</code>, neither 'name' nor 'slug' is set. Please edit <code>contenttypes.yml</code>, and correct this.\", $key);\n            throw new InvalidArgumentException($error);\n        }\n        if (!isset($contentType['singular_name']) && !isset($contentType['singular_slug'])) {\n            $error = sprintf(\"In contenttype <code>%s</code>, neither 'singular_name' nor 'singular_slug' is set. Please edit <code>contenttypes.yml</code>, and correct this.\", $key);\n            throw new InvalidArgumentException($error);\n        }\n\n        // Contenttypes without fields make no sense.\n        if (!isset($contentType['fields'])) {\n            $error = sprintf(\"In contenttype <code>%s</code>, no 'fields' are set. Please edit <code>contenttypes.yml</code>, and correct this.\", $key);\n            throw new InvalidArgumentException($error);\n        }\n\n        if (!isset($contentType['slug'])) {\n            $contentType['slug'] = Slugify::create()->slugify($contentType['name']);\n        }\n        if (!isset($contentType['name'])) {\n            $contentType['name'] = ucwords(preg_replace('/[^a-z0-9]/i', ' ', $contentType['slug']));\n        }\n        if (!isset($contentType['singular_slug'])) {\n            $contentType['singular_slug'] = Slugify::create()->slugify($contentType['singular_name']);\n        }\n        if (!isset($contentType['singular_name'])) {\n            $contentType['singular_name'] = ucwords(preg_replace('/[^a-z0-9]/i', ' ', $contentType['singular_slug']));\n        }\n        if (!isset($contentType['show_on_dashboard'])) {\n            $contentType['show_on_dashboard'] = true;\n        }\n        if (!isset($contentType['show_in_menu'])) {\n            $contentType['show_in_menu'] = true;\n        }\n        if (!isset($contentType['sort'])) {\n            $contentType['sort'] = false;\n        }\n        if (!isset($contentType['default_status'])) {\n            $contentType['default_status'] = 'draft';\n        }\n        if (!isset($contentType['viewless'])) {\n            $contentType['viewless'] = false;\n        }\n        if (!isset($contentType['liveeditor'])) {\n            $contentType['liveeditor'] = true;\n        }\n        // Override contenttype setting with view and config settings\n        if (($contentType['viewless']) || (!$generalConfig['liveeditor'])) {\n            $contentType['liveeditor'] = false;\n        }\n        // Allow explicit setting of a Contenttype's table name suffix. We default\n        // to slug if not present as it has been this way since Bolt v1.2.1\n        if (!isset($contentType['tablename'])) {\n            $contentType['tablename'] = Slugify::create()->slugify($contentType['slug'], '_');\n        } else {\n            $contentType['tablename'] = Slugify::create()->slugify($contentType['tablename'], '_');\n        }\n        if (!isset($contentType['allow_numeric_slugs'])) {\n            $contentType['allow_numeric_slugs'] = false;\n        }\n        if (!isset($contentType['singleton'])) {\n            $contentType['singleton'] = false;\n        }\n\n        list($fields, $groups) = $this->parseFieldsAndGroups($contentType['fields'], $generalConfig);\n        $contentType['fields'] = $fields;\n        $contentType['groups'] = $groups;\n\n        // Make sure taxonomy is an array.\n        if (isset($contentType['taxonomy'])) {\n            $contentType['taxonomy'] = (array) $contentType['taxonomy'];\n        }\n\n        // when adding relations, make sure they're added by their slug. Not their 'name' or 'singular name'.\n        if (!empty($contentType['relations']) && is_array($contentType['relations'])) {\n            foreach (array_keys($contentType['relations']) as $relkey) {\n                if ($relkey != Slugify::create()->slugify($relkey)) {\n                    $contentType['relations'][Slugify::create()->slugify($relkey)] = $contentType['relations'][$relkey];\n                    unset($contentType['relations'][$relkey]);\n                }\n            }\n        }\n\n        return $contentType;\n    }\n\n    /**\n     * Parse a Contenttype's filed and determine the grouping.\n     *\n     * @param array $fields\n     * @param array $generalConfig\n     *\n     * @return array\n     */\n    protected function parseFieldsAndGroups(array $fields, array $generalConfig)\n    {\n        $acceptableFileTypes = $generalConfig['accept_file_types'];\n\n        $currentGroup = 'ungrouped';\n        $groups = [];\n        $hasGroups = false;\n\n        foreach ($fields as $key => $field) {\n            unset($fields[$key]);\n            $key = str_replace('-', '_', strtolower(Str::makeSafe($key, true)));\n            if (!isset($field['type']) || empty($field['type'])) {\n                $error = sprintf('Field \"%s\" has no \"type\" set.', $key);\n\n                throw new InvalidArgumentException($error);\n            }\n\n            // If field is a \"file\" type, make sure the 'extensions' are set, and it's an array.\n            if ($field['type'] == 'file' || $field['type'] == 'filelist') {\n                if (empty($field['extensions'])) {\n                    $field['extensions'] = $acceptableFileTypes;\n                }\n\n                $field['extensions'] = (array) $field['extensions'];\n            }\n\n            // If field is an \"image\" type, make sure the 'extensions' are set, and it's an array.\n            if ($field['type'] == 'image' || $field['type'] == 'imagelist') {\n                if (empty($field['extensions'])) {\n                    $field['extensions'] = array_intersect(\n                        Image\\Type::getExtensions(),\n                        $acceptableFileTypes\n                    );\n                }\n\n                $field['extensions'] = (array) $field['extensions'];\n            }\n\n            // Make indexed arrays into associative for select fields\n            // e.g.: [ 'yes', 'no' ] => { 'yes': 'yes', 'no': 'no' }\n            if ($field['type'] === 'select' && isset($field['values']) && Arr::isIndexed($field['values'])) {\n                $field['values'] = array_combine($field['values'], $field['values']);\n            }\n\n            if (!empty($field['group'])) {\n                $hasGroups = true;\n            }\n\n            // Make sure we have these keys and every field has a group set.\n            $field = array_replace(\n                [\n                    'class'   => '',\n                    'default' => '',\n                    'group'   => $currentGroup,\n                    'label'   => '',\n                    'variant' => '',\n                ],\n                $field\n            );\n\n            // Collect group data for rendering.\n            // Make sure that once you started with group all following have that group, too.\n            $currentGroup = $field['group'];\n            $groups[$currentGroup] = 1;\n\n            $fields[$key] = $field;\n\n            // Repeating fields checks\n            if ($field['type'] === 'repeater') {\n                $fields[$key] = $this->parseFieldRepeaters($fields, $key);\n                if ($fields[$key] === null) {\n                    unset($fields[$key]);\n                }\n            }\n        }\n\n        // Make sure the 'uses' of the slug is an array.\n        if (isset($fields['slug']) && isset($fields['slug']['uses'])) {\n            $fields['slug']['uses'] = (array) $fields['slug']['uses'];\n        }\n\n        return [$fields, $hasGroups ? array_keys($groups) : []];\n    }\n\n    /**\n     * Basic validation of repeater fields.\n     *\n     * @param array  $fields\n     * @param string $key\n     *\n     * @return array\n     */\n    private function parseFieldRepeaters(array $fields, $key)\n    {\n        $blacklist = ['repeater', 'slug', 'templatefield'];\n        $repeater = $fields[$key];\n\n        if (!isset($repeater['fields']) || !is_array($repeater['fields'])) {\n            return;\n        }\n\n        foreach ($repeater['fields'] as $repeaterKey => $repeaterField) {\n            if (!isset($repeaterField['type']) || in_array($repeaterField['type'], $blacklist)) {\n                unset($repeater['fields'][$repeaterKey]);\n            }\n        }\n\n        return $repeater;\n    }\n\n    /**\n     * Parse and fine-tune the database configuration.\n     *\n     * @param array $options\n     *\n     * @return array\n     */\n    protected function parseDatabase(array $options)\n    {\n        // Make sure prefix ends with underscore\n        if (substr($options['prefix'], strlen($options['prefix']) - 1) !== '_') {\n            $options['prefix'] .= '_';\n        }\n\n        // Parse master connection parameters\n        $master = $this->parseConnectionParams($options);\n        // Merge master connection into options\n        $options = array_replace($options, $master);\n\n        // Add platform specific random functions\n        $driver = \\Bolt\\Common\\Str::replaceFirst($options['driver'], 'pdo_', '');\n        if ($driver === 'sqlite') {\n            $options['driver'] = 'pdo_sqlite';\n            $options['randomfunction'] = 'RANDOM()';\n        } elseif (in_array($driver, ['mysql', 'mysqli'])) {\n            $options['driver'] = 'pdo_mysql';\n            $options['randomfunction'] = 'RAND()';\n        } elseif (in_array($driver, ['pgsql', 'postgres', 'postgresql'])) {\n            $options['driver'] = 'pdo_pgsql';\n            $options['randomfunction'] = 'RANDOM()';\n        }\n\n        // Specify the wrapper class for the connection\n        $options['wrapperClass'] = Database\\Connection::class;\n\n        // Parse SQLite separately since it has to figure out database path\n        if ($driver === 'sqlite') {\n            return $this->parseSqliteOptions($options);\n        }\n\n        // If no slaves return with single connection\n        if (empty($options['slaves'])) {\n            return $options;\n        }\n\n        // Specify we want a master slave connection\n        $options['wrapperClass'] = Database\\MasterSlaveConnection::class;\n\n        // Add master connection where MasterSlaveConnection looks for it.\n        $options['master'] = $master;\n\n        // Parse each slave connection parameters\n        foreach ($options['slaves'] as $name => $slave) {\n            $options['slaves'][$name] = $this->parseConnectionParams($slave, $master);\n        }\n\n        return $options;\n    }\n\n    /**\n     * Fine-tune Sqlite configuration parameters.\n     *\n     * @param array $config\n     *\n     * @return array\n     */\n    protected function parseSqliteOptions(array $config)\n    {\n        if (isset($config['memory']) && $config['memory']) {\n            // If in-memory, no need to parse paths\n            unset($config['path']);\n\n            return $config;\n        }\n        // Prevent SQLite driver from trying to use in-memory connection\n        unset($config['memory']);\n\n        // Get path from config or use database path\n        $path = isset($config['path']) ? $config['path'] : $this->app['path_resolver']->resolve('database');\n        if (Path::isRelative($path)) {\n            $path = $this->app['path_resolver']->resolve($path);\n        }\n\n        // If path has filename with extension, use that\n        if (Path::hasExtension($path)) {\n            $config['path'] = $path;\n\n            return $config;\n        }\n\n        // Use database name for filename\n        $filename = basename($config['dbname']);\n        if (!Path::hasExtension($filename)) {\n            $filename .= '.db';\n        }\n\n        // Join filename with database path\n        $config['path'] = Path::join($path, $filename);\n\n        return $config;\n    }\n\n    /**\n     * Parses params to valid connection parameters.\n     *\n     * - Defaults are merged into the params\n     * - Bolt keys are converted to Doctrine keys\n     * - Invalid keys are filtered out\n     *\n     * @param array|string $params\n     * @param array        $defaults\n     *\n     * @return array\n     */\n    protected function parseConnectionParams($params, $defaults = [])\n    {\n        // Handle host shortcut\n        if (is_string($params)) {\n            $params = ['host' => $params];\n        }\n\n        // Convert keys from Bolt\n        $replacements = [\n            'databasename' => 'dbname',\n            'username'     => 'user',\n        ];\n        foreach ($replacements as $old => $new) {\n            if (isset($params[$old])) {\n                $params[$new] = $params[$old];\n                unset($params[$old]);\n            }\n        }\n\n        // Merge in defaults\n        $params = array_replace($defaults, $params);\n\n        // Filter out invalid keys\n        $validKeys = [\n            'user', 'password', 'host', 'port', 'dbname', 'charset',      // common\n            'path', 'memory',                                             // Qqlite\n            'unix_socket', 'driverOptions', 'collate',                    // MySql\n            'sslmode',                                                    // PostgreSQL\n            'servicename', 'service', 'pooled', 'instancename', 'server', // Oracle\n            'persistent',                                                 // SQL Anywhere\n        ];\n        $params = array_intersect_key($params, array_flip($validKeys));\n\n        return $params;\n    }\n\n    /**\n     * Sanity check for slashes in in taxonomy slugs.\n     *\n     * @return bool\n     */\n    private function checkTaxonomy()\n    {\n        foreach ($this->data['taxonomy'] as $key => $taxonomy) {\n            if (empty($taxonomy['options']) || !is_array($taxonomy['options'])) {\n                continue;\n            }\n\n            foreach ($taxonomy['options'] as $optionKey => $optionValue) {\n                if (strpos($optionKey, '/') === false) {\n                    continue;\n                }\n\n                $this->passed = false;\n                $error = Trans::__(\n                    'general.phrase.invalid-taxonomy-slug',\n                    ['%taxonomy%' => $key, '%option%' => $optionValue]\n                );\n                $this->app['logger.flash']->error($error);\n            }\n        }\n\n        return $this->passed;\n    }\n\n    /**\n     * Sanity checks for doubles in in contenttypes.\n     *\n     * @return bool\n     */\n    public function checkConfig()\n    {\n        $slugs = [];\n        if ($this->passed === null) {\n            $this->passed = true;\n        } else {\n            return $this->passed;\n        }\n\n        foreach ($this->data['contenttypes'] as $key => $ct) {\n            // Make sure that there are no hyphens in the contenttype name, advise to change to underscores\n            if (strpos($key, '-') !== false) {\n                $error = Trans::__(\n                    'contenttypes.generic.invalid-hyphen',\n                    [\n                        '%contenttype%' => $key,\n                    ]\n                );\n                $this->app['logger.flash']->error($error);\n                unset($this->data['contenttypes'][$key]);\n\n                $this->passed = false;\n            }\n\n            /**\n             * Make sure any field that has a 'uses' parameter actually points to a field that exists.\n             *\n             * For example, this will show a notice:\n             * entries:\n             *   name: Entries\n             *     singular_name: Entry\n             *     fields:\n             *       title:\n             *         type: text\n             *         class: large\n             *       slug:\n             *         type: slug\n             *         uses: name\n             */\n            foreach ($ct['fields'] as $fieldname => $field) {\n                // Verify that the contenttype doesn't try to add fields that are reserved.\n                if ($fieldname != 'slug' && in_array($fieldname, $this->reservedFieldNames)) {\n                    $error = Trans::__(\n                        'contenttypes.generic.reserved-name',\n                        ['%contenttype%' => $key, '%field%' => $fieldname]\n                    );\n                    $this->app['logger.flash']->danger($error);\n\n                    $this->passed = false;\n                }\n\n                // Check 'uses'. If it's an array, split it up, and check the separate parts. We also need to check\n                // for the fields that are always present, like 'id'.\n                if (!empty($field['uses']) && is_array($field['uses'])) {\n                    foreach ((array) $field['uses'] as $useField) {\n                        if (!empty($field['uses']) && empty($ct['fields'][$useField]) && !in_array($useField, $this->reservedFieldNames)) {\n                            $error = Trans::__(\n                                'contenttypes.generic.wrong-use-field',\n                                ['%contenttype%' => $key, '%field%' => $fieldname, '%uses%' => $useField]\n                            );\n                            $this->app['logger.flash']->warning($error);\n\n                            $this->passed = false;\n                        }\n                    }\n                }\n\n                // Check if all the used fields are existing field types.\n                // Note: Check is disabled for now, because of the load order. At this point\n                // in the execution, field types added by extensions are not yet initialised,\n                // giving \"false positives\". See https://github.com/bolt/bolt/pull/7260\n                /*\n                if (!isset($field['type']) || !$this->fields->has($field['type'])) {\n                    $error = Trans::__(\n                        'contenttypes.generic.no-proper-type',\n                        [\n                            '%contenttype%' => $key,\n                            '%field%'       => $fieldname,\n                            '%type%'        => $field['type'],\n                        ]\n                    );\n                    $this->app['logger.flash']->warning($error);\n\n                    unset($ct['fields'][$fieldname]);\n                    $this->passed = false;\n                }\n                */\n\n                // Make sure that there are no consecutive underscores in field names\n                if (strpos($fieldname, '__') !== false) {\n                    $error = Trans::__(\n                        'contenttypes.generic.consecutive-underscores',\n                        [\n                            '%contenttype%' => $key,\n                            '%field%'       => $fieldname,\n                            '%type%'        => $field['type'],\n                        ]\n                    );\n                    $this->app['logger.flash']->warning($error);\n\n                    unset($ct['fields'][$fieldname]);\n                    $this->passed = false;\n                }\n            }\n\n            /**\n             * Make sure any contenttype that has a 'relation' defined points to a contenttype that exists.\n             */\n            if (isset($ct['relations'])) {\n                foreach ($ct['relations'] as $relKey => $relData) {\n                    // For BC we check if relation uses hyphen and re-map to underscores\n                    if (strpos($relKey, '-') !== false) {\n                        $newRelKey = str_replace('-', '_', strtolower(Str::makeSafe($relKey, true)));\n                        unset($this->data['contenttypes'][$key]['relations'][$relKey]);\n                        $this->data['contenttypes'][$key]['relations'][$newRelKey] = $relData;\n                        $relKey = $newRelKey;\n                    }\n                    if (!isset($this->data['contenttypes'][$relKey])) {\n                        $error = Trans::__(\n                            'contenttypes.generic.invalid-relation',\n                            ['%contenttype%' => $key, '%relation%' => $relKey]\n                        );\n                        $this->app['logger.flash']->error($error);\n\n                        unset($this->data['contenttypes'][$key]['relations'][$relKey]);\n                        $this->passed = false;\n                    }\n                    if (array_key_exists($relKey, $ct['fields'])) {\n                        $error = Trans::__(\n                            'general.phrase.clashing-relation',\n                            ['%contenttype%' => $key, '%relation%' => $relKey]\n                        );\n                        $this->app['logger.flash']->error($error);\n                    }\n                }\n            }\n\n            // Keep a running score of used slugs.\n            if (!isset($slugs[$ct['slug']])) {\n                $slugs[$ct['slug']] = 0;\n            }\n            ++$slugs[$ct['slug']];\n            if (!isset($slugs[$ct['singular_slug']])) {\n                $slugs[$ct['singular_slug']] = 0;\n            }\n            if ($ct['singular_slug'] != $ct['slug']) {\n                ++$slugs[$ct['singular_slug']];\n            }\n        }\n\n        // Sanity checks for taxonomy.yml\n        foreach ($this->data['taxonomy'] as $key => $taxo) {\n            // Show some helpful warnings if slugs or keys are not set correctly.\n            if ($taxo['slug'] != $key) {\n                $error = Trans::__(\n                    \"The identifier and slug for '%taxonomytype%' are the not the same ('%slug%' vs. '%taxonomytype%'). Please edit taxonomy.yml, and make them match to prevent inconsistencies between database storage and your templates.\",\n                    ['%taxonomytype%' => $key, '%slug%' => $taxo['slug']]\n                );\n                $this->app['logger.flash']->warning($error);\n\n                $this->passed = false;\n            }\n        }\n\n        // if there aren't any other errors, check for duplicates across contenttypes.\n        if (!$this->app['logger.flash']->has('error')) {\n            foreach ($slugs as $slug => $count) {\n                if ($count > 1) {\n                    $error = Trans::__(\n                        \"The slug '%slug%' is used in more than one contenttype. Please edit contenttypes.yml, and make them distinct.\",\n                        ['%slug%' => $slug]\n                    );\n                    $this->app['logger.flash']->warning($error);\n\n                    $this->passed = false;\n                }\n            }\n        }\n\n        return $this->checkTaxonomy();\n    }\n\n    /**\n     * A getter to access the fields manager.\n     *\n     * @return \\Bolt\\Storage\\Field\\Manager\n     **/\n    public function getFields()\n    {\n        return $this->fields;\n    }\n\n    /**\n     * Assume sensible defaults for a number of options.\n     */\n    protected function getDefaults()\n    {\n        return [\n            'database'    => [\n                'driver'         => 'sqlite',\n                'host'           => 'localhost',\n                'slaves'         => [],\n                'dbname'         => 'bolt',\n                'prefix'         => 'bolt_',\n                'charset'        => 'utf8',\n                'collate'        => 'utf8_unicode_ci',\n                'randomfunction' => '',\n            ],\n            'sitename'                    => 'Default Bolt site',\n            'locale'                      => null,\n            'recordsperpage'              => 10,\n            'recordsperdashboardwidget'   => 5,\n            'systemlog'                   => [\n                'enabled' => true,\n            ],\n            'changelog'                   => [\n                'enabled' => false,\n            ],\n            'debuglog'                    => [\n                'enabled'  => false,\n                'level'    => 'DEBUG',\n                'filename' => 'bolt-debug.log',\n            ],\n            'debug'                       => null,\n            'debug_show_loggedoff'        => false,\n            'debug_error_level'           => null,\n            'production_error_level'      => null,\n            'debug_enable_whoops'         => false, /** @deprecated. Deprecated since 3.2, to be removed in 4.0 */\n            'debug_error_use_symfony'     => false,\n            'debug_permission_audit_mode' => false,\n            'debug_trace_argument_limit'  => 4,\n            'strict_variables'            => null,\n            'theme'                       => 'base-2016',\n            'listing_template'            => 'listing.twig',\n            'listing_records'             => '5',\n            'listing_sort'                => 'datepublish DESC',\n            'caching'                     => [\n                'config'    => true,\n                'templates' => true,\n                'request'   => false,\n                'duration'  => 10,\n            ],\n            'wysiwyg'                     => [\n                'images'      => false,\n                'tables'      => false,\n                'fontcolor'   => false,\n                'align'       => false,\n                'subsuper'    => false,\n                'embed'       => false,\n                'anchor'      => false,\n                'underline'   => false,\n                'strike'      => false,\n                'blockquote'  => false,\n                'codesnippet' => false,\n                'specialchar' => false,\n                'styles'      => false,\n                'ck'          => [\n                    'autoParagraph'           => true,\n                    'contentsCss'             => [\n                        ['css/ckeditor-contents.css', 'bolt'],\n                        ['css/ckeditor.css', 'bolt'],\n                    ],\n                    'filebrowserWindowWidth'  => 640,\n                    'filebrowserWindowHeight' => 480,\n                ],\n            ],\n            'liveeditor'                  => true,\n            'canonical'                   => null,\n            'developer_notices'           => false,\n            'cookies_use_remoteaddr'      => true,\n            'cookies_use_browseragent'    => false,\n            'cookies_use_httphost'        => true,\n            'cookies_lifetime'            => 14 * 24 * 3600,\n            'enforce_ssl'                 => false,\n            'thumbnails'                  => [\n                'default_thumbnail' => [160, 120],\n                'default_image'     => [1000, 750],\n                'quality'           => 75,\n                'cropping'          => 'crop',\n                'notfound_image'    => 'bolt_assets://img/default_notfound.png',\n                'error_image'       => 'bolt_assets://img/default_error.png',\n                'only_aliases'      => false,\n            ],\n            'accept_file_types'           => explode(',', 'twig,html,js,css,scss,gif,jpg,jpeg,png,ico,zip,tgz,txt,md,doc,docx,pdf,epub,xls,xlsx,csv,ppt,pptx,mp3,ogg,wav,m4a,mp4,m4v,ogv,wmv,avi,webm,svg'),\n            'hash_strength'               => 10,\n            'branding'                    => [\n                'name'        => 'Bolt',\n                'path'        => '/bolt',\n                'provided_by' => [],\n            ],\n            'maintenance_mode'            => false,\n            'headers'                     => [\n                'x_frame_options' => true,\n            ],\n            'htmlcleaner'                 => [\n                'allowed_tags'       => explode(',', 'div,span,p,br,hr,s,u,strong,em,i,b,li,ul,ol,mark,blockquote,pre,code,tt,h1,h2,h3,h4,h5,h6,dd,dl,dh,table,tbody,thead,tfoot,th,td,tr,a,img,address,abbr,iframe'),\n                'allowed_attributes' => explode(',', 'id,class,style,name,value,href,src,alt,title,width,height,frameborder,allowfullscreen,scrolling'),\n            ],\n            'performance'                 => [\n                'http_cache'    => [\n                    'options' => [],\n                ],\n                'timed_records' => [\n                    'interval' => 3600,\n                    'use_cron' => false,\n                ],\n            ],\n        ];\n    }\n\n    /**\n     * Build an array of Twig paths.\n     *\n     * @return string[]\n     */\n    public function getTwigPath()\n    {\n        Deprecated::method(3.3);\n\n        $themepath = $this->app['resources']->getPath('templatespath');\n\n        $twigpath = [];\n\n        if (file_exists($themepath)) {\n            $twigpath[] = $themepath;\n        } else {\n            // If the template path doesn't exist, flash error on the dashboard.\n            $relativethemepath = basename($this->get('general/theme'));\n            $theme = $this->get('theme');\n            if (isset($theme['template_directory'])) {\n                $relativethemepath .= '/' . $this->get('theme/template_directory');\n            }\n\n            $error = \"Template folder 'theme/\" . $relativethemepath . \"' does not exist, or is not writable.\";\n            $this->app['logger.flash']->danger($error);\n        }\n\n        // We add these later, because the order is important: By having theme/ourtheme first,\n        // files in that folder will take precedence. For instance when overriding the menu template.\n        $twigpath[] = $this->app['resources']->getPath('src/../app/theme_defaults');\n\n        return $twigpath;\n    }\n\n    /**\n     * @deprecated Deprecated since 3.3, to be removed in 4.0.\n     */\n    public function setCKPath()\n    {\n    }\n\n    /**\n     * Attempt to load cached configuration files.\n     *\n     * @throws RuntimeException\n     *\n     * @return array|null\n     */\n    protected function loadCache()\n    {\n        if ($this->isCacheValid() === false) {\n            return null;\n        }\n\n        $data = null;\n\n        try {\n            $data = $this->cacheFile->parse();\n        } catch (ParseException $e) {\n            // JSON is invalid, remove the file\n            $this->invalidateCache();\n        } catch (IOException $e) {\n            $part = Translator::__(\n                'Try logging in with your ftp-client and make the file readable. ' .\n                'Else try to go <a>back</a> to the last page.'\n            );\n            $message = '<p>' . Translator::__('general.phrase.file-not-readable-following-colon') . '</p>' .\n                '<pre>' . htmlspecialchars($this->cacheFile->getFullPath()) . '</pre>' .\n                '<p>' . str_replace('<a>', '<a href=\"javascript:history.go(-1)\">', $part) . '</p>';\n\n            throw new RuntimeException(Translator::__('page.file-management.message.file-not-readable' . $message), $e->getCode(), $e);\n        }\n\n        // Check if we loaded actual data.\n        if (count($data) < 4 || empty($data['general'])) {\n            return null;\n        }\n\n        // Yup, all seems to be right.\n        return $data;\n    }\n\n    /**\n     * Check if the cached config file exists, and is newer than the authoritative source.\n     *\n     * @return bool\n     */\n    private function isCacheValid()\n    {\n        if (!$this->cacheFile->exists()) {\n            return false;\n        }\n\n        $cachedConfigTimestamp = $this->cacheFile->getTimestamp();\n\n        /** @var \\Bolt\\Filesystem\\Filesystem $configFs */\n        $configFs = $this->app['filesystem']->getFilesystem('config');\n\n        $configFiles = [\n            'config.yml',\n            'config_local.yml',\n            'contenttypes.yml',\n            'extensions.yml',\n            'menu.yml',\n            'permissions.yml',\n            'routing.yml',\n            'taxonomy.yml',\n        ];\n        foreach ($configFiles as $configFile) {\n            $timestamp = $configFs->has($configFile) ? $configFs->get($configFile)->getTimestamp() : 0;\n            if ($timestamp > $cachedConfigTimestamp) {\n                // The configuration file timestamp is *newer* than the cache file's \u2026 invalidate!\n                $this->invalidateCache();\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if the cache is still valid with theme file as well.\n     *\n     * @return bool\n     */\n    private function isThemeCacheValid()\n    {\n        if (!$this->cacheFile->exists()) {\n            return false;\n        }\n\n        $themeDir = $this->app['filesystem']->getDir('themes://' . $this->get('general/theme'));\n\n        // Check the timestamp for the theme's configuration file\n        $timestampTheme = 0;\n        $themeFile = $themeDir->getFile('theme.yml');\n        if ($themeFile->exists()) {\n            $timestampTheme = $themeFile->getTimestamp();\n        } elseif (($themeFile = $themeDir->getFile('config.yml')) && $themeFile->exists()) {\n            /** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */\n            $timestampTheme = $themeFile->getTimestamp();\n        }\n\n        return $this->cacheFile->getTimestamp() > $timestampTheme;\n    }\n\n    /**\n     * Invalidate (remove) the cache file.\n     */\n    private function invalidateCache()\n    {\n        try {\n            $this->cacheFile->delete();\n        } catch (IOException $e) {\n            // We were unable to remove the file\u2026 time to retire this class\n        }\n    }\n\n    /**\n     * @internal Do not use\n     *\n     * @param bool $force\n     */\n    public function cacheConfig($force = false)\n    {\n        if ($this->cacheFile->exists() && $force === false) {\n            return;\n        }\n        $this->cacheFile->dump($this->data);\n    }\n\n    /**\n     * @deprecated Deprecated since 3.2, to be removed in 4.0. Now handled in a listener.\n     */\n    protected function saveCache()\n    {\n    }\n\n    /**\n     * @deprecated Deprecated since 3.2, to be removed in 4.0.\n     */\n    protected function checkValidCache()\n    {\n    }\n\n    /**\n     * Get a timestamp, corrected to the timezone.\n     *\n     * @param mixed $when\n     *\n     * @return string Timestamp\n     */\n    public function getTimestamp($when)\n    {\n        Deprecated::method(3.3);\n\n        $timezone = $this->get('general/timezone');\n        $now = date_format(new \\DateTime($when, new \\DateTimeZone($timezone)), 'Y-m-d H:i:s');\n\n        return $now;\n    }\n\n    /**\n     * Get the current timestamp, corrected to the timezone.\n     *\n     * @return string Current timestamp\n     */\n    public function getCurrentTimestamp()\n    {\n        Deprecated::method(3.3);\n\n        $timezone = $this->get('general/timezone');\n        $now = date_format(new \\DateTime($timezone), 'Y-m-d H:i:s');\n\n        return $now;\n    }\n\n    /**\n     * Use {@see Zone} instead with a {@see Request}.\n     *\n     * Going forward, decisions determined by current request\n     * should be done in an app or route middleware.\n     * Application should be setup agnostic to the current request.\n     *\n     * Route middlewares apply only to a certain route or group of routes.\n     * See {@see \\Bolt\\Controller\\Async\\AsyncBase::before} for an example.\n     *\n     * App middlewares apply to all routes.\n     * See classes in \\Bolt\\EventListener for examples of these.\n     * These middlewares could also be filtered by checking for Zone inside of listener.\n     *\n     * @deprecated Deprecated since 3.0, to be removed in 4.0.\n     *\n     * @return string\n     */\n    public function getWhichEnd()\n    {\n        Deprecated::method(3.0);\n\n        $zone = $this->determineZone();\n        $this->app['end'] = $zone; // This is also deprecated\n\n        return $zone;\n    }\n\n    private function determineZone()\n    {\n        if (PHP_SAPI === 'cli') {\n            return 'cli';\n        }\n        /** @var \\Symfony\\Component\\HttpFoundation\\RequestStack $stack */\n        $stack = $this->app['request_stack'];\n        $request = $stack->getCurrentRequest() ?: Request::createFromGlobals();\n\n        if ($zone = Zone::get($request)) {\n            return $zone;\n        }\n\n        /** @var \\Bolt\\EventListener\\ZoneGuesser $guesser */\n        $guesser = $this->app['listener.zone_guesser'];\n\n        return $guesser->setZone($request);\n    }\n}\n", "<?php\n\nnamespace Bolt\\Controller\\Async;\n\nuse Bolt\\Filesystem\\Exception\\ExceptionInterface;\nuse Bolt\\Filesystem\\Exception\\FileExistsException;\nuse Bolt\\Filesystem\\Exception\\FileNotFoundException;\nuse Bolt\\Filesystem\\Exception\\IOException;\nuse Bolt\\Filesystem\\Listing;\nuse Bolt\\Helpers\\Str;\nuse Bolt\\Translation\\Translator as Trans;\nuse Silex\\ControllerCollection;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Csrf\\CsrfToken;\nuse Webmozart\\PathUtil\\Path;\n\n/**\n * Async controller for filesystem management async routes.\n *\n * @author Gawain Lynch <gawain.lynch@gmail.com>\n * @author Carson Full <carsonfull@gmail.com>\n */\nclass FilesystemManager extends AsyncBase\n{\n    protected function addRoutes(ControllerCollection $ctr)\n    {\n        $ctr->get('/browse/{namespace}/{path}', 'browse')\n            ->assert('path', '.*')\n            ->value('namespace', 'files')\n            ->value('path', '')\n            ->bind('asyncbrowse');\n\n        $ctr->get('/file/autocomplete', 'filesAutoComplete')\n            ->bind('file/autocomplete');\n\n        $ctr->post('/file/create', 'createFile')\n            ->bind('file/create');\n\n        $ctr->post('/file/delete', 'deleteFile')\n            ->bind('file/delete');\n\n        $ctr->post('/file/duplicate', 'duplicateFile')\n            ->bind('file/duplicate');\n\n        $ctr->post('/file/rename', 'renameFile')\n            ->bind('file/rename');\n\n        $ctr->post('/folder/create', 'createFolder')\n            ->bind('createfolder');\n\n        $ctr->post('/folder/rename', 'renameFolder')\n            ->bind('renamefolder');\n\n        $ctr->post('/folder/remove', 'removeFolder')\n            ->bind('removefolder');\n\n        $ctr->get('/recordbrowser', 'recordBrowser')\n            ->bind('recordbrowser');\n    }\n\n    /**\n     * List browse on the server, so we can insert them in the file input.\n     *\n     * @param Request $request\n     * @param string  $namespace\n     * @param string  $path\n     *\n     * @return \\Bolt\\Response\\TemplateResponse\n     */\n    public function browse(Request $request, $namespace, $path)\n    {\n        $directory = $this->filesystem()->getDir(\"$namespace://$path\");\n        $listing = new Listing($directory);\n        $showHidden = $this->isAllowed('files:hidden');\n\n        try {\n            $directories = $listing->getDirectories($showHidden);\n            $files = $listing->getFiles($showHidden);\n        } catch (IOException $e) {\n            $this->logException(Trans::__('page.file-management.message.folder-not-found', ['%s' => $path]), $e);\n            $directories = [];\n            $files = [];\n        }\n\n        $context = [\n            'directory'   => $directory,\n            'directories' => $directories,\n            'files'       => $files,\n            'multiselect' => $request->query->getBoolean('multiselect'),\n        ];\n\n        return $this->render('@bolt/async/browse.twig', ['context' => $context]);\n    }\n\n    /**\n     * Create a new folder.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function createFolder(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parentPath = Str::makeSafe($request->request->get('parent'), false, '()[]!@$^-_=+{},.~');\n        $folderName = Str::makeSafe($request->request->get('foldername'), false, '()[]!@$^-_=+{},.~');\n\n        try {\n            $dir = $this->filesystem()->getDir(\"$namespace://$parentPath/$folderName\");\n            $dir->create();\n\n            return $this->json($dir->getPath(), Response::HTTP_OK);\n        } catch (IOException $e) {\n            $msg = Trans::__('Unable to create directory: %DIR%', ['%DIR%' => $folderName]);\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Create an empty file.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function createFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parentPath = Str::makeSafe($request->request->get('parentPath'), false, '()[]!@$^-_=+{},.~');\n        $filename = Str::makeSafe($request->request->get('filename'), false, '()[]!@$^-_=+{},.~');\n\n        if ($this->validateFileExtension($filename) === false) {\n            return $this->json(\n                sprintf(\"File extension not allowed: %s\", $filename),\n                Response::HTTP_BAD_REQUEST\n            );\n        }\n\n        try {\n            $file = $this->filesystem()->getFile(\"$namespace://$parentPath/$filename\");\n            $file->put('');\n\n            return $this->json($file->getPath(), Response::HTTP_OK);\n        } catch (IOException $e) {\n            $msg = Trans::__('Unable to create file: %FILE%', ['%FILE%' => $filename]);\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Delete a file on the server.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function deleteFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $filename = $request->request->get('filename');\n\n        try {\n            $this->filesystem()->delete(\"$namespace://$filename\");\n\n            return $this->json($filename, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to delete file: %FILE%', ['%FILE%' => $filename]);\n            $this->logException($msg, $e);\n\n            return $this->json(\n                $msg,\n                $e instanceof FileNotFoundException ? Response::HTTP_NOT_FOUND : Response::HTTP_INTERNAL_SERVER_ERROR\n            );\n        }\n    }\n\n    /**\n     * Duplicate a file on the server.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function duplicateFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $filename = $request->request->get('filename');\n\n        $filesystem = $this->filesystem()->getFilesystem($namespace);\n\n        // If the filename doesn't have an extension $extensionPos will be equal to its length, so that $fileBase will\n        // contain the entire filename. This also accounts for dotfiles.\n        $extensionPos = strrpos($filename, '.') ?: strlen($filename);\n\n        $fileBase = substr($filename, 0, $extensionPos) . '_copy';\n        $fileExtension = substr($filename, $extensionPos);\n\n        $n = 0;\n\n        // Increase $n until filename_copy$n.ext doesn't exist\n        do {\n            ++$n;\n            $destination = $fileBase . $n . $fileExtension;\n        } while ($filesystem->has($destination));\n\n        try {\n            $filesystem->copy($filename, $destination);\n\n            return $this->json($destination, Response::HTTP_OK);\n        } catch (IOException $e) {\n            $msg = Trans::__('Unable to duplicate file: %FILE%', ['%FILE%' => $filename]);\n\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Return autocomplete data for a file name.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function filesAutoComplete(Request $request)\n    {\n        $term = $request->query->get('term', '.*');\n        $dir = Path::getDirectory($term);\n        $term = Path::getFilename($term);\n        $term = preg_quote($term);\n\n        $extensions = implode('|', explode(',', $request->query->get('ext', '.*')));\n        $regex = sprintf('/.*(%s).*\\.(%s)$/', $term, $extensions);\n\n        $files = $this->filesystem()\n            ->find()\n            ->in('files://' . $dir)\n            ->name($regex)\n        ;\n\n        $result = [];\n        /** @var \\Bolt\\Filesystem\\Handler\\File $file */\n        foreach ($files as $file) {\n            $result[] = $file->toJs();\n        }\n\n        return $this->json($result);\n    }\n\n    /**\n     * List records to easily insert links through the WYSIWYG editor.\n     *\n     * @return \\Bolt\\Response\\TemplateResponse\n     */\n    public function recordBrowser()\n    {\n        $results = [];\n\n        foreach ($this->app['config']->get('contenttypes') as $contenttype) {\n            if ($contenttype['viewless']) {\n                // Skip viewless ContentTypes\n                continue;\n            }\n\n            $slug = $contenttype['slug'];\n            $records = $this->getContent($slug, ['published' => true, 'hydrate' => false]);\n            foreach ($records as $record) {\n                $results[$slug][] = [\n                    'title' => $record->getTitle(),\n                    'id'    => $record->id,\n                    'link'  => $record->link(),\n                ];\n            }\n        }\n\n        $context = ['results' => $results];\n\n        return $this->render('@bolt/recordbrowser/recordbrowser.twig', ['context' => $context]);\n    }\n\n    /**\n     * Delete a folder recursively if writeable.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function removeFolder(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parent = $request->request->get('parent');\n        $folderName = $request->request->get('foldername');\n\n        try {\n            $this->filesystem()->deleteDir(\"$namespace://$parent/$folderName\");\n\n            return $this->json($folderName, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to delete directory: %DIR%', ['%DIR%' => $folderName]);\n\n            $this->logException($msg, $e);\n\n            return $this->json($msg, Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    /**\n     * Rename a file within the files directory tree.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function renameFile(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parent = $request->request->get('parent');\n        $oldName = $request->request->get('oldname');\n        $newName = $request->request->get('newname');\n\n        if (!$this->isExtensionChangedAndIsChangeAllowed($oldName, $newName)) {\n            return $this->json(Trans::__('general.phrase.only-root-change-file-extensions'), Response::HTTP_FORBIDDEN);\n        }\n\n        if ($this->validateFileExtension($newName) === false) {\n            return $this->json(\n                sprintf(\"File extension not allowed: %s\", $newName),\n                Response::HTTP_BAD_REQUEST\n            );\n        }\n\n        try {\n            $this->filesystem()->rename(\"$namespace://$parent/$oldName\", \"$parent/$newName\");\n\n            return $this->json($newName, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to rename file: %FILE%', ['%FILE%' => $oldName]);\n            $this->logException($msg, $e);\n\n            if ($e instanceof FileExistsException) {\n                $status = Response::HTTP_CONFLICT;\n            } elseif ($e instanceof FileNotFoundException) {\n                $status = Response::HTTP_NOT_FOUND;\n            } else {\n                $status = Response::HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            return $this->json($msg, $status);\n        }\n    }\n\n    /**\n     * Rename a folder within the files directory tree.\n     *\n     * @param Request $request\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\JsonResponse\n     */\n    public function renameFolder(Request $request)\n    {\n        // Verify CSRF token\n        $this->checkToken($request);\n\n        $namespace = $request->request->get('namespace');\n        $parent = $request->request->get('parent');\n        $oldName = $request->request->get('oldname');\n        $newName = $request->request->get('newname');\n\n        try {\n            $dir = $this->filesystem()->getDir(\"$namespace://$parent/$oldName\");\n            if (!$dir) {\n                return $this->json(\n                    sprintf(\"Only directories are allowed to be renamed with this method\"),\n                    Response::HTTP_BAD_REQUEST\n                );\n            }\n            $this->filesystem()->rename(\"$namespace://$parent/$oldName\", \"$parent/$newName\");\n\n            return $this->json($newName, Response::HTTP_OK);\n        } catch (ExceptionInterface $e) {\n            $msg = Trans::__('Unable to rename directory: %DIR%', ['%DIR%' => $oldName]);\n            $this->logException($msg, $e);\n\n            if ($e instanceof FileExistsException) {\n                $status = Response::HTTP_CONFLICT;\n            } elseif ($e instanceof FileNotFoundException) {\n                $status = Response::HTTP_NOT_FOUND;\n            } else {\n                $status = Response::HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            return $this->json($msg, $status);\n        }\n    }\n\n    /**\n     * Check that file extensions are not being changed.\n     *\n     * @param string $oldName\n     * @param string $newName\n     *\n     * @return bool\n     */\n    private function isExtensionChangedAndIsChangeAllowed($oldName, $newName)\n    {\n        $user = $this->getUser();\n\n        if ($this->users()->hasRole($user['id'], 'root') || $this->users()->hasRole($user['id'], 'admin')) {\n            return true;\n        }\n\n        $oldFile = new \\SplFileInfo($oldName);\n        $newFile = new \\SplFileInfo($newName);\n\n        return $oldFile->getExtension() === $newFile->getExtension();\n    }\n\n    /**\n     * Log an exception to the system log.\n     *\n     * @param string     $message   A formatted error message\n     * @param \\Exception $exception The exception that has been thrown\n     *\n     * @return bool Whether the record has been processed\n     */\n    private function logException($message, $exception)\n    {\n        return $this->app['logger.system']->error(\n            $message . ': ' . $exception->getMessage(),\n            ['event' => 'exception', 'exception' => $exception]\n        );\n    }\n\n    /**\n     * @param string $filename\n     *\n     * @return bool\n     */\n    private function validateFileExtension($filename)\n    {\n        // no UNIX-hidden files\n        if ($filename[0] === '.') {\n            return false;\n        }\n\n        // only whitelisted extensions\n        $extension = pathinfo($filename, PATHINFO_EXTENSION);\n        $allowedExtensions = $this->getAllowedUploadExtensions();\n\n        return in_array(mb_strtolower($extension), $allowedExtensions);\n    }\n\n    /**\n     * Get the array of configured acceptable file extensions.\n     *\n     * @return array\n     */\n    private function getAllowedUploadExtensions()\n    {\n        return $this->app['config']->get('general/accept_file_types');\n    }\n\n    /**\n     * Check if the passed in token was valid\n     *\n     * @param Request $request\n     */\n    private function checkToken(Request $request)\n    {\n        $token = new CsrfToken('bolt', $request->request->get('token'));\n\n        if (! $this->app['csrf']->isTokenValid($token)) {\n            $msg = 'Token not valid';\n            $this->abort(Response::HTTP_UNAUTHORIZED, $msg);\n        }\n    }\n}\n", "<?php\n\nnamespace Bolt\\Controller;\n\nuse Bolt\\Asset\\File\\JavaScript;\nuse Bolt\\Asset\\File\\Stylesheet;\nuse Bolt\\Asset\\Snippet\\Snippet;\nuse Bolt\\Asset\\Target;\nuse Bolt\\Helpers\\Input;\nuse Bolt\\Response\\TemplateResponse;\nuse Bolt\\Storage\\Entity\\Content;\nuse Bolt\\Storage\\Entity\\Relations;\nuse Bolt\\Storage\\Entity\\Taxonomy;\nuse Bolt\\Storage\\EntityManager;\nuse Bolt\\Storage\\Mapping\\ContentType;\nuse Bolt\\Storage\\Query\\QueryResultset;\nuse Bolt\\Storage\\Repository\\TaxonomyRepository;\nuse Bolt\\Translation\\Translator as Trans;\nuse Silex\\ControllerCollection;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Exception\\MethodNotAllowedHttpException;\n\n/**\n * Standard Frontend actions.\n *\n * This file acts as a grouping for the default front-end controllers.\n *\n * For overriding the default behavior here, please reference\n * https://docs.bolt.cm/templating/templates-routes#routing or the routing.yml\n * file in your configuration.\n */\nclass Frontend extends ConfigurableBase\n{\n    protected function getConfigurationRoutes()\n    {\n        return $this->app['config']->get('routing', []);\n    }\n\n    protected function addRoutes(ControllerCollection $c)\n    {\n        $c->value(Zone::KEY, Zone::FRONTEND);\n        parent::addRoutes($c);\n    }\n\n    /**\n     * The default before filter for the controllers in this file.\n     *\n     * Refer to the routing.yml config file for overridding.\n     *\n     * @param Request $request The Symfony Request\n     *\n     * @return null|TemplateResponse|RedirectResponse\n     */\n    public function before(Request $request)\n    {\n        // Start the 'stopwatch' for the profiler.\n        $this->app['stopwatch']->start('bolt.frontend.before');\n\n        // If there are no users in the users table, or the table doesn't exist.\n        // Repair the DB, and let's add a new user.\n        if (!$this->hasUsers()) {\n            $this->flashes()->info(Trans::__('general.phrase.users-none-create-first'));\n\n            return $this->redirectToRoute('userfirst');\n        }\n\n        // If we are in maintenance mode and current user is not logged in, show maintenance notice.\n        if ($this->getOption('general/maintenance_mode') && !$this->isAllowed('maintenance-mode')) {\n            $twig = $this->app['twig'];\n            $template = $this->templateChooser()->maintenance();\n\n            $html = $twig->resolveTemplate($template)->render([]);\n            $response = new TemplateResponse($template, [], $html, Response::HTTP_SERVICE_UNAVAILABLE);\n\n            return $response;\n        }\n\n        // Stop the 'stopwatch' for the profiler.\n        $this->app['stopwatch']->stop('bolt.frontend.before');\n\n        return null;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function after(Request $request, Response $response)\n    {\n        if ($this->session()->isStarted()) {\n            $response->setPrivate();\n        } else {\n            $sharedMaxAge = $this->getOption('general/caching/duration', 10) * 60;\n            $response\n                ->setPublic()\n                ->setSharedMaxAge($sharedMaxAge)\n            ;\n        }\n    }\n\n    /**\n     * Controller for the \"Homepage\" route. Usually the front page of the website.\n     *\n     * @param Request $request\n     *\n     * @return TemplateResponse\n     */\n    public function homepage(Request $request)\n    {\n        $homepage = $this->getOption('theme/homepage') ?: $this->getOption('general/homepage');\n        $listingParameters = $this->getListingParameters($homepage, true);\n        $content = $this->getContent($homepage, $listingParameters);\n\n        $template = $this->templateChooser()->homepage($content);\n        $globals = [];\n\n        if (is_array($content) && count($content) > 0) {\n            $first = current($content);\n            $globals[$first->contenttype['slug']] = $content;\n            $globals['records'] = $content;\n        } elseif (is_object($content)) {\n            $globals['record'] = $content;\n            $globals[$content->contenttype['singular_slug']] = $content;\n            $globals['records'] = [$content->id => $content];\n        }\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Controller for a single record page, like '/page/about/' or '/entry/lorum'.\n     *\n     * @param Request $request         The request\n     * @param string  $contenttypeslug The content type slug\n     * @param string  $slug            The content slug\n     *\n     * @return TemplateResponse\n     */\n    public function record(Request $request, $contenttypeslug, $slug = '')\n    {\n        $contenttype = $this->getContentType($contenttypeslug);\n\n        // If the ContentType is 'viewless', don't show the record page.\n        if (isset($contenttype['viewless']) && $contenttype['viewless'] === true) {\n            $this->abort(Response::HTTP_NOT_FOUND, \"Page $contenttypeslug/$slug not found.\");\n\n            return null;\n        }\n\n        // Perhaps we don't have a slug. Let's see if we can pick up the 'id', instead.\n        if (empty($slug)) {\n            $slug = $request->get('id');\n        }\n\n        $slug = $this->app['slugify']->slugify($slug);\n\n        // First, try to get it by slug.\n        $content = $this->getContent($contenttype['slug'], ['slug' => $slug, 'returnsingle' => true, 'log_not_found' => !is_numeric($slug)]);\n\n        if (is_numeric($slug) && !$content) {\n            // And otherwise try getting it by ID\n            $content = $this->getContent($contenttype['slug'], ['id' => $slug, 'returnsingle' => true]);\n        }\n\n        // No content, no page!\n        if (!$content) {\n            $this->abort(Response::HTTP_NOT_FOUND, \"Page $contenttypeslug/$slug not found.\");\n\n            return null;\n        }\n\n        // Then, select which template to use, based on our 'cascading templates rules'\n        $template = $this->templateChooser()->record($content);\n\n        // Setting the editlink\n        $this->app['editlink'] = $this->generateUrl('editcontent', ['contenttypeslug' => $contenttype['slug'], 'id' => $content->id]);\n        $this->app['edittitle'] = $content->getTitle();\n\n        // Make sure we can also access it as {{ page.title }} for pages, etc. We set these in the global scope,\n        // So that they're also available in menu's and templates rendered by extensions.\n        $globals = [\n            'record'                      => $content,\n            $contenttype['singular_slug'] => $content,\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * The controller for previewing a content from posted data.\n     *\n     * @param Request $request         The Symfony Request\n     * @param string  $contenttypeslug The content type slug\n     *\n     * @throws \\Exception\n     *\n     * @return TemplateResponse\n     */\n    public function preview(Request $request, $contenttypeslug)\n    {\n        if (!$request->isMethod('POST')) {\n            throw new MethodNotAllowedHttpException(['POST'], 'This route only accepts POST requests.');\n        }\n\n        // Only accept requests with a valid token\n        $tokenValue = $request->request->get('content_edit', ['_token' => null])['_token'];\n        if (!$this->isAllowed('dashboard') || !$this->isCsrfTokenValid($tokenValue, 'content_edit')) {\n            return new Response('Not allowed or invalid CSRF token', Response::HTTP_FORBIDDEN);\n        }\n\n        $contenttype = $this->getContentType($contenttypeslug);\n        $formValues = $request->request->all();\n\n        $storage = $this->storage();\n        if ($storage instanceof EntityManager) {\n            /** @var EntityManager $storage */\n            /** @var Content $content */\n            $content = $storage->create($contenttypeslug, $formValues);\n\n            /** @var Collection\\Relations $related */\n            $related = $storage->createCollection(Relations::class);\n            $related->setFromPost($formValues, $content);\n            $content->setRelation($related);\n\n            /** @var Collection\\Taxonomy $taxonomies */\n            $taxonomies = $storage->createCollection(Taxonomy::class);\n            $taxonomies->setFromPost($formValues, $content);\n            $content->setTaxonomy($taxonomies);\n\n        } else {\n            $content = $storage->getContentObject($contenttypeslug, [], false);\n            $content->setFromPost($formValues, $contenttype);\n        }\n\n        $this->fixBlockFieldsForPreview($content);\n        $this->fixHTMLFieldsForPreview($content);\n\n        $liveEditor = $request->get('_live-editor-preview');\n        if (!empty($liveEditor)) {\n            $jsFile = (new JavaScript('js/ckeditor/ckeditor.js', 'bolt'))\n                ->setPriority(1)\n                ->setLate(false);\n            $cssFile = (new Stylesheet('css/liveeditor.css', 'bolt'))\n                ->setPriority(5)\n                ->setLate(false);\n            $snippet = (new Snippet())\n                ->setCallback('<script>window.boltIsEditing = true;</script>')\n                ->setLocation(Target::BEFORE_HEAD_JS);\n\n            $this->app['asset.queue.snippet']->add($snippet);\n            $this->app['asset.queue.file']->add($jsFile);\n            $this->app['asset.queue.file']->add($cssFile);\n        }\n\n        // Then, select which template to use, based on our 'cascading templates rules'\n        $template = $this->templateChooser()->record($content);\n\n        // Make sure we can also access it as {{ page.title }} for pages, etc. We set these in the global scope,\n        // So that they're also available in menu's and templates rendered by extensions.\n        $globals = [\n            'record'                      => $content,\n            $contenttype['singular_slug'] => $content,\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Helper function to prefill `block` fields with an additional `block` field per item.\n     *\n     * This is needed to make previewing content with block fields fully working.\n     */\n    private function fixBlockFieldsForPreview($record)\n    {\n        foreach ($record->contenttype['fields'] as $fieldSlug => $fieldSettings) {\n            if ($fieldSettings['type'] === 'block') {\n                $fieldValue = $this->getBlockFieldValue($record, $fieldSlug);\n                if ($fieldValue) {\n                    $newArray = [];\n                    foreach ($fieldValue as $item) {\n                        if (!empty($item)) {\n                            foreach ($item as $k => &$v) {\n                                $v['block'] = $k;\n                            }\n                            $newArray[] = $v;\n                        }\n                    }\n                    $this->setFieldValue($record, $fieldSlug, $newArray);\n                }\n            }\n        }\n\n        return $record;\n    }\n\n    /**\n     * Helper function to make sure HTML-like fields are Twig_Markup, and image fields are\n     * an image. Like they are in a \"real\" page.\n     *\n     * This is needed to make previewing content with block fields fully working.\n     * See: https://github.com/bolt/bolt/issues/7753\n     */\n    private function fixHTMLFieldsForPreview($record)\n    {\n        foreach ($record->contenttype['fields'] as $fieldSlug => $fieldSettings) {\n            if (in_array($fieldSettings['type'], ['html', 'text', 'textarea', 'markdown'])) {\n                $fieldValue = new \\Twig_Markup($this->getFieldValue($record, $fieldSlug), \"UTF-8\");\n\n                $this->setFieldValue($record, $fieldSlug, $fieldValue);\n            }\n            if ($fieldSettings['type'] === 'image') {\n                $fieldValue = $this->getFieldValue($record, $fieldSlug);\n\n                if (is_array($fieldValue) && isset($fieldValue['file'])) {\n                    $this->setFieldValue($record, $fieldSlug, $fieldValue['file']);\n                }\n            }\n        }\n\n        return $record;\n    }\n\n    private function getBlockFieldValue($record, $field)\n    {\n        if ($record instanceof Content) {\n            $value = $record->get($field);\n            if (is_array($value)) {\n                return $value;\n            }\n        } elseif (isset($record->values[$field]) && is_array($record->values[$field])) {\n            return $record->values[$field];\n        }\n\n        return null;\n    }\n\n    private function getFieldValue($record, $field)\n    {\n        if ($record instanceof Content) {\n            return $record->get($field);\n        } elseif (isset($record->values[$field]) && is_array($record->values[$field])) {\n            return $record->values[$field];\n        }\n\n        return null;\n    }\n\n    private function setFieldValue($record, $field, $value)\n    {\n        if ($record instanceof Content) {\n            $record->set($field, $value);\n        } else {\n            $record->values[$field] = $value;\n        }\n    }\n\n    /**\n     * The listing page controller.\n     *\n     * @param Request $request         The Symfony Request\n     * @param string  $contenttypeslug The content type slug\n     *\n     * @return TemplateResponse\n     */\n    public function listing(Request $request, $contenttypeslug)\n    {\n        $listingParameters = $this->getListingParameters($contenttypeslug);\n        $content = $this->getContent($contenttypeslug, $listingParameters);\n        $contenttype = $this->getContentType($contenttypeslug);\n\n        $template = $this->templateChooser()->listing($contenttype);\n\n        // Make sure we can also access it as {{ pages }} for pages, etc. We set these in the global scope,\n        // So that they're also available in menu's and templates rendered by extensions.\n        $globals = [\n            'records'        => $content,\n            $contenttypeslug => $content,\n            'contenttype'    => $contenttype['name'],\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * The taxonomy listing page controller.\n     *\n     * @param Request $request      The Symfony Request\n     * @param string  $taxonomytype The taxonomy type slug\n     * @param string  $slug         The taxonomy slug\n     *\n     * @throws \\Bolt\\Exception\\InvalidRepositoryException\n     *\n     * @return TemplateResponse|false\n     */\n    public function taxonomy(Request $request, $taxonomytype, $slug)\n    {\n        $taxonomy = $this->app['config']->get('taxonomy/' . $taxonomytype);\n        // No taxonomytype, no possible content.\n        if (empty($taxonomy)) {\n            return false;\n        }\n        $taxonomyslug = $taxonomy['slug'];\n\n        // First, get some content\n        $context = $taxonomy['singular_slug'] . '_' . $slug;\n        $page = $this->app['pager']->getCurrentPage($context);\n        // Theme value takes precedence over default config @see https://github.com/bolt/bolt/issues/3951\n        $amount = $this->getOption('theme/listing_records', false) ?: $this->getOption('general/listing_records');\n\n        // Handle case where listing records has been override for specific taxonomy\n        if (array_key_exists('listing_records', $taxonomy) && is_int($taxonomy['listing_records'])) {\n            $amount = $taxonomy['listing_records'];\n        }\n\n        $order = $this->getOption('theme/listing_sort', false) ?: $this->getOption('general/listing_sort');\n        $isLegacy = $this->getOption('general/compatibility/setcontent_legacy', true);\n        if ($isLegacy) {\n            $content = $this->storage()->getContentByTaxonomy($taxonomytype, $slug, ['limit' => $amount, 'order' => $order, 'page' => $page]);\n        } else {\n            $page = $this->app['pager']->getCurrentPage('taxonomy');\n            $appCt = array_keys($this->app['query.search_config']->getSearchableTypes());\n            /** @var TaxonomyRepository $repo */\n            $repo = $this->app['storage']->getRepository(Taxonomy::class);\n            $query = $repo->queryContentByTaxonomy($appCt, [$taxonomytype => $slug])\n                ->setFirstResult(($page - 1) * $amount)\n                ->setMaxResults($amount)\n            ;\n\n            $results = $repo->getContentByTaxonomy($query);\n            $set = new QueryResultset();\n            foreach ($results->getCollection() as $record) {\n                $set->add([$record]);\n            }\n            $content = $this->app['twig.records.view']->createView($set);\n        }\n\n        if (!$this->isTaxonomyValid($content, $slug, $taxonomy)) {\n            $this->abort(Response::HTTP_NOT_FOUND, \"No slug '$slug' in taxonomy '$taxonomyslug'\");\n        }\n\n        $template = $this->templateChooser()->taxonomy($taxonomyslug);\n\n        // Get a display value for slug. This should be moved from 'slug' context key to 'name' in v4.0.\n        $name = $slug;\n        if ($taxonomy['behaves_like'] !== 'tags' && isset($taxonomy['options'][$slug])) {\n            $name = $taxonomy['options'][$slug];\n        }\n\n        $globals = [\n            'records'      => $content,\n            'slug'         => $name,\n            'taxonomy'     => $this->getOption('taxonomy/' . $taxonomyslug),\n            'taxonomytype' => $taxonomyslug,\n        ];\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Check if the taxonomy is valid.\n     *\n     * @see https://github.com/bolt/bolt/pull/2310\n     *\n     * @param array|false $content\n     * @param string      $slug\n     * @param array       $taxonomy\n     *\n     * @return bool\n     */\n    protected function isTaxonomyValid($content, $slug, array $taxonomy)\n    {\n        if ($taxonomy['behaves_like'] === 'tags' && !$content) {\n            return false;\n        }\n\n        $isNotTag = in_array($taxonomy['behaves_like'], ['categories', 'grouping']);\n        $options = isset($taxonomy['options']) ? array_keys($taxonomy['options']) : [];\n        $isTax = in_array($slug, $options);\n        if ($isNotTag && !$isTax) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * The search result page controller.\n     *\n     * @param Request $request      The Symfony Request\n     * @param array   $contenttypes The content type slug(s) you want to search for\n     *\n     * @return TemplateResponse\n     */\n    public function search(Request $request, array $contenttypes = null)\n    {\n        $q = '';\n        $context = __FUNCTION__;\n\n        if ($request->query->has('q')) {\n            $q = $request->query->get('q');\n        } elseif ($request->query->has($context)) {\n            $q = $request->query->get($context);\n        }\n        $q = Input::cleanPostedData($q, false);\n\n        $page = $this->app['pager']->getCurrentPage($context);\n\n        // Theme value takes precedence over default config @see https://github.com/bolt/bolt/issues/3951\n        $pageSize = $this->getOption('theme/search_results_records', false);\n        if ($pageSize === false && !$pageSize = $this->getOption('general/search_results_records', false)) {\n            $pageSize = $this->getOption('theme/listing_records', false) ?: $this->getOption('general/listing_records', 10);\n        }\n\n        $offset = ($page - 1) * $pageSize;\n        $limit = $pageSize;\n\n        // set-up filters from URL\n        $filters = [];\n        foreach ($request->query->all() as $key => $value) {\n            if (strpos($key, '_') > 0) {\n                list($contenttypeslug, $field) = explode('_', $key, 2);\n                if (isset($filters[$contenttypeslug])) {\n                    $filters[$contenttypeslug][$field] = $value;\n                } else {\n                    $contenttype = $this->getContentType($contenttypeslug);\n                    if (is_array($contenttype)) {\n                        $filters[$contenttypeslug] = [\n                            $field => $value,\n                        ];\n                    }\n                }\n            }\n        }\n        if (count($filters) == 0) {\n            $filters = null;\n        }\n\n        $isLegacy = $this->getOption('general/compatibility/setcontent_legacy', true);\n        if ($isLegacy) {\n            $result = $this->storage()->searchContent($q, $contenttypes, $filters, $limit, $offset);\n\n            /** @var \\Bolt\\Pager\\PagerManager $manager */\n            $manager = $this->app['pager'];\n            $manager\n                ->createPager($context)\n                ->setCount($result['no_of_results'])\n                ->setTotalpages(ceil($result['no_of_results'] / $pageSize))\n                ->setCurrent($page)\n                ->setShowingFrom($offset + 1)\n                ->setShowingTo($offset + ($result ? count($result['results']) : 0));\n            ;\n\n            $manager->setLink($this->generateUrl('search', ['q' => $q]) . '&page_search=');\n        } else {\n            $appCt = array_keys($this->app['query.search_config']->getSearchableTypes());\n            $textQuery = '(' . join(',', $appCt) . ')/search';\n            $params = [\n                'filter' => $q,\n                'page'   => $page,\n                'limit'  => $pageSize,\n            ];\n            $searchResult = $this->getContent($textQuery, $params);\n\n            $result = [\n                'results' => $searchResult->getSortedResults(),\n                'query'   => [\n                    'sanitized_q' => strip_tags($q),\n                ],\n            ];\n        }\n\n        $globals = [\n            'records'      => $result['results'],\n            $context       => $result['query']['sanitized_q'],\n            'searchresult' => $result,\n        ];\n\n        $template = $this->templateChooser()->search();\n\n        return $this->render($template, [], $globals);\n    }\n\n    /**\n     * Renders the specified template from the current theme in response to a request without\n     * loading any content.\n     *\n     * @param string $template The template name\n     *\n     * @return TemplateResponse\n     */\n    public function template($template)\n    {\n        // Add the template extension if it is missing\n        if (!preg_match('/\\\\.twig$/i', $template)) {\n            $template .= '.twig';\n        }\n\n        return $this->render($template);\n    }\n\n    /**\n     * Returns an array of the parameters used in getContent for listing pages.\n     *\n     * @param string $contentTypeSlug The content type slug\n     * @param bool   $allowViewless   Allow viewless contenttype\n     *\n     * @return array Parameters to use in getContent\n     */\n    private function getListingParameters($contentTypeSlug, $allowViewless = false)\n    {\n        $contentType = $this->getContentType(current(explode('/', $contentTypeSlug)));\n\n        // If there is no ContentType, don't get parameters for it\n        if ($contentType === false) {\n            return [];\n        }\n\n        // If the ContentType is 'viewless', don't show the listing / record page.\n        if ($contentType['viewless'] && !$allowViewless) {\n            $this->abort(Response::HTTP_NOT_FOUND, 'Page ' . $contentType['slug'] . ' not found.');\n        }\n\n        // Build the pager\n        $page = $this->app['pager']->getCurrentPage($contentType['slug']);\n        $order = isset($contentType['listing_sort']) ? $contentType['listing_sort'] : $this->getListingOrder($contentType);\n\n        // CT value takes precedence over theme & config.yml\n        if (!empty($contentType['listing_records'])) {\n            $amount = $contentType['listing_records'];\n        } else {\n            $amount = $this->getOption('theme/listing_records') ?: $this->getOption('general/listing_records');\n        }\n\n        return ['limit' => $amount, 'order' => $order, 'page' => $page, 'paging' => true];\n    }\n\n    /**\n     * Return the listing order.\n     *\n     * If the ContentType's sort is false (default in Config::parseContentType),\n     * either:\n     *  - we let `getContent()` sort by itself\n     *  - we explicitly set it to sort on the general/listing_sort setting\n     *\n     * @param ContentType|array $contentType\n     *\n     * @return null|string\n     */\n    private function getListingOrder($contentType)\n    {\n        // An empty default isn't set in config yet, arrays got to hate them.\n        if (isset($contentType['taxonomy'])) {\n            $taxonomies = $this->getOption('taxonomy');\n            foreach ($contentType['taxonomy'] as $taxonomyName) {\n                if ($taxonomies[$taxonomyName]['has_sortorder']) {\n                    // Let getContent() handle it\n                    return null;\n                }\n            }\n        }\n\n        return $this->getOption('theme/listing_sort') ?: $this->getOption('general/listing_sort');\n    }\n}\n", "<?php\n\nnamespace Bolt\\Tests\\Controller\\Async;\n\nuse Bolt\\Common\\Json;\nuse Bolt\\Filesystem\\Handler\\HandlerInterface;\nuse Bolt\\Response\\TemplateView;\nuse Bolt\\Storage\\Entity\\Users;\nuse Bolt\\Tests\\Controller\\ControllerUnitTest;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;\nuse Symfony\\Component\\Security\\Csrf\\CsrfToken;\nuse Symfony\\Component\\Security\\Csrf\\CsrfTokenManager;\nuse Symfony\\Component\\Security\\Csrf\\TokenStorage\\SessionTokenStorage;\n\n/**\n * Class to test correct operation of src/Controller/Async/FileManager.\n *\n * @author Gawain Lynch <gawain.lynch@gmail.com>\n **/\nclass FilesystemManagerTest extends ControllerUnitTest\n{\n    const FILESYSTEM = 'files';\n\n    const FILE_NAME = '__phpunit_test_file_delete_me.txt';\n    const FILE_NAME_NOT_ALLOWED = '__phpunit_test_file_delete_me.exe';\n    const FILE_NAME_NOT_ALLOWED_2 = '__phpunit_test_file_delete_me';\n    const FILE_NAME_2 = '__phpunit_test_file_2_delete_me.txt';\n    const FOLDER_NAME = '__phpunit_test_folder_delete_me';\n    const FOLDER_NAME_2 = '__phpunit_test_folder_2_delete_me';\n\n    private $oldFiles = [];\n\n    /** @var CsrfToken */\n    private $token;\n\n    protected function setUp()\n    {\n        $tokenManager = new CsrfTokenManager(null, new SessionTokenStorage(new Session(new MockArraySessionStorage())));\n        $this->setService('csrf', $tokenManager);\n        $this->token = $tokenManager->refreshToken('bolt');\n    }\n\n    /**\n     * Store the list of files in the files folder so we can delete any added files after we're done testing.\n     *\n     * @before\n     */\n    public function storeFileList()\n    {\n        $this->oldFiles = $this->getService('filesystem')->listContents(self::FILESYSTEM . '://');\n    }\n\n    /**\n     * Remove any files added during the test.\n     *\n     * @after\n     */\n    public function restoreFileList()\n    {\n        $newFiles = array_udiff(\n            $this->getService('filesystem')->listContents(self::FILESYSTEM . '://'),\n            $this->oldFiles,\n            function (HandlerInterface $file1, HandlerInterface $file2) {\n                return strcmp($file2->getPath(), $file2->getPath());\n            }\n        );\n        /** @var HandlerInterface $file */\n        foreach ($newFiles as $file) {\n            $file->delete();\n        }\n    }\n\n    public function testBrowse()\n    {\n        $this->setRequest(Request::create('/async/browse'));\n        $response = $this->controller()->browse($this->getRequest(), self::FILESYSTEM, '/');\n\n        $this->assertInstanceOf(TemplateView::class, $response);\n        $this->assertEquals('@bolt/async/browse.twig', $response->getTemplate());\n    }\n\n    public function testCreateFolder()\n    {\n        $this->setRequest(Request::create('/async/folder/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parent'     => '',\n            'foldername' => self::FOLDER_NAME,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFolder($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        // Test whether the new folder actually exists\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FOLDER_NAME));\n    }\n\n    public function testRemoveFolder()\n    {\n        $this->setRequest(Request::create('/async/folder/delete', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parent'     => '',\n            'foldername' => self::FOLDER_NAME,\n            'token'      => $this->token,\n        ]));\n\n        // The folder should exist before deleting\n        $this->controller()->createFolder($this->getRequest());\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FOLDER_NAME));\n\n        $response = $this->controller()->removeFolder($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FOLDER_NAME));\n    }\n\n    public function testCreateFile()\n    {\n        $this->setRequest(Request::create('/async/file/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parentPath' => '',\n            'filename'   => self::FILE_NAME,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFile($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        // Test whether the new file actually exists\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n    }\n\n    public function testCreateFileInvalidExtension()\n    {\n        $this->setRequest(Request::create('/async/file/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parentPath' => '',\n            'filename'   => self::FILE_NAME_NOT_ALLOWED,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFile($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_BAD_REQUEST, $response->getStatusCode());\n\n        // Test whether the new file is not saved\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME_NOT_ALLOWED));\n    }\n\n    public function testCreateFileInvalidExtension2()\n    {\n        $this->setRequest(Request::create('/async/file/create', 'POST', [\n            'namespace'  => self::FILESYSTEM,\n            'parentPath' => '',\n            'filename'   => self::FILE_NAME_NOT_ALLOWED_2,\n            'token'      => $this->token,\n        ]));\n        $response = $this->controller()->createFile($this->getRequest());\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_BAD_REQUEST, $response->getStatusCode());\n\n        // Test whether the new file is not saved\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME_NOT_ALLOWED));\n    }\n\n    /**\n     * Duplicating a file five times should create FILENAME_copy1-5.EXT. This should work for both regular filenames\n     * and dotfiles.\n     */\n    public function testDuplicateFile()\n    {\n        $filenames = ['__phpunit_test_file_delete_me.extension', '.__phpunit_test_dotfile_delete_me'];\n\n        foreach ($filenames as $filename) {\n            // Create the file\n            $this->getService('filesystem')->put(self::FILESYSTEM . '://' . $filename, '');\n\n            $extensionPos = strrpos($filename, '.') ?: strlen($filename);\n            $fileBase = substr($filename, 0, $extensionPos) . '_copy';\n            $fileExtension = substr($filename, $extensionPos);\n\n            for ($i = 1; $i <= 5; ++$i) {\n                $destination = $fileBase . $i . $fileExtension;\n\n                // The file shouldn't exist yet\n                $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $destination));\n\n                $this->setRequest(Request::create('/async/file/duplicate', 'POST', [\n                    'namespace' => self::FILESYSTEM,\n                    'filename'  => $filename,\n                    'token'      => $this->token,\n                ]));\n\n                $response = $this->controller()->duplicateFile($this->getRequest());\n                $this->assertInstanceOf(JsonResponse::class, $response);\n                $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n                // The copy should now have been created\n                $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $destination));\n            }\n        }\n    }\n\n    public function testDeleteFile()\n    {\n        $this->setRequest(Request::create('/async/file/delete', 'POST', [\n            'namespace' => 'files',\n            'filename'  => self::FILE_NAME,\n            'token'      => $this->token,\n        ]));\n\n        // The file should still exist before deleting\n        $this->controller()->createFile($this->getRequest());\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n\n        $response = $this->controller()->deleteFile($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n        // The file shouldn't exist anymore\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n\n        // Attempting to delete the same file twice (or simply attempting to remove a file that doesn't exist) should\n        // return a 404 Not Found status code\n        $response = $this->controller()->deleteFile($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_NOT_FOUND, $response->getStatusCode());\n    }\n\n    /**\n     * Test renaming both files and folders, since the controller actions have the same signature and output.\n     */\n    public function testRename()\n    {\n        $definitions = [\n            'file'   => ['old' => self::FILE_NAME, 'new' => self::FILE_NAME_2],\n            'folder' => ['old' => self::FOLDER_NAME, 'new' => self::FOLDER_NAME_2],\n        ];\n        foreach ($definitions as $object => $data) {\n            $this->createObject($object, $data['old']);\n\n            // Rename the object\n            $response = $this->renameObject($object, $data['old'], $data['new']);\n\n            $this->assertInstanceOf(JsonResponse::class, $response);\n            $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n\n            $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $data['old']));\n            $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $data['new']));\n        }\n    }\n\n    /**\n     * Test the error handling when attempting to rename non existent files and folders and when attemtping to rename to\n     * a filename that already exists.\n     */\n    public function testInvalidRename()\n    {\n        $definitions = [\n            'file'   => ['old' => self::FILE_NAME, 'new' => self::FILE_NAME_2],\n            'folder' => ['old' => self::FOLDER_NAME, 'new' => self::FOLDER_NAME_2],\n        ];\n        foreach ($definitions as $object => $data) {\n            /*\n             * Object doesn't exist\n             */\n            $this->createObject($object, $data['old']);\n            $response = $this->renameObject($object, $data['old'] . '_nonexistent.txt', $data['new']);\n\n            $this->assertInstanceOf(JsonResponse::class, $response);\n            $this->assertEquals(Response::HTTP_NOT_FOUND, $response->getStatusCode());\n\n            /*\n             * Destination already exists\n             */\n            // Create the objects\n            foreach ([$data['old'], $data['new']] as $filename) {\n                $this->createObject($object, $filename);\n            }\n\n            $response = $this->renameObject($object, $data['old'], $data['new']);\n            $this->assertInstanceOf(JsonResponse::class, $response);\n            $this->assertEquals(Response::HTTP_CONFLICT, $response->getStatusCode());\n        }\n    }\n\n    public function testRenameToInvalidExtension()\n    {\n        $this->createObject('file', self::FILE_NAME);\n        $response = $this->renameObject('file', self::FILE_NAME, self::FILE_NAME_NOT_ALLOWED);\n\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_FORBIDDEN, $response->getStatusCode());\n\n        $this->assertFalse($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME_NOT_ALLOWED));\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . self::FILE_NAME));\n    }\n\n    public function testFilesAutoComplete()\n    {\n        // First create a bunch of files named FOLDER/$i.EXTENSION\n        $prefix = 'autocomplete';\n        $extensions = ['ext1', 'ext2'];\n        $count = 5;\n\n        for ($i = 1; $i <= $count; ++$i) {\n            foreach ($extensions as $extension) {\n                $this->getService('filesystem')->put(self::FILESYSTEM . '://' . $prefix . $i . '.' . $extension, '');\n            }\n        }\n\n        // Querying should return all files\n        $this->setRequest(Request::create('/async/file/autocomplete', 'GET', [\n            'term' => $prefix,\n            'ext'  => '.*',\n        ]));\n\n        $response = $this->controller()->filesAutoComplete($this->getRequest());\n        $this->assertInstanceOf(JsonResponse::class, $response);\n        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());\n        $this->assertCount($count * count($extensions), Json::parse($response->getContent()));\n\n        // Filtering by one extension should return only $count files\n        $this->setRequest(Request::create('/async/file/autocomplete', 'GET', [\n            'term' => $prefix,\n            'ext'  => $extensions[0],\n        ]));\n\n        $response = $this->controller()->filesAutoComplete($this->getRequest());\n        $this->assertCount($count, Json::parse($response->getContent()));\n    }\n\n    public function testFileBrowser()\n    {\n        //$this->setSessionUser(new Entity\\Users($this->getService('users')->getUser('admin')));\n        $this->setRequest(Request::create('/async/recordbrowser'));\n\n        $response = $this->controller()->recordBrowser();\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('@bolt/recordbrowser/recordbrowser.twig', $response->getTemplate());\n    }\n\n    /**\n     * @param string $object The type of the object, either 'file' or 'folder'\n     * @param string $name   The name of the new object\n     */\n    private function createObject($object, $name)\n    {\n        $this->setRequest(Request::create(\"/async/$object/create\", 'POST', [\n            'namespace'  => 'files',\n            'parent'     => '',\n            'filename'   => $name,\n            'foldername' => $name,\n            'token'      => $this->token,\n        ]));\n        switch ($object) {\n            case 'file':\n                $this->controller()->createFile($this->getRequest());\n                break;\n            case 'folder':\n                $this->controller()->createFolder($this->getRequest());\n                break;\n        }\n        $this->assertTrue($this->getService('filesystem')->has(self::FILESYSTEM . '://' . $name));\n    }\n\n    /**\n     * @param string $object The type of the object, either 'file' or 'folder'\n     * @param string $old\n     * @param string $new\n     *\n     * @return JsonResponse\n     */\n    private function renameObject($object, $old, $new)\n    {\n        $this->setRequest(Request::create(\"/async/$object/rename\", 'POST', [\n            'namespace' => 'files',\n            'parent'    => '',\n            'oldname'   => $old,\n            'newname'   => $new,\n            'token'     => $this->token,\n        ]));\n        switch ($object) {\n            case 'file':\n                $response = $this->controller()->renameFile($this->getRequest());\n                break;\n            case 'folder':\n                $response = $this->controller()->renameFolder($this->getRequest());\n                break;\n        }\n\n        return $response;\n    }\n\n    /**\n     * @return \\Bolt\\Controller\\Async\\FilesystemManager\n     */\n    protected function controller()\n    {\n        return $this->getService('controller.async.filesystem_manager');\n    }\n}\n", "<?php\n\nnamespace Bolt\\Tests\\Controller;\n\nuse Bolt\\Controller\\Zone;\nuse Bolt\\Legacy\\Content;\nuse Bolt\\Response\\TemplateResponse;\nuse Bolt\\Response\\TemplateView;\nuse Bolt\\TemplateChooser;\nuse Bolt\\Twig\\Runtime\\HtmlRuntime;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseEvent;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\n\n/**\n * Class to test correct operation of src/Controller/Frontend.\n *\n *\n * @author Ross Riley <riley.ross@gmail.com>\n * @author Carson Full <carsonfull@gmail.com>\n * @author Gawain Lynch <gawain.lynch@gmail.com>\n **/\nclass FrontendTest extends ControllerUnitTest\n{\n    /**\n     * @covers \\Bolt\\Controller\\Zone::get\n     * @covers \\Bolt\\Controller\\Zone::isFrontend\n     */\n    public function testControllerZone()\n    {\n        $app = $this->getApp();\n        $this->setRequest(Request::create('/'));\n\n        $request = $this->getRequest();\n        $kernel = $this->createMock(HttpKernelInterface::class);\n        $app['dispatcher']->dispatch(KernelEvents::REQUEST, new GetResponseEvent($kernel, $request, HttpKernelInterface::MASTER_REQUEST));\n\n        $this->assertEquals('frontend', Zone::get($request));\n        $this->assertTrue(Zone::isFrontend($request));\n    }\n\n    public function testDefaultHomepageTemplate()\n    {\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyDefaultHomepage()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/compatibility/template_view', false);\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    public function testConfiguredConfigHomepageTemplate()\n    {\n        $this->getService('filesystem')->put('theme://custom-home.twig', '');\n        $this->getService('config')->set('general/homepage_template', 'custom-home.twig');\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('custom-home.twig', $response->getTemplate());\n    }\n\n    public function testConfiguredThemeHomepageTemplate()\n    {\n        $this->getService('filesystem')->put('theme://custom-theme-home.twig', '');\n        $this->getService('config')->set('theme/homepage_template', 'custom-theme-home.twig');\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('custom-theme-home.twig', $response->getTemplate());\n    }\n\n    public function testHomepageContent()\n    {\n        $this->setRequest(Request::create('/'));\n\n        $response = $this->controller()->homepage($this->getRequest());\n        $globals = $this->getTwigGlobals();\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertInstanceOf(Content::class, $globals['record']);\n    }\n\n    public function testMultipleHomepages()\n    {\n        $app = $this->getApp();\n        $this->setRequest(Request::create('/'));\n        $app['config']->set('general/homepage', 'pages');\n\n        $this->controller()->homepage($this->getRequest());\n\n        $globals = $this->getTwigGlobals();\n        foreach ($globals['records'] as $record) {\n            $this->assertInstanceOf(Content::class, $record);\n        }\n    }\n\n    public function testRecord()\n    {\n        $response = $this->getRecordResponse();\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('page.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyRecord()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $response = $this->getRecordResponse();\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('page.twig', $response->getTemplate());\n    }\n\n    private function getRecordResponse()\n    {\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $request = Request::create('/pages/test');\n        $this->setRequest($request);\n        $content = new Content($this->getApp(), $contentType);\n        $content->setValues(['slug' => 'test', 'title' => 'test']);\n        $this->getService('storage')->saveContent($content);\n\n        $response = $this->controller()->record($request, 'pages', 'test');\n\n        return $response;\n    }\n\n    public function testCanonicalUrlForHomepage()\n    {\n        $expected = 'http://foo.dev/';\n\n        /** @var \\Silex\\Application $app */\n        $app = $this->getApp();\n        $app['config']->set('general/homepage', 'page/1');\n\n        $this->setRequest(Request::create($expected));\n        $app['request_context']->fromRequest($this->getRequest());\n\n        $kernel = $this->createMock(HttpKernelInterface::class);\n        $event = new GetResponseEvent($kernel, $this->getRequest(), HttpKernelInterface::MASTER_REQUEST);\n        $app['canonical']->onRequest($event);\n\n        $templates = $this->getMockBuilder(TemplateChooser::class)\n            ->setMethods(['record'])\n            ->setConstructorArgs([$app['config']])\n            ->getMock()\n        ;\n        $templates->expects($this->any())\n            ->method('record')\n            ->will($this->returnValue('index.twig'));\n        $this->setService('templatechooser', $templates);\n\n        // Route for /page/1 instead of homepage\n        $this->controller()->record($this->getRequest(), 'page', '1');\n\n        $this->assertEquals($expected, $app['canonical']->getUrl(), 'Canonical url should be homepage');\n    }\n\n    public function testCanonicalUrlForNumericRecord()\n    {\n        /** @var \\Silex\\Application $app */\n        $app = $this->getApp();\n        $this->setService('twig.runtime.bolt_html', $this->getHtmlRuntime());\n\n        $this->setRequest(Request::create('/pages/5'));\n        $app['request_context']->fromRequest($this->getRequest());\n\n        $contentType = $app['storage']->getContentType('pages');\n        $content1 = new Content($app, $contentType);\n        $content1->id = 5;\n        $content1['slug'] = 'foo';\n\n        $storage = $this->getMockStorage(['getContent']);\n        $this->setService('storage', $storage);\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n\n        $storage->expects($this->at(1))\n            ->method('getContent')\n            ->will($this->returnValue($content1));\n\n        $kernel = $this->createMock(HttpKernelInterface::class);\n        $event = new GetResponseEvent($kernel, $this->getRequest(), HttpKernelInterface::MASTER_REQUEST);\n        $app['canonical']->onRequest($event);\n\n        // Route for /page/5 instead of /page/foo\n        $this->controller()->record($this->getRequest(), 'pages', 5);\n\n        $this->assertEquals('http://localhost/page/foo', $app['canonical']->getUrl(), 'Canonical url should use record slug instead of record ID');\n    }\n\n    public function testNumericRecord()\n    {\n        $this->setService('twig.runtime.bolt_html', $this->getHtmlRuntime());\n\n        $this->setRequest(Request::create('/pages/', 'GET', ['id' => 5]));\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $content1 = new Content($this->getApp(), $contentType);\n\n        $storage = $this->getMockStorage(['getContent']);\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n\n        $storage->expects($this->at(1))\n            ->method('getContent')\n            ->will($this->returnValue($content1));\n\n        $this->setService('storage', $storage);\n\n        $response = $this->controller()->record($this->getRequest(), 'pages', 5);\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('page.twig', $response->getTemplate());\n    }\n\n    /**\n     * @return HtmlRuntime\n     */\n    private function getHtmlRuntime()\n    {\n        $app = $this->getApp();\n\n        return new HtmlRuntime(\n            $app['config'],\n            $app['markdown'],\n            $app['menu'],\n            $app['storage']\n        );\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testNoRecord()\n    {\n        $this->setRequest(Request::create('/pages/', 'GET', ['id' => 5]));\n        $storage = $this->getMockStorage();\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n        $this->setService('storage', $storage);\n\n        $this->controller()->record($this->getRequest(), 'pages');\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testRecordNoTemplate()\n    {\n        $this->setRequest(Request::create('/pages/', 'GET', ['id' => 5]));\n        $storage = $this->getMockStorage();\n\n        $storage->expects($this->at(0))\n            ->method('getContent')\n            ->will($this->returnValue(false));\n        $this->setService('storage', $storage);\n\n        $this->controller()->record($this->getRequest(), 'pages');\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testViewlessRecord()\n    {\n        $this->setRequest(Request::create('/pages/test'));\n\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $contentType['viewless'] = true;\n\n        $storage = $this->getMockStorage();\n        $storage->expects($this->once())\n            ->method('getContentType')\n            ->will($this->returnValue($contentType));\n        $this->setService('storage', $storage);\n\n        $this->controller()->record($this->getRequest(), 'pages', 'test');\n    }\n\n    public function testPreview()\n    {\n        $this->setRequest(Request::create('/pages', 'POST'));\n        $this->controller()->listing($this->getRequest(), 'pages/test');\n\n        $templates = $this->getMockBuilder(TemplateChooser::class)\n            ->setMethods(['record'])\n            ->setConstructorArgs([$this->getApp()['config']])\n            ->getMock()\n        ;\n        $templates\n            ->expects($this->any())\n            ->method('record')\n            ->will($this->returnValue('record.twig'))\n        ;\n        $this->setService('templatechooser', $templates);\n\n        $response = $this->controller()->preview($this->getRequest(), 'pages');\n\n        $this->assertFalse($response instanceof TemplateView);\n    }\n\n    public function testListing()\n    {\n        $this->setRequest(Request::create('/pages'));\n        $response = $this->controller()->listing($this->getRequest(), 'pages');\n\n        $this->assertSame('listing.twig', $response->getTemplate());\n        $this->assertTrue($response instanceof TemplateView);\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyListing()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/pages'));\n        $response = $this->controller()->listing($this->getRequest(), 'pages');\n\n        $this->assertSame('listing.twig', $response->getTemplate());\n        $this->assertTrue($response instanceof TemplateResponse);\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage not found\n     */\n    public function testViewlessListing()\n    {\n        $this->setRequest(Request::create('/'));\n        $contentType = $this->getService('storage')->getContentType('pages');\n        $contentType['viewless'] = true;\n\n        $storage = $this->getMockStorage();\n        $storage->expects($this->once())\n            ->method('getContentType')\n            ->will($this->returnValue($contentType));\n        $this->setService('storage', $storage);\n\n        $response = $this->controller()->listing($this->getRequest(), 'pages');\n        $this->assertTrue($response instanceof TemplateView);\n    }\n\n    public function testBadTaxonomy()\n    {\n        $this->setRequest(Request::create('/faketaxonomy/main'));\n\n        $response = $this->controller()->taxonomy($this->getRequest(), 'faketaxonomy', 'main');\n        $this->assertFalse($response);\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpKernel\\Exception\\HttpException\n     * @expectedExceptionMessage No slug\n     */\n    public function testNoContent404()\n    {\n        $this->setRequest(Request::create('/tags/fake'));\n\n        $this->controller()->taxonomy($this->getRequest(), 'tags', 'fake');\n    }\n\n    public function testTaxonomyListing()\n    {\n        $this->setRequest(Request::create('/categories/news'));\n        $this->getService('config')->set('taxonomy/categories/singular_slug', 'categories');\n\n        $response = $this->controller()->taxonomy($this->getRequest(), 'categories', 'news');\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('listing.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyTaxonomyListing()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/categories/news'));\n        $this->getService('config')->set('taxonomy/categories/singular_slug', 'categories');\n\n        $response = $this->controller()->taxonomy($this->getRequest(), 'categories', 'news');\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('listing.twig', $response->getTemplate());\n    }\n\n    public function testSimpleTemplateRender()\n    {\n        $this->setRequest(Request::create('/example'));\n\n        $response = $this->controller()->template('index');\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacyTemplate()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/example'));\n\n        $response = $this->controller()->template('index');\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('index.twig', $response->getTemplate());\n    }\n\n    /**\n     * @expectedException \\Twig\\Error\\LoaderError\n     * @expectedExceptionMessage Template \"nonexistent.twig\" is not defined.\n     */\n    public function testFailingTemplateRender()\n    {\n        $this->controller()->template('nonexistent');\n    }\n\n    public function testSearchListing()\n    {\n        $this->setRequest(Request::create('/search', 'GET', ['q' => 'Lorem']));\n\n        $response = $this->controller()->search($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('search.twig', $response->getTemplate());\n    }\n\n    /**\n     * @group legacy\n     */\n    public function testLegacySearch()\n    {\n        $this->getService('config')->set('general/compatibility/template_view', false);\n        $this->setRequest(Request::create('/search', 'GET', ['q' => 'Lorem']));\n\n        $response = $this->controller()->search($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateResponse);\n        $this->assertSame('search.twig', $response->getTemplate());\n    }\n\n    public function testSearchWithFilters()\n    {\n        $this->setRequest(Request::create('/search', 'GET', [\n            'search'          => 'Lorem',\n            'pages_title'     => 1,\n            'showcases_title' => 1,\n            'pages_body'      => 1,\n        ]));\n\n        $response = $this->controller()->search($this->getRequest());\n\n        $this->assertTrue($response instanceof TemplateView);\n        $this->assertSame('search.twig', $response->getTemplate());\n    }\n\n    public function testBeforeHandlerForFirstUser()\n    {\n        $this->setRequest(Request::create('/'));\n\n        $users = $this->getMockUsers();\n\n        $users->expects($this->once())\n            ->method('getUsers')\n            ->will($this->returnValue(false));\n        $this->setService('users', $users);\n\n        $response = $this->controller()->before($this->getRequest());\n\n        $this->assertInstanceOf(RedirectResponse::class, $response);\n        $this->assertEquals('/bolt/userfirst', $response->getTargetUrl());\n    }\n\n    public function testBeforeHandlerForMaintenanceMode()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/maintenance_mode', true);\n\n        $permissions = $this->getMockPermissions();\n        $permissions->expects($this->any())\n            ->method('isAllowed')\n            ->will($this->returnValue(false));\n        $this->setService('permissions', $permissions);\n\n        $response = $this->controller()->before($this->getRequest());\n        $this->assertEquals(503, $response->getStatusCode());\n    }\n\n    public function testBeforeHandlerForPrivilegedMaintenanceMode()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/maintenance_mode', true);\n\n        $permissions = $this->getMockPermissions();\n        $permissions->expects($this->any())\n            ->method('isAllowed')\n            ->will($this->returnValue(true));\n        $this->setService('permissions', $permissions);\n\n        $response = $this->controller()->before($this->getRequest());\n\n        $this->assertNull($response);\n    }\n\n    public function testNormalBeforeHandler()\n    {\n        $this->setRequest(Request::create('/'));\n        $this->getService('config')->set('general/maintenance_mode', false);\n\n        $response = $this->controller()->before($this->getRequest());\n\n        $this->assertNull($response);\n    }\n\n    /**\n     * @return \\Bolt\\Controller\\Frontend\n     */\n    protected function controller()\n    {\n        return $this->getService('controller.frontend');\n    }\n\n    protected function getTwigGlobals()\n    {\n        $app = $this->getApp();\n\n        return $app['twig']->getGlobals();\n    }\n}\n"], "filenames": ["src/Config.php", "src/Controller/Async/FilesystemManager.php", "src/Controller/Frontend.php", "tests/phpunit/unit/Controller/Async/FilesystemManagerTest.php", "tests/phpunit/unit/Controller/FrontendTest.php"], "buggy_code_start_loc": [314, 430, 19, 28, 331], "buggy_code_end_loc": [315, 473, 203, 259, 333], "fixing_code_start_loc": [314, 431, 20, 28, 331], "fixing_code_end_loc": [315, 475, 211, 277, 332], "type": "CWE-352", "message": "Bolt CMS before version 3.7.1 lacked CSRF protection in the preview generating endpoint. Previews are intended to be generated by the admins, developers, chief-editors, and editors, who are authorized to create content in the application. But due to lack of proper CSRF protection, unauthorized users could generate a preview. This has been fixed in Bolt 3.7.1", "other": {"cve": {"id": "CVE-2020-4040", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-08T22:15:10.603", "lastModified": "2022-10-07T01:25:11.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bolt CMS before version 3.7.1 lacked CSRF protection in the preview generating endpoint. Previews are intended to be generated by the admins, developers, chief-editors, and editors, who are authorized to create content in the application. But due to lack of proper CSRF protection, unauthorized users could generate a preview. This has been fixed in Bolt 3.7.1"}, {"lang": "es", "value": "Bolt CMS versi\u00f3n anterior a 3.7.1, carec\u00eda de protecci\u00f3n de CSRF en  el endpoint de generaci\u00f3n de vista previa. Las vistas previas est\u00e1n destinadas a ser generadas por los administradores, desarrolladores, jefes de redacci\u00f3n y editores, que est\u00e1n autorizados para crear contenido en la aplicaci\u00f3n. Pero debido a la falta de una protecci\u00f3n de CSRF apropiada, los usuarios no autorizados podr\u00edan generar una vista previa. Esto se ha corregido en Bolt versi\u00f3n 3.7.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:boltcms:bolt:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.7.1", "matchCriteriaId": "00F61767-4ADE-48D3-B45B-7F500002E79D"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/158299/Bolt-CMS-3.7.0-XSS-CSRF-Shell-Upload.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2020/Jul/4", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/bolt/bolt/commit/b42cbfcf3e3108c46a80581216ba03ef449e419f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bolt/bolt/pull/7853", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bolt/bolt/security/advisories/GHSA-2q66-6cc3-6xm8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bolt/bolt/commit/b42cbfcf3e3108c46a80581216ba03ef449e419f"}}