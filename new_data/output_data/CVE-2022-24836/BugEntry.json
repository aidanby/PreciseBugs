{"buggy_code": ["# coding: utf-8\n# frozen_string_literal: true\n\nrequire \"pathname\"\n\nmodule Nokogiri\n  module HTML4\n    class Document < Nokogiri::XML::Document\n      ###\n      # Get the meta tag encoding for this document.  If there is no meta tag,\n      # then nil is returned.\n      def meta_encoding\n        if (meta = at_xpath(\"//meta[@charset]\"))\n          meta[:charset]\n        elsif (meta = meta_content_type)\n          meta[\"content\"][/charset\\s*=\\s*([\\w-]+)/i, 1]\n        end\n      end\n\n      ###\n      # Set the meta tag encoding for this document.\n      #\n      # If an meta encoding tag is already present, its content is\n      # replaced with the given text.\n      #\n      # Otherwise, this method tries to create one at an appropriate\n      # place supplying head and/or html elements as necessary, which\n      # is inside a head element if any, and before any text node or\n      # content element (typically <body>) if any.\n      #\n      # The result when trying to set an encoding that is different\n      # from the document encoding is undefined.\n      #\n      # Beware in CRuby, that libxml2 automatically inserts a meta tag\n      # into a head element.\n      def meta_encoding=(encoding)\n        if (meta = meta_content_type)\n          meta[\"content\"] = format(\"text/html; charset=%s\", encoding)\n          encoding\n        elsif (meta = at_xpath(\"//meta[@charset]\"))\n          meta[\"charset\"] = encoding\n        else\n          meta = XML::Node.new(\"meta\", self)\n          if (dtd = internal_subset) && dtd.html5_dtd?\n            meta[\"charset\"] = encoding\n          else\n            meta[\"http-equiv\"] = \"Content-Type\"\n            meta[\"content\"] = format(\"text/html; charset=%s\", encoding)\n          end\n\n          if (head = at_xpath(\"//head\"))\n            head.prepend_child(meta)\n          else\n            set_metadata_element(meta)\n          end\n          encoding\n        end\n      end\n\n      def meta_content_type\n        xpath(\"//meta[@http-equiv and boolean(@content)]\").find do |node|\n          node[\"http-equiv\"] =~ /\\AContent-Type\\z/i\n        end\n      end\n      private :meta_content_type\n\n      ###\n      # Get the title string of this document.  Return nil if there is\n      # no title tag.\n      def title\n        (title = at_xpath(\"//title\")) && title.inner_text\n      end\n\n      ###\n      # Set the title string of this document.\n      #\n      # If a title element is already present, its content is replaced\n      # with the given text.\n      #\n      # Otherwise, this method tries to create one at an appropriate\n      # place supplying head and/or html elements as necessary, which\n      # is inside a head element if any, right after a meta\n      # encoding/charset tag if any, and before any text node or\n      # content element (typically <body>) if any.\n      def title=(text)\n        tnode = XML::Text.new(text, self)\n        if (title = at_xpath(\"//title\"))\n          title.children = tnode\n          return text\n        end\n\n        title = XML::Node.new(\"title\", self) << tnode\n        if (head = at_xpath(\"//head\"))\n          head << title\n        elsif (meta = (at_xpath(\"//meta[@charset]\") || meta_content_type))\n          # better put after charset declaration\n          meta.add_next_sibling(title)\n        else\n          set_metadata_element(title)\n        end\n      end\n\n      def set_metadata_element(element) # rubocop:disable Naming/AccessorMethodName\n        if (head = at_xpath(\"//head\"))\n          head << element\n        elsif (html = at_xpath(\"//html\"))\n          head = html.prepend_child(XML::Node.new(\"head\", self))\n          head.prepend_child(element)\n        elsif (first = children.find do |node|\n                 case node\n                 when XML::Element, XML::Text\n                   true\n                 end\n               end)\n          # We reach here only if the underlying document model\n          # allows <html>/<head> elements to be omitted and does not\n          # automatically supply them.\n          first.add_previous_sibling(element)\n        else\n          html = add_child(XML::Node.new(\"html\", self))\n          head = html.add_child(XML::Node.new(\"head\", self))\n          head.prepend_child(element)\n        end\n      end\n      private :set_metadata_element\n\n      ####\n      # Serialize Node using +options+. Save options can also be set using a block.\n      #\n      # See also Nokogiri::XML::Node::SaveOptions and Node@Serialization+and+Generating+Output.\n      #\n      # These two statements are equivalent:\n      #\n      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)\n      #\n      # or\n      #\n      #   node.serialize(:encoding => 'UTF-8') do |config|\n      #     config.format.as_xml\n      #   end\n      #\n      def serialize(options = {})\n        options[:save_with] ||= XML::Node::SaveOptions::DEFAULT_HTML\n        super\n      end\n\n      ####\n      # Create a Nokogiri::XML::DocumentFragment from +tags+\n      def fragment(tags = nil)\n        DocumentFragment.new(self, tags, root)\n      end\n\n      # :call-seq:\n      #   xpath_doctype() \u2192 Nokogiri::CSS::XPathVisitor::DoctypeConfig\n      #\n      # [Returns] The document type which determines CSS-to-XPath translation.\n      #\n      # See XPathVisitor for more information.\n      def xpath_doctype\n        Nokogiri::CSS::XPathVisitor::DoctypeConfig::HTML4\n      end\n\n      class << self\n        ###\n        # Parse HTML.  +string_or_io+ may be a String, or any object that\n        # responds to _read_ and _close_ such as an IO, or StringIO.\n        # +url+ is resource where this document is located.  +encoding+ is the\n        # encoding that should be used when processing the document. +options+\n        # is a number that sets options in the parser, such as\n        # Nokogiri::XML::ParseOptions::RECOVER.  See the constants in\n        # Nokogiri::XML::ParseOptions.\n        def parse(string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML)\n          options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n          yield options if block_given?\n\n          url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil\n\n          if string_or_io.respond_to?(:encoding)\n            unless string_or_io.encoding.name == \"ASCII-8BIT\"\n              encoding ||= string_or_io.encoding.name\n            end\n          end\n\n          if string_or_io.respond_to?(:read)\n            if string_or_io.is_a?(Pathname)\n              # resolve the Pathname to the file and open it as an IO object, see #2110\n              string_or_io = string_or_io.expand_path.open\n              url ||= string_or_io.path\n            end\n\n            unless encoding\n              # Libxml2's parser has poor support for encoding\n              # detection.  First, it does not recognize the HTML5\n              # style meta charset declaration.  Secondly, even if it\n              # successfully detects an encoding hint, it does not\n              # re-decode or re-parse the preceding part which may be\n              # garbled.\n              #\n              # EncodingReader aims to perform advanced encoding\n              # detection beyond what Libxml2 does, and to emulate\n              # rewinding of a stream and make Libxml2 redo parsing\n              # from the start when an encoding hint is found.\n              string_or_io = EncodingReader.new(string_or_io)\n              begin\n                return read_io(string_or_io, url, encoding, options.to_i)\n              rescue EncodingFound => e\n                encoding = e.found_encoding\n              end\n            end\n            return read_io(string_or_io, url, encoding, options.to_i)\n          end\n\n          # read_memory pukes on empty docs\n          if string_or_io.nil? || string_or_io.empty?\n            return encoding ? new.tap { |i| i.encoding = encoding } : new\n          end\n\n          encoding ||= EncodingReader.detect_encoding(string_or_io)\n\n          read_memory(string_or_io, url, encoding, options.to_i)\n        end\n      end\n\n      class EncodingFound < StandardError # :nodoc: all\n        attr_reader :found_encoding\n\n        def initialize(encoding)\n          @found_encoding = encoding\n          super(format(\"encoding found: %s\", encoding))\n        end\n      end\n\n      # :nodoc: all\n      class EncodingReader\n        class SAXHandler < Nokogiri::XML::SAX::Document\n          attr_reader :encoding\n\n          def initialize\n            @encoding = nil\n            super()\n          end\n\n          def start_element(name, attrs = [])\n            return unless name == \"meta\"\n\n            attr = Hash[attrs]\n            (charset = attr[\"charset\"]) &&\n              (@encoding = charset)\n            (http_equiv = attr[\"http-equiv\"]) &&\n              http_equiv.match(/\\AContent-Type\\z/i) &&\n              (content = attr[\"content\"]) &&\n              (m = content.match(/;\\s*charset\\s*=\\s*([\\w-]+)/)) &&\n              (@encoding = m[1])\n          end\n        end\n\n        class JumpSAXHandler < SAXHandler\n          def initialize(jumptag)\n            @jumptag = jumptag\n            super()\n          end\n\n          def start_element(name, attrs = [])\n            super\n            throw(@jumptag, @encoding) if @encoding\n            throw(@jumptag, nil) if /\\A(?:div|h1|img|p|br)\\z/.match?(name)\n          end\n        end\n\n        def self.detect_encoding(chunk)\n          (m = chunk.match(/\\A(<\\?xml[ \\t\\r\\n]+[^>]*>)/)) &&\n            (return Nokogiri.XML(m[1]).encoding)\n\n          if Nokogiri.jruby?\n            (m = chunk.match(/(<meta\\s)(.*)(charset\\s*=\\s*([\\w-]+))(.*)/i)) &&\n              (return m[4])\n            catch(:encoding_found) do\n              Nokogiri::HTML4::SAX::Parser.new(JumpSAXHandler.new(:encoding_found)).parse(chunk)\n              nil\n            end\n          else\n            handler = SAXHandler.new\n            parser = Nokogiri::HTML4::SAX::PushParser.new(handler)\n            begin\n              parser << chunk\n            rescue\n              Nokogiri::SyntaxError\n            end\n            handler.encoding\n          end\n        end\n\n        def initialize(io)\n          @io = io\n          @firstchunk = nil\n          @encoding_found = nil\n        end\n\n        # This method is used by the C extension so that\n        # Nokogiri::HTML4::Document#read_io() does not leak memory when\n        # EncodingFound is raised.\n        attr_reader :encoding_found\n\n        def read(len)\n          # no support for a call without len\n\n          unless @firstchunk\n            (@firstchunk = @io.read(len)) || (return nil)\n\n            # This implementation expects that the first call from\n            # htmlReadIO() is made with a length long enough (~1KB) to\n            # achieve advanced encoding detection.\n            if (encoding = EncodingReader.detect_encoding(@firstchunk))\n              # The first chunk is stored for the next read in retry.\n              raise @encoding_found = EncodingFound.new(encoding)\n            end\n          end\n          @encoding_found = nil\n\n          ret = @firstchunk.slice!(0, len)\n          if (len -= ret.length) > 0\n            (rest = @io.read(len)) && ret << (rest)\n          end\n          if ret.empty?\n            nil\n          else\n            ret\n          end\n        end\n      end\n    end\n  end\nend\n", "# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n\nrequire \"helper\"\n\nclass TestNokogiriHtmlDocument < Nokogiri::TestCase\n  describe \"Nokogiri::HTML::Document\" do\n    describe \"Encoding\" do\n      def test_encoding\n        doc = Nokogiri::HTML(File.open(SHIFT_JIS_HTML, \"rb\"))\n\n        hello = \"\u3053\u3093\u306b\u3061\u306f\"\n\n        assert_match(doc.encoding, doc.to_html)\n        assert_match(hello.encode(\"Shift_JIS\"), doc.to_html)\n        assert_equal(\"Shift_JIS\", doc.to_html.encoding.name)\n\n        assert_match(hello, doc.to_html(encoding: \"UTF-8\"))\n        assert_match(\"UTF-8\", doc.to_html(encoding: \"UTF-8\"))\n        assert_match(\"UTF-8\", doc.to_html(encoding: \"UTF-8\").encoding.name)\n      end\n\n      def test_encoding_without_charset\n        doc = Nokogiri::HTML(File.open(SHIFT_JIS_NO_CHARSET, \"r:Shift_JIS:Shift_JIS\").read)\n\n        hello = \"\u3053\u3093\u306b\u3061\u306f\"\n\n        assert_match(hello, doc.content)\n        assert_match(hello, doc.to_html(encoding: \"UTF-8\"))\n        assert_match(\"UTF-8\", doc.to_html(encoding: \"UTF-8\").encoding.name)\n      end\n\n      def test_default_to_encoding_from_string\n        bad_charset = <<~eohtml\n          <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"   \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n          <html>\n          <head>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=charset=UTF-8\">\n          </head>\n          <body>\n            <a href=\"http://tenderlovemaking.com/\">blah!</a>\n          </body>\n          </html>\n        eohtml\n        doc = Nokogiri::HTML(bad_charset)\n        assert_equal(bad_charset.encoding.name, doc.encoding)\n\n        doc = Nokogiri.parse(bad_charset)\n        assert_equal(bad_charset.encoding.name, doc.encoding)\n      end\n\n      def test_encoding_non_utf8\n        orig = \"\u65e5\u672c\u8a9e\u304c\u4e0a\u624b\u3067\u3059\"\n        bin = Encoding::ASCII_8BIT\n        [Encoding::Shift_JIS, Encoding::EUC_JP].each do |enc|\n          html = <<~eohtml.encode(enc)\n            <html>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=#{enc.name}\">\n            <title xml:lang=\"ja\">#{orig}</title></html>\n          eohtml\n          text = Nokogiri::HTML.parse(html).at(\"title\").inner_text\n          assert_equal(\n            orig.encode(enc).force_encoding(bin),\n            text.encode(enc).force_encoding(bin)\n          )\n        end\n      end\n\n      def test_encoding_with_a_bad_name\n        bad_charset = <<~eohtml\n          <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"   \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n          <html>\n          <head>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=charset=UTF-8\">\n          </head>\n          <body>\n            <a href=\"http://tenderlovemaking.com/\">blah!</a>\n          </body>\n          </html>\n        eohtml\n        doc = Nokogiri::HTML(bad_charset, nil, \"askldjfhalsdfjhlkasdfjh\")\n        assert_equal([\"http://tenderlovemaking.com/\"],\n          doc.css(\"a\").map { |a| a[\"href\"] })\n      end\n\n      def test_empty_doc_encoding\n        encoding = \"US-ASCII\"\n        assert_equal(encoding, Nokogiri::HTML.parse(nil, nil, encoding).encoding)\n      end\n\n      describe \"Detection\" do\n        def binread(file)\n          File.binread(file)\n        end\n\n        def binopen(file)\n          File.open(file, \"rb\")\n        end\n\n        it \"handles both memory and IO\" do\n          from_stream = Nokogiri::HTML(binopen(NOENCODING_FILE))\n          from_string = Nokogiri::HTML(binread(NOENCODING_FILE))\n\n          assert_equal(from_string.to_s.size, from_stream.to_s.size)\n          assert_operator(from_string.to_s.size, :>, 0)\n        end\n\n        it \"uses meta charset encoding when present\" do\n          html = Nokogiri::HTML(binopen(METACHARSET_FILE))\n          assert_equal(\"iso-2022-jp\", html.encoding)\n          assert_equal(\"\u305f\u3053\u713c\u304d\u4eee\u9762\", html.title)\n        end\n\n        { \"xhtml\" => ENCODING_XHTML_FILE, \"html\" => ENCODING_HTML_FILE }.each do |flavor, file|\n          it \"detects #{flavor} document encoding\" do\n            doc_from_string_enc = Nokogiri::HTML(binread(file), nil, \"Shift_JIS\")\n            ary_from_string_enc = doc_from_string_enc.xpath(\"//p/text()\").map(&:text)\n\n            doc_from_string = Nokogiri::HTML(binread(file))\n            ary_from_string = doc_from_string.xpath(\"//p/text()\").map(&:text)\n\n            doc_from_file_enc = Nokogiri::HTML(binopen(file), nil, \"Shift_JIS\")\n            ary_from_file_enc = doc_from_file_enc.xpath(\"//p/text()\").map(&:text)\n\n            doc_from_file = Nokogiri::HTML(binopen(file))\n            ary_from_file = doc_from_file.xpath(\"//p/text()\").map(&:text)\n\n            title = \"\u305f\u3053\u713c\u304d\u4eee\u9762\"\n\n            assert_equal(title, doc_from_string_enc.at(\"//title/text()\").text)\n            assert_equal(title, doc_from_string.at(\"//title/text()\").text)\n            assert_equal(title, doc_from_file_enc.at(\"//title/text()\").text)\n            assert_equal(title, doc_from_file.at(\"//title/text()\").text)\n\n            evil = (0..72).map { |i| \"\u8d85\" * i + \"\u60aa\u3044\u4e8b\u3092\u69cb\u60f3\u4e2d\u3002\" }\n\n            assert_equal(evil, ary_from_string_enc)\n            assert_equal(evil, ary_from_string)\n\n            next unless !Nokogiri.uses_libxml? || Nokogiri::VersionInfo.instance.libxml2_has_iconv?\n\n            # libxml2 without iconv does not pass this test\n            assert_equal(evil, ary_from_file_enc)\n            assert_equal(evil, ary_from_file)\n          end\n        end\n\n        describe \"error handling\" do\n          RAW = \"<html><body><div\"\n\n          { \"read_memory\" => RAW, \"read_io\" => StringIO.new(RAW) }.each do |flavor, input|\n            it \"#{flavor} should handle errors\" do\n              doc = Nokogiri::HTML.parse(input)\n              assert_operator(doc.errors.length, :>, 0)\n            end\n          end\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# coding: utf-8\n# frozen_string_literal: true\n\nrequire \"pathname\"\n\nmodule Nokogiri\n  module HTML4\n    class Document < Nokogiri::XML::Document\n      ###\n      # Get the meta tag encoding for this document.  If there is no meta tag,\n      # then nil is returned.\n      def meta_encoding\n        if (meta = at_xpath(\"//meta[@charset]\"))\n          meta[:charset]\n        elsif (meta = meta_content_type)\n          meta[\"content\"][/charset\\s*=\\s*([\\w-]+)/i, 1]\n        end\n      end\n\n      ###\n      # Set the meta tag encoding for this document.\n      #\n      # If an meta encoding tag is already present, its content is\n      # replaced with the given text.\n      #\n      # Otherwise, this method tries to create one at an appropriate\n      # place supplying head and/or html elements as necessary, which\n      # is inside a head element if any, and before any text node or\n      # content element (typically <body>) if any.\n      #\n      # The result when trying to set an encoding that is different\n      # from the document encoding is undefined.\n      #\n      # Beware in CRuby, that libxml2 automatically inserts a meta tag\n      # into a head element.\n      def meta_encoding=(encoding)\n        if (meta = meta_content_type)\n          meta[\"content\"] = format(\"text/html; charset=%s\", encoding)\n          encoding\n        elsif (meta = at_xpath(\"//meta[@charset]\"))\n          meta[\"charset\"] = encoding\n        else\n          meta = XML::Node.new(\"meta\", self)\n          if (dtd = internal_subset) && dtd.html5_dtd?\n            meta[\"charset\"] = encoding\n          else\n            meta[\"http-equiv\"] = \"Content-Type\"\n            meta[\"content\"] = format(\"text/html; charset=%s\", encoding)\n          end\n\n          if (head = at_xpath(\"//head\"))\n            head.prepend_child(meta)\n          else\n            set_metadata_element(meta)\n          end\n          encoding\n        end\n      end\n\n      def meta_content_type\n        xpath(\"//meta[@http-equiv and boolean(@content)]\").find do |node|\n          node[\"http-equiv\"] =~ /\\AContent-Type\\z/i\n        end\n      end\n      private :meta_content_type\n\n      ###\n      # Get the title string of this document.  Return nil if there is\n      # no title tag.\n      def title\n        (title = at_xpath(\"//title\")) && title.inner_text\n      end\n\n      ###\n      # Set the title string of this document.\n      #\n      # If a title element is already present, its content is replaced\n      # with the given text.\n      #\n      # Otherwise, this method tries to create one at an appropriate\n      # place supplying head and/or html elements as necessary, which\n      # is inside a head element if any, right after a meta\n      # encoding/charset tag if any, and before any text node or\n      # content element (typically <body>) if any.\n      def title=(text)\n        tnode = XML::Text.new(text, self)\n        if (title = at_xpath(\"//title\"))\n          title.children = tnode\n          return text\n        end\n\n        title = XML::Node.new(\"title\", self) << tnode\n        if (head = at_xpath(\"//head\"))\n          head << title\n        elsif (meta = (at_xpath(\"//meta[@charset]\") || meta_content_type))\n          # better put after charset declaration\n          meta.add_next_sibling(title)\n        else\n          set_metadata_element(title)\n        end\n      end\n\n      def set_metadata_element(element) # rubocop:disable Naming/AccessorMethodName\n        if (head = at_xpath(\"//head\"))\n          head << element\n        elsif (html = at_xpath(\"//html\"))\n          head = html.prepend_child(XML::Node.new(\"head\", self))\n          head.prepend_child(element)\n        elsif (first = children.find do |node|\n                 case node\n                 when XML::Element, XML::Text\n                   true\n                 end\n               end)\n          # We reach here only if the underlying document model\n          # allows <html>/<head> elements to be omitted and does not\n          # automatically supply them.\n          first.add_previous_sibling(element)\n        else\n          html = add_child(XML::Node.new(\"html\", self))\n          head = html.add_child(XML::Node.new(\"head\", self))\n          head.prepend_child(element)\n        end\n      end\n      private :set_metadata_element\n\n      ####\n      # Serialize Node using +options+. Save options can also be set using a block.\n      #\n      # See also Nokogiri::XML::Node::SaveOptions and Node@Serialization+and+Generating+Output.\n      #\n      # These two statements are equivalent:\n      #\n      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)\n      #\n      # or\n      #\n      #   node.serialize(:encoding => 'UTF-8') do |config|\n      #     config.format.as_xml\n      #   end\n      #\n      def serialize(options = {})\n        options[:save_with] ||= XML::Node::SaveOptions::DEFAULT_HTML\n        super\n      end\n\n      ####\n      # Create a Nokogiri::XML::DocumentFragment from +tags+\n      def fragment(tags = nil)\n        DocumentFragment.new(self, tags, root)\n      end\n\n      # :call-seq:\n      #   xpath_doctype() \u2192 Nokogiri::CSS::XPathVisitor::DoctypeConfig\n      #\n      # [Returns] The document type which determines CSS-to-XPath translation.\n      #\n      # See XPathVisitor for more information.\n      def xpath_doctype\n        Nokogiri::CSS::XPathVisitor::DoctypeConfig::HTML4\n      end\n\n      class << self\n        ###\n        # Parse HTML.  +string_or_io+ may be a String, or any object that\n        # responds to _read_ and _close_ such as an IO, or StringIO.\n        # +url+ is resource where this document is located.  +encoding+ is the\n        # encoding that should be used when processing the document. +options+\n        # is a number that sets options in the parser, such as\n        # Nokogiri::XML::ParseOptions::RECOVER.  See the constants in\n        # Nokogiri::XML::ParseOptions.\n        def parse(string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML)\n          options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n          yield options if block_given?\n\n          url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil\n\n          if string_or_io.respond_to?(:encoding)\n            unless string_or_io.encoding.name == \"ASCII-8BIT\"\n              encoding ||= string_or_io.encoding.name\n            end\n          end\n\n          if string_or_io.respond_to?(:read)\n            if string_or_io.is_a?(Pathname)\n              # resolve the Pathname to the file and open it as an IO object, see #2110\n              string_or_io = string_or_io.expand_path.open\n              url ||= string_or_io.path\n            end\n\n            unless encoding\n              # Libxml2's parser has poor support for encoding\n              # detection.  First, it does not recognize the HTML5\n              # style meta charset declaration.  Secondly, even if it\n              # successfully detects an encoding hint, it does not\n              # re-decode or re-parse the preceding part which may be\n              # garbled.\n              #\n              # EncodingReader aims to perform advanced encoding\n              # detection beyond what Libxml2 does, and to emulate\n              # rewinding of a stream and make Libxml2 redo parsing\n              # from the start when an encoding hint is found.\n              string_or_io = EncodingReader.new(string_or_io)\n              begin\n                return read_io(string_or_io, url, encoding, options.to_i)\n              rescue EncodingFound => e\n                encoding = e.found_encoding\n              end\n            end\n            return read_io(string_or_io, url, encoding, options.to_i)\n          end\n\n          # read_memory pukes on empty docs\n          if string_or_io.nil? || string_or_io.empty?\n            return encoding ? new.tap { |i| i.encoding = encoding } : new\n          end\n\n          encoding ||= EncodingReader.detect_encoding(string_or_io)\n\n          read_memory(string_or_io, url, encoding, options.to_i)\n        end\n      end\n\n      class EncodingFound < StandardError # :nodoc: all\n        attr_reader :found_encoding\n\n        def initialize(encoding)\n          @found_encoding = encoding\n          super(format(\"encoding found: %s\", encoding))\n        end\n      end\n\n      # :nodoc: all\n      class EncodingReader\n        class SAXHandler < Nokogiri::XML::SAX::Document\n          attr_reader :encoding\n\n          def initialize\n            @encoding = nil\n            super()\n          end\n\n          def start_element(name, attrs = [])\n            return unless name == \"meta\"\n\n            attr = Hash[attrs]\n            (charset = attr[\"charset\"]) &&\n              (@encoding = charset)\n            (http_equiv = attr[\"http-equiv\"]) &&\n              http_equiv.match(/\\AContent-Type\\z/i) &&\n              (content = attr[\"content\"]) &&\n              (m = content.match(/;\\s*charset\\s*=\\s*([\\w-]+)/)) &&\n              (@encoding = m[1])\n          end\n        end\n\n        class JumpSAXHandler < SAXHandler\n          def initialize(jumptag)\n            @jumptag = jumptag\n            super()\n          end\n\n          def start_element(name, attrs = [])\n            super\n            throw(@jumptag, @encoding) if @encoding\n            throw(@jumptag, nil) if /\\A(?:div|h1|img|p|br)\\z/.match?(name)\n          end\n        end\n\n        def self.detect_encoding(chunk)\n          (m = chunk.match(/\\A(<\\?xml[ \\t\\r\\n][^>]*>)/)) &&\n            (return Nokogiri.XML(m[1]).encoding)\n\n          if Nokogiri.jruby?\n            (m = chunk.match(/(<meta\\s)(.*)(charset\\s*=\\s*([\\w-]+))(.*)/i)) &&\n              (return m[4])\n            catch(:encoding_found) do\n              Nokogiri::HTML4::SAX::Parser.new(JumpSAXHandler.new(:encoding_found)).parse(chunk)\n              nil\n            end\n          else\n            handler = SAXHandler.new\n            parser = Nokogiri::HTML4::SAX::PushParser.new(handler)\n            begin\n              parser << chunk\n            rescue\n              Nokogiri::SyntaxError\n            end\n            handler.encoding\n          end\n        end\n\n        def initialize(io)\n          @io = io\n          @firstchunk = nil\n          @encoding_found = nil\n        end\n\n        # This method is used by the C extension so that\n        # Nokogiri::HTML4::Document#read_io() does not leak memory when\n        # EncodingFound is raised.\n        attr_reader :encoding_found\n\n        def read(len)\n          # no support for a call without len\n\n          unless @firstchunk\n            (@firstchunk = @io.read(len)) || (return nil)\n\n            # This implementation expects that the first call from\n            # htmlReadIO() is made with a length long enough (~1KB) to\n            # achieve advanced encoding detection.\n            if (encoding = EncodingReader.detect_encoding(@firstchunk))\n              # The first chunk is stored for the next read in retry.\n              raise @encoding_found = EncodingFound.new(encoding)\n            end\n          end\n          @encoding_found = nil\n\n          ret = @firstchunk.slice!(0, len)\n          if (len -= ret.length) > 0\n            (rest = @io.read(len)) && ret << (rest)\n          end\n          if ret.empty?\n            nil\n          else\n            ret\n          end\n        end\n      end\n    end\n  end\nend\n", "# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n\nrequire \"helper\"\n\nclass TestNokogiriHtmlDocument < Nokogiri::TestCase\n  describe \"Nokogiri::HTML::Document\" do\n    describe \"Encoding\" do\n      def test_encoding\n        doc = Nokogiri::HTML(File.open(SHIFT_JIS_HTML, \"rb\"))\n\n        hello = \"\u3053\u3093\u306b\u3061\u306f\"\n\n        assert_match(doc.encoding, doc.to_html)\n        assert_match(hello.encode(\"Shift_JIS\"), doc.to_html)\n        assert_equal(\"Shift_JIS\", doc.to_html.encoding.name)\n\n        assert_match(hello, doc.to_html(encoding: \"UTF-8\"))\n        assert_match(\"UTF-8\", doc.to_html(encoding: \"UTF-8\"))\n        assert_match(\"UTF-8\", doc.to_html(encoding: \"UTF-8\").encoding.name)\n      end\n\n      def test_encoding_without_charset\n        doc = Nokogiri::HTML(File.open(SHIFT_JIS_NO_CHARSET, \"r:Shift_JIS:Shift_JIS\").read)\n\n        hello = \"\u3053\u3093\u306b\u3061\u306f\"\n\n        assert_match(hello, doc.content)\n        assert_match(hello, doc.to_html(encoding: \"UTF-8\"))\n        assert_match(\"UTF-8\", doc.to_html(encoding: \"UTF-8\").encoding.name)\n      end\n\n      def test_default_to_encoding_from_string\n        bad_charset = <<~eohtml\n          <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"   \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n          <html>\n          <head>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=charset=UTF-8\">\n          </head>\n          <body>\n            <a href=\"http://tenderlovemaking.com/\">blah!</a>\n          </body>\n          </html>\n        eohtml\n        doc = Nokogiri::HTML(bad_charset)\n        assert_equal(bad_charset.encoding.name, doc.encoding)\n\n        doc = Nokogiri.parse(bad_charset)\n        assert_equal(bad_charset.encoding.name, doc.encoding)\n      end\n\n      def test_encoding_non_utf8\n        orig = \"\u65e5\u672c\u8a9e\u304c\u4e0a\u624b\u3067\u3059\"\n        bin = Encoding::ASCII_8BIT\n        [Encoding::Shift_JIS, Encoding::EUC_JP].each do |enc|\n          html = <<~eohtml.encode(enc)\n            <html>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=#{enc.name}\">\n            <title xml:lang=\"ja\">#{orig}</title></html>\n          eohtml\n          text = Nokogiri::HTML.parse(html).at(\"title\").inner_text\n          assert_equal(\n            orig.encode(enc).force_encoding(bin),\n            text.encode(enc).force_encoding(bin)\n          )\n        end\n      end\n\n      def test_encoding_with_a_bad_name\n        bad_charset = <<~eohtml\n          <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"   \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n          <html>\n          <head>\n            <meta http-equiv=\"Content-Type\" content=\"text/html; charset=charset=UTF-8\">\n          </head>\n          <body>\n            <a href=\"http://tenderlovemaking.com/\">blah!</a>\n          </body>\n          </html>\n        eohtml\n        doc = Nokogiri::HTML(bad_charset, nil, \"askldjfhalsdfjhlkasdfjh\")\n        assert_equal([\"http://tenderlovemaking.com/\"],\n          doc.css(\"a\").map { |a| a[\"href\"] })\n      end\n\n      def test_empty_doc_encoding\n        encoding = \"US-ASCII\"\n        assert_equal(encoding, Nokogiri::HTML.parse(nil, nil, encoding).encoding)\n      end\n\n      describe \"Detection\" do\n        def binread(file)\n          File.binread(file)\n        end\n\n        def binopen(file)\n          File.open(file, \"rb\")\n        end\n\n        it \"handles both memory and IO\" do\n          from_stream = Nokogiri::HTML(binopen(NOENCODING_FILE))\n          from_string = Nokogiri::HTML(binread(NOENCODING_FILE))\n\n          assert_equal(from_string.to_s.size, from_stream.to_s.size)\n          assert_operator(from_string.to_s.size, :>, 0)\n        end\n\n        it \"uses meta charset encoding when present\" do\n          html = Nokogiri::HTML(binopen(METACHARSET_FILE))\n          assert_equal(\"iso-2022-jp\", html.encoding)\n          assert_equal(\"\u305f\u3053\u713c\u304d\u4eee\u9762\", html.title)\n        end\n\n        { \"xhtml\" => ENCODING_XHTML_FILE, \"html\" => ENCODING_HTML_FILE }.each do |flavor, file|\n          it \"detects #{flavor} document encoding\" do\n            doc_from_string_enc = Nokogiri::HTML(binread(file), nil, \"Shift_JIS\")\n            ary_from_string_enc = doc_from_string_enc.xpath(\"//p/text()\").map(&:text)\n\n            doc_from_string = Nokogiri::HTML(binread(file))\n            ary_from_string = doc_from_string.xpath(\"//p/text()\").map(&:text)\n\n            doc_from_file_enc = Nokogiri::HTML(binopen(file), nil, \"Shift_JIS\")\n            ary_from_file_enc = doc_from_file_enc.xpath(\"//p/text()\").map(&:text)\n\n            doc_from_file = Nokogiri::HTML(binopen(file))\n            ary_from_file = doc_from_file.xpath(\"//p/text()\").map(&:text)\n\n            title = \"\u305f\u3053\u713c\u304d\u4eee\u9762\"\n\n            assert_equal(title, doc_from_string_enc.at(\"//title/text()\").text)\n            assert_equal(title, doc_from_string.at(\"//title/text()\").text)\n            assert_equal(title, doc_from_file_enc.at(\"//title/text()\").text)\n            assert_equal(title, doc_from_file.at(\"//title/text()\").text)\n\n            evil = (0..72).map { |i| \"\u8d85\" * i + \"\u60aa\u3044\u4e8b\u3092\u69cb\u60f3\u4e2d\u3002\" }\n\n            assert_equal(evil, ary_from_string_enc)\n            assert_equal(evil, ary_from_string)\n\n            next unless !Nokogiri.uses_libxml? || Nokogiri::VersionInfo.instance.libxml2_has_iconv?\n\n            # libxml2 without iconv does not pass this test\n            assert_equal(evil, ary_from_file_enc)\n            assert_equal(evil, ary_from_file)\n          end\n        end\n\n        describe \"error handling\" do\n          RAW = \"<html><body><div\"\n\n          { \"read_memory\" => RAW, \"read_io\" => StringIO.new(RAW) }.each do |flavor, input|\n            it \"#{flavor} should handle errors\" do\n              doc = Nokogiri::HTML.parse(input)\n              assert_operator(doc.errors.length, :>, 0)\n            end\n          end\n        end\n\n        it \"does not start backtracking during detection of XHTML encoding\" do\n          # this test is a quick and dirty version\n          # of the more complete perf test that is on main.\n          n = 40_000\n          redos_string = \"<?xml \" + (\" \" * n)\n          redos_string.encode!(\"ASCII-8BIT\")\n          start_time = Time.now\n          Nokogiri::HTML4(redos_string)\n          elapsed_time = Time.now - start_time\n          assert_operator(elapsed_time, :<, 1)\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/nokogiri/html4/document.rb", "test/html4/test_document_encoding.rb"], "buggy_code_start_loc": [271, 157], "buggy_code_end_loc": [272, 157], "fixing_code_start_loc": [271, 158], "fixing_code_end_loc": [272, 170], "type": "CWE-1333", "message": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri `< v1.13.4` contains an inefficient regular expression that is susceptible to excessive backtracking when attempting to detect encoding in HTML documents. Users are advised to upgrade to Nokogiri `>= 1.13.4`. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-24836", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-11T22:15:07.347", "lastModified": "2023-02-16T02:30:25.097", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri `< v1.13.4` contains an inefficient regular expression that is susceptible to excessive backtracking when attempting to detect encoding in HTML documents. Users are advised to upgrade to Nokogiri `>= 1.13.4`. There are no known workarounds for this issue."}, {"lang": "es", "value": "Nokogiri es una biblioteca XML y HTML de c\u00f3digo abierto para Ruby. Nokogiri versiones anteriores a v1.13.4 contiene una expresi\u00f3n regular ineficiente que es susceptible de un retroceso excesivo cuando intenta detectar la codificaci\u00f3n en documentos HTML. Se recomienda a usuarios actualizar a Nokogiri versiones posteriores a 1.13.4 incluy\u00e9ndola. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}, {"lang": "en", "value": "CWE-400"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nokogiri:nokogiri:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.13.4", "matchCriteriaId": "57E74758-D6C1-4C5F-B471-D4028BAEF97C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0", "versionEndExcluding": "13.1", "matchCriteriaId": "454702CC-FB2E-4D17-AEAF-A428925B44A4"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Dec/23", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/nokogiri/commit/e444525ef1634b675cd1cf52d39f4320ef0aecfd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-crjr-9rc5-ghw8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00013.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00018.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6DHCOWMA5PQTIQIMDENA7R2Y5BDYAIYM/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OUPLBUZVM4WPFSXBEP2JS3R6LMKRTLFC/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XMDCWRQXJQ3TFSETPCEFMQ6RR6ME5UA3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-29", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213532", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sparklemotion/nokogiri/commit/e444525ef1634b675cd1cf52d39f4320ef0aecfd"}}