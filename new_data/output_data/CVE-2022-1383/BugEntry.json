{"buggy_code": ["/* radare - LGPL - Copyright 2020 - mrmacete */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_hash.h>\n#include \"coresymbolication.h\"\n\n#define R_CS_EL_OFF_SEGS 0x58\n#define R_CS_EL_SIZE_SEG 0x20\n#define R_CS_EL_SIZE_SECT_64 0x18\n#define R_CS_EL_SIZE_SECT_32 0x10\n#define R_CS_EL_SIZE_SYM 0x18\n#define R_CS_EL_SIZE_LSYM 0x24\n#define R_CS_EL_SIZE_LINFO 0x14\n\nstatic RCoreSymCacheElementHdr *r_coresym_cache_element_header_new(RBuffer *buf, size_t off, int bits) {\n\tRCoreSymCacheElementHdr *hdr = R_NEW0 (RCoreSymCacheElementHdr);\n\tif (hdr && r_buf_fread_at (buf, off, (ut8 *)hdr, \"13i16c5i\", 1) == sizeof (RCoreSymCacheElementHdr)) {\n\t\treturn hdr;\n\t}\n\tfree (hdr);\n\treturn NULL;\n}\n\nstatic void r_coresym_cache_element_segment_fini(RCoreSymCacheElementSegment *seg) {\n\tif (seg) {\n\t\tfree (seg->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_section_fini(RCoreSymCacheElementSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_flc_fini(RCoreSymCacheElementFLC *flc) {\n\tif (flc) {\n\t\tfree (flc->file);\n\t}\n}\n\nstatic void r_coresym_cache_element_symbol_fini(RCoreSymCacheElementSymbol *sym) {\n\tif (sym) {\n\t\tfree (sym->name);\n\t\tfree (sym->mangled_name);\n\t}\n}\n\nstatic void r_coresym_cache_element_lined_symbol_fini(RCoreSymCacheElementLinedSymbol *sym) {\n\tif (sym) {\n\t\tr_coresym_cache_element_symbol_fini (&sym->sym);\n\t\tr_coresym_cache_element_flc_fini (&sym->flc);\n\t}\n}\n\nstatic void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}\n\nvoid r_coresym_cache_element_free(RCoreSymCacheElement *element) {\n\tif (!element) {\n\t\treturn;\n\t}\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tr_coresym_cache_element_segment_fini (&element->segments[i]);\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tr_coresym_cache_element_section_fini (&element->sections[i]);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tr_coresym_cache_element_symbol_fini (&element->symbols[i]);\n\t\t}\n\t}\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tr_coresym_cache_element_lined_symbol_fini (&element->lined_symbols[i]);\n\t\t}\n\t}\n\tif (element->line_info) {\n\t\tfor (i = 0; i < element->hdr->n_line_info; i++) {\n\t\t\tr_coresym_cache_element_line_info_fini (&element->line_info[i]);\n\t\t}\n\t}\n\tfree (element->segments);\n\tfree (element->sections);\n\tfree (element->symbols);\n\tfree (element->lined_symbols);\n\tfree (element->line_info);\n\tfree (element->hdr);\n\tfree (element->file_name);\n\tfree (element->binary_version);\n\tfree (element);\n}\n\nut64 r_coresym_cache_element_pa2va(RCoreSymCacheElement *element, ut64 pa) {\n\tsize_t i;\n\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\tif (seg->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (seg->paddr < pa && pa < seg->paddr + seg->size) {\n\t\t\treturn pa - seg->paddr + seg->vaddr;\n\t\t}\n\t}\n\treturn pa;\n}\n\nstatic void meta_add_fileline(RBinFile *bf, ut64 vaddr, ut32 size, RCoreSymCacheElementFLC *flc) {\n\tSdb *s = bf->sdb_addrinfo;\n\tif (!s) {\n\t\treturn;\n\t}\n\tchar aoffset[64];\n\tut64 cursor = vaddr;\n\tut64 end = cursor + R_MAX (size, 1);\n\tchar *fileline = r_str_newf (\"%s:%d\", flc->file, flc->line);\n\twhile (cursor < end) {\n\t\tchar *aoffsetptr = sdb_itoa (cursor, aoffset, 16);\n\t\tif (!aoffsetptr) {\n\t\t\tbreak;\n\t\t}\n\t\tsdb_set (s, aoffsetptr, fileline, 0);\n\t\tsdb_set (s, fileline, aoffsetptr, 0);\n\t\tcursor += 2;\n\t}\n\tfree (fileline);\n}\n\nstatic char *str_dup_safe(const ut8 *b, const ut8 *str, const ut8 *end) {\n\tif (str >= b && str < end) {\n\t\tint len = r_str_nlen ((const char *)str, end - str);\n\t\tif (len) {\n\t\t\treturn r_str_ndup ((const char *)str, len);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nRCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n\n"], "fixing_code": ["/* radare - LGPL - Copyright 2020 - mrmacete */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_hash.h>\n#include \"coresymbolication.h\"\n\n#define R_CS_EL_OFF_SEGS 0x58\n#define R_CS_EL_SIZE_SEG 0x20\n#define R_CS_EL_SIZE_SECT_64 0x18\n#define R_CS_EL_SIZE_SECT_32 0x10\n#define R_CS_EL_SIZE_SYM 0x18\n#define R_CS_EL_SIZE_LSYM 0x24\n#define R_CS_EL_SIZE_LINFO 0x14\n\nstatic RCoreSymCacheElementHdr *r_coresym_cache_element_header_new(RBuffer *buf, size_t off, int bits) {\n\tRCoreSymCacheElementHdr *hdr = R_NEW0 (RCoreSymCacheElementHdr);\n\tif (hdr && r_buf_fread_at (buf, off, (ut8 *)hdr, \"13i16c5i\", 1) == sizeof (RCoreSymCacheElementHdr)) {\n\t\treturn hdr;\n\t}\n\tfree (hdr);\n\treturn NULL;\n}\n\nstatic void r_coresym_cache_element_segment_fini(RCoreSymCacheElementSegment *seg) {\n\tif (seg) {\n\t\tfree (seg->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_section_fini(RCoreSymCacheElementSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_flc_fini(RCoreSymCacheElementFLC *flc) {\n\tif (flc) {\n\t\tfree (flc->file);\n\t}\n}\n\nstatic void r_coresym_cache_element_symbol_fini(RCoreSymCacheElementSymbol *sym) {\n\tif (sym) {\n\t\tfree (sym->name);\n\t\tfree (sym->mangled_name);\n\t}\n}\n\nstatic void r_coresym_cache_element_lined_symbol_fini(RCoreSymCacheElementLinedSymbol *sym) {\n\tif (sym) {\n\t\tr_coresym_cache_element_symbol_fini (&sym->sym);\n\t\tr_coresym_cache_element_flc_fini (&sym->flc);\n\t}\n}\n\nstatic void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}\n\nvoid r_coresym_cache_element_free(RCoreSymCacheElement *element) {\n\tif (!element) {\n\t\treturn;\n\t}\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tr_coresym_cache_element_segment_fini (&element->segments[i]);\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tr_coresym_cache_element_section_fini (&element->sections[i]);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tr_coresym_cache_element_symbol_fini (&element->symbols[i]);\n\t\t}\n\t}\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tr_coresym_cache_element_lined_symbol_fini (&element->lined_symbols[i]);\n\t\t}\n\t}\n\tif (element->line_info) {\n\t\tfor (i = 0; i < element->hdr->n_line_info; i++) {\n\t\t\tr_coresym_cache_element_line_info_fini (&element->line_info[i]);\n\t\t}\n\t}\n\tfree (element->segments);\n\tfree (element->sections);\n\tfree (element->symbols);\n\tfree (element->lined_symbols);\n\tfree (element->line_info);\n\tfree (element->hdr);\n\tfree (element->file_name);\n\tfree (element->binary_version);\n\tfree (element);\n}\n\nut64 r_coresym_cache_element_pa2va(RCoreSymCacheElement *element, ut64 pa) {\n\tsize_t i;\n\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\tif (seg->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (seg->paddr < pa && pa < seg->paddr + seg->size) {\n\t\t\treturn pa - seg->paddr + seg->vaddr;\n\t\t}\n\t}\n\treturn pa;\n}\n\nstatic void meta_add_fileline(RBinFile *bf, ut64 vaddr, ut32 size, RCoreSymCacheElementFLC *flc) {\n\tSdb *s = bf->sdb_addrinfo;\n\tif (!s) {\n\t\treturn;\n\t}\n\tchar aoffset[64];\n\tut64 cursor = vaddr;\n\tut64 end = cursor + R_MAX (size, 1);\n\tchar *fileline = r_str_newf (\"%s:%d\", flc->file, flc->line);\n\twhile (cursor < end) {\n\t\tchar *aoffsetptr = sdb_itoa (cursor, aoffset, 16);\n\t\tif (!aoffsetptr) {\n\t\t\tbreak;\n\t\t}\n\t\tsdb_set (s, aoffsetptr, fileline, 0);\n\t\tsdb_set (s, fileline, aoffsetptr, 0);\n\t\tcursor += 2;\n\t}\n\tfree (fileline);\n}\n\nstatic char *str_dup_safe(const ut8 *b, const ut8 *str, const ut8 *end) {\n\tif (str >= b && str < end) {\n\t\tint len = r_str_nlen ((const char *)str, end - str);\n\t\tif (len) {\n\t\t\treturn r_str_ndup ((const char *)str, len);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nRCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n\t\t\t} else {\n\t\t\t\tsect->name = strdup (\"\");\n\t\t\t}\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n\n"], "filenames": ["libr/bin/format/mach0/coresymbolication.c"], "buggy_code_start_loc": [277], "buggy_code_end_loc": [295], "fixing_code_start_loc": [277], "fixing_code_end_loc": [299], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.", "other": {"cve": {"id": "CVE-2022-1383", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-18T01:15:10.333", "lastModified": "2022-04-26T16:26:45.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash."}, {"lang": "es", "value": "Un Desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.6.8. El bug causa que el programa lea datos m\u00e1s all\u00e1 del final del b\u00fafer previsto. Normalmente, esto puede permitir a atacantes leer informaci\u00f3n confidencial de otras ubicaciones de memoria o causar un bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.8", "matchCriteriaId": "8956009B-4EDA-4AA6-997D-B2C8C5D05CEC"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/1dd65336f0f0c351d6ea853efcf73cf9c0030862", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/02b4b563-b946-4343-9092-38d1c5cd60c9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/1dd65336f0f0c351d6ea853efcf73cf9c0030862"}}