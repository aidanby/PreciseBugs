{"buggy_code": ["import asyncio\nimport string\nfrom random import choice\nfrom typing import Optional\n\nimport discord\nfrom redbot.core import Config, commands\nfrom redbot.core.i18n import Translator, cog_i18n\n\n_ = Translator(\"Roomer\", __file__)\n\n\n@cog_i18n(_)\nclass Roomer(commands.Cog):\n    __version__ = \"1.0.0\"\n\n    def format_help_for_context(self, ctx: commands.Context) -> str:\n        # Thanks Sinbad! And Trusty in whose cogs I found this.\n        pre_processed = super().format_help_for_context(ctx)\n        return f\"{pre_processed}\\n\\nVersion: {self.__version__}\"\n\n    async def red_delete_data_for_user(self, **kwargs):\n        pass  # This cog stores no EUD\n\n    def __init__(self, bot):\n        self.config = Config.get_conf(self, identifier=300620201743, force_registration=True)\n        default_guild = {\n            \"auto_channels\": None,\n            \"name\": \"general\",\n            \"auto\": False,\n            \"pstart\": None,\n            \"pcat\": None,\n            \"pchannels\": {},\n            \"private\": False,\n            \"private_textchannels_enabled\": False,\n            \"private_textchannels\": {},\n        }\n        self.config.register_guild(**default_guild)\n        self.config.register_global(notification=0)\n        self.invoiceConfig = None\n        bot.loop.create_task(self.initialize(bot))\n\n    async def initialize(self, bot):\n        await bot.wait_until_red_ready()\n        self._maybe_get_invoice_config(bot)\n        await self._send_pending_owner_notifications(bot)\n\n    # region listeners\n\n    @commands.Cog.listener()\n    async def on_voice_state_update(self, member, before, after):\n        settings = await self.config.guild(member.guild).all()\n        # Some config cleanup for older versions here\n        try:\n            if settings[\"category\"]:\n                await self.config.guild(member.guild).category.clear()\n        except KeyError:\n            pass\n        await self._autoroom_listener(settings, member, before.channel, after.channel)\n        await self._privatevc_listener(settings, member, before.channel)\n\n    # region autoroom listener\n\n    async def _autoroom_listener(self, settings, member, before_channel, after_channel):\n        if settings[\"auto\"]:\n            if settings[\"auto_channels\"]:\n                if after_channel:\n                    await self._member_joined_auto_start_channel(settings, member, after_channel)\n                if before_channel:\n                    await self._maybe_delete_auto_channels(\n                        settings, member, before_channel, after_channel\n                    )\n\n    async def _member_joined_auto_start_channel(self, settings, member, after_channel):\n        if after_channel.id in settings[\"auto_channels\"]:\n            channel = await after_channel.category.create_voice_channel(\n                settings[\"name\"],\n                overwrites=after_channel.overwrites,\n                reason=_(\"Automated voicechannel creation.\"),\n            )\n            await member.move_to(channel, reason=_(\"Moved to automatically created channel.\"))\n\n    async def _maybe_delete_auto_channels(self, settings, member, before_channel, after_channel):\n        if len(before_channel.members) == 0:\n            auto_categories = [\n                member.guild.get_channel(c).category for c in settings[\"auto_channels\"]\n            ]\n            if before_channel.id in settings[\"auto_channels\"]:\n                return\n            elif before_channel.category in auto_categories:\n                try:\n                    await before_channel.delete(reason=_(\"Channel empty.\"))\n                except discord.NotFound:\n                    pass\n\n    # endregion autoroom listener\n\n    # region privatevc listener\n\n    async def _privatevc_listener(self, settings, member, before_channel):\n        if settings[\"private\"]:\n            if before_channel:\n                if before_channel.id in settings[\"pchannels\"].values():\n                    if len(before_channel.members) == 0:\n                        for key in settings[\"pchannels\"]:\n                            if settings[\"pchannels\"][key] == before_channel.id:\n                                ckey = key\n                        del settings[\"pchannels\"][ckey]\n                        await self.config.guild(member.guild).pchannels.set(settings[\"pchannels\"])\n                        await before_channel.delete(reason=_(\"Private room empty.\"))\n\n    # endregion privatevc listener\n\n    # endregion listeners\n\n    @commands.admin()\n    @commands.guild_only()\n    @commands.group()\n    async def roomer(self, ctx):\n        \"\"\"Roomer settings\"\"\"\n        pass\n\n    @commands.guild_only()\n    @commands.group()\n    async def vc(self, ctx):\n        \"\"\"Voicechannel commands.\"\"\"\n        pass\n\n    @commands.guild_only()\n    @commands.group()\n    async def tc(self, ctx):\n        \"\"\"Textchannel commands.\"\"\"\n        pass\n\n    # region auto\n    @roomer.group()\n    async def auto(self, ctx):\n        \"\"\"Automation settings.\"\"\"\n        pass\n\n    @auto.command()\n    async def enable(self, ctx):\n        \"\"\"Enable automatic voicechannel creation.\"\"\"\n        await self.config.guild(ctx.guild).auto.set(True)\n        await ctx.send(_(\"Automatic voicechannel creation enabled.\"))\n\n    @auto.command()\n    async def disable(self, ctx):\n        \"\"\"Disable automatic voicechannel creation.\"\"\"\n        await self.config.guild(ctx.guild).auto.set(True)\n        await ctx.send(_(\"Automatic voicechannel creation disabled.\"))\n\n    @auto.command()\n    async def name(self, ctx, *, name: str):\n        \"\"\"Set the name that is used for automatically created voicechannels.\"\"\"\n        await self.config.guild(ctx.guild).name.set(name)\n        await ctx.send(\n            _(\"Automatically created voicechannels will now be named ``{name}``.\").format(\n                name=name\n            )\n        )\n\n    @auto.group()\n    async def channel(self, ctx):\n        \"\"\"Manage channels related to automated voicechannels.\"\"\"\n        pass\n\n    @channel.command()\n    async def add(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Add a start channel used for automatic voicechannels.\"\"\"\n        if not channel.category:\n            return await ctx.send(\n                _(\n                    \"{channel} is not in a discord category. Auto-channels need to be part of a category for this feature to work properly.\"\n                ).format(channel=channel.name)\n            )\n        auto_channels = await self.config.guild(ctx.guild).auto_channels()\n        if auto_channels is None:\n            auto_channels = []\n        auto_channels.append(channel.id)\n        await self.config.guild(ctx.guild).auto_channels.set(auto_channels)\n        await ctx.send(\n            _(\"Startchannel used for automatic voicechannels added: {channel}\").format(\n                channel=channel.name\n            )\n        )\n\n    @channel.command()\n    async def remove(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Remove a start channel used for automatic voicechannels.\"\"\"\n        auto_channels = await self.config.guild(ctx.guild).auto_channels()\n        auto_channels.remove(channel.id)\n        await self.config.guild(ctx.guild).auto_channels.set(auto_channels)\n        await ctx.send(\n            _(\"Startchannel used for automatic voicechannels removed: {channel}\").format(\n                channel=channel.name\n            )\n        )\n\n    # endregion auto\n\n    # region privatevc\n\n    @roomer.group()\n    async def private(self, ctx):\n        \"\"\"Change settings for private rooms\"\"\"\n        pass\n\n    @private.command(name=\"enable\")\n    async def penable(self, ctx):\n        \"\"\"Enable private rooms\"\"\"\n        if await self.config.guild(ctx.guild).pstart():\n            await self.config.guild(ctx.guild).private.set(True)\n            await ctx.send(_(\"Private channels enabled.\"))\n        else:\n            await ctx.send(\n                _(\"Set up a starting channel using {command} first.\").format(\n                    command=f\"``{ctx.clean_prefix}roomer private startchannel``\"\n                )\n            )\n\n    @private.command(name=\"disable\")\n    async def pdisable(self, ctx):\n        \"\"\"Disable private rooms\"\"\"\n        await self.config.guild(ctx.guild).private.set(False)\n        await ctx.send(_(\"Private channels disabled.\"))\n\n    @private.command()\n    async def startchannel(self, ctx, vc: discord.VoiceChannel):\n        \"\"\"Set a channel that users will join to start using private rooms.\\nI recommend not allowing talking permissions here.\"\"\"\n        await self.config.guild(ctx.guild).pstart.set(vc.id)\n        await self.config.guild(ctx.guild).pcat.set(vc.category_id)\n        await ctx.send(\n            _(\n                \"Private starting channel set. Users can join this channel to use all features of private rooms.\\nI recommend not allowing members to speak in this channel.\"\n            )\n        )\n\n    @commands.max_concurrency(1, commands.BucketType.guild, wait=True)\n    @vc.command()\n    async def create(self, ctx, public: Optional[bool] = False, *, name: str):\n        \"\"\"Create a private voicechannel.\"\"\"\n        data = await self.config.guild(ctx.guild).all()\n        if data[\"private\"]:\n            try:\n                if ctx.author.voice.channel.id == data[\"pstart\"]:\n                    key = await self._generate_key(data[\"pchannels\"].keys())\n                    if public:\n                        ov = {\n                            ctx.author: discord.PermissionOverwrite(\n                                view_channel=True, connect=True, speak=True, manage_channels=True\n                            )\n                        }\n                    else:\n                        ov = {\n                            ctx.guild.default_role: discord.PermissionOverwrite(\n                                view_channel=True,\n                                connect=False,\n                                use_voice_activation=True,\n                            ),\n                            ctx.author: discord.PermissionOverwrite(\n                                view_channel=True, connect=True, speak=True, manage_channels=True\n                            ),\n                        }\n                    c = await ctx.guild.create_voice_channel(\n                        name,\n                        overwrites=ov,\n                        category=ctx.guild.get_channel(data[\"pcat\"]),\n                        reason=_(\"Private room\"),\n                    )\n                    await ctx.author.move_to(c, reason=_(\"Private channel.\"))\n                    data[\"pchannels\"][key] = c.id\n                    await self.config.guild(ctx.guild).pchannels.set(data[\"pchannels\"])\n                    try:\n                        await self._send_key(ctx, key)\n                    except KeyError:\n                        await ctx.send(\n                            _(\"Couldn't send the key to your private channel. Aborting...\")\n                        )\n                        await ctx.autho.move_to(ctx.author.voice.channel)\n                        await c.delete()\n                        return\n                else:\n                    await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n            except AttributeError:\n                await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n        else:\n            await ctx.send(_(\"Private rooms are not enabled on this server.\"))\n\n    @commands.guild_only()\n    @vc.command()\n    async def join(self, ctx, key: str):\n        \"\"\"Join a private room.\"\"\"\n        await ctx.message.delete()\n        async with ctx.typing():\n            data = await self.config.guild(ctx.guild).all()\n            if data[\"private\"]:\n                try:\n                    if ctx.author.voice.channel.id == data[\"pstart\"]:\n                        if key in data[\"pchannels\"]:\n                            await ctx.author.move_to(ctx.guild.get_channel(data[\"pchannels\"][key]))\n                    else:\n                        await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n                except AttributeError:\n                    await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n            else:\n                await ctx.send(_(\"Private rooms are not enabled on this server.\"))\n\n    @commands.guild_only()\n    @vc.command()\n    async def hidden(self, ctx: commands.Context, true_or_false: Optional[bool] = True):\n        \"\"\"Hide or unhide a voicechannel you own.\"\"\"\n        data = await self.config.guild(ctx.guild).pchannels()\n        try:\n            for key in data:\n                if data[key] == ctx.author.voice.channel.id:\n                    ov = {\n                        ctx.guild.default_role: discord.PermissionOverwrite(\n                            view_channel=False, connect=False\n                        ),\n                        ctx.author: discord.PermissionOverwrite(\n                            view_channel=True, connect=True, speak=True, manage_channels=True\n                        ),\n                    }\n                    if self.invoiceConfig:\n                        ov[\n                            ctx.guild.get_role(\n                                await self.invoiceConfig.channel(ctx.author.voice.channel).role()\n                            )\n                        ] = discord.PermissionOverwrite(\n                            view_channel=True, connect=True, speak=True\n                        )\n                    await ctx.author.voice.channel.edit(overwrites=ov)\n            await ctx.tick()\n            await ctx.send(_(\"VC has been hidden successfully.\"))\n        except AttributeError:\n            return await ctx.send(_(\"You need to be in a VC to do this.\"))\n\n    async def _send_key(self, ctx, key):\n        text = _(\n            \"The key to your private room is: ``{key}``\\nGive this key to a friend and ask them to use ``{command}`` to join your private room.\"\n        ).format(key=key, command=f\"{ctx.clean_prefix}vc join {key}\")\n        if self.invoiceConfig:\n            for i in range(10):\n                try:\n                    await ctx.guild.get_channel(\n                        await self.invoiceConfig.channel(ctx.author.voice.channel).channel()\n                    ).send(text)\n                    break\n                except:\n                    await asyncio.sleep(2)\n                if i == 9:\n                    await self._send_key_dm(ctx.author, text)\n        else:\n            await self._send_key_dm(ctx.author, text)\n\n    async def _send_key_dm(self, author, text):\n        try:\n            await author.send(text)\n        except discord.Forbidden:\n            raise KeyError\n\n    # endregion privatevc\n\n    # region privatetc\n\n    @roomer.group()\n    async def text(self, ctx):\n        \"\"\"Change settings for private text channels.\"\"\"\n        pass\n\n    @text.command(name=\"enable\")\n    async def tc_enable(self, ctx):\n        \"\"\"Enable private text channels.\"\"\"\n        await self.config.guild(ctx.guild).private_textchannels_enabled.set(True)\n        await ctx.send(_(\"Private text channels enabled.\"))\n\n    @text.command(name=\"disable\")\n    async def tc_disable(self, ctx):\n        \"\"\"Enable private text channels.\"\"\"\n        await self.config.guild(ctx.guild).private_textchannels_enabled.set(False)\n        await ctx.send(_(\"Private text channels disabled.\"))\n\n    @commands.max_concurrency(1, commands.BucketType.guild, wait=True)\n    @tc.command(name=\"create\")\n    async def tc_create(self, ctx, public: Optional[bool] = False, *, name: str):\n        \"\"\"Create a private text channel.\"\"\"\n        data = await self.config.guild(ctx.guild).all()\n        if data[\"private_textchannels_enabled\"]:\n            key = await self._generate_key(data[\"private_textchannels\"].keys())\n            ov = {\n                ctx.guild.default_role: discord.PermissionOverwrite(\n                    view_channel=False,\n                    read_message_history=False,\n                    read_messages=False,\n                    send_messages=False,\n                ),\n                ctx.author: discord.PermissionOverwrite(\n                    view_channel=True,\n                    manage_channels=True,\n                    manage_messages=True,\n                    read_message_history=True,\n                    read_messages=True,\n                    send_messages=True,\n                    send_tts_messages=True,\n                ),\n            }\n            c = await ctx.guild.create_text_channel(\n                name,\n                overwrites=ov,\n                category=ctx.guild.get_channel(data[\"pcat\"]),\n                reason=_(\"Private text channel\"),\n            )\n            data[\"private_textchannels\"][key] = c.id\n            await self.config.guild(ctx.guild).pchannels.set(data[\"private_textchannels\"])\n            await self._send_private_textchannel_key(c, key, ctx.clean_prefix)\n        else:\n            await ctx.send(_(\"Private text channels are not enabled on this server.\"))\n\n    @commands.max_concurrency(1, commands.BucketType.guild, wait=True)\n    @tc.command(name=\"close\")\n    async def tc_close(self, ctx):\n        \"\"\"Close the current private text cannel.\"\"\"\n        async with self.config.guild(ctx.guild).private_textchannels() as textchannels:\n            if ctx.channel.id in textchannels:\n                await ctx.channel.delete(reason=_(\"Private text channel deleted.\"))\n                del textchannels[ctx.channel.id]\n            else:\n                await ctx.send(_(\"Use this command in a private text channel.\"))\n\n    @tc.command(name=\"join\")\n    async def tc_join(self, ctx, key: str):\n        \"\"\"Join a private text channel.\"\"\"\n        await ctx.message.delete()\n        async with ctx.typing():\n            data = await self.config.guild(ctx.guild).all()\n            if data[\"private_textchannels_enabled\"]:\n                if key in data[\"private_textchannels\"]:\n                    await ctx.guild.get_channel(int(key)).set_permissions(\n                        ctx.author,\n                        read_message_history=True,\n                        read_messages=True,\n                        send_messages=True,\n                        view_channel=True,\n                    )\n            else:\n                await ctx.send(_(\"Private rooms are not enabled on this server.\"))\n\n    async def _send_private_textchannel_key(\n        self, channel: discord.TextChannel, key: str, clean_prefix\n    ):\n        m = await channel.send(\n            _(\n                \"The key to this private text channel is: ``{key}``\\nGive this key to a friend and ask them to use ``{command}`` to join your private room.\"\n            ).format(key=key, command=f\"{clean_prefix}tc join {key}\")\n        )\n        try:\n            await m.pin()\n        except discord.Forbidden:\n            pass\n\n    # endregion privatetc\n\n    # region helpers\n    async def sendNotInStartChannelMessage(self, ctx, channel_id):\n        await ctx.send(\n            _(\"You must be in the voicechannel {vc} first.\").format(\n                vc=ctx.guild.get_channel(channel_id).mention\n            )\n        )\n\n    def _maybe_get_invoice_config(self, bot):\n        if bot.get_cog(\"InVoice\"):\n            self.invoiceConfig = bot.get_cog(\"InVoice\").config\n\n    async def _send_pending_owner_notifications(self, bot):\n        if await self.config.notification() == 0:\n            await bot.send_to_owners(\n                \"Roomer: If you are updating roomer you will need to redo your autoroom setup.\\n\\nThis is due to some backend storage changes to allow for multiple automated categories.\"\n            )\n            await self.config.notification.set(1)\n\n    async def _generate_key(self, key_list_for_channel_type):\n        while True:\n            # This probably won't turn into an endless loop bceause it has more possibilities than discord allows channels per guild\n            key = \"\".join(choice(string.ascii_lowercase + \"0123456789\") for i in range(16))\n            if not (key in key_list_for_channel_type):\n                return key\n\n    # endregion helpers\n"], "fixing_code": ["import asyncio\nimport string\nfrom random import choice\nfrom typing import Optional\n\nimport discord\nfrom redbot.core import Config, commands\nfrom redbot.core.i18n import Translator, cog_i18n\n\n_ = Translator(\"Roomer\", __file__)\n\n\n@cog_i18n(_)\nclass Roomer(commands.Cog):\n    __version__ = \"1.0.1\"\n\n    def format_help_for_context(self, ctx: commands.Context) -> str:\n        # Thanks Sinbad! And Trusty in whose cogs I found this.\n        pre_processed = super().format_help_for_context(ctx)\n        return f\"{pre_processed}\\n\\nVersion: {self.__version__}\"\n\n    async def red_delete_data_for_user(self, **kwargs):\n        pass  # This cog stores no EUD\n\n    def __init__(self, bot):\n        self.config = Config.get_conf(self, identifier=300620201743, force_registration=True)\n        default_guild = {\n            \"auto_channels\": None,\n            \"name\": \"general\",\n            \"auto\": False,\n            \"pstart\": None,\n            \"pcat\": None,\n            \"pchannels\": {},\n            \"private\": False,\n            \"private_textchannels_enabled\": False,\n            \"private_textchannels\": {},\n        }\n        self.config.register_guild(**default_guild)\n        self.config.register_global(notification=0)\n        self.invoiceConfig = None\n        bot.loop.create_task(self.initialize(bot))\n\n    async def initialize(self, bot):\n        await bot.wait_until_red_ready()\n        self._maybe_get_invoice_config(bot)\n        await self._send_pending_owner_notifications(bot)\n\n    # region listeners\n\n    @commands.Cog.listener()\n    async def on_voice_state_update(self, member, before, after):\n        settings = await self.config.guild(member.guild).all()\n        # Some config cleanup for older versions here\n        try:\n            if settings[\"category\"]:\n                await self.config.guild(member.guild).category.clear()\n        except KeyError:\n            pass\n        await self._autoroom_listener(settings, member, before.channel, after.channel)\n        await self._privatevc_listener(settings, member, before.channel)\n\n    # region autoroom listener\n\n    async def _autoroom_listener(self, settings, member, before_channel, after_channel):\n        if settings[\"auto\"]:\n            if settings[\"auto_channels\"]:\n                if after_channel:\n                    await self._member_joined_auto_start_channel(settings, member, after_channel)\n                if before_channel:\n                    await self._maybe_delete_auto_channels(\n                        settings, member, before_channel, after_channel\n                    )\n\n    async def _member_joined_auto_start_channel(self, settings, member, after_channel):\n        if after_channel.id in settings[\"auto_channels\"]:\n            channel = await after_channel.category.create_voice_channel(\n                settings[\"name\"],\n                overwrites=after_channel.overwrites,\n                reason=_(\"Automated voicechannel creation.\"),\n            )\n            await member.move_to(channel, reason=_(\"Moved to automatically created channel.\"))\n\n    async def _maybe_delete_auto_channels(self, settings, member, before_channel, after_channel):\n        if len(before_channel.members) == 0:\n            auto_categories = [\n                member.guild.get_channel(c).category for c in settings[\"auto_channels\"]\n            ]\n            if before_channel.id in settings[\"auto_channels\"]:\n                return\n            elif before_channel.category in auto_categories:\n                try:\n                    await before_channel.delete(reason=_(\"Channel empty.\"))\n                except discord.NotFound:\n                    pass\n\n    # endregion autoroom listener\n\n    # region privatevc listener\n\n    async def _privatevc_listener(self, settings, member, before_channel):\n        if settings[\"private\"]:\n            if before_channel:\n                if before_channel.id in settings[\"pchannels\"].values():\n                    if len(before_channel.members) == 0:\n                        for key in settings[\"pchannels\"]:\n                            if settings[\"pchannels\"][key] == before_channel.id:\n                                ckey = key\n                        del settings[\"pchannels\"][ckey]\n                        await self.config.guild(member.guild).pchannels.set(settings[\"pchannels\"])\n                        await before_channel.delete(reason=_(\"Private room empty.\"))\n\n    # endregion privatevc listener\n\n    # endregion listeners\n\n    @commands.admin()\n    @commands.guild_only()\n    @commands.group()\n    async def roomer(self, ctx):\n        \"\"\"Roomer settings\"\"\"\n        pass\n\n    @commands.guild_only()\n    @commands.group()\n    async def vc(self, ctx):\n        \"\"\"Voicechannel commands.\"\"\"\n        pass\n\n    @commands.guild_only()\n    @commands.group()\n    async def tc(self, ctx):\n        \"\"\"Textchannel commands.\"\"\"\n        pass\n\n    # region auto\n    @roomer.group()\n    async def auto(self, ctx):\n        \"\"\"Automation settings.\"\"\"\n        pass\n\n    @auto.command()\n    async def enable(self, ctx):\n        \"\"\"Enable automatic voicechannel creation.\"\"\"\n        await self.config.guild(ctx.guild).auto.set(True)\n        await ctx.send(_(\"Automatic voicechannel creation enabled.\"))\n\n    @auto.command()\n    async def disable(self, ctx):\n        \"\"\"Disable automatic voicechannel creation.\"\"\"\n        await self.config.guild(ctx.guild).auto.set(True)\n        await ctx.send(_(\"Automatic voicechannel creation disabled.\"))\n\n    @auto.command()\n    async def name(self, ctx, *, name: str):\n        \"\"\"Set the name that is used for automatically created voicechannels.\"\"\"\n        await self.config.guild(ctx.guild).name.set(name)\n        await ctx.send(\n            _(\"Automatically created voicechannels will now be named ``{name}``.\").format(\n                name=name\n            )\n        )\n\n    @auto.group()\n    async def channel(self, ctx):\n        \"\"\"Manage channels related to automated voicechannels.\"\"\"\n        pass\n\n    @channel.command()\n    async def add(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Add a start channel used for automatic voicechannels.\"\"\"\n        if not channel.category:\n            return await ctx.send(\n                _(\n                    \"{channel} is not in a discord category. Auto-channels need to be part of a category for this feature to work properly.\"\n                ).format(channel=channel.name)\n            )\n        auto_channels = await self.config.guild(ctx.guild).auto_channels()\n        if auto_channels is None:\n            auto_channels = []\n        auto_channels.append(channel.id)\n        await self.config.guild(ctx.guild).auto_channels.set(auto_channels)\n        await ctx.send(\n            _(\"Startchannel used for automatic voicechannels added: {channel}\").format(\n                channel=channel.name\n            )\n        )\n\n    @channel.command()\n    async def remove(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Remove a start channel used for automatic voicechannels.\"\"\"\n        auto_channels = await self.config.guild(ctx.guild).auto_channels()\n        auto_channels.remove(channel.id)\n        await self.config.guild(ctx.guild).auto_channels.set(auto_channels)\n        await ctx.send(\n            _(\"Startchannel used for automatic voicechannels removed: {channel}\").format(\n                channel=channel.name\n            )\n        )\n\n    # endregion auto\n\n    # region privatevc\n\n    @roomer.group()\n    async def private(self, ctx):\n        \"\"\"Change settings for private rooms\"\"\"\n        pass\n\n    @private.command(name=\"enable\")\n    async def penable(self, ctx):\n        \"\"\"Enable private rooms\"\"\"\n        if await self.config.guild(ctx.guild).pstart():\n            await self.config.guild(ctx.guild).private.set(True)\n            await ctx.send(_(\"Private channels enabled.\"))\n        else:\n            await ctx.send(\n                _(\"Set up a starting channel using {command} first.\").format(\n                    command=f\"``{ctx.clean_prefix}roomer private startchannel``\"\n                )\n            )\n\n    @private.command(name=\"disable\")\n    async def pdisable(self, ctx):\n        \"\"\"Disable private rooms\"\"\"\n        await self.config.guild(ctx.guild).private.set(False)\n        await ctx.send(_(\"Private channels disabled.\"))\n\n    @private.command()\n    async def startchannel(self, ctx, vc: discord.VoiceChannel):\n        \"\"\"Set a channel that users will join to start using private rooms.\\nI recommend not allowing talking permissions here.\"\"\"\n        await self.config.guild(ctx.guild).pstart.set(vc.id)\n        await self.config.guild(ctx.guild).pcat.set(vc.category_id)\n        await ctx.send(\n            _(\n                \"Private starting channel set. Users can join this channel to use all features of private rooms.\\nI recommend not allowing members to speak in this channel.\"\n            )\n        )\n\n    @commands.max_concurrency(1, commands.BucketType.guild, wait=True)\n    @vc.command()\n    async def create(self, ctx, public: Optional[bool] = False, *, name: str):\n        \"\"\"Create a private voicechannel.\"\"\"\n        data = await self.config.guild(ctx.guild).all()\n        if data[\"private\"]:\n            try:\n                if ctx.author.voice.channel.id == data[\"pstart\"]:\n                    key = await self._generate_key(data[\"pchannels\"].keys())\n                    if public:\n                        ov = {\n                            ctx.author: discord.PermissionOverwrite(\n                                view_channel=True, connect=True, speak=True, manage_channels=True\n                            )\n                        }\n                    else:\n                        ov = {\n                            ctx.guild.default_role: discord.PermissionOverwrite(\n                                view_channel=True,\n                                connect=False,\n                                use_voice_activation=True,\n                            ),\n                            ctx.author: discord.PermissionOverwrite(\n                                view_channel=True, connect=True, speak=True, manage_channels=True\n                            ),\n                        }\n                    c = await ctx.guild.create_voice_channel(\n                        name,\n                        overwrites=ov,\n                        category=ctx.guild.get_channel(data[\"pcat\"]),\n                        reason=_(\"Private room\"),\n                    )\n                    await ctx.author.move_to(c, reason=_(\"Private channel.\"))\n                    data[\"pchannels\"][key] = c.id\n                    await self.config.guild(ctx.guild).pchannels.set(data[\"pchannels\"])\n                    try:\n                        await self._send_key(ctx, key)\n                    except KeyError:\n                        await ctx.send(\n                            _(\"Couldn't send the key to your private channel. Aborting...\")\n                        )\n                        await ctx.autho.move_to(ctx.author.voice.channel)\n                        await c.delete()\n                        return\n                else:\n                    await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n            except AttributeError:\n                await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n        else:\n            await ctx.send(_(\"Private rooms are not enabled on this server.\"))\n\n    @commands.guild_only()\n    @vc.command()\n    async def join(self, ctx, key: str):\n        \"\"\"Join a private room.\"\"\"\n        await ctx.message.delete()\n        async with ctx.typing():\n            data = await self.config.guild(ctx.guild).all()\n            if data[\"private\"]:\n                try:\n                    if ctx.author.voice.channel.id == data[\"pstart\"]:\n                        if key in data[\"pchannels\"]:\n                            await ctx.author.move_to(ctx.guild.get_channel(data[\"pchannels\"][key]))\n                    else:\n                        await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n                except AttributeError:\n                    await self.sendNotInStartChannelMessage(ctx, data[\"pstart\"])\n            else:\n                await ctx.send(_(\"Private rooms are not enabled on this server.\"))\n\n    @commands.guild_only()\n    @vc.command()\n    async def hidden(self, ctx: commands.Context, true_or_false: Optional[bool] = True):\n        \"\"\"Hide or unhide a voicechannel you own.\"\"\"\n        data = await self.config.guild(ctx.guild).pchannels()\n        try:\n            for key in data:\n                if data[key] == ctx.author.voice.channel.id:\n                    ov = ctx.author.voice.channel.overwrites\n                    ov[ctx.guild.default_role] = discord.PermissionOverwrite(\n                        view_channel=False, connect=False\n                    )\n                    if self.invoiceConfig:\n                        ov[\n                            ctx.guild.get_role(\n                                await self.invoiceConfig.channel(ctx.author.voice.channel).role()\n                            )\n                        ] = discord.PermissionOverwrite(\n                            view_channel=True, connect=True, speak=True\n                        )\n                    await ctx.author.voice.channel.edit(overwrites=ov)\n            await ctx.tick()\n            await ctx.send(_(\"VC has been hidden successfully.\"))\n        except AttributeError:\n            return await ctx.send(_(\"You need to be in a VC to do this.\"))\n\n    async def _send_key(self, ctx, key):\n        text = _(\n            \"The key to your private room is: ``{key}``\\nGive this key to a friend and ask them to use ``{command}`` to join your private room.\"\n        ).format(key=key, command=f\"{ctx.clean_prefix}vc join {key}\")\n        if self.invoiceConfig:\n            for i in range(10):\n                try:\n                    await ctx.guild.get_channel(\n                        await self.invoiceConfig.channel(ctx.author.voice.channel).channel()\n                    ).send(text)\n                    break\n                except:\n                    await asyncio.sleep(2)\n                if i == 9:\n                    await self._send_key_dm(ctx.author, text)\n        else:\n            await self._send_key_dm(ctx.author, text)\n\n    async def _send_key_dm(self, author, text):\n        try:\n            await author.send(text)\n        except discord.Forbidden:\n            raise KeyError\n\n    # endregion privatevc\n\n    # region privatetc\n\n    @roomer.group()\n    async def text(self, ctx):\n        \"\"\"Change settings for private text channels.\"\"\"\n        pass\n\n    @text.command(name=\"enable\")\n    async def tc_enable(self, ctx):\n        \"\"\"Enable private text channels.\"\"\"\n        await self.config.guild(ctx.guild).private_textchannels_enabled.set(True)\n        await ctx.send(_(\"Private text channels enabled.\"))\n\n    @text.command(name=\"disable\")\n    async def tc_disable(self, ctx):\n        \"\"\"Enable private text channels.\"\"\"\n        await self.config.guild(ctx.guild).private_textchannels_enabled.set(False)\n        await ctx.send(_(\"Private text channels disabled.\"))\n\n    @commands.max_concurrency(1, commands.BucketType.guild, wait=True)\n    @tc.command(name=\"create\")\n    async def tc_create(self, ctx, public: Optional[bool] = False, *, name: str):\n        \"\"\"Create a private text channel.\"\"\"\n        data = await self.config.guild(ctx.guild).all()\n        if data[\"private_textchannels_enabled\"]:\n            key = await self._generate_key(data[\"private_textchannels\"].keys())\n            ov = {\n                ctx.guild.default_role: discord.PermissionOverwrite(\n                    view_channel=False,\n                    read_message_history=False,\n                    read_messages=False,\n                    send_messages=False,\n                ),\n                ctx.author: discord.PermissionOverwrite(\n                    view_channel=True,\n                    manage_channels=True,\n                    manage_messages=True,\n                    read_message_history=True,\n                    read_messages=True,\n                    send_messages=True,\n                    send_tts_messages=True,\n                ),\n            }\n            c = await ctx.guild.create_text_channel(\n                name,\n                overwrites=ov,\n                category=ctx.guild.get_channel(data[\"pcat\"]),\n                reason=_(\"Private text channel\"),\n            )\n            data[\"private_textchannels\"][key] = c.id\n            await self.config.guild(ctx.guild).pchannels.set(data[\"private_textchannels\"])\n            await self._send_private_textchannel_key(c, key, ctx.clean_prefix)\n        else:\n            await ctx.send(_(\"Private text channels are not enabled on this server.\"))\n\n    @commands.max_concurrency(1, commands.BucketType.guild, wait=True)\n    @tc.command(name=\"close\")\n    async def tc_close(self, ctx):\n        \"\"\"Close the current private text cannel.\"\"\"\n        async with self.config.guild(ctx.guild).private_textchannels() as textchannels:\n            if ctx.channel.id in textchannels:\n                await ctx.channel.delete(reason=_(\"Private text channel deleted.\"))\n                del textchannels[ctx.channel.id]\n            else:\n                await ctx.send(_(\"Use this command in a private text channel.\"))\n\n    @tc.command(name=\"join\")\n    async def tc_join(self, ctx, key: str):\n        \"\"\"Join a private text channel.\"\"\"\n        await ctx.message.delete()\n        async with ctx.typing():\n            data = await self.config.guild(ctx.guild).all()\n            if data[\"private_textchannels_enabled\"]:\n                if key in data[\"private_textchannels\"]:\n                    await ctx.guild.get_channel(int(key)).set_permissions(\n                        ctx.author,\n                        read_message_history=True,\n                        read_messages=True,\n                        send_messages=True,\n                        view_channel=True,\n                    )\n            else:\n                await ctx.send(_(\"Private rooms are not enabled on this server.\"))\n\n    async def _send_private_textchannel_key(\n        self, channel: discord.TextChannel, key: str, clean_prefix\n    ):\n        m = await channel.send(\n            _(\n                \"The key to this private text channel is: ``{key}``\\nGive this key to a friend and ask them to use ``{command}`` to join your private room.\"\n            ).format(key=key, command=f\"{clean_prefix}tc join {key}\")\n        )\n        try:\n            await m.pin()\n        except discord.Forbidden:\n            pass\n\n    # endregion privatetc\n\n    # region helpers\n    async def sendNotInStartChannelMessage(self, ctx, channel_id):\n        await ctx.send(\n            _(\"You must be in the voicechannel {vc} first.\").format(\n                vc=ctx.guild.get_channel(channel_id).mention\n            )\n        )\n\n    def _maybe_get_invoice_config(self, bot):\n        if bot.get_cog(\"InVoice\"):\n            self.invoiceConfig = bot.get_cog(\"InVoice\").config\n\n    async def _send_pending_owner_notifications(self, bot):\n        if await self.config.notification() == 0:\n            await bot.send_to_owners(\n                \"Roomer: If you are updating roomer you will need to redo your autoroom setup.\\n\\nThis is due to some backend storage changes to allow for multiple automated categories.\"\n            )\n            await self.config.notification.set(1)\n\n    async def _generate_key(self, key_list_for_channel_type):\n        while True:\n            # This probably won't turn into an endless loop bceause it has more possibilities than discord allows channels per guild\n            key = \"\".join(choice(string.ascii_lowercase + \"0123456789\") for i in range(16))\n            if not (key in key_list_for_channel_type):\n                return key\n\n    # endregion helpers\n"], "filenames": ["roomer/roomer.py"], "buggy_code_start_loc": [15], "buggy_code_end_loc": [325], "fixing_code_start_loc": [15], "fixing_code_end_loc": [321], "type": "NVD-CWE-noinfo", "message": "Roomer is a discord bot cog (extension) which provides automatic voice channel generation as well as private voice and text channels. A vulnerability has been discovered allowing discord users to get the ``manage channel`` permissions in a private VC they have joined. This allowed them to make changes to or delete the voice channel they have taken over. The exploit does not allow access or control to any other channels in the server. Upgrade to version 1.0.1 for a patched version of the cog. As a workaround you may disable private VCs in your guild(server) or unload the roomer cog to render the exploit unusable.", "other": {"cve": {"id": "CVE-2021-32646", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-28T18:15:07.493", "lastModified": "2022-07-02T20:01:19.470", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Roomer is a discord bot cog (extension) which provides automatic voice channel generation as well as private voice and text channels. A vulnerability has been discovered allowing discord users to get the ``manage channel`` permissions in a private VC they have joined. This allowed them to make changes to or delete the voice channel they have taken over. The exploit does not allow access or control to any other channels in the server. Upgrade to version 1.0.1 for a patched version of the cog. As a workaround you may disable private VCs in your guild(server) or unload the roomer cog to render the exploit unusable."}, {"lang": "es", "value": "Roomer es un bot cog (extensi\u00f3n) de discord que proporciona generaci\u00f3n autom\u00e1tica de canales de voz, as\u00ed como canales privados de voz y texto.&#xa0;Ha sido detectada una vulnerabilidad que permite a usuarios de discord obtener los permisos de \"manage channel\" en un VC privado al que se han unido.&#xa0;Esto les permiti\u00f3 realizar cambios o eliminar el canal de voz que han asumido.&#xa0;La explotaci\u00f3n no permite el acceso ni el control a ning\u00fan otro canal del servidor.&#xa0;Actualizar a versi\u00f3n 1.0.1 para obtener una versi\u00f3n parcheada del cog.&#xa0;Como soluci\u00f3n alternativa, puede desencadenar los VC privados en su guild(server) o descargar el engranaje m\u00e1s espacioso para inutilizar la explotaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dav-cogs_project:dav-cogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "E33CBB67-F1C1-4F77-8886-644206CB57F0"}]}]}], "references": [{"url": "https://github.com/Dav-Git/Dav-Cogs/commit/fbe2ae8ec851a2e9e3e2370db3b812f268e8c8cb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Dav-Git/Dav-Cogs/security/advisories/GHSA-3f73-8j6q-28v8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Dav-Git/Dav-Cogs/commit/fbe2ae8ec851a2e9e3e2370db3b812f268e8c8cb"}}