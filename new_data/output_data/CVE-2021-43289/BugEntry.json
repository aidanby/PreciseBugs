{"buggy_code": ["/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.server.controller;\n\nimport com.thoughtworks.go.domain.ConsoleConsumer;\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.domain.StageIdentifier;\nimport com.thoughtworks.go.domain.exception.IllegalArtifactLocationException;\nimport com.thoughtworks.go.server.cache.ZipArtifactCache;\nimport com.thoughtworks.go.server.dao.JobInstanceDao;\nimport com.thoughtworks.go.server.security.HeaderConstraint;\nimport com.thoughtworks.go.server.service.ArtifactsService;\nimport com.thoughtworks.go.server.service.ConsoleActivityMonitor;\nimport com.thoughtworks.go.server.service.ConsoleService;\nimport com.thoughtworks.go.server.service.RestfulService;\nimport com.thoughtworks.go.server.util.ErrorHandler;\nimport com.thoughtworks.go.server.view.artifacts.ArtifactsView;\nimport com.thoughtworks.go.server.view.artifacts.LocalArtifactsView;\nimport com.thoughtworks.go.server.web.ArtifactFolderViewFactory;\nimport com.thoughtworks.go.server.web.FileModelAndView;\nimport com.thoughtworks.go.server.web.ResponseCodeView;\nimport com.thoughtworks.go.util.ArtifactLogUtil;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.thoughtworks.go.server.web.ZipArtifactFolderViewFactory.zipViewFactory;\nimport static com.thoughtworks.go.util.ArtifactLogUtil.isConsoleOutput;\nimport static com.thoughtworks.go.util.GoConstants.*;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n\n@Controller\npublic class ArtifactsController {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ArtifactsController.class);\n\n    private final JobInstanceDao jobInstanceDao;\n    private final ConsoleActivityMonitor consoleActivityMonitor;\n    private final ArtifactFolderViewFactory folderViewFactory;\n    private final ArtifactFolderViewFactory jsonViewFactory;\n    private final ArtifactFolderViewFactory zipViewFactory;\n    private final Charset consoleLogCharset;\n    private ArtifactsService artifactsService;\n    private RestfulService restfulService;\n    private ConsoleService consoleService;\n    private HeaderConstraint headerConstraint;\n\n    @Autowired\n    ArtifactsController(ArtifactsService artifactsService, RestfulService restfulService, ZipArtifactCache zipArtifactCache, JobInstanceDao jobInstanceDao,\n                        ConsoleActivityMonitor consoleActivityMonitor, ConsoleService consoleService, SystemEnvironment systemEnvironment) {\n        this.artifactsService = artifactsService;\n        this.restfulService = restfulService;\n        this.jobInstanceDao = jobInstanceDao;\n        this.consoleActivityMonitor = consoleActivityMonitor;\n        this.consoleService = consoleService;\n\n        this.folderViewFactory = FileModelAndView.htmlViewFactory();\n        this.jsonViewFactory = FileModelAndView.jsonViewfactory();\n        this.zipViewFactory = zipViewFactory(zipArtifactCache);\n        this.headerConstraint = new HeaderConstraint(systemEnvironment);\n        this.consoleLogCharset = systemEnvironment.consoleLogCharsetAsCharset();\n    }\n\n\n    /* RESTful URLs */\n    @RequestMapping(value = \"/repository/restful/artifact/GET/html\", method = RequestMethod.GET)\n    public ModelAndView getArtifactAsHtml(@RequestParam(\"pipelineName\") String pipelineName,\n                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                          @RequestParam(\"stageName\") String stageName,\n                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                          @RequestParam(\"buildName\") String buildName,\n                                          @RequestParam(\"filePath\") String filePath,\n                                          @RequestParam(value = \"sha1\", required = false) String sha,\n                                          @RequestParam(value = \"serverAlias\", required = false) String serverAlias) throws Exception {\n        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/GET/json\", method = RequestMethod.GET)\n    public ModelAndView getArtifactAsJson(@RequestParam(\"pipelineName\") String pipelineName,\n                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                          @RequestParam(\"stageName\") String stageName,\n                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                          @RequestParam(\"buildName\") String buildName,\n                                          @RequestParam(\"filePath\") String filePath,\n                                          @RequestParam(value = \"sha1\", required = false) String sha\n    ) throws Exception {\n        return getArtifact(filePath, jsonViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/GET/zip\", method = RequestMethod.GET)\n    public ModelAndView getArtifactAsZip(@RequestParam(\"pipelineName\") String pipelineName,\n                                         @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                         @RequestParam(\"stageName\") String stageName,\n                                         @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                         @RequestParam(\"buildName\") String buildName,\n                                         @RequestParam(\"filePath\") String filePath,\n                                         @RequestParam(value = \"sha1\", required = false) String sha\n    ) throws Exception {\n        if (filePath.equals(\".zip\")) {\n            filePath = \"./.zip\";\n        }\n        return getArtifact(filePath, zipViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/GET/*\", method = RequestMethod.GET)\n    public void fetch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        request.getRequestDispatcher(\"/repository/restful/artifact/GET/html\").forward(request, response);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/POST/*\", method = RequestMethod.POST)\n    public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineName,\n                                     @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                     @RequestParam(\"stageName\") String stageName,\n                                     @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                     @RequestParam(\"buildName\") String buildName,\n                                     @RequestParam(value = \"buildId\", required = false) Long buildId,\n                                     @RequestParam(\"filePath\") String filePath,\n                                     @RequestParam(value = \"attempt\", required = false) Integer attempt,\n                                     MultipartHttpServletRequest request) throws Exception {\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }\n\n    private boolean updateChecksumFile(MultipartHttpServletRequest request, JobIdentifier jobIdentifier, String filePath) throws IOException, IllegalArtifactLocationException {\n        MultipartFile checksumMultipartFile = getChecksumFile(request);\n        if (checksumMultipartFile != null) {\n            String checksumFilePath = String.format(\"%s/%s/%s\", artifactsService.findArtifactRoot(jobIdentifier), ArtifactLogUtil.CRUISE_OUTPUT_FOLDER, ArtifactLogUtil.MD5_CHECKSUM_FILENAME);\n            File checksumFile = artifactsService.getArtifactLocation(checksumFilePath);\n            synchronized (checksumFilePath.intern()) {\n                return artifactsService.saveOrAppendFile(checksumFile, checksumMultipartFile.getInputStream());\n            }\n        } else {\n            LOGGER.warn(\"[Artifacts Upload] Checksum file not uploaded for artifact at path '{}'\", filePath);\n        }\n        return true;\n    }\n\n    private boolean saveFile(int convertedAttempt, File artifact, MultipartFile multipartFile, boolean shouldUnzip) throws IOException {\n        try (InputStream inputStream = multipartFile.getInputStream()) {\n            return artifactsService.saveFile(artifact, inputStream, shouldUnzip, convertedAttempt);\n        }\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/PUT/*\", method = RequestMethod.PUT)\n    public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineName,\n                                    @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                    @RequestParam(\"stageName\") String stageName,\n                                    @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                    @RequestParam(\"buildName\") String buildName,\n                                    @RequestParam(value = \"buildId\", required = false) Long buildId,\n                                    @RequestParam(\"filePath\") String filePath,\n                                    @RequestParam(value = \"agentId\", required = false) String agentId,\n                                    HttpServletRequest request\n    ) throws Exception {\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        JobIdentifier jobIdentifier;\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        if (isConsoleOutput(filePath)) {\n            return putConsoleOutput(jobIdentifier, request.getInputStream());\n        } else {\n            return putArtifact(jobIdentifier, filePath, request.getInputStream());\n        }\n    }\n\n    /* Other URLs */\n\n    @RequestMapping(value = \"/**/consoleout.json\", method = RequestMethod.GET)\n    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,\n                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                   @RequestParam(\"stageName\") String stageName,\n                                   @RequestParam(\"buildName\") String buildName,\n                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                   @RequestParam(value = \"startLineNumber\", required = false) Long start\n    ) {\n        start = start == null ? 0L : start;\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }\n\n    @ErrorHandler\n    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {\n        LOGGER.error(\"Error loading artifacts: \", e);\n        Map model = new HashMap();\n        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");\n        return new ModelAndView(\"exceptions_page\", model);\n    }\n\n    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {\n        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        long before = System.currentTimeMillis();\n        ArtifactsView view;\n        //Work out the job that we are trying to retrieve\n        JobIdentifier translatedId;\n        try {\n            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        }\n\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);\n\n        ModelAndView createdView = view.createView(filePath, sha);\n        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);\n        return createdView;\n    }\n\n    private boolean shouldUnzipStream(MultipartFile multipartFile) {\n        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);\n    }\n\n    private MultipartFile multipartFile(MultipartHttpServletRequest request) {\n        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);\n        if (multipartFile == null) {\n            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);\n        }\n        return multipartFile;\n    }\n\n    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {\n        return request.getFile(CHECKSUM_MULTIPART_FILENAME);\n    }\n\n    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {\n        File consoleLogFile = consoleService.consoleLogFile(jobIdentifier);\n        boolean updated = consoleService.updateConsoleLog(consoleLogFile, inputStream);\n        if (updated) {\n            consoleActivityMonitor.consoleUpdatedFor(jobIdentifier);\n            return FileModelAndView.fileAppended(consoleLogFile.getPath());\n        } else {\n            return FileModelAndView.errorSavingFile(consoleLogFile.getPath());\n        }\n    }\n\n    private ModelAndView putArtifact(JobIdentifier jobIdentifier, String filePath,\n                                     InputStream inputStream) throws Exception {\n        File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n        if (artifactsService.saveOrAppendFile(artifact, inputStream)) {\n            return FileModelAndView.fileAppended(filePath);\n        } else {\n            return FileModelAndView.errorSavingFile(filePath);\n        }\n    }\n\n    private ModelAndView buildNotFound(String pipelineName, String counterOrLabel, String stageName,\n                                       String stageCounter,\n                                       String buildName) {\n        return ResponseCodeView.create(SC_NOT_FOUND, String.format(\"Job %s/%s/%s/%s/%s not found.\", pipelineName,\n                counterOrLabel, stageName, stageCounter, buildName));\n    }\n\n    private ModelAndView logsNotFound(JobIdentifier identifier) {\n        String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n        return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n    }\n\n    private boolean isValidStageCounter(String stageCounter) {\n        if (StringUtils.isEmpty(stageCounter) || StageIdentifier.LATEST.equalsIgnoreCase(stageCounter)) {\n            return true;\n        }\n\n        try {\n            int value = Integer.parseInt(stageCounter);\n            return value > 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n", "/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.server.controller;\n\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.server.cache.ZipArtifactCache;\nimport com.thoughtworks.go.server.dao.JobInstanceDao;\nimport com.thoughtworks.go.server.service.ArtifactsService;\nimport com.thoughtworks.go.server.service.ConsoleActivityMonitor;\nimport com.thoughtworks.go.server.service.ConsoleService;\nimport com.thoughtworks.go.server.service.RestfulService;\nimport com.thoughtworks.go.server.web.ArtifactFolderViewFactory;\nimport com.thoughtworks.go.server.web.ResponseCodeView;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.mock.web.MockHttpServletRequest;\nimport org.springframework.mock.web.MockMultipartFile;\nimport org.springframework.mock.web.MockMultipartHttpServletRequest;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.InputStream;\n\nimport static com.thoughtworks.go.util.GoConstants.*;\nimport static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport static org.hamcrest.Matchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.*;\n\npublic class ArtifactsControllerTest {\n\n    private ArtifactsController artifactsController;\n\n    private MockHttpServletRequest request;\n    private ConsoleActivityMonitor consoleActivityMonitor;\n    private RestfulService restfulService;\n    private ArtifactsService artifactService;\n    private ConsoleService consoleService;\n    private SystemEnvironment systemEnvironment;\n    private JobInstanceDao jobInstanceDao;\n\n    @BeforeEach\n    public void setUp() {\n        consoleActivityMonitor = mock(ConsoleActivityMonitor.class);\n\n        restfulService = mock(RestfulService.class);\n        artifactService = mock(ArtifactsService.class);\n        consoleService = mock(ConsoleService.class);\n        jobInstanceDao = mock(JobInstanceDao.class);\n        systemEnvironment = mock(SystemEnvironment.class);\n        artifactsController = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment);\n\n        request = new MockHttpServletRequest();\n    }\n\n    @Test\n    public void shouldUpdateLastConsoleActivityOnConsoleLogPut() throws Exception {\n        String content = \"Testing:\";\n        request.setContent(content.getBytes());\n        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);\n        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l)).thenReturn(jobIdentifier);\n        String path = \"cruise-output/console.log\";\n        File artifactFile = new File(\"junk\");\n        when(consoleService.consoleLogFile(jobIdentifier)).thenReturn(artifactFile);\n        when(consoleService.updateConsoleLog(eq(artifactFile), any(InputStream.class))).thenReturn(true);\n        assertThat(((ResponseCodeView) artifactsController.putArtifact(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l, path, \"agent-id\", request).getView()).getStatusCode(), is(HttpServletResponse.SC_OK));\n        verify(consoleActivityMonitor).consoleUpdatedFor(jobIdentifier);\n    }\n\n    @Test\n    public void testConsoleOutShouldReturnErrorWhenJobHasBeenCompletedAndLogsNotFound() throws Exception {\n        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);\n        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\")).thenReturn(jobIdentifier);\n\n        when(jobInstanceDao.isJobCompleted(jobIdentifier)).thenReturn(true);\n        when(consoleService.doesLogExist(jobIdentifier)).thenReturn(false);\n\n        ModelAndView view = artifactsController.consoleout(\"pipeline\", \"10\", \"stage\", \"build\", \"2\", 1L);\n\n        assertThat(view.getView().getContentType(), is(RESPONSE_CHARSET));\n        assertThat(view.getView(), is(instanceOf((ResponseCodeView.class))));\n        assertThat(((ResponseCodeView) view.getView()).getContent(), containsString(\"Console log for Build [pipeline/10/stage/2/build/103] is unavailable as it may have been purged by Go or deleted externally\"));\n    }\n\n    @Test\n    public void shouldReturnHttpErrorCodeWhenChecksumFileSaveFails() throws Exception {\n        File artifactFile = new File(\"junk\");\n        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline-1\", 1, \"1\", \"stage-1\", \"2\", \"job-1\", 122l);\n        when(restfulService.findJob(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122l)).thenReturn(jobIdentifier);\n        when(artifactService.findArtifact(any(JobIdentifier.class), eq(\"some-path\"))).thenReturn(artifactFile);\n        when(artifactService.saveFile(any(File.class), any(InputStream.class), eq(false), eq(1))).thenReturn(true);\n        when(artifactService.saveOrAppendFile(any(File.class), any(InputStream.class))).thenReturn(false);\n\n        MockMultipartHttpServletRequest mockMultipartHttpServletRequest = new MockMultipartHttpServletRequest();\n        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(REGULAR_MULTIPART_FILENAME, \"content\".getBytes()));\n        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(CHECKSUM_MULTIPART_FILENAME, \"checksum-content\".getBytes()));\n\n        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122L, \"some-path\", 1, mockMultipartHttpServletRequest);\n\n\n        ResponseCodeView view = (ResponseCodeView) modelAndView.getView();\n        assertThat(view.getStatusCode(), is(SC_INTERNAL_SERVER_ERROR));\n        assertThat(view.getContent(), is(\"Error saving checksum file for the artifact at path 'some-path'\"));\n    }\n\n    @Test\n    void shouldFailToPostAndPutWhenStageCounterIsNotAPositiveInteger() throws Exception {\n        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", 1, null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n\n        modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", 1, null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n\n        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", \"1\", null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n\n        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", \"1\", null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n    }\n\n    @Test\n    public void shouldFunnelAll_GET_calls() throws Exception {\n        final ModelAndView returnVal = new ModelAndView();\n        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {\n            @Override\n            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,\n                                     String buildName, String sha, String serverAlias) throws Exception {\n                return returnVal;\n            }\n        };\n\n        assertThat(controller.getArtifactAsHtml(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\", null), sameInstance(returnVal));\n        assertThat(controller.getArtifactAsZip(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));\n        assertThat(controller.getArtifactAsJson(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));\n    }\n\n    @Test\n    public void shouldReturnBadRequestIfRequiredHeadersAreMissingOnACreateArtifactRequest() throws Exception {\n        MultipartHttpServletRequest multipartHttpServletRequest = new MockMultipartHttpServletRequest();\n\n        when(systemEnvironment.isApiSafeModeEnabled()).thenReturn(true);\n        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline\", \"invalid-label\", \"stage\", \"stage-counter\", \"job-name\", 3L, \"file-path\", 3, multipartHttpServletRequest);\n        ResponseCodeView codeView = (ResponseCodeView) modelAndView.getView();\n\n        assertThat(codeView.getStatusCode(), is(HttpServletResponse.SC_BAD_REQUEST));\n        assertThat(codeView.getContent(), is(\"Missing required header 'Confirm'\"));\n\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.server.controller;\n\nimport com.thoughtworks.go.domain.ConsoleConsumer;\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.domain.StageIdentifier;\nimport com.thoughtworks.go.domain.exception.IllegalArtifactLocationException;\nimport com.thoughtworks.go.server.cache.ZipArtifactCache;\nimport com.thoughtworks.go.server.dao.JobInstanceDao;\nimport com.thoughtworks.go.server.security.HeaderConstraint;\nimport com.thoughtworks.go.server.service.ArtifactsService;\nimport com.thoughtworks.go.server.service.ConsoleActivityMonitor;\nimport com.thoughtworks.go.server.service.ConsoleService;\nimport com.thoughtworks.go.server.service.RestfulService;\nimport com.thoughtworks.go.server.util.ErrorHandler;\nimport com.thoughtworks.go.server.view.artifacts.ArtifactsView;\nimport com.thoughtworks.go.server.view.artifacts.LocalArtifactsView;\nimport com.thoughtworks.go.server.web.ArtifactFolderViewFactory;\nimport com.thoughtworks.go.server.web.FileModelAndView;\nimport com.thoughtworks.go.server.web.ResponseCodeView;\nimport com.thoughtworks.go.util.ArtifactLogUtil;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.thoughtworks.go.server.web.ZipArtifactFolderViewFactory.zipViewFactory;\nimport static com.thoughtworks.go.util.ArtifactLogUtil.isConsoleOutput;\nimport static com.thoughtworks.go.util.GoConstants.*;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n\n@Controller\npublic class ArtifactsController {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ArtifactsController.class);\n\n    private final JobInstanceDao jobInstanceDao;\n    private final ConsoleActivityMonitor consoleActivityMonitor;\n    private final ArtifactFolderViewFactory folderViewFactory;\n    private final ArtifactFolderViewFactory jsonViewFactory;\n    private final ArtifactFolderViewFactory zipViewFactory;\n    private final Charset consoleLogCharset;\n    private ArtifactsService artifactsService;\n    private RestfulService restfulService;\n    private ConsoleService consoleService;\n    private HeaderConstraint headerConstraint;\n\n    @Autowired\n    ArtifactsController(ArtifactsService artifactsService, RestfulService restfulService, ZipArtifactCache zipArtifactCache, JobInstanceDao jobInstanceDao,\n                        ConsoleActivityMonitor consoleActivityMonitor, ConsoleService consoleService, SystemEnvironment systemEnvironment) {\n        this.artifactsService = artifactsService;\n        this.restfulService = restfulService;\n        this.jobInstanceDao = jobInstanceDao;\n        this.consoleActivityMonitor = consoleActivityMonitor;\n        this.consoleService = consoleService;\n\n        this.folderViewFactory = FileModelAndView.htmlViewFactory();\n        this.jsonViewFactory = FileModelAndView.jsonViewfactory();\n        this.zipViewFactory = zipViewFactory(zipArtifactCache);\n        this.headerConstraint = new HeaderConstraint(systemEnvironment);\n        this.consoleLogCharset = systemEnvironment.consoleLogCharsetAsCharset();\n    }\n\n\n    /* RESTful URLs */\n    @RequestMapping(value = \"/repository/restful/artifact/GET/html\", method = RequestMethod.GET)\n    public ModelAndView getArtifactAsHtml(@RequestParam(\"pipelineName\") String pipelineName,\n                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                          @RequestParam(\"stageName\") String stageName,\n                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                          @RequestParam(\"buildName\") String buildName,\n                                          @RequestParam(\"filePath\") String filePath,\n                                          @RequestParam(value = \"sha1\", required = false) String sha,\n                                          @RequestParam(value = \"serverAlias\", required = false) String serverAlias) throws Exception {\n        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/GET/json\", method = RequestMethod.GET)\n    public ModelAndView getArtifactAsJson(@RequestParam(\"pipelineName\") String pipelineName,\n                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                          @RequestParam(\"stageName\") String stageName,\n                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                          @RequestParam(\"buildName\") String buildName,\n                                          @RequestParam(\"filePath\") String filePath,\n                                          @RequestParam(value = \"sha1\", required = false) String sha\n    ) throws Exception {\n        return getArtifact(filePath, jsonViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/GET/zip\", method = RequestMethod.GET)\n    public ModelAndView getArtifactAsZip(@RequestParam(\"pipelineName\") String pipelineName,\n                                         @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                         @RequestParam(\"stageName\") String stageName,\n                                         @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                         @RequestParam(\"buildName\") String buildName,\n                                         @RequestParam(\"filePath\") String filePath,\n                                         @RequestParam(value = \"sha1\", required = false) String sha\n    ) throws Exception {\n        if (filePath.equals(\".zip\")) {\n            filePath = \"./.zip\";\n        }\n        return getArtifact(filePath, zipViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/GET/*\", method = RequestMethod.GET)\n    public void fetch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        request.getRequestDispatcher(\"/repository/restful/artifact/GET/html\").forward(request, response);\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/POST/*\", method = RequestMethod.POST)\n    public ModelAndView postArtifact(@RequestParam(\"pipelineName\") String pipelineName,\n                                     @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                     @RequestParam(\"stageName\") String stageName,\n                                     @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                     @RequestParam(\"buildName\") String buildName,\n                                     @RequestParam(value = \"buildId\", required = false) Long buildId,\n                                     @RequestParam(\"filePath\") String filePath,\n                                     @RequestParam(value = \"attempt\", required = false) Integer attempt,\n                                     MultipartHttpServletRequest request) throws Exception {\n        JobIdentifier jobIdentifier;\n        if (!headerConstraint.isSatisfied(request)) {\n            return ResponseCodeView.create(HttpServletResponse.SC_BAD_REQUEST, \"Missing required header 'Confirm'\");\n        }\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter,\n                    buildName);\n        }\n\n        int convertedAttempt = attempt == null ? 1 : attempt;\n\n        try {\n            File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n            if (artifact.exists() && artifact.isFile()) {\n                return FileModelAndView.fileAlreadyExists(filePath);\n            }\n\n            MultipartFile multipartFile = multipartFile(request);\n            if (multipartFile == null) {\n                return FileModelAndView.invalidUploadRequest();\n            }\n\n            boolean success = saveFile(convertedAttempt, artifact, multipartFile, shouldUnzipStream(multipartFile));\n\n            if (!success) {\n                return FileModelAndView.errorSavingFile(filePath);\n            }\n\n            success = updateChecksumFile(request, jobIdentifier, filePath);\n\n            if (!success) {\n                return FileModelAndView.errorSavingChecksumFile(filePath);\n            }\n\n            return FileModelAndView.fileCreated(filePath);\n\n        } catch (IllegalArtifactLocationException e) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n    }\n\n    private boolean updateChecksumFile(MultipartHttpServletRequest request, JobIdentifier jobIdentifier, String filePath) throws IOException, IllegalArtifactLocationException {\n        MultipartFile checksumMultipartFile = getChecksumFile(request);\n        if (checksumMultipartFile != null) {\n            String checksumFilePath = String.format(\"%s/%s/%s\", artifactsService.findArtifactRoot(jobIdentifier), ArtifactLogUtil.CRUISE_OUTPUT_FOLDER, ArtifactLogUtil.MD5_CHECKSUM_FILENAME);\n            File checksumFile = artifactsService.getArtifactLocation(checksumFilePath);\n            synchronized (checksumFilePath.intern()) {\n                return artifactsService.saveOrAppendFile(checksumFile, checksumMultipartFile.getInputStream());\n            }\n        } else {\n            LOGGER.warn(\"[Artifacts Upload] Checksum file not uploaded for artifact at path '{}'\", filePath);\n        }\n        return true;\n    }\n\n    private boolean saveFile(int convertedAttempt, File artifact, MultipartFile multipartFile, boolean shouldUnzip) throws IOException {\n        try (InputStream inputStream = multipartFile.getInputStream()) {\n            return artifactsService.saveFile(artifact, inputStream, shouldUnzip, convertedAttempt);\n        }\n    }\n\n    @RequestMapping(value = \"/repository/restful/artifact/PUT/*\", method = RequestMethod.PUT)\n    public ModelAndView putArtifact(@RequestParam(\"pipelineName\") String pipelineName,\n                                    @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                    @RequestParam(\"stageName\") String stageName,\n                                    @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                    @RequestParam(\"buildName\") String buildName,\n                                    @RequestParam(value = \"buildId\", required = false) Long buildId,\n                                    @RequestParam(\"filePath\") String filePath,\n                                    @RequestParam(value = \"agentId\", required = false) String agentId,\n                                    HttpServletRequest request\n    ) throws Exception {\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        JobIdentifier jobIdentifier;\n        try {\n            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        if (isConsoleOutput(filePath)) {\n            return putConsoleOutput(jobIdentifier, request.getInputStream());\n        } else {\n            return putArtifact(jobIdentifier, filePath, request.getInputStream());\n        }\n    }\n\n    /* Other URLs */\n\n    @RequestMapping(value = \"/**/consoleout.json\", method = RequestMethod.GET)\n    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,\n                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,\n                                   @RequestParam(\"stageName\") String stageName,\n                                   @RequestParam(\"buildName\") String buildName,\n                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,\n                                   @RequestParam(value = \"startLineNumber\", required = false) Long start\n    ) {\n        start = start == null ? 0L : start;\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n\n        try {\n            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {\n                return logsNotFound(identifier);\n            }\n            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);\n            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);\n        }\n    }\n\n    @ErrorHandler\n    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {\n        LOGGER.error(\"Error loading artifacts: \", e);\n        Map model = new HashMap();\n        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");\n        return new ModelAndView(\"exceptions_page\", model);\n    }\n\n    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {\n        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n\n        if (!isValidStageCounter(stageCounter)) {\n            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        }\n\n        long before = System.currentTimeMillis();\n        ArtifactsView view;\n        //Work out the job that we are trying to retrieve\n        JobIdentifier translatedId;\n        try {\n            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        } catch (Exception e) {\n            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);\n        }\n\n        if (filePath.contains(\"..\")) {\n            return FileModelAndView.forbiddenUrl(filePath);\n        }\n\n        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);\n\n        ModelAndView createdView = view.createView(filePath, sha);\n        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);\n        return createdView;\n    }\n\n    private boolean shouldUnzipStream(MultipartFile multipartFile) {\n        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);\n    }\n\n    private MultipartFile multipartFile(MultipartHttpServletRequest request) {\n        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);\n        if (multipartFile == null) {\n            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);\n        }\n        return multipartFile;\n    }\n\n    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {\n        return request.getFile(CHECKSUM_MULTIPART_FILENAME);\n    }\n\n    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {\n        File consoleLogFile = consoleService.consoleLogFile(jobIdentifier);\n        boolean updated = consoleService.updateConsoleLog(consoleLogFile, inputStream);\n        if (updated) {\n            consoleActivityMonitor.consoleUpdatedFor(jobIdentifier);\n            return FileModelAndView.fileAppended(consoleLogFile.getPath());\n        } else {\n            return FileModelAndView.errorSavingFile(consoleLogFile.getPath());\n        }\n    }\n\n    private ModelAndView putArtifact(JobIdentifier jobIdentifier, String filePath,\n                                     InputStream inputStream) throws Exception {\n        File artifact = artifactsService.findArtifact(jobIdentifier, filePath);\n        if (artifactsService.saveOrAppendFile(artifact, inputStream)) {\n            return FileModelAndView.fileAppended(filePath);\n        } else {\n            return FileModelAndView.errorSavingFile(filePath);\n        }\n    }\n\n    private ModelAndView buildNotFound(String pipelineName, String counterOrLabel, String stageName,\n                                       String stageCounter,\n                                       String buildName) {\n        return ResponseCodeView.create(SC_NOT_FOUND, String.format(\"Job %s/%s/%s/%s/%s not found.\", pipelineName,\n                counterOrLabel, stageName, stageCounter, buildName));\n    }\n\n    private ModelAndView logsNotFound(JobIdentifier identifier) {\n        String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());\n        return ResponseCodeView.create(SC_NOT_FOUND, notFound);\n    }\n\n    private boolean isValidStageCounter(String stageCounter) {\n        if (StringUtils.isEmpty(stageCounter) || StageIdentifier.LATEST.equalsIgnoreCase(stageCounter)) {\n            return true;\n        }\n\n        try {\n            int value = Integer.parseInt(stageCounter);\n            return value > 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n", "/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.server.controller;\n\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.server.cache.ZipArtifactCache;\nimport com.thoughtworks.go.server.dao.JobInstanceDao;\nimport com.thoughtworks.go.server.service.ArtifactsService;\nimport com.thoughtworks.go.server.service.ConsoleActivityMonitor;\nimport com.thoughtworks.go.server.service.ConsoleService;\nimport com.thoughtworks.go.server.service.RestfulService;\nimport com.thoughtworks.go.server.web.ArtifactFolderViewFactory;\nimport com.thoughtworks.go.server.web.ResponseCodeView;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.mock.web.MockHttpServletRequest;\nimport org.springframework.mock.web.MockMultipartFile;\nimport org.springframework.mock.web.MockMultipartHttpServletRequest;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.InputStream;\n\nimport static com.thoughtworks.go.util.GoConstants.*;\nimport static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport static org.hamcrest.Matchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.*;\n\npublic class ArtifactsControllerTest {\n\n    private ArtifactsController artifactsController;\n\n    private MockHttpServletRequest request;\n    private ConsoleActivityMonitor consoleActivityMonitor;\n    private RestfulService restfulService;\n    private ArtifactsService artifactService;\n    private ConsoleService consoleService;\n    private SystemEnvironment systemEnvironment;\n    private JobInstanceDao jobInstanceDao;\n\n    @BeforeEach\n    public void setUp() {\n        consoleActivityMonitor = mock(ConsoleActivityMonitor.class);\n\n        restfulService = mock(RestfulService.class);\n        artifactService = mock(ArtifactsService.class);\n        consoleService = mock(ConsoleService.class);\n        jobInstanceDao = mock(JobInstanceDao.class);\n        systemEnvironment = mock(SystemEnvironment.class);\n        artifactsController = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment);\n\n        request = new MockHttpServletRequest();\n    }\n\n    @Test\n    public void shouldUpdateLastConsoleActivityOnConsoleLogPut() throws Exception {\n        String content = \"Testing:\";\n        request.setContent(content.getBytes());\n        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);\n        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l)).thenReturn(jobIdentifier);\n        String path = \"cruise-output/console.log\";\n        File artifactFile = new File(\"junk\");\n        when(consoleService.consoleLogFile(jobIdentifier)).thenReturn(artifactFile);\n        when(consoleService.updateConsoleLog(eq(artifactFile), any(InputStream.class))).thenReturn(true);\n        assertThat(((ResponseCodeView) artifactsController.putArtifact(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l, path, \"agent-id\", request).getView()).getStatusCode(), is(HttpServletResponse.SC_OK));\n        verify(consoleActivityMonitor).consoleUpdatedFor(jobIdentifier);\n    }\n\n    @Test\n    public void testConsoleOutShouldReturnErrorWhenJobHasBeenCompletedAndLogsNotFound() throws Exception {\n        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);\n        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\")).thenReturn(jobIdentifier);\n\n        when(jobInstanceDao.isJobCompleted(jobIdentifier)).thenReturn(true);\n        when(consoleService.doesLogExist(jobIdentifier)).thenReturn(false);\n\n        ModelAndView view = artifactsController.consoleout(\"pipeline\", \"10\", \"stage\", \"build\", \"2\", 1L);\n\n        assertThat(view.getView().getContentType(), is(RESPONSE_CHARSET));\n        assertThat(view.getView(), is(instanceOf((ResponseCodeView.class))));\n        assertThat(((ResponseCodeView) view.getView()).getContent(), containsString(\"Console log for Build [pipeline/10/stage/2/build/103] is unavailable as it may have been purged by Go or deleted externally\"));\n    }\n\n    @Test\n    public void shouldReturnHttpErrorCodeWhenChecksumFileSaveFails() throws Exception {\n        File artifactFile = new File(\"junk\");\n        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline-1\", 1, \"1\", \"stage-1\", \"2\", \"job-1\", 122l);\n        when(restfulService.findJob(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122l)).thenReturn(jobIdentifier);\n        when(artifactService.findArtifact(any(JobIdentifier.class), eq(\"some-path\"))).thenReturn(artifactFile);\n        when(artifactService.saveFile(any(File.class), any(InputStream.class), eq(false), eq(1))).thenReturn(true);\n        when(artifactService.saveOrAppendFile(any(File.class), any(InputStream.class))).thenReturn(false);\n\n        MockMultipartHttpServletRequest mockMultipartHttpServletRequest = new MockMultipartHttpServletRequest();\n        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(REGULAR_MULTIPART_FILENAME, \"content\".getBytes()));\n        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(CHECKSUM_MULTIPART_FILENAME, \"checksum-content\".getBytes()));\n\n        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122L, \"some-path\", 1, mockMultipartHttpServletRequest);\n\n\n        ResponseCodeView view = (ResponseCodeView) modelAndView.getView();\n        assertThat(view.getStatusCode(), is(SC_INTERNAL_SERVER_ERROR));\n        assertThat(view.getContent(), is(\"Error saving checksum file for the artifact at path 'some-path'\"));\n    }\n\n    @Test\n    void shouldFailToPostAndPutWhenStageCounterIsNotAPositiveInteger() throws Exception {\n        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", 1, null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n\n        modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", 1, null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n\n        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", \"1\", null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n\n        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", \"1\", null);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n    }\n\n    @Test\n    void shouldFailToGetConsoleOutWhenStageCounterIsNotAPositiveInteger() throws Exception {\n        ModelAndView modelAndView = artifactsController.consoleout(\"pipeline-1\", \"1\", \"stage-1\", \"job-1\", \"NOT_AN_INTEGER\", 122L);\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n    }\n\n    @Test\n    void shouldFailToGetArtifactWhenStageCounterIsNotAPositiveInteger() throws Exception {\n        ModelAndView modelAndView = artifactsController.getArtifactAsHtml(\"pipeline-1\", \"1\", \"stage-1\",  \"NOT_AN_INTEGER\", \"job-1\", \"some-path\", \"sha1\", \"alias\");\n        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));\n    }\n\n    @Test\n    public void shouldFunnelAll_GET_calls() throws Exception {\n        final ModelAndView returnVal = new ModelAndView();\n        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {\n            @Override\n            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,\n                                     String buildName, String sha, String serverAlias) throws Exception {\n                return returnVal;\n            }\n        };\n\n        assertThat(controller.getArtifactAsHtml(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\", null), sameInstance(returnVal));\n        assertThat(controller.getArtifactAsZip(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));\n        assertThat(controller.getArtifactAsJson(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));\n    }\n\n    @Test\n    public void shouldReturnBadRequestIfRequiredHeadersAreMissingOnACreateArtifactRequest() throws Exception {\n        MultipartHttpServletRequest multipartHttpServletRequest = new MockMultipartHttpServletRequest();\n\n        when(systemEnvironment.isApiSafeModeEnabled()).thenReturn(true);\n        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline\", \"invalid-label\", \"stage\", \"stage-counter\", \"job-name\", 3L, \"file-path\", 3, multipartHttpServletRequest);\n        ResponseCodeView codeView = (ResponseCodeView) modelAndView.getView();\n\n        assertThat(codeView.getStatusCode(), is(HttpServletResponse.SC_BAD_REQUEST));\n        assertThat(codeView.getContent(), is(\"Missing required header 'Confirm'\"));\n\n    }\n}\n"], "filenames": ["server/src/main/java/com/thoughtworks/go/server/controller/ArtifactsController.java", "server/src/test-fast/java/com/thoughtworks/go/server/controller/ArtifactsControllerTest.java"], "buggy_code_start_loc": [261, 139], "buggy_code_end_loc": [283, 139], "fixing_code_start_loc": [262, 140], "fixing_code_end_loc": [293, 152], "type": "CWE-22", "message": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename.", "other": {"cve": {"id": "CVE-2021-43289", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-14T13:15:11.500", "lastModified": "2022-04-26T17:01:32.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. An attacker who has compromised a GoCD agent can upload a malicious file into an arbitrary directory of a GoCD server, but does not control the filename."}, {"lang": "es", "value": "Se ha detectado un problema en ThoughtWorks GoCD versiones anteriores a 21.3.0. Un atacante que haya comprometido un agente GoCD puede cargar un archivo malicioso en un directorio arbitrario de un servidor GoCD, pero no controla el nombre del archivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thoughtworks:gocd:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.3.0", "matchCriteriaId": "96C28DAA-9A8B-46E3-9443-656B378A26D8"}]}]}], "references": [{"url": "https://blog.sonarsource.com/gocd-vulnerability-chain", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/gocd/gocd/commit/4c4bb4780eb0d3fc4cacfc4cfcc0b07e2eaf0595", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gocd/gocd/commit/c22e0428164af25d3e91baabd3f538a41cadc82f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.gocd.org/releases/#21-3-0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gocd/gocd/commit/4c4bb4780eb0d3fc4cacfc4cfcc0b07e2eaf0595"}}