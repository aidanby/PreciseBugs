{"buggy_code": ["# Configuration\n\nIn order to simplify the setup of the library, we provide the class `Lcobucci\\JWT\\Configuration`.\n\nIt's meant for:\n\n* Configuring the default algorithm (signer) and key(s) to be used\n* Configuring the default set of validation constraints\n* Providing custom implementation for the [extension points](extending-the-library.md)\n* Retrieving components (encoder, decoder, parser, validator, and builder)\n\n## Usage\n\nIn order to use it, you must:\n\n1. Initialise the configuration object\n1. Customise the configuration object\n1. Retrieve components\n\n### Configuration initialisation\n\nThe `Lcobucci\\JWT\\Signer\\Key\\InMemory` object is used for symmetric/asymmetric signature.\n\nTo initialise it, you can pass the key content as a plain text:\n\n```php\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$key = InMemory::plainText('my-key-as-plaintext');\n```\n\nProvide a base64 encoded string:\n\n```php\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$key = InMemory::base64Encoded('YSB2ZXJ5IGxvbmcgYSB2ZXJ5IHVsdHJhIHNlY3VyZSBrZXkgZm9yIG15IGFtYXppbmcgdG9rZW5z');\n```\n\nOr provide a file path:\n\n```php\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\nuse Lcobucci\\JWT\\Signer\\Key\\LocalFileReference;\n\n$key = InMemory::file(__DIR__ . '/path-to-my-key-stored-in-a-file.pem'); // this reads the file and keeps its contents in memory\n$key = LocalFileReference::file(__DIR__ . '/path-to-my-key-stored-in-a-file.pem'); // this just keeps a reference to file\n```\n\n#### For symmetric algorithms\n\nSymmetric algorithms use the same key for both signature creation and verification.\nThis means that it's really important that your key **remains secret**.\n\n!!! Tip\n    It is recommended that you use a key with lots of entropy, preferably generated using a cryptographically secure pseudo-random number generator (CSPRNG).\n    You can use the [CryptoKey](https://github.com/AndrewCarterUK/CryptoKey) tool to do this for you.\n\n```php\nuse Lcobucci\\JWT\\Configuration;\nuse Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$configuration = Configuration::forSymmetricSigner(\n    // You may use any HMAC variations (256, 384, and 512)\n    new Sha256(),\n    // replace the value below with a key of your own!\n    InMemory::base64Encoded('mBC5v1sOKVvbdEitdSBenu59nfNfhwkedkJVNabosTw=')\n    // You may also override the JOSE encoder/decoder if needed by providing extra arguments here\n);\n```\n\n#### For asymmetric algorithms\n\nAsymmetric algorithms use a **private key** for signature creation and a **public key** for verification.\nThis means that it's fine to distribute your **public key**. However, the **private key** should **remain secret**.\n\n```php\nuse Lcobucci\\JWT\\Configuration;\nuse Lcobucci\\JWT\\Signer;\nuse Lcobucci\\JWT\\Signer\\Key\\LocalFileReference;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$configuration = Configuration::forAsymmetricSigner(\n    // You may use RSA or ECDSA and all their variations (256, 384, and 512)\n    new Signer\\Rsa\\Sha256(),\n    LocalFileReference::file(__DIR__ . '/my-private-key.pem'),\n    InMemory::base64Encoded('mBC5v1sOKVvbdEitdSBenu59nfNfhwkedkJVNabosTw=')\n    // You may also override the JOSE encoder/decoder if needed by providing extra arguments here\n);\n```\n\n!!! Important\n    The implementation of ECDSA algorithms have a constructor dependency.\n    Use the `create()` named constructor to avoid having to handle it (e.g.: `Lcobucci\\JWT\\Signer\\Ecdsa\\Sha256::create()`).\n\n#### For no algorithm\n\n!!! Warning\n    This configuration type is **NOT** recommended for production environments.\n    It's only provided to allow people to have a simpler and faster setup for tests, avoiding any kind of signature creation/verification.\n\n```php\nuse Lcobucci\\JWT\\Configuration;\n\n$configuration = Configuration::forUnsecuredSigner(\n    // You may also override the JOSE encoder/decoder if needed by providing extra arguments here\n);\n```\n\n### Customisation\n\nBy using the setters of the `Lcobucci\\JWT\\Configuration` you may customise the setup of this library.\n\n!!! Important\n    If you want to use a customised configuration, please make sure you call the setters before of invoking any getter.\n    Otherwise, the default implementations will be used.\n\nThese are the available setters:\n\n* `Lcobucci\\JWT\\Configuration#setBuilderFactory()`: configures how the token builder should be created\n* `Lcobucci\\JWT\\Configuration#setParser()`: configures a custom token parser\n* `Lcobucci\\JWT\\Configuration#setValidator()`: configures a custom validator\n* `Lcobucci\\JWT\\Configuration#setValidationConstraints()`: configures the default set of validation constraints\n\n### Retrieve components\n\nOnce you've made all the necessary configuration you can pass the configuration object around your code and use the getters to retrieve the components:\n\nThese are the available getters:\n\n* `Lcobucci\\JWT\\Configuration#builder()`: retrieves the token builder (always creating a new instance)\n* `Lcobucci\\JWT\\Configuration#parser()`: retrieves the token parser\n* `Lcobucci\\JWT\\Configuration#signer()`: retrieves the signer\n* `Lcobucci\\JWT\\Configuration#signingKey()`: retrieves the key for signature creation\n* `Lcobucci\\JWT\\Configuration#verificationKey()`: retrieves the key for signature verification\n* `Lcobucci\\JWT\\Configuration#validator()`: retrieves the token validator\n* `Lcobucci\\JWT\\Configuration#validationConstraints()`: retrieves the default set of validation constraints\n", "# Upgrading steps\n\nHere we'll keep a list of all steps you need to take to make sure your code is compatible with newer versions.\n\n## v3.x to v4.x\n\nThe `v4.0.0` aggregates about 5 years of work and contains **several BC-breaks**.\nWe're building on the version `v3.4.0` a forward compatibility layer to help users to migrate to `v4.0.0`.\n\nTo help on the migration process, all deprecated components are being marked with `@deprecated` and deprecated behaviour will trigger a `E_USER_DEPRECATED` error.\nHowever, you can also find here the instructions on how to make your code compatible with both versions.\n\n### General migration strategy\n\nUpdate your existing software to the latest 3.4.x version using composer:\n\n```sh\ncomposer require lcobucci/jwt ^3.4\n```\n\nThen run your tests and fix all deprecation notices.\nAlso change all calls to deprecated methods, even if they are not triggering any notices.\nTools like [`phpstan/phpstan-deprecation-rules`](https://github.com/phpstan/phpstan-deprecation-rules) can help finding them.\n\nNote that PHPUnit tests will only fail if you have the `E_USER_DEPRECATED` error level activated - it is a good practice to run tests using `E_ALL`.\nData providers that trigger deprecation messages will not fail tests at all, only print the message to the console.\nMake sure you do not see any of them before you continue.\n\nNow you can upgrade to the latest 4.x version:\n\n```sh\ncomposer require lcobucci/jwt ^4.0\n```\n\nRemember that some deprecation messages from the 3.4 version may have notified you that things still are different in 4.0, so you may find you need to adapt your own code once more at this stage.\n\nWhile you are at it, consider using the new configuration object.\nThe details are listed below.\n\n### Inject the configuration object instead of builder/parser/key\n\nThis object serves as a small service locator that centralises the JWT-related dependencies.\nThe main goal is to simplify the injection of our components into downstream code.\n\nThis step is quite important to at least have a single way to initialise the JWT components, even if the configuration object is thrown away.\n\nCheck an example of how to migrate the injection of builder+signer+key to configuration object below: \n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n-use Lcobucci\\JWT\\Builder;\n use Lcobucci\\JWT\\Configuration;\n-use Lcobucci\\JWT\\Signer;\n-use Lcobucci\\JWT\\Signer\\Key;\n use Lcobucci\\JWT\\Token;\n \n use function bin2hex;\n use function random_bytes;\n \n final class JwtIssuer\n {\n-    private Builder $builder;\n-    private Signer $signer;\n-    private Key $key;\n- \n-    public function __construct(Builder $builder, Signer $signer, Key $key)\n-    {\n-        $this->builder = $builder;\n-        $this->signer  = $signer;\n-        $this->key     = $key;\n-    }   \n+    private Configuration $config;\n+    \n+    public function __construct(Configuration $config)\n+    {\n+        $this->config = $config;\n+    }\n    \n     public function issueToken(): Token\n     {\n-        return $this->builder\n+        return $this->config->builder()\n             ->identifiedBy(bin2hex(random_bytes(16)))\n-            ->getToken($this->signer, $this->key);\n+            ->getToken($this->config->signer(), $this->config->signingKey());\n     }\n }\n```\n\nYou can find more information on how to use the configuration object, [here](configuration.md).\n\n### Use new `Key` objects\n\n`Lcobucci\\JWT\\Signer\\Key` has been converted to an interface in `v4.0`.\nWe provide two new implementations: `Lcobucci\\JWT\\Signer\\Key\\InMemory` and `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference`.\n\n`Lcobucci\\JWT\\Signer\\Key\\InMemory` is a drop-in replacement of the behaviour for `Lcobucci\\JWT\\Signer\\Key` in `v3.x`.\nYou will need to pick the appropriated named constructor to migrate your code:\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n-use Lcobucci\\JWT\\Signer\\Key;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n-\n-use function base64_decode;\n \n // Key from plain text\n-$key = new Key('a-very-secure-key');\n+$key = InMemory::plainText('a-very-secure-key');\n \n // Key from base64 encoded string\n-$key = new Key(base64_decode('YS12ZXJ5LXNlY3VyZS1rZXk=', true));\n+$key = InMemory::base64Encoded('YS12ZXJ5LXNlY3VyZS1rZXk=');\n \n // Key from file contents\n-$key = new Key('file:///var/secrets/my-private-key.pem');\n+$key = InMemory::file('/var/secrets/my-private-key.pem');\n```\n\n### Use the new `Builder` API\n\nThere are 4 main differences on the new API:\n\n1. Token configuration methods were renamed\n1. Signature is created via `Builder#getToken()` (instead of `Builder#sign()`)\n1. `DateTimeImmutable` objects are now for the registered claims with dates\n1. Headers should be replicated manually - whenever necessary\n\nHere's the migration:\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n+use DateTimeImmutable; \n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n-\n-use function time;\n\n-$now = time();\n+$now = new DateTimeImmutable();\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->setIssuer('http://example.com', true)\n+    ->issuedBy('http://example.com')\n+    ->withHeader('iss', 'http://example.com')\n-    ->setAudience('http://example.org')\n+    ->permittedFor('http://example.org')\n-    ->setId('4f1g23a12aa')\n+    ->identifiedBy('4f1g23a12aa')\n-    ->setSubject('user123')\n+    ->relatedTo('user123')\n-    ->setIssuedAt($now)\n+    ->issuedAt($now)\n-    ->setNotBefore($now + 60)\n+    ->canOnlyBeUsedAfter($now->modify('+1 minute'))\n-    ->setExpiration($now + 3600)\n+    ->expiresAt($now->modify('+1 hour'))\n-    ->set('uid', 1)\n+    ->withClaim('uid', 1)\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n#### Support for multiple audiences\n\nEven though we didn't officially support multiple audiences, it was technically possible to achieve that by manually setting the `aud` claim to an array with multiple strings.\n\nIf you parse a token with 3.4, and read its contents with `\\Lcobucci\\JWT\\Token#getClaim()` or`\\Lcobucci\\JWT\\Token#getClaims()`, you will only get the first element of such an array back.\nIf the audience claim does only contain a string, or only contains one string in the array, nothing changes.\nPlease [upgrade to the new Token API](#use-the-new-token-api) for accessing claims in order to get the full audience array again (e.g. call `Token#claims()->get('aud')`).\n\nWhen creating a token, use the new method `Builder#permittedFor()` as detailed below.\n\n##### Multiple calls to `Builder#permittedFor()`\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->withClaim('aud', ['one', 'two', 'three'])\n+    ->permittedFor('one')\n+    ->permittedFor('two')\n+    ->permittedFor('three')\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n##### Single call to `Builder#permittedFor()` with multiple arguments\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->withClaim('aud', ['one', 'two', 'three'])\n+    ->permittedFor('one', 'two', 'three')\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n##### Single call to `Builder#permittedFor()` with argument unpacking\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->withClaim('aud', ['one', 'two', 'three'])\n+    ->permittedFor(...['one', 'two', 'three'])\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n### Replace `Token#verify()` and `Token#validate()` with Validation API\n\nThese methods were quite limited and brings multiple responsibilities to the `Token` class.\nOn `v4.0` we provide another component to validate tokens, including their signature.\n\nHere's an example of how to modify that logic (considering [constraints have been configured](configuration.md#customisation)):\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n use InvalidArgumentException;\n+use Lcobucci\\JWT\\Configuration;\n-use Lcobucci\\JWT\\Signer;\n-use Lcobucci\\JWT\\Signer\\Key;\n-use Lcobucci\\JWT\\Parser;\n-use Lcobucci\\JWT\\ValidationData;\n \n final class AuthenticateJwt\n {\n-    private Parser $parser;\n-    private Signer $signer;\n-    private Key $key;\n+    private Configuration $config;\n     \n-    public function __construct(Parser $parser, Signer $signer, Key $key)\n+    public function __construct(Configuration $config)\n     {\n-        $this->parser = $parser;\n-        $this->signer = $signer;\n-        $this->key    = $key;\n+        $this->config = $config;\n     }\n     \n     public function authenticate(string $jwt): void\n     {\n-        $token = $this->parser->parse($jwt);\n+        $token = $this->config->parser()->parse($jwt);\n         \n-        if (! $token->validate(new ValidationData()) || $token->verify($this->signer, $this->key)) {\n+        if (! $this->config->validator()->validate($token, ...$this->config->validationConstraints())) {\n             throw new InvalidArgumentException('Invalid token provided');\n         }\n     }\n }\n```\n\nCheck [here](validating-tokens.md) for more information on how to validate tokens and what are the built-in constraints.\n\n### Use the new `Token` API\n\nThere some important differences on this new API:\n\n1. We no longer use the `Lcobucci\\JWT\\Claim` objects\n1. Headers and claims are now represented as `Lcobucci\\JWT\\Token\\DataSet`\n1. Different methods should be used to retrieve a header/claim\n1. No exception is thrown when accessing missing header/claim, the default argument is always used\n1. Tokens should be explicitly casted to string via method\n\nYour code should be adapted to manipulate tokens like this:\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n // we assume here that $token is a valid parsed/created token\n \n-$token->getHeaders() \n+$token->headers()->all()\n-$token->hasHeader('typ')\n+$token->headers()->has('typ')\n-$token->getHeader('typ')\n+$token->headers()->get('typ')\n\n-$token->getClaims() \n+$token->claims()->all()\n-$token->hasClaim('iss')\n+$token->claims()->has('iss')\n-$token->getClaim('iss')\n+$token->claims()->get('iss')\n\n-echo (string) $token;\n+echo $token->toString();\n```\n", "parameters:\n    level: max\n    paths:\n        - src\n        - test\n\n    ignoreErrors:\n        - '#.*OpenSSLAsymmetricKey.*#'\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer\\Key;\n\nuse Lcobucci\\JWT\\Signer\\Key;\n\nuse function file_exists;\nuse function strpos;\nuse function substr;\n\nfinal class LocalFileReference implements Key\n{\n    private const PATH_PREFIX = 'file://';\n\n    private string $path;\n    private string $passphrase;\n\n    private function __construct(string $path, string $passphrase)\n    {\n        $this->path       = $path;\n        $this->passphrase = $passphrase;\n    }\n\n    /** @throws FileCouldNotBeRead */\n    public static function file(string $path, string $passphrase = ''): self\n    {\n        if (strpos($path, self::PATH_PREFIX) === 0) {\n            $path = substr($path, 7);\n        }\n\n        if (! file_exists($path)) {\n            throw FileCouldNotBeRead::onPath($path);\n        }\n\n        return new self($path, $passphrase);\n    }\n\n    public function contents(): string\n    {\n        return self::PATH_PREFIX . $this->path;\n    }\n\n    public function passphrase(): string\n    {\n        return $this->passphrase;\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\FunctionalTests;\n\nuse Lcobucci\\JWT\\Configuration;\nuse Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\nuse Lcobucci\\JWT\\Signer\\Hmac\\Sha512;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\nuse Lcobucci\\JWT\\Token;\nuse Lcobucci\\JWT\\Validation\\Constraint\\SignedWith;\nuse Lcobucci\\JWT\\Validation\\RequiredConstraintsViolated;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function assert;\n\n/**\n * @covers \\Lcobucci\\JWT\\Configuration\n * @covers \\Lcobucci\\JWT\\Encoding\\JoseEncoder\n * @covers \\Lcobucci\\JWT\\Encoding\\ChainedFormatter\n * @covers \\Lcobucci\\JWT\\Encoding\\MicrosecondBasedDateConversion\n * @covers \\Lcobucci\\JWT\\Encoding\\UnifyAudience\n * @covers \\Lcobucci\\JWT\\Token\\Builder\n * @covers \\Lcobucci\\JWT\\Token\\Parser\n * @covers \\Lcobucci\\JWT\\Token\\Plain\n * @covers \\Lcobucci\\JWT\\Token\\DataSet\n * @covers \\Lcobucci\\JWT\\Token\\Signature\n * @covers \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n * @covers \\Lcobucci\\JWT\\Signer\\Hmac\n * @covers \\Lcobucci\\JWT\\Signer\\Hmac\\Sha256\n * @covers \\Lcobucci\\JWT\\Signer\\Hmac\\Sha512\n * @covers \\Lcobucci\\JWT\\Validation\\Validator\n * @covers \\Lcobucci\\JWT\\Validation\\RequiredConstraintsViolated\n * @covers \\Lcobucci\\JWT\\Validation\\Constraint\\SignedWith\n */\nclass HmacTokenTest extends TestCase\n{\n    private Configuration $config;\n\n    /** @before */\n    public function createConfiguration(): void\n    {\n        $this->config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n    }\n\n    /** @test */\n    public function builderCanGenerateAToken(): Token\n    {\n        $user    = ['name' => 'testing', 'email' => 'testing@abc.com'];\n        $builder = $this->config->builder();\n\n        $token = $builder->identifiedBy('1')\n                         ->permittedFor('http://client.abc.com')\n                         ->issuedBy('http://api.abc.com')\n                         ->withClaim('user', $user)\n                         ->withHeader('jki', '1234')\n                         ->getToken($this->config->signer(), $this->config->signingKey());\n\n        self::assertEquals('1234', $token->headers()->get('jki'));\n        self::assertEquals(['http://client.abc.com'], $token->claims()->get(Token\\RegisteredClaims::AUDIENCE));\n        self::assertEquals('http://api.abc.com', $token->claims()->get(Token\\RegisteredClaims::ISSUER));\n        self::assertEquals($user, $token->claims()->get('user'));\n\n        return $token;\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function parserCanReadAToken(Token $generated): void\n    {\n        $read = $this->config->parser()->parse($generated->toString());\n        assert($read instanceof Token\\Plain);\n\n        self::assertEquals($generated, $read);\n        self::assertEquals('testing', $read->claims()->get('user')['name']);\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function signatureAssertionShouldRaiseExceptionWhenKeyIsNotRight(Token $token): void\n    {\n        $this->expectException(RequiredConstraintsViolated::class);\n        $this->expectExceptionMessage('The token violates some mandatory constraints');\n\n        $this->config->validator()->assert(\n            $token,\n            new SignedWith($this->config->signer(), InMemory::plainText('testing1'))\n        );\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function signatureAssertionShouldRaiseExceptionWhenAlgorithmIsDifferent(Token $token): void\n    {\n        $this->expectException(RequiredConstraintsViolated::class);\n        $this->expectExceptionMessage('The token violates some mandatory constraints');\n\n        $this->config->validator()->assert(\n            $token,\n            new SignedWith(new Sha512(), $this->config->verificationKey())\n        );\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function signatureValidationShouldSucceedWhenKeyIsRight(Token $token): void\n    {\n        $constraint = new SignedWith($this->config->signer(), $this->config->verificationKey());\n\n        self::assertTrue($this->config->validator()->validate($token, $constraint));\n    }\n\n    /** @test */\n    public function everythingShouldWorkWhenUsingATokenGeneratedByOtherLibs(): void\n    {\n        $data = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9.eyJoZWxsbyI6IndvcmxkIn0.Rh'\n                . '7AEgqCB7zae1PkgIlvOpeyw9Ab8NGTbeOH7heHO0o';\n\n        $token = $this->config->parser()->parse($data);\n        assert($token instanceof Token\\Plain);\n        $constraint = new SignedWith($this->config->signer(), $this->config->verificationKey());\n\n        self::assertTrue($this->config->validator()->validate($token, $constraint));\n        self::assertEquals('world', $token->claims()->get('hello'));\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer;\n\nuse Lcobucci\\JWT\\Keys;\nuse Lcobucci\\JWT\\Signer\\Ecdsa\\MultibyteStringConverter;\nuse OpenSSLAsymmetricKey;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function assert;\nuse function is_resource;\nuse function openssl_pkey_get_private;\nuse function openssl_pkey_get_public;\nuse function openssl_sign;\nuse function openssl_verify;\n\nuse const OPENSSL_ALGO_SHA256;\n\n/** @coversDefaultClass \\Lcobucci\\JWT\\Signer\\Ecdsa */\nfinal class EcdsaTest extends TestCase\n{\n    use Keys;\n\n    private MultibyteStringConverter $pointsManipulator;\n\n    /** @before */\n    public function createDependencies(): void\n    {\n        $this->pointsManipulator = new MultibyteStringConverter();\n    }\n\n    private function getSigner(): Ecdsa\n    {\n        $signer = $this->getMockForAbstractClass(Ecdsa::class, [$this->pointsManipulator]);\n\n        $signer->method('algorithm')\n               ->willReturn(OPENSSL_ALGO_SHA256);\n\n        $signer->method('algorithmId')\n               ->willReturn('ES256');\n\n        $signer->method('keyLength')\n               ->willReturn(64);\n\n        return $signer;\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\Ecdsa\\MultibyteStringConverter\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Ecdsa::__construct\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     */\n    public function signShouldReturnTheAHashBasedOnTheOpenSslSignature(): void\n    {\n        $payload = 'testing';\n\n        $signer    = $this->getSigner();\n        $signature = $signer->sign($payload, self::$ecdsaKeys['private']);\n\n        $publicKey = openssl_pkey_get_public(self::$ecdsaKeys['public1']->contents());\n        assert(is_resource($publicKey) || $publicKey instanceof OpenSSLAsymmetricKey);\n\n        self::assertSame(\n            1,\n            openssl_verify(\n                $payload,\n                $this->pointsManipulator->toAsn1($signature, $signer->keyLength()),\n                $publicKey,\n                OPENSSL_ALGO_SHA256\n            )\n        );\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\Ecdsa\\MultibyteStringConverter\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Ecdsa::__construct\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     */\n    public function verifyShouldDelegateToEcdsaSignerUsingPublicKey(): void\n    {\n        $payload    = 'testing';\n        $privateKey = openssl_pkey_get_private(self::$ecdsaKeys['private']->contents());\n        assert(is_resource($privateKey) || $privateKey instanceof OpenSSLAsymmetricKey);\n\n        $signature = '';\n        openssl_sign($payload, $signature, $privateKey, OPENSSL_ALGO_SHA256);\n\n        $signer = $this->getSigner();\n\n        self::assertTrue(\n            $signer->verify(\n                $this->pointsManipulator->fromAsn1($signature, $signer->keyLength()),\n                $payload,\n                self::$ecdsaKeys['public1']\n            )\n        );\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer\\Key;\n\nuse org\\bovigo\\vfs\\vfsStream;\nuse PHPUnit\\Framework\\TestCase;\n\n/** @coversDefaultClass \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference */\nfinal class LocalFileReferenceTest extends TestCase\n{\n    /** @before */\n    public function configureRootDir(): void\n    {\n        vfsStream::setup(\n            'root',\n            null,\n            ['test.pem' => 'testing']\n        );\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::file\n     * @covers \\Lcobucci\\JWT\\Signer\\Key\\FileCouldNotBeRead\n     */\n    public function thereShouldBeNoReferenceToAFileThatDoesNotExist(): void\n    {\n        $this->expectException(FileCouldNotBeRead::class);\n        $this->expectExceptionMessage('The path \"vfs://root/test2.pem\" does not contain a valid key file');\n\n        LocalFileReference::file(vfsStream::url('root/test2.pem'));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::file\n     * @covers ::__construct\n     * @covers ::contents\n     */\n    public function pathShouldBeNormalised(): void\n    {\n        $key = LocalFileReference::file('file://' . vfsStream::url('root/test.pem'));\n\n        self::assertSame('file://vfs://root/test.pem', $key->contents());\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::file\n     * @covers ::__construct\n     * @covers ::contents\n     * @covers ::passphrase\n     */\n    public function contentsShouldReturnOnlyTheReferenceToTheFile(): void\n    {\n        $key = LocalFileReference::file(vfsStream::url('root/test.pem'), 'test');\n\n        self::assertSame('file://vfs://root/test.pem', $key->contents());\n        self::assertSame('test', $key->passphrase());\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer;\n\nuse Lcobucci\\JWT\\Keys;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\nuse OpenSSLAsymmetricKey;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function assert;\nuse function is_resource;\nuse function openssl_pkey_get_private;\nuse function openssl_pkey_get_public;\nuse function openssl_sign;\nuse function openssl_verify;\n\nuse const OPENSSL_ALGO_SHA256;\n\n/** @coversDefaultClass \\Lcobucci\\JWT\\Signer\\Rsa */\nfinal class RsaTest extends TestCase\n{\n    use Keys;\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     */\n    public function signShouldReturnAValidOpensslSignature(): void\n    {\n        $payload = 'testing';\n\n        $signer    = $this->getSigner();\n        $signature = $signer->sign($payload, self::$rsaKeys['private']);\n\n        $publicKey = openssl_pkey_get_public(self::$rsaKeys['public']->contents());\n        assert(is_resource($publicKey) || $publicKey instanceof OpenSSLAsymmetricKey);\n\n        self::assertSame(1, openssl_verify($payload, $signature, $publicKey, OPENSSL_ALGO_SHA256));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\CannotSignPayload\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldRaiseAnExceptionWhenKeyIsInvalid(): void\n    {\n        $key = <<<KEY\n-----BEGIN RSA PRIVATE KEY-----\nMGECAQACEQC4MRKSVsq5XnRBrJoX6+rnAgMBAAECECO8SZkgw6Yg66A6SUly/3kC\nCQDtPXZtCQWJuwIJAMbBu17GDOrFAggopfhNlFcjkwIIVjb7G+U0/TECCEERyvxP\nTWdN\n-----END RSA PRIVATE KEY-----\nKEY;\n\n        $signer = $this->getSigner();\n\n        $this->expectException(CannotSignPayload::class);\n        $this->expectExceptionMessage('There was an error while creating the signature');\n\n        $signer->sign('testing', InMemory::plainText($key));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldRaiseAnExceptionWhenKeyIsNotParseable(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('It was not possible to parse your key');\n\n        $signer->sign('testing', InMemory::plainText('blablabla'));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     */\n    public function signShouldRaiseAnExceptionWhenKeyTypeIsNotRsa(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('This key is not compatible with this signer');\n\n        $signer->sign('testing', self::$ecdsaKeys['private']);\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     */\n    public function verifyShouldReturnTrueWhenSignatureIsValid(): void\n    {\n        $payload    = 'testing';\n        $privateKey = openssl_pkey_get_private(self::$rsaKeys['private']->contents());\n        assert(is_resource($privateKey) || $privateKey instanceof OpenSSLAsymmetricKey);\n\n        $signature = '';\n        openssl_sign($payload, $signature, $privateKey, OPENSSL_ALGO_SHA256);\n\n        $signer = $this->getSigner();\n\n        self::assertTrue($signer->verify($signature, $payload, self::$rsaKeys['public']));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function verifyShouldRaiseAnExceptionWhenKeyIsNotParseable(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('It was not possible to parse your key');\n\n        $signer->verify('testing', 'testing', InMemory::plainText('blablabla'));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     */\n    public function verifyShouldRaiseAnExceptionWhenKeyTypeIsNotRsa(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('It was not possible to parse your key');\n\n        $signer->verify('testing', 'testing', self::$ecdsaKeys['private']);\n    }\n\n    private function getSigner(): Rsa\n    {\n        $signer = $this->getMockForAbstractClass(Rsa::class);\n\n        $signer->method('algorithm')\n               ->willReturn(OPENSSL_ALGO_SHA256);\n\n        $signer->method('algorithmId')\n               ->willReturn('RS256');\n\n        return $signer;\n    }\n}\n"], "fixing_code": ["# Configuration\n\nIn order to simplify the setup of the library, we provide the class `Lcobucci\\JWT\\Configuration`.\n\nIt's meant for:\n\n* Configuring the default algorithm (signer) and key(s) to be used\n* Configuring the default set of validation constraints\n* Providing custom implementation for the [extension points](extending-the-library.md)\n* Retrieving components (encoder, decoder, parser, validator, and builder)\n\n## Usage\n\nIn order to use it, you must:\n\n1. Initialise the configuration object\n1. Customise the configuration object\n1. Retrieve components\n\n### Configuration initialisation\n\nThe `Lcobucci\\JWT\\Signer\\Key\\InMemory` object is used for symmetric/asymmetric signature.\n\nTo initialise it, you can pass the key content as a plain text:\n\n```php\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$key = InMemory::plainText('my-key-as-plaintext');\n```\n\nProvide a base64 encoded string:\n\n```php\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$key = InMemory::base64Encoded('YSB2ZXJ5IGxvbmcgYSB2ZXJ5IHVsdHJhIHNlY3VyZSBrZXkgZm9yIG15IGFtYXppbmcgdG9rZW5z');\n```\n\nOr provide a file path:\n\n```php\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$key = InMemory::file(__DIR__ . '/path-to-my-key-stored-in-a-file.pem'); // this reads the file and keeps its contents in memory\n```\n\n#### For symmetric algorithms\n\nSymmetric algorithms use the same key for both signature creation and verification.\nThis means that it's really important that your key **remains secret**.\n\n!!! Tip\n    It is recommended that you use a key with lots of entropy, preferably generated using a cryptographically secure pseudo-random number generator (CSPRNG).\n    You can use the [CryptoKey](https://github.com/AndrewCarterUK/CryptoKey) tool to do this for you.\n\n```php\nuse Lcobucci\\JWT\\Configuration;\nuse Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$configuration = Configuration::forSymmetricSigner(\n    // You may use any HMAC variations (256, 384, and 512)\n    new Sha256(),\n    // replace the value below with a key of your own!\n    InMemory::base64Encoded('mBC5v1sOKVvbdEitdSBenu59nfNfhwkedkJVNabosTw=')\n    // You may also override the JOSE encoder/decoder if needed by providing extra arguments here\n);\n```\n\n#### For asymmetric algorithms\n\nAsymmetric algorithms use a **private key** for signature creation and a **public key** for verification.\nThis means that it's fine to distribute your **public key**. However, the **private key** should **remain secret**.\n\n```php\nuse Lcobucci\\JWT\\Configuration;\nuse Lcobucci\\JWT\\Signer;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\n\n$configuration = Configuration::forAsymmetricSigner(\n    // You may use RSA or ECDSA and all their variations (256, 384, and 512)\n    new Signer\\Rsa\\Sha256(),\n    InMemory::file(__DIR__ . '/my-private-key.pem'),\n    InMemory::base64Encoded('mBC5v1sOKVvbdEitdSBenu59nfNfhwkedkJVNabosTw=')\n    // You may also override the JOSE encoder/decoder if needed by providing extra arguments here\n);\n```\n\n!!! Important\n    The implementation of ECDSA algorithms have a constructor dependency.\n    Use the `create()` named constructor to avoid having to handle it (e.g.: `Lcobucci\\JWT\\Signer\\Ecdsa\\Sha256::create()`).\n\n#### For no algorithm\n\n!!! Warning\n    This configuration type is **NOT** recommended for production environments.\n    It's only provided to allow people to have a simpler and faster setup for tests, avoiding any kind of signature creation/verification.\n\n```php\nuse Lcobucci\\JWT\\Configuration;\n\n$configuration = Configuration::forUnsecuredSigner(\n    // You may also override the JOSE encoder/decoder if needed by providing extra arguments here\n);\n```\n\n### Customisation\n\nBy using the setters of the `Lcobucci\\JWT\\Configuration` you may customise the setup of this library.\n\n!!! Important\n    If you want to use a customised configuration, please make sure you call the setters before of invoking any getter.\n    Otherwise, the default implementations will be used.\n\nThese are the available setters:\n\n* `Lcobucci\\JWT\\Configuration#setBuilderFactory()`: configures how the token builder should be created\n* `Lcobucci\\JWT\\Configuration#setParser()`: configures a custom token parser\n* `Lcobucci\\JWT\\Configuration#setValidator()`: configures a custom validator\n* `Lcobucci\\JWT\\Configuration#setValidationConstraints()`: configures the default set of validation constraints\n\n### Retrieve components\n\nOnce you've made all the necessary configuration you can pass the configuration object around your code and use the getters to retrieve the components:\n\nThese are the available getters:\n\n* `Lcobucci\\JWT\\Configuration#builder()`: retrieves the token builder (always creating a new instance)\n* `Lcobucci\\JWT\\Configuration#parser()`: retrieves the token parser\n* `Lcobucci\\JWT\\Configuration#signer()`: retrieves the signer\n* `Lcobucci\\JWT\\Configuration#signingKey()`: retrieves the key for signature creation\n* `Lcobucci\\JWT\\Configuration#verificationKey()`: retrieves the key for signature verification\n* `Lcobucci\\JWT\\Configuration#validator()`: retrieves the token validator\n* `Lcobucci\\JWT\\Configuration#validationConstraints()`: retrieves the default set of validation constraints\n", "# Upgrading steps\n\nHere we'll keep a list of all steps you need to take to make sure your code is compatible with newer versions.\n\n## v3.x to v4.x\n\nThe `v4.0.0` aggregates about 5 years of work and contains **several BC-breaks**.\nWe're building on the version `v3.4.0` a forward compatibility layer to help users to migrate to `v4.0.0`.\n\nTo help on the migration process, all deprecated components are being marked with `@deprecated` and deprecated behaviour will trigger a `E_USER_DEPRECATED` error.\nHowever, you can also find here the instructions on how to make your code compatible with both versions.\n\n### General migration strategy\n\nUpdate your existing software to the latest 3.4.x version using composer:\n\n```sh\ncomposer require lcobucci/jwt ^3.4\n```\n\nThen run your tests and fix all deprecation notices.\nAlso change all calls to deprecated methods, even if they are not triggering any notices.\nTools like [`phpstan/phpstan-deprecation-rules`](https://github.com/phpstan/phpstan-deprecation-rules) can help finding them.\n\nNote that PHPUnit tests will only fail if you have the `E_USER_DEPRECATED` error level activated - it is a good practice to run tests using `E_ALL`.\nData providers that trigger deprecation messages will not fail tests at all, only print the message to the console.\nMake sure you do not see any of them before you continue.\n\nNow you can upgrade to the latest 4.x version:\n\n```sh\ncomposer require lcobucci/jwt ^4.0\n```\n\nRemember that some deprecation messages from the 3.4 version may have notified you that things still are different in 4.0, so you may find you need to adapt your own code once more at this stage.\n\nWhile you are at it, consider using the new configuration object.\nThe details are listed below.\n\n### Inject the configuration object instead of builder/parser/key\n\nThis object serves as a small service locator that centralises the JWT-related dependencies.\nThe main goal is to simplify the injection of our components into downstream code.\n\nThis step is quite important to at least have a single way to initialise the JWT components, even if the configuration object is thrown away.\n\nCheck an example of how to migrate the injection of builder+signer+key to configuration object below: \n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n-use Lcobucci\\JWT\\Builder;\n use Lcobucci\\JWT\\Configuration;\n-use Lcobucci\\JWT\\Signer;\n-use Lcobucci\\JWT\\Signer\\Key;\n use Lcobucci\\JWT\\Token;\n \n use function bin2hex;\n use function random_bytes;\n \n final class JwtIssuer\n {\n-    private Builder $builder;\n-    private Signer $signer;\n-    private Key $key;\n- \n-    public function __construct(Builder $builder, Signer $signer, Key $key)\n-    {\n-        $this->builder = $builder;\n-        $this->signer  = $signer;\n-        $this->key     = $key;\n-    }   \n+    private Configuration $config;\n+    \n+    public function __construct(Configuration $config)\n+    {\n+        $this->config = $config;\n+    }\n    \n     public function issueToken(): Token\n     {\n-        return $this->builder\n+        return $this->config->builder()\n             ->identifiedBy(bin2hex(random_bytes(16)))\n-            ->getToken($this->signer, $this->key);\n+            ->getToken($this->config->signer(), $this->config->signingKey());\n     }\n }\n```\n\nYou can find more information on how to use the configuration object, [here](configuration.md).\n\n### Use new `Key` objects\n\n`Lcobucci\\JWT\\Signer\\Key` has been converted to an interface in `v4.0`.\n\nWe provide `Lcobucci\\JWT\\Signer\\Key\\InMemory`, a drop-in replacement of the behaviour for `Lcobucci\\JWT\\Signer\\Key` in `v3.x`.\nYou will need to pick the appropriated named constructor to migrate your code:\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n-use Lcobucci\\JWT\\Signer\\Key;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n-\n-use function base64_decode;\n \n // Key from plain text\n-$key = new Key('a-very-secure-key');\n+$key = InMemory::plainText('a-very-secure-key');\n \n // Key from base64 encoded string\n-$key = new Key(base64_decode('YS12ZXJ5LXNlY3VyZS1rZXk=', true));\n+$key = InMemory::base64Encoded('YS12ZXJ5LXNlY3VyZS1rZXk=');\n \n // Key from file contents\n-$key = new Key('file:///var/secrets/my-private-key.pem');\n+$key = InMemory::file('/var/secrets/my-private-key.pem');\n```\n\n### Use the new `Builder` API\n\nThere are 4 main differences on the new API:\n\n1. Token configuration methods were renamed\n1. Signature is created via `Builder#getToken()` (instead of `Builder#sign()`)\n1. `DateTimeImmutable` objects are now for the registered claims with dates\n1. Headers should be replicated manually - whenever necessary\n\nHere's the migration:\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n+use DateTimeImmutable; \n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n-\n-use function time;\n\n-$now = time();\n+$now = new DateTimeImmutable();\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->setIssuer('http://example.com', true)\n+    ->issuedBy('http://example.com')\n+    ->withHeader('iss', 'http://example.com')\n-    ->setAudience('http://example.org')\n+    ->permittedFor('http://example.org')\n-    ->setId('4f1g23a12aa')\n+    ->identifiedBy('4f1g23a12aa')\n-    ->setSubject('user123')\n+    ->relatedTo('user123')\n-    ->setIssuedAt($now)\n+    ->issuedAt($now)\n-    ->setNotBefore($now + 60)\n+    ->canOnlyBeUsedAfter($now->modify('+1 minute'))\n-    ->setExpiration($now + 3600)\n+    ->expiresAt($now->modify('+1 hour'))\n-    ->set('uid', 1)\n+    ->withClaim('uid', 1)\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n#### Support for multiple audiences\n\nEven though we didn't officially support multiple audiences, it was technically possible to achieve that by manually setting the `aud` claim to an array with multiple strings.\n\nIf you parse a token with 3.4, and read its contents with `\\Lcobucci\\JWT\\Token#getClaim()` or`\\Lcobucci\\JWT\\Token#getClaims()`, you will only get the first element of such an array back.\nIf the audience claim does only contain a string, or only contains one string in the array, nothing changes.\nPlease [upgrade to the new Token API](#use-the-new-token-api) for accessing claims in order to get the full audience array again (e.g. call `Token#claims()->get('aud')`).\n\nWhen creating a token, use the new method `Builder#permittedFor()` as detailed below.\n\n##### Multiple calls to `Builder#permittedFor()`\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->withClaim('aud', ['one', 'two', 'three'])\n+    ->permittedFor('one')\n+    ->permittedFor('two')\n+    ->permittedFor('three')\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n##### Single call to `Builder#permittedFor()` with multiple arguments\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->withClaim('aud', ['one', 'two', 'three'])\n+    ->permittedFor('one', 'two', 'three')\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n##### Single call to `Builder#permittedFor()` with argument unpacking\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n\n-use Lcobucci\\JWT\\Builder;\n+use Lcobucci\\JWT\\Configuration;\n+use Lcobucci\\JWT\\Signer\\Key\\InMemory;\n use Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\n\n+$config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n\n-$token = (new Builder())\n+$token = $config->builder()\n-    ->withClaim('aud', ['one', 'two', 'three'])\n+    ->permittedFor(...['one', 'two', 'three'])\n-    ->sign(new Sha256(), 'testing')\n-    ->getToken();\n+    ->getToken($config->signer(), $config->signingKey());\n```\n\n### Replace `Token#verify()` and `Token#validate()` with Validation API\n\nThese methods were quite limited and brings multiple responsibilities to the `Token` class.\nOn `v4.0` we provide another component to validate tokens, including their signature.\n\nHere's an example of how to modify that logic (considering [constraints have been configured](configuration.md#customisation)):\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n use InvalidArgumentException;\n+use Lcobucci\\JWT\\Configuration;\n-use Lcobucci\\JWT\\Signer;\n-use Lcobucci\\JWT\\Signer\\Key;\n-use Lcobucci\\JWT\\Parser;\n-use Lcobucci\\JWT\\ValidationData;\n \n final class AuthenticateJwt\n {\n-    private Parser $parser;\n-    private Signer $signer;\n-    private Key $key;\n+    private Configuration $config;\n     \n-    public function __construct(Parser $parser, Signer $signer, Key $key)\n+    public function __construct(Configuration $config)\n     {\n-        $this->parser = $parser;\n-        $this->signer = $signer;\n-        $this->key    = $key;\n+        $this->config = $config;\n     }\n     \n     public function authenticate(string $jwt): void\n     {\n-        $token = $this->parser->parse($jwt);\n+        $token = $this->config->parser()->parse($jwt);\n         \n-        if (! $token->validate(new ValidationData()) || $token->verify($this->signer, $this->key)) {\n+        if (! $this->config->validator()->validate($token, ...$this->config->validationConstraints())) {\n             throw new InvalidArgumentException('Invalid token provided');\n         }\n     }\n }\n```\n\nCheck [here](validating-tokens.md) for more information on how to validate tokens and what are the built-in constraints.\n\n### Use the new `Token` API\n\nThere some important differences on this new API:\n\n1. We no longer use the `Lcobucci\\JWT\\Claim` objects\n1. Headers and claims are now represented as `Lcobucci\\JWT\\Token\\DataSet`\n1. Different methods should be used to retrieve a header/claim\n1. No exception is thrown when accessing missing header/claim, the default argument is always used\n1. Tokens should be explicitly casted to string via method\n\nYour code should be adapted to manipulate tokens like this:\n\n```diff\n <?php\n declare(strict_types=1);\n \n namespace Me\\MyApp\\Authentication;\n \n // we assume here that $token is a valid parsed/created token\n \n-$token->getHeaders() \n+$token->headers()->all()\n-$token->hasHeader('typ')\n+$token->headers()->has('typ')\n-$token->getHeader('typ')\n+$token->headers()->get('typ')\n\n-$token->getClaims() \n+$token->claims()->all()\n-$token->hasClaim('iss')\n+$token->claims()->has('iss')\n-$token->getClaim('iss')\n+$token->claims()->get('iss')\n\n-echo (string) $token;\n+echo $token->toString();\n```\n", "parameters:\n    level: max\n    paths:\n        - src\n        - test\n\n    ignoreErrors:\n        - '#.*OpenSSLAsymmetricKey.*#'\n        - '#Call to method .* of deprecated class Lcobucci\\\\JWT\\\\Signer\\\\Key\\\\LocalFileReference#'\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer\\Key;\n\nuse Lcobucci\\JWT\\Signer\\Key;\n\nuse function file_exists;\nuse function strpos;\nuse function substr;\n\n/** @deprecated please use {@see InMemory} instead */\nfinal class LocalFileReference implements Key\n{\n    private const PATH_PREFIX = 'file://';\n\n    private string $path;\n    private string $passphrase;\n    private string $contents;\n\n    private function __construct(string $path, string $passphrase)\n    {\n        $this->path       = $path;\n        $this->passphrase = $passphrase;\n    }\n\n    /** @throws FileCouldNotBeRead */\n    public static function file(string $path, string $passphrase = ''): self\n    {\n        if (strpos($path, self::PATH_PREFIX) === 0) {\n            $path = substr($path, 7);\n        }\n\n        if (! file_exists($path)) {\n            throw FileCouldNotBeRead::onPath($path);\n        }\n\n        return new self($path, $passphrase);\n    }\n\n    public function contents(): string\n    {\n        if (! isset($this->contents)) {\n            $this->contents = InMemory::file($this->path)->contents();\n        }\n\n        return $this->contents;\n    }\n\n    public function passphrase(): string\n    {\n        return $this->passphrase;\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\FunctionalTests;\n\nuse Lcobucci\\JWT\\Configuration;\nuse Lcobucci\\JWT\\Signer\\Hmac\\Sha256;\nuse Lcobucci\\JWT\\Signer\\Hmac\\Sha512;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\nuse Lcobucci\\JWT\\Signer\\Key\\LocalFileReference;\nuse Lcobucci\\JWT\\Token;\nuse Lcobucci\\JWT\\Validation\\Constraint\\SignedWith;\nuse Lcobucci\\JWT\\Validation\\RequiredConstraintsViolated;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function assert;\nuse function file_put_contents;\nuse function is_string;\nuse function sys_get_temp_dir;\nuse function tempnam;\n\n/**\n * @covers \\Lcobucci\\JWT\\Configuration\n * @covers \\Lcobucci\\JWT\\Encoding\\JoseEncoder\n * @covers \\Lcobucci\\JWT\\Encoding\\ChainedFormatter\n * @covers \\Lcobucci\\JWT\\Encoding\\MicrosecondBasedDateConversion\n * @covers \\Lcobucci\\JWT\\Encoding\\UnifyAudience\n * @covers \\Lcobucci\\JWT\\Token\\Builder\n * @covers \\Lcobucci\\JWT\\Token\\Parser\n * @covers \\Lcobucci\\JWT\\Token\\Plain\n * @covers \\Lcobucci\\JWT\\Token\\DataSet\n * @covers \\Lcobucci\\JWT\\Token\\Signature\n * @covers \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n * @covers \\Lcobucci\\JWT\\Signer\\Hmac\n * @covers \\Lcobucci\\JWT\\Signer\\Hmac\\Sha256\n * @covers \\Lcobucci\\JWT\\Signer\\Hmac\\Sha512\n * @covers \\Lcobucci\\JWT\\Validation\\Validator\n * @covers \\Lcobucci\\JWT\\Validation\\RequiredConstraintsViolated\n * @covers \\Lcobucci\\JWT\\Validation\\Constraint\\SignedWith\n */\nclass HmacTokenTest extends TestCase\n{\n    private Configuration $config;\n\n    /** @before */\n    public function createConfiguration(): void\n    {\n        $this->config = Configuration::forSymmetricSigner(new Sha256(), InMemory::plainText('testing'));\n    }\n\n    /** @test */\n    public function builderCanGenerateAToken(): Token\n    {\n        $user    = ['name' => 'testing', 'email' => 'testing@abc.com'];\n        $builder = $this->config->builder();\n\n        $token = $builder->identifiedBy('1')\n                         ->permittedFor('http://client.abc.com')\n                         ->issuedBy('http://api.abc.com')\n                         ->withClaim('user', $user)\n                         ->withHeader('jki', '1234')\n                         ->getToken($this->config->signer(), $this->config->signingKey());\n\n        self::assertEquals('1234', $token->headers()->get('jki'));\n        self::assertEquals(['http://client.abc.com'], $token->claims()->get(Token\\RegisteredClaims::AUDIENCE));\n        self::assertEquals('http://api.abc.com', $token->claims()->get(Token\\RegisteredClaims::ISSUER));\n        self::assertEquals($user, $token->claims()->get('user'));\n\n        return $token;\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function parserCanReadAToken(Token $generated): void\n    {\n        $read = $this->config->parser()->parse($generated->toString());\n        assert($read instanceof Token\\Plain);\n\n        self::assertEquals($generated, $read);\n        self::assertEquals('testing', $read->claims()->get('user')['name']);\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function signatureAssertionShouldRaiseExceptionWhenKeyIsNotRight(Token $token): void\n    {\n        $this->expectException(RequiredConstraintsViolated::class);\n        $this->expectExceptionMessage('The token violates some mandatory constraints');\n\n        $this->config->validator()->assert(\n            $token,\n            new SignedWith($this->config->signer(), InMemory::plainText('testing1'))\n        );\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function signatureAssertionShouldRaiseExceptionWhenAlgorithmIsDifferent(Token $token): void\n    {\n        $this->expectException(RequiredConstraintsViolated::class);\n        $this->expectExceptionMessage('The token violates some mandatory constraints');\n\n        $this->config->validator()->assert(\n            $token,\n            new SignedWith(new Sha512(), $this->config->verificationKey())\n        );\n    }\n\n    /**\n     * @test\n     * @depends builderCanGenerateAToken\n     */\n    public function signatureValidationShouldSucceedWhenKeyIsRight(Token $token): void\n    {\n        $constraint = new SignedWith($this->config->signer(), $this->config->verificationKey());\n\n        self::assertTrue($this->config->validator()->validate($token, $constraint));\n    }\n\n    /** @test */\n    public function everythingShouldWorkWhenUsingATokenGeneratedByOtherLibs(): void\n    {\n        $data = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9.eyJoZWxsbyI6IndvcmxkIn0.Rh'\n                . '7AEgqCB7zae1PkgIlvOpeyw9Ab8NGTbeOH7heHO0o';\n\n        $token = $this->config->parser()->parse($data);\n        assert($token instanceof Token\\Plain);\n        $constraint = new SignedWith($this->config->signer(), $this->config->verificationKey());\n\n        self::assertTrue($this->config->validator()->validate($token, $constraint));\n        self::assertEquals('world', $token->claims()->get('hello'));\n    }\n\n    /** @test */\n    public function signatureValidationWithLocalFileKeyReferenceWillOperateWithKeyContents(): void\n    {\n        $key = tempnam(sys_get_temp_dir(), 'key');\n        assert(is_string($key));\n\n        file_put_contents($key, 'just a dummy key');\n\n        $validKey      = LocalFileReference::file($key);\n        $invalidKey    = InMemory::plainText('file://' . $key);\n        $signer        = new Sha256();\n        $configuration = Configuration::forSymmetricSigner($signer, $validKey);\n        $validator     = $configuration->validator();\n\n        $token = $configuration->builder()\n            ->withClaim('foo', 'bar')\n            ->getToken($configuration->signer(), $configuration->signingKey());\n\n        self::assertFalse(\n            $validator->validate(\n                $token,\n                new SignedWith($signer, $invalidKey)\n            ),\n            'Token cannot be validated against the **path** of the key'\n        );\n\n        self::assertTrue(\n            $validator->validate(\n                $token,\n                new SignedWith($signer, $validKey)\n            ),\n            'Token can be validated against the **contents** of the key'\n        );\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer;\n\nuse Lcobucci\\JWT\\Keys;\nuse Lcobucci\\JWT\\Signer\\Ecdsa\\MultibyteStringConverter;\nuse OpenSSLAsymmetricKey;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function assert;\nuse function is_resource;\nuse function openssl_pkey_get_private;\nuse function openssl_pkey_get_public;\nuse function openssl_sign;\nuse function openssl_verify;\n\nuse const OPENSSL_ALGO_SHA256;\n\n/** @coversDefaultClass \\Lcobucci\\JWT\\Signer\\Ecdsa */\nfinal class EcdsaTest extends TestCase\n{\n    use Keys;\n\n    private MultibyteStringConverter $pointsManipulator;\n\n    /** @before */\n    public function createDependencies(): void\n    {\n        $this->pointsManipulator = new MultibyteStringConverter();\n    }\n\n    private function getSigner(): Ecdsa\n    {\n        $signer = $this->getMockForAbstractClass(Ecdsa::class, [$this->pointsManipulator]);\n\n        $signer->method('algorithm')\n               ->willReturn(OPENSSL_ALGO_SHA256);\n\n        $signer->method('algorithmId')\n               ->willReturn('ES256');\n\n        $signer->method('keyLength')\n               ->willReturn(64);\n\n        return $signer;\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\Ecdsa\\MultibyteStringConverter\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Ecdsa::__construct\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldReturnTheAHashBasedOnTheOpenSslSignature(): void\n    {\n        $payload = 'testing';\n\n        $signer    = $this->getSigner();\n        $signature = $signer->sign($payload, self::$ecdsaKeys['private']);\n\n        $publicKey = openssl_pkey_get_public(self::$ecdsaKeys['public1']->contents());\n        assert(is_resource($publicKey) || $publicKey instanceof OpenSSLAsymmetricKey);\n\n        self::assertSame(\n            1,\n            openssl_verify(\n                $payload,\n                $this->pointsManipulator->toAsn1($signature, $signer->keyLength()),\n                $publicKey,\n                OPENSSL_ALGO_SHA256\n            )\n        );\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\Ecdsa\\MultibyteStringConverter\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Ecdsa::__construct\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function verifyShouldDelegateToEcdsaSignerUsingPublicKey(): void\n    {\n        $payload    = 'testing';\n        $privateKey = openssl_pkey_get_private(self::$ecdsaKeys['private']->contents());\n        assert(is_resource($privateKey) || $privateKey instanceof OpenSSLAsymmetricKey);\n\n        $signature = '';\n        openssl_sign($payload, $signature, $privateKey, OPENSSL_ALGO_SHA256);\n\n        $signer = $this->getSigner();\n\n        self::assertTrue(\n            $signer->verify(\n                $this->pointsManipulator->fromAsn1($signature, $signer->keyLength()),\n                $payload,\n                self::$ecdsaKeys['public1']\n            )\n        );\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer\\Key;\n\nuse org\\bovigo\\vfs\\vfsStream;\nuse PHPUnit\\Framework\\TestCase;\n\n/**\n * @coversDefaultClass \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n *\n * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n */\nfinal class LocalFileReferenceTest extends TestCase\n{\n    /** @before */\n    public function configureRootDir(): void\n    {\n        vfsStream::setup(\n            'root',\n            null,\n            ['test.pem' => 'testing']\n        );\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::file\n     * @covers \\Lcobucci\\JWT\\Signer\\Key\\FileCouldNotBeRead\n     */\n    public function thereShouldBeNoReferenceToAFileThatDoesNotExist(): void\n    {\n        $this->expectException(FileCouldNotBeRead::class);\n        $this->expectExceptionMessage('The path \"vfs://root/test2.pem\" does not contain a valid key file');\n\n        LocalFileReference::file(vfsStream::url('root/test2.pem'));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::file\n     * @covers ::__construct\n     * @covers ::contents\n     * @covers ::passphrase\n     */\n    public function pathShouldBeNormalised(): void\n    {\n        $key = LocalFileReference::file('file://' . vfsStream::url('root/test.pem'), 'test');\n\n        self::assertSame('testing', $key->contents());\n        self::assertSame('test', $key->passphrase());\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\nnamespace Lcobucci\\JWT\\Signer;\n\nuse Lcobucci\\JWT\\Keys;\nuse Lcobucci\\JWT\\Signer\\Key\\InMemory;\nuse OpenSSLAsymmetricKey;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function assert;\nuse function is_resource;\nuse function openssl_pkey_get_private;\nuse function openssl_pkey_get_public;\nuse function openssl_sign;\nuse function openssl_verify;\n\nuse const OPENSSL_ALGO_SHA256;\n\n/** @coversDefaultClass \\Lcobucci\\JWT\\Signer\\Rsa */\nfinal class RsaTest extends TestCase\n{\n    use Keys;\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldReturnAValidOpensslSignature(): void\n    {\n        $payload = 'testing';\n\n        $signer    = $this->getSigner();\n        $signature = $signer->sign($payload, self::$rsaKeys['private']);\n\n        $publicKey = openssl_pkey_get_public(self::$rsaKeys['public']->contents());\n        assert(is_resource($publicKey) || $publicKey instanceof OpenSSLAsymmetricKey);\n\n        self::assertSame(1, openssl_verify($payload, $signature, $publicKey, OPENSSL_ALGO_SHA256));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\CannotSignPayload\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldRaiseAnExceptionWhenKeyIsInvalid(): void\n    {\n        $key = <<<KEY\n-----BEGIN RSA PRIVATE KEY-----\nMGECAQACEQC4MRKSVsq5XnRBrJoX6+rnAgMBAAECECO8SZkgw6Yg66A6SUly/3kC\nCQDtPXZtCQWJuwIJAMbBu17GDOrFAggopfhNlFcjkwIIVjb7G+U0/TECCEERyvxP\nTWdN\n-----END RSA PRIVATE KEY-----\nKEY;\n\n        $signer = $this->getSigner();\n\n        $this->expectException(CannotSignPayload::class);\n        $this->expectExceptionMessage('There was an error while creating the signature');\n\n        $signer->sign('testing', InMemory::plainText($key));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldRaiseAnExceptionWhenKeyIsNotParseable(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('It was not possible to parse your key');\n\n        $signer->sign('testing', InMemory::plainText('blablabla'));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::sign\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function signShouldRaiseAnExceptionWhenKeyTypeIsNotRsa(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('This key is not compatible with this signer');\n\n        $signer->sign('testing', self::$ecdsaKeys['private']);\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers ::keyType\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function verifyShouldReturnTrueWhenSignatureIsValid(): void\n    {\n        $payload    = 'testing';\n        $privateKey = openssl_pkey_get_private(self::$rsaKeys['private']->contents());\n        assert(is_resource($privateKey) || $privateKey instanceof OpenSSLAsymmetricKey);\n\n        $signature = '';\n        openssl_sign($payload, $signature, $privateKey, OPENSSL_ALGO_SHA256);\n\n        $signer = $this->getSigner();\n\n        self::assertTrue($signer->verify($signature, $payload, self::$rsaKeys['public']));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function verifyShouldRaiseAnExceptionWhenKeyIsNotParseable(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('It was not possible to parse your key');\n\n        $signer->verify('testing', 'testing', InMemory::plainText('blablabla'));\n    }\n\n    /**\n     * @test\n     *\n     * @covers ::verify\n     * @covers \\Lcobucci\\JWT\\Signer\\OpenSSL\n     * @covers \\Lcobucci\\JWT\\Signer\\InvalidKeyProvided\n     *\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\n     * @uses \\Lcobucci\\JWT\\Signer\\Key\\InMemory\n     */\n    public function verifyShouldRaiseAnExceptionWhenKeyTypeIsNotRsa(): void\n    {\n        $signer = $this->getSigner();\n\n        $this->expectException(InvalidKeyProvided::class);\n        $this->expectExceptionMessage('It was not possible to parse your key');\n\n        $signer->verify('testing', 'testing', self::$ecdsaKeys['private']);\n    }\n\n    private function getSigner(): Rsa\n    {\n        $signer = $this->getMockForAbstractClass(Rsa::class);\n\n        $signer->method('algorithm')\n               ->willReturn(OPENSSL_ALGO_SHA256);\n\n        $signer->method('algorithmId')\n               ->willReturn('RS256');\n\n        return $signer;\n    }\n}\n"], "filenames": ["docs/configuration.md", "docs/upgrading.md", "phpstan.neon.dist", "src/Signer/Key/LocalFileReference.php", "test/functional/HmacTokenTest.php", "test/unit/Signer/EcdsaTest.php", "test/unit/Signer/Key/LocalFileReferenceTest.php", "test/unit/Signer/RsaTest.php"], "buggy_code_start_loc": [44, 99, 8, 11, 9, 58, 9, 32], "buggy_code_end_loc": [88, 102, 8, 42, 133, 90, 63, 163], "fixing_code_start_loc": [43, 99, 9, 12, 10, 59, 9, 33], "fixing_code_end_loc": [85, 101, 10, 48, 174, 93, 53, 168], "type": "CWE-345", "message": "JWT is a library to work with JSON Web Token and JSON Web Signature. Prior to versions 3.4.6, 4.0.4, and 4.1.5, users of HMAC-based algorithms (HS256, HS384, and HS512) combined with `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference` as key are having their tokens issued/validated using the file path as hashing key - instead of the contents. The HMAC hashing functions take any string as input and, since users can issue and validate tokens, users are lead to believe that everything works properly. Versions 3.4.6, 4.0.4, and 4.1.5 have been patched to always load the file contents, deprecated the `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference`, and suggest `Lcobucci\\JWT\\Signer\\Key\\InMemory` as the alternative. As a workaround, use `Lcobucci\\JWT\\Signer\\Key\\InMemory` instead of `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference` to create the instances of one's keys.", "other": {"cve": {"id": "CVE-2021-41106", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-28T21:15:07.370", "lastModified": "2021-10-07T16:22:44.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JWT is a library to work with JSON Web Token and JSON Web Signature. Prior to versions 3.4.6, 4.0.4, and 4.1.5, users of HMAC-based algorithms (HS256, HS384, and HS512) combined with `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference` as key are having their tokens issued/validated using the file path as hashing key - instead of the contents. The HMAC hashing functions take any string as input and, since users can issue and validate tokens, users are lead to believe that everything works properly. Versions 3.4.6, 4.0.4, and 4.1.5 have been patched to always load the file contents, deprecated the `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference`, and suggest `Lcobucci\\JWT\\Signer\\Key\\InMemory` as the alternative. As a workaround, use `Lcobucci\\JWT\\Signer\\Key\\InMemory` instead of `Lcobucci\\JWT\\Signer\\Key\\LocalFileReference` to create the instances of one's keys."}, {"lang": "es", "value": "JWT es una biblioteca para trabajar con JSON Web Token y JSON Web Signature. Antes de las versiones 3.4.6, 4.0.4 y 4.1.5, los usuarios de los algoritmos basados en HMAC (HS256, HS384 y HS512) combinados con \"Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\" como clave est\u00e1n emitiendo/validando sus tokens usando la ruta del archivo como clave de hashing - en lugar del contenido. Las funciones de hashing HMAC aceptan cualquier cadena como entrada y, dado que los usuarios pueden emitir y comprobar tokens, los usuarios son llevados a creer que todo funciona correctamente. Las versiones 3.4.6, 4.0.4 y 4.1.5 han sido parcheadas para cargar siempre el contenido del archivo, desaprobando la funci\u00f3n \"Lcobucci\\JWT\\Signer\\Key\\LocalFileReference\", y sugiriendo \"Lcobucci\\JWT\\Signer\\Key\\InMemory\" como alternativa. Como soluci\u00f3n, use \"Lcobucci\\JWT\\SignerKey\\InMemory\" en lugar de \"Lcobucci\\JWT\\SignerKey\\LocalFileReference\" para crear las instancias de las claves propias"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jwt_project:jwt:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.6", "matchCriteriaId": "6756DFB7-6FCD-4D08-87A5-56D4A9DE2430"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jwt_project:jwt:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.4", "matchCriteriaId": "18C105D0-94D0-4E6A-AE8A-F02E5963A50E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jwt_project:jwt:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.5", "matchCriteriaId": "2EFDA9F5-63DB-416C-BBAD-9012B2486CAE"}]}]}], "references": [{"url": "https://github.com/lcobucci/jwt/commit/8175de5b841fbe3fd97d2d49b3fc15c4ecb39a73", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lcobucci/jwt/commit/c45bb8b961a8e742d8f6b88ef5ff1bd5cca5d01c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lcobucci/jwt/security/advisories/GHSA-7322-jrq4-x5hf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lcobucci/jwt/commit/8175de5b841fbe3fd97d2d49b3fc15c4ecb39a73"}}