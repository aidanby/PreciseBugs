{"buggy_code": ["/*-\n * Copyright (c) 2003-2009 Tim Kientzle\n * Copyright (c) 2010-2012 Michihiro NAKAJIMA\n * Copyright (c) 2017 Martin Matuska\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#if ARCHIVE_ACL_FREEBSD\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#define _ACL_PRIVATE /* For debugging */\n#include <sys/acl.h>\n#endif\n\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_disk_private.h\"\n#include \"archive_write_disk_private.h\"\n\ntypedef struct {\n\tconst int a_perm;\t/* Libarchive permission or flag */\n\tconst int p_perm;\t/* Platform permission or flag */\n} acl_perm_map_t;\n\nstatic const acl_perm_map_t acl_posix_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},\n\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},\n};\n\nstatic const int acl_posix_perm_map_size =\n    (int)(sizeof(acl_posix_perm_map)/sizeof(acl_posix_perm_map[0]));\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\nstatic const acl_perm_map_t acl_nfs4_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},\n\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},\n\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},\n\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},\n\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},\n\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}\n};\n\nstatic const int acl_nfs4_perm_map_size =\n    (int)(sizeof(acl_nfs4_perm_map)/sizeof(acl_nfs4_perm_map[0]));\n\nstatic const acl_perm_map_t acl_nfs4_flag_map[] = {\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_NO_PROPAGATE_INHERIT},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACL_ENTRY_SUCCESSFUL_ACCESS},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACL_ENTRY_FAILED_ACCESS},\n#ifdef ACL_ENTRY_INHERITED\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED}\n#endif\n};\n\nstatic const int acl_nfs4_flag_map_size =\n    (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n#endif /* ARCHIVE_ACL_FREEBSD_NFS4 */\n\nstatic int\ntranslate_acl(struct archive_read_disk *a,\n    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)\n{\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tint brand;\n\tacl_flagset_t\t acl_flagset;\n\tacl_entry_type_t acl_type;\n#endif\n\tacl_tag_t\t acl_tag;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\tint\t\t i, entry_acl_type, perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tint\t\t r, s, ae_id, ae_tag, ae_perm;\n\tvoid\t\t*q;\n\tconst char\t*ae_name;\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t// FreeBSD \"brands\" ACLs as POSIX.1e or NFSv4\n\t// Make sure the \"brand\" on this ACL is consistent\n\t// with the default_entry_acl_type bits provided.\n\tif (acl_get_brand_np(acl, &brand) != 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read ACL brand\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tswitch (brand) {\n\tcase ACL_BRAND_POSIX:\n\t\tswitch (default_entry_acl_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Invalid ACL entry type for POSIX.1e ACL\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tbreak;\n\tcase ACL_BRAND_NFS4:\n\t\tif (default_entry_acl_type & ~ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Invalid ACL entry type for NFSv4 ACL\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Unknown ACL brand\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n#endif\n\n\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);\n\tif (s == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get first ACL entry\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\twhile (s == 1) {\n\t\tae_id = -1;\n\t\tae_name = NULL;\n\t\tae_perm = 0;\n\n\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL tag type\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tswitch (acl_tag) {\n\t\tcase ACL_USER:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(uid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(gid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ACL_EVERYONE:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\t/* Skip types that libarchive can't support. */\n\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits\n\t\tentry_acl_type = default_entry_acl_type;\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_entry_type_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_entry_type_np(acl_entry, &acl_type) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno, \"Failed \"\n\t\t\t\t    \"to get ACL type from a NFSv4 ACL entry\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tswitch (acl_type) {\n\t\t\tcase ACL_ENTRY_TYPE_ALLOW:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\tbreak;\n\t\t\tcase ACL_ENTRY_TYPE_DENY:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t\tbreak;\n\t\t\tcase ACL_ENTRY_TYPE_AUDIT:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\tbreak;\n\t\t\tcase ACL_ENTRY_TYPE_ALARM:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Invalid NFSv4 ACL entry type\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Libarchive stores \"flag\" (NFSv4 inheritance bits)\n\t\t\t * in the ae_perm bitmap.\n\t\t\t *\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Failed to get flagset from a NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tr = acl_get_flag_np(acl_flagset,\n\t\t\t\t    acl_nfs4_flag_map[i].p_perm);\n\t\t\t\tif (r == -1) {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Failed to check flag in a NFSv4 \"\n\t\t\t\t\t    \"ACL flagset\");\n\t\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t\t} else if (r)\n\t\t\t\t\tae_perm |= acl_nfs4_flag_map[i].a_perm;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tr = acl_get_perm_np(acl_permset, perm_map[i].p_perm);\n\t\t\tif (r == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Failed to check permission in an ACL \"\n\t\t\t\t    \"permission set\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t} else if (r)\n\t\t\t\tae_perm |= perm_map[i].a_perm;\n\t\t}\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t\t\t\t    ae_perm, ae_tag,\n\t\t\t\t\t    ae_id, ae_name);\n\n\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get next ACL entry\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}\n\nint\narchive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n    struct archive_entry *entry, int *fd)\n{\n\tconst char\t*accpath;\n\tacl_t\t\tacl;\n\tint\t\tr;\n\n\taccpath = NULL;\n\n\tif (*fd < 0) {\n\t\taccpath = archive_read_disk_entry_setup_path(a, entry, fd);\n\t\tif (accpath == NULL)\n\t\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tarchive_entry_acl_clear(entry);\n\n\tacl = NULL;\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t/* Try NFSv4 ACL first. */\n\tif (*fd >= 0)\n\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_NFS4);\n\telse if (!a->follow_symlinks)\n\t\tacl = acl_get_link_np(accpath, ACL_TYPE_NFS4);\n\telse\n\t\tacl = acl_get_file(accpath, ACL_TYPE_NFS4);\n\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0 && r == 1) {\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (acl != NULL) {\n\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate NFSv4 ACLs\");\n\t\t}\n\n\t\treturn (r);\n\t}\n#endif\n\n\t/* Retrieve access ACL from file. */\n\tif (*fd >= 0)\n\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_ACCESS);\n#if HAVE_ACL_GET_LINK_NP\n\telse if (!a->follow_symlinks)\n\t\tacl = acl_get_link_np(accpath, ACL_TYPE_ACCESS);\n#else\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\tacl = NULL;\n#endif\n\telse\n\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);\n\n#if HAVE_ACL_IS_TRIVIAL_NP\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0 && r == 1) {\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\t}\n#endif\n\n\tif (acl != NULL) {\n\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate access ACLs\");\n\t\t\treturn (r);\n\t\t}\n\t}\n\n\t/* Only directories can have default ACLs. */\n\tif (S_ISDIR(archive_entry_mode(entry))) {\n\t\tif (*fd >= 0)\n\t\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_DEFAULT);\n\t\telse\n\t\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);\n\t\tif (acl != NULL) {\n\t\t\tr = translate_acl(a, entry, acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);\n\t\t\tacl_free(acl);\n\t\t\tif (r != ARCHIVE_OK) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Couldn't translate default ACLs\");\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}\n#endif\t/* ARCHIVE_ACL_FREEBSD */\n", "/*-\n * Copyright (c) 2003-2009 Tim Kientzle\n * Copyright (c) 2010-2012 Michihiro NAKAJIMA\n * Copyright (c) 2017 Martin Matuska\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#if ARCHIVE_ACL_LIBACL || ARCHIVE_ACL_LIBRICHACL\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if HAVE_ACL_LIBACL_H\n#include <acl/libacl.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#include <sys/acl.h>\n#endif\n#ifdef HAVE_SYS_RICHACL_H\n#include <sys/richacl.h>\n#endif\n\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_disk_private.h\"\n#include \"archive_write_disk_private.h\"\n\ntypedef struct {\n\tconst int a_perm;\t/* Libarchive permission or flag */\n\tconst int p_perm;\t/* Platform permission or flag */\n} acl_perm_map_t;\n\n#if ARCHIVE_ACL_LIBACL\nstatic const acl_perm_map_t acl_posix_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},\n\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},\n};\n\nstatic const int acl_posix_perm_map_size =\n    (int)(sizeof(acl_posix_perm_map)/sizeof(acl_posix_perm_map[0]));\n#endif /* ARCHIVE_ACL_LIBACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\nstatic const acl_perm_map_t acl_nfs4_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, RICHACE_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_READ_DATA, RICHACE_READ_DATA},\n\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, RICHACE_LIST_DIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, RICHACE_WRITE_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_FILE, RICHACE_ADD_FILE},\n\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, RICHACE_APPEND_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, RICHACE_ADD_SUBDIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, RICHACE_READ_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, RICHACE_WRITE_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, RICHACE_DELETE_CHILD},\n\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, RICHACE_READ_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, RICHACE_WRITE_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_DELETE, RICHACE_DELETE},\n\t{ARCHIVE_ENTRY_ACL_READ_ACL, RICHACE_READ_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, RICHACE_WRITE_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, RICHACE_WRITE_OWNER},\n\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, RICHACE_SYNCHRONIZE}\n};\n\nstatic const int acl_nfs4_perm_map_size =\n    (int)(sizeof(acl_nfs4_perm_map)/sizeof(acl_nfs4_perm_map[0]));\n\nstatic const acl_perm_map_t acl_nfs4_flag_map[] = {\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, RICHACE_FILE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, RICHACE_DIRECTORY_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, RICHACE_NO_PROPAGATE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, RICHACE_INHERIT_ONLY_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, RICHACE_INHERITED_ACE}\n};\n\nstatic const int acl_nfs4_flag_map_size =\n    (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n#endif /* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBACL\n/*\n * Translate POSIX.1e ACLs into libarchive internal structure\n */\nstatic int\ntranslate_acl(struct archive_read_disk *a,\n    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)\n{\n\tacl_tag_t\t acl_tag;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\tint\t\t i, entry_acl_type;\n\tint\t\t r, s, ae_id, ae_tag, ae_perm;\n\tvoid\t\t*q;\n\tconst char\t*ae_name;\n\n\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);\n\tif (s == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get first ACL entry\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\twhile (s == 1) {\n\t\tae_id = -1;\n\t\tae_name = NULL;\n\t\tae_perm = 0;\n\n\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL tag type\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tswitch (acl_tag) {\n\t\tcase ACL_USER:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(uid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(gid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Skip types that libarchive can't support. */\n\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits\n\t\tentry_acl_type = default_entry_acl_type;\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\tr = acl_get_perm(acl_permset,\n\t\t\t    acl_posix_perm_map[i].p_perm);\n\t\t\tif (r == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Failed to check permission in an ACL \"\n\t\t\t\t    \"permission set\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t} else if (r)\n\t\t\t\tae_perm |= acl_posix_perm_map[i].a_perm;\n\t\t}\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t\t\t\t    ae_perm, ae_tag,\n\t\t\t\t\t    ae_id, ae_name);\n\n\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get next ACL entry\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n#endif /* ARCHIVE_ACL_LIBACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\n/*\n * Translate RichACL into libarchive internal ACL\n */\nstatic int\ntranslate_richacl(struct archive_read_disk *a, struct archive_entry *entry,\n    struct richacl *richacl)\n{\n\tint ae_id, ae_tag, ae_perm;\n\tint entry_acl_type, i;\n\tconst char *ae_name;\n\n\tstruct richace *richace;\n\n\trichacl_for_each_entry(richace, richacl) {\n\t\tae_name = NULL;\n\t\tae_tag = 0;\n\t\tae_perm = 0;\n\t\tae_id = -1;\n\n\t\tswitch (richace->e_type) {\n\t\tcase RICHACE_ACCESS_ALLOWED_ACE_TYPE:\n\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\tbreak;\n\t\tcase RICHACE_ACCESS_DENIED_ACE_TYPE:\n\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\tbreak;\n\t\tdefault: /* Unknown entry type, skip */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Unsupported */\n\t\tif (richace->e_flags & RICHACE_UNMAPPED_WHO)\n\t\t\tcontinue;\n\n\t\tif (richace->e_flags & RICHACE_SPECIAL_WHO) {\n\t\t\tswitch (richace->e_id) {\n\t\t\tcase RICHACE_OWNER_SPECIAL_ID:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase RICHACE_GROUP_SPECIAL_ID:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase RICHACE_EVERYONE_SPECIAL_ID:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault: /* Unknown special ID type */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tae_id = richace->e_id;\n\t\t\tif (richace->e_flags & RICHACE_IDENTIFIER_GROUP) {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    (gid_t)(richace->e_id));\n\t\t\t} else {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    (uid_t)(richace->e_id));\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\tif ((richace->e_flags &\n\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0)\n\t\t\t\tae_perm |= acl_nfs4_flag_map[i].a_perm;\n\t\t}\n\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\tif ((richace->e_mask &\n\t\t\t    acl_nfs4_perm_map[i].p_perm) != 0)\n\t\t\t\tae_perm |=\n\t\t\t\t    acl_nfs4_perm_map[i].a_perm;\n\t\t}\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t    ae_perm, ae_tag, ae_id, ae_name);\n\t}\n\treturn (ARCHIVE_OK);\n}\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\nstatic int\n_richacl_mode_to_mask(short mode)\n{\n\tint mask = 0;\n\n\tif (mode & S_IROTH)\n\t\tmask |= RICHACE_POSIX_MODE_READ;\n\tif (mode & S_IWOTH)\n\t\tmask |= RICHACE_POSIX_MODE_WRITE;\n\tif (mode & S_IXOTH)\n\t\tmask |= RICHACE_POSIX_MODE_EXEC;\n\n\treturn (mask);\n}\n\nstatic void\n_richacl_mode_to_masks(struct richacl *richacl, __LA_MODE_T mode)\n{\n\trichacl->a_owner_mask = _richacl_mode_to_mask((mode & 0700) >> 6);\n\trichacl->a_group_mask = _richacl_mode_to_mask((mode & 0070) >> 3);\n\trichacl->a_other_mask = _richacl_mode_to_mask(mode & 0007);\n}\n#endif /* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\nstatic int\nset_richacl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tint\t\t e = 0;\n\tstruct richacl  *richacl = NULL;\n\tstruct richace  *richace;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (ae_requested_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\trichacl = richacl_alloc(entries);\n\tif (richacl == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t\t\"Failed to initialize RichACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\trichace = &(richacl->a_entries[e]);\n\n\t\trichace->e_flags = 0;\n\t\trichace->e_mask = 0;\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_uid;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_gid;\n\t\t\trichace->e_flags |= RICHACE_IDENTIFIER_GROUP;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_OWNER_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_GROUP_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_EVERYONE_SPECIAL_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_type) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_nfs4_perm_map[i].a_perm)\n\t\t\t\trichace->e_mask |= acl_nfs4_perm_map[i].p_perm;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\tif (ae_permset &\n\t\t\t    acl_nfs4_flag_map[i].a_perm)\n\t\t\t\trichace->e_flags |= acl_nfs4_flag_map[i].p_perm;\n\t\t}\n\te++;\n\t}\n\n\t/* Fill RichACL masks */\n\t_richacl_mode_to_masks(richacl, mode);\n\n\tif (fd >= 0) {\n\t\tif (richacl_set_fd(fd, richacl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set richacl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (richacl_set_file(name, richacl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set richacl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\trichacl_free(richacl);\n\treturn (ret);\n}\n#endif /* ARCHIVE_ACL_RICHACL */\n\n#if ARCHIVE_ACL_LIBACL\nstatic int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tacl_t\t\t acl = NULL;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_posix_perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    acl_posix_perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {\n\t\tif (acl_set_fd(fd, acl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl_set_file(name, acl_type, acl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}\n#endif /* ARCHIVE_ACL_LIBACL */\n\nint\narchive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n    struct archive_entry *entry, int *fd)\n{\n\tconst char\t*accpath;\n\tint\t\tr;\n#if ARCHIVE_ACL_LIBACL\n\tacl_t\t\tacl;\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tstruct richacl *richacl;\n\tmode_t\t\tmode;\n#endif\n\n\taccpath = NULL;\n\tr = ARCHIVE_OK;\n\n\t/* For default ACLs we need reachable accpath */\n\tif (*fd < 0 || S_ISDIR(archive_entry_mode(entry))) {\n\t\taccpath = archive_read_disk_entry_setup_path(a, entry, fd);\n\t\tif (accpath == NULL)\n\t\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tarchive_entry_acl_clear(entry);\n\n#if ARCHIVE_ACL_LIBACL\n\tacl = NULL;\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\trichacl = NULL;\n#endif\n\n#if ARCHIVE_ACL_LIBRICHACL\n\t/* Try NFSv4 ACL first. */\n\tif (*fd >= 0)\n\t\trichacl = richacl_get_fd(*fd);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one */\n\t\trichacl = NULL;\n\telse\n\t\trichacl = richacl_get_file(accpath);\n\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (richacl != NULL) {\n\t\tmode = archive_entry_mode(entry);\n\t\tif (richacl_equiv_mode(richacl, &mode) == 0) {\n\t\t\trichacl_free(richacl);\n\t\t\trichacl = NULL;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t}\n\n\tif (richacl != NULL) {\n\t\tr = translate_richacl(a, entry, richacl);\n\t\trichacl_free(richacl);\n\t\trichacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\"Couldn't translate NFSv4 ACLs\");\n\t\t}\n\n\t\treturn (r);\n\t}\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBACL\n\t/* Retrieve access ACL from file. */\n\tif (*fd >= 0)\n\t\tacl = acl_get_fd(*fd);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\tacl = NULL;\n\telse\n\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);\n\n\tif (acl != NULL) {\n\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate access ACLs\");\n\t\t\treturn (r);\n\t\t}\n\t}\n\n\t/* Only directories can have default ACLs. */\n\tif (S_ISDIR(archive_entry_mode(entry))) {\n\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);\n\t\tif (acl != NULL) {\n\t\t\tr = translate_acl(a, entry, acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);\n\t\t\tacl_free(acl);\n\t\t\tif (r != ARCHIVE_OK) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Couldn't translate default ACLs\");\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* ARCHIVE_ACL_LIBACL */\n\treturn (r);\n}\n\nint\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t/* UNUSED */\n#endif\n\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t/* ARCHIVE_ACL_LIBACL */\n\treturn (ret);\n}\n#endif /* ARCHIVE_ACL_LIBACL || ARCHIVE_ACL_LIBRICHACL */\n", "/*-\n * Copyright (c) 2017 Martin Matuska\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#if ARCHIVE_ACL_SUNOS\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#define _ACL_PRIVATE /* For debugging */\n#include <sys/acl.h>\n#endif\n\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_disk_private.h\"\n#include \"archive_write_disk_private.h\"\n\ntypedef struct {\n\tconst int a_perm;\t/* Libarchive permission or flag */\n\tconst int p_perm;\t/* Platform permission or flag */\n} acl_perm_map_t;\n\nstatic const acl_perm_map_t acl_posix_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, S_IXOTH },\n\t{ARCHIVE_ENTRY_ACL_WRITE, S_IWOTH },\n\t{ARCHIVE_ENTRY_ACL_READ, S_IROTH }\n};\n\nstatic const int acl_posix_perm_map_size =\n    (int)(sizeof(acl_posix_perm_map)/sizeof(acl_posix_perm_map[0]));\n\n#if ARCHIVE_ACL_SUNOS_NFS4\nstatic const acl_perm_map_t acl_nfs4_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACE_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACE_READ_DATA},\n\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACE_LIST_DIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACE_WRITE_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACE_ADD_FILE},\n\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACE_APPEND_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACE_ADD_SUBDIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACE_READ_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACE_WRITE_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACE_DELETE_CHILD},\n\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACE_READ_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACE_WRITE_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_DELETE, ACE_DELETE},\n\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACE_READ_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACE_WRITE_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACE_WRITE_OWNER},\n\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACE_SYNCHRONIZE}\n};\n\nstatic const int acl_nfs4_perm_map_size =\n    (int)(sizeof(acl_nfs4_perm_map)/sizeof(acl_nfs4_perm_map[0]));\n\nstatic const acl_perm_map_t acl_nfs4_flag_map[] = {\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACE_FILE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACE_DIRECTORY_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACE_NO_PROPAGATE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACE_INHERIT_ONLY_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACE_SUCCESSFUL_ACCESS_ACE_FLAG},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACE_FAILED_ACCESS_ACE_FLAG},\n#ifdef ACE_INHERITED_ACE\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACE_INHERITED_ACE}\n#endif\n};\n\nconst int acl_nfs4_flag_map_size =\n    (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n\n#endif /* ARCHIVE_ACL_SUNOS_NFS4 */\n\nstatic void *\nsunacl_get(int cmd, int *aclcnt, int fd, const char *path)\n{\n\tint cnt, cntcmd;\n\tsize_t size;\n\tvoid *aclp;\n\n\tif (cmd == GETACL) {\n\t\tcntcmd = GETACLCNT;\n\t\tsize = sizeof(aclent_t);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if (cmd == ACE_GETACL) {\n\t\tcntcmd = ACE_GETACLCNT;\n\t\tsize = sizeof(ace_t);\n\t}\n#endif\n\telse {\n\t\terrno = EINVAL;\n\t\t*aclcnt = -1;\n\t\treturn (NULL);\n\t}\n\n\taclp = NULL;\n\tcnt = -2;\n\n\twhile (cnt == -2 || (cnt == -1 && errno == ENOSPC)) {\n\t\tif (path != NULL)\n\t\t\tcnt = acl(path, cntcmd, 0, NULL);\n\t\telse\n\t\t\tcnt = facl(fd, cntcmd, 0, NULL);\n\n\t\tif (cnt > 0) {\n\t\t\tif (aclp == NULL)\n\t\t\t\taclp = malloc(cnt * size);\n\t\t\telse\n\t\t\t\taclp = realloc(NULL, cnt * size);\n\t\t\tif (aclp != NULL) {\n\t\t\t\tif (path != NULL)\n\t\t\t\t\tcnt = acl(path, cmd, cnt, aclp);\n\t\t\t\telse\n\t\t\t\t\tcnt = facl(fd, cmd, cnt, aclp);\n\t\t\t}\n\t\t} else {\n\t\t\tfree(aclp);\n\t\t\taclp = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*aclcnt = cnt;\n\treturn (aclp);\n}\n\n/*\n * Check if acl is trivial\n * This is a FreeBSD acl_is_trivial_np() implementation for Solaris\n */\nstatic int\nsun_acl_is_trivial(void *aclp, int aclcnt, mode_t mode, int is_nfs4,\n    int is_dir, int *trivialp)\n{\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tint i, p;\n\tconst uint32_t rperm = ACE_READ_DATA;\n\tconst uint32_t wperm = ACE_WRITE_DATA | ACE_APPEND_DATA;\n\tconst uint32_t eperm = ACE_EXECUTE;\n\tconst uint32_t pubset = ACE_READ_ATTRIBUTES | ACE_READ_NAMED_ATTRS |\n\t    ACE_READ_ACL | ACE_SYNCHRONIZE;\n\tconst uint32_t ownset = pubset | ACE_WRITE_ATTRIBUTES |\n\t    ACE_WRITE_NAMED_ATTRS | ACE_WRITE_ACL | ACE_WRITE_OWNER;\n\n\tace_t *ace;\n\tace_t tace[6];\n#endif\n\n\tif (aclp == NULL || trivialp == NULL)\n\t\treturn (-1);\n\n\t*trivialp = 0;\n\n\t/*\n\t * POSIX.1e ACLs marked with ACL_IS_TRIVIAL are compatible with\n\t * FreeBSD acl_is_trivial_np(). On Solaris they have 4 entries,\n\t * including mask.\n\t */\n\tif (!is_nfs4) {\n\t\tif (aclcnt == 4)\n\t\t\t*trivialp = 1;\n\t\treturn (0);\n\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t/*\n\t * Continue with checking NFSv4 ACLs\n\t *\n\t * Create list of trivial ace's to be compared\n\t */\n\n\t/* owner@ allow pre */\n\ttace[0].a_flags = ACE_OWNER;\n\ttace[0].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[0].a_access_mask = 0;\n\n\t/* owner@ deny */\n\ttace[1].a_flags = ACE_OWNER;\n\ttace[1].a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\ttace[1].a_access_mask = 0;\n\n\t/* group@ deny */\n\ttace[2].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;\n\ttace[2].a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\ttace[2].a_access_mask = 0;\n\n\t/* owner@ allow */\n\ttace[3].a_flags = ACE_OWNER;\n\ttace[3].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[3].a_access_mask = ownset;\n\n\t/* group@ allow */\n\ttace[4].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;\n\ttace[4].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[4].a_access_mask = pubset;\n\n\t/* everyone@ allow */\n\ttace[5].a_flags = ACE_EVERYONE;\n\ttace[5].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[5].a_access_mask = pubset;\n\n\t/* Permissions for everyone@ */\n\tif (mode & 0004)\n\t\ttace[5].a_access_mask |= rperm;\n\tif (mode & 0002)\n\t\ttace[5].a_access_mask |= wperm;\n\tif (mode & 0001)\n\t\ttace[5].a_access_mask |= eperm;\n\n\t/* Permissions for group@ */\n\tif (mode & 0040)\n\t\ttace[4].a_access_mask |= rperm;\n\telse if (mode & 0004)\n\t\ttace[2].a_access_mask |= rperm;\n\tif (mode & 0020)\n\t\ttace[4].a_access_mask |= wperm;\n\telse if (mode & 0002)\n\t\ttace[2].a_access_mask |= wperm;\n\tif (mode & 0010)\n\t\ttace[4].a_access_mask |= eperm;\n\telse if (mode & 0001)\n\t\ttace[2].a_access_mask |= eperm;\n\n\t/* Permissions for owner@ */\n\tif (mode & 0400) {\n\t\ttace[3].a_access_mask |= rperm;\n\t\tif (!(mode & 0040) && (mode & 0004))\n\t\t\ttace[0].a_access_mask |= rperm;\n\t} else if ((mode & 0040) || (mode & 0004))\n\t\ttace[1].a_access_mask |= rperm;\n\tif (mode & 0200) {\n\t\ttace[3].a_access_mask |= wperm;\n\t\tif (!(mode & 0020) && (mode & 0002))\n\t\t\ttace[0].a_access_mask |= wperm;\n\t} else if ((mode & 0020) || (mode & 0002))\n\t\ttace[1].a_access_mask |= wperm;\n\tif (mode & 0100) {\n\t\ttace[3].a_access_mask |= eperm;\n\t\tif (!(mode & 0010) && (mode & 0001))\n\t\t\ttace[0].a_access_mask |= eperm;\n\t} else if ((mode & 0010) || (mode & 0001))\n\t\ttace[1].a_access_mask |= eperm;\n\n\t/* Check if the acl count matches */\n\tp = 3;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (tace[i].a_access_mask != 0)\n\t\t\tp++;\n\t}\n\tif (aclcnt != p)\n\t\treturn (0);\n\n\tp = 0;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (tace[i].a_access_mask != 0) {\n\t\t\tace = &((ace_t *)aclp)[p];\n\t\t\t/*\n\t\t\t * Illumos added ACE_DELETE_CHILD to write perms for\n\t\t\t * directories. We have to check against that, too.\n\t\t\t */\n\t\t\tif (ace->a_flags != tace[i].a_flags ||\n\t\t\t    ace->a_type != tace[i].a_type ||\n\t\t\t    (ace->a_access_mask != tace[i].a_access_mask &&\n\t\t\t    (!is_dir || (tace[i].a_access_mask & wperm) == 0 ||\n\t\t\t    ace->a_access_mask !=\n\t\t\t    (tace[i].a_access_mask | ACE_DELETE_CHILD))))\n\t\t\t\treturn (0);\n\t\t\tp++;\n\t\t}\n\t}\n\n\t*trivialp = 1;\n#else\t/* !ARCHIVE_ACL_SUNOS_NFS4 */\n\t(void)is_dir;\t/* UNUSED */\n\t(void)aclp;\t/* UNUSED */\n#endif\t/* !ARCHIVE_ACL_SUNOS_NFS4 */\n\treturn (0);\n}\n\n/*\n * Translate Solaris POSIX.1e and NFSv4 ACLs into libarchive internal ACL\n */\nstatic int\ntranslate_acl(struct archive_read_disk *a,\n    struct archive_entry *entry, void *aclp, int aclcnt,\n    int default_entry_acl_type)\n{\n\tint e, i;\n\tint ae_id, ae_tag, ae_perm;\n\tint entry_acl_type;\n\tconst char *ae_name;\n\taclent_t *aclent;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tace_t *ace;\n#endif\n\n\tif (aclcnt <= 0)\n\t\treturn (ARCHIVE_OK);\n\n\tfor (e = 0; e < aclcnt; e++) {\n\t\tae_name = NULL;\n\t\tae_tag = 0;\n\t\tae_perm = 0;\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (default_entry_acl_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tace = &((ace_t *)aclp)[e];\n\t\t\tae_id = ace->a_who;\n\n\t\t\tswitch(ace->a_type) {\n\t\t\tcase ACE_ACCESS_ALLOWED_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\tbreak;\n\t\t\tcase ACE_ACCESS_DENIED_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t\tbreak;\n\t\t\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t\t\tbreak;\n\t\t\tcase ACE_SYSTEM_ALARM_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown entry type, skip */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((ace->a_flags & ACE_OWNER) != 0)\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\telse if ((ace->a_flags & ACE_GROUP) != 0)\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\telse if ((ace->a_flags & ACE_EVERYONE) != 0)\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\telse if ((ace->a_flags & ACE_IDENTIFIER_GROUP) != 0) {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t} else {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif ((ace->a_flags &\n\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0)\n\t\t\t\t\tae_perm |= acl_nfs4_flag_map[i].a_perm;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\t\tif ((ace->a_access_mask &\n\t\t\t\t    acl_nfs4_perm_map[i].p_perm) != 0)\n\t\t\t\t\tae_perm |= acl_nfs4_perm_map[i].a_perm;\n\t\t\t}\n\t\t} else\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\t\tif (default_entry_acl_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {\n\t\t\taclent = &((aclent_t *)aclp)[e];\n\t\t\tif ((aclent->a_type & ACL_DEFAULT) != 0)\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\telse\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t\tae_id = aclent->a_id;\n\n\t\t\tswitch(aclent->a_type) {\n\t\t\tcase DEF_USER:\n\t\t\tcase USER:\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase DEF_GROUP:\n\t\t\tcase GROUP:\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase DEF_CLASS_OBJ:\n\t\t\tcase CLASS_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tcase DEF_USER_OBJ:\n\t\t\tcase USER_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase DEF_GROUP_OBJ:\n\t\t\tcase GROUP_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase DEF_OTHER_OBJ:\n\t\t\tcase OTHER_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown tag type, skip */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\t\tif ((aclent->a_perm &\n\t\t\t\t    acl_posix_perm_map[i].p_perm) != 0)\n\t\t\t\t\tae_perm |= acl_posix_perm_map[i].a_perm;\n\t\t\t}\n\t\t} else\n\t\t\treturn (ARCHIVE_WARN);\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t    ae_perm, ae_tag, ae_id, ae_name);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\taclent_t\t *aclent;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tace_t\t\t *ace;\n#endif\n\tint\t\t cmd, e, r;\n\tvoid\t\t *aclp;\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\tcmd = SETACL;\n\t\taclp = malloc(entries * sizeof(aclent_t));\n\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tcmd = ACE_SETACL;\n\t\taclp = malloc(entries * sizeof(ace_t));\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (aclp == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Can't allocate memory for acl buffer\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\taclent = NULL;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tace = NULL;\n#endif\n\t\tif (cmd == SETACL) {\n\t\t\taclent = &((aclent_t *)aclp)[e];\n\t\t\taclent->a_id = -1;\n\t\t\taclent->a_type = 0;\n\t\t\taclent->a_perm = 0;\n\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\telse {\t/* cmd == ACE_SETACL */\n\t\t\tace = &((ace_t *)aclp)[e];\n\t\t\tace->a_who = -1;\n\t\t\tace->a_access_mask = 0;\n\t\t\tace->a_flags = 0;\n\t\t}\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_uid;\n\t\t\t\taclent->a_type |= USER;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_uid;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_gid;\n\t\t\t\taclent->a_type |= GROUP;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_gid;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= USER_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_OWNER;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= GROUP_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_GROUP;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= CLASS_OBJ;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= OTHER_OBJ;\n\t\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_flags |= ACE_EVERYONE;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tr = 0;\n\t\tswitch (ae_type) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n#endif\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\t\tif (aclent == NULL)\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= ACL_DEFAULT;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\terrno = EINVAL;\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t}\n#endif\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\t\tif (ae_requested_type ==\n\t\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4)\n\t\t\t\t\tace->a_access_mask |=\n\t\t\t\t\t    perm_map[i].p_perm;\n\t\t\t\telse\n#endif\n\t\t\t\t\taclent->a_perm |= perm_map[i].p_perm;\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tace->a_flags |=\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\te++;\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (facl(fd, cmd, entries, aclp) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl(name, cmd, entries, aclp) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tfree(aclp);\n\treturn (ret);\n}\n\nint\narchive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n    struct archive_entry *entry, int *fd)\n{\n\tconst char\t*accpath;\n\tvoid\t\t*aclp;\n\tint\t\taclcnt;\n\tint\t\tr;\n\n\taccpath = NULL;\n\n\tif (*fd < 0) {\n\t\taccpath = archive_read_disk_entry_setup_path(a, entry, fd);\n\t\tif (accpath == NULL)\n\t\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tarchive_entry_acl_clear(entry);\n\n\taclp = NULL;\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tif (*fd >= 0)\n\t\taclp = sunacl_get(ACE_GETACL, &aclcnt, *fd, NULL);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\taclp = NULL;\n\telse\n\t\taclp = sunacl_get(ACE_GETACL, &aclcnt, 0, accpath);\n\n\tif (aclp != NULL && sun_acl_is_trivial(aclp, aclcnt,\n\t    archive_entry_mode(entry), 1, S_ISDIR(archive_entry_mode(entry)),\n\t    &r) == 0 && r == 1) {\n\t\tfree(aclp);\n\t\taclp = NULL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (aclp != NULL) {\n\t\tr = translate_acl(a, entry, aclp, aclcnt,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4);\n\t\tfree(aclp);\n\t\taclp = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate NFSv4 ACLs\");\n\t\t}\n\t\treturn (r);\n\t}\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\n\t/* Retrieve POSIX.1e ACLs from file. */\n\tif (*fd >= 0)\n\t\taclp = sunacl_get(GETACL, &aclcnt, *fd, NULL);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\taclp = NULL;\n\telse\n\t\taclp = sunacl_get(GETACL, &aclcnt, 0, accpath);\n\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (aclp != NULL && sun_acl_is_trivial(aclp, aclcnt,\n\t    archive_entry_mode(entry), 0, S_ISDIR(archive_entry_mode(entry)),\n\t    &r) == 0 && r == 1) {\n\t\tfree(aclp);\n\t\taclp = NULL;\n\t}\n\n\tif (aclp != NULL)\n\t{\n\t\tr = translate_acl(a, entry, aclp, aclcnt,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);\n\t\tfree(aclp);\n\t\taclp = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate access ACLs\");\n\t\t\treturn (r);\n\t\t}\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}\n#endif\t/* ARCHIVE_ACL_SUNOS */\n"], "fixing_code": ["/*-\n * Copyright (c) 2003-2009 Tim Kientzle\n * Copyright (c) 2010-2012 Michihiro NAKAJIMA\n * Copyright (c) 2017 Martin Matuska\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#if ARCHIVE_ACL_FREEBSD\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#define _ACL_PRIVATE /* For debugging */\n#include <sys/acl.h>\n#endif\n\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_disk_private.h\"\n#include \"archive_write_disk_private.h\"\n\ntypedef struct {\n\tconst int a_perm;\t/* Libarchive permission or flag */\n\tconst int p_perm;\t/* Platform permission or flag */\n} acl_perm_map_t;\n\nstatic const acl_perm_map_t acl_posix_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},\n\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},\n};\n\nstatic const int acl_posix_perm_map_size =\n    (int)(sizeof(acl_posix_perm_map)/sizeof(acl_posix_perm_map[0]));\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\nstatic const acl_perm_map_t acl_nfs4_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACL_READ_DATA},\n\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACL_LIST_DIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACL_WRITE_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACL_ADD_FILE},\n\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACL_APPEND_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACL_ADD_SUBDIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACL_DELETE_CHILD},\n\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_DELETE, ACL_DELETE},\n\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACL_READ_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACL_WRITE_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACL_WRITE_OWNER},\n\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACL_SYNCHRONIZE}\n};\n\nstatic const int acl_nfs4_perm_map_size =\n    (int)(sizeof(acl_nfs4_perm_map)/sizeof(acl_nfs4_perm_map[0]));\n\nstatic const acl_perm_map_t acl_nfs4_flag_map[] = {\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_FILE_INHERIT},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_NO_PROPAGATE_INHERIT},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACL_ENTRY_INHERIT_ONLY},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACL_ENTRY_SUCCESSFUL_ACCESS},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACL_ENTRY_FAILED_ACCESS},\n#ifdef ACL_ENTRY_INHERITED\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACL_ENTRY_INHERITED}\n#endif\n};\n\nstatic const int acl_nfs4_flag_map_size =\n    (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n#endif /* ARCHIVE_ACL_FREEBSD_NFS4 */\n\nstatic int\ntranslate_acl(struct archive_read_disk *a,\n    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)\n{\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tint brand;\n\tacl_flagset_t\t acl_flagset;\n\tacl_entry_type_t acl_type;\n#endif\n\tacl_tag_t\t acl_tag;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\tint\t\t i, entry_acl_type, perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tint\t\t r, s, ae_id, ae_tag, ae_perm;\n\tvoid\t\t*q;\n\tconst char\t*ae_name;\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t// FreeBSD \"brands\" ACLs as POSIX.1e or NFSv4\n\t// Make sure the \"brand\" on this ACL is consistent\n\t// with the default_entry_acl_type bits provided.\n\tif (acl_get_brand_np(acl, &brand) != 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read ACL brand\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tswitch (brand) {\n\tcase ACL_BRAND_POSIX:\n\t\tswitch (default_entry_acl_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Invalid ACL entry type for POSIX.1e ACL\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tbreak;\n\tcase ACL_BRAND_NFS4:\n\t\tif (default_entry_acl_type & ~ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Invalid ACL entry type for NFSv4 ACL\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Unknown ACL brand\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n#endif\n\n\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);\n\tif (s == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get first ACL entry\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\twhile (s == 1) {\n\t\tae_id = -1;\n\t\tae_name = NULL;\n\t\tae_perm = 0;\n\n\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL tag type\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tswitch (acl_tag) {\n\t\tcase ACL_USER:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(uid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(gid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ACL_EVERYONE:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\t/* Skip types that libarchive can't support. */\n\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits\n\t\tentry_acl_type = default_entry_acl_type;\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_entry_type_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_entry_type_np(acl_entry, &acl_type) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno, \"Failed \"\n\t\t\t\t    \"to get ACL type from a NFSv4 ACL entry\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tswitch (acl_type) {\n\t\t\tcase ACL_ENTRY_TYPE_ALLOW:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\tbreak;\n\t\t\tcase ACL_ENTRY_TYPE_DENY:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t\tbreak;\n\t\t\tcase ACL_ENTRY_TYPE_AUDIT:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\tbreak;\n\t\t\tcase ACL_ENTRY_TYPE_ALARM:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Invalid NFSv4 ACL entry type\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Libarchive stores \"flag\" (NFSv4 inheritance bits)\n\t\t\t * in the ae_perm bitmap.\n\t\t\t *\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Failed to get flagset from a NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tr = acl_get_flag_np(acl_flagset,\n\t\t\t\t    acl_nfs4_flag_map[i].p_perm);\n\t\t\t\tif (r == -1) {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Failed to check flag in a NFSv4 \"\n\t\t\t\t\t    \"ACL flagset\");\n\t\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t\t} else if (r)\n\t\t\t\t\tae_perm |= acl_nfs4_flag_map[i].a_perm;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (default_entry_acl_type & ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tr = acl_get_perm_np(acl_permset, perm_map[i].p_perm);\n\t\t\tif (r == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Failed to check permission in an ACL \"\n\t\t\t\t    \"permission set\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t} else if (r)\n\t\t\t\tae_perm |= perm_map[i].a_perm;\n\t\t}\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t\t\t\t    ae_perm, ae_tag,\n\t\t\t\t\t    ae_id, ae_name);\n\n\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get next ACL entry\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n\t\terrno = EINVAL;\n\t\tarchive_set_error(a, errno,\n\t\t    \"Cannot set default ACL on non-directory\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (S_ISLNK(mode)) {\n\t    /* acl_set_file() follows symbolic links, skip */\n\t    ret = ARCHIVE_OK;\n\t} else if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}\n\nint\narchive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n    struct archive_entry *entry, int *fd)\n{\n\tconst char\t*accpath;\n\tacl_t\t\tacl;\n\tint\t\tr;\n\n\taccpath = NULL;\n\n\tif (*fd < 0) {\n\t\taccpath = archive_read_disk_entry_setup_path(a, entry, fd);\n\t\tif (accpath == NULL)\n\t\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tarchive_entry_acl_clear(entry);\n\n\tacl = NULL;\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t/* Try NFSv4 ACL first. */\n\tif (*fd >= 0)\n\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_NFS4);\n\telse if (!a->follow_symlinks)\n\t\tacl = acl_get_link_np(accpath, ACL_TYPE_NFS4);\n\telse\n\t\tacl = acl_get_file(accpath, ACL_TYPE_NFS4);\n\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0 && r == 1) {\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (acl != NULL) {\n\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_NFS4);\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate NFSv4 ACLs\");\n\t\t}\n\n\t\treturn (r);\n\t}\n#endif\n\n\t/* Retrieve access ACL from file. */\n\tif (*fd >= 0)\n\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_ACCESS);\n#if HAVE_ACL_GET_LINK_NP\n\telse if (!a->follow_symlinks)\n\t\tacl = acl_get_link_np(accpath, ACL_TYPE_ACCESS);\n#else\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\tacl = NULL;\n#endif\n\telse\n\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);\n\n#if HAVE_ACL_IS_TRIVIAL_NP\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (acl != NULL && acl_is_trivial_np(acl, &r) == 0 && r == 1) {\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\t}\n#endif\n\n\tif (acl != NULL) {\n\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate access ACLs\");\n\t\t\treturn (r);\n\t\t}\n\t}\n\n\t/* Only directories can have default ACLs. */\n\tif (S_ISDIR(archive_entry_mode(entry))) {\n\t\tif (*fd >= 0)\n\t\t\tacl = acl_get_fd_np(*fd, ACL_TYPE_DEFAULT);\n\t\telse\n\t\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);\n\t\tif (acl != NULL) {\n\t\t\tr = translate_acl(a, entry, acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);\n\t\t\tacl_free(acl);\n\t\t\tif (r != ARCHIVE_OK) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Couldn't translate default ACLs\");\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}\n#endif\t/* ARCHIVE_ACL_FREEBSD */\n", "/*-\n * Copyright (c) 2003-2009 Tim Kientzle\n * Copyright (c) 2010-2012 Michihiro NAKAJIMA\n * Copyright (c) 2017 Martin Matuska\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#if ARCHIVE_ACL_LIBACL || ARCHIVE_ACL_LIBRICHACL\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if HAVE_ACL_LIBACL_H\n#include <acl/libacl.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#include <sys/acl.h>\n#endif\n#ifdef HAVE_SYS_RICHACL_H\n#include <sys/richacl.h>\n#endif\n\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_disk_private.h\"\n#include \"archive_write_disk_private.h\"\n\ntypedef struct {\n\tconst int a_perm;\t/* Libarchive permission or flag */\n\tconst int p_perm;\t/* Platform permission or flag */\n} acl_perm_map_t;\n\n#if ARCHIVE_ACL_LIBACL\nstatic const acl_perm_map_t acl_posix_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACL_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_WRITE, ACL_WRITE},\n\t{ARCHIVE_ENTRY_ACL_READ, ACL_READ},\n};\n\nstatic const int acl_posix_perm_map_size =\n    (int)(sizeof(acl_posix_perm_map)/sizeof(acl_posix_perm_map[0]));\n#endif /* ARCHIVE_ACL_LIBACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\nstatic const acl_perm_map_t acl_nfs4_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, RICHACE_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_READ_DATA, RICHACE_READ_DATA},\n\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, RICHACE_LIST_DIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, RICHACE_WRITE_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_FILE, RICHACE_ADD_FILE},\n\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, RICHACE_APPEND_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, RICHACE_ADD_SUBDIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, RICHACE_READ_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, RICHACE_WRITE_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, RICHACE_DELETE_CHILD},\n\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, RICHACE_READ_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, RICHACE_WRITE_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_DELETE, RICHACE_DELETE},\n\t{ARCHIVE_ENTRY_ACL_READ_ACL, RICHACE_READ_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, RICHACE_WRITE_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, RICHACE_WRITE_OWNER},\n\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, RICHACE_SYNCHRONIZE}\n};\n\nstatic const int acl_nfs4_perm_map_size =\n    (int)(sizeof(acl_nfs4_perm_map)/sizeof(acl_nfs4_perm_map[0]));\n\nstatic const acl_perm_map_t acl_nfs4_flag_map[] = {\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, RICHACE_FILE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, RICHACE_DIRECTORY_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, RICHACE_NO_PROPAGATE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, RICHACE_INHERIT_ONLY_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, RICHACE_INHERITED_ACE}\n};\n\nstatic const int acl_nfs4_flag_map_size =\n    (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n#endif /* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBACL\n/*\n * Translate POSIX.1e ACLs into libarchive internal structure\n */\nstatic int\ntranslate_acl(struct archive_read_disk *a,\n    struct archive_entry *entry, acl_t acl, int default_entry_acl_type)\n{\n\tacl_tag_t\t acl_tag;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\tint\t\t i, entry_acl_type;\n\tint\t\t r, s, ae_id, ae_tag, ae_perm;\n\tvoid\t\t*q;\n\tconst char\t*ae_name;\n\n\ts = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_entry);\n\tif (s == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get first ACL entry\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\twhile (s == 1) {\n\t\tae_id = -1;\n\t\tae_name = NULL;\n\t\tae_perm = 0;\n\n\t\tif (acl_get_tag_type(acl_entry, &acl_tag) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL tag type\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tswitch (acl_tag) {\n\t\tcase ACL_USER:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(uid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tq = acl_get_qualifier(acl_entry);\n\t\t\tif (q != NULL) {\n\t\t\t\tae_id = (int)*(gid_t *)q;\n\t\t\t\tacl_free(q);\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Skip types that libarchive can't support. */\n\t\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// XXX acl_type maps to allow/deny/audit/YYYY bits\n\t\tentry_acl_type = default_entry_acl_type;\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\tr = acl_get_perm(acl_permset,\n\t\t\t    acl_posix_perm_map[i].p_perm);\n\t\t\tif (r == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Failed to check permission in an ACL \"\n\t\t\t\t    \"permission set\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t} else if (r)\n\t\t\t\tae_perm |= acl_posix_perm_map[i].a_perm;\n\t\t}\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t\t\t\t    ae_perm, ae_tag,\n\t\t\t\t\t    ae_id, ae_name);\n\n\t\ts = acl_get_entry(acl, ACL_NEXT_ENTRY, &acl_entry);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get next ACL entry\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n#endif /* ARCHIVE_ACL_LIBACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\n/*\n * Translate RichACL into libarchive internal ACL\n */\nstatic int\ntranslate_richacl(struct archive_read_disk *a, struct archive_entry *entry,\n    struct richacl *richacl)\n{\n\tint ae_id, ae_tag, ae_perm;\n\tint entry_acl_type, i;\n\tconst char *ae_name;\n\n\tstruct richace *richace;\n\n\trichacl_for_each_entry(richace, richacl) {\n\t\tae_name = NULL;\n\t\tae_tag = 0;\n\t\tae_perm = 0;\n\t\tae_id = -1;\n\n\t\tswitch (richace->e_type) {\n\t\tcase RICHACE_ACCESS_ALLOWED_ACE_TYPE:\n\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\tbreak;\n\t\tcase RICHACE_ACCESS_DENIED_ACE_TYPE:\n\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\tbreak;\n\t\tdefault: /* Unknown entry type, skip */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Unsupported */\n\t\tif (richace->e_flags & RICHACE_UNMAPPED_WHO)\n\t\t\tcontinue;\n\n\t\tif (richace->e_flags & RICHACE_SPECIAL_WHO) {\n\t\t\tswitch (richace->e_id) {\n\t\t\tcase RICHACE_OWNER_SPECIAL_ID:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase RICHACE_GROUP_SPECIAL_ID:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase RICHACE_EVERYONE_SPECIAL_ID:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault: /* Unknown special ID type */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tae_id = richace->e_id;\n\t\t\tif (richace->e_flags & RICHACE_IDENTIFIER_GROUP) {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    (gid_t)(richace->e_id));\n\t\t\t} else {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    (uid_t)(richace->e_id));\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\tif ((richace->e_flags &\n\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0)\n\t\t\t\tae_perm |= acl_nfs4_flag_map[i].a_perm;\n\t\t}\n\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\tif ((richace->e_mask &\n\t\t\t    acl_nfs4_perm_map[i].p_perm) != 0)\n\t\t\t\tae_perm |=\n\t\t\t\t    acl_nfs4_perm_map[i].a_perm;\n\t\t}\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t    ae_perm, ae_tag, ae_id, ae_name);\n\t}\n\treturn (ARCHIVE_OK);\n}\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\nstatic int\n_richacl_mode_to_mask(short mode)\n{\n\tint mask = 0;\n\n\tif (mode & S_IROTH)\n\t\tmask |= RICHACE_POSIX_MODE_READ;\n\tif (mode & S_IWOTH)\n\t\tmask |= RICHACE_POSIX_MODE_WRITE;\n\tif (mode & S_IXOTH)\n\t\tmask |= RICHACE_POSIX_MODE_EXEC;\n\n\treturn (mask);\n}\n\nstatic void\n_richacl_mode_to_masks(struct richacl *richacl, __LA_MODE_T mode)\n{\n\trichacl->a_owner_mask = _richacl_mode_to_mask((mode & 0700) >> 6);\n\trichacl->a_group_mask = _richacl_mode_to_mask((mode & 0070) >> 3);\n\trichacl->a_other_mask = _richacl_mode_to_mask(mode & 0007);\n}\n#endif /* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBRICHACL\nstatic int\nset_richacl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tint\t\t e = 0;\n\tstruct richacl  *richacl = NULL;\n\tstruct richace  *richace;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (ae_requested_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* Linux does not support RichACLs on symbolic links */\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\trichacl = richacl_alloc(entries);\n\tif (richacl == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t\t\"Failed to initialize RichACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\trichace = &(richacl->a_entries[e]);\n\n\t\trichace->e_flags = 0;\n\t\trichace->e_mask = 0;\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_uid;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_gid;\n\t\t\trichace->e_flags |= RICHACE_IDENTIFIER_GROUP;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_OWNER_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_GROUP_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_EVERYONE_SPECIAL_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_type) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_nfs4_perm_map[i].a_perm)\n\t\t\t\trichace->e_mask |= acl_nfs4_perm_map[i].p_perm;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\tif (ae_permset &\n\t\t\t    acl_nfs4_flag_map[i].a_perm)\n\t\t\t\trichace->e_flags |= acl_nfs4_flag_map[i].p_perm;\n\t\t}\n\te++;\n\t}\n\n\t/* Fill RichACL masks */\n\t_richacl_mode_to_masks(richacl, mode);\n\n\tif (fd >= 0) {\n\t\tif (richacl_set_fd(fd, richacl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set richacl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (richacl_set_file(name, richacl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set richacl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\trichacl_free(richacl);\n\treturn (ret);\n}\n#endif /* ARCHIVE_ACL_RICHACL */\n\n#if ARCHIVE_ACL_LIBACL\nstatic int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tacl_t\t\t acl = NULL;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* Linux does not support ACLs on symbolic links */\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n\t\terrno = EINVAL;\n\t\tarchive_set_error(a, errno,\n\t\t    \"Cannot set default ACL on non-directory\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_posix_perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    acl_posix_perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {\n\t\tif (acl_set_fd(fd, acl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl_set_file(name, acl_type, acl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}\n#endif /* ARCHIVE_ACL_LIBACL */\n\nint\narchive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n    struct archive_entry *entry, int *fd)\n{\n\tconst char\t*accpath;\n\tint\t\tr;\n#if ARCHIVE_ACL_LIBACL\n\tacl_t\t\tacl;\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tstruct richacl *richacl;\n\tmode_t\t\tmode;\n#endif\n\n\taccpath = NULL;\n\tr = ARCHIVE_OK;\n\n\t/* For default ACLs we need reachable accpath */\n\tif (*fd < 0 || S_ISDIR(archive_entry_mode(entry))) {\n\t\taccpath = archive_read_disk_entry_setup_path(a, entry, fd);\n\t\tif (accpath == NULL)\n\t\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tarchive_entry_acl_clear(entry);\n\n#if ARCHIVE_ACL_LIBACL\n\tacl = NULL;\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\trichacl = NULL;\n#endif\n\n#if ARCHIVE_ACL_LIBRICHACL\n\t/* Try NFSv4 ACL first. */\n\tif (*fd >= 0)\n\t\trichacl = richacl_get_fd(*fd);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one */\n\t\trichacl = NULL;\n\telse\n\t\trichacl = richacl_get_file(accpath);\n\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (richacl != NULL) {\n\t\tmode = archive_entry_mode(entry);\n\t\tif (richacl_equiv_mode(richacl, &mode) == 0) {\n\t\t\trichacl_free(richacl);\n\t\t\trichacl = NULL;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t}\n\n\tif (richacl != NULL) {\n\t\tr = translate_richacl(a, entry, richacl);\n\t\trichacl_free(richacl);\n\t\trichacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\"Couldn't translate NFSv4 ACLs\");\n\t\t}\n\n\t\treturn (r);\n\t}\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n\n#if ARCHIVE_ACL_LIBACL\n\t/* Retrieve access ACL from file. */\n\tif (*fd >= 0)\n\t\tacl = acl_get_fd(*fd);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\tacl = NULL;\n\telse\n\t\tacl = acl_get_file(accpath, ACL_TYPE_ACCESS);\n\n\tif (acl != NULL) {\n\t\tr = translate_acl(a, entry, acl, ARCHIVE_ENTRY_ACL_TYPE_ACCESS);\n\t\tacl_free(acl);\n\t\tacl = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate access ACLs\");\n\t\t\treturn (r);\n\t\t}\n\t}\n\n\t/* Only directories can have default ACLs. */\n\tif (S_ISDIR(archive_entry_mode(entry))) {\n\t\tacl = acl_get_file(accpath, ACL_TYPE_DEFAULT);\n\t\tif (acl != NULL) {\n\t\t\tr = translate_acl(a, entry, acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);\n\t\t\tacl_free(acl);\n\t\t\tif (r != ARCHIVE_OK) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Couldn't translate default ACLs\");\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* ARCHIVE_ACL_LIBACL */\n\treturn (r);\n}\n\nint\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t/* UNUSED */\n#endif\n\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t/* ARCHIVE_ACL_LIBACL */\n\treturn (ret);\n}\n#endif /* ARCHIVE_ACL_LIBACL || ARCHIVE_ACL_LIBRICHACL */\n", "/*-\n * Copyright (c) 2017 Martin Matuska\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#if ARCHIVE_ACL_SUNOS\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#define _ACL_PRIVATE /* For debugging */\n#include <sys/acl.h>\n#endif\n\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_disk_private.h\"\n#include \"archive_write_disk_private.h\"\n\ntypedef struct {\n\tconst int a_perm;\t/* Libarchive permission or flag */\n\tconst int p_perm;\t/* Platform permission or flag */\n} acl_perm_map_t;\n\nstatic const acl_perm_map_t acl_posix_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, S_IXOTH },\n\t{ARCHIVE_ENTRY_ACL_WRITE, S_IWOTH },\n\t{ARCHIVE_ENTRY_ACL_READ, S_IROTH }\n};\n\nstatic const int acl_posix_perm_map_size =\n    (int)(sizeof(acl_posix_perm_map)/sizeof(acl_posix_perm_map[0]));\n\n#if ARCHIVE_ACL_SUNOS_NFS4\nstatic const acl_perm_map_t acl_nfs4_perm_map[] = {\n\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACE_EXECUTE},\n\t{ARCHIVE_ENTRY_ACL_READ_DATA, ACE_READ_DATA},\n\t{ARCHIVE_ENTRY_ACL_LIST_DIRECTORY, ACE_LIST_DIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_WRITE_DATA, ACE_WRITE_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_FILE, ACE_ADD_FILE},\n\t{ARCHIVE_ENTRY_ACL_APPEND_DATA, ACE_APPEND_DATA},\n\t{ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY, ACE_ADD_SUBDIRECTORY},\n\t{ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS, ACE_READ_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS, ACE_WRITE_NAMED_ATTRS},\n\t{ARCHIVE_ENTRY_ACL_DELETE_CHILD, ACE_DELETE_CHILD},\n\t{ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES, ACE_READ_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES, ACE_WRITE_ATTRIBUTES},\n\t{ARCHIVE_ENTRY_ACL_DELETE, ACE_DELETE},\n\t{ARCHIVE_ENTRY_ACL_READ_ACL, ACE_READ_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_ACL, ACE_WRITE_ACL},\n\t{ARCHIVE_ENTRY_ACL_WRITE_OWNER, ACE_WRITE_OWNER},\n\t{ARCHIVE_ENTRY_ACL_SYNCHRONIZE, ACE_SYNCHRONIZE}\n};\n\nstatic const int acl_nfs4_perm_map_size =\n    (int)(sizeof(acl_nfs4_perm_map)/sizeof(acl_nfs4_perm_map[0]));\n\nstatic const acl_perm_map_t acl_nfs4_flag_map[] = {\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACE_FILE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT, ACE_DIRECTORY_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT, ACE_NO_PROPAGATE_INHERIT_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY, ACE_INHERIT_ONLY_ACE},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS, ACE_SUCCESSFUL_ACCESS_ACE_FLAG},\n\t{ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS, ACE_FAILED_ACCESS_ACE_FLAG},\n#ifdef ACE_INHERITED_ACE\n\t{ARCHIVE_ENTRY_ACL_ENTRY_INHERITED, ACE_INHERITED_ACE}\n#endif\n};\n\nconst int acl_nfs4_flag_map_size =\n    (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n\n#endif /* ARCHIVE_ACL_SUNOS_NFS4 */\n\nstatic void *\nsunacl_get(int cmd, int *aclcnt, int fd, const char *path)\n{\n\tint cnt, cntcmd;\n\tsize_t size;\n\tvoid *aclp;\n\n\tif (cmd == GETACL) {\n\t\tcntcmd = GETACLCNT;\n\t\tsize = sizeof(aclent_t);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if (cmd == ACE_GETACL) {\n\t\tcntcmd = ACE_GETACLCNT;\n\t\tsize = sizeof(ace_t);\n\t}\n#endif\n\telse {\n\t\terrno = EINVAL;\n\t\t*aclcnt = -1;\n\t\treturn (NULL);\n\t}\n\n\taclp = NULL;\n\tcnt = -2;\n\n\twhile (cnt == -2 || (cnt == -1 && errno == ENOSPC)) {\n\t\tif (path != NULL)\n\t\t\tcnt = acl(path, cntcmd, 0, NULL);\n\t\telse\n\t\t\tcnt = facl(fd, cntcmd, 0, NULL);\n\n\t\tif (cnt > 0) {\n\t\t\tif (aclp == NULL)\n\t\t\t\taclp = malloc(cnt * size);\n\t\t\telse\n\t\t\t\taclp = realloc(NULL, cnt * size);\n\t\t\tif (aclp != NULL) {\n\t\t\t\tif (path != NULL)\n\t\t\t\t\tcnt = acl(path, cmd, cnt, aclp);\n\t\t\t\telse\n\t\t\t\t\tcnt = facl(fd, cmd, cnt, aclp);\n\t\t\t}\n\t\t} else {\n\t\t\tfree(aclp);\n\t\t\taclp = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*aclcnt = cnt;\n\treturn (aclp);\n}\n\n/*\n * Check if acl is trivial\n * This is a FreeBSD acl_is_trivial_np() implementation for Solaris\n */\nstatic int\nsun_acl_is_trivial(void *aclp, int aclcnt, mode_t mode, int is_nfs4,\n    int is_dir, int *trivialp)\n{\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tint i, p;\n\tconst uint32_t rperm = ACE_READ_DATA;\n\tconst uint32_t wperm = ACE_WRITE_DATA | ACE_APPEND_DATA;\n\tconst uint32_t eperm = ACE_EXECUTE;\n\tconst uint32_t pubset = ACE_READ_ATTRIBUTES | ACE_READ_NAMED_ATTRS |\n\t    ACE_READ_ACL | ACE_SYNCHRONIZE;\n\tconst uint32_t ownset = pubset | ACE_WRITE_ATTRIBUTES |\n\t    ACE_WRITE_NAMED_ATTRS | ACE_WRITE_ACL | ACE_WRITE_OWNER;\n\n\tace_t *ace;\n\tace_t tace[6];\n#endif\n\n\tif (aclp == NULL || trivialp == NULL)\n\t\treturn (-1);\n\n\t*trivialp = 0;\n\n\t/*\n\t * POSIX.1e ACLs marked with ACL_IS_TRIVIAL are compatible with\n\t * FreeBSD acl_is_trivial_np(). On Solaris they have 4 entries,\n\t * including mask.\n\t */\n\tif (!is_nfs4) {\n\t\tif (aclcnt == 4)\n\t\t\t*trivialp = 1;\n\t\treturn (0);\n\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t/*\n\t * Continue with checking NFSv4 ACLs\n\t *\n\t * Create list of trivial ace's to be compared\n\t */\n\n\t/* owner@ allow pre */\n\ttace[0].a_flags = ACE_OWNER;\n\ttace[0].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[0].a_access_mask = 0;\n\n\t/* owner@ deny */\n\ttace[1].a_flags = ACE_OWNER;\n\ttace[1].a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\ttace[1].a_access_mask = 0;\n\n\t/* group@ deny */\n\ttace[2].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;\n\ttace[2].a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\ttace[2].a_access_mask = 0;\n\n\t/* owner@ allow */\n\ttace[3].a_flags = ACE_OWNER;\n\ttace[3].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[3].a_access_mask = ownset;\n\n\t/* group@ allow */\n\ttace[4].a_flags = ACE_GROUP | ACE_IDENTIFIER_GROUP;\n\ttace[4].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[4].a_access_mask = pubset;\n\n\t/* everyone@ allow */\n\ttace[5].a_flags = ACE_EVERYONE;\n\ttace[5].a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\ttace[5].a_access_mask = pubset;\n\n\t/* Permissions for everyone@ */\n\tif (mode & 0004)\n\t\ttace[5].a_access_mask |= rperm;\n\tif (mode & 0002)\n\t\ttace[5].a_access_mask |= wperm;\n\tif (mode & 0001)\n\t\ttace[5].a_access_mask |= eperm;\n\n\t/* Permissions for group@ */\n\tif (mode & 0040)\n\t\ttace[4].a_access_mask |= rperm;\n\telse if (mode & 0004)\n\t\ttace[2].a_access_mask |= rperm;\n\tif (mode & 0020)\n\t\ttace[4].a_access_mask |= wperm;\n\telse if (mode & 0002)\n\t\ttace[2].a_access_mask |= wperm;\n\tif (mode & 0010)\n\t\ttace[4].a_access_mask |= eperm;\n\telse if (mode & 0001)\n\t\ttace[2].a_access_mask |= eperm;\n\n\t/* Permissions for owner@ */\n\tif (mode & 0400) {\n\t\ttace[3].a_access_mask |= rperm;\n\t\tif (!(mode & 0040) && (mode & 0004))\n\t\t\ttace[0].a_access_mask |= rperm;\n\t} else if ((mode & 0040) || (mode & 0004))\n\t\ttace[1].a_access_mask |= rperm;\n\tif (mode & 0200) {\n\t\ttace[3].a_access_mask |= wperm;\n\t\tif (!(mode & 0020) && (mode & 0002))\n\t\t\ttace[0].a_access_mask |= wperm;\n\t} else if ((mode & 0020) || (mode & 0002))\n\t\ttace[1].a_access_mask |= wperm;\n\tif (mode & 0100) {\n\t\ttace[3].a_access_mask |= eperm;\n\t\tif (!(mode & 0010) && (mode & 0001))\n\t\t\ttace[0].a_access_mask |= eperm;\n\t} else if ((mode & 0010) || (mode & 0001))\n\t\ttace[1].a_access_mask |= eperm;\n\n\t/* Check if the acl count matches */\n\tp = 3;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (tace[i].a_access_mask != 0)\n\t\t\tp++;\n\t}\n\tif (aclcnt != p)\n\t\treturn (0);\n\n\tp = 0;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (tace[i].a_access_mask != 0) {\n\t\t\tace = &((ace_t *)aclp)[p];\n\t\t\t/*\n\t\t\t * Illumos added ACE_DELETE_CHILD to write perms for\n\t\t\t * directories. We have to check against that, too.\n\t\t\t */\n\t\t\tif (ace->a_flags != tace[i].a_flags ||\n\t\t\t    ace->a_type != tace[i].a_type ||\n\t\t\t    (ace->a_access_mask != tace[i].a_access_mask &&\n\t\t\t    (!is_dir || (tace[i].a_access_mask & wperm) == 0 ||\n\t\t\t    ace->a_access_mask !=\n\t\t\t    (tace[i].a_access_mask | ACE_DELETE_CHILD))))\n\t\t\t\treturn (0);\n\t\t\tp++;\n\t\t}\n\t}\n\n\t*trivialp = 1;\n#else\t/* !ARCHIVE_ACL_SUNOS_NFS4 */\n\t(void)is_dir;\t/* UNUSED */\n\t(void)aclp;\t/* UNUSED */\n#endif\t/* !ARCHIVE_ACL_SUNOS_NFS4 */\n\treturn (0);\n}\n\n/*\n * Translate Solaris POSIX.1e and NFSv4 ACLs into libarchive internal ACL\n */\nstatic int\ntranslate_acl(struct archive_read_disk *a,\n    struct archive_entry *entry, void *aclp, int aclcnt,\n    int default_entry_acl_type)\n{\n\tint e, i;\n\tint ae_id, ae_tag, ae_perm;\n\tint entry_acl_type;\n\tconst char *ae_name;\n\taclent_t *aclent;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tace_t *ace;\n#endif\n\n\tif (aclcnt <= 0)\n\t\treturn (ARCHIVE_OK);\n\n\tfor (e = 0; e < aclcnt; e++) {\n\t\tae_name = NULL;\n\t\tae_tag = 0;\n\t\tae_perm = 0;\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (default_entry_acl_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tace = &((ace_t *)aclp)[e];\n\t\t\tae_id = ace->a_who;\n\n\t\t\tswitch(ace->a_type) {\n\t\t\tcase ACE_ACCESS_ALLOWED_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\tbreak;\n\t\t\tcase ACE_ACCESS_DENIED_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t\tbreak;\n\t\t\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t\t\tbreak;\n\t\t\tcase ACE_SYSTEM_ALARM_ACE_TYPE:\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown entry type, skip */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((ace->a_flags & ACE_OWNER) != 0)\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\telse if ((ace->a_flags & ACE_GROUP) != 0)\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\telse if ((ace->a_flags & ACE_EVERYONE) != 0)\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\telse if ((ace->a_flags & ACE_IDENTIFIER_GROUP) != 0) {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t} else {\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif ((ace->a_flags &\n\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0)\n\t\t\t\t\tae_perm |= acl_nfs4_flag_map[i].a_perm;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\t\tif ((ace->a_access_mask &\n\t\t\t\t    acl_nfs4_perm_map[i].p_perm) != 0)\n\t\t\t\t\tae_perm |= acl_nfs4_perm_map[i].a_perm;\n\t\t\t}\n\t\t} else\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\t\tif (default_entry_acl_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {\n\t\t\taclent = &((aclent_t *)aclp)[e];\n\t\t\tif ((aclent->a_type & ACL_DEFAULT) != 0)\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\telse\n\t\t\t\tentry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t\tae_id = aclent->a_id;\n\n\t\t\tswitch(aclent->a_type) {\n\t\t\tcase DEF_USER:\n\t\t\tcase USER:\n\t\t\t\tae_name = archive_read_disk_uname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase DEF_GROUP:\n\t\t\tcase GROUP:\n\t\t\t\tae_name = archive_read_disk_gname(&a->archive,\n\t\t\t\t    ae_id);\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase DEF_CLASS_OBJ:\n\t\t\tcase CLASS_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tcase DEF_USER_OBJ:\n\t\t\tcase USER_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase DEF_GROUP_OBJ:\n\t\t\tcase GROUP_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase DEF_OTHER_OBJ:\n\t\t\tcase OTHER_OBJ:\n\t\t\t\tae_tag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown tag type, skip */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\t\tif ((aclent->a_perm &\n\t\t\t\t    acl_posix_perm_map[i].p_perm) != 0)\n\t\t\t\t\tae_perm |= acl_posix_perm_map[i].a_perm;\n\t\t\t}\n\t\t} else\n\t\t\treturn (ARCHIVE_WARN);\n\n\t\tarchive_entry_acl_add_entry(entry, entry_acl_type,\n\t\t    ae_perm, ae_tag, ae_id, ae_name);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\taclent_t\t *aclent;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tace_t\t\t *ace;\n#endif\n\tint\t\t cmd, e, r;\n\tvoid\t\t *aclp;\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\tcmd = SETACL;\n\t\taclp = malloc(entries * sizeof(aclent_t));\n\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tcmd = ACE_SETACL;\n\t\taclp = malloc(entries * sizeof(ace_t));\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (aclp == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Can't allocate memory for acl buffer\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n        if (S_ISLNK(mode)) {\n                /* Skip ACLs on symbolic links */\n\t\tret = ARCHIVE_OK;\n\t\tgoto exit_free;\n        }\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\taclent = NULL;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tace = NULL;\n#endif\n\t\tif (cmd == SETACL) {\n\t\t\taclent = &((aclent_t *)aclp)[e];\n\t\t\taclent->a_id = -1;\n\t\t\taclent->a_type = 0;\n\t\t\taclent->a_perm = 0;\n\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\telse {\t/* cmd == ACE_SETACL */\n\t\t\tace = &((ace_t *)aclp)[e];\n\t\t\tace->a_who = -1;\n\t\t\tace->a_access_mask = 0;\n\t\t\tace->a_flags = 0;\n\t\t}\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_uid;\n\t\t\t\taclent->a_type |= USER;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_uid;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_gid;\n\t\t\t\taclent->a_type |= GROUP;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_gid;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= USER_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_OWNER;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= GROUP_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_GROUP;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= CLASS_OBJ;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= OTHER_OBJ;\n\t\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_flags |= ACE_EVERYONE;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tr = 0;\n\t\tswitch (ae_type) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n#endif\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\t\tif (aclent == NULL)\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= ACL_DEFAULT;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\terrno = EINVAL;\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t}\n#endif\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\t\tif (ae_requested_type ==\n\t\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4)\n\t\t\t\t\tace->a_access_mask |=\n\t\t\t\t\t    perm_map[i].p_perm;\n\t\t\t\telse\n#endif\n\t\t\t\t\taclent->a_perm |= perm_map[i].p_perm;\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tace->a_flags |=\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\te++;\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (facl(fd, cmd, entries, aclp) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl(name, cmd, entries, aclp) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tfree(aclp);\n\treturn (ret);\n}\n\nint\narchive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n    struct archive_entry *entry, int *fd)\n{\n\tconst char\t*accpath;\n\tvoid\t\t*aclp;\n\tint\t\taclcnt;\n\tint\t\tr;\n\n\taccpath = NULL;\n\n\tif (*fd < 0) {\n\t\taccpath = archive_read_disk_entry_setup_path(a, entry, fd);\n\t\tif (accpath == NULL)\n\t\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tarchive_entry_acl_clear(entry);\n\n\taclp = NULL;\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tif (*fd >= 0)\n\t\taclp = sunacl_get(ACE_GETACL, &aclcnt, *fd, NULL);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\taclp = NULL;\n\telse\n\t\taclp = sunacl_get(ACE_GETACL, &aclcnt, 0, accpath);\n\n\tif (aclp != NULL && sun_acl_is_trivial(aclp, aclcnt,\n\t    archive_entry_mode(entry), 1, S_ISDIR(archive_entry_mode(entry)),\n\t    &r) == 0 && r == 1) {\n\t\tfree(aclp);\n\t\taclp = NULL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (aclp != NULL) {\n\t\tr = translate_acl(a, entry, aclp, aclcnt,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4);\n\t\tfree(aclp);\n\t\taclp = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate NFSv4 ACLs\");\n\t\t}\n\t\treturn (r);\n\t}\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\n\t/* Retrieve POSIX.1e ACLs from file. */\n\tif (*fd >= 0)\n\t\taclp = sunacl_get(GETACL, &aclcnt, *fd, NULL);\n\telse if ((!a->follow_symlinks)\n\t    && (archive_entry_filetype(entry) == AE_IFLNK))\n\t\t/* We can't get the ACL of a symlink, so we assume it can't\n\t\t   have one. */\n\t\taclp = NULL;\n\telse\n\t\taclp = sunacl_get(GETACL, &aclcnt, 0, accpath);\n\n\t/* Ignore \"trivial\" ACLs that just mirror the file mode. */\n\tif (aclp != NULL && sun_acl_is_trivial(aclp, aclcnt,\n\t    archive_entry_mode(entry), 0, S_ISDIR(archive_entry_mode(entry)),\n\t    &r) == 0 && r == 1) {\n\t\tfree(aclp);\n\t\taclp = NULL;\n\t}\n\n\tif (aclp != NULL)\n\t{\n\t\tr = translate_acl(a, entry, aclp, aclcnt,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);\n\t\tfree(aclp);\n\t\taclp = NULL;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Couldn't translate access ACLs\");\n\t\t\treturn (r);\n\t\t}\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}\n#endif\t/* ARCHIVE_ACL_SUNOS */\n"], "filenames": ["libarchive/archive_disk_acl_freebsd.c", "libarchive/archive_disk_acl_linux.c", "libarchive/archive_disk_acl_sunos.c"], "buggy_code_start_loc": [322, 345, 446], "buggy_code_end_loc": [697, 738, 814], "fixing_code_start_loc": [322, 346, 446], "fixing_code_end_loc": [707, 755, 819], "type": "CWE-59", "message": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.", "other": {"cve": {"id": "CVE-2021-23177", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:09.280", "lastModified": "2022-12-03T14:16:24.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges."}, {"lang": "es", "value": "Un fallo de resoluci\u00f3n de enlaces inapropiado mientras es extra\u00eddo un archivo puede conllevar a un cambio de la lista de control de acceso (ACL) del objetivo del enlace. Un atacante puede proporcionar un archivo malicioso a un usuario v\u00edctima, que desencadenar\u00eda este fallo cuando intentara extraer el archivo. Un atacante local puede usar este fallo para cambiar la ACL de un archivo en el sistema y conseguir m\u00e1s privilegios."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.5.2", "matchCriteriaId": "A55FBDE8-F405-4C72-BCDC-756873D578C9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "6C3741B8-851F-475D-B428-523F4F722350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87C21FE1-EA5C-498F-9C6C-D05F91A88217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "9EF5C4AC-CA69-41E3-AD93-7AC21931374A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "729C515E-1DD3-466D-A50B-AFE058FFC94A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "76C24D94-834A-4E9D-8F73-624AFA99AAA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "871A5C26-DB7B-4870-A5B2-5DD24C90B4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "1272DF03-7674-4BD4-8E64-94004B195448"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder:-:*:*:*:*:*:*:*", "matchCriteriaId": "1CD81C46-328B-412D-AF4E-68A2AD2F1A73"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "6C3741B8-851F-475D-B428-523F4F722350"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87C21FE1-EA5C-498F-9C6C-D05F91A88217"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "9EF5C4AC-CA69-41E3-AD93-7AC21931374A"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "729C515E-1DD3-466D-A50B-AFE058FFC94A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-23177", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024245", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/issues/1565", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00030.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad"}}