{"buggy_code": ["/*\n * Copyright (c) 2013-2015, Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/module.h>\n#include <rdma/ib_umem.h>\n#include <rdma/ib_cache.h>\n#include <rdma/ib_user_verbs.h>\n#include <linux/mlx5/fs.h>\n#include \"mlx5_ib.h\"\n#include \"ib_rep.h\"\n\n/* not supported currently */\nstatic int wq_signature;\n\nenum {\n\tMLX5_IB_ACK_REQ_FREQ\t= 8,\n};\n\nenum {\n\tMLX5_IB_DEFAULT_SCHED_QUEUE\t= 0x83,\n\tMLX5_IB_DEFAULT_QP0_SCHED_QUEUE\t= 0x3f,\n\tMLX5_IB_LINK_TYPE_IB\t\t= 0,\n\tMLX5_IB_LINK_TYPE_ETH\t\t= 1\n};\n\nenum {\n\tMLX5_IB_SQ_STRIDE\t= 6,\n\tMLX5_IB_SQ_UMR_INLINE_THRESHOLD = 64,\n};\n\nstatic const u32 mlx5_ib_opcode[] = {\n\t[IB_WR_SEND]\t\t\t\t= MLX5_OPCODE_SEND,\n\t[IB_WR_LSO]\t\t\t\t= MLX5_OPCODE_LSO,\n\t[IB_WR_SEND_WITH_IMM]\t\t\t= MLX5_OPCODE_SEND_IMM,\n\t[IB_WR_RDMA_WRITE]\t\t\t= MLX5_OPCODE_RDMA_WRITE,\n\t[IB_WR_RDMA_WRITE_WITH_IMM]\t\t= MLX5_OPCODE_RDMA_WRITE_IMM,\n\t[IB_WR_RDMA_READ]\t\t\t= MLX5_OPCODE_RDMA_READ,\n\t[IB_WR_ATOMIC_CMP_AND_SWP]\t\t= MLX5_OPCODE_ATOMIC_CS,\n\t[IB_WR_ATOMIC_FETCH_AND_ADD]\t\t= MLX5_OPCODE_ATOMIC_FA,\n\t[IB_WR_SEND_WITH_INV]\t\t\t= MLX5_OPCODE_SEND_INVAL,\n\t[IB_WR_LOCAL_INV]\t\t\t= MLX5_OPCODE_UMR,\n\t[IB_WR_REG_MR]\t\t\t\t= MLX5_OPCODE_UMR,\n\t[IB_WR_MASKED_ATOMIC_CMP_AND_SWP]\t= MLX5_OPCODE_ATOMIC_MASKED_CS,\n\t[IB_WR_MASKED_ATOMIC_FETCH_AND_ADD]\t= MLX5_OPCODE_ATOMIC_MASKED_FA,\n\t[MLX5_IB_WR_UMR]\t\t\t= MLX5_OPCODE_UMR,\n};\n\nstruct mlx5_wqe_eth_pad {\n\tu8 rsvd0[16];\n};\n\nenum raw_qp_set_mask_map {\n\tMLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID\t\t= 1UL << 0,\n\tMLX5_RAW_QP_RATE_LIMIT\t\t\t= 1UL << 1,\n};\n\nstruct mlx5_modify_raw_qp_param {\n\tu16 operation;\n\n\tu32 set_mask; /* raw_qp_set_mask_map */\n\n\tstruct mlx5_rate_limit rl;\n\n\tu8 rq_q_ctr_id;\n};\n\nstatic void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq);\n\nstatic int is_qp0(enum ib_qp_type qp_type)\n{\n\treturn qp_type == IB_QPT_SMI;\n}\n\nstatic int is_sqp(enum ib_qp_type qp_type)\n{\n\treturn is_qp0(qp_type) || is_qp1(qp_type);\n}\n\nstatic void *get_wqe(struct mlx5_ib_qp *qp, int offset)\n{\n\treturn mlx5_buf_offset(&qp->buf, offset);\n}\n\nstatic void *get_recv_wqe(struct mlx5_ib_qp *qp, int n)\n{\n\treturn get_wqe(qp, qp->rq.offset + (n << qp->rq.wqe_shift));\n}\n\nvoid *mlx5_get_send_wqe(struct mlx5_ib_qp *qp, int n)\n{\n\treturn get_wqe(qp, qp->sq.offset + (n << MLX5_IB_SQ_STRIDE));\n}\n\n/**\n * mlx5_ib_read_user_wqe() - Copy a user-space WQE to kernel space.\n *\n * @qp: QP to copy from.\n * @send: copy from the send queue when non-zero, use the receive queue\n *\t  otherwise.\n * @wqe_index:  index to start copying from. For send work queues, the\n *\t\twqe_index is in units of MLX5_SEND_WQE_BB.\n *\t\tFor receive work queue, it is the number of work queue\n *\t\telement in the queue.\n * @buffer: destination buffer.\n * @length: maximum number of bytes to copy.\n *\n * Copies at least a single WQE, but may copy more data.\n *\n * Return: the number of bytes copied, or an error code.\n */\nint mlx5_ib_read_user_wqe(struct mlx5_ib_qp *qp, int send, int wqe_index,\n\t\t\t  void *buffer, u32 length,\n\t\t\t  struct mlx5_ib_qp_base *base)\n{\n\tstruct ib_device *ibdev = qp->ibqp.device;\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tstruct mlx5_ib_wq *wq = send ? &qp->sq : &qp->rq;\n\tsize_t offset;\n\tsize_t wq_end;\n\tstruct ib_umem *umem = base->ubuffer.umem;\n\tu32 first_copy_length;\n\tint wqe_length;\n\tint ret;\n\n\tif (wq->wqe_cnt == 0) {\n\t\tmlx5_ib_dbg(dev, \"mlx5_ib_read_user_wqe for a QP with wqe_cnt == 0. qp_type: 0x%x\\n\",\n\t\t\t    qp->ibqp.qp_type);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = wq->offset + ((wqe_index % wq->wqe_cnt) << wq->wqe_shift);\n\twq_end = wq->offset + (wq->wqe_cnt << wq->wqe_shift);\n\n\tif (send && length < sizeof(struct mlx5_wqe_ctrl_seg))\n\t\treturn -EINVAL;\n\n\tif (offset > umem->length ||\n\t    (send && offset + sizeof(struct mlx5_wqe_ctrl_seg) > umem->length))\n\t\treturn -EINVAL;\n\n\tfirst_copy_length = min_t(u32, offset + length, wq_end) - offset;\n\tret = ib_umem_copy_from(buffer, umem, offset, first_copy_length);\n\tif (ret)\n\t\treturn ret;\n\n\tif (send) {\n\t\tstruct mlx5_wqe_ctrl_seg *ctrl = buffer;\n\t\tint ds = be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_DS_MASK;\n\n\t\twqe_length = ds * MLX5_WQE_DS_UNITS;\n\t} else {\n\t\twqe_length = 1 << wq->wqe_shift;\n\t}\n\n\tif (wqe_length <= first_copy_length)\n\t\treturn first_copy_length;\n\n\tret = ib_umem_copy_from(buffer + first_copy_length, umem, wq->offset,\n\t\t\t\twqe_length - first_copy_length);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wqe_length;\n}\n\nstatic void mlx5_ib_qp_event(struct mlx5_core_qp *qp, int type)\n{\n\tstruct ib_qp *ibqp = &to_mibqp(qp)->ibqp;\n\tstruct ib_event event;\n\n\tif (type == MLX5_EVENT_TYPE_PATH_MIG) {\n\t\t/* This event is only valid for trans_qps */\n\t\tto_mibqp(qp)->port = to_mibqp(qp)->trans_qp.alt_port;\n\t}\n\n\tif (ibqp->event_handler) {\n\t\tevent.device     = ibqp->device;\n\t\tevent.element.qp = ibqp;\n\t\tswitch (type) {\n\t\tcase MLX5_EVENT_TYPE_PATH_MIG:\n\t\t\tevent.event = IB_EVENT_PATH_MIG;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_COMM_EST:\n\t\t\tevent.event = IB_EVENT_COMM_EST;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_SQ_DRAINED:\n\t\t\tevent.event = IB_EVENT_SQ_DRAINED;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_SRQ_LAST_WQE:\n\t\t\tevent.event = IB_EVENT_QP_LAST_WQE_REACHED;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\t\tevent.event = IB_EVENT_QP_FATAL;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_PATH_MIG_FAILED:\n\t\t\tevent.event = IB_EVENT_PATH_MIG_ERR;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\t\tevent.event = IB_EVENT_QP_REQ_ERR;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\t\tevent.event = IB_EVENT_QP_ACCESS_ERR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"mlx5_ib: Unexpected event type %d on QP %06x\\n\", type, qp->qpn);\n\t\t\treturn;\n\t\t}\n\n\t\tibqp->event_handler(&event, ibqp->qp_context);\n\t}\n}\n\nstatic int set_rq_size(struct mlx5_ib_dev *dev, struct ib_qp_cap *cap,\n\t\t       int has_rq, struct mlx5_ib_qp *qp, struct mlx5_ib_create_qp *ucmd)\n{\n\tint wqe_size;\n\tint wq_size;\n\n\t/* Sanity check RQ size before proceeding */\n\tif (cap->max_recv_wr > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz)))\n\t\treturn -EINVAL;\n\n\tif (!has_rq) {\n\t\tqp->rq.max_gs = 0;\n\t\tqp->rq.wqe_cnt = 0;\n\t\tqp->rq.wqe_shift = 0;\n\t\tcap->max_recv_wr = 0;\n\t\tcap->max_recv_sge = 0;\n\t} else {\n\t\tif (ucmd) {\n\t\t\tqp->rq.wqe_cnt = ucmd->rq_wqe_count;\n\t\t\tif (ucmd->rq_wqe_shift > BITS_PER_BYTE * sizeof(ucmd->rq_wqe_shift))\n\t\t\t\treturn -EINVAL;\n\t\t\tqp->rq.wqe_shift = ucmd->rq_wqe_shift;\n\t\t\tif ((1 << qp->rq.wqe_shift) / sizeof(struct mlx5_wqe_data_seg) < qp->wq_sig)\n\t\t\t\treturn -EINVAL;\n\t\t\tqp->rq.max_gs = (1 << qp->rq.wqe_shift) / sizeof(struct mlx5_wqe_data_seg) - qp->wq_sig;\n\t\t\tqp->rq.max_post = qp->rq.wqe_cnt;\n\t\t} else {\n\t\t\twqe_size = qp->wq_sig ? sizeof(struct mlx5_wqe_signature_seg) : 0;\n\t\t\twqe_size += cap->max_recv_sge * sizeof(struct mlx5_wqe_data_seg);\n\t\t\twqe_size = roundup_pow_of_two(wqe_size);\n\t\t\twq_size = roundup_pow_of_two(cap->max_recv_wr) * wqe_size;\n\t\t\twq_size = max_t(int, wq_size, MLX5_SEND_WQE_BB);\n\t\t\tqp->rq.wqe_cnt = wq_size / wqe_size;\n\t\t\tif (wqe_size > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_rq)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"wqe_size %d, max %d\\n\",\n\t\t\t\t\t    wqe_size,\n\t\t\t\t\t    MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t\t max_wqe_sz_rq));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tqp->rq.wqe_shift = ilog2(wqe_size);\n\t\t\tqp->rq.max_gs = (1 << qp->rq.wqe_shift) / sizeof(struct mlx5_wqe_data_seg) - qp->wq_sig;\n\t\t\tqp->rq.max_post = qp->rq.wqe_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sq_overhead(struct ib_qp_init_attr *attr)\n{\n\tint size = 0;\n\n\tswitch (attr->qp_type) {\n\tcase IB_QPT_XRC_INI:\n\t\tsize += sizeof(struct mlx5_wqe_xrc_seg);\n\t\t/* fall through */\n\tcase IB_QPT_RC:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tmax(sizeof(struct mlx5_wqe_atomic_seg) +\n\t\t\t    sizeof(struct mlx5_wqe_raddr_seg),\n\t\t\t    sizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\t    sizeof(struct mlx5_mkey_seg) +\n\t\t\t    MLX5_IB_SQ_UMR_INLINE_THRESHOLD /\n\t\t\t    MLX5_IB_UMR_OCTOWORD);\n\t\tbreak;\n\n\tcase IB_QPT_XRC_TGT:\n\t\treturn 0;\n\n\tcase IB_QPT_UC:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tmax(sizeof(struct mlx5_wqe_raddr_seg),\n\t\t\t    sizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\t    sizeof(struct mlx5_mkey_seg));\n\t\tbreak;\n\n\tcase IB_QPT_UD:\n\t\tif (attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)\n\t\t\tsize += sizeof(struct mlx5_wqe_eth_pad) +\n\t\t\t\tsizeof(struct mlx5_wqe_eth_seg);\n\t\t/* fall through */\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_wqe_datagram_seg);\n\t\tbreak;\n\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_mkey_seg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n}\n\nstatic int calc_send_wqe(struct ib_qp_init_attr *attr)\n{\n\tint inl_size = 0;\n\tint size;\n\n\tsize = sq_overhead(attr);\n\tif (size < 0)\n\t\treturn size;\n\n\tif (attr->cap.max_inline_data) {\n\t\tinl_size = size + sizeof(struct mlx5_wqe_inline_seg) +\n\t\t\tattr->cap.max_inline_data;\n\t}\n\n\tsize += attr->cap.max_send_sge * sizeof(struct mlx5_wqe_data_seg);\n\tif (attr->create_flags & IB_QP_CREATE_SIGNATURE_EN &&\n\t    ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB) < MLX5_SIG_WQE_SIZE)\n\t\t\treturn MLX5_SIG_WQE_SIZE;\n\telse\n\t\treturn ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB);\n}\n\nstatic int get_send_sge(struct ib_qp_init_attr *attr, int wqe_size)\n{\n\tint max_sge;\n\n\tif (attr->qp_type == IB_QPT_RC)\n\t\tmax_sge = (min_t(int, wqe_size, 512) -\n\t\t\t   sizeof(struct mlx5_wqe_ctrl_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_raddr_seg)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\telse if (attr->qp_type == IB_QPT_XRC_INI)\n\t\tmax_sge = (min_t(int, wqe_size, 512) -\n\t\t\t   sizeof(struct mlx5_wqe_ctrl_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_xrc_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_raddr_seg)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\telse\n\t\tmax_sge = (wqe_size - sq_overhead(attr)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\n\treturn min_t(int, max_sge, wqe_size - sq_overhead(attr) /\n\t\t     sizeof(struct mlx5_wqe_data_seg));\n}\n\nstatic int calc_sq_size(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,\n\t\t\tstruct mlx5_ib_qp *qp)\n{\n\tint wqe_size;\n\tint wq_size;\n\n\tif (!attr->cap.max_send_wr)\n\t\treturn 0;\n\n\twqe_size = calc_send_wqe(attr);\n\tmlx5_ib_dbg(dev, \"wqe_size %d\\n\", wqe_size);\n\tif (wqe_size < 0)\n\t\treturn wqe_size;\n\n\tif (wqe_size > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_dbg(dev, \"wqe_size(%d) > max_sq_desc_sz(%d)\\n\",\n\t\t\t    wqe_size, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tqp->max_inline_data = wqe_size - sq_overhead(attr) -\n\t\t\t      sizeof(struct mlx5_wqe_inline_seg);\n\tattr->cap.max_inline_data = qp->max_inline_data;\n\n\tif (attr->create_flags & IB_QP_CREATE_SIGNATURE_EN)\n\t\tqp->signature_en = true;\n\n\twq_size = roundup_pow_of_two(attr->cap.max_send_wr * wqe_size);\n\tqp->sq.wqe_cnt = wq_size / MLX5_SEND_WQE_BB;\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_dbg(dev, \"send queue size (%d * %d / %d -> %d) exceeds limits(%d)\\n\",\n\t\t\t    attr->cap.max_send_wr, wqe_size, MLX5_SEND_WQE_BB,\n\t\t\t    qp->sq.wqe_cnt,\n\t\t\t    1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -ENOMEM;\n\t}\n\tqp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);\n\tqp->sq.max_gs = get_send_sge(attr, wqe_size);\n\tif (qp->sq.max_gs < attr->cap.max_send_sge)\n\t\treturn -ENOMEM;\n\n\tattr->cap.max_send_sge = qp->sq.max_gs;\n\tqp->sq.max_post = wq_size / wqe_size;\n\tattr->cap.max_send_wr = qp->sq.max_post;\n\n\treturn wq_size;\n}\n\nstatic int set_user_buf_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    struct mlx5_ib_create_qp *ucmd,\n\t\t\t    struct mlx5_ib_qp_base *base,\n\t\t\t    struct ib_qp_init_attr *attr)\n{\n\tint desc_sz = 1 << qp->sq.wqe_shift;\n\n\tif (desc_sz > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_warn(dev, \"desc_sz %d, max_sq_desc_sz %d\\n\",\n\t\t\t     desc_sz, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucmd->sq_wqe_count && ((1 << ilog2(ucmd->sq_wqe_count)) != ucmd->sq_wqe_count)) {\n\t\tmlx5_ib_warn(dev, \"sq_wqe_count %d, sq_wqe_count %d\\n\",\n\t\t\t     ucmd->sq_wqe_count, ucmd->sq_wqe_count);\n\t\treturn -EINVAL;\n\t}\n\n\tqp->sq.wqe_cnt = ucmd->sq_wqe_count;\n\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_warn(dev, \"wqe_cnt %d, max_wqes %d\\n\",\n\t\t\t     qp->sq.wqe_cnt,\n\t\t\t     1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tbase->ubuffer.buf_size = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_size = qp->sq.wqe_cnt << 6;\n\t} else {\n\t\tbase->ubuffer.buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t\t\t\t (qp->sq.wqe_cnt << 6);\n\t}\n\n\treturn 0;\n}\n\nstatic int qp_has_rq(struct ib_qp_init_attr *attr)\n{\n\tif (attr->qp_type == IB_QPT_XRC_INI ||\n\t    attr->qp_type == IB_QPT_XRC_TGT || attr->srq ||\n\t    attr->qp_type == MLX5_IB_QPT_REG_UMR ||\n\t    !attr->cap.max_recv_wr)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nenum {\n\t/* this is the first blue flame register in the array of bfregs assigned\n\t * to a processes. Since we do not use it for blue flame but rather\n\t * regular 64 bit doorbells, we do not need a lock for maintaiing\n\t * \"odd/even\" order\n\t */\n\tNUM_NON_BLUE_FLAME_BFREGS = 1,\n};\n\nstatic int max_bfregs(struct mlx5_ib_dev *dev, struct mlx5_bfreg_info *bfregi)\n{\n\treturn get_num_static_uars(dev, bfregi) * MLX5_NON_FP_BFREGS_PER_UAR;\n}\n\nstatic int num_med_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t struct mlx5_bfreg_info *bfregi)\n{\n\tint n;\n\n\tn = max_bfregs(dev, bfregi) - bfregi->num_low_latency_bfregs -\n\t    NUM_NON_BLUE_FLAME_BFREGS;\n\n\treturn n >= 0 ? n : 0;\n}\n\nstatic int first_med_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t   struct mlx5_bfreg_info *bfregi)\n{\n\treturn num_med_bfreg(dev, bfregi) ? 1 : -ENOMEM;\n}\n\nstatic int first_hi_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t  struct mlx5_bfreg_info *bfregi)\n{\n\tint med;\n\n\tmed = num_med_bfreg(dev, bfregi);\n\treturn ++med;\n}\n\nstatic int alloc_high_class_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_bfreg_info *bfregi)\n{\n\tint i;\n\n\tfor (i = first_hi_bfreg(dev, bfregi); i < max_bfregs(dev, bfregi); i++) {\n\t\tif (!bfregi->count[i]) {\n\t\t\tbfregi->count[i]++;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int alloc_med_class_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t\t struct mlx5_bfreg_info *bfregi)\n{\n\tint minidx = first_med_bfreg(dev, bfregi);\n\tint i;\n\n\tif (minidx < 0)\n\t\treturn minidx;\n\n\tfor (i = minidx; i < first_hi_bfreg(dev, bfregi); i++) {\n\t\tif (bfregi->count[i] < bfregi->count[minidx])\n\t\t\tminidx = i;\n\t\tif (!bfregi->count[minidx])\n\t\t\tbreak;\n\t}\n\n\tbfregi->count[minidx]++;\n\treturn minidx;\n}\n\nstatic int alloc_bfreg(struct mlx5_ib_dev *dev,\n\t\t       struct mlx5_bfreg_info *bfregi)\n{\n\tint bfregn = -ENOMEM;\n\n\tmutex_lock(&bfregi->lock);\n\tif (bfregi->ver >= 2) {\n\t\tbfregn = alloc_high_class_bfreg(dev, bfregi);\n\t\tif (bfregn < 0)\n\t\t\tbfregn = alloc_med_class_bfreg(dev, bfregi);\n\t}\n\n\tif (bfregn < 0) {\n\t\tBUILD_BUG_ON(NUM_NON_BLUE_FLAME_BFREGS != 1);\n\t\tbfregn = 0;\n\t\tbfregi->count[bfregn]++;\n\t}\n\tmutex_unlock(&bfregi->lock);\n\n\treturn bfregn;\n}\n\nvoid mlx5_ib_free_bfreg(struct mlx5_ib_dev *dev, struct mlx5_bfreg_info *bfregi, int bfregn)\n{\n\tmutex_lock(&bfregi->lock);\n\tbfregi->count[bfregn]--;\n\tmutex_unlock(&bfregi->lock);\n}\n\nstatic enum mlx5_qp_state to_mlx5_state(enum ib_qp_state state)\n{\n\tswitch (state) {\n\tcase IB_QPS_RESET:\treturn MLX5_QP_STATE_RST;\n\tcase IB_QPS_INIT:\treturn MLX5_QP_STATE_INIT;\n\tcase IB_QPS_RTR:\treturn MLX5_QP_STATE_RTR;\n\tcase IB_QPS_RTS:\treturn MLX5_QP_STATE_RTS;\n\tcase IB_QPS_SQD:\treturn MLX5_QP_STATE_SQD;\n\tcase IB_QPS_SQE:\treturn MLX5_QP_STATE_SQER;\n\tcase IB_QPS_ERR:\treturn MLX5_QP_STATE_ERR;\n\tdefault:\t\treturn -1;\n\t}\n}\n\nstatic int to_mlx5_st(enum ib_qp_type type)\n{\n\tswitch (type) {\n\tcase IB_QPT_RC:\t\t\treturn MLX5_QP_ST_RC;\n\tcase IB_QPT_UC:\t\t\treturn MLX5_QP_ST_UC;\n\tcase IB_QPT_UD:\t\t\treturn MLX5_QP_ST_UD;\n\tcase MLX5_IB_QPT_REG_UMR:\treturn MLX5_QP_ST_REG_UMR;\n\tcase IB_QPT_XRC_INI:\n\tcase IB_QPT_XRC_TGT:\t\treturn MLX5_QP_ST_XRC;\n\tcase IB_QPT_SMI:\t\treturn MLX5_QP_ST_QP0;\n\tcase MLX5_IB_QPT_HW_GSI:\treturn MLX5_QP_ST_QP1;\n\tcase MLX5_IB_QPT_DCI:\t\treturn MLX5_QP_ST_DCI;\n\tcase IB_QPT_RAW_IPV6:\t\treturn MLX5_QP_ST_RAW_IPV6;\n\tcase IB_QPT_RAW_PACKET:\n\tcase IB_QPT_RAW_ETHERTYPE:\treturn MLX5_QP_ST_RAW_ETHERTYPE;\n\tcase IB_QPT_MAX:\n\tdefault:\t\treturn -EINVAL;\n\t}\n}\n\nstatic void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq,\n\t\t\t     struct mlx5_ib_cq *recv_cq);\nstatic void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq,\n\t\t\t       struct mlx5_ib_cq *recv_cq);\n\nint bfregn_to_uar_index(struct mlx5_ib_dev *dev,\n\t\t\tstruct mlx5_bfreg_info *bfregi, u32 bfregn,\n\t\t\tbool dyn_bfreg)\n{\n\tunsigned int bfregs_per_sys_page;\n\tu32 index_of_sys_page;\n\tu32 offset;\n\n\tbfregs_per_sys_page = get_uars_per_sys_page(dev, bfregi->lib_uar_4k) *\n\t\t\t\tMLX5_NON_FP_BFREGS_PER_UAR;\n\tindex_of_sys_page = bfregn / bfregs_per_sys_page;\n\n\tif (dyn_bfreg) {\n\t\tindex_of_sys_page += bfregi->num_static_sys_pages;\n\n\t\tif (index_of_sys_page >= bfregi->num_sys_pages)\n\t\t\treturn -EINVAL;\n\n\t\tif (bfregn > bfregi->num_dyn_bfregs ||\n\t\t    bfregi->sys_pages[index_of_sys_page] == MLX5_IB_INVALID_UAR_INDEX) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid dynamic uar index\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\toffset = bfregn % bfregs_per_sys_page / MLX5_NON_FP_BFREGS_PER_UAR;\n\treturn bfregi->sys_pages[index_of_sys_page] + offset;\n}\n\nstatic int mlx5_ib_umem_get(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_pd *pd,\n\t\t\t    unsigned long addr, size_t size,\n\t\t\t    struct ib_umem **umem,\n\t\t\t    int *npages, int *page_shift, int *ncont,\n\t\t\t    u32 *offset)\n{\n\tint err;\n\n\t*umem = ib_umem_get(pd->uobject->context, addr, size, 0, 0);\n\tif (IS_ERR(*umem)) {\n\t\tmlx5_ib_dbg(dev, \"umem_get failed\\n\");\n\t\treturn PTR_ERR(*umem);\n\t}\n\n\tmlx5_ib_cont_pages(*umem, addr, 0, npages, page_shift, ncont, NULL);\n\n\terr = mlx5_ib_get_buf_offset(addr, *page_shift, offset);\n\tif (err) {\n\t\tmlx5_ib_warn(dev, \"bad offset\\n\");\n\t\tgoto err_umem;\n\t}\n\n\tmlx5_ib_dbg(dev, \"addr 0x%lx, size %zu, npages %d, page_shift %d, ncont %d, offset %d\\n\",\n\t\t    addr, size, *npages, *page_shift, *ncont, *offset);\n\n\treturn 0;\n\nerr_umem:\n\tib_umem_release(*umem);\n\t*umem = NULL;\n\n\treturn err;\n}\n\nstatic void destroy_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_rwq *rwq)\n{\n\tstruct mlx5_ib_ucontext *context;\n\n\tif (rwq->create_flags & MLX5_IB_WQ_FLAGS_DELAY_DROP)\n\t\tatomic_dec(&dev->delay_drop.rqs_cnt);\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tmlx5_ib_db_unmap_user(context, &rwq->db);\n\tif (rwq->umem)\n\t\tib_umem_release(rwq->umem);\n}\n\nstatic int create_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t  struct mlx5_ib_rwq *rwq,\n\t\t\t  struct mlx5_ib_create_wq *ucmd)\n{\n\tstruct mlx5_ib_ucontext *context;\n\tint page_shift = 0;\n\tint npages;\n\tu32 offset = 0;\n\tint ncont = 0;\n\tint err;\n\n\tif (!ucmd->buf_addr)\n\t\treturn -EINVAL;\n\n\tcontext = to_mucontext(pd->uobject->context);\n\trwq->umem = ib_umem_get(pd->uobject->context, ucmd->buf_addr,\n\t\t\t       rwq->buf_size, 0, 0);\n\tif (IS_ERR(rwq->umem)) {\n\t\tmlx5_ib_dbg(dev, \"umem_get failed\\n\");\n\t\terr = PTR_ERR(rwq->umem);\n\t\treturn err;\n\t}\n\n\tmlx5_ib_cont_pages(rwq->umem, ucmd->buf_addr, 0, &npages, &page_shift,\n\t\t\t   &ncont, NULL);\n\terr = mlx5_ib_get_buf_offset(ucmd->buf_addr, page_shift,\n\t\t\t\t     &rwq->rq_page_offset);\n\tif (err) {\n\t\tmlx5_ib_warn(dev, \"bad offset\\n\");\n\t\tgoto err_umem;\n\t}\n\n\trwq->rq_num_pas = ncont;\n\trwq->page_shift = page_shift;\n\trwq->log_page_size =  page_shift - MLX5_ADAPTER_PAGE_SHIFT;\n\trwq->wq_sig = !!(ucmd->flags & MLX5_WQ_FLAG_SIGNATURE);\n\n\tmlx5_ib_dbg(dev, \"addr 0x%llx, size %zd, npages %d, page_shift %d, ncont %d, offset %d\\n\",\n\t\t    (unsigned long long)ucmd->buf_addr, rwq->buf_size,\n\t\t    npages, page_shift, ncont, offset);\n\n\terr = mlx5_ib_db_map_user(context, ucmd->db_addr, &rwq->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"map failed\\n\");\n\t\tgoto err_umem;\n\t}\n\n\trwq->create_type = MLX5_WQ_USER;\n\treturn 0;\n\nerr_umem:\n\tib_umem_release(rwq->umem);\n\treturn err;\n}\n\nstatic int adjust_bfregn(struct mlx5_ib_dev *dev,\n\t\t\t struct mlx5_bfreg_info *bfregi, int bfregn)\n{\n\treturn bfregn / MLX5_NON_FP_BFREGS_PER_UAR * MLX5_BFREGS_PER_UAR +\n\t\t\t\tbfregn % MLX5_NON_FP_BFREGS_PER_UAR;\n}\n\nstatic int create_user_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t  struct mlx5_ib_qp *qp, struct ib_udata *udata,\n\t\t\t  struct ib_qp_init_attr *attr,\n\t\t\t  u32 **in,\n\t\t\t  struct mlx5_ib_create_qp_resp *resp, int *inlen,\n\t\t\t  struct mlx5_ib_qp_base *base)\n{\n\tstruct mlx5_ib_ucontext *context;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_ubuffer *ubuffer = &base->ubuffer;\n\tint page_shift = 0;\n\tint uar_index = 0;\n\tint npages;\n\tu32 offset = 0;\n\tint bfregn;\n\tint ncont = 0;\n\t__be64 *pas;\n\tvoid *qpc;\n\tint err;\n\n\terr = ib_copy_from_udata(&ucmd, udata, sizeof(ucmd));\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn err;\n\t}\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tif (ucmd.flags & MLX5_QP_FLAG_BFREG_INDEX) {\n\t\tuar_index = bfregn_to_uar_index(dev, &context->bfregi,\n\t\t\t\t\t\tucmd.bfreg_index, true);\n\t\tif (uar_index < 0)\n\t\t\treturn uar_index;\n\n\t\tbfregn = MLX5_IB_INVALID_BFREG;\n\t} else if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL) {\n\t\t/*\n\t\t * TBD: should come from the verbs when we have the API\n\t\t */\n\t\t/* In CROSS_CHANNEL CQ and QP must use the same UAR */\n\t\tbfregn = MLX5_CROSS_CHANNEL_BFREG;\n\t}\n\telse {\n\t\tbfregn = alloc_bfreg(dev, &context->bfregi);\n\t\tif (bfregn < 0)\n\t\t\treturn bfregn;\n\t}\n\n\tmlx5_ib_dbg(dev, \"bfregn 0x%x, uar_index 0x%x\\n\", bfregn, uar_index);\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tuar_index = bfregn_to_uar_index(dev, &context->bfregi, bfregn,\n\t\t\t\t\t\tfalse);\n\n\tqp->rq.offset = 0;\n\tqp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);\n\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\n\terr = set_user_buf_size(dev, qp, &ucmd, base, attr);\n\tif (err)\n\t\tgoto err_bfreg;\n\n\tif (ucmd.buf_addr && ubuffer->buf_size) {\n\t\tubuffer->buf_addr = ucmd.buf_addr;\n\t\terr = mlx5_ib_umem_get(dev, pd, ubuffer->buf_addr,\n\t\t\t\t       ubuffer->buf_size,\n\t\t\t\t       &ubuffer->umem, &npages, &page_shift,\n\t\t\t\t       &ncont, &offset);\n\t\tif (err)\n\t\t\tgoto err_bfreg;\n\t} else {\n\t\tubuffer->umem = NULL;\n\t}\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) * ncont;\n\t*in = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_qp_in, *in, pas);\n\tif (ubuffer->umem)\n\t\tmlx5_ib_populate_pas(dev, ubuffer->umem, page_shift, pas, 0);\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, *in, qpc);\n\n\tMLX5_SET(qpc, qpc, log_page_size, page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(qpc, qpc, page_offset, offset);\n\n\tMLX5_SET(qpc, qpc, uar_page, uar_index);\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tresp->bfreg_index = adjust_bfregn(dev, &context->bfregi, bfregn);\n\telse\n\t\tresp->bfreg_index = MLX5_IB_INVALID_BFREG;\n\tqp->bfregn = bfregn;\n\n\terr = mlx5_ib_db_map_user(context, ucmd.db_addr, &qp->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"map failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = ib_copy_to_udata(udata, resp, min(udata->outlen, sizeof(*resp)));\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\tgoto err_unmap;\n\t}\n\tqp->create_type = MLX5_QP_USER;\n\n\treturn 0;\n\nerr_unmap:\n\tmlx5_ib_db_unmap_user(context, &qp->db);\n\nerr_free:\n\tkvfree(*in);\n\nerr_umem:\n\tif (ubuffer->umem)\n\t\tib_umem_release(ubuffer->umem);\n\nerr_bfreg:\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, bfregn);\n\treturn err;\n}\n\nstatic void destroy_qp_user(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_qp *qp, struct mlx5_ib_qp_base *base)\n{\n\tstruct mlx5_ib_ucontext *context;\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tmlx5_ib_db_unmap_user(context, &qp->db);\n\tif (base->ubuffer.umem)\n\t\tib_umem_release(base->ubuffer.umem);\n\n\t/*\n\t * Free only the BFREGs which are handled by the kernel.\n\t * BFREGs of UARs allocated dynamically are handled by user.\n\t */\n\tif (qp->bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, qp->bfregn);\n}\n\nstatic int create_kernel_qp(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    u32 **in, int *inlen,\n\t\t\t    struct mlx5_ib_qp_base *base)\n{\n\tint uar_index;\n\tvoid *qpc;\n\tint err;\n\n\tif (init_attr->create_flags & ~(IB_QP_CREATE_SIGNATURE_EN |\n\t\t\t\t\tIB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK |\n\t\t\t\t\tIB_QP_CREATE_IPOIB_UD_LSO |\n\t\t\t\t\tIB_QP_CREATE_NETIF_QP |\n\t\t\t\t\tmlx5_ib_create_qp_sqpn_qp1()))\n\t\treturn -EINVAL;\n\n\tif (init_attr->qp_type == MLX5_IB_QPT_REG_UMR)\n\t\tqp->bf.bfreg = &dev->fp_bfreg;\n\telse\n\t\tqp->bf.bfreg = &dev->bfreg;\n\n\t/* We need to divide by two since each register is comprised of\n\t * two buffers of identical size, namely odd and even\n\t */\n\tqp->bf.buf_size = (1 << MLX5_CAP_GEN(dev->mdev, log_bf_reg_size)) / 2;\n\tuar_index = qp->bf.bfreg->index;\n\n\terr = calc_sq_size(dev, init_attr, qp);\n\tif (err < 0) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tqp->rq.offset = 0;\n\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\tbase->ubuffer.buf_size = err + (qp->rq.wqe_cnt << qp->rq.wqe_shift);\n\n\terr = mlx5_buf_alloc(dev->mdev, base->ubuffer.buf_size, &qp->buf);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tqp->sq.qend = mlx5_get_send_wqe(qp, qp->sq.wqe_cnt);\n\t*inlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) * qp->buf.npages;\n\t*in = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_buf;\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, *in, qpc);\n\tMLX5_SET(qpc, qpc, uar_page, uar_index);\n\tMLX5_SET(qpc, qpc, log_page_size, qp->buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\n\t/* Set \"fast registration enabled\" for all kernel QPs */\n\tMLX5_SET(qpc, qpc, fre, 1);\n\tMLX5_SET(qpc, qpc, rlky, 1);\n\n\tif (init_attr->create_flags & mlx5_ib_create_qp_sqpn_qp1()) {\n\t\tMLX5_SET(qpc, qpc, deth_sqpn, 1);\n\t\tqp->flags |= MLX5_IB_QP_SQPN_QP1;\n\t}\n\n\tmlx5_fill_page_array(&qp->buf,\n\t\t\t     (__be64 *)MLX5_ADDR_OF(create_qp_in, *in, pas));\n\n\terr = mlx5_db_alloc(dev->mdev, &qp->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\tgoto err_free;\n\t}\n\n\tqp->sq.wrid = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t     sizeof(*qp->sq.wrid), GFP_KERNEL);\n\tqp->sq.wr_data = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\tsizeof(*qp->sq.wr_data), GFP_KERNEL);\n\tqp->rq.wrid = kvmalloc_array(qp->rq.wqe_cnt,\n\t\t\t\t     sizeof(*qp->rq.wrid), GFP_KERNEL);\n\tqp->sq.w_list = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t       sizeof(*qp->sq.w_list), GFP_KERNEL);\n\tqp->sq.wqe_head = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\t sizeof(*qp->sq.wqe_head), GFP_KERNEL);\n\n\tif (!qp->sq.wrid || !qp->sq.wr_data || !qp->rq.wrid ||\n\t    !qp->sq.w_list || !qp->sq.wqe_head) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wrid;\n\t}\n\tqp->create_type = MLX5_QP_KERNEL;\n\n\treturn 0;\n\nerr_wrid:\n\tkvfree(qp->sq.wqe_head);\n\tkvfree(qp->sq.w_list);\n\tkvfree(qp->sq.wrid);\n\tkvfree(qp->sq.wr_data);\n\tkvfree(qp->rq.wrid);\n\tmlx5_db_free(dev->mdev, &qp->db);\n\nerr_free:\n\tkvfree(*in);\n\nerr_buf:\n\tmlx5_buf_free(dev->mdev, &qp->buf);\n\treturn err;\n}\n\nstatic void destroy_qp_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tkvfree(qp->sq.wqe_head);\n\tkvfree(qp->sq.w_list);\n\tkvfree(qp->sq.wrid);\n\tkvfree(qp->sq.wr_data);\n\tkvfree(qp->rq.wrid);\n\tmlx5_db_free(dev->mdev, &qp->db);\n\tmlx5_buf_free(dev->mdev, &qp->buf);\n}\n\nstatic u32 get_rx_type(struct mlx5_ib_qp *qp, struct ib_qp_init_attr *attr)\n{\n\tif (attr->srq || (attr->qp_type == IB_QPT_XRC_TGT) ||\n\t    (attr->qp_type == MLX5_IB_QPT_DCI) ||\n\t    (attr->qp_type == IB_QPT_XRC_INI))\n\t\treturn MLX5_SRQ_RQ;\n\telse if (!qp->has_rq)\n\t\treturn MLX5_ZERO_LEN_RQ;\n\telse\n\t\treturn MLX5_NON_ZERO_RQ;\n}\n\nstatic int is_connected(enum ib_qp_type qp_type)\n{\n\tif (qp_type == IB_QPT_RC || qp_type == IB_QPT_UC)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int create_raw_packet_qp_tis(struct mlx5_ib_dev *dev,\n\t\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t\t    struct mlx5_ib_sq *sq, u32 tdn)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_tis_in)] = {0};\n\tvoid *tisc = MLX5_ADDR_OF(create_tis_in, in, ctx);\n\n\tMLX5_SET(tisc, tisc, transport_domain, tdn);\n\tif (qp->flags & MLX5_IB_QP_UNDERLAY)\n\t\tMLX5_SET(tisc, tisc, underlay_qpn, qp->underlay_qpn);\n\n\treturn mlx5_core_create_tis(dev->mdev, in, sizeof(in), &sq->tisn);\n}\n\nstatic void destroy_raw_packet_qp_tis(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_sq *sq)\n{\n\tmlx5_core_destroy_tis(dev->mdev, sq->tisn);\n}\n\nstatic void destroy_flow_rule_vport_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t       struct mlx5_ib_sq *sq)\n{\n\tif (sq->flow_rule)\n\t\tmlx5_del_flow_rules(sq->flow_rule);\n}\n\nstatic int create_raw_packet_qp_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq, void *qpin,\n\t\t\t\t   struct ib_pd *pd)\n{\n\tstruct mlx5_ib_ubuffer *ubuffer = &sq->ubuffer;\n\t__be64 *pas;\n\tvoid *in;\n\tvoid *sqc;\n\tvoid *qpc = MLX5_ADDR_OF(create_qp_in, qpin, qpc);\n\tvoid *wq;\n\tint inlen;\n\tint err;\n\tint page_shift = 0;\n\tint npages;\n\tint ncont = 0;\n\tu32 offset = 0;\n\n\terr = mlx5_ib_umem_get(dev, pd, ubuffer->buf_addr, ubuffer->buf_size,\n\t\t\t       &sq->ubuffer.umem, &npages, &page_shift,\n\t\t\t       &ncont, &offset);\n\tif (err)\n\t\treturn err;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) + sizeof(u64) * ncont;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\tif (MLX5_CAP_ETH(dev->mdev, multi_pkt_send_wqe))\n\t\tMLX5_SET(sqc, sqc, allow_multi_pkt_send_wqe, 1);\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\tMLX5_SET(sqc, sqc, user_index, MLX5_GET(qpc, qpc, user_index));\n\tMLX5_SET(sqc, sqc, cqn, MLX5_GET(qpc, qpc, cqn_snd));\n\tMLX5_SET(sqc, sqc, tis_lst_sz, 1);\n\tMLX5_SET(sqc, sqc, tis_num_0, sq->tisn);\n\tif (MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t    MLX5_CAP_ETH(dev->mdev, swp))\n\t\tMLX5_SET(sqc, sqc, allow_swp, 1);\n\n\twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tMLX5_SET(wq, wq, pd, MLX5_GET(qpc, qpc, pd));\n\tMLX5_SET(wq, wq, uar_page, MLX5_GET(qpc, qpc, uar_page));\n\tMLX5_SET64(wq, wq, dbr_addr, MLX5_GET64(qpc, qpc, dbr_addr));\n\tMLX5_SET(wq, wq, log_wq_stride, ilog2(MLX5_SEND_WQE_BB));\n\tMLX5_SET(wq, wq, log_wq_sz, MLX5_GET(qpc, qpc, log_sq_size));\n\tMLX5_SET(wq, wq, log_wq_pg_sz,  page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(wq, wq, page_offset, offset);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(dev, sq->ubuffer.umem, page_shift, pas, 0);\n\n\terr = mlx5_core_create_sq_tracked(dev->mdev, in, inlen, &sq->base.mqp);\n\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_umem;\n\n\terr = create_flow_rule_vport_sq(dev, sq);\n\tif (err)\n\t\tgoto err_flow;\n\n\treturn 0;\n\nerr_flow:\n\tmlx5_core_destroy_sq_tracked(dev->mdev, &sq->base.mqp);\n\nerr_umem:\n\tib_umem_release(sq->ubuffer.umem);\n\tsq->ubuffer.umem = NULL;\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_sq *sq)\n{\n\tdestroy_flow_rule_vport_sq(dev, sq);\n\tmlx5_core_destroy_sq_tracked(dev->mdev, &sq->base.mqp);\n\tib_umem_release(sq->ubuffer.umem);\n}\n\nstatic size_t get_rq_pas_size(void *qpc)\n{\n\tu32 log_page_size = MLX5_GET(qpc, qpc, log_page_size) + 12;\n\tu32 log_rq_stride = MLX5_GET(qpc, qpc, log_rq_stride);\n\tu32 log_rq_size   = MLX5_GET(qpc, qpc, log_rq_size);\n\tu32 page_offset   = MLX5_GET(qpc, qpc, page_offset);\n\tu32 po_quanta\t  = 1 << (log_page_size - 6);\n\tu32 rq_sz\t  = 1 << (log_rq_size + 4 + log_rq_stride);\n\tu32 page_size\t  = 1 << log_page_size;\n\tu32 rq_sz_po      = rq_sz + (page_offset * po_quanta);\n\tu32 rq_num_pas\t  = (rq_sz_po + page_size - 1) / page_size;\n\n\treturn rq_num_pas * sizeof(u64);\n}\n\nstatic int create_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_rq *rq, void *qpin,\n\t\t\t\t   size_t qpinlen)\n{\n\tstruct mlx5_ib_qp *mqp = rq->base.container_mibqp;\n\t__be64 *pas;\n\t__be64 *qp_pas;\n\tvoid *in;\n\tvoid *rqc;\n\tvoid *wq;\n\tvoid *qpc = MLX5_ADDR_OF(create_qp_in, qpin, qpc);\n\tsize_t rq_pas_size = get_rq_pas_size(qpc);\n\tsize_t inlen;\n\tint err;\n\n\tif (qpinlen < rq_pas_size + MLX5_BYTE_OFF(create_qp_in, pas))\n\t\treturn -EINVAL;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rq_in) + rq_pas_size;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(create_rq_in, in, ctx);\n\tif (!(rq->flags & MLX5_IB_RQ_CVLAN_STRIPPING))\n\t\tMLX5_SET(rqc, rqc, vsd, 1);\n\tMLX5_SET(rqc, rqc, mem_rq_type, MLX5_RQC_MEM_RQ_TYPE_MEMORY_RQ_INLINE);\n\tMLX5_SET(rqc, rqc, state, MLX5_RQC_STATE_RST);\n\tMLX5_SET(rqc, rqc, flush_in_error_en, 1);\n\tMLX5_SET(rqc, rqc, user_index, MLX5_GET(qpc, qpc, user_index));\n\tMLX5_SET(rqc, rqc, cqn, MLX5_GET(qpc, qpc, cqn_rcv));\n\n\tif (mqp->flags & MLX5_IB_QP_CAP_SCATTER_FCS)\n\t\tMLX5_SET(rqc, rqc, scatter_fcs, 1);\n\n\twq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tif (rq->flags & MLX5_IB_RQ_PCI_WRITE_END_PADDING)\n\t\tMLX5_SET(wq, wq, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN);\n\tMLX5_SET(wq, wq, page_offset, MLX5_GET(qpc, qpc, page_offset));\n\tMLX5_SET(wq, wq, pd, MLX5_GET(qpc, qpc, pd));\n\tMLX5_SET64(wq, wq, dbr_addr, MLX5_GET64(qpc, qpc, dbr_addr));\n\tMLX5_SET(wq, wq, log_wq_stride, MLX5_GET(qpc, qpc, log_rq_stride) + 4);\n\tMLX5_SET(wq, wq, log_wq_pg_sz, MLX5_GET(qpc, qpc, log_page_size));\n\tMLX5_SET(wq, wq, log_wq_sz, MLX5_GET(qpc, qpc, log_rq_size));\n\n\tpas = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tqp_pas = (__be64 *)MLX5_ADDR_OF(create_qp_in, qpin, pas);\n\tmemcpy(pas, qp_pas, rq_pas_size);\n\n\terr = mlx5_core_create_rq_tracked(dev->mdev, in, inlen, &rq->base.mqp);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_rq *rq)\n{\n\tmlx5_core_destroy_rq_tracked(dev->mdev, &rq->base.mqp);\n}\n\nstatic bool tunnel_offload_supported(struct mlx5_core_dev *dev)\n{\n\treturn  (MLX5_CAP_ETH(dev, tunnel_stateless_vxlan) ||\n\t\t MLX5_CAP_ETH(dev, tunnel_stateless_gre) ||\n\t\t MLX5_CAP_ETH(dev, tunnel_stateless_geneve_rx));\n}\n\nstatic int create_raw_packet_qp_tir(struct mlx5_ib_dev *dev,\n\t\t\t\t    struct mlx5_ib_rq *rq, u32 tdn,\n\t\t\t\t    bool tunnel_offload_en)\n{\n\tu32 *in;\n\tvoid *tirc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_tir_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\ttirc = MLX5_ADDR_OF(create_tir_in, in, ctx);\n\tMLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_DIRECT);\n\tMLX5_SET(tirc, tirc, inline_rqn, rq->base.mqp.qpn);\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\tif (tunnel_offload_en)\n\t\tMLX5_SET(tirc, tirc, tunneled_offload_en, 1);\n\n\tif (dev->rep)\n\t\tMLX5_SET(tirc, tirc, self_lb_block,\n\t\t\t MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST_);\n\n\terr = mlx5_core_create_tir(dev->mdev, in, inlen, &rq->tirn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_tir(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_rq *rq)\n{\n\tmlx5_core_destroy_tir(dev->mdev, rq->tirn);\n}\n\nstatic int create_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tu32 *in, size_t inlen,\n\t\t\t\tstruct ib_pd *pd)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct ib_uobject *uobj = pd->uobject;\n\tstruct ib_ucontext *ucontext = uobj->context;\n\tstruct mlx5_ib_ucontext *mucontext = to_mucontext(ucontext);\n\tint err;\n\tu32 tdn = mucontext->tdn;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = create_raw_packet_qp_tis(dev, qp, sq, tdn);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = create_raw_packet_qp_sq(dev, sq, in, pd);\n\t\tif (err)\n\t\t\tgoto err_destroy_tis;\n\n\t\tsq->base.container_mibqp = qp;\n\t\tsq->base.mqp.event = mlx5_ib_qp_event;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\trq->base.container_mibqp = qp;\n\n\t\tif (qp->flags & MLX5_IB_QP_CVLAN_STRIPPING)\n\t\t\trq->flags |= MLX5_IB_RQ_CVLAN_STRIPPING;\n\t\tif (qp->flags & MLX5_IB_QP_PCI_WRITE_END_PADDING)\n\t\t\trq->flags |= MLX5_IB_RQ_PCI_WRITE_END_PADDING;\n\t\terr = create_raw_packet_qp_rq(dev, rq, in, inlen);\n\t\tif (err)\n\t\t\tgoto err_destroy_sq;\n\n\n\t\terr = create_raw_packet_qp_tir(dev, rq, tdn,\n\t\t\t\t\t       qp->tunnel_offload_en);\n\t\tif (err)\n\t\t\tgoto err_destroy_rq;\n\t}\n\n\tqp->trans_qp.base.mqp.qpn = qp->sq.wqe_cnt ? sq->base.mqp.qpn :\n\t\t\t\t\t\t     rq->base.mqp.qpn;\n\n\treturn 0;\n\nerr_destroy_rq:\n\tdestroy_raw_packet_qp_rq(dev, rq);\nerr_destroy_sq:\n\tif (!qp->sq.wqe_cnt)\n\t\treturn err;\n\tdestroy_raw_packet_qp_sq(dev, sq);\nerr_destroy_tis:\n\tdestroy_raw_packet_qp_tis(dev, sq);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\n\tif (qp->rq.wqe_cnt) {\n\t\tdestroy_raw_packet_qp_tir(dev, rq);\n\t\tdestroy_raw_packet_qp_rq(dev, rq);\n\t}\n\n\tif (qp->sq.wqe_cnt) {\n\t\tdestroy_raw_packet_qp_sq(dev, sq);\n\t\tdestroy_raw_packet_qp_tis(dev, sq);\n\t}\n}\n\nstatic void raw_packet_qp_copy_info(struct mlx5_ib_qp *qp,\n\t\t\t\t    struct mlx5_ib_raw_packet_qp *raw_packet_qp)\n{\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\n\tsq->sq = &qp->sq;\n\trq->rq = &qp->rq;\n\tsq->doorbell = &qp->db;\n\trq->doorbell = &qp->db;\n}\n\nstatic void destroy_rss_raw_qp_tir(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tmlx5_core_destroy_tir(dev->mdev, qp->rss_qp.tirn);\n}\n\nstatic int create_rss_raw_qp_tir(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\t struct ib_pd *pd,\n\t\t\t\t struct ib_qp_init_attr *init_attr,\n\t\t\t\t struct ib_udata *udata)\n{\n\tstruct ib_uobject *uobj = pd->uobject;\n\tstruct ib_ucontext *ucontext = uobj->context;\n\tstruct mlx5_ib_ucontext *mucontext = to_mucontext(ucontext);\n\tstruct mlx5_ib_create_qp_resp resp = {};\n\tint inlen;\n\tint err;\n\tu32 *in;\n\tvoid *tirc;\n\tvoid *hfso;\n\tu32 selected_fields = 0;\n\tu32 outer_l4;\n\tsize_t min_resp_len;\n\tu32 tdn = mucontext->tdn;\n\tstruct mlx5_ib_create_qp_rss ucmd = {};\n\tsize_t required_cmd_sz;\n\n\tif (init_attr->qp_type != IB_QPT_RAW_PACKET)\n\t\treturn -EOPNOTSUPP;\n\n\tif (init_attr->create_flags || init_attr->send_cq)\n\t\treturn -EINVAL;\n\n\tmin_resp_len = offsetof(typeof(resp), bfreg_index) + sizeof(resp.bfreg_index);\n\tif (udata->outlen < min_resp_len)\n\t\treturn -EINVAL;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), flags) + sizeof(ucmd.flags);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tmlx5_ib_dbg(dev, \"invalid inlen\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tmlx5_ib_dbg(dev, \"inlen is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen))) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ucmd.comp_mask) {\n\t\tmlx5_ib_dbg(dev, \"invalid comp mask\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd.flags & ~MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\tmlx5_ib_dbg(dev, \"invalid flags\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS &&\n\t    !tunnel_offload_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"tunnel offloads isn't supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_INNER &&\n\t    !(ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS)) {\n\t\tmlx5_ib_dbg(dev, \"Tunnel offloads must be set for inner RSS\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = ib_copy_to_udata(udata, &resp, min(udata->outlen, sizeof(resp)));\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_tir_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\ttirc = MLX5_ADDR_OF(create_tir_in, in, ctx);\n\tMLX5_SET(tirc, tirc, disp_type,\n\t\t MLX5_TIRC_DISP_TYPE_INDIRECT);\n\tMLX5_SET(tirc, tirc, indirect_table,\n\t\t init_attr->rwq_ind_tbl->ind_tbl_num);\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\n\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\n\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS)\n\t\tMLX5_SET(tirc, tirc, tunneled_offload_en, 1);\n\n\tif (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_INNER)\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner);\n\telse\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\n\tswitch (ucmd.rx_hash_function) {\n\tcase MLX5_RX_HASH_FUNC_TOEPLITZ:\n\t{\n\t\tvoid *rss_key = MLX5_ADDR_OF(tirc, tirc, rx_hash_toeplitz_key);\n\t\tsize_t len = MLX5_FLD_SZ_BYTES(tirc, rx_hash_toeplitz_key);\n\n\t\tif (len != ucmd.rx_key_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tMLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_TOEPLITZ);\n\t\tMLX5_SET(tirc, tirc, rx_hash_symmetric, 1);\n\t\tmemcpy(rss_key, ucmd.rx_hash_key, len);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (!ucmd.rx_hash_fields_mask) {\n\t\t/* special case when this TIR serves as steering entry without hashing */\n\t\tif (!init_attr->rwq_ind_tbl->log_ind_tbl_size)\n\t\t\tgoto create_tir;\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t     (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4)) &&\n\t     ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6) ||\n\t     (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* If none of IPV4 & IPV6 SRC/DST was set - this bit field is ignored */\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type,\n\t\t\t MLX5_L3_PROT_TYPE_IPV4);\n\telse if ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6) ||\n\t\t (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type,\n\t\t\t MLX5_L3_PROT_TYPE_IPV6);\n\n\touter_l4 = ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP)) << 0 |\n\t\t   ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP) ||\n\t\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP)) << 1 |\n\t\t   (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_IPSEC_SPI) << 2;\n\n\t/* Check that only one l4 protocol is set */\n\tif (outer_l4 & (outer_l4 - 1)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* If none of TCP & UDP SRC/DST was set - this bit field is ignored */\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type,\n\t\t\t MLX5_L4_PROT_TYPE_TCP);\n\telse if ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP) ||\n\t\t (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type,\n\t\t\t MLX5_L4_PROT_TYPE_UDP);\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_SRC_IP;\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_DST_IP;\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_L4_SPORT;\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_L4_DPORT;\n\n\tif (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_IPSEC_SPI)\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_IPSEC_SPI;\n\n\tMLX5_SET(rx_hash_field_select, hfso, selected_fields, selected_fields);\n\ncreate_tir:\n\tif (dev->rep)\n\t\tMLX5_SET(tirc, tirc, self_lb_block,\n\t\t\t MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST_);\n\n\terr = mlx5_core_create_tir(dev->mdev, in, inlen, &qp->rss_qp.tirn);\n\n\tif (err)\n\t\tgoto err;\n\n\tkvfree(in);\n\t/* qpn is reserved for that QP */\n\tqp->trans_qp.base.mqp.qpn = 0;\n\tqp->flags |= MLX5_IB_QP_RSS;\n\treturn 0;\n\nerr:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_create_qp_resp resp;\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&qp->mutex);\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr->create_flags &\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n\t\t    (init_attr->qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd && pd->uobject) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\t\t&ucmd, udata->inlen, &uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\n\t\tqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp->tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr->qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev->mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp->underlay_qpn = init_attr->source_qpn;\n\t\t}\n\t} else {\n\t\tqp->wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\n\t\t\t  qp, (pd && pd->uobject) ? &ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd->uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, \"invalid rq params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count > max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr->create_flags &\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n\t\t\t\t\t     &resp, &inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp->flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"create qp failed\\n\");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq)\n\t__acquires(&send_cq->lock) __acquires(&recv_cq->lock)\n{\n\tif (send_cq) {\n\t\tif (recv_cq) {\n\t\t\tif (send_cq->mcq.cqn < recv_cq->mcq.cqn)  {\n\t\t\t\tspin_lock(&send_cq->lock);\n\t\t\t\tspin_lock_nested(&recv_cq->lock,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\t\t} else if (send_cq->mcq.cqn == recv_cq->mcq.cqn) {\n\t\t\t\tspin_lock(&send_cq->lock);\n\t\t\t\t__acquire(&recv_cq->lock);\n\t\t\t} else {\n\t\t\t\tspin_lock(&recv_cq->lock);\n\t\t\t\tspin_lock_nested(&send_cq->lock,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&send_cq->lock);\n\t\t\t__acquire(&recv_cq->lock);\n\t\t}\n\t} else if (recv_cq) {\n\t\tspin_lock(&recv_cq->lock);\n\t\t__acquire(&send_cq->lock);\n\t} else {\n\t\t__acquire(&send_cq->lock);\n\t\t__acquire(&recv_cq->lock);\n\t}\n}\n\nstatic void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq)\n\t__releases(&send_cq->lock) __releases(&recv_cq->lock)\n{\n\tif (send_cq) {\n\t\tif (recv_cq) {\n\t\t\tif (send_cq->mcq.cqn < recv_cq->mcq.cqn)  {\n\t\t\t\tspin_unlock(&recv_cq->lock);\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t} else if (send_cq->mcq.cqn == recv_cq->mcq.cqn) {\n\t\t\t\t__release(&recv_cq->lock);\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t\tspin_unlock(&recv_cq->lock);\n\t\t\t}\n\t\t} else {\n\t\t\t__release(&recv_cq->lock);\n\t\t\tspin_unlock(&send_cq->lock);\n\t\t}\n\t} else if (recv_cq) {\n\t\t__release(&send_cq->lock);\n\t\tspin_unlock(&recv_cq->lock);\n\t} else {\n\t\t__release(&recv_cq->lock);\n\t\t__release(&send_cq->lock);\n\t}\n}\n\nstatic struct mlx5_ib_pd *get_pd(struct mlx5_ib_qp *qp)\n{\n\treturn to_mpd(qp->ibqp.pd);\n}\n\nstatic void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq)\n{\n\tswitch (qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\tcase MLX5_IB_QPT_REG_UMR:\n\tcase IB_QPT_XRC_INI:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_RAW_IPV6:\n\tcase IB_QPT_RAW_ETHERTYPE:\n\tcase IB_QPT_RAW_PACKET:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = ib_recv_cq ? to_mcq(ib_recv_cq) : NULL;\n\t\tbreak;\n\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct mlx5_modify_raw_qp_param *raw_qp_param,\n\t\t\t\tu8 lag_tx_affinity);\n\nstatic void destroy_qp_common(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_cq *send_cq, *recv_cq;\n\tstruct mlx5_ib_qp_base *base;\n\tunsigned long flags;\n\tint err;\n\n\tif (qp->ibqp.rwq_ind_tbl) {\n\t\tdestroy_rss_raw_qp_tir(dev, qp);\n\t\treturn;\n\t}\n\n\tbase = (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tif (qp->state != IB_QPS_RESET) {\n\t\tif (qp->ibqp.qp_type != IB_QPT_RAW_PACKET &&\n\t\t    !(qp->flags & MLX5_IB_QP_UNDERLAY)) {\n\t\t\terr = mlx5_core_qp_modify(dev->mdev,\n\t\t\t\t\t\t  MLX5_CMD_OP_2RST_QP, 0,\n\t\t\t\t\t\t  NULL, &base->mqp);\n\t\t} else {\n\t\t\tstruct mlx5_modify_raw_qp_param raw_qp_param = {\n\t\t\t\t.operation = MLX5_CMD_OP_2RST_QP\n\t\t\t};\n\n\t\t\terr = modify_raw_packet_qp(dev, qp, &raw_qp_param, 0);\n\t\t}\n\t\tif (err)\n\t\t\tmlx5_ib_warn(dev, \"mlx5_ib: modify QP 0x%06x to RESET failed\\n\",\n\t\t\t\t     base->mqp.qpn);\n\t}\n\n\tget_cqs(qp->ibqp.qp_type, qp->ibqp.send_cq, qp->ibqp.recv_cq,\n\t\t&send_cq, &recv_cq);\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* del from lists under both locks above to protect reset flow paths */\n\tlist_del(&qp->qps_list);\n\tif (send_cq)\n\t\tlist_del(&qp->cq_send_list);\n\n\tif (recv_cq)\n\t\tlist_del(&qp->cq_recv_list);\n\n\tif (qp->create_type == MLX5_QP_KERNEL) {\n\t\t__mlx5_ib_cq_clean(recv_cq, base->mqp.qpn,\n\t\t\t\t   qp->ibqp.srq ? to_msrq(qp->ibqp.srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\t__mlx5_ib_cq_clean(send_cq, base->mqp.qpn,\n\t\t\t\t\t   NULL);\n\t}\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\tif (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tdestroy_raw_packet_qp(dev, qp);\n\t} else {\n\t\terr = mlx5_core_destroy_qp(dev->mdev, &base->mqp);\n\t\tif (err)\n\t\t\tmlx5_ib_warn(dev, \"failed to destroy QP 0x%x\\n\",\n\t\t\t\t     base->mqp.qpn);\n\t}\n\n\tif (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\telse if (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, &get_pd(qp)->ibpd, qp, base);\n}\n\nstatic const char *ib_qp_type_str(enum ib_qp_type type)\n{\n\tswitch (type) {\n\tcase IB_QPT_SMI:\n\t\treturn \"IB_QPT_SMI\";\n\tcase IB_QPT_GSI:\n\t\treturn \"IB_QPT_GSI\";\n\tcase IB_QPT_RC:\n\t\treturn \"IB_QPT_RC\";\n\tcase IB_QPT_UC:\n\t\treturn \"IB_QPT_UC\";\n\tcase IB_QPT_UD:\n\t\treturn \"IB_QPT_UD\";\n\tcase IB_QPT_RAW_IPV6:\n\t\treturn \"IB_QPT_RAW_IPV6\";\n\tcase IB_QPT_RAW_ETHERTYPE:\n\t\treturn \"IB_QPT_RAW_ETHERTYPE\";\n\tcase IB_QPT_XRC_INI:\n\t\treturn \"IB_QPT_XRC_INI\";\n\tcase IB_QPT_XRC_TGT:\n\t\treturn \"IB_QPT_XRC_TGT\";\n\tcase IB_QPT_RAW_PACKET:\n\t\treturn \"IB_QPT_RAW_PACKET\";\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\treturn \"MLX5_IB_QPT_REG_UMR\";\n\tcase IB_QPT_DRIVER:\n\t\treturn \"IB_QPT_DRIVER\";\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\treturn \"Invalid QP type\";\n\t}\n}\n\nstatic struct ib_qp *mlx5_ib_create_dct(struct ib_pd *pd,\n\t\t\t\t\tstruct ib_qp_init_attr *attr,\n\t\t\t\t\tstruct mlx5_ib_create_qp *ucmd)\n{\n\tstruct mlx5_ib_qp *qp;\n\tint err = 0;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tvoid *dctc;\n\n\tif (!attr->srq || !attr->recv_cq)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\tucmd, sizeof(*ucmd), &uidx);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);\n\tif (!qp->dct.in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tqp->qp_sub_type = MLX5_IB_QPT_DCT;\n\tMLX5_SET(dctc, dctc, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(dctc, dctc, srqn_xrqn, to_msrq(attr->srq)->msrq.srqn);\n\tMLX5_SET(dctc, dctc, cqn, to_mcq(attr->recv_cq)->mcq.cqn);\n\tMLX5_SET64(dctc, dctc, dc_access_key, ucmd->access_key);\n\tMLX5_SET(dctc, dctc, user_index, uidx);\n\n\tqp->state = IB_QPS_RESET;\n\n\treturn &qp->ibqp;\nerr_free:\n\tkfree(qp);\n\treturn ERR_PTR(err);\n}\n\nstatic int set_mlx_qp_type(struct mlx5_ib_dev *dev,\n\t\t\t   struct ib_qp_init_attr *init_attr,\n\t\t\t   struct mlx5_ib_create_qp *ucmd,\n\t\t\t   struct ib_udata *udata)\n{\n\tenum { MLX_QP_FLAGS = MLX5_QP_FLAG_TYPE_DCT | MLX5_QP_FLAG_TYPE_DCI };\n\tint err;\n\n\tif (!udata)\n\t\treturn -EINVAL;\n\n\tif (udata->inlen < sizeof(*ucmd)) {\n\t\tmlx5_ib_dbg(dev, \"create_qp user command is smaller than expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr = ib_copy_from_udata(ucmd, udata, sizeof(*ucmd));\n\tif (err)\n\t\treturn err;\n\n\tif ((ucmd->flags & MLX_QP_FLAGS) == MLX5_QP_FLAG_TYPE_DCI) {\n\t\tinit_attr->qp_type = MLX5_IB_QPT_DCI;\n\t} else {\n\t\tif ((ucmd->flags & MLX_QP_FLAGS) == MLX5_QP_FLAG_TYPE_DCT) {\n\t\t\tinit_attr->qp_type = MLX5_IB_QPT_DCT;\n\t\t} else {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid QP flags\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!MLX5_CAP_GEN(dev->mdev, dct)) {\n\t\tmlx5_ib_dbg(dev, \"DC transport is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstruct ib_qp *mlx5_ib_create_qp(struct ib_pd *pd,\n\t\t\t\tstruct ib_qp_init_attr *verbs_init_attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev;\n\tstruct mlx5_ib_qp *qp;\n\tu16 xrcdn = 0;\n\tint err;\n\tstruct ib_qp_init_attr mlx_init_attr;\n\tstruct ib_qp_init_attr *init_attr = verbs_init_attr;\n\n\tif (pd) {\n\t\tdev = to_mdev(pd->device);\n\n\t\tif (init_attr->qp_type == IB_QPT_RAW_PACKET) {\n\t\t\tif (!pd->uobject) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Raw Packet QP is not supported for kernel consumers\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t} else if (!to_mucontext(pd->uobject->context)->cqe_version) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Raw Packet QP is only supported for CQE version > 0\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* being cautious here */\n\t\tif (init_attr->qp_type != IB_QPT_XRC_TGT &&\n\t\t    init_attr->qp_type != MLX5_IB_QPT_REG_UMR) {\n\t\t\tpr_warn(\"%s: no PD for transport %s\\n\", __func__,\n\t\t\t\tib_qp_type_str(init_attr->qp_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdev = to_mdev(to_mxrcd(init_attr->xrcd)->ibxrcd.device);\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_DRIVER) {\n\t\tstruct mlx5_ib_create_qp ucmd;\n\n\t\tinit_attr = &mlx_init_attr;\n\t\tmemcpy(init_attr, verbs_init_attr, sizeof(*verbs_init_attr));\n\t\terr = set_mlx_qp_type(dev, init_attr, &ucmd, udata);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tif (init_attr->qp_type == MLX5_IB_QPT_DCI) {\n\t\t\tif (init_attr->cap.max_recv_wr ||\n\t\t\t    init_attr->cap.max_recv_sge) {\n\t\t\t\tmlx5_ib_dbg(dev, \"DCI QP requires zero size receive queue\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t} else {\n\t\t\treturn mlx5_ib_create_dct(pd, init_attr, &ucmd);\n\t\t}\n\t}\n\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\tcase IB_QPT_XRC_INI:\n\t\tif (!MLX5_CAP_GEN(dev->mdev, xrc)) {\n\t\t\tmlx5_ib_dbg(dev, \"XRC not supported\\n\");\n\t\t\treturn ERR_PTR(-ENOSYS);\n\t\t}\n\t\tinit_attr->recv_cq = NULL;\n\t\tif (init_attr->qp_type == IB_QPT_XRC_TGT) {\n\t\t\txrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;\n\t\t\tinit_attr->send_cq = NULL;\n\t\t}\n\n\t\t/* fall through */\n\tcase IB_QPT_RAW_PACKET:\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase MLX5_IB_QPT_REG_UMR:\n\tcase MLX5_IB_QPT_DCI:\n\t\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\t\tif (!qp)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = create_qp_common(dev, pd, init_attr, udata, qp);\n\t\tif (err) {\n\t\t\tmlx5_ib_dbg(dev, \"create_qp_common failed\\n\");\n\t\t\tkfree(qp);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tif (is_qp0(init_attr->qp_type))\n\t\t\tqp->ibqp.qp_num = 0;\n\t\telse if (is_qp1(init_attr->qp_type))\n\t\t\tqp->ibqp.qp_num = 1;\n\t\telse\n\t\t\tqp->ibqp.qp_num = qp->trans_qp.base.mqp.qpn;\n\n\t\tmlx5_ib_dbg(dev, \"ib qpnum 0x%x, mlx qpn 0x%x, rcqn 0x%x, scqn 0x%x\\n\",\n\t\t\t    qp->ibqp.qp_num, qp->trans_qp.base.mqp.qpn,\n\t\t\t    init_attr->recv_cq ? to_mcq(init_attr->recv_cq)->mcq.cqn : -1,\n\t\t\t    init_attr->send_cq ? to_mcq(init_attr->send_cq)->mcq.cqn : -1);\n\n\t\tqp->trans_qp.xrcdn = xrcdn;\n\n\t\tbreak;\n\n\tcase IB_QPT_GSI:\n\t\treturn mlx5_ib_gsi_create_qp(pd, init_attr);\n\n\tcase IB_QPT_RAW_IPV6:\n\tcase IB_QPT_RAW_ETHERTYPE:\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\tmlx5_ib_dbg(dev, \"unsupported qp type %d\\n\",\n\t\t\t    init_attr->qp_type);\n\t\t/* Don't support raw QPs */\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (verbs_init_attr->qp_type == IB_QPT_DRIVER)\n\t\tqp->qp_sub_type = init_attr->qp_type;\n\n\treturn &qp->ibqp;\n}\n\nstatic int mlx5_ib_destroy_dct(struct mlx5_ib_qp *mqp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(mqp->ibqp.device);\n\n\tif (mqp->state == IB_QPS_RTR) {\n\t\tint err;\n\n\t\terr = mlx5_core_destroy_dct(dev->mdev, &mqp->dct.mdct);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"failed to destroy DCT %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tkfree(mqp->dct.in);\n\tkfree(mqp);\n\treturn 0;\n}\n\nint mlx5_ib_destroy_qp(struct ib_qp *qp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\n\tif (unlikely(qp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_destroy_qp(qp);\n\n\tif (mqp->qp_sub_type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_destroy_dct(mqp);\n\n\tdestroy_qp_common(dev, mqp);\n\n\tkfree(mqp);\n\n\treturn 0;\n}\n\nstatic __be32 to_mlx5_access_flags(struct mlx5_ib_qp *qp, const struct ib_qp_attr *attr,\n\t\t\t\t   int attr_mask)\n{\n\tu32 hw_access_flags = 0;\n\tu8 dest_rd_atomic;\n\tu32 access_flags;\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tdest_rd_atomic = attr->max_dest_rd_atomic;\n\telse\n\t\tdest_rd_atomic = qp->trans_qp.resp_depth;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\taccess_flags = attr->qp_access_flags;\n\telse\n\t\taccess_flags = qp->trans_qp.atomic_rd_en;\n\n\tif (!dest_rd_atomic)\n\t\taccess_flags &= IB_ACCESS_REMOTE_WRITE;\n\n\tif (access_flags & IB_ACCESS_REMOTE_READ)\n\t\thw_access_flags |= MLX5_QP_BIT_RRE;\n\tif (access_flags & IB_ACCESS_REMOTE_ATOMIC)\n\t\thw_access_flags |= (MLX5_QP_BIT_RAE | MLX5_ATOMIC_MODE_CX);\n\tif (access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\thw_access_flags |= MLX5_QP_BIT_RWE;\n\n\treturn cpu_to_be32(hw_access_flags);\n}\n\nenum {\n\tMLX5_PATH_FLAG_FL\t= 1 << 0,\n\tMLX5_PATH_FLAG_FREE_AR\t= 1 << 1,\n\tMLX5_PATH_FLAG_COUNTER\t= 1 << 2,\n};\n\nstatic int ib_rate_to_mlx5(struct mlx5_ib_dev *dev, u8 rate)\n{\n\tif (rate == IB_RATE_PORT_CURRENT)\n\t\treturn 0;\n\n\tif (rate < IB_RATE_2_5_GBPS || rate > IB_RATE_300_GBPS)\n\t\treturn -EINVAL;\n\n\twhile (rate != IB_RATE_PORT_CURRENT &&\n\t       !(1 << (rate + MLX5_STAT_RATE_OFFSET) &\n\t\t MLX5_CAP_GEN(dev->mdev, stat_rate_support)))\n\t\t--rate;\n\n\treturn rate ? rate + MLX5_STAT_RATE_OFFSET : rate;\n}\n\nstatic int modify_raw_packet_eth_prio(struct mlx5_core_dev *dev,\n\t\t\t\t      struct mlx5_ib_sq *sq, u8 sl)\n{\n\tvoid *in;\n\tvoid *tisc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tis_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_tis_in, in, bitmask.prio, 1);\n\n\ttisc = MLX5_ADDR_OF(modify_tis_in, in, ctx);\n\tMLX5_SET(tisc, tisc, prio, ((sl & 0x7) << 1));\n\n\terr = mlx5_core_modify_tis(dev, sq->tisn, in, inlen);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int modify_raw_packet_tx_affinity(struct mlx5_core_dev *dev,\n\t\t\t\t\t struct mlx5_ib_sq *sq, u8 tx_affinity)\n{\n\tvoid *in;\n\tvoid *tisc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tis_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_tis_in, in, bitmask.lag_tx_port_affinity, 1);\n\n\ttisc = MLX5_ADDR_OF(modify_tis_in, in, ctx);\n\tMLX5_SET(tisc, tisc, lag_tx_port_affinity, tx_affinity);\n\n\terr = mlx5_core_modify_tis(dev, sq->tisn, in, inlen);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int mlx5_set_path(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t const struct rdma_ah_attr *ah,\n\t\t\t struct mlx5_qp_path *path, u8 port, int attr_mask,\n\t\t\t u32 path_flags, const struct ib_qp_attr *attr,\n\t\t\t bool alt)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah);\n\tint err;\n\tenum ib_gid_type gid_type;\n\tu8 ah_flags = rdma_ah_get_ah_flags(ah);\n\tu8 sl = rdma_ah_get_sl(ah);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tpath->pkey_index = cpu_to_be16(alt ? attr->alt_pkey_index :\n\t\t\t\t\t\t     attr->pkey_index);\n\n\tif (ah_flags & IB_AH_GRH) {\n\t\tif (grh->sgid_index >=\n\t\t    dev->mdev->port_caps[port - 1].gid_table_len) {\n\t\t\tpr_err(\"sgid_index (%u) too large. max is %d\\n\",\n\t\t\t       grh->sgid_index,\n\t\t\t       dev->mdev->port_caps[port - 1].gid_table_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ah->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tif (!(ah_flags & IB_AH_GRH))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(path->rmac, ah->roce.dmac, sizeof(ah->roce.dmac));\n\t\tif (qp->ibqp.qp_type == IB_QPT_RC ||\n\t\t    qp->ibqp.qp_type == IB_QPT_UC ||\n\t\t    qp->ibqp.qp_type == IB_QPT_XRC_INI ||\n\t\t    qp->ibqp.qp_type == IB_QPT_XRC_TGT)\n\t\t\tpath->udp_sport =\n\t\t\t\tmlx5_get_roce_udp_sport(dev, ah->grh.sgid_attr);\n\t\tpath->dci_cfi_prio_sl = (sl & 0x7) << 4;\n\t\tgid_type = ah->grh.sgid_attr->gid_type;\n\t\tif (gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)\n\t\t\tpath->ecn_dscp = (grh->traffic_class >> 2) & 0x3f;\n\t} else {\n\t\tpath->fl_free_ar = (path_flags & MLX5_PATH_FLAG_FL) ? 0x80 : 0;\n\t\tpath->fl_free_ar |=\n\t\t\t(path_flags & MLX5_PATH_FLAG_FREE_AR) ? 0x40 : 0;\n\t\tpath->rlid = cpu_to_be16(rdma_ah_get_dlid(ah));\n\t\tpath->grh_mlid = rdma_ah_get_path_bits(ah) & 0x7f;\n\t\tif (ah_flags & IB_AH_GRH)\n\t\t\tpath->grh_mlid\t|= 1 << 7;\n\t\tpath->dci_cfi_prio_sl = sl & 0xf;\n\t}\n\n\tif (ah_flags & IB_AH_GRH) {\n\t\tpath->mgid_index = grh->sgid_index;\n\t\tpath->hop_limit  = grh->hop_limit;\n\t\tpath->tclass_flowlabel =\n\t\t\tcpu_to_be32((grh->traffic_class << 20) |\n\t\t\t\t    (grh->flow_label));\n\t\tmemcpy(path->rgid, grh->dgid.raw, 16);\n\t}\n\n\terr = ib_rate_to_mlx5(dev, rdma_ah_get_static_rate(ah));\n\tif (err < 0)\n\t\treturn err;\n\tpath->static_rate = err;\n\tpath->port = port;\n\n\tif (attr_mask & IB_QP_TIMEOUT)\n\t\tpath->ackto_lt = (alt ? attr->alt_timeout : attr->timeout) << 3;\n\n\tif ((qp->ibqp.qp_type == IB_QPT_RAW_PACKET) && qp->sq.wqe_cnt)\n\t\treturn modify_raw_packet_eth_prio(dev->mdev,\n\t\t\t\t\t\t  &qp->raw_packet_qp.sq,\n\t\t\t\t\t\t  sl & 0xf);\n\n\treturn 0;\n}\n\nstatic enum mlx5_qp_optpar opt_mask[MLX5_QP_NUM_STATE][MLX5_QP_NUM_STATE][MLX5_QP_ST_MAX] = {\n\t[MLX5_QP_STATE_INIT] = {\n\t\t[MLX5_QP_STATE_INIT] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_Q_KEY\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t},\n\t\t[MLX5_QP_STATE_RTR] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH  |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH  |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_PKEY_INDEX     |\n\t\t\t\t\t  MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_XRC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_RTR] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_RTS] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_SRQN\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_CQN_RCV,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_SQER] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_UD]\t = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_UC]\t = MLX5_QP_OPTPAR_RWE,\n\t\t\t[MLX5_QP_ST_RC]\t = MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RRE,\n\t\t},\n\t},\n};\n\nstatic int ib_nr_to_mlx5_nr(int ib_mask)\n{\n\tswitch (ib_mask) {\n\tcase IB_QP_STATE:\n\t\treturn 0;\n\tcase IB_QP_CUR_STATE:\n\t\treturn 0;\n\tcase IB_QP_EN_SQD_ASYNC_NOTIFY:\n\t\treturn 0;\n\tcase IB_QP_ACCESS_FLAGS:\n\t\treturn MLX5_QP_OPTPAR_RWE | MLX5_QP_OPTPAR_RRE |\n\t\t\tMLX5_QP_OPTPAR_RAE;\n\tcase IB_QP_PKEY_INDEX:\n\t\treturn MLX5_QP_OPTPAR_PKEY_INDEX;\n\tcase IB_QP_PORT:\n\t\treturn MLX5_QP_OPTPAR_PRI_PORT;\n\tcase IB_QP_QKEY:\n\t\treturn MLX5_QP_OPTPAR_Q_KEY;\n\tcase IB_QP_AV:\n\t\treturn MLX5_QP_OPTPAR_PRIMARY_ADDR_PATH |\n\t\t\tMLX5_QP_OPTPAR_PRI_PORT;\n\tcase IB_QP_PATH_MTU:\n\t\treturn 0;\n\tcase IB_QP_TIMEOUT:\n\t\treturn MLX5_QP_OPTPAR_ACK_TIMEOUT;\n\tcase IB_QP_RETRY_CNT:\n\t\treturn MLX5_QP_OPTPAR_RETRY_COUNT;\n\tcase IB_QP_RNR_RETRY:\n\t\treturn MLX5_QP_OPTPAR_RNR_RETRY;\n\tcase IB_QP_RQ_PSN:\n\t\treturn 0;\n\tcase IB_QP_MAX_QP_RD_ATOMIC:\n\t\treturn MLX5_QP_OPTPAR_SRA_MAX;\n\tcase IB_QP_ALT_PATH:\n\t\treturn MLX5_QP_OPTPAR_ALT_ADDR_PATH;\n\tcase IB_QP_MIN_RNR_TIMER:\n\t\treturn MLX5_QP_OPTPAR_RNR_TIMEOUT;\n\tcase IB_QP_SQ_PSN:\n\t\treturn 0;\n\tcase IB_QP_MAX_DEST_RD_ATOMIC:\n\t\treturn MLX5_QP_OPTPAR_RRA_MAX | MLX5_QP_OPTPAR_RWE |\n\t\t\tMLX5_QP_OPTPAR_RRE | MLX5_QP_OPTPAR_RAE;\n\tcase IB_QP_PATH_MIG_STATE:\n\t\treturn MLX5_QP_OPTPAR_PM_STATE;\n\tcase IB_QP_CAP:\n\t\treturn 0;\n\tcase IB_QP_DEST_QPN:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int ib_mask_to_mlx5_opt(int ib_mask)\n{\n\tint result = 0;\n\tint i;\n\n\tfor (i = 0; i < 8 * sizeof(int); i++) {\n\t\tif ((1 << i) & ib_mask)\n\t\t\tresult |= ib_nr_to_mlx5_nr(1 << i);\n\t}\n\n\treturn result;\n}\n\nstatic int modify_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_rq *rq, int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tvoid *in;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_rq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_rq_in, in, rq_state, rq->state);\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\tMLX5_SET(rqc, rqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID) {\n\t\tif (MLX5_CAP_GEN(dev->mdev, modify_rq_counter_set_id)) {\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\t\t\tMLX5_SET(rqc, rqc, counter_set_id, raw_qp_param->rq_q_ctr_id);\n\t\t} else\n\t\t\tpr_info_once(\"%s: RAW PACKET QP counters are not supported on current FW\\n\",\n\t\t\t\t     dev->ib_dev.name);\n\t}\n\n\terr = mlx5_core_modify_rq(dev->mdev, rq->base.mqp.qpn, in, inlen);\n\tif (err)\n\t\tgoto out;\n\n\trq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int modify_raw_packet_qp_sq(struct mlx5_core_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq,\n\t\t\t\t   int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tstruct mlx5_ib_qp *ibqp = sq->base.container_mibqp;\n\tstruct mlx5_rate_limit old_rl = ibqp->rl;\n\tstruct mlx5_rate_limit new_rl = old_rl;\n\tbool new_rate_added = false;\n\tu16 rl_index = 0;\n\tvoid *in;\n\tvoid *sqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, sq_state, sq->state);\n\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_RATE_LIMIT) {\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tpr_warn(\"%s: Rate limit can only be changed when SQ is moving to RDY\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tnew_rl = raw_qp_param->rl;\n\t}\n\n\tif (!mlx5_rl_are_equal(&old_rl, &new_rl)) {\n\t\tif (new_rl.rate) {\n\t\t\terr = mlx5_rl_add_rate(dev, &rl_index, &new_rl);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed configuring rate limit(err %d): \\\n\t\t\t\t       rate %u, max_burst_sz %u, typical_pkt_sz %u\\n\",\n\t\t\t\t       err, new_rl.rate, new_rl.max_burst_sz,\n\t\t\t\t       new_rl.typical_pkt_sz);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnew_rate_added = true;\n\t\t}\n\n\t\tMLX5_SET64(modify_sq_in, in, modify_bitmask, 1);\n\t\t/* index 0 means no limit */\n\t\tMLX5_SET(sqc, sqc, packet_pacing_rate_limit_index, rl_index);\n\t}\n\n\terr = mlx5_core_modify_sq(dev, sq->base.mqp.qpn, in, inlen);\n\tif (err) {\n\t\t/* Remove new rate from table if failed */\n\t\tif (new_rate_added)\n\t\t\tmlx5_rl_remove_rate(dev, &new_rl);\n\t\tgoto out;\n\t}\n\n\t/* Only remove the old rate after new rate was set */\n\tif ((old_rl.rate &&\n\t     !mlx5_rl_are_equal(&old_rl, &new_rl)) ||\n\t    (new_state != MLX5_SQC_STATE_RDY))\n\t\tmlx5_rl_remove_rate(dev, &old_rl);\n\n\tibqp->rl = new_rl;\n\tsq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct mlx5_modify_raw_qp_param *raw_qp_param,\n\t\t\t\tu8 tx_affinity)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tint modify_rq = !!qp->rq.wqe_cnt;\n\tint modify_sq = !!qp->sq.wqe_cnt;\n\tint rq_state;\n\tint sq_state;\n\tint err;\n\n\tswitch (raw_qp_param->operation) {\n\tcase MLX5_CMD_OP_RST2INIT_QP:\n\t\trq_state = MLX5_RQC_STATE_RDY;\n\t\tsq_state = MLX5_SQC_STATE_RDY;\n\t\tbreak;\n\tcase MLX5_CMD_OP_2ERR_QP:\n\t\trq_state = MLX5_RQC_STATE_ERR;\n\t\tsq_state = MLX5_SQC_STATE_ERR;\n\t\tbreak;\n\tcase MLX5_CMD_OP_2RST_QP:\n\t\trq_state = MLX5_RQC_STATE_RST;\n\t\tsq_state = MLX5_SQC_STATE_RST;\n\t\tbreak;\n\tcase MLX5_CMD_OP_RTR2RTS_QP:\n\tcase MLX5_CMD_OP_RTS2RTS_QP:\n\t\tif (raw_qp_param->set_mask ==\n\t\t    MLX5_RAW_QP_RATE_LIMIT) {\n\t\t\tmodify_rq = 0;\n\t\t\tsq_state = sq->state;\n\t\t} else {\n\t\t\treturn raw_qp_param->set_mask ? -EINVAL : 0;\n\t\t}\n\t\tbreak;\n\tcase MLX5_CMD_OP_INIT2INIT_QP:\n\tcase MLX5_CMD_OP_INIT2RTR_QP:\n\t\tif (raw_qp_param->set_mask)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (modify_rq) {\n\t\terr =  modify_raw_packet_qp_rq(dev, rq, rq_state, raw_qp_param);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (modify_sq) {\n\t\tif (tx_affinity) {\n\t\t\terr = modify_raw_packet_tx_affinity(dev->mdev, sq,\n\t\t\t\t\t\t\t    tx_affinity);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\treturn modify_raw_packet_qp_sq(dev->mdev, sq, sq_state, raw_qp_param);\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlx5_ib_modify_qp(struct ib_qp *ibqp,\n\t\t\t       const struct ib_qp_attr *attr, int attr_mask,\n\t\t\t       enum ib_qp_state cur_state, enum ib_qp_state new_state,\n\t\t\t       const struct mlx5_ib_modify_qp *ucmd)\n{\n\tstatic const u16 optab[MLX5_QP_NUM_STATE][MLX5_QP_NUM_STATE] = {\n\t\t[MLX5_QP_STATE_RST] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_INIT]\t= MLX5_CMD_OP_RST2INIT_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_INIT]  = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_INIT]\t= MLX5_CMD_OP_INIT2INIT_QP,\n\t\t\t[MLX5_QP_STATE_RTR]\t= MLX5_CMD_OP_INIT2RTR_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_RTR]   = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_RTR2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_RTS]   = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_RTS2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_SQD] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_SQER] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_SQERR2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_ERR] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t}\n\t};\n\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct mlx5_ib_cq *send_cq, *recv_cq;\n\tstruct mlx5_qp_context *context;\n\tstruct mlx5_ib_pd *pd;\n\tstruct mlx5_ib_port *mibport = NULL;\n\tenum mlx5_qp_state mlx5_cur, mlx5_new;\n\tenum mlx5_qp_optpar optpar;\n\tint mlx5_st;\n\tint err;\n\tu16 op;\n\tu8 tx_affinity = 0;\n\n\tmlx5_st = to_mlx5_st(ibqp->qp_type == IB_QPT_DRIVER ?\n\t\t\t     qp->qp_sub_type : ibqp->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tcontext->flags = cpu_to_be32(mlx5_st << 16);\n\n\tif (!(attr_mask & IB_QP_PATH_MIG_STATE)) {\n\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_MIGRATED << 11);\n\t} else {\n\t\tswitch (attr->path_mig_state) {\n\t\tcase IB_MIG_MIGRATED:\n\t\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_MIGRATED << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_REARM:\n\t\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_REARM << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_ARMED:\n\t\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_ARMED << 11);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((cur_state == IB_QPS_RESET) && (new_state == IB_QPS_INIT)) {\n\t\tif ((ibqp->qp_type == IB_QPT_RC) ||\n\t\t    (ibqp->qp_type == IB_QPT_UD &&\n\t\t     !(qp->flags & MLX5_IB_QP_SQPN_QP1)) ||\n\t\t    (ibqp->qp_type == IB_QPT_UC) ||\n\t\t    (ibqp->qp_type == IB_QPT_RAW_PACKET) ||\n\t\t    (ibqp->qp_type == IB_QPT_XRC_INI) ||\n\t\t    (ibqp->qp_type == IB_QPT_XRC_TGT)) {\n\t\t\tif (mlx5_lag_is_active(dev->mdev)) {\n\t\t\t\tu8 p = mlx5_core_native_port_num(dev->mdev);\n\t\t\t\ttx_affinity = (unsigned int)atomic_add_return(1,\n\t\t\t\t\t\t&dev->roce[p].next_port) %\n\t\t\t\t\t\tMLX5_MAX_PORTS + 1;\n\t\t\t\tcontext->flags |= cpu_to_be32(tx_affinity << 24);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_sqp(ibqp->qp_type)) {\n\t\tcontext->mtu_msgmax = (IB_MTU_256 << 5) | 8;\n\t} else if ((ibqp->qp_type == IB_QPT_UD &&\n\t\t    !(qp->flags & MLX5_IB_QP_UNDERLAY)) ||\n\t\t   ibqp->qp_type == MLX5_IB_QPT_REG_UMR) {\n\t\tcontext->mtu_msgmax = (IB_MTU_4096 << 5) | 12;\n\t} else if (attr_mask & IB_QP_PATH_MTU) {\n\t\tif (attr->path_mtu < IB_MTU_256 ||\n\t\t    attr->path_mtu > IB_MTU_4096) {\n\t\t\tmlx5_ib_warn(dev, \"invalid mtu %d\\n\", attr->path_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->mtu_msgmax = (attr->path_mtu << 5) |\n\t\t\t\t      (u8)MLX5_CAP_GEN(dev->mdev, log_max_msg);\n\t}\n\n\tif (attr_mask & IB_QP_DEST_QPN)\n\t\tcontext->log_pg_sz_remote_qpn = cpu_to_be32(attr->dest_qp_num);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tcontext->pri_path.pkey_index = cpu_to_be16(attr->pkey_index);\n\n\t/* todo implement counter_index functionality */\n\n\tif (is_sqp(ibqp->qp_type))\n\t\tcontext->pri_path.port = qp->port;\n\n\tif (attr_mask & IB_QP_PORT)\n\t\tcontext->pri_path.port = attr->port_num;\n\n\tif (attr_mask & IB_QP_AV) {\n\t\terr = mlx5_set_path(dev, qp, &attr->ah_attr, &context->pri_path,\n\t\t\t\t    attr_mask & IB_QP_PORT ? attr->port_num : qp->port,\n\t\t\t\t    attr_mask, 0, attr, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_TIMEOUT)\n\t\tcontext->pri_path.ackto_lt |= attr->timeout << 3;\n\n\tif (attr_mask & IB_QP_ALT_PATH) {\n\t\terr = mlx5_set_path(dev, qp, &attr->alt_ah_attr,\n\t\t\t\t    &context->alt_path,\n\t\t\t\t    attr->alt_port_num,\n\t\t\t\t    attr_mask | IB_QP_PKEY_INDEX | IB_QP_TIMEOUT,\n\t\t\t\t    0, attr, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tpd = get_pd(qp);\n\tget_cqs(qp->ibqp.qp_type, qp->ibqp.send_cq, qp->ibqp.recv_cq,\n\t\t&send_cq, &recv_cq);\n\n\tcontext->flags_pd = cpu_to_be32(pd ? pd->pdn : to_mpd(dev->devr.p0)->pdn);\n\tcontext->cqn_send = send_cq ? cpu_to_be32(send_cq->mcq.cqn) : 0;\n\tcontext->cqn_recv = recv_cq ? cpu_to_be32(recv_cq->mcq.cqn) : 0;\n\tcontext->params1  = cpu_to_be32(MLX5_IB_ACK_REQ_FREQ << 28);\n\n\tif (attr_mask & IB_QP_RNR_RETRY)\n\t\tcontext->params1 |= cpu_to_be32(attr->rnr_retry << 13);\n\n\tif (attr_mask & IB_QP_RETRY_CNT)\n\t\tcontext->params1 |= cpu_to_be32(attr->retry_cnt << 16);\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tif (attr->max_rd_atomic)\n\t\t\tcontext->params1 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_rd_atomic - 1) << 21);\n\t}\n\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tcontext->next_send_psn = cpu_to_be32(attr->sq_psn);\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tif (attr->max_dest_rd_atomic)\n\t\t\tcontext->params2 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_dest_rd_atomic - 1) << 21);\n\t}\n\n\tif (attr_mask & (IB_QP_ACCESS_FLAGS | IB_QP_MAX_DEST_RD_ATOMIC))\n\t\tcontext->params2 |= to_mlx5_access_flags(qp, attr, attr_mask);\n\n\tif (attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tcontext->rnr_nextrecvpsn |= cpu_to_be32(attr->min_rnr_timer << 24);\n\n\tif (attr_mask & IB_QP_RQ_PSN)\n\t\tcontext->rnr_nextrecvpsn |= cpu_to_be32(attr->rq_psn);\n\n\tif (attr_mask & IB_QP_QKEY)\n\t\tcontext->qkey = cpu_to_be32(attr->qkey);\n\n\tif (qp->rq.wqe_cnt && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\n\t\tcontext->db_rec_addr = cpu_to_be64(qp->db.dma);\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\tu8 port_num = (attr_mask & IB_QP_PORT ? attr->port_num :\n\t\t\t       qp->port) - 1;\n\n\t\t/* Underlay port should be used - index 0 function per port */\n\t\tif (qp->flags & MLX5_IB_QP_UNDERLAY)\n\t\t\tport_num = 0;\n\n\t\tmibport = &dev->port[port_num];\n\t\tcontext->qp_counter_set_usr_page |=\n\t\t\tcpu_to_be32((u32)(mibport->cnts.set_id) << 24);\n\t}\n\n\tif (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\n\t\tcontext->sq_crq_size |= cpu_to_be16(1 << 4);\n\n\tif (qp->flags & MLX5_IB_QP_SQPN_QP1)\n\t\tcontext->deth_sqpn = cpu_to_be32(1);\n\n\tmlx5_cur = to_mlx5_state(cur_state);\n\tmlx5_new = to_mlx5_state(new_state);\n\n\tif (mlx5_cur >= MLX5_QP_NUM_STATE || mlx5_new >= MLX5_QP_NUM_STATE ||\n\t    !optab[mlx5_cur][mlx5_new]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\top = optab[mlx5_cur][mlx5_new];\n\toptpar = ib_mask_to_mlx5_opt(attr_mask);\n\toptpar &= opt_mask[mlx5_cur][mlx5_new][mlx5_st];\n\n\tif (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tstruct mlx5_modify_raw_qp_param raw_qp_param = {};\n\n\t\traw_qp_param.operation = op;\n\t\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\t\traw_qp_param.rq_q_ctr_id = mibport->cnts.set_id;\n\t\t\traw_qp_param.set_mask |= MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID;\n\t\t}\n\n\t\tif (attr_mask & IB_QP_RATE_LIMIT) {\n\t\t\traw_qp_param.rl.rate = attr->rate_limit;\n\n\t\t\tif (ucmd->burst_info.max_burst_sz) {\n\t\t\t\tif (attr->rate_limit &&\n\t\t\t\t    MLX5_CAP_QOS(dev->mdev, packet_pacing_burst_bound)) {\n\t\t\t\t\traw_qp_param.rl.max_burst_sz =\n\t\t\t\t\t\tucmd->burst_info.max_burst_sz;\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ucmd->burst_info.typical_pkt_sz) {\n\t\t\t\tif (attr->rate_limit &&\n\t\t\t\t    MLX5_CAP_QOS(dev->mdev, packet_pacing_typical_size)) {\n\t\t\t\t\traw_qp_param.rl.typical_pkt_sz =\n\t\t\t\t\t\tucmd->burst_info.typical_pkt_sz;\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\traw_qp_param.set_mask |= MLX5_RAW_QP_RATE_LIMIT;\n\t\t}\n\n\t\terr = modify_raw_packet_qp(dev, qp, &raw_qp_param, tx_affinity);\n\t} else {\n\t\terr = mlx5_core_qp_modify(dev->mdev, op, optpar, context,\n\t\t\t\t\t  &base->mqp);\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\tqp->state = new_state;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\tqp->trans_qp.atomic_rd_en = attr->qp_access_flags;\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tqp->trans_qp.resp_depth = attr->max_dest_rd_atomic;\n\tif (attr_mask & IB_QP_PORT)\n\t\tqp->port = attr->port_num;\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\tqp->trans_qp.alt_port = attr->alt_port_num;\n\n\t/*\n\t * If we moved a kernel QP to RESET, clean up all old CQ\n\t * entries and reinitialize the QP.\n\t */\n\tif (new_state == IB_QPS_RESET &&\n\t    !ibqp->uobject && ibqp->qp_type != IB_QPT_XRC_TGT) {\n\t\tmlx5_ib_cq_clean(recv_cq, base->mqp.qpn,\n\t\t\t\t ibqp->srq ? to_msrq(ibqp->srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\tmlx5_ib_cq_clean(send_cq, base->mqp.qpn, NULL);\n\n\t\tqp->rq.head = 0;\n\t\tqp->rq.tail = 0;\n\t\tqp->sq.head = 0;\n\t\tqp->sq.tail = 0;\n\t\tqp->sq.cur_post = 0;\n\t\tqp->sq.last_poll = 0;\n\t\tqp->db.db[MLX5_RCV_DBR] = 0;\n\t\tqp->db.db[MLX5_SND_DBR] = 0;\n\t}\n\nout:\n\tkfree(context);\n\treturn err;\n}\n\nstatic inline bool is_valid_mask(int mask, int req, int opt)\n{\n\tif ((mask & req) != req)\n\t\treturn false;\n\n\tif (mask & ~(req | opt))\n\t\treturn false;\n\n\treturn true;\n}\n\n/* check valid transition for driver QP types\n * for now the only QP type that this function supports is DCI\n */\nstatic bool modify_dci_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state new_state,\n\t\t\t\tenum ib_qp_attr_mask attr_mask)\n{\n\tint req = IB_QP_STATE;\n\tint opt = 0;\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\treq |= IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_INIT) {\n\t\topt = IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\treq |= IB_QP_PATH_MTU;\n\t\topt = IB_QP_PKEY_INDEX;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTR && new_state == IB_QPS_RTS) {\n\t\treq |= IB_QP_TIMEOUT | IB_QP_RETRY_CNT | IB_QP_RNR_RETRY |\n\t\t       IB_QP_MAX_QP_RD_ATOMIC | IB_QP_SQ_PSN;\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTS && new_state == IB_QPS_RTS) {\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state != IB_QPS_RESET && new_state == IB_QPS_ERR) {\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t}\n\treturn false;\n}\n\n/* mlx5_ib_modify_dct: modify a DCT QP\n * valid transitions are:\n * RESET to INIT: must set access_flags, pkey_index and port\n * INIT  to RTR : must set min_rnr_timer, tclass, flow_label,\n *\t\t\t   mtu, gid_index and hop_limit\n * Other transitions and attributes are illegal\n */\nstatic int mlx5_ib_modify_dct(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tenum ib_qp_state cur_state, new_state;\n\tint err = 0;\n\tint required = IB_QP_STATE;\n\tvoid *dctc;\n\n\tif (!(attr_mask & IB_QP_STATE))\n\t\treturn -EINVAL;\n\n\tcur_state = qp->state;\n\tnew_state = attr->qp_state;\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\trequired |= IB_QP_ACCESS_FLAGS | IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\tif (!is_valid_mask(attr_mask, required, 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (attr->port_num == 0 ||\n\t\t    attr->port_num > MLX5_CAP_GEN(dev->mdev, num_ports)) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid port number %d. number of ports is %d\\n\",\n\t\t\t\t    attr->port_num, dev->num_ports);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ)\n\t\t\tMLX5_SET(dctc, dctc, rre, 1);\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\t\tMLX5_SET(dctc, dctc, rwe, 1);\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_ATOMIC) {\n\t\t\tif (!mlx5_ib_dc_atomic_is_supported(dev))\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tMLX5_SET(dctc, dctc, rae, 1);\n\t\t\tMLX5_SET(dctc, dctc, atomic_mode, MLX5_ATOMIC_MODE_DCT_CX);\n\t\t}\n\t\tMLX5_SET(dctc, dctc, pkey_index, attr->pkey_index);\n\t\tMLX5_SET(dctc, dctc, port, attr->port_num);\n\t\tMLX5_SET(dctc, dctc, counter_set_id, dev->port[attr->port_num - 1].cnts.set_id);\n\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\tstruct mlx5_ib_modify_qp_resp resp = {};\n\t\tu32 min_resp_len = offsetof(typeof(resp), dctn) +\n\t\t\t\t   sizeof(resp.dctn);\n\n\t\tif (udata->outlen < min_resp_len)\n\t\t\treturn -EINVAL;\n\t\tresp.response_length = min_resp_len;\n\n\t\trequired |= IB_QP_MIN_RNR_TIMER | IB_QP_AV | IB_QP_PATH_MTU;\n\t\tif (!is_valid_mask(attr_mask, required, 0))\n\t\t\treturn -EINVAL;\n\t\tMLX5_SET(dctc, dctc, min_rnr_nak, attr->min_rnr_timer);\n\t\tMLX5_SET(dctc, dctc, tclass, attr->ah_attr.grh.traffic_class);\n\t\tMLX5_SET(dctc, dctc, flow_label, attr->ah_attr.grh.flow_label);\n\t\tMLX5_SET(dctc, dctc, mtu, attr->path_mtu);\n\t\tMLX5_SET(dctc, dctc, my_addr_index, attr->ah_attr.grh.sgid_index);\n\t\tMLX5_SET(dctc, dctc, hop_limit, attr->ah_attr.grh.hop_limit);\n\n\t\terr = mlx5_core_create_dct(dev->mdev, &qp->dct.mdct, qp->dct.in,\n\t\t\t\t\t   MLX5_ST_SZ_BYTES(create_dct_in));\n\t\tif (err)\n\t\t\treturn err;\n\t\tresp.dctn = qp->dct.mdct.mqp.qpn;\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err) {\n\t\t\tmlx5_core_destroy_dct(dev->mdev, &qp->dct.mdct);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tmlx5_ib_warn(dev, \"Modify DCT: Invalid transition from %d to %d\\n\", cur_state, new_state);\n\t\treturn -EINVAL;\n\t}\n\tif (err)\n\t\tqp->state = IB_QPS_ERR;\n\telse\n\t\tqp->state = new_state;\n\treturn err;\n}\n\nint mlx5_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_modify_qp ucmd = {};\n\tenum ib_qp_type qp_type;\n\tenum ib_qp_state cur_state, new_state;\n\tsize_t required_cmd_sz;\n\tint err = -EINVAL;\n\tint port;\n\tenum rdma_link_layer ll = IB_LINK_LAYER_UNSPECIFIED;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -ENOSYS;\n\n\tif (udata && udata->inlen) {\n\t\trequired_cmd_sz = offsetof(typeof(ucmd), reserved) +\n\t\t\tsizeof(ucmd.reserved);\n\t\tif (udata->inlen < required_cmd_sz)\n\t\t\treturn -EINVAL;\n\n\t\tif (udata->inlen > sizeof(ucmd) &&\n\t\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (ib_copy_from_udata(&ucmd, udata,\n\t\t\t\t       min(udata->inlen, sizeof(ucmd))))\n\t\t\treturn -EFAULT;\n\n\t\tif (ucmd.comp_mask ||\n\t\t    memchr_inv(&ucmd.reserved, 0, sizeof(ucmd.reserved)) ||\n\t\t    memchr_inv(&ucmd.burst_info.reserved, 0,\n\t\t\t       sizeof(ucmd.burst_info.reserved)))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_modify_qp(ibqp, attr, attr_mask);\n\n\tif (ibqp->qp_type == IB_QPT_DRIVER)\n\t\tqp_type = qp->qp_sub_type;\n\telse\n\t\tqp_type = (unlikely(ibqp->qp_type == MLX5_IB_QPT_HW_GSI)) ?\n\t\t\tIB_QPT_GSI : ibqp->qp_type;\n\n\tif (qp_type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_modify_dct(ibqp, attr, attr_mask, udata);\n\n\tmutex_lock(&qp->mutex);\n\n\tcur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;\n\tnew_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;\n\n\tif (!(cur_state == new_state && cur_state == IB_QPS_RESET)) {\n\t\tport = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\t\tll = dev->ib_dev.get_link_layer(&dev->ib_dev, port);\n\t}\n\n\tif (qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tif (attr_mask & ~(IB_QP_STATE | IB_QP_CUR_STATE)) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid attr_mask 0x%x when underlay QP is used\\n\",\n\t\t\t\t    attr_mask);\n\t\t\tgoto out;\n\t\t}\n\t} else if (qp_type != MLX5_IB_QPT_REG_UMR &&\n\t\t   qp_type != MLX5_IB_QPT_DCI &&\n\t\t   !ib_modify_qp_is_ok(cur_state, new_state, qp_type, attr_mask, ll)) {\n\t\tmlx5_ib_dbg(dev, \"invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\\n\",\n\t\t\t    cur_state, new_state, ibqp->qp_type, attr_mask);\n\t\tgoto out;\n\t} else if (qp_type == MLX5_IB_QPT_DCI &&\n\t\t   !modify_dci_qp_is_ok(cur_state, new_state, attr_mask)) {\n\t\tmlx5_ib_dbg(dev, \"invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\\n\",\n\t\t\t    cur_state, new_state, qp_type, attr_mask);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PORT) &&\n\t    (attr->port_num == 0 ||\n\t     attr->port_num > dev->num_ports)) {\n\t\tmlx5_ib_dbg(dev, \"invalid port number %d. number of ports is %d\\n\",\n\t\t\t    attr->port_num, dev->num_ports);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tport = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\t\tif (attr->pkey_index >=\n\t\t    dev->mdev->port_caps[port - 1].pkey_table_len) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid pkey index %d\\n\",\n\t\t\t\t    attr->pkey_index);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&\n\t    attr->max_rd_atomic >\n\t    (1 << MLX5_CAP_GEN(dev->mdev, log_max_ra_res_qp))) {\n\t\tmlx5_ib_dbg(dev, \"invalid max_rd_atomic value %d\\n\",\n\t\t\t    attr->max_rd_atomic);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&\n\t    attr->max_dest_rd_atomic >\n\t    (1 << MLX5_CAP_GEN(dev->mdev, log_max_ra_req_qp))) {\n\t\tmlx5_ib_dbg(dev, \"invalid max_dest_rd_atomic value %d\\n\",\n\t\t\t    attr->max_dest_rd_atomic);\n\t\tgoto out;\n\t}\n\n\tif (cur_state == new_state && cur_state == IB_QPS_RESET) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = __mlx5_ib_modify_qp(ibqp, attr, attr_mask, cur_state,\n\t\t\t\t  new_state, &ucmd);\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstatic int mlx5_wq_overflow(struct mlx5_ib_wq *wq, int nreq, struct ib_cq *ib_cq)\n{\n\tstruct mlx5_ib_cq *cq;\n\tunsigned cur;\n\n\tcur = wq->head - wq->tail;\n\tif (likely(cur + nreq < wq->max_post))\n\t\treturn 0;\n\n\tcq = to_mcq(ib_cq);\n\tspin_lock(&cq->lock);\n\tcur = wq->head - wq->tail;\n\tspin_unlock(&cq->lock);\n\n\treturn cur + nreq >= wq->max_post;\n}\n\nstatic __always_inline void set_raddr_seg(struct mlx5_wqe_raddr_seg *rseg,\n\t\t\t\t\t  u64 remote_addr, u32 rkey)\n{\n\trseg->raddr    = cpu_to_be64(remote_addr);\n\trseg->rkey     = cpu_to_be32(rkey);\n\trseg->reserved = 0;\n}\n\nstatic void *set_eth_seg(struct mlx5_wqe_eth_seg *eseg,\n\t\t\t const struct ib_send_wr *wr, void *qend,\n\t\t\t struct mlx5_ib_qp *qp, int *size)\n{\n\tvoid *seg = eseg;\n\n\tmemset(eseg, 0, sizeof(struct mlx5_wqe_eth_seg));\n\n\tif (wr->send_flags & IB_SEND_IP_CSUM)\n\t\teseg->cs_flags = MLX5_ETH_WQE_L3_CSUM |\n\t\t\t\t MLX5_ETH_WQE_L4_CSUM;\n\n\tseg += sizeof(struct mlx5_wqe_eth_seg);\n\t*size += sizeof(struct mlx5_wqe_eth_seg) / 16;\n\n\tif (wr->opcode == IB_WR_LSO) {\n\t\tstruct ib_ud_wr *ud_wr = container_of(wr, struct ib_ud_wr, wr);\n\t\tint size_of_inl_hdr_start = sizeof(eseg->inline_hdr.start);\n\t\tu64 left, leftlen, copysz;\n\t\tvoid *pdata = ud_wr->header;\n\n\t\tleft = ud_wr->hlen;\n\t\teseg->mss = cpu_to_be16(ud_wr->mss);\n\t\teseg->inline_hdr.sz = cpu_to_be16(left);\n\n\t\t/*\n\t\t * check if there is space till the end of queue, if yes,\n\t\t * copy all in one shot, otherwise copy till the end of queue,\n\t\t * rollback and than the copy the left\n\t\t */\n\t\tleftlen = qend - (void *)eseg->inline_hdr.start;\n\t\tcopysz = min_t(u64, leftlen, left);\n\n\t\tmemcpy(seg - size_of_inl_hdr_start, pdata, copysz);\n\n\t\tif (likely(copysz > size_of_inl_hdr_start)) {\n\t\t\tseg += ALIGN(copysz - size_of_inl_hdr_start, 16);\n\t\t\t*size += ALIGN(copysz - size_of_inl_hdr_start, 16) / 16;\n\t\t}\n\n\t\tif (unlikely(copysz < left)) { /* the last wqe in the queue */\n\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tleft -= copysz;\n\t\t\tpdata += copysz;\n\t\t\tmemcpy(seg, pdata, left);\n\t\t\tseg += ALIGN(left, 16);\n\t\t\t*size += ALIGN(left, 16) / 16;\n\t\t}\n\t}\n\n\treturn seg;\n}\n\nstatic void set_datagram_seg(struct mlx5_wqe_datagram_seg *dseg,\n\t\t\t     const struct ib_send_wr *wr)\n{\n\tmemcpy(&dseg->av, &to_mah(ud_wr(wr)->ah)->av, sizeof(struct mlx5_av));\n\tdseg->av.dqp_dct = cpu_to_be32(ud_wr(wr)->remote_qpn | MLX5_EXTENDED_UD_AV);\n\tdseg->av.key.qkey.qkey = cpu_to_be32(ud_wr(wr)->remote_qkey);\n}\n\nstatic void set_data_ptr_seg(struct mlx5_wqe_data_seg *dseg, struct ib_sge *sg)\n{\n\tdseg->byte_count = cpu_to_be32(sg->length);\n\tdseg->lkey       = cpu_to_be32(sg->lkey);\n\tdseg->addr       = cpu_to_be64(sg->addr);\n}\n\nstatic u64 get_xlt_octo(u64 bytes)\n{\n\treturn ALIGN(bytes, MLX5_IB_UMR_XLT_ALIGNMENT) /\n\t       MLX5_IB_UMR_OCTOWORD;\n}\n\nstatic __be64 frwr_mkey_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LEN\t\t|\n\t\tMLX5_MKEY_MASK_PAGE_SIZE\t|\n\t\tMLX5_MKEY_MASK_START_ADDR\t|\n\t\tMLX5_MKEY_MASK_EN_RINVAL\t|\n\t\tMLX5_MKEY_MASK_KEY\t\t|\n\t\tMLX5_MKEY_MASK_LR\t\t|\n\t\tMLX5_MKEY_MASK_LW\t\t|\n\t\tMLX5_MKEY_MASK_RR\t\t|\n\t\tMLX5_MKEY_MASK_RW\t\t|\n\t\tMLX5_MKEY_MASK_A\t\t|\n\t\tMLX5_MKEY_MASK_SMALL_FENCE\t|\n\t\tMLX5_MKEY_MASK_FREE;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 sig_mkey_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LEN\t\t|\n\t\tMLX5_MKEY_MASK_PAGE_SIZE\t|\n\t\tMLX5_MKEY_MASK_START_ADDR\t|\n\t\tMLX5_MKEY_MASK_EN_SIGERR\t|\n\t\tMLX5_MKEY_MASK_EN_RINVAL\t|\n\t\tMLX5_MKEY_MASK_KEY\t\t|\n\t\tMLX5_MKEY_MASK_LR\t\t|\n\t\tMLX5_MKEY_MASK_LW\t\t|\n\t\tMLX5_MKEY_MASK_RR\t\t|\n\t\tMLX5_MKEY_MASK_RW\t\t|\n\t\tMLX5_MKEY_MASK_SMALL_FENCE\t|\n\t\tMLX5_MKEY_MASK_FREE\t\t|\n\t\tMLX5_MKEY_MASK_BSF_EN;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic void set_reg_umr_seg(struct mlx5_wqe_umr_ctrl_seg *umr,\n\t\t\t    struct mlx5_ib_mr *mr, bool umr_inline)\n{\n\tint size = mr->ndescs * mr->desc_size;\n\n\tmemset(umr, 0, sizeof(*umr));\n\n\tumr->flags = MLX5_UMR_CHECK_NOT_FREE;\n\tif (umr_inline)\n\t\tumr->flags |= MLX5_UMR_INLINE;\n\tumr->xlt_octowords = cpu_to_be16(get_xlt_octo(size));\n\tumr->mkey_mask = frwr_mkey_mask();\n}\n\nstatic void set_linv_umr_seg(struct mlx5_wqe_umr_ctrl_seg *umr)\n{\n\tmemset(umr, 0, sizeof(*umr));\n\tumr->mkey_mask = cpu_to_be64(MLX5_MKEY_MASK_FREE);\n\tumr->flags = MLX5_UMR_INLINE;\n}\n\nstatic __be64 get_umr_enable_mr_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_KEY |\n\t\t MLX5_MKEY_MASK_FREE;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_disable_mr_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_FREE;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_update_translation_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LEN |\n\t\t MLX5_MKEY_MASK_PAGE_SIZE |\n\t\t MLX5_MKEY_MASK_START_ADDR;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_update_access_mask(int atomic)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LR |\n\t\t MLX5_MKEY_MASK_LW |\n\t\t MLX5_MKEY_MASK_RR |\n\t\t MLX5_MKEY_MASK_RW;\n\n\tif (atomic)\n\t\tresult |= MLX5_MKEY_MASK_A;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_update_pd_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_PD;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic int umr_check_mkey_mask(struct mlx5_ib_dev *dev, u64 mask)\n{\n\tif ((mask & MLX5_MKEY_MASK_PAGE_SIZE &&\n\t     MLX5_CAP_GEN(dev->mdev, umr_modify_entity_size_disabled)) ||\n\t    (mask & MLX5_MKEY_MASK_A &&\n\t     MLX5_CAP_GEN(dev->mdev, umr_modify_atomic_disabled)))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic int set_reg_umr_segment(struct mlx5_ib_dev *dev,\n\t\t\t       struct mlx5_wqe_umr_ctrl_seg *umr,\n\t\t\t       const struct ib_send_wr *wr, int atomic)\n{\n\tconst struct mlx5_umr_wr *umrwr = umr_wr(wr);\n\n\tmemset(umr, 0, sizeof(*umr));\n\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_FAIL_IF_FREE)\n\t\tumr->flags = MLX5_UMR_CHECK_FREE; /* fail if free */\n\telse\n\t\tumr->flags = MLX5_UMR_CHECK_NOT_FREE; /* fail if not free */\n\n\tumr->xlt_octowords = cpu_to_be16(get_xlt_octo(umrwr->xlt_size));\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_XLT) {\n\t\tu64 offset = get_xlt_octo(umrwr->offset);\n\n\t\tumr->xlt_offset = cpu_to_be16(offset & 0xffff);\n\t\tumr->xlt_offset_47_16 = cpu_to_be32(offset >> 16);\n\t\tumr->flags |= MLX5_UMR_TRANSLATION_OFFSET_EN;\n\t}\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_TRANSLATION)\n\t\tumr->mkey_mask |= get_umr_update_translation_mask();\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_PD_ACCESS) {\n\t\tumr->mkey_mask |= get_umr_update_access_mask(atomic);\n\t\tumr->mkey_mask |= get_umr_update_pd_mask();\n\t}\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_ENABLE_MR)\n\t\tumr->mkey_mask |= get_umr_enable_mr_mask();\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_DISABLE_MR)\n\t\tumr->mkey_mask |= get_umr_disable_mr_mask();\n\n\tif (!wr->num_sge)\n\t\tumr->flags |= MLX5_UMR_INLINE;\n\n\treturn umr_check_mkey_mask(dev, be64_to_cpu(umr->mkey_mask));\n}\n\nstatic u8 get_umr_flags(int acc)\n{\n\treturn (acc & IB_ACCESS_REMOTE_ATOMIC ? MLX5_PERM_ATOMIC       : 0) |\n\t       (acc & IB_ACCESS_REMOTE_WRITE  ? MLX5_PERM_REMOTE_WRITE : 0) |\n\t       (acc & IB_ACCESS_REMOTE_READ   ? MLX5_PERM_REMOTE_READ  : 0) |\n\t       (acc & IB_ACCESS_LOCAL_WRITE   ? MLX5_PERM_LOCAL_WRITE  : 0) |\n\t\tMLX5_PERM_LOCAL_READ | MLX5_PERM_UMR_EN;\n}\n\nstatic void set_reg_mkey_seg(struct mlx5_mkey_seg *seg,\n\t\t\t     struct mlx5_ib_mr *mr,\n\t\t\t     u32 key, int access)\n{\n\tint ndescs = ALIGN(mr->ndescs, 8) >> 1;\n\n\tmemset(seg, 0, sizeof(*seg));\n\n\tif (mr->access_mode == MLX5_MKC_ACCESS_MODE_MTT)\n\t\tseg->log2_page_size = ilog2(mr->ibmr.page_size);\n\telse if (mr->access_mode == MLX5_MKC_ACCESS_MODE_KLMS)\n\t\t/* KLMs take twice the size of MTTs */\n\t\tndescs *= 2;\n\n\tseg->flags = get_umr_flags(access) | mr->access_mode;\n\tseg->qpn_mkey7_0 = cpu_to_be32((key & 0xff) | 0xffffff00);\n\tseg->flags_pd = cpu_to_be32(MLX5_MKEY_REMOTE_INVAL);\n\tseg->start_addr = cpu_to_be64(mr->ibmr.iova);\n\tseg->len = cpu_to_be64(mr->ibmr.length);\n\tseg->xlt_oct_size = cpu_to_be32(ndescs);\n}\n\nstatic void set_linv_mkey_seg(struct mlx5_mkey_seg *seg)\n{\n\tmemset(seg, 0, sizeof(*seg));\n\tseg->status = MLX5_MKEY_STATUS_FREE;\n}\n\nstatic void set_reg_mkey_segment(struct mlx5_mkey_seg *seg,\n\t\t\t\t const struct ib_send_wr *wr)\n{\n\tconst struct mlx5_umr_wr *umrwr = umr_wr(wr);\n\n\tmemset(seg, 0, sizeof(*seg));\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_DISABLE_MR)\n\t\tseg->status = MLX5_MKEY_STATUS_FREE;\n\n\tseg->flags = convert_access(umrwr->access_flags);\n\tif (umrwr->pd)\n\t\tseg->flags_pd = cpu_to_be32(to_mpd(umrwr->pd)->pdn);\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_TRANSLATION &&\n\t    !umrwr->length)\n\t\tseg->flags_pd |= cpu_to_be32(MLX5_MKEY_LEN64);\n\n\tseg->start_addr = cpu_to_be64(umrwr->virt_addr);\n\tseg->len = cpu_to_be64(umrwr->length);\n\tseg->log2_page_size = umrwr->page_shift;\n\tseg->qpn_mkey7_0 = cpu_to_be32(0xffffff00 |\n\t\t\t\t       mlx5_mkey_variant(umrwr->mkey));\n}\n\nstatic void set_reg_data_seg(struct mlx5_wqe_data_seg *dseg,\n\t\t\t     struct mlx5_ib_mr *mr,\n\t\t\t     struct mlx5_ib_pd *pd)\n{\n\tint bcount = mr->desc_size * mr->ndescs;\n\n\tdseg->addr = cpu_to_be64(mr->desc_map);\n\tdseg->byte_count = cpu_to_be32(ALIGN(bcount, 64));\n\tdseg->lkey = cpu_to_be32(pd->ibpd.local_dma_lkey);\n}\n\nstatic void set_reg_umr_inline_seg(void *seg, struct mlx5_ib_qp *qp,\n\t\t\t\t   struct mlx5_ib_mr *mr, int mr_list_size)\n{\n\tvoid *qend = qp->sq.qend;\n\tvoid *addr = mr->descs;\n\tint copy;\n\n\tif (unlikely(seg + mr_list_size > qend)) {\n\t\tcopy = qend - seg;\n\t\tmemcpy(seg, addr, copy);\n\t\taddr += copy;\n\t\tmr_list_size -= copy;\n\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t}\n\tmemcpy(seg, addr, mr_list_size);\n\tseg += mr_list_size;\n}\n\nstatic __be32 send_ieth(const struct ib_send_wr *wr)\n{\n\tswitch (wr->opcode) {\n\tcase IB_WR_SEND_WITH_IMM:\n\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\treturn wr->ex.imm_data;\n\n\tcase IB_WR_SEND_WITH_INV:\n\t\treturn cpu_to_be32(wr->ex.invalidate_rkey);\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 calc_sig(void *wqe, int size)\n{\n\tu8 *p = wqe;\n\tu8 res = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tres ^= p[i];\n\n\treturn ~res;\n}\n\nstatic u8 wq_sig(void *wqe)\n{\n\treturn calc_sig(wqe, (*((u8 *)wqe + 8) & 0x3f) << 4);\n}\n\nstatic int set_data_inl_seg(struct mlx5_ib_qp *qp, const struct ib_send_wr *wr,\n\t\t\t    void *wqe, int *sz)\n{\n\tstruct mlx5_wqe_inline_seg *seg;\n\tvoid *qend = qp->sq.qend;\n\tvoid *addr;\n\tint inl = 0;\n\tint copy;\n\tint len;\n\tint i;\n\n\tseg = wqe;\n\twqe += sizeof(*seg);\n\tfor (i = 0; i < wr->num_sge; i++) {\n\t\taddr = (void *)(unsigned long)(wr->sg_list[i].addr);\n\t\tlen  = wr->sg_list[i].length;\n\t\tinl += len;\n\n\t\tif (unlikely(inl > qp->max_inline_data))\n\t\t\treturn -ENOMEM;\n\n\t\tif (unlikely(wqe + len > qend)) {\n\t\t\tcopy = qend - wqe;\n\t\t\tmemcpy(wqe, addr, copy);\n\t\t\taddr += copy;\n\t\t\tlen -= copy;\n\t\t\twqe = mlx5_get_send_wqe(qp, 0);\n\t\t}\n\t\tmemcpy(wqe, addr, len);\n\t\twqe += len;\n\t}\n\n\tseg->byte_count = cpu_to_be32(inl | MLX5_INLINE_SEG);\n\n\t*sz = ALIGN(inl + sizeof(seg->byte_count), 16) / 16;\n\n\treturn 0;\n}\n\nstatic u16 prot_field_size(enum ib_signature_type type)\n{\n\tswitch (type) {\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\treturn MLX5_DIF_SIZE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 bs_selector(int block_size)\n{\n\tswitch (block_size) {\n\tcase 512:\t    return 0x1;\n\tcase 520:\t    return 0x2;\n\tcase 4096:\t    return 0x3;\n\tcase 4160:\t    return 0x4;\n\tcase 1073741824:    return 0x5;\n\tdefault:\t    return 0;\n\t}\n}\n\nstatic void mlx5_fill_inl_bsf(struct ib_sig_domain *domain,\n\t\t\t      struct mlx5_bsf_inl *inl)\n{\n\t/* Valid inline section and allow BSF refresh */\n\tinl->vld_refresh = cpu_to_be16(MLX5_BSF_INL_VALID |\n\t\t\t\t       MLX5_BSF_REFRESH_DIF);\n\tinl->dif_apptag = cpu_to_be16(domain->sig.dif.app_tag);\n\tinl->dif_reftag = cpu_to_be32(domain->sig.dif.ref_tag);\n\t/* repeating block */\n\tinl->rp_inv_seed = MLX5_BSF_REPEAT_BLOCK;\n\tinl->sig_type = domain->sig.dif.bg_type == IB_T10DIF_CRC ?\n\t\t\tMLX5_DIF_CRC : MLX5_DIF_IPCS;\n\n\tif (domain->sig.dif.ref_remap)\n\t\tinl->dif_inc_ref_guard_check |= MLX5_BSF_INC_REFTAG;\n\n\tif (domain->sig.dif.app_escape) {\n\t\tif (domain->sig.dif.ref_escape)\n\t\t\tinl->dif_inc_ref_guard_check |= MLX5_BSF_APPREF_ESCAPE;\n\t\telse\n\t\t\tinl->dif_inc_ref_guard_check |= MLX5_BSF_APPTAG_ESCAPE;\n\t}\n\n\tinl->dif_app_bitmask_check =\n\t\tcpu_to_be16(domain->sig.dif.apptag_check_mask);\n}\n\nstatic int mlx5_set_bsf(struct ib_mr *sig_mr,\n\t\t\tstruct ib_sig_attrs *sig_attrs,\n\t\t\tstruct mlx5_bsf *bsf, u32 data_size)\n{\n\tstruct mlx5_core_sig_ctx *msig = to_mmr(sig_mr)->sig;\n\tstruct mlx5_bsf_basic *basic = &bsf->basic;\n\tstruct ib_sig_domain *mem = &sig_attrs->mem;\n\tstruct ib_sig_domain *wire = &sig_attrs->wire;\n\n\tmemset(bsf, 0, sizeof(*bsf));\n\n\t/* Basic + Extended + Inline */\n\tbasic->bsf_size_sbs = 1 << 7;\n\t/* Input domain check byte mask */\n\tbasic->check_byte_mask = sig_attrs->check_mask;\n\tbasic->raw_data_size = cpu_to_be32(data_size);\n\n\t/* Memory domain */\n\tswitch (sig_attrs->mem.sig_type) {\n\tcase IB_SIG_TYPE_NONE:\n\t\tbreak;\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\tbasic->mem.bs_selector = bs_selector(mem->sig.dif.pi_interval);\n\t\tbasic->m_bfs_psv = cpu_to_be32(msig->psv_memory.psv_idx);\n\t\tmlx5_fill_inl_bsf(mem, &bsf->m_inl);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Wire domain */\n\tswitch (sig_attrs->wire.sig_type) {\n\tcase IB_SIG_TYPE_NONE:\n\t\tbreak;\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\tif (mem->sig.dif.pi_interval == wire->sig.dif.pi_interval &&\n\t\t    mem->sig_type == wire->sig_type) {\n\t\t\t/* Same block structure */\n\t\t\tbasic->bsf_size_sbs |= 1 << 4;\n\t\t\tif (mem->sig.dif.bg_type == wire->sig.dif.bg_type)\n\t\t\t\tbasic->wire.copy_byte_mask |= MLX5_CPY_GRD_MASK;\n\t\t\tif (mem->sig.dif.app_tag == wire->sig.dif.app_tag)\n\t\t\t\tbasic->wire.copy_byte_mask |= MLX5_CPY_APP_MASK;\n\t\t\tif (mem->sig.dif.ref_tag == wire->sig.dif.ref_tag)\n\t\t\t\tbasic->wire.copy_byte_mask |= MLX5_CPY_REF_MASK;\n\t\t} else\n\t\t\tbasic->wire.bs_selector = bs_selector(wire->sig.dif.pi_interval);\n\n\t\tbasic->w_bfs_psv = cpu_to_be32(msig->psv_wire.psv_idx);\n\t\tmlx5_fill_inl_bsf(wire, &bsf->w_inl);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_sig_data_segment(const struct ib_sig_handover_wr *wr,\n\t\t\t\tstruct mlx5_ib_qp *qp, void **seg, int *size)\n{\n\tstruct ib_sig_attrs *sig_attrs = wr->sig_attrs;\n\tstruct ib_mr *sig_mr = wr->sig_mr;\n\tstruct mlx5_bsf *bsf;\n\tu32 data_len = wr->wr.sg_list->length;\n\tu32 data_key = wr->wr.sg_list->lkey;\n\tu64 data_va = wr->wr.sg_list->addr;\n\tint ret;\n\tint wqe_size;\n\n\tif (!wr->prot ||\n\t    (data_key == wr->prot->lkey &&\n\t     data_va == wr->prot->addr &&\n\t     data_len == wr->prot->length)) {\n\t\t/**\n\t\t * Source domain doesn't contain signature information\n\t\t * or data and protection are interleaved in memory.\n\t\t * So need construct:\n\t\t *                  ------------------\n\t\t *                 |     data_klm     |\n\t\t *                  ------------------\n\t\t *                 |       BSF        |\n\t\t *                  ------------------\n\t\t **/\n\t\tstruct mlx5_klm *data_klm = *seg;\n\n\t\tdata_klm->bcount = cpu_to_be32(data_len);\n\t\tdata_klm->key = cpu_to_be32(data_key);\n\t\tdata_klm->va = cpu_to_be64(data_va);\n\t\twqe_size = ALIGN(sizeof(*data_klm), 64);\n\t} else {\n\t\t/**\n\t\t * Source domain contains signature information\n\t\t * So need construct a strided block format:\n\t\t *               ---------------------------\n\t\t *              |     stride_block_ctrl     |\n\t\t *               ---------------------------\n\t\t *              |          data_klm         |\n\t\t *               ---------------------------\n\t\t *              |          prot_klm         |\n\t\t *               ---------------------------\n\t\t *              |             BSF           |\n\t\t *               ---------------------------\n\t\t **/\n\t\tstruct mlx5_stride_block_ctrl_seg *sblock_ctrl;\n\t\tstruct mlx5_stride_block_entry *data_sentry;\n\t\tstruct mlx5_stride_block_entry *prot_sentry;\n\t\tu32 prot_key = wr->prot->lkey;\n\t\tu64 prot_va = wr->prot->addr;\n\t\tu16 block_size = sig_attrs->mem.sig.dif.pi_interval;\n\t\tint prot_size;\n\n\t\tsblock_ctrl = *seg;\n\t\tdata_sentry = (void *)sblock_ctrl + sizeof(*sblock_ctrl);\n\t\tprot_sentry = (void *)data_sentry + sizeof(*data_sentry);\n\n\t\tprot_size = prot_field_size(sig_attrs->mem.sig_type);\n\t\tif (!prot_size) {\n\t\t\tpr_err(\"Bad block size given: %u\\n\", block_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsblock_ctrl->bcount_per_cycle = cpu_to_be32(block_size +\n\t\t\t\t\t\t\t    prot_size);\n\t\tsblock_ctrl->op = cpu_to_be32(MLX5_STRIDE_BLOCK_OP);\n\t\tsblock_ctrl->repeat_count = cpu_to_be32(data_len / block_size);\n\t\tsblock_ctrl->num_entries = cpu_to_be16(2);\n\n\t\tdata_sentry->bcount = cpu_to_be16(block_size);\n\t\tdata_sentry->key = cpu_to_be32(data_key);\n\t\tdata_sentry->va = cpu_to_be64(data_va);\n\t\tdata_sentry->stride = cpu_to_be16(block_size);\n\n\t\tprot_sentry->bcount = cpu_to_be16(prot_size);\n\t\tprot_sentry->key = cpu_to_be32(prot_key);\n\t\tprot_sentry->va = cpu_to_be64(prot_va);\n\t\tprot_sentry->stride = cpu_to_be16(prot_size);\n\n\t\twqe_size = ALIGN(sizeof(*sblock_ctrl) + sizeof(*data_sentry) +\n\t\t\t\t sizeof(*prot_sentry), 64);\n\t}\n\n\t*seg += wqe_size;\n\t*size += wqe_size / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tbsf = *seg;\n\tret = mlx5_set_bsf(sig_mr, sig_attrs, bsf, data_len);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t*seg += sizeof(*bsf);\n\t*size += sizeof(*bsf) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\treturn 0;\n}\n\nstatic void set_sig_mkey_segment(struct mlx5_mkey_seg *seg,\n\t\t\t\t const struct ib_sig_handover_wr *wr, u32 size,\n\t\t\t\t u32 length, u32 pdn)\n{\n\tstruct ib_mr *sig_mr = wr->sig_mr;\n\tu32 sig_key = sig_mr->rkey;\n\tu8 sigerr = to_mmr(sig_mr)->sig->sigerr_count & 1;\n\n\tmemset(seg, 0, sizeof(*seg));\n\n\tseg->flags = get_umr_flags(wr->access_flags) |\n\t\t\t\t   MLX5_MKC_ACCESS_MODE_KLMS;\n\tseg->qpn_mkey7_0 = cpu_to_be32((sig_key & 0xff) | 0xffffff00);\n\tseg->flags_pd = cpu_to_be32(MLX5_MKEY_REMOTE_INVAL | sigerr << 26 |\n\t\t\t\t    MLX5_MKEY_BSF_EN | pdn);\n\tseg->len = cpu_to_be64(length);\n\tseg->xlt_oct_size = cpu_to_be32(get_xlt_octo(size));\n\tseg->bsfs_octo_size = cpu_to_be32(MLX5_MKEY_BSF_OCTO_SIZE);\n}\n\nstatic void set_sig_umr_segment(struct mlx5_wqe_umr_ctrl_seg *umr,\n\t\t\t\tu32 size)\n{\n\tmemset(umr, 0, sizeof(*umr));\n\n\tumr->flags = MLX5_FLAGS_INLINE | MLX5_FLAGS_CHECK_FREE;\n\tumr->xlt_octowords = cpu_to_be16(get_xlt_octo(size));\n\tumr->bsf_octowords = cpu_to_be16(MLX5_MKEY_BSF_OCTO_SIZE);\n\tumr->mkey_mask = sig_mkey_mask();\n}\n\n\nstatic int set_sig_umr_wr(const struct ib_send_wr *send_wr,\n\t\t\t  struct mlx5_ib_qp *qp, void **seg, int *size)\n{\n\tconst struct ib_sig_handover_wr *wr = sig_handover_wr(send_wr);\n\tstruct mlx5_ib_mr *sig_mr = to_mmr(wr->sig_mr);\n\tu32 pdn = get_pd(qp)->pdn;\n\tu32 xlt_size;\n\tint region_len, ret;\n\n\tif (unlikely(wr->wr.num_sge != 1) ||\n\t    unlikely(wr->access_flags & IB_ACCESS_REMOTE_ATOMIC) ||\n\t    unlikely(!sig_mr->sig) || unlikely(!qp->signature_en) ||\n\t    unlikely(!sig_mr->sig->sig_status_checked))\n\t\treturn -EINVAL;\n\n\t/* length of the protected region, data + protection */\n\tregion_len = wr->wr.sg_list->length;\n\tif (wr->prot &&\n\t    (wr->prot->lkey != wr->wr.sg_list->lkey  ||\n\t     wr->prot->addr != wr->wr.sg_list->addr  ||\n\t     wr->prot->length != wr->wr.sg_list->length))\n\t\tregion_len += wr->prot->length;\n\n\t/**\n\t * KLM octoword size - if protection was provided\n\t * then we use strided block format (3 octowords),\n\t * else we use single KLM (1 octoword)\n\t **/\n\txlt_size = wr->prot ? 0x30 : sizeof(struct mlx5_klm);\n\n\tset_sig_umr_segment(*seg, xlt_size);\n\t*seg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t*size += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tset_sig_mkey_segment(*seg, wr, xlt_size, region_len, pdn);\n\t*seg += sizeof(struct mlx5_mkey_seg);\n\t*size += sizeof(struct mlx5_mkey_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tret = set_sig_data_segment(wr, qp, seg, size);\n\tif (ret)\n\t\treturn ret;\n\n\tsig_mr->sig->sig_status_checked = false;\n\treturn 0;\n}\n\nstatic int set_psv_wr(struct ib_sig_domain *domain,\n\t\t      u32 psv_idx, void **seg, int *size)\n{\n\tstruct mlx5_seg_set_psv *psv_seg = *seg;\n\n\tmemset(psv_seg, 0, sizeof(*psv_seg));\n\tpsv_seg->psv_num = cpu_to_be32(psv_idx);\n\tswitch (domain->sig_type) {\n\tcase IB_SIG_TYPE_NONE:\n\t\tbreak;\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\tpsv_seg->transient_sig = cpu_to_be32(domain->sig.dif.bg << 16 |\n\t\t\t\t\t\t     domain->sig.dif.app_tag);\n\t\tpsv_seg->ref_tag = cpu_to_be32(domain->sig.dif.ref_tag);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Bad signature type (%d) is given.\\n\",\n\t\t       domain->sig_type);\n\t\treturn -EINVAL;\n\t}\n\n\t*seg += sizeof(*psv_seg);\n\t*size += sizeof(*psv_seg) / 16;\n\n\treturn 0;\n}\n\nstatic int set_reg_wr(struct mlx5_ib_qp *qp,\n\t\t      const struct ib_reg_wr *wr,\n\t\t      void **seg, int *size)\n{\n\tstruct mlx5_ib_mr *mr = to_mmr(wr->mr);\n\tstruct mlx5_ib_pd *pd = to_mpd(qp->ibqp.pd);\n\tint mr_list_size = mr->ndescs * mr->desc_size;\n\tbool umr_inline = mr_list_size <= MLX5_IB_SQ_UMR_INLINE_THRESHOLD;\n\n\tif (unlikely(wr->wr.send_flags & IB_SEND_INLINE)) {\n\t\tmlx5_ib_warn(to_mdev(qp->ibqp.device),\n\t\t\t     \"Invalid IB_SEND_INLINE send flag\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset_reg_umr_seg(*seg, mr, umr_inline);\n\t*seg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t*size += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tset_reg_mkey_seg(*seg, mr, wr->key, wr->access);\n\t*seg += sizeof(struct mlx5_mkey_seg);\n\t*size += sizeof(struct mlx5_mkey_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tif (umr_inline) {\n\t\tset_reg_umr_inline_seg(*seg, qp, mr, mr_list_size);\n\t\t*size += get_xlt_octo(mr_list_size);\n\t} else {\n\t\tset_reg_data_seg(*seg, mr, pd);\n\t\t*seg += sizeof(struct mlx5_wqe_data_seg);\n\t\t*size += (sizeof(struct mlx5_wqe_data_seg) / 16);\n\t}\n\treturn 0;\n}\n\nstatic void set_linv_wr(struct mlx5_ib_qp *qp, void **seg, int *size)\n{\n\tset_linv_umr_seg(*seg);\n\t*seg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t*size += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\tset_linv_mkey_seg(*seg);\n\t*seg += sizeof(struct mlx5_mkey_seg);\n\t*size += sizeof(struct mlx5_mkey_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n}\n\nstatic void dump_wqe(struct mlx5_ib_qp *qp, int idx, int size_16)\n{\n\t__be32 *p = NULL;\n\tint tidx = idx;\n\tint i, j;\n\n\tpr_debug(\"dump wqe at %p\\n\", mlx5_get_send_wqe(qp, tidx));\n\tfor (i = 0, j = 0; i < size_16 * 4; i += 4, j += 4) {\n\t\tif ((i & 0xf) == 0) {\n\t\t\tvoid *buf = mlx5_get_send_wqe(qp, tidx);\n\t\t\ttidx = (tidx + 1) & (qp->sq.wqe_cnt - 1);\n\t\t\tp = buf;\n\t\t\tj = 0;\n\t\t}\n\t\tpr_debug(\"%08x %08x %08x %08x\\n\", be32_to_cpu(p[j]),\n\t\t\t be32_to_cpu(p[j + 1]), be32_to_cpu(p[j + 2]),\n\t\t\t be32_to_cpu(p[j + 3]));\n\t}\n}\n\nstatic int __begin_wqe(struct mlx5_ib_qp *qp, void **seg,\n\t\t     struct mlx5_wqe_ctrl_seg **ctrl,\n\t\t     const struct ib_send_wr *wr, unsigned *idx,\n\t\t     int *size, int nreq, bool send_signaled, bool solicited)\n{\n\tif (unlikely(mlx5_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)))\n\t\treturn -ENOMEM;\n\n\t*idx = qp->sq.cur_post & (qp->sq.wqe_cnt - 1);\n\t*seg = mlx5_get_send_wqe(qp, *idx);\n\t*ctrl = *seg;\n\t*(uint32_t *)(*seg + 8) = 0;\n\t(*ctrl)->imm = send_ieth(wr);\n\t(*ctrl)->fm_ce_se = qp->sq_signal_bits |\n\t\t(send_signaled ? MLX5_WQE_CTRL_CQ_UPDATE : 0) |\n\t\t(solicited ? MLX5_WQE_CTRL_SOLICITED : 0);\n\n\t*seg += sizeof(**ctrl);\n\t*size = sizeof(**ctrl) / 16;\n\n\treturn 0;\n}\n\nstatic int begin_wqe(struct mlx5_ib_qp *qp, void **seg,\n\t\t     struct mlx5_wqe_ctrl_seg **ctrl,\n\t\t     const struct ib_send_wr *wr, unsigned *idx,\n\t\t     int *size, int nreq)\n{\n\treturn __begin_wqe(qp, seg, ctrl, wr, idx, size, nreq,\n\t\t\t   wr->send_flags & IB_SEND_SIGNALED,\n\t\t\t   wr->send_flags & IB_SEND_SOLICITED);\n}\n\nstatic void finish_wqe(struct mlx5_ib_qp *qp,\n\t\t       struct mlx5_wqe_ctrl_seg *ctrl,\n\t\t       u8 size, unsigned idx, u64 wr_id,\n\t\t       int nreq, u8 fence, u32 mlx5_opcode)\n{\n\tu8 opmod = 0;\n\n\tctrl->opmod_idx_opcode = cpu_to_be32(((u32)(qp->sq.cur_post) << 8) |\n\t\t\t\t\t     mlx5_opcode | ((u32)opmod << 24));\n\tctrl->qpn_ds = cpu_to_be32(size | (qp->trans_qp.base.mqp.qpn << 8));\n\tctrl->fm_ce_se |= fence;\n\tif (unlikely(qp->wq_sig))\n\t\tctrl->signature = wq_sig(ctrl);\n\n\tqp->sq.wrid[idx] = wr_id;\n\tqp->sq.w_list[idx].opcode = mlx5_opcode;\n\tqp->sq.wqe_head[idx] = qp->sq.head + nreq;\n\tqp->sq.cur_post += DIV_ROUND_UP(size * 16, MLX5_SEND_WQE_BB);\n\tqp->sq.w_list[idx].next = qp->sq.cur_post;\n}\n\nstatic int _mlx5_ib_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t\t      const struct ib_send_wr **bad_wr, bool drain)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl = NULL;  /* compiler warning */\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_qp *qp;\n\tstruct mlx5_ib_mr *mr;\n\tstruct mlx5_wqe_data_seg *dpseg;\n\tstruct mlx5_wqe_xrc_seg *xrc;\n\tstruct mlx5_bf *bf;\n\tint uninitialized_var(size);\n\tvoid *qend;\n\tunsigned long flags;\n\tunsigned idx;\n\tint err = 0;\n\tint num_sge;\n\tvoid *seg;\n\tint nreq;\n\tint i;\n\tu8 next_fence = 0;\n\tu8 fence;\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_post_send(ibqp, wr, bad_wr);\n\n\tqp = to_mqp(ibqp);\n\tbf = &qp->bf;\n\tqend = qp->sq.qend;\n\n\tspin_lock_irqsave(&qp->sq.lock, flags);\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR && !drain) {\n\t\terr = -EIO;\n\t\t*bad_wr = wr;\n\t\tnreq = 0;\n\t\tgoto out;\n\t}\n\n\tfor (nreq = 0; wr; nreq++, wr = wr->next) {\n\t\tif (unlikely(wr->opcode >= ARRAY_SIZE(mlx5_ib_opcode))) {\n\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_sge = wr->num_sge;\n\t\tif (unlikely(num_sge > qp->sq.max_gs)) {\n\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = begin_wqe(qp, &seg, &ctrl, wr, &idx, &size, nreq);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (wr->opcode == IB_WR_LOCAL_INV ||\n\t\t    wr->opcode == IB_WR_REG_MR) {\n\t\t\tfence = dev->umr_fence;\n\t\t\tnext_fence = MLX5_FENCE_MODE_INITIATOR_SMALL;\n\t\t} else if (wr->send_flags & IB_SEND_FENCE) {\n\t\t\tif (qp->next_fence)\n\t\t\t\tfence = MLX5_FENCE_MODE_SMALL_AND_FENCE;\n\t\t\telse\n\t\t\t\tfence = MLX5_FENCE_MODE_FENCE;\n\t\t} else {\n\t\t\tfence = qp->next_fence;\n\t\t}\n\n\t\tswitch (ibqp->qp_type) {\n\t\tcase IB_QPT_XRC_INI:\n\t\t\txrc = seg;\n\t\t\tseg += sizeof(*xrc);\n\t\t\tsize += sizeof(*xrc) / 16;\n\t\t\t/* fall through */\n\t\tcase IB_QPT_RC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_RDMA_READ:\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(seg, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\tseg += sizeof(struct mlx5_wqe_raddr_seg);\n\t\t\t\tsize += sizeof(struct mlx5_wqe_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\tcase IB_WR_MASKED_ATOMIC_CMP_AND_SWP:\n\t\t\t\tmlx5_ib_warn(dev, \"Atomic operations are not supported yet\\n\");\n\t\t\t\terr = -ENOSYS;\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\n\t\t\tcase IB_WR_LOCAL_INV:\n\t\t\t\tqp->sq.wr_data[idx] = IB_WR_LOCAL_INV;\n\t\t\t\tctrl->imm = cpu_to_be32(wr->ex.invalidate_rkey);\n\t\t\t\tset_linv_wr(qp, &seg, &size);\n\t\t\t\tnum_sge = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_REG_MR:\n\t\t\t\tqp->sq.wr_data[idx] = IB_WR_REG_MR;\n\t\t\t\tctrl->imm = cpu_to_be32(reg_wr(wr)->key);\n\t\t\t\terr = set_reg_wr(qp, reg_wr(wr), &seg, &size);\n\t\t\t\tif (err) {\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tnum_sge = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_REG_SIG_MR:\n\t\t\t\tqp->sq.wr_data[idx] = IB_WR_REG_SIG_MR;\n\t\t\t\tmr = to_mmr(sig_handover_wr(wr)->sig_mr);\n\n\t\t\t\tctrl->imm = cpu_to_be32(mr->ibmr.rkey);\n\t\t\t\terr = set_sig_umr_wr(wr, qp, &seg, &size);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq,\n\t\t\t\t\t   fence, MLX5_OPCODE_UMR);\n\t\t\t\t/*\n\t\t\t\t * SET_PSV WQEs are not signaled and solicited\n\t\t\t\t * on error\n\t\t\t\t */\n\t\t\t\terr = __begin_wqe(qp, &seg, &ctrl, wr, &idx,\n\t\t\t\t\t\t  &size, nreq, false, true);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\terr = set_psv_wr(&sig_handover_wr(wr)->sig_attrs->mem,\n\t\t\t\t\t\t mr->sig->psv_memory.psv_idx, &seg,\n\t\t\t\t\t\t &size);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq,\n\t\t\t\t\t   fence, MLX5_OPCODE_SET_PSV);\n\t\t\t\terr = __begin_wqe(qp, &seg, &ctrl, wr, &idx,\n\t\t\t\t\t\t  &size, nreq, false, true);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\terr = set_psv_wr(&sig_handover_wr(wr)->sig_attrs->wire,\n\t\t\t\t\t\t mr->sig->psv_wire.psv_idx, &seg,\n\t\t\t\t\t\t &size);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq,\n\t\t\t\t\t   fence, MLX5_OPCODE_SET_PSV);\n\t\t\t\tqp->next_fence = MLX5_FENCE_MODE_INITIATOR_SMALL;\n\t\t\t\tnum_sge = 0;\n\t\t\t\tgoto skip_psv;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_QPT_UC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(seg, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\tseg  += sizeof(struct mlx5_wqe_raddr_seg);\n\t\t\t\tsize += sizeof(struct mlx5_wqe_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_QPT_SMI:\n\t\t\tif (unlikely(!mdev->port_caps[qp->port - 1].has_smi)) {\n\t\t\t\tmlx5_ib_warn(dev, \"Send SMP MADs is not allowed\\n\");\n\t\t\t\terr = -EPERM;\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase MLX5_IB_QPT_HW_GSI:\n\t\t\tset_datagram_seg(seg, wr);\n\t\t\tseg += sizeof(struct mlx5_wqe_datagram_seg);\n\t\t\tsize += sizeof(struct mlx5_wqe_datagram_seg) / 16;\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tbreak;\n\t\tcase IB_QPT_UD:\n\t\t\tset_datagram_seg(seg, wr);\n\t\t\tseg += sizeof(struct mlx5_wqe_datagram_seg);\n\t\t\tsize += sizeof(struct mlx5_wqe_datagram_seg) / 16;\n\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\n\t\t\t/* handle qp that supports ud offload */\n\t\t\tif (qp->flags & IB_QP_CREATE_IPOIB_UD_LSO) {\n\t\t\t\tstruct mlx5_wqe_eth_pad *pad;\n\n\t\t\t\tpad = seg;\n\t\t\t\tmemset(pad, 0, sizeof(struct mlx5_wqe_eth_pad));\n\t\t\t\tseg += sizeof(struct mlx5_wqe_eth_pad);\n\t\t\t\tsize += sizeof(struct mlx5_wqe_eth_pad) / 16;\n\n\t\t\t\tseg = set_eth_seg(seg, wr, qend, qp, &size);\n\n\t\t\t\tif (unlikely((seg == qend)))\n\t\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MLX5_IB_QPT_REG_UMR:\n\t\t\tif (wr->opcode != MLX5_IB_WR_UMR) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tmlx5_ib_warn(dev, \"bad opcode\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tqp->sq.wr_data[idx] = MLX5_IB_WR_UMR;\n\t\t\tctrl->imm = cpu_to_be32(umr_wr(wr)->mkey);\n\t\t\terr = set_reg_umr_segment(dev, seg, wr, !!(MLX5_CAP_GEN(mdev, atomic)));\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out;\n\t\t\tseg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t\t\tsize += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tset_reg_mkey_segment(seg, wr);\n\t\t\tseg += sizeof(struct mlx5_mkey_seg);\n\t\t\tsize += sizeof(struct mlx5_mkey_seg) / 16;\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wr->send_flags & IB_SEND_INLINE && num_sge) {\n\t\t\tint uninitialized_var(sz);\n\n\t\t\terr = set_data_inl_seg(qp, wr, seg, &sz);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsize += sz;\n\t\t} else {\n\t\t\tdpseg = seg;\n\t\t\tfor (i = 0; i < num_sge; i++) {\n\t\t\t\tif (unlikely(dpseg == qend)) {\n\t\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\t\t\tdpseg = seg;\n\t\t\t\t}\n\t\t\t\tif (likely(wr->sg_list[i].length)) {\n\t\t\t\t\tset_data_ptr_seg(dpseg, wr->sg_list + i);\n\t\t\t\t\tsize += sizeof(struct mlx5_wqe_data_seg) / 16;\n\t\t\t\t\tdpseg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqp->next_fence = next_fence;\n\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq, fence,\n\t\t\t   mlx5_ib_opcode[wr->opcode]);\nskip_psv:\n\t\tif (0)\n\t\t\tdump_wqe(qp, idx, size);\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tqp->sq.head += nreq;\n\n\t\t/* Make sure that descriptors are written before\n\t\t * updating doorbell record and ringing the doorbell\n\t\t */\n\t\twmb();\n\n\t\tqp->db.db[MLX5_SND_DBR] = cpu_to_be32(qp->sq.cur_post);\n\n\t\t/* Make sure doorbell record is visible to the HCA before\n\t\t * we hit doorbell */\n\t\twmb();\n\n\t\t/* currently we support only regular doorbells */\n\t\tmlx5_write64((__be32 *)ctrl, bf->bfreg->map + bf->offset, NULL);\n\t\t/* Make sure doorbells don't leak out of SQ spinlock\n\t\t * and reach the HCA out of order.\n\t\t */\n\t\tmmiowb();\n\t\tbf->offset ^= bf->buf_size;\n\t}\n\n\tspin_unlock_irqrestore(&qp->sq.lock, flags);\n\n\treturn err;\n}\n\nint mlx5_ib_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t      const struct ib_send_wr **bad_wr)\n{\n\treturn _mlx5_ib_post_send(ibqp, wr, bad_wr, false);\n}\n\nstatic void set_sig_seg(struct mlx5_rwqe_sig *sig, int size)\n{\n\tsig->signature = calc_sig(sig, size);\n}\n\nstatic int _mlx5_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t      const struct ib_recv_wr **bad_wr, bool drain)\n{\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_wqe_data_seg *scat;\n\tstruct mlx5_rwqe_sig *sig;\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint ind;\n\tint i;\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_post_recv(ibqp, wr, bad_wr);\n\n\tspin_lock_irqsave(&qp->rq.lock, flags);\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR && !drain) {\n\t\terr = -EIO;\n\t\t*bad_wr = wr;\n\t\tnreq = 0;\n\t\tgoto out;\n\t}\n\n\tind = qp->rq.head & (qp->rq.wqe_cnt - 1);\n\n\tfor (nreq = 0; wr; nreq++, wr = wr->next) {\n\t\tif (mlx5_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (unlikely(wr->num_sge > qp->rq.max_gs)) {\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tscat = get_recv_wqe(qp, ind);\n\t\tif (qp->wq_sig)\n\t\t\tscat++;\n\n\t\tfor (i = 0; i < wr->num_sge; i++)\n\t\t\tset_data_ptr_seg(scat + i, wr->sg_list + i);\n\n\t\tif (i < qp->rq.max_gs) {\n\t\t\tscat[i].byte_count = 0;\n\t\t\tscat[i].lkey       = cpu_to_be32(MLX5_INVALID_LKEY);\n\t\t\tscat[i].addr       = 0;\n\t\t}\n\n\t\tif (qp->wq_sig) {\n\t\t\tsig = (struct mlx5_rwqe_sig *)scat;\n\t\t\tset_sig_seg(sig, (qp->rq.max_gs + 1) << 2);\n\t\t}\n\n\t\tqp->rq.wrid[ind] = wr->wr_id;\n\n\t\tind = (ind + 1) & (qp->rq.wqe_cnt - 1);\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tqp->rq.head += nreq;\n\n\t\t/* Make sure that descriptors are written before\n\t\t * doorbell record.\n\t\t */\n\t\twmb();\n\n\t\t*qp->db.db = cpu_to_be32(qp->rq.head & 0xffff);\n\t}\n\n\tspin_unlock_irqrestore(&qp->rq.lock, flags);\n\n\treturn err;\n}\n\nint mlx5_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t      const struct ib_recv_wr **bad_wr)\n{\n\treturn _mlx5_ib_post_recv(ibqp, wr, bad_wr, false);\n}\n\nstatic inline enum ib_qp_state to_ib_qp_state(enum mlx5_qp_state mlx5_state)\n{\n\tswitch (mlx5_state) {\n\tcase MLX5_QP_STATE_RST:      return IB_QPS_RESET;\n\tcase MLX5_QP_STATE_INIT:     return IB_QPS_INIT;\n\tcase MLX5_QP_STATE_RTR:      return IB_QPS_RTR;\n\tcase MLX5_QP_STATE_RTS:      return IB_QPS_RTS;\n\tcase MLX5_QP_STATE_SQ_DRAINING:\n\tcase MLX5_QP_STATE_SQD:      return IB_QPS_SQD;\n\tcase MLX5_QP_STATE_SQER:     return IB_QPS_SQE;\n\tcase MLX5_QP_STATE_ERR:      return IB_QPS_ERR;\n\tdefault:\t\t     return -1;\n\t}\n}\n\nstatic inline enum ib_mig_state to_ib_mig_state(int mlx5_mig_state)\n{\n\tswitch (mlx5_mig_state) {\n\tcase MLX5_QP_PM_ARMED:\t\treturn IB_MIG_ARMED;\n\tcase MLX5_QP_PM_REARM:\t\treturn IB_MIG_REARM;\n\tcase MLX5_QP_PM_MIGRATED:\treturn IB_MIG_MIGRATED;\n\tdefault: return -1;\n\t}\n}\n\nstatic int to_ib_qp_access_flags(int mlx5_flags)\n{\n\tint ib_flags = 0;\n\n\tif (mlx5_flags & MLX5_QP_BIT_RRE)\n\t\tib_flags |= IB_ACCESS_REMOTE_READ;\n\tif (mlx5_flags & MLX5_QP_BIT_RWE)\n\t\tib_flags |= IB_ACCESS_REMOTE_WRITE;\n\tif (mlx5_flags & MLX5_QP_BIT_RAE)\n\t\tib_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\n\treturn ib_flags;\n}\n\nstatic void to_rdma_ah_attr(struct mlx5_ib_dev *ibdev,\n\t\t\t    struct rdma_ah_attr *ah_attr,\n\t\t\t    struct mlx5_qp_path *path)\n{\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\n\tif (!path->port || path->port > ibdev->num_ports)\n\t\treturn;\n\n\tah_attr->type = rdma_ah_find_type(&ibdev->ib_dev, path->port);\n\n\trdma_ah_set_port_num(ah_attr, path->port);\n\trdma_ah_set_sl(ah_attr, path->dci_cfi_prio_sl & 0xf);\n\n\trdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));\n\trdma_ah_set_path_bits(ah_attr, path->grh_mlid & 0x7f);\n\trdma_ah_set_static_rate(ah_attr,\n\t\t\t\tpath->static_rate ? path->static_rate - 5 : 0);\n\tif (path->grh_mlid & (1 << 7)) {\n\t\tu32 tc_fl = be32_to_cpu(path->tclass_flowlabel);\n\n\t\trdma_ah_set_grh(ah_attr, NULL,\n\t\t\t\ttc_fl & 0xfffff,\n\t\t\t\tpath->mgid_index,\n\t\t\t\tpath->hop_limit,\n\t\t\t\t(tc_fl >> 20) & 0xff);\n\t\trdma_ah_set_dgid_raw(ah_attr, path->rgid);\n\t}\n}\n\nstatic int query_raw_packet_qp_sq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_sq *sq,\n\t\t\t\t\tu8 *sq_state)\n{\n\tint err;\n\n\terr = mlx5_core_query_sq_state(dev->mdev, sq->base.mqp.qpn, sq_state);\n\tif (err)\n\t\tgoto out;\n\tsq->state = *sq_state;\n\nout:\n\treturn err;\n}\n\nstatic int query_raw_packet_qp_rq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_rq *rq,\n\t\t\t\t\tu8 *rq_state)\n{\n\tvoid *out;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(query_rq_out);\n\tout = kvzalloc(inlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_query_rq(dev->mdev, rq->base.mqp.qpn, out);\n\tif (err)\n\t\tgoto out;\n\n\trqc = MLX5_ADDR_OF(query_rq_out, out, rq_context);\n\t*rq_state = MLX5_GET(rqc, rqc, state);\n\trq->state = *rq_state;\n\nout:\n\tkvfree(out);\n\treturn err;\n}\n\nstatic int sqrq_state_to_qp_state(u8 sq_state, u8 rq_state,\n\t\t\t\t  struct mlx5_ib_qp *qp, u8 *qp_state)\n{\n\tstatic const u8 sqrq_trans[MLX5_RQ_NUM_STATE][MLX5_SQ_NUM_STATE] = {\n\t\t[MLX5_RQC_STATE_RST] = {\n\t\t\t[MLX5_SQC_STATE_RST]\t= IB_QPS_RESET,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQ_STATE_NA]\t= IB_QPS_RESET,\n\t\t},\n\t\t[MLX5_RQC_STATE_RDY] = {\n\t\t\t[MLX5_SQC_STATE_RST]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= IB_QPS_SQE,\n\t\t\t[MLX5_SQ_STATE_NA]\t= MLX5_QP_STATE,\n\t\t},\n\t\t[MLX5_RQC_STATE_ERR] = {\n\t\t\t[MLX5_SQC_STATE_RST]    = MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= IB_QPS_ERR,\n\t\t\t[MLX5_SQ_STATE_NA]\t= IB_QPS_ERR,\n\t\t},\n\t\t[MLX5_RQ_STATE_NA] = {\n\t\t\t[MLX5_SQC_STATE_RST]    = IB_QPS_RESET,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQ_STATE_NA]\t= MLX5_QP_STATE_BAD,\n\t\t},\n\t};\n\n\t*qp_state = sqrq_trans[rq_state][sq_state];\n\n\tif (*qp_state == MLX5_QP_STATE_BAD) {\n\t\tWARN(1, \"Buggy Raw Packet QP state, SQ 0x%x state: 0x%x, RQ 0x%x state: 0x%x\",\n\t\t     qp->raw_packet_qp.sq.base.mqp.qpn, sq_state,\n\t\t     qp->raw_packet_qp.rq.base.mqp.qpn, rq_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*qp_state == MLX5_QP_STATE)\n\t\t*qp_state = qp->state;\n\n\treturn 0;\n}\n\nstatic int query_raw_packet_qp_state(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_qp *qp,\n\t\t\t\t     u8 *raw_packet_qp_state)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tint err;\n\tu8 sq_state = MLX5_SQ_STATE_NA;\n\tu8 rq_state = MLX5_RQ_STATE_NA;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_sq_state(dev, sq, &sq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_rq_state(dev, rq, &rq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn sqrq_state_to_qp_state(sq_state, rq_state, qp,\n\t\t\t\t      raw_packet_qp_state);\n}\n\nstatic int query_qp_attr(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t struct ib_qp_attr *qp_attr)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_qp_out);\n\tstruct mlx5_qp_context *context;\n\tint mlx5_state;\n\tu32 *outb;\n\tint err = 0;\n\n\toutb = kzalloc(outlen, GFP_KERNEL);\n\tif (!outb)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_qp_query(dev->mdev, &qp->trans_qp.base.mqp, outb,\n\t\t\t\t outlen);\n\tif (err)\n\t\tgoto out;\n\n\t/* FIXME: use MLX5_GET rather than mlx5_qp_context manual struct */\n\tcontext = (struct mlx5_qp_context *)MLX5_ADDR_OF(query_qp_out, outb, qpc);\n\n\tmlx5_state = be32_to_cpu(context->flags) >> 28;\n\n\tqp->state\t\t     = to_ib_qp_state(mlx5_state);\n\tqp_attr->path_mtu\t     = context->mtu_msgmax >> 5;\n\tqp_attr->path_mig_state\t     =\n\t\tto_ib_mig_state((be32_to_cpu(context->flags) >> 11) & 0x3);\n\tqp_attr->qkey\t\t     = be32_to_cpu(context->qkey);\n\tqp_attr->rq_psn\t\t     = be32_to_cpu(context->rnr_nextrecvpsn) & 0xffffff;\n\tqp_attr->sq_psn\t\t     = be32_to_cpu(context->next_send_psn) & 0xffffff;\n\tqp_attr->dest_qp_num\t     = be32_to_cpu(context->log_pg_sz_remote_qpn) & 0xffffff;\n\tqp_attr->qp_access_flags     =\n\t\tto_ib_qp_access_flags(be32_to_cpu(context->params2));\n\n\tif (qp->ibqp.qp_type == IB_QPT_RC || qp->ibqp.qp_type == IB_QPT_UC) {\n\t\tto_rdma_ah_attr(dev, &qp_attr->ah_attr, &context->pri_path);\n\t\tto_rdma_ah_attr(dev, &qp_attr->alt_ah_attr, &context->alt_path);\n\t\tqp_attr->alt_pkey_index =\n\t\t\tbe16_to_cpu(context->alt_path.pkey_index);\n\t\tqp_attr->alt_port_num\t=\n\t\t\trdma_ah_get_port_num(&qp_attr->alt_ah_attr);\n\t}\n\n\tqp_attr->pkey_index = be16_to_cpu(context->pri_path.pkey_index);\n\tqp_attr->port_num = context->pri_path.port;\n\n\t/* qp_attr->en_sqd_async_notify is only applicable in modify qp */\n\tqp_attr->sq_draining = mlx5_state == MLX5_QP_STATE_SQ_DRAINING;\n\n\tqp_attr->max_rd_atomic = 1 << ((be32_to_cpu(context->params1) >> 21) & 0x7);\n\n\tqp_attr->max_dest_rd_atomic =\n\t\t1 << ((be32_to_cpu(context->params2) >> 21) & 0x7);\n\tqp_attr->min_rnr_timer\t    =\n\t\t(be32_to_cpu(context->rnr_nextrecvpsn) >> 24) & 0x1f;\n\tqp_attr->timeout\t    = context->pri_path.ackto_lt >> 3;\n\tqp_attr->retry_cnt\t    = (be32_to_cpu(context->params1) >> 16) & 0x7;\n\tqp_attr->rnr_retry\t    = (be32_to_cpu(context->params1) >> 13) & 0x7;\n\tqp_attr->alt_timeout\t    = context->alt_path.ackto_lt >> 3;\n\nout:\n\tkfree(outb);\n\treturn err;\n}\n\nstatic int mlx5_ib_dct_query_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *mqp,\n\t\t\t\tstruct ib_qp_attr *qp_attr, int qp_attr_mask,\n\t\t\t\tstruct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_core_dct\t*dct = &mqp->dct.mdct;\n\tu32 *out;\n\tu32 access_flags = 0;\n\tint outlen = MLX5_ST_SZ_BYTES(query_dct_out);\n\tvoid *dctc;\n\tint err;\n\tint supported_mask = IB_QP_STATE |\n\t\t\t     IB_QP_ACCESS_FLAGS |\n\t\t\t     IB_QP_PORT |\n\t\t\t     IB_QP_MIN_RNR_TIMER |\n\t\t\t     IB_QP_AV |\n\t\t\t     IB_QP_PATH_MTU |\n\t\t\t     IB_QP_PKEY_INDEX;\n\n\tif (qp_attr_mask & ~supported_mask)\n\t\treturn -EINVAL;\n\tif (mqp->state != IB_QPS_RTR)\n\t\treturn -EINVAL;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_dct_query(dev->mdev, dct, out, outlen);\n\tif (err)\n\t\tgoto out;\n\n\tdctc = MLX5_ADDR_OF(query_dct_out, out, dct_context_entry);\n\n\tif (qp_attr_mask & IB_QP_STATE)\n\t\tqp_attr->qp_state = IB_QPS_RTR;\n\n\tif (qp_attr_mask & IB_QP_ACCESS_FLAGS) {\n\t\tif (MLX5_GET(dctc, dctc, rre))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_READ;\n\t\tif (MLX5_GET(dctc, dctc, rwe))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_WRITE;\n\t\tif (MLX5_GET(dctc, dctc, rae))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\t\tqp_attr->qp_access_flags = access_flags;\n\t}\n\n\tif (qp_attr_mask & IB_QP_PORT)\n\t\tqp_attr->port_num = MLX5_GET(dctc, dctc, port);\n\tif (qp_attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tqp_attr->min_rnr_timer = MLX5_GET(dctc, dctc, min_rnr_nak);\n\tif (qp_attr_mask & IB_QP_AV) {\n\t\tqp_attr->ah_attr.grh.traffic_class = MLX5_GET(dctc, dctc, tclass);\n\t\tqp_attr->ah_attr.grh.flow_label = MLX5_GET(dctc, dctc, flow_label);\n\t\tqp_attr->ah_attr.grh.sgid_index = MLX5_GET(dctc, dctc, my_addr_index);\n\t\tqp_attr->ah_attr.grh.hop_limit = MLX5_GET(dctc, dctc, hop_limit);\n\t}\n\tif (qp_attr_mask & IB_QP_PATH_MTU)\n\t\tqp_attr->path_mtu = MLX5_GET(dctc, dctc, mtu);\n\tif (qp_attr_mask & IB_QP_PKEY_INDEX)\n\t\tqp_attr->pkey_index = MLX5_GET(dctc, dctc, pkey_index);\nout:\n\tkfree(out);\n\treturn err;\n}\n\nint mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,\n\t\t     int qp_attr_mask, struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tint err = 0;\n\tu8 raw_packet_qp_state;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -ENOSYS;\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_query_qp(ibqp, qp_attr, qp_attr_mask,\n\t\t\t\t\t    qp_init_attr);\n\n\t/* Not all of output fields are applicable, make sure to zero them */\n\tmemset(qp_init_attr, 0, sizeof(*qp_init_attr));\n\tmemset(qp_attr, 0, sizeof(*qp_attr));\n\n\tif (unlikely(qp->qp_sub_type == MLX5_IB_QPT_DCT))\n\t\treturn mlx5_ib_dct_query_qp(dev, qp, qp_attr,\n\t\t\t\t\t    qp_attr_mask, qp_init_attr);\n\n\tmutex_lock(&qp->mutex);\n\n\tif (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\terr = query_raw_packet_qp_state(dev, qp, &raw_packet_qp_state);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tqp->state = raw_packet_qp_state;\n\t\tqp_attr->port_num = 1;\n\t} else {\n\t\terr = query_qp_attr(dev, qp, qp_attr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tqp_attr->qp_state\t     = qp->state;\n\tqp_attr->cur_qp_state\t     = qp_attr->qp_state;\n\tqp_attr->cap.max_recv_wr     = qp->rq.wqe_cnt;\n\tqp_attr->cap.max_recv_sge    = qp->rq.max_gs;\n\n\tif (!ibqp->uobject) {\n\t\tqp_attr->cap.max_send_wr  = qp->sq.max_post;\n\t\tqp_attr->cap.max_send_sge = qp->sq.max_gs;\n\t\tqp_init_attr->qp_context = ibqp->qp_context;\n\t} else {\n\t\tqp_attr->cap.max_send_wr  = 0;\n\t\tqp_attr->cap.max_send_sge = 0;\n\t}\n\n\tqp_init_attr->qp_type = ibqp->qp_type;\n\tqp_init_attr->recv_cq = ibqp->recv_cq;\n\tqp_init_attr->send_cq = ibqp->send_cq;\n\tqp_init_attr->srq = ibqp->srq;\n\tqp_attr->cap.max_inline_data = qp->max_inline_data;\n\n\tqp_init_attr->cap\t     = qp_attr->cap;\n\n\tqp_init_attr->create_flags = 0;\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_CROSS_CHANNEL;\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_MANAGED_SEND;\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_MANAGED_RECV;\n\tif (qp->flags & MLX5_IB_QP_SQPN_QP1)\n\t\tqp_init_attr->create_flags |= mlx5_ib_create_qp_sqpn_qp1();\n\n\tqp_init_attr->sq_sig_type = qp->sq_signal_bits & MLX5_WQE_CTRL_CQ_UPDATE ?\n\t\tIB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstruct ib_xrcd *mlx5_ib_alloc_xrcd(struct ib_device *ibdev,\n\t\t\t\t\t  struct ib_ucontext *context,\n\t\t\t\t\t  struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tstruct mlx5_ib_xrcd *xrcd;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, xrc))\n\t\treturn ERR_PTR(-ENOSYS);\n\n\txrcd = kmalloc(sizeof(*xrcd), GFP_KERNEL);\n\tif (!xrcd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlx5_core_xrcd_alloc(dev->mdev, &xrcd->xrcdn);\n\tif (err) {\n\t\tkfree(xrcd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &xrcd->ibxrcd;\n}\n\nint mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(xrcd->device);\n\tu32 xrcdn = to_mxrcd(xrcd)->xrcdn;\n\tint err;\n\n\terr = mlx5_core_xrcd_dealloc(dev->mdev, xrcdn);\n\tif (err)\n\t\tmlx5_ib_warn(dev, \"failed to dealloc xrcdn 0x%x\\n\", xrcdn);\n\n\tkfree(xrcd);\n\treturn 0;\n}\n\nstatic void mlx5_ib_wq_event(struct mlx5_core_qp *core_qp, int type)\n{\n\tstruct mlx5_ib_rwq *rwq = to_mibrwq(core_qp);\n\tstruct mlx5_ib_dev *dev = to_mdev(rwq->ibwq.device);\n\tstruct ib_event event;\n\n\tif (rwq->ibwq.event_handler) {\n\t\tevent.device     = rwq->ibwq.device;\n\t\tevent.element.wq = &rwq->ibwq;\n\t\tswitch (type) {\n\t\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\t\tevent.event = IB_EVENT_WQ_FATAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlx5_ib_warn(dev, \"Unexpected event type %d on WQ %06x\\n\", type, core_qp->qpn);\n\t\t\treturn;\n\t\t}\n\n\t\trwq->ibwq.event_handler(&event, rwq->ibwq.wq_context);\n\t}\n}\n\nstatic int set_delay_drop(struct mlx5_ib_dev *dev)\n{\n\tint err = 0;\n\n\tmutex_lock(&dev->delay_drop.lock);\n\tif (dev->delay_drop.activate)\n\t\tgoto out;\n\n\terr = mlx5_core_set_delay_drop(dev->mdev, dev->delay_drop.timeout);\n\tif (err)\n\t\tgoto out;\n\n\tdev->delay_drop.activate = true;\nout:\n\tmutex_unlock(&dev->delay_drop.lock);\n\n\tif (!err)\n\t\tatomic_inc(&dev->delay_drop.rqs_cnt);\n\treturn err;\n}\n\nstatic int  create_rq(struct mlx5_ib_rwq *rwq, struct ib_pd *pd,\n\t\t      struct ib_wq_init_attr *init_attr)\n{\n\tstruct mlx5_ib_dev *dev;\n\tint has_net_offloads;\n\t__be64 *rq_pas0;\n\tvoid *in;\n\tvoid *rqc;\n\tvoid *wq;\n\tint inlen;\n\tint err;\n\n\tdev = to_mdev(pd->device);\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rq_in) + sizeof(u64) * rwq->rq_num_pas;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(create_rq_in, in, ctx);\n\tMLX5_SET(rqc,  rqc, mem_rq_type,\n\t\t MLX5_RQC_MEM_RQ_TYPE_MEMORY_RQ_INLINE);\n\tMLX5_SET(rqc, rqc, user_index, rwq->user_index);\n\tMLX5_SET(rqc,  rqc, cqn, to_mcq(init_attr->cq)->mcq.cqn);\n\tMLX5_SET(rqc,  rqc, state, MLX5_RQC_STATE_RST);\n\tMLX5_SET(rqc,  rqc, flush_in_error_en, 1);\n\twq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tMLX5_SET(wq, wq, wq_type,\n\t\t rwq->create_flags & MLX5_IB_WQ_FLAGS_STRIDING_RQ ?\n\t\t MLX5_WQ_TYPE_CYCLIC_STRIDING_RQ : MLX5_WQ_TYPE_CYCLIC);\n\tif (init_attr->create_flags & IB_WQ_FLAGS_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tMLX5_SET(wq, wq, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t}\n\t}\n\tMLX5_SET(wq, wq, log_wq_stride, rwq->log_rq_stride);\n\tif (rwq->create_flags & MLX5_IB_WQ_FLAGS_STRIDING_RQ) {\n\t\tMLX5_SET(wq, wq, two_byte_shift_en, rwq->two_byte_shift_en);\n\t\tMLX5_SET(wq, wq, log_wqe_stride_size,\n\t\t\t rwq->single_stride_log_num_of_bytes -\n\t\t\t MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES);\n\t\tMLX5_SET(wq, wq, log_wqe_num_of_strides, rwq->log_num_strides -\n\t\t\t MLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES);\n\t}\n\tMLX5_SET(wq, wq, log_wq_sz, rwq->log_rq_size);\n\tMLX5_SET(wq, wq, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(wq, wq, page_offset, rwq->rq_page_offset);\n\tMLX5_SET(wq, wq, log_wq_pg_sz, rwq->log_page_size);\n\tMLX5_SET(wq, wq, wq_signature, rwq->wq_sig);\n\tMLX5_SET64(wq, wq, dbr_addr, rwq->db.dma);\n\thas_net_offloads = MLX5_CAP_GEN(dev->mdev, eth_net_offloads);\n\tif (init_attr->create_flags & IB_WQ_FLAGS_CVLAN_STRIPPING) {\n\t\tif (!(has_net_offloads && MLX5_CAP_ETH(dev->mdev, vlan_cap))) {\n\t\t\tmlx5_ib_dbg(dev, \"VLAN offloads are not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tMLX5_SET(rqc, rqc, vsd, 1);\n\t}\n\tif (init_attr->create_flags & IB_WQ_FLAGS_SCATTER_FCS) {\n\t\tif (!(has_net_offloads && MLX5_CAP_ETH(dev->mdev, scatter_fcs))) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(rqc, rqc, scatter_fcs, 1);\n\t}\n\tif (init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP) {\n\t\tif (!(dev->ib_dev.attrs.raw_packet_caps &\n\t\t      IB_RAW_PACKET_CAP_DELAY_DROP)) {\n\t\t\tmlx5_ib_dbg(dev, \"Delay drop is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(rqc, rqc, delay_drop_en, 1);\n\t}\n\trq_pas0 = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(dev, rwq->umem, rwq->page_shift, rq_pas0, 0);\n\terr = mlx5_core_create_rq_tracked(dev->mdev, in, inlen, &rwq->core_qp);\n\tif (!err && init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP) {\n\t\terr = set_delay_drop(dev);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"Failed to enable delay drop err=%d\\n\",\n\t\t\t\t     err);\n\t\t\tmlx5_core_destroy_rq_tracked(dev->mdev, &rwq->core_qp);\n\t\t} else {\n\t\t\trwq->create_flags |= MLX5_IB_WQ_FLAGS_DELAY_DROP;\n\t\t}\n\t}\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int set_user_rq_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_wq_init_attr *wq_init_attr,\n\t\t\t    struct mlx5_ib_create_wq *ucmd,\n\t\t\t    struct mlx5_ib_rwq *rwq)\n{\n\t/* Sanity check RQ size before proceeding */\n\tif (wq_init_attr->max_wr > (1 << MLX5_CAP_GEN(dev->mdev, log_max_wq_sz)))\n\t\treturn -EINVAL;\n\n\tif (!ucmd->rq_wqe_count)\n\t\treturn -EINVAL;\n\n\trwq->wqe_count = ucmd->rq_wqe_count;\n\trwq->wqe_shift = ucmd->rq_wqe_shift;\n\tif (check_shl_overflow(rwq->wqe_count, rwq->wqe_shift, &rwq->buf_size))\n\t\treturn -EINVAL;\n\n\trwq->log_rq_stride = rwq->wqe_shift;\n\trwq->log_rq_size = ilog2(rwq->wqe_count);\n\treturn 0;\n}\n\nstatic int prepare_user_rq(struct ib_pd *pd,\n\t\t\t   struct ib_wq_init_attr *init_attr,\n\t\t\t   struct ib_udata *udata,\n\t\t\t   struct mlx5_ib_rwq *rwq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tstruct mlx5_ib_create_wq ucmd = {};\n\tint err;\n\tsize_t required_cmd_sz;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), single_stride_log_num_of_bytes)\n\t\t+ sizeof(ucmd.single_stride_log_num_of_bytes);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tmlx5_ib_dbg(dev, \"invalid inlen\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tmlx5_ib_dbg(dev, \"inlen is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen))) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ucmd.comp_mask & (~MLX5_IB_CREATE_WQ_STRIDING_RQ)) {\n\t\tmlx5_ib_dbg(dev, \"invalid comp mask\\n\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (ucmd.comp_mask & MLX5_IB_CREATE_WQ_STRIDING_RQ) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, striding_rq)) {\n\t\t\tmlx5_ib_dbg(dev, \"Striding RQ is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif ((ucmd.single_stride_log_num_of_bytes <\n\t\t    MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES) ||\n\t\t    (ucmd.single_stride_log_num_of_bytes >\n\t\t     MLX5_MAX_SINGLE_STRIDE_LOG_NUM_BYTES)) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid log stride size (%u. Range is %u - %u)\\n\",\n\t\t\t\t    ucmd.single_stride_log_num_of_bytes,\n\t\t\t\t    MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES,\n\t\t\t\t    MLX5_MAX_SINGLE_STRIDE_LOG_NUM_BYTES);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((ucmd.single_wqe_log_num_of_strides >\n\t\t    MLX5_MAX_SINGLE_WQE_LOG_NUM_STRIDES) ||\n\t\t     (ucmd.single_wqe_log_num_of_strides <\n\t\t\tMLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES)) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid log num strides (%u. Range is %u - %u)\\n\",\n\t\t\t\t    ucmd.single_wqe_log_num_of_strides,\n\t\t\t\t    MLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES,\n\t\t\t\t    MLX5_MAX_SINGLE_WQE_LOG_NUM_STRIDES);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trwq->single_stride_log_num_of_bytes =\n\t\t\tucmd.single_stride_log_num_of_bytes;\n\t\trwq->log_num_strides = ucmd.single_wqe_log_num_of_strides;\n\t\trwq->two_byte_shift_en = !!ucmd.two_byte_shift_en;\n\t\trwq->create_flags |= MLX5_IB_WQ_FLAGS_STRIDING_RQ;\n\t}\n\n\terr = set_user_rq_size(dev, init_attr, &ucmd, rwq);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = create_user_rq(dev, pd, rwq, &ucmd);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\trwq->user_index = ucmd.user_index;\n\treturn 0;\n}\n\nstruct ib_wq *mlx5_ib_create_wq(struct ib_pd *pd,\n\t\t\t\tstruct ib_wq_init_attr *init_attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev;\n\tstruct mlx5_ib_rwq *rwq;\n\tstruct mlx5_ib_create_wq_resp resp = {};\n\tsize_t min_resp_len;\n\tint err;\n\n\tif (!udata)\n\t\treturn ERR_PTR(-ENOSYS);\n\n\tmin_resp_len = offsetof(typeof(resp), reserved) + sizeof(resp.reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = to_mdev(pd->device);\n\tswitch (init_attr->wq_type) {\n\tcase IB_WQT_RQ:\n\t\trwq = kzalloc(sizeof(*rwq), GFP_KERNEL);\n\t\tif (!rwq)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = prepare_user_rq(pd, init_attr, udata, rwq);\n\t\tif (err)\n\t\t\tgoto err;\n\t\terr = create_rq(rwq, pd, init_attr);\n\t\tif (err)\n\t\t\tgoto err_user_rq;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_ib_dbg(dev, \"unsupported wq type %d\\n\",\n\t\t\t    init_attr->wq_type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trwq->ibwq.wq_num = rwq->core_qp.qpn;\n\trwq->ibwq.state = IB_WQS_RESET;\n\tif (udata->outlen) {\n\t\tresp.response_length = offsetof(typeof(resp), response_length) +\n\t\t\t\tsizeof(resp.response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\tgoto err_copy;\n\t}\n\n\trwq->core_qp.event = mlx5_ib_wq_event;\n\trwq->ibwq.event_handler = init_attr->event_handler;\n\treturn &rwq->ibwq;\n\nerr_copy:\n\tmlx5_core_destroy_rq_tracked(dev->mdev, &rwq->core_qp);\nerr_user_rq:\n\tdestroy_user_rq(dev, pd, rwq);\nerr:\n\tkfree(rwq);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_ib_destroy_wq(struct ib_wq *wq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(wq->device);\n\tstruct mlx5_ib_rwq *rwq = to_mrwq(wq);\n\n\tmlx5_core_destroy_rq_tracked(dev->mdev, &rwq->core_qp);\n\tdestroy_user_rq(dev, wq->pd, rwq);\n\tkfree(rwq);\n\n\treturn 0;\n}\n\nstruct ib_rwq_ind_table *mlx5_ib_create_rwq_ind_table(struct ib_device *device,\n\t\t\t\t\t\t      struct ib_rwq_ind_table_init_attr *init_attr,\n\t\t\t\t\t\t      struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_ib_rwq_ind_table *rwq_ind_tbl;\n\tint sz = 1 << init_attr->log_ind_tbl_size;\n\tstruct mlx5_ib_create_rwq_ind_tbl_resp resp = {};\n\tsize_t min_resp_len;\n\tint inlen;\n\tint err;\n\tint i;\n\tu32 *in;\n\tvoid *rqtc;\n\n\tif (udata->inlen > 0 &&\n\t    !ib_is_udata_cleared(udata, 0,\n\t\t\t\t udata->inlen))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (init_attr->log_ind_tbl_size >\n\t    MLX5_CAP_GEN(dev->mdev, log_max_rqt_size)) {\n\t\tmlx5_ib_dbg(dev, \"log_ind_tbl_size = %d is bigger than supported = %d\\n\",\n\t\t\t    init_attr->log_ind_tbl_size,\n\t\t\t    MLX5_CAP_GEN(dev->mdev, log_max_rqt_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmin_resp_len = offsetof(typeof(resp), reserved) + sizeof(resp.reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trwq_ind_tbl = kzalloc(sizeof(*rwq_ind_tbl), GFP_KERNEL);\n\tif (!rwq_ind_tbl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\trqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);\n\n\tMLX5_SET(rqtc, rqtc, rqt_actual_size, sz);\n\tMLX5_SET(rqtc, rqtc, rqt_max_size, sz);\n\n\tfor (i = 0; i < sz; i++)\n\t\tMLX5_SET(rqtc, rqtc, rq_num[i], init_attr->ind_tbl[i]->wq_num);\n\n\terr = mlx5_core_create_rqt(dev->mdev, in, inlen, &rwq_ind_tbl->rqtn);\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err;\n\n\trwq_ind_tbl->ib_rwq_ind_tbl.ind_tbl_num = rwq_ind_tbl->rqtn;\n\tif (udata->outlen) {\n\t\tresp.response_length = offsetof(typeof(resp), response_length) +\n\t\t\t\t\tsizeof(resp.response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\tgoto err_copy;\n\t}\n\n\treturn &rwq_ind_tbl->ib_rwq_ind_tbl;\n\nerr_copy:\n\tmlx5_core_destroy_rqt(dev->mdev, rwq_ind_tbl->rqtn);\nerr:\n\tkfree(rwq_ind_tbl);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_ib_destroy_rwq_ind_table(struct ib_rwq_ind_table *ib_rwq_ind_tbl)\n{\n\tstruct mlx5_ib_rwq_ind_table *rwq_ind_tbl = to_mrwq_ind_table(ib_rwq_ind_tbl);\n\tstruct mlx5_ib_dev *dev = to_mdev(ib_rwq_ind_tbl->device);\n\n\tmlx5_core_destroy_rqt(dev->mdev, rwq_ind_tbl->rqtn);\n\n\tkfree(rwq_ind_tbl);\n\treturn 0;\n}\n\nint mlx5_ib_modify_wq(struct ib_wq *wq, struct ib_wq_attr *wq_attr,\n\t\t      u32 wq_attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(wq->device);\n\tstruct mlx5_ib_rwq *rwq = to_mrwq(wq);\n\tstruct mlx5_ib_modify_wq ucmd = {};\n\tsize_t required_cmd_sz;\n\tint curr_wq_state;\n\tint wq_state;\n\tint inlen;\n\tint err;\n\tvoid *rqc;\n\tvoid *in;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), reserved) + sizeof(ucmd.reserved);\n\tif (udata->inlen < required_cmd_sz)\n\t\treturn -EINVAL;\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen)))\n\t\treturn -EFAULT;\n\n\tif (ucmd.comp_mask || ucmd.reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_rq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\n\tcurr_wq_state = (wq_attr_mask & IB_WQ_CUR_STATE) ?\n\t\twq_attr->curr_wq_state : wq->state;\n\twq_state = (wq_attr_mask & IB_WQ_STATE) ?\n\t\twq_attr->wq_state : curr_wq_state;\n\tif (curr_wq_state == IB_WQS_ERR)\n\t\tcurr_wq_state = MLX5_RQC_STATE_ERR;\n\tif (wq_state == IB_WQS_ERR)\n\t\twq_state = MLX5_RQC_STATE_ERR;\n\tMLX5_SET(modify_rq_in, in, rq_state, curr_wq_state);\n\tMLX5_SET(rqc, rqc, state, wq_state);\n\n\tif (wq_attr_mask & IB_WQ_FLAGS) {\n\t\tif (wq_attr->flags_mask & IB_WQ_FLAGS_CVLAN_STRIPPING) {\n\t\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap))) {\n\t\t\t\tmlx5_ib_dbg(dev, \"VLAN offloads are not \"\n\t\t\t\t\t    \"supported\\n\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_VSD);\n\t\t\tMLX5_SET(rqc, rqc, vsd,\n\t\t\t\t (wq_attr->flags & IB_WQ_FLAGS_CVLAN_STRIPPING) ? 0 : 1);\n\t\t}\n\n\t\tif (wq_attr->flags_mask & IB_WQ_FLAGS_PCI_WRITE_END_PADDING) {\n\t\t\tmlx5_ib_dbg(dev, \"Modifying scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (curr_wq_state == IB_WQS_RESET && wq_state == IB_WQS_RDY) {\n\t\tif (MLX5_CAP_GEN(dev->mdev, modify_rq_counter_set_id)) {\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\t\t\tMLX5_SET(rqc, rqc, counter_set_id,\n\t\t\t\t dev->port->cnts.set_id);\n\t\t} else\n\t\t\tpr_info_once(\"%s: Receive WQ counters are not supported on current FW\\n\",\n\t\t\t\t     dev->ib_dev.name);\n\t}\n\n\terr = mlx5_core_modify_rq(dev->mdev, rwq->core_qp.qpn, in, inlen);\n\tif (!err)\n\t\trwq->ibwq.state = (wq_state == MLX5_RQC_STATE_ERR) ? IB_WQS_ERR : wq_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstruct mlx5_ib_drain_cqe {\n\tstruct ib_cqe cqe;\n\tstruct completion done;\n};\n\nstatic void mlx5_ib_drain_qp_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_drain_cqe *cqe = container_of(wc->wr_cqe,\n\t\t\t\t\t\t     struct mlx5_ib_drain_cqe,\n\t\t\t\t\t\t     cqe);\n\n\tcomplete(&cqe->done);\n}\n\n/* This function returns only once the drained WR was completed */\nstatic void handle_drain_completion(struct ib_cq *cq,\n\t\t\t\t    struct mlx5_ib_drain_cqe *sdrain,\n\t\t\t\t    struct mlx5_ib_dev *dev)\n{\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tif (cq->poll_ctx == IB_POLL_DIRECT) {\n\t\twhile (wait_for_completion_timeout(&sdrain->done, HZ / 10) <= 0)\n\t\t\tib_process_cq_direct(cq, -1);\n\t\treturn;\n\t}\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tstruct mlx5_ib_cq *mcq = to_mcq(cq);\n\t\tbool triggered = false;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\t\t/* Make sure that the CQ handler won't run if wasn't run yet */\n\t\tif (!mcq->mcq.reset_notify_added)\n\t\t\tmcq->mcq.reset_notify_added = 1;\n\t\telse\n\t\t\ttriggered = true;\n\t\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\t\tif (triggered) {\n\t\t\t/* Wait for any scheduled/running task to be ended */\n\t\t\tswitch (cq->poll_ctx) {\n\t\t\tcase IB_POLL_SOFTIRQ:\n\t\t\t\tirq_poll_disable(&cq->iop);\n\t\t\t\tirq_poll_enable(&cq->iop);\n\t\t\t\tbreak;\n\t\t\tcase IB_POLL_WORKQUEUE:\n\t\t\t\tcancel_work_sync(&cq->work);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t}\n\t\t}\n\n\t\t/* Run the CQ handler - this makes sure that the drain WR will\n\t\t * be processed if wasn't processed yet.\n\t\t */\n\t\tmcq->mcq.comp(&mcq->mcq);\n\t}\n\n\twait_for_completion(&sdrain->done);\n}\n\nvoid mlx5_ib_drain_sq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->send_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx5_ib_drain_cqe sdrain;\n\tconst struct ib_send_wr *bad_swr;\n\tstruct ib_rdma_wr swr = {\n\t\t.wr = {\n\t\t\t.next = NULL,\n\t\t\t{ .wr_cqe\t= &sdrain.cqe, },\n\t\t\t.opcode\t= IB_WR_RDMA_WRITE,\n\t\t},\n\t};\n\tint ret;\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tsdrain.cqe.done = mlx5_ib_drain_qp_done;\n\tinit_completion(&sdrain.done);\n\n\tret = _mlx5_ib_post_send(qp, &swr.wr, &bad_swr, true);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &sdrain, dev);\n}\n\nvoid mlx5_ib_drain_rq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->recv_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx5_ib_drain_cqe rdrain;\n\tstruct ib_recv_wr rwr = {};\n\tconst struct ib_recv_wr *bad_rwr;\n\tint ret;\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\trwr.wr_cqe = &rdrain.cqe;\n\trdrain.cqe.done = mlx5_ib_drain_qp_done;\n\tinit_completion(&rdrain.done);\n\n\tret = _mlx5_ib_post_recv(qp, &rwr, &bad_rwr, true);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &rdrain, dev);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2013-2015, Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/module.h>\n#include <rdma/ib_umem.h>\n#include <rdma/ib_cache.h>\n#include <rdma/ib_user_verbs.h>\n#include <linux/mlx5/fs.h>\n#include \"mlx5_ib.h\"\n#include \"ib_rep.h\"\n\n/* not supported currently */\nstatic int wq_signature;\n\nenum {\n\tMLX5_IB_ACK_REQ_FREQ\t= 8,\n};\n\nenum {\n\tMLX5_IB_DEFAULT_SCHED_QUEUE\t= 0x83,\n\tMLX5_IB_DEFAULT_QP0_SCHED_QUEUE\t= 0x3f,\n\tMLX5_IB_LINK_TYPE_IB\t\t= 0,\n\tMLX5_IB_LINK_TYPE_ETH\t\t= 1\n};\n\nenum {\n\tMLX5_IB_SQ_STRIDE\t= 6,\n\tMLX5_IB_SQ_UMR_INLINE_THRESHOLD = 64,\n};\n\nstatic const u32 mlx5_ib_opcode[] = {\n\t[IB_WR_SEND]\t\t\t\t= MLX5_OPCODE_SEND,\n\t[IB_WR_LSO]\t\t\t\t= MLX5_OPCODE_LSO,\n\t[IB_WR_SEND_WITH_IMM]\t\t\t= MLX5_OPCODE_SEND_IMM,\n\t[IB_WR_RDMA_WRITE]\t\t\t= MLX5_OPCODE_RDMA_WRITE,\n\t[IB_WR_RDMA_WRITE_WITH_IMM]\t\t= MLX5_OPCODE_RDMA_WRITE_IMM,\n\t[IB_WR_RDMA_READ]\t\t\t= MLX5_OPCODE_RDMA_READ,\n\t[IB_WR_ATOMIC_CMP_AND_SWP]\t\t= MLX5_OPCODE_ATOMIC_CS,\n\t[IB_WR_ATOMIC_FETCH_AND_ADD]\t\t= MLX5_OPCODE_ATOMIC_FA,\n\t[IB_WR_SEND_WITH_INV]\t\t\t= MLX5_OPCODE_SEND_INVAL,\n\t[IB_WR_LOCAL_INV]\t\t\t= MLX5_OPCODE_UMR,\n\t[IB_WR_REG_MR]\t\t\t\t= MLX5_OPCODE_UMR,\n\t[IB_WR_MASKED_ATOMIC_CMP_AND_SWP]\t= MLX5_OPCODE_ATOMIC_MASKED_CS,\n\t[IB_WR_MASKED_ATOMIC_FETCH_AND_ADD]\t= MLX5_OPCODE_ATOMIC_MASKED_FA,\n\t[MLX5_IB_WR_UMR]\t\t\t= MLX5_OPCODE_UMR,\n};\n\nstruct mlx5_wqe_eth_pad {\n\tu8 rsvd0[16];\n};\n\nenum raw_qp_set_mask_map {\n\tMLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID\t\t= 1UL << 0,\n\tMLX5_RAW_QP_RATE_LIMIT\t\t\t= 1UL << 1,\n};\n\nstruct mlx5_modify_raw_qp_param {\n\tu16 operation;\n\n\tu32 set_mask; /* raw_qp_set_mask_map */\n\n\tstruct mlx5_rate_limit rl;\n\n\tu8 rq_q_ctr_id;\n};\n\nstatic void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq);\n\nstatic int is_qp0(enum ib_qp_type qp_type)\n{\n\treturn qp_type == IB_QPT_SMI;\n}\n\nstatic int is_sqp(enum ib_qp_type qp_type)\n{\n\treturn is_qp0(qp_type) || is_qp1(qp_type);\n}\n\nstatic void *get_wqe(struct mlx5_ib_qp *qp, int offset)\n{\n\treturn mlx5_buf_offset(&qp->buf, offset);\n}\n\nstatic void *get_recv_wqe(struct mlx5_ib_qp *qp, int n)\n{\n\treturn get_wqe(qp, qp->rq.offset + (n << qp->rq.wqe_shift));\n}\n\nvoid *mlx5_get_send_wqe(struct mlx5_ib_qp *qp, int n)\n{\n\treturn get_wqe(qp, qp->sq.offset + (n << MLX5_IB_SQ_STRIDE));\n}\n\n/**\n * mlx5_ib_read_user_wqe() - Copy a user-space WQE to kernel space.\n *\n * @qp: QP to copy from.\n * @send: copy from the send queue when non-zero, use the receive queue\n *\t  otherwise.\n * @wqe_index:  index to start copying from. For send work queues, the\n *\t\twqe_index is in units of MLX5_SEND_WQE_BB.\n *\t\tFor receive work queue, it is the number of work queue\n *\t\telement in the queue.\n * @buffer: destination buffer.\n * @length: maximum number of bytes to copy.\n *\n * Copies at least a single WQE, but may copy more data.\n *\n * Return: the number of bytes copied, or an error code.\n */\nint mlx5_ib_read_user_wqe(struct mlx5_ib_qp *qp, int send, int wqe_index,\n\t\t\t  void *buffer, u32 length,\n\t\t\t  struct mlx5_ib_qp_base *base)\n{\n\tstruct ib_device *ibdev = qp->ibqp.device;\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tstruct mlx5_ib_wq *wq = send ? &qp->sq : &qp->rq;\n\tsize_t offset;\n\tsize_t wq_end;\n\tstruct ib_umem *umem = base->ubuffer.umem;\n\tu32 first_copy_length;\n\tint wqe_length;\n\tint ret;\n\n\tif (wq->wqe_cnt == 0) {\n\t\tmlx5_ib_dbg(dev, \"mlx5_ib_read_user_wqe for a QP with wqe_cnt == 0. qp_type: 0x%x\\n\",\n\t\t\t    qp->ibqp.qp_type);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = wq->offset + ((wqe_index % wq->wqe_cnt) << wq->wqe_shift);\n\twq_end = wq->offset + (wq->wqe_cnt << wq->wqe_shift);\n\n\tif (send && length < sizeof(struct mlx5_wqe_ctrl_seg))\n\t\treturn -EINVAL;\n\n\tif (offset > umem->length ||\n\t    (send && offset + sizeof(struct mlx5_wqe_ctrl_seg) > umem->length))\n\t\treturn -EINVAL;\n\n\tfirst_copy_length = min_t(u32, offset + length, wq_end) - offset;\n\tret = ib_umem_copy_from(buffer, umem, offset, first_copy_length);\n\tif (ret)\n\t\treturn ret;\n\n\tif (send) {\n\t\tstruct mlx5_wqe_ctrl_seg *ctrl = buffer;\n\t\tint ds = be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_DS_MASK;\n\n\t\twqe_length = ds * MLX5_WQE_DS_UNITS;\n\t} else {\n\t\twqe_length = 1 << wq->wqe_shift;\n\t}\n\n\tif (wqe_length <= first_copy_length)\n\t\treturn first_copy_length;\n\n\tret = ib_umem_copy_from(buffer + first_copy_length, umem, wq->offset,\n\t\t\t\twqe_length - first_copy_length);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wqe_length;\n}\n\nstatic void mlx5_ib_qp_event(struct mlx5_core_qp *qp, int type)\n{\n\tstruct ib_qp *ibqp = &to_mibqp(qp)->ibqp;\n\tstruct ib_event event;\n\n\tif (type == MLX5_EVENT_TYPE_PATH_MIG) {\n\t\t/* This event is only valid for trans_qps */\n\t\tto_mibqp(qp)->port = to_mibqp(qp)->trans_qp.alt_port;\n\t}\n\n\tif (ibqp->event_handler) {\n\t\tevent.device     = ibqp->device;\n\t\tevent.element.qp = ibqp;\n\t\tswitch (type) {\n\t\tcase MLX5_EVENT_TYPE_PATH_MIG:\n\t\t\tevent.event = IB_EVENT_PATH_MIG;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_COMM_EST:\n\t\t\tevent.event = IB_EVENT_COMM_EST;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_SQ_DRAINED:\n\t\t\tevent.event = IB_EVENT_SQ_DRAINED;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_SRQ_LAST_WQE:\n\t\t\tevent.event = IB_EVENT_QP_LAST_WQE_REACHED;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\t\tevent.event = IB_EVENT_QP_FATAL;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_PATH_MIG_FAILED:\n\t\t\tevent.event = IB_EVENT_PATH_MIG_ERR;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\t\tevent.event = IB_EVENT_QP_REQ_ERR;\n\t\t\tbreak;\n\t\tcase MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\t\tevent.event = IB_EVENT_QP_ACCESS_ERR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"mlx5_ib: Unexpected event type %d on QP %06x\\n\", type, qp->qpn);\n\t\t\treturn;\n\t\t}\n\n\t\tibqp->event_handler(&event, ibqp->qp_context);\n\t}\n}\n\nstatic int set_rq_size(struct mlx5_ib_dev *dev, struct ib_qp_cap *cap,\n\t\t       int has_rq, struct mlx5_ib_qp *qp, struct mlx5_ib_create_qp *ucmd)\n{\n\tint wqe_size;\n\tint wq_size;\n\n\t/* Sanity check RQ size before proceeding */\n\tif (cap->max_recv_wr > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz)))\n\t\treturn -EINVAL;\n\n\tif (!has_rq) {\n\t\tqp->rq.max_gs = 0;\n\t\tqp->rq.wqe_cnt = 0;\n\t\tqp->rq.wqe_shift = 0;\n\t\tcap->max_recv_wr = 0;\n\t\tcap->max_recv_sge = 0;\n\t} else {\n\t\tif (ucmd) {\n\t\t\tqp->rq.wqe_cnt = ucmd->rq_wqe_count;\n\t\t\tif (ucmd->rq_wqe_shift > BITS_PER_BYTE * sizeof(ucmd->rq_wqe_shift))\n\t\t\t\treturn -EINVAL;\n\t\t\tqp->rq.wqe_shift = ucmd->rq_wqe_shift;\n\t\t\tif ((1 << qp->rq.wqe_shift) / sizeof(struct mlx5_wqe_data_seg) < qp->wq_sig)\n\t\t\t\treturn -EINVAL;\n\t\t\tqp->rq.max_gs = (1 << qp->rq.wqe_shift) / sizeof(struct mlx5_wqe_data_seg) - qp->wq_sig;\n\t\t\tqp->rq.max_post = qp->rq.wqe_cnt;\n\t\t} else {\n\t\t\twqe_size = qp->wq_sig ? sizeof(struct mlx5_wqe_signature_seg) : 0;\n\t\t\twqe_size += cap->max_recv_sge * sizeof(struct mlx5_wqe_data_seg);\n\t\t\twqe_size = roundup_pow_of_two(wqe_size);\n\t\t\twq_size = roundup_pow_of_two(cap->max_recv_wr) * wqe_size;\n\t\t\twq_size = max_t(int, wq_size, MLX5_SEND_WQE_BB);\n\t\t\tqp->rq.wqe_cnt = wq_size / wqe_size;\n\t\t\tif (wqe_size > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_rq)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"wqe_size %d, max %d\\n\",\n\t\t\t\t\t    wqe_size,\n\t\t\t\t\t    MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t\t max_wqe_sz_rq));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tqp->rq.wqe_shift = ilog2(wqe_size);\n\t\t\tqp->rq.max_gs = (1 << qp->rq.wqe_shift) / sizeof(struct mlx5_wqe_data_seg) - qp->wq_sig;\n\t\t\tqp->rq.max_post = qp->rq.wqe_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sq_overhead(struct ib_qp_init_attr *attr)\n{\n\tint size = 0;\n\n\tswitch (attr->qp_type) {\n\tcase IB_QPT_XRC_INI:\n\t\tsize += sizeof(struct mlx5_wqe_xrc_seg);\n\t\t/* fall through */\n\tcase IB_QPT_RC:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tmax(sizeof(struct mlx5_wqe_atomic_seg) +\n\t\t\t    sizeof(struct mlx5_wqe_raddr_seg),\n\t\t\t    sizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\t    sizeof(struct mlx5_mkey_seg) +\n\t\t\t    MLX5_IB_SQ_UMR_INLINE_THRESHOLD /\n\t\t\t    MLX5_IB_UMR_OCTOWORD);\n\t\tbreak;\n\n\tcase IB_QPT_XRC_TGT:\n\t\treturn 0;\n\n\tcase IB_QPT_UC:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tmax(sizeof(struct mlx5_wqe_raddr_seg),\n\t\t\t    sizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\t    sizeof(struct mlx5_mkey_seg));\n\t\tbreak;\n\n\tcase IB_QPT_UD:\n\t\tif (attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)\n\t\t\tsize += sizeof(struct mlx5_wqe_eth_pad) +\n\t\t\t\tsizeof(struct mlx5_wqe_eth_seg);\n\t\t/* fall through */\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_wqe_datagram_seg);\n\t\tbreak;\n\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_mkey_seg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n}\n\nstatic int calc_send_wqe(struct ib_qp_init_attr *attr)\n{\n\tint inl_size = 0;\n\tint size;\n\n\tsize = sq_overhead(attr);\n\tif (size < 0)\n\t\treturn size;\n\n\tif (attr->cap.max_inline_data) {\n\t\tinl_size = size + sizeof(struct mlx5_wqe_inline_seg) +\n\t\t\tattr->cap.max_inline_data;\n\t}\n\n\tsize += attr->cap.max_send_sge * sizeof(struct mlx5_wqe_data_seg);\n\tif (attr->create_flags & IB_QP_CREATE_SIGNATURE_EN &&\n\t    ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB) < MLX5_SIG_WQE_SIZE)\n\t\t\treturn MLX5_SIG_WQE_SIZE;\n\telse\n\t\treturn ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB);\n}\n\nstatic int get_send_sge(struct ib_qp_init_attr *attr, int wqe_size)\n{\n\tint max_sge;\n\n\tif (attr->qp_type == IB_QPT_RC)\n\t\tmax_sge = (min_t(int, wqe_size, 512) -\n\t\t\t   sizeof(struct mlx5_wqe_ctrl_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_raddr_seg)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\telse if (attr->qp_type == IB_QPT_XRC_INI)\n\t\tmax_sge = (min_t(int, wqe_size, 512) -\n\t\t\t   sizeof(struct mlx5_wqe_ctrl_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_xrc_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_raddr_seg)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\telse\n\t\tmax_sge = (wqe_size - sq_overhead(attr)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\n\treturn min_t(int, max_sge, wqe_size - sq_overhead(attr) /\n\t\t     sizeof(struct mlx5_wqe_data_seg));\n}\n\nstatic int calc_sq_size(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,\n\t\t\tstruct mlx5_ib_qp *qp)\n{\n\tint wqe_size;\n\tint wq_size;\n\n\tif (!attr->cap.max_send_wr)\n\t\treturn 0;\n\n\twqe_size = calc_send_wqe(attr);\n\tmlx5_ib_dbg(dev, \"wqe_size %d\\n\", wqe_size);\n\tif (wqe_size < 0)\n\t\treturn wqe_size;\n\n\tif (wqe_size > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_dbg(dev, \"wqe_size(%d) > max_sq_desc_sz(%d)\\n\",\n\t\t\t    wqe_size, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tqp->max_inline_data = wqe_size - sq_overhead(attr) -\n\t\t\t      sizeof(struct mlx5_wqe_inline_seg);\n\tattr->cap.max_inline_data = qp->max_inline_data;\n\n\tif (attr->create_flags & IB_QP_CREATE_SIGNATURE_EN)\n\t\tqp->signature_en = true;\n\n\twq_size = roundup_pow_of_two(attr->cap.max_send_wr * wqe_size);\n\tqp->sq.wqe_cnt = wq_size / MLX5_SEND_WQE_BB;\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_dbg(dev, \"send queue size (%d * %d / %d -> %d) exceeds limits(%d)\\n\",\n\t\t\t    attr->cap.max_send_wr, wqe_size, MLX5_SEND_WQE_BB,\n\t\t\t    qp->sq.wqe_cnt,\n\t\t\t    1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -ENOMEM;\n\t}\n\tqp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);\n\tqp->sq.max_gs = get_send_sge(attr, wqe_size);\n\tif (qp->sq.max_gs < attr->cap.max_send_sge)\n\t\treturn -ENOMEM;\n\n\tattr->cap.max_send_sge = qp->sq.max_gs;\n\tqp->sq.max_post = wq_size / wqe_size;\n\tattr->cap.max_send_wr = qp->sq.max_post;\n\n\treturn wq_size;\n}\n\nstatic int set_user_buf_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    struct mlx5_ib_create_qp *ucmd,\n\t\t\t    struct mlx5_ib_qp_base *base,\n\t\t\t    struct ib_qp_init_attr *attr)\n{\n\tint desc_sz = 1 << qp->sq.wqe_shift;\n\n\tif (desc_sz > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_warn(dev, \"desc_sz %d, max_sq_desc_sz %d\\n\",\n\t\t\t     desc_sz, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucmd->sq_wqe_count && ((1 << ilog2(ucmd->sq_wqe_count)) != ucmd->sq_wqe_count)) {\n\t\tmlx5_ib_warn(dev, \"sq_wqe_count %d, sq_wqe_count %d\\n\",\n\t\t\t     ucmd->sq_wqe_count, ucmd->sq_wqe_count);\n\t\treturn -EINVAL;\n\t}\n\n\tqp->sq.wqe_cnt = ucmd->sq_wqe_count;\n\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_warn(dev, \"wqe_cnt %d, max_wqes %d\\n\",\n\t\t\t     qp->sq.wqe_cnt,\n\t\t\t     1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tbase->ubuffer.buf_size = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_size = qp->sq.wqe_cnt << 6;\n\t} else {\n\t\tbase->ubuffer.buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t\t\t\t (qp->sq.wqe_cnt << 6);\n\t}\n\n\treturn 0;\n}\n\nstatic int qp_has_rq(struct ib_qp_init_attr *attr)\n{\n\tif (attr->qp_type == IB_QPT_XRC_INI ||\n\t    attr->qp_type == IB_QPT_XRC_TGT || attr->srq ||\n\t    attr->qp_type == MLX5_IB_QPT_REG_UMR ||\n\t    !attr->cap.max_recv_wr)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nenum {\n\t/* this is the first blue flame register in the array of bfregs assigned\n\t * to a processes. Since we do not use it for blue flame but rather\n\t * regular 64 bit doorbells, we do not need a lock for maintaiing\n\t * \"odd/even\" order\n\t */\n\tNUM_NON_BLUE_FLAME_BFREGS = 1,\n};\n\nstatic int max_bfregs(struct mlx5_ib_dev *dev, struct mlx5_bfreg_info *bfregi)\n{\n\treturn get_num_static_uars(dev, bfregi) * MLX5_NON_FP_BFREGS_PER_UAR;\n}\n\nstatic int num_med_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t struct mlx5_bfreg_info *bfregi)\n{\n\tint n;\n\n\tn = max_bfregs(dev, bfregi) - bfregi->num_low_latency_bfregs -\n\t    NUM_NON_BLUE_FLAME_BFREGS;\n\n\treturn n >= 0 ? n : 0;\n}\n\nstatic int first_med_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t   struct mlx5_bfreg_info *bfregi)\n{\n\treturn num_med_bfreg(dev, bfregi) ? 1 : -ENOMEM;\n}\n\nstatic int first_hi_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t  struct mlx5_bfreg_info *bfregi)\n{\n\tint med;\n\n\tmed = num_med_bfreg(dev, bfregi);\n\treturn ++med;\n}\n\nstatic int alloc_high_class_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_bfreg_info *bfregi)\n{\n\tint i;\n\n\tfor (i = first_hi_bfreg(dev, bfregi); i < max_bfregs(dev, bfregi); i++) {\n\t\tif (!bfregi->count[i]) {\n\t\t\tbfregi->count[i]++;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int alloc_med_class_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t\t struct mlx5_bfreg_info *bfregi)\n{\n\tint minidx = first_med_bfreg(dev, bfregi);\n\tint i;\n\n\tif (minidx < 0)\n\t\treturn minidx;\n\n\tfor (i = minidx; i < first_hi_bfreg(dev, bfregi); i++) {\n\t\tif (bfregi->count[i] < bfregi->count[minidx])\n\t\t\tminidx = i;\n\t\tif (!bfregi->count[minidx])\n\t\t\tbreak;\n\t}\n\n\tbfregi->count[minidx]++;\n\treturn minidx;\n}\n\nstatic int alloc_bfreg(struct mlx5_ib_dev *dev,\n\t\t       struct mlx5_bfreg_info *bfregi)\n{\n\tint bfregn = -ENOMEM;\n\n\tmutex_lock(&bfregi->lock);\n\tif (bfregi->ver >= 2) {\n\t\tbfregn = alloc_high_class_bfreg(dev, bfregi);\n\t\tif (bfregn < 0)\n\t\t\tbfregn = alloc_med_class_bfreg(dev, bfregi);\n\t}\n\n\tif (bfregn < 0) {\n\t\tBUILD_BUG_ON(NUM_NON_BLUE_FLAME_BFREGS != 1);\n\t\tbfregn = 0;\n\t\tbfregi->count[bfregn]++;\n\t}\n\tmutex_unlock(&bfregi->lock);\n\n\treturn bfregn;\n}\n\nvoid mlx5_ib_free_bfreg(struct mlx5_ib_dev *dev, struct mlx5_bfreg_info *bfregi, int bfregn)\n{\n\tmutex_lock(&bfregi->lock);\n\tbfregi->count[bfregn]--;\n\tmutex_unlock(&bfregi->lock);\n}\n\nstatic enum mlx5_qp_state to_mlx5_state(enum ib_qp_state state)\n{\n\tswitch (state) {\n\tcase IB_QPS_RESET:\treturn MLX5_QP_STATE_RST;\n\tcase IB_QPS_INIT:\treturn MLX5_QP_STATE_INIT;\n\tcase IB_QPS_RTR:\treturn MLX5_QP_STATE_RTR;\n\tcase IB_QPS_RTS:\treturn MLX5_QP_STATE_RTS;\n\tcase IB_QPS_SQD:\treturn MLX5_QP_STATE_SQD;\n\tcase IB_QPS_SQE:\treturn MLX5_QP_STATE_SQER;\n\tcase IB_QPS_ERR:\treturn MLX5_QP_STATE_ERR;\n\tdefault:\t\treturn -1;\n\t}\n}\n\nstatic int to_mlx5_st(enum ib_qp_type type)\n{\n\tswitch (type) {\n\tcase IB_QPT_RC:\t\t\treturn MLX5_QP_ST_RC;\n\tcase IB_QPT_UC:\t\t\treturn MLX5_QP_ST_UC;\n\tcase IB_QPT_UD:\t\t\treturn MLX5_QP_ST_UD;\n\tcase MLX5_IB_QPT_REG_UMR:\treturn MLX5_QP_ST_REG_UMR;\n\tcase IB_QPT_XRC_INI:\n\tcase IB_QPT_XRC_TGT:\t\treturn MLX5_QP_ST_XRC;\n\tcase IB_QPT_SMI:\t\treturn MLX5_QP_ST_QP0;\n\tcase MLX5_IB_QPT_HW_GSI:\treturn MLX5_QP_ST_QP1;\n\tcase MLX5_IB_QPT_DCI:\t\treturn MLX5_QP_ST_DCI;\n\tcase IB_QPT_RAW_IPV6:\t\treturn MLX5_QP_ST_RAW_IPV6;\n\tcase IB_QPT_RAW_PACKET:\n\tcase IB_QPT_RAW_ETHERTYPE:\treturn MLX5_QP_ST_RAW_ETHERTYPE;\n\tcase IB_QPT_MAX:\n\tdefault:\t\treturn -EINVAL;\n\t}\n}\n\nstatic void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq,\n\t\t\t     struct mlx5_ib_cq *recv_cq);\nstatic void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq,\n\t\t\t       struct mlx5_ib_cq *recv_cq);\n\nint bfregn_to_uar_index(struct mlx5_ib_dev *dev,\n\t\t\tstruct mlx5_bfreg_info *bfregi, u32 bfregn,\n\t\t\tbool dyn_bfreg)\n{\n\tunsigned int bfregs_per_sys_page;\n\tu32 index_of_sys_page;\n\tu32 offset;\n\n\tbfregs_per_sys_page = get_uars_per_sys_page(dev, bfregi->lib_uar_4k) *\n\t\t\t\tMLX5_NON_FP_BFREGS_PER_UAR;\n\tindex_of_sys_page = bfregn / bfregs_per_sys_page;\n\n\tif (dyn_bfreg) {\n\t\tindex_of_sys_page += bfregi->num_static_sys_pages;\n\n\t\tif (index_of_sys_page >= bfregi->num_sys_pages)\n\t\t\treturn -EINVAL;\n\n\t\tif (bfregn > bfregi->num_dyn_bfregs ||\n\t\t    bfregi->sys_pages[index_of_sys_page] == MLX5_IB_INVALID_UAR_INDEX) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid dynamic uar index\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\toffset = bfregn % bfregs_per_sys_page / MLX5_NON_FP_BFREGS_PER_UAR;\n\treturn bfregi->sys_pages[index_of_sys_page] + offset;\n}\n\nstatic int mlx5_ib_umem_get(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_pd *pd,\n\t\t\t    unsigned long addr, size_t size,\n\t\t\t    struct ib_umem **umem,\n\t\t\t    int *npages, int *page_shift, int *ncont,\n\t\t\t    u32 *offset)\n{\n\tint err;\n\n\t*umem = ib_umem_get(pd->uobject->context, addr, size, 0, 0);\n\tif (IS_ERR(*umem)) {\n\t\tmlx5_ib_dbg(dev, \"umem_get failed\\n\");\n\t\treturn PTR_ERR(*umem);\n\t}\n\n\tmlx5_ib_cont_pages(*umem, addr, 0, npages, page_shift, ncont, NULL);\n\n\terr = mlx5_ib_get_buf_offset(addr, *page_shift, offset);\n\tif (err) {\n\t\tmlx5_ib_warn(dev, \"bad offset\\n\");\n\t\tgoto err_umem;\n\t}\n\n\tmlx5_ib_dbg(dev, \"addr 0x%lx, size %zu, npages %d, page_shift %d, ncont %d, offset %d\\n\",\n\t\t    addr, size, *npages, *page_shift, *ncont, *offset);\n\n\treturn 0;\n\nerr_umem:\n\tib_umem_release(*umem);\n\t*umem = NULL;\n\n\treturn err;\n}\n\nstatic void destroy_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_rwq *rwq)\n{\n\tstruct mlx5_ib_ucontext *context;\n\n\tif (rwq->create_flags & MLX5_IB_WQ_FLAGS_DELAY_DROP)\n\t\tatomic_dec(&dev->delay_drop.rqs_cnt);\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tmlx5_ib_db_unmap_user(context, &rwq->db);\n\tif (rwq->umem)\n\t\tib_umem_release(rwq->umem);\n}\n\nstatic int create_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t  struct mlx5_ib_rwq *rwq,\n\t\t\t  struct mlx5_ib_create_wq *ucmd)\n{\n\tstruct mlx5_ib_ucontext *context;\n\tint page_shift = 0;\n\tint npages;\n\tu32 offset = 0;\n\tint ncont = 0;\n\tint err;\n\n\tif (!ucmd->buf_addr)\n\t\treturn -EINVAL;\n\n\tcontext = to_mucontext(pd->uobject->context);\n\trwq->umem = ib_umem_get(pd->uobject->context, ucmd->buf_addr,\n\t\t\t       rwq->buf_size, 0, 0);\n\tif (IS_ERR(rwq->umem)) {\n\t\tmlx5_ib_dbg(dev, \"umem_get failed\\n\");\n\t\terr = PTR_ERR(rwq->umem);\n\t\treturn err;\n\t}\n\n\tmlx5_ib_cont_pages(rwq->umem, ucmd->buf_addr, 0, &npages, &page_shift,\n\t\t\t   &ncont, NULL);\n\terr = mlx5_ib_get_buf_offset(ucmd->buf_addr, page_shift,\n\t\t\t\t     &rwq->rq_page_offset);\n\tif (err) {\n\t\tmlx5_ib_warn(dev, \"bad offset\\n\");\n\t\tgoto err_umem;\n\t}\n\n\trwq->rq_num_pas = ncont;\n\trwq->page_shift = page_shift;\n\trwq->log_page_size =  page_shift - MLX5_ADAPTER_PAGE_SHIFT;\n\trwq->wq_sig = !!(ucmd->flags & MLX5_WQ_FLAG_SIGNATURE);\n\n\tmlx5_ib_dbg(dev, \"addr 0x%llx, size %zd, npages %d, page_shift %d, ncont %d, offset %d\\n\",\n\t\t    (unsigned long long)ucmd->buf_addr, rwq->buf_size,\n\t\t    npages, page_shift, ncont, offset);\n\n\terr = mlx5_ib_db_map_user(context, ucmd->db_addr, &rwq->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"map failed\\n\");\n\t\tgoto err_umem;\n\t}\n\n\trwq->create_type = MLX5_WQ_USER;\n\treturn 0;\n\nerr_umem:\n\tib_umem_release(rwq->umem);\n\treturn err;\n}\n\nstatic int adjust_bfregn(struct mlx5_ib_dev *dev,\n\t\t\t struct mlx5_bfreg_info *bfregi, int bfregn)\n{\n\treturn bfregn / MLX5_NON_FP_BFREGS_PER_UAR * MLX5_BFREGS_PER_UAR +\n\t\t\t\tbfregn % MLX5_NON_FP_BFREGS_PER_UAR;\n}\n\nstatic int create_user_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t  struct mlx5_ib_qp *qp, struct ib_udata *udata,\n\t\t\t  struct ib_qp_init_attr *attr,\n\t\t\t  u32 **in,\n\t\t\t  struct mlx5_ib_create_qp_resp *resp, int *inlen,\n\t\t\t  struct mlx5_ib_qp_base *base)\n{\n\tstruct mlx5_ib_ucontext *context;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_ubuffer *ubuffer = &base->ubuffer;\n\tint page_shift = 0;\n\tint uar_index = 0;\n\tint npages;\n\tu32 offset = 0;\n\tint bfregn;\n\tint ncont = 0;\n\t__be64 *pas;\n\tvoid *qpc;\n\tint err;\n\n\terr = ib_copy_from_udata(&ucmd, udata, sizeof(ucmd));\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn err;\n\t}\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tif (ucmd.flags & MLX5_QP_FLAG_BFREG_INDEX) {\n\t\tuar_index = bfregn_to_uar_index(dev, &context->bfregi,\n\t\t\t\t\t\tucmd.bfreg_index, true);\n\t\tif (uar_index < 0)\n\t\t\treturn uar_index;\n\n\t\tbfregn = MLX5_IB_INVALID_BFREG;\n\t} else if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL) {\n\t\t/*\n\t\t * TBD: should come from the verbs when we have the API\n\t\t */\n\t\t/* In CROSS_CHANNEL CQ and QP must use the same UAR */\n\t\tbfregn = MLX5_CROSS_CHANNEL_BFREG;\n\t}\n\telse {\n\t\tbfregn = alloc_bfreg(dev, &context->bfregi);\n\t\tif (bfregn < 0)\n\t\t\treturn bfregn;\n\t}\n\n\tmlx5_ib_dbg(dev, \"bfregn 0x%x, uar_index 0x%x\\n\", bfregn, uar_index);\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tuar_index = bfregn_to_uar_index(dev, &context->bfregi, bfregn,\n\t\t\t\t\t\tfalse);\n\n\tqp->rq.offset = 0;\n\tqp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);\n\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\n\terr = set_user_buf_size(dev, qp, &ucmd, base, attr);\n\tif (err)\n\t\tgoto err_bfreg;\n\n\tif (ucmd.buf_addr && ubuffer->buf_size) {\n\t\tubuffer->buf_addr = ucmd.buf_addr;\n\t\terr = mlx5_ib_umem_get(dev, pd, ubuffer->buf_addr,\n\t\t\t\t       ubuffer->buf_size,\n\t\t\t\t       &ubuffer->umem, &npages, &page_shift,\n\t\t\t\t       &ncont, &offset);\n\t\tif (err)\n\t\t\tgoto err_bfreg;\n\t} else {\n\t\tubuffer->umem = NULL;\n\t}\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) * ncont;\n\t*in = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_qp_in, *in, pas);\n\tif (ubuffer->umem)\n\t\tmlx5_ib_populate_pas(dev, ubuffer->umem, page_shift, pas, 0);\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, *in, qpc);\n\n\tMLX5_SET(qpc, qpc, log_page_size, page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(qpc, qpc, page_offset, offset);\n\n\tMLX5_SET(qpc, qpc, uar_page, uar_index);\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tresp->bfreg_index = adjust_bfregn(dev, &context->bfregi, bfregn);\n\telse\n\t\tresp->bfreg_index = MLX5_IB_INVALID_BFREG;\n\tqp->bfregn = bfregn;\n\n\terr = mlx5_ib_db_map_user(context, ucmd.db_addr, &qp->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"map failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = ib_copy_to_udata(udata, resp, min(udata->outlen, sizeof(*resp)));\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\tgoto err_unmap;\n\t}\n\tqp->create_type = MLX5_QP_USER;\n\n\treturn 0;\n\nerr_unmap:\n\tmlx5_ib_db_unmap_user(context, &qp->db);\n\nerr_free:\n\tkvfree(*in);\n\nerr_umem:\n\tif (ubuffer->umem)\n\t\tib_umem_release(ubuffer->umem);\n\nerr_bfreg:\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, bfregn);\n\treturn err;\n}\n\nstatic void destroy_qp_user(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_qp *qp, struct mlx5_ib_qp_base *base)\n{\n\tstruct mlx5_ib_ucontext *context;\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tmlx5_ib_db_unmap_user(context, &qp->db);\n\tif (base->ubuffer.umem)\n\t\tib_umem_release(base->ubuffer.umem);\n\n\t/*\n\t * Free only the BFREGs which are handled by the kernel.\n\t * BFREGs of UARs allocated dynamically are handled by user.\n\t */\n\tif (qp->bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, qp->bfregn);\n}\n\nstatic int create_kernel_qp(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    u32 **in, int *inlen,\n\t\t\t    struct mlx5_ib_qp_base *base)\n{\n\tint uar_index;\n\tvoid *qpc;\n\tint err;\n\n\tif (init_attr->create_flags & ~(IB_QP_CREATE_SIGNATURE_EN |\n\t\t\t\t\tIB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK |\n\t\t\t\t\tIB_QP_CREATE_IPOIB_UD_LSO |\n\t\t\t\t\tIB_QP_CREATE_NETIF_QP |\n\t\t\t\t\tmlx5_ib_create_qp_sqpn_qp1()))\n\t\treturn -EINVAL;\n\n\tif (init_attr->qp_type == MLX5_IB_QPT_REG_UMR)\n\t\tqp->bf.bfreg = &dev->fp_bfreg;\n\telse\n\t\tqp->bf.bfreg = &dev->bfreg;\n\n\t/* We need to divide by two since each register is comprised of\n\t * two buffers of identical size, namely odd and even\n\t */\n\tqp->bf.buf_size = (1 << MLX5_CAP_GEN(dev->mdev, log_bf_reg_size)) / 2;\n\tuar_index = qp->bf.bfreg->index;\n\n\terr = calc_sq_size(dev, init_attr, qp);\n\tif (err < 0) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tqp->rq.offset = 0;\n\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\tbase->ubuffer.buf_size = err + (qp->rq.wqe_cnt << qp->rq.wqe_shift);\n\n\terr = mlx5_buf_alloc(dev->mdev, base->ubuffer.buf_size, &qp->buf);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tqp->sq.qend = mlx5_get_send_wqe(qp, qp->sq.wqe_cnt);\n\t*inlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) * qp->buf.npages;\n\t*in = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_buf;\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, *in, qpc);\n\tMLX5_SET(qpc, qpc, uar_page, uar_index);\n\tMLX5_SET(qpc, qpc, log_page_size, qp->buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\n\t/* Set \"fast registration enabled\" for all kernel QPs */\n\tMLX5_SET(qpc, qpc, fre, 1);\n\tMLX5_SET(qpc, qpc, rlky, 1);\n\n\tif (init_attr->create_flags & mlx5_ib_create_qp_sqpn_qp1()) {\n\t\tMLX5_SET(qpc, qpc, deth_sqpn, 1);\n\t\tqp->flags |= MLX5_IB_QP_SQPN_QP1;\n\t}\n\n\tmlx5_fill_page_array(&qp->buf,\n\t\t\t     (__be64 *)MLX5_ADDR_OF(create_qp_in, *in, pas));\n\n\terr = mlx5_db_alloc(dev->mdev, &qp->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\tgoto err_free;\n\t}\n\n\tqp->sq.wrid = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t     sizeof(*qp->sq.wrid), GFP_KERNEL);\n\tqp->sq.wr_data = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\tsizeof(*qp->sq.wr_data), GFP_KERNEL);\n\tqp->rq.wrid = kvmalloc_array(qp->rq.wqe_cnt,\n\t\t\t\t     sizeof(*qp->rq.wrid), GFP_KERNEL);\n\tqp->sq.w_list = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t       sizeof(*qp->sq.w_list), GFP_KERNEL);\n\tqp->sq.wqe_head = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\t sizeof(*qp->sq.wqe_head), GFP_KERNEL);\n\n\tif (!qp->sq.wrid || !qp->sq.wr_data || !qp->rq.wrid ||\n\t    !qp->sq.w_list || !qp->sq.wqe_head) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wrid;\n\t}\n\tqp->create_type = MLX5_QP_KERNEL;\n\n\treturn 0;\n\nerr_wrid:\n\tkvfree(qp->sq.wqe_head);\n\tkvfree(qp->sq.w_list);\n\tkvfree(qp->sq.wrid);\n\tkvfree(qp->sq.wr_data);\n\tkvfree(qp->rq.wrid);\n\tmlx5_db_free(dev->mdev, &qp->db);\n\nerr_free:\n\tkvfree(*in);\n\nerr_buf:\n\tmlx5_buf_free(dev->mdev, &qp->buf);\n\treturn err;\n}\n\nstatic void destroy_qp_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tkvfree(qp->sq.wqe_head);\n\tkvfree(qp->sq.w_list);\n\tkvfree(qp->sq.wrid);\n\tkvfree(qp->sq.wr_data);\n\tkvfree(qp->rq.wrid);\n\tmlx5_db_free(dev->mdev, &qp->db);\n\tmlx5_buf_free(dev->mdev, &qp->buf);\n}\n\nstatic u32 get_rx_type(struct mlx5_ib_qp *qp, struct ib_qp_init_attr *attr)\n{\n\tif (attr->srq || (attr->qp_type == IB_QPT_XRC_TGT) ||\n\t    (attr->qp_type == MLX5_IB_QPT_DCI) ||\n\t    (attr->qp_type == IB_QPT_XRC_INI))\n\t\treturn MLX5_SRQ_RQ;\n\telse if (!qp->has_rq)\n\t\treturn MLX5_ZERO_LEN_RQ;\n\telse\n\t\treturn MLX5_NON_ZERO_RQ;\n}\n\nstatic int is_connected(enum ib_qp_type qp_type)\n{\n\tif (qp_type == IB_QPT_RC || qp_type == IB_QPT_UC)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int create_raw_packet_qp_tis(struct mlx5_ib_dev *dev,\n\t\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t\t    struct mlx5_ib_sq *sq, u32 tdn)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_tis_in)] = {0};\n\tvoid *tisc = MLX5_ADDR_OF(create_tis_in, in, ctx);\n\n\tMLX5_SET(tisc, tisc, transport_domain, tdn);\n\tif (qp->flags & MLX5_IB_QP_UNDERLAY)\n\t\tMLX5_SET(tisc, tisc, underlay_qpn, qp->underlay_qpn);\n\n\treturn mlx5_core_create_tis(dev->mdev, in, sizeof(in), &sq->tisn);\n}\n\nstatic void destroy_raw_packet_qp_tis(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_sq *sq)\n{\n\tmlx5_core_destroy_tis(dev->mdev, sq->tisn);\n}\n\nstatic void destroy_flow_rule_vport_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t       struct mlx5_ib_sq *sq)\n{\n\tif (sq->flow_rule)\n\t\tmlx5_del_flow_rules(sq->flow_rule);\n}\n\nstatic int create_raw_packet_qp_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq, void *qpin,\n\t\t\t\t   struct ib_pd *pd)\n{\n\tstruct mlx5_ib_ubuffer *ubuffer = &sq->ubuffer;\n\t__be64 *pas;\n\tvoid *in;\n\tvoid *sqc;\n\tvoid *qpc = MLX5_ADDR_OF(create_qp_in, qpin, qpc);\n\tvoid *wq;\n\tint inlen;\n\tint err;\n\tint page_shift = 0;\n\tint npages;\n\tint ncont = 0;\n\tu32 offset = 0;\n\n\terr = mlx5_ib_umem_get(dev, pd, ubuffer->buf_addr, ubuffer->buf_size,\n\t\t\t       &sq->ubuffer.umem, &npages, &page_shift,\n\t\t\t       &ncont, &offset);\n\tif (err)\n\t\treturn err;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) + sizeof(u64) * ncont;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\tif (MLX5_CAP_ETH(dev->mdev, multi_pkt_send_wqe))\n\t\tMLX5_SET(sqc, sqc, allow_multi_pkt_send_wqe, 1);\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\tMLX5_SET(sqc, sqc, user_index, MLX5_GET(qpc, qpc, user_index));\n\tMLX5_SET(sqc, sqc, cqn, MLX5_GET(qpc, qpc, cqn_snd));\n\tMLX5_SET(sqc, sqc, tis_lst_sz, 1);\n\tMLX5_SET(sqc, sqc, tis_num_0, sq->tisn);\n\tif (MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t    MLX5_CAP_ETH(dev->mdev, swp))\n\t\tMLX5_SET(sqc, sqc, allow_swp, 1);\n\n\twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tMLX5_SET(wq, wq, pd, MLX5_GET(qpc, qpc, pd));\n\tMLX5_SET(wq, wq, uar_page, MLX5_GET(qpc, qpc, uar_page));\n\tMLX5_SET64(wq, wq, dbr_addr, MLX5_GET64(qpc, qpc, dbr_addr));\n\tMLX5_SET(wq, wq, log_wq_stride, ilog2(MLX5_SEND_WQE_BB));\n\tMLX5_SET(wq, wq, log_wq_sz, MLX5_GET(qpc, qpc, log_sq_size));\n\tMLX5_SET(wq, wq, log_wq_pg_sz,  page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(wq, wq, page_offset, offset);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(dev, sq->ubuffer.umem, page_shift, pas, 0);\n\n\terr = mlx5_core_create_sq_tracked(dev->mdev, in, inlen, &sq->base.mqp);\n\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_umem;\n\n\terr = create_flow_rule_vport_sq(dev, sq);\n\tif (err)\n\t\tgoto err_flow;\n\n\treturn 0;\n\nerr_flow:\n\tmlx5_core_destroy_sq_tracked(dev->mdev, &sq->base.mqp);\n\nerr_umem:\n\tib_umem_release(sq->ubuffer.umem);\n\tsq->ubuffer.umem = NULL;\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_sq *sq)\n{\n\tdestroy_flow_rule_vport_sq(dev, sq);\n\tmlx5_core_destroy_sq_tracked(dev->mdev, &sq->base.mqp);\n\tib_umem_release(sq->ubuffer.umem);\n}\n\nstatic size_t get_rq_pas_size(void *qpc)\n{\n\tu32 log_page_size = MLX5_GET(qpc, qpc, log_page_size) + 12;\n\tu32 log_rq_stride = MLX5_GET(qpc, qpc, log_rq_stride);\n\tu32 log_rq_size   = MLX5_GET(qpc, qpc, log_rq_size);\n\tu32 page_offset   = MLX5_GET(qpc, qpc, page_offset);\n\tu32 po_quanta\t  = 1 << (log_page_size - 6);\n\tu32 rq_sz\t  = 1 << (log_rq_size + 4 + log_rq_stride);\n\tu32 page_size\t  = 1 << log_page_size;\n\tu32 rq_sz_po      = rq_sz + (page_offset * po_quanta);\n\tu32 rq_num_pas\t  = (rq_sz_po + page_size - 1) / page_size;\n\n\treturn rq_num_pas * sizeof(u64);\n}\n\nstatic int create_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_rq *rq, void *qpin,\n\t\t\t\t   size_t qpinlen)\n{\n\tstruct mlx5_ib_qp *mqp = rq->base.container_mibqp;\n\t__be64 *pas;\n\t__be64 *qp_pas;\n\tvoid *in;\n\tvoid *rqc;\n\tvoid *wq;\n\tvoid *qpc = MLX5_ADDR_OF(create_qp_in, qpin, qpc);\n\tsize_t rq_pas_size = get_rq_pas_size(qpc);\n\tsize_t inlen;\n\tint err;\n\n\tif (qpinlen < rq_pas_size + MLX5_BYTE_OFF(create_qp_in, pas))\n\t\treturn -EINVAL;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rq_in) + rq_pas_size;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(create_rq_in, in, ctx);\n\tif (!(rq->flags & MLX5_IB_RQ_CVLAN_STRIPPING))\n\t\tMLX5_SET(rqc, rqc, vsd, 1);\n\tMLX5_SET(rqc, rqc, mem_rq_type, MLX5_RQC_MEM_RQ_TYPE_MEMORY_RQ_INLINE);\n\tMLX5_SET(rqc, rqc, state, MLX5_RQC_STATE_RST);\n\tMLX5_SET(rqc, rqc, flush_in_error_en, 1);\n\tMLX5_SET(rqc, rqc, user_index, MLX5_GET(qpc, qpc, user_index));\n\tMLX5_SET(rqc, rqc, cqn, MLX5_GET(qpc, qpc, cqn_rcv));\n\n\tif (mqp->flags & MLX5_IB_QP_CAP_SCATTER_FCS)\n\t\tMLX5_SET(rqc, rqc, scatter_fcs, 1);\n\n\twq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tif (rq->flags & MLX5_IB_RQ_PCI_WRITE_END_PADDING)\n\t\tMLX5_SET(wq, wq, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN);\n\tMLX5_SET(wq, wq, page_offset, MLX5_GET(qpc, qpc, page_offset));\n\tMLX5_SET(wq, wq, pd, MLX5_GET(qpc, qpc, pd));\n\tMLX5_SET64(wq, wq, dbr_addr, MLX5_GET64(qpc, qpc, dbr_addr));\n\tMLX5_SET(wq, wq, log_wq_stride, MLX5_GET(qpc, qpc, log_rq_stride) + 4);\n\tMLX5_SET(wq, wq, log_wq_pg_sz, MLX5_GET(qpc, qpc, log_page_size));\n\tMLX5_SET(wq, wq, log_wq_sz, MLX5_GET(qpc, qpc, log_rq_size));\n\n\tpas = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tqp_pas = (__be64 *)MLX5_ADDR_OF(create_qp_in, qpin, pas);\n\tmemcpy(pas, qp_pas, rq_pas_size);\n\n\terr = mlx5_core_create_rq_tracked(dev->mdev, in, inlen, &rq->base.mqp);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_rq *rq)\n{\n\tmlx5_core_destroy_rq_tracked(dev->mdev, &rq->base.mqp);\n}\n\nstatic bool tunnel_offload_supported(struct mlx5_core_dev *dev)\n{\n\treturn  (MLX5_CAP_ETH(dev, tunnel_stateless_vxlan) ||\n\t\t MLX5_CAP_ETH(dev, tunnel_stateless_gre) ||\n\t\t MLX5_CAP_ETH(dev, tunnel_stateless_geneve_rx));\n}\n\nstatic int create_raw_packet_qp_tir(struct mlx5_ib_dev *dev,\n\t\t\t\t    struct mlx5_ib_rq *rq, u32 tdn,\n\t\t\t\t    bool tunnel_offload_en)\n{\n\tu32 *in;\n\tvoid *tirc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_tir_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\ttirc = MLX5_ADDR_OF(create_tir_in, in, ctx);\n\tMLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_DIRECT);\n\tMLX5_SET(tirc, tirc, inline_rqn, rq->base.mqp.qpn);\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\tif (tunnel_offload_en)\n\t\tMLX5_SET(tirc, tirc, tunneled_offload_en, 1);\n\n\tif (dev->rep)\n\t\tMLX5_SET(tirc, tirc, self_lb_block,\n\t\t\t MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST_);\n\n\terr = mlx5_core_create_tir(dev->mdev, in, inlen, &rq->tirn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_tir(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_rq *rq)\n{\n\tmlx5_core_destroy_tir(dev->mdev, rq->tirn);\n}\n\nstatic int create_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tu32 *in, size_t inlen,\n\t\t\t\tstruct ib_pd *pd)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct ib_uobject *uobj = pd->uobject;\n\tstruct ib_ucontext *ucontext = uobj->context;\n\tstruct mlx5_ib_ucontext *mucontext = to_mucontext(ucontext);\n\tint err;\n\tu32 tdn = mucontext->tdn;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = create_raw_packet_qp_tis(dev, qp, sq, tdn);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = create_raw_packet_qp_sq(dev, sq, in, pd);\n\t\tif (err)\n\t\t\tgoto err_destroy_tis;\n\n\t\tsq->base.container_mibqp = qp;\n\t\tsq->base.mqp.event = mlx5_ib_qp_event;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\trq->base.container_mibqp = qp;\n\n\t\tif (qp->flags & MLX5_IB_QP_CVLAN_STRIPPING)\n\t\t\trq->flags |= MLX5_IB_RQ_CVLAN_STRIPPING;\n\t\tif (qp->flags & MLX5_IB_QP_PCI_WRITE_END_PADDING)\n\t\t\trq->flags |= MLX5_IB_RQ_PCI_WRITE_END_PADDING;\n\t\terr = create_raw_packet_qp_rq(dev, rq, in, inlen);\n\t\tif (err)\n\t\t\tgoto err_destroy_sq;\n\n\n\t\terr = create_raw_packet_qp_tir(dev, rq, tdn,\n\t\t\t\t\t       qp->tunnel_offload_en);\n\t\tif (err)\n\t\t\tgoto err_destroy_rq;\n\t}\n\n\tqp->trans_qp.base.mqp.qpn = qp->sq.wqe_cnt ? sq->base.mqp.qpn :\n\t\t\t\t\t\t     rq->base.mqp.qpn;\n\n\treturn 0;\n\nerr_destroy_rq:\n\tdestroy_raw_packet_qp_rq(dev, rq);\nerr_destroy_sq:\n\tif (!qp->sq.wqe_cnt)\n\t\treturn err;\n\tdestroy_raw_packet_qp_sq(dev, sq);\nerr_destroy_tis:\n\tdestroy_raw_packet_qp_tis(dev, sq);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\n\tif (qp->rq.wqe_cnt) {\n\t\tdestroy_raw_packet_qp_tir(dev, rq);\n\t\tdestroy_raw_packet_qp_rq(dev, rq);\n\t}\n\n\tif (qp->sq.wqe_cnt) {\n\t\tdestroy_raw_packet_qp_sq(dev, sq);\n\t\tdestroy_raw_packet_qp_tis(dev, sq);\n\t}\n}\n\nstatic void raw_packet_qp_copy_info(struct mlx5_ib_qp *qp,\n\t\t\t\t    struct mlx5_ib_raw_packet_qp *raw_packet_qp)\n{\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\n\tsq->sq = &qp->sq;\n\trq->rq = &qp->rq;\n\tsq->doorbell = &qp->db;\n\trq->doorbell = &qp->db;\n}\n\nstatic void destroy_rss_raw_qp_tir(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tmlx5_core_destroy_tir(dev->mdev, qp->rss_qp.tirn);\n}\n\nstatic int create_rss_raw_qp_tir(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\t struct ib_pd *pd,\n\t\t\t\t struct ib_qp_init_attr *init_attr,\n\t\t\t\t struct ib_udata *udata)\n{\n\tstruct ib_uobject *uobj = pd->uobject;\n\tstruct ib_ucontext *ucontext = uobj->context;\n\tstruct mlx5_ib_ucontext *mucontext = to_mucontext(ucontext);\n\tstruct mlx5_ib_create_qp_resp resp = {};\n\tint inlen;\n\tint err;\n\tu32 *in;\n\tvoid *tirc;\n\tvoid *hfso;\n\tu32 selected_fields = 0;\n\tu32 outer_l4;\n\tsize_t min_resp_len;\n\tu32 tdn = mucontext->tdn;\n\tstruct mlx5_ib_create_qp_rss ucmd = {};\n\tsize_t required_cmd_sz;\n\n\tif (init_attr->qp_type != IB_QPT_RAW_PACKET)\n\t\treturn -EOPNOTSUPP;\n\n\tif (init_attr->create_flags || init_attr->send_cq)\n\t\treturn -EINVAL;\n\n\tmin_resp_len = offsetof(typeof(resp), bfreg_index) + sizeof(resp.bfreg_index);\n\tif (udata->outlen < min_resp_len)\n\t\treturn -EINVAL;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), flags) + sizeof(ucmd.flags);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tmlx5_ib_dbg(dev, \"invalid inlen\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tmlx5_ib_dbg(dev, \"inlen is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen))) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ucmd.comp_mask) {\n\t\tmlx5_ib_dbg(dev, \"invalid comp mask\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd.flags & ~MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\tmlx5_ib_dbg(dev, \"invalid flags\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS &&\n\t    !tunnel_offload_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"tunnel offloads isn't supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_INNER &&\n\t    !(ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS)) {\n\t\tmlx5_ib_dbg(dev, \"Tunnel offloads must be set for inner RSS\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = ib_copy_to_udata(udata, &resp, min(udata->outlen, sizeof(resp)));\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_tir_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\ttirc = MLX5_ADDR_OF(create_tir_in, in, ctx);\n\tMLX5_SET(tirc, tirc, disp_type,\n\t\t MLX5_TIRC_DISP_TYPE_INDIRECT);\n\tMLX5_SET(tirc, tirc, indirect_table,\n\t\t init_attr->rwq_ind_tbl->ind_tbl_num);\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\n\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\n\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS)\n\t\tMLX5_SET(tirc, tirc, tunneled_offload_en, 1);\n\n\tif (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_INNER)\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner);\n\telse\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\n\tswitch (ucmd.rx_hash_function) {\n\tcase MLX5_RX_HASH_FUNC_TOEPLITZ:\n\t{\n\t\tvoid *rss_key = MLX5_ADDR_OF(tirc, tirc, rx_hash_toeplitz_key);\n\t\tsize_t len = MLX5_FLD_SZ_BYTES(tirc, rx_hash_toeplitz_key);\n\n\t\tif (len != ucmd.rx_key_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tMLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_TOEPLITZ);\n\t\tMLX5_SET(tirc, tirc, rx_hash_symmetric, 1);\n\t\tmemcpy(rss_key, ucmd.rx_hash_key, len);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (!ucmd.rx_hash_fields_mask) {\n\t\t/* special case when this TIR serves as steering entry without hashing */\n\t\tif (!init_attr->rwq_ind_tbl->log_ind_tbl_size)\n\t\t\tgoto create_tir;\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t     (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4)) &&\n\t     ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6) ||\n\t     (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* If none of IPV4 & IPV6 SRC/DST was set - this bit field is ignored */\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type,\n\t\t\t MLX5_L3_PROT_TYPE_IPV4);\n\telse if ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6) ||\n\t\t (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type,\n\t\t\t MLX5_L3_PROT_TYPE_IPV6);\n\n\touter_l4 = ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP)) << 0 |\n\t\t   ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP) ||\n\t\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP)) << 1 |\n\t\t   (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_IPSEC_SPI) << 2;\n\n\t/* Check that only one l4 protocol is set */\n\tif (outer_l4 & (outer_l4 - 1)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* If none of TCP & UDP SRC/DST was set - this bit field is ignored */\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type,\n\t\t\t MLX5_L4_PROT_TYPE_TCP);\n\telse if ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP) ||\n\t\t (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type,\n\t\t\t MLX5_L4_PROT_TYPE_UDP);\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_SRC_IP;\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_DST_IP;\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_L4_SPORT;\n\n\tif ((ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP) ||\n\t    (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_L4_DPORT;\n\n\tif (ucmd.rx_hash_fields_mask & MLX5_RX_HASH_IPSEC_SPI)\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_IPSEC_SPI;\n\n\tMLX5_SET(rx_hash_field_select, hfso, selected_fields, selected_fields);\n\ncreate_tir:\n\tif (dev->rep)\n\t\tMLX5_SET(tirc, tirc, self_lb_block,\n\t\t\t MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST_);\n\n\terr = mlx5_core_create_tir(dev->mdev, in, inlen, &qp->rss_qp.tirn);\n\n\tif (err)\n\t\tgoto err;\n\n\tkvfree(in);\n\t/* qpn is reserved for that QP */\n\tqp->trans_qp.base.mqp.qpn = 0;\n\tqp->flags |= MLX5_IB_QP_RSS;\n\treturn 0;\n\nerr:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_create_qp_resp resp = {};\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tstruct mlx5_ib_create_qp ucmd;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tmutex_init(&qp->mutex);\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(init_attr->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->rwq_ind_tbl) {\n\t\tif (!udata)\n\t\t\treturn -ENOSYS;\n\n\t\terr = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);\n\t\treturn err;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {\n\t\tif (!MLX5_CAP_GEN(mdev, block_lb_mc)) {\n\t\t\tmlx5_ib_dbg(dev, \"block multicast loopback isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\t\t}\n\t}\n\n\tif (init_attr->create_flags &\n\t\t\t(IB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t IB_QP_CREATE_MANAGED_SEND |\n\t\t\t IB_QP_CREATE_MANAGED_RECV)) {\n\t\tif (!MLX5_CAP_GEN(mdev, cd)) {\n\t\t\tmlx5_ib_dbg(dev, \"cross-channel isn't supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\tqp->flags |= MLX5_IB_QP_CROSS_CHANNEL;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_SEND;\n\t\tif (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)\n\t\t\tqp->flags |= MLX5_IB_QP_MANAGED_RECV;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))\n\t\tif (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {\n\t\t\tmlx5_ib_dbg(dev, \"ipoib UD lso qp isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is supported only for Raw Packet QPs\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||\n\t\t    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS isn't supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tqp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;\n\t}\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {\n\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||\n\t\t    (init_attr->qp_type != IB_QPT_RAW_PACKET))\n\t\t\treturn -EOPNOTSUPP;\n\t\tqp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;\n\t}\n\n\tif (pd && pd->uobject) {\n\t\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\t\t&ucmd, udata->inlen, &uidx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);\n\t\tqp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);\n\t\tif (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {\n\t\t\tif (init_attr->qp_type != IB_QPT_RAW_PACKET ||\n\t\t\t    !tunnel_offload_supported(mdev)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Tunnel offload isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tqp->tunnel_offload_en = true;\n\t\t}\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\t\tif (init_attr->qp_type != IB_QPT_UD ||\n\t\t\t    (MLX5_CAP_GEN(dev->mdev, port_type) !=\n\t\t\t     MLX5_CAP_PORT_TYPE_IB) ||\n\t\t\t    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Source QP option isn't supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX5_IB_QP_UNDERLAY;\n\t\t\tqp->underlay_qpn = init_attr->source_qpn;\n\t\t}\n\t} else {\n\t\tqp->wq_sig = !!wq_signature;\n\t}\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq,\n\t\t\t  qp, (pd && pd->uobject) ? &ucmd : NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (pd) {\n\t\tif (pd->uobject) {\n\t\t\t__u32 max_wqes =\n\t\t\t\t1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);\n\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d)\\n\", ucmd.sq_wqe_count);\n\t\t\tif (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||\n\t\t\t    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {\n\t\t\t\tmlx5_ib_dbg(dev, \"invalid rq params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ucmd.sq_wqe_count > max_wqes) {\n\t\t\t\tmlx5_ib_dbg(dev, \"requested sq_wqe_count (%d) > max allowed (%d)\\n\",\n\t\t\t\t\t    ucmd.sq_wqe_count, max_wqes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (init_attr->create_flags &\n\t\t\t    mlx5_ib_create_qp_sqpn_qp1()) {\n\t\t\t\tmlx5_ib_dbg(dev, \"user-space is not allowed to create UD QPs spoofing as QP1\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = create_user_qp(dev, pd, qp, udata, init_attr, &in,\n\t\t\t\t\t     &resp, &inlen, base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t} else {\n\t\t\terr = create_kernel_qp(dev, init_attr, qp, &in, &inlen,\n\t\t\t\t\t       base);\n\t\t\tif (err)\n\t\t\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tin = kvzalloc(inlen, GFP_KERNEL);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->create_type = MLX5_QP_EMPTY;\n\t}\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->wq_sig)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tif (qp->scat_cqe && is_connected(init_attr->qp_type)) {\n\t\tint rcqe_sz;\n\t\tint scqe_sz;\n\n\t\trcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);\n\t\tscqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t\telse\n\t\t\tMLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);\n\n\t\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {\n\t\t\tif (scqe_sz == 128)\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\t\telse\n\t\t\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n\t\t}\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t/* Set default resources */\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t/* 0xffffff means we ask to work with cqe version 0 */\n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */\n\tif (init_attr->qp_type == IB_QPT_UD &&\n\t    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\t\tqp->flags |= MLX5_IB_QP_LSO;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t} else {\n\t\t\tqp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;\n\t\t}\n\t}\n\n\tif (inlen < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd);\n\t} else {\n\t\terr = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);\n\t}\n\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"create qp failed\\n\");\n\t\tgoto err_create;\n\t}\n\n\tkvfree(in);\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* Maintain device to QPs access, needed for further handling via reset\n\t * flow\n\t */\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t/* Maintain CQ to QPs access, needed for further handling via reset flow\n\t */\n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tif (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, pd, qp, base);\n\telse if (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\nerr:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq)\n\t__acquires(&send_cq->lock) __acquires(&recv_cq->lock)\n{\n\tif (send_cq) {\n\t\tif (recv_cq) {\n\t\t\tif (send_cq->mcq.cqn < recv_cq->mcq.cqn)  {\n\t\t\t\tspin_lock(&send_cq->lock);\n\t\t\t\tspin_lock_nested(&recv_cq->lock,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\t\t} else if (send_cq->mcq.cqn == recv_cq->mcq.cqn) {\n\t\t\t\tspin_lock(&send_cq->lock);\n\t\t\t\t__acquire(&recv_cq->lock);\n\t\t\t} else {\n\t\t\t\tspin_lock(&recv_cq->lock);\n\t\t\t\tspin_lock_nested(&send_cq->lock,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&send_cq->lock);\n\t\t\t__acquire(&recv_cq->lock);\n\t\t}\n\t} else if (recv_cq) {\n\t\tspin_lock(&recv_cq->lock);\n\t\t__acquire(&send_cq->lock);\n\t} else {\n\t\t__acquire(&send_cq->lock);\n\t\t__acquire(&recv_cq->lock);\n\t}\n}\n\nstatic void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq)\n\t__releases(&send_cq->lock) __releases(&recv_cq->lock)\n{\n\tif (send_cq) {\n\t\tif (recv_cq) {\n\t\t\tif (send_cq->mcq.cqn < recv_cq->mcq.cqn)  {\n\t\t\t\tspin_unlock(&recv_cq->lock);\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t} else if (send_cq->mcq.cqn == recv_cq->mcq.cqn) {\n\t\t\t\t__release(&recv_cq->lock);\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t\tspin_unlock(&recv_cq->lock);\n\t\t\t}\n\t\t} else {\n\t\t\t__release(&recv_cq->lock);\n\t\t\tspin_unlock(&send_cq->lock);\n\t\t}\n\t} else if (recv_cq) {\n\t\t__release(&send_cq->lock);\n\t\tspin_unlock(&recv_cq->lock);\n\t} else {\n\t\t__release(&recv_cq->lock);\n\t\t__release(&send_cq->lock);\n\t}\n}\n\nstatic struct mlx5_ib_pd *get_pd(struct mlx5_ib_qp *qp)\n{\n\treturn to_mpd(qp->ibqp.pd);\n}\n\nstatic void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq)\n{\n\tswitch (qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\tcase MLX5_IB_QPT_REG_UMR:\n\tcase IB_QPT_XRC_INI:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_RAW_IPV6:\n\tcase IB_QPT_RAW_ETHERTYPE:\n\tcase IB_QPT_RAW_PACKET:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = ib_recv_cq ? to_mcq(ib_recv_cq) : NULL;\n\t\tbreak;\n\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct mlx5_modify_raw_qp_param *raw_qp_param,\n\t\t\t\tu8 lag_tx_affinity);\n\nstatic void destroy_qp_common(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_cq *send_cq, *recv_cq;\n\tstruct mlx5_ib_qp_base *base;\n\tunsigned long flags;\n\tint err;\n\n\tif (qp->ibqp.rwq_ind_tbl) {\n\t\tdestroy_rss_raw_qp_tir(dev, qp);\n\t\treturn;\n\t}\n\n\tbase = (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & MLX5_IB_QP_UNDERLAY) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tif (qp->state != IB_QPS_RESET) {\n\t\tif (qp->ibqp.qp_type != IB_QPT_RAW_PACKET &&\n\t\t    !(qp->flags & MLX5_IB_QP_UNDERLAY)) {\n\t\t\terr = mlx5_core_qp_modify(dev->mdev,\n\t\t\t\t\t\t  MLX5_CMD_OP_2RST_QP, 0,\n\t\t\t\t\t\t  NULL, &base->mqp);\n\t\t} else {\n\t\t\tstruct mlx5_modify_raw_qp_param raw_qp_param = {\n\t\t\t\t.operation = MLX5_CMD_OP_2RST_QP\n\t\t\t};\n\n\t\t\terr = modify_raw_packet_qp(dev, qp, &raw_qp_param, 0);\n\t\t}\n\t\tif (err)\n\t\t\tmlx5_ib_warn(dev, \"mlx5_ib: modify QP 0x%06x to RESET failed\\n\",\n\t\t\t\t     base->mqp.qpn);\n\t}\n\n\tget_cqs(qp->ibqp.qp_type, qp->ibqp.send_cq, qp->ibqp.recv_cq,\n\t\t&send_cq, &recv_cq);\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t/* del from lists under both locks above to protect reset flow paths */\n\tlist_del(&qp->qps_list);\n\tif (send_cq)\n\t\tlist_del(&qp->cq_send_list);\n\n\tif (recv_cq)\n\t\tlist_del(&qp->cq_recv_list);\n\n\tif (qp->create_type == MLX5_QP_KERNEL) {\n\t\t__mlx5_ib_cq_clean(recv_cq, base->mqp.qpn,\n\t\t\t\t   qp->ibqp.srq ? to_msrq(qp->ibqp.srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\t__mlx5_ib_cq_clean(send_cq, base->mqp.qpn,\n\t\t\t\t\t   NULL);\n\t}\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\tif (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tdestroy_raw_packet_qp(dev, qp);\n\t} else {\n\t\terr = mlx5_core_destroy_qp(dev->mdev, &base->mqp);\n\t\tif (err)\n\t\t\tmlx5_ib_warn(dev, \"failed to destroy QP 0x%x\\n\",\n\t\t\t\t     base->mqp.qpn);\n\t}\n\n\tif (qp->create_type == MLX5_QP_KERNEL)\n\t\tdestroy_qp_kernel(dev, qp);\n\telse if (qp->create_type == MLX5_QP_USER)\n\t\tdestroy_qp_user(dev, &get_pd(qp)->ibpd, qp, base);\n}\n\nstatic const char *ib_qp_type_str(enum ib_qp_type type)\n{\n\tswitch (type) {\n\tcase IB_QPT_SMI:\n\t\treturn \"IB_QPT_SMI\";\n\tcase IB_QPT_GSI:\n\t\treturn \"IB_QPT_GSI\";\n\tcase IB_QPT_RC:\n\t\treturn \"IB_QPT_RC\";\n\tcase IB_QPT_UC:\n\t\treturn \"IB_QPT_UC\";\n\tcase IB_QPT_UD:\n\t\treturn \"IB_QPT_UD\";\n\tcase IB_QPT_RAW_IPV6:\n\t\treturn \"IB_QPT_RAW_IPV6\";\n\tcase IB_QPT_RAW_ETHERTYPE:\n\t\treturn \"IB_QPT_RAW_ETHERTYPE\";\n\tcase IB_QPT_XRC_INI:\n\t\treturn \"IB_QPT_XRC_INI\";\n\tcase IB_QPT_XRC_TGT:\n\t\treturn \"IB_QPT_XRC_TGT\";\n\tcase IB_QPT_RAW_PACKET:\n\t\treturn \"IB_QPT_RAW_PACKET\";\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\treturn \"MLX5_IB_QPT_REG_UMR\";\n\tcase IB_QPT_DRIVER:\n\t\treturn \"IB_QPT_DRIVER\";\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\treturn \"Invalid QP type\";\n\t}\n}\n\nstatic struct ib_qp *mlx5_ib_create_dct(struct ib_pd *pd,\n\t\t\t\t\tstruct ib_qp_init_attr *attr,\n\t\t\t\t\tstruct mlx5_ib_create_qp *ucmd)\n{\n\tstruct mlx5_ib_qp *qp;\n\tint err = 0;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tvoid *dctc;\n\n\tif (!attr->srq || !attr->recv_cq)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\tucmd, sizeof(*ucmd), &uidx);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);\n\tif (!qp->dct.in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tqp->qp_sub_type = MLX5_IB_QPT_DCT;\n\tMLX5_SET(dctc, dctc, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(dctc, dctc, srqn_xrqn, to_msrq(attr->srq)->msrq.srqn);\n\tMLX5_SET(dctc, dctc, cqn, to_mcq(attr->recv_cq)->mcq.cqn);\n\tMLX5_SET64(dctc, dctc, dc_access_key, ucmd->access_key);\n\tMLX5_SET(dctc, dctc, user_index, uidx);\n\n\tqp->state = IB_QPS_RESET;\n\n\treturn &qp->ibqp;\nerr_free:\n\tkfree(qp);\n\treturn ERR_PTR(err);\n}\n\nstatic int set_mlx_qp_type(struct mlx5_ib_dev *dev,\n\t\t\t   struct ib_qp_init_attr *init_attr,\n\t\t\t   struct mlx5_ib_create_qp *ucmd,\n\t\t\t   struct ib_udata *udata)\n{\n\tenum { MLX_QP_FLAGS = MLX5_QP_FLAG_TYPE_DCT | MLX5_QP_FLAG_TYPE_DCI };\n\tint err;\n\n\tif (!udata)\n\t\treturn -EINVAL;\n\n\tif (udata->inlen < sizeof(*ucmd)) {\n\t\tmlx5_ib_dbg(dev, \"create_qp user command is smaller than expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr = ib_copy_from_udata(ucmd, udata, sizeof(*ucmd));\n\tif (err)\n\t\treturn err;\n\n\tif ((ucmd->flags & MLX_QP_FLAGS) == MLX5_QP_FLAG_TYPE_DCI) {\n\t\tinit_attr->qp_type = MLX5_IB_QPT_DCI;\n\t} else {\n\t\tif ((ucmd->flags & MLX_QP_FLAGS) == MLX5_QP_FLAG_TYPE_DCT) {\n\t\t\tinit_attr->qp_type = MLX5_IB_QPT_DCT;\n\t\t} else {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid QP flags\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!MLX5_CAP_GEN(dev->mdev, dct)) {\n\t\tmlx5_ib_dbg(dev, \"DC transport is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstruct ib_qp *mlx5_ib_create_qp(struct ib_pd *pd,\n\t\t\t\tstruct ib_qp_init_attr *verbs_init_attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev;\n\tstruct mlx5_ib_qp *qp;\n\tu16 xrcdn = 0;\n\tint err;\n\tstruct ib_qp_init_attr mlx_init_attr;\n\tstruct ib_qp_init_attr *init_attr = verbs_init_attr;\n\n\tif (pd) {\n\t\tdev = to_mdev(pd->device);\n\n\t\tif (init_attr->qp_type == IB_QPT_RAW_PACKET) {\n\t\t\tif (!pd->uobject) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Raw Packet QP is not supported for kernel consumers\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t} else if (!to_mucontext(pd->uobject->context)->cqe_version) {\n\t\t\t\tmlx5_ib_dbg(dev, \"Raw Packet QP is only supported for CQE version > 0\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* being cautious here */\n\t\tif (init_attr->qp_type != IB_QPT_XRC_TGT &&\n\t\t    init_attr->qp_type != MLX5_IB_QPT_REG_UMR) {\n\t\t\tpr_warn(\"%s: no PD for transport %s\\n\", __func__,\n\t\t\t\tib_qp_type_str(init_attr->qp_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdev = to_mdev(to_mxrcd(init_attr->xrcd)->ibxrcd.device);\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_DRIVER) {\n\t\tstruct mlx5_ib_create_qp ucmd;\n\n\t\tinit_attr = &mlx_init_attr;\n\t\tmemcpy(init_attr, verbs_init_attr, sizeof(*verbs_init_attr));\n\t\terr = set_mlx_qp_type(dev, init_attr, &ucmd, udata);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tif (init_attr->qp_type == MLX5_IB_QPT_DCI) {\n\t\t\tif (init_attr->cap.max_recv_wr ||\n\t\t\t    init_attr->cap.max_recv_sge) {\n\t\t\t\tmlx5_ib_dbg(dev, \"DCI QP requires zero size receive queue\\n\");\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t} else {\n\t\t\treturn mlx5_ib_create_dct(pd, init_attr, &ucmd);\n\t\t}\n\t}\n\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\tcase IB_QPT_XRC_INI:\n\t\tif (!MLX5_CAP_GEN(dev->mdev, xrc)) {\n\t\t\tmlx5_ib_dbg(dev, \"XRC not supported\\n\");\n\t\t\treturn ERR_PTR(-ENOSYS);\n\t\t}\n\t\tinit_attr->recv_cq = NULL;\n\t\tif (init_attr->qp_type == IB_QPT_XRC_TGT) {\n\t\t\txrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;\n\t\t\tinit_attr->send_cq = NULL;\n\t\t}\n\n\t\t/* fall through */\n\tcase IB_QPT_RAW_PACKET:\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase MLX5_IB_QPT_REG_UMR:\n\tcase MLX5_IB_QPT_DCI:\n\t\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\t\tif (!qp)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = create_qp_common(dev, pd, init_attr, udata, qp);\n\t\tif (err) {\n\t\t\tmlx5_ib_dbg(dev, \"create_qp_common failed\\n\");\n\t\t\tkfree(qp);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tif (is_qp0(init_attr->qp_type))\n\t\t\tqp->ibqp.qp_num = 0;\n\t\telse if (is_qp1(init_attr->qp_type))\n\t\t\tqp->ibqp.qp_num = 1;\n\t\telse\n\t\t\tqp->ibqp.qp_num = qp->trans_qp.base.mqp.qpn;\n\n\t\tmlx5_ib_dbg(dev, \"ib qpnum 0x%x, mlx qpn 0x%x, rcqn 0x%x, scqn 0x%x\\n\",\n\t\t\t    qp->ibqp.qp_num, qp->trans_qp.base.mqp.qpn,\n\t\t\t    init_attr->recv_cq ? to_mcq(init_attr->recv_cq)->mcq.cqn : -1,\n\t\t\t    init_attr->send_cq ? to_mcq(init_attr->send_cq)->mcq.cqn : -1);\n\n\t\tqp->trans_qp.xrcdn = xrcdn;\n\n\t\tbreak;\n\n\tcase IB_QPT_GSI:\n\t\treturn mlx5_ib_gsi_create_qp(pd, init_attr);\n\n\tcase IB_QPT_RAW_IPV6:\n\tcase IB_QPT_RAW_ETHERTYPE:\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\tmlx5_ib_dbg(dev, \"unsupported qp type %d\\n\",\n\t\t\t    init_attr->qp_type);\n\t\t/* Don't support raw QPs */\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (verbs_init_attr->qp_type == IB_QPT_DRIVER)\n\t\tqp->qp_sub_type = init_attr->qp_type;\n\n\treturn &qp->ibqp;\n}\n\nstatic int mlx5_ib_destroy_dct(struct mlx5_ib_qp *mqp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(mqp->ibqp.device);\n\n\tif (mqp->state == IB_QPS_RTR) {\n\t\tint err;\n\n\t\terr = mlx5_core_destroy_dct(dev->mdev, &mqp->dct.mdct);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"failed to destroy DCT %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tkfree(mqp->dct.in);\n\tkfree(mqp);\n\treturn 0;\n}\n\nint mlx5_ib_destroy_qp(struct ib_qp *qp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\n\tif (unlikely(qp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_destroy_qp(qp);\n\n\tif (mqp->qp_sub_type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_destroy_dct(mqp);\n\n\tdestroy_qp_common(dev, mqp);\n\n\tkfree(mqp);\n\n\treturn 0;\n}\n\nstatic __be32 to_mlx5_access_flags(struct mlx5_ib_qp *qp, const struct ib_qp_attr *attr,\n\t\t\t\t   int attr_mask)\n{\n\tu32 hw_access_flags = 0;\n\tu8 dest_rd_atomic;\n\tu32 access_flags;\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tdest_rd_atomic = attr->max_dest_rd_atomic;\n\telse\n\t\tdest_rd_atomic = qp->trans_qp.resp_depth;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\taccess_flags = attr->qp_access_flags;\n\telse\n\t\taccess_flags = qp->trans_qp.atomic_rd_en;\n\n\tif (!dest_rd_atomic)\n\t\taccess_flags &= IB_ACCESS_REMOTE_WRITE;\n\n\tif (access_flags & IB_ACCESS_REMOTE_READ)\n\t\thw_access_flags |= MLX5_QP_BIT_RRE;\n\tif (access_flags & IB_ACCESS_REMOTE_ATOMIC)\n\t\thw_access_flags |= (MLX5_QP_BIT_RAE | MLX5_ATOMIC_MODE_CX);\n\tif (access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\thw_access_flags |= MLX5_QP_BIT_RWE;\n\n\treturn cpu_to_be32(hw_access_flags);\n}\n\nenum {\n\tMLX5_PATH_FLAG_FL\t= 1 << 0,\n\tMLX5_PATH_FLAG_FREE_AR\t= 1 << 1,\n\tMLX5_PATH_FLAG_COUNTER\t= 1 << 2,\n};\n\nstatic int ib_rate_to_mlx5(struct mlx5_ib_dev *dev, u8 rate)\n{\n\tif (rate == IB_RATE_PORT_CURRENT)\n\t\treturn 0;\n\n\tif (rate < IB_RATE_2_5_GBPS || rate > IB_RATE_300_GBPS)\n\t\treturn -EINVAL;\n\n\twhile (rate != IB_RATE_PORT_CURRENT &&\n\t       !(1 << (rate + MLX5_STAT_RATE_OFFSET) &\n\t\t MLX5_CAP_GEN(dev->mdev, stat_rate_support)))\n\t\t--rate;\n\n\treturn rate ? rate + MLX5_STAT_RATE_OFFSET : rate;\n}\n\nstatic int modify_raw_packet_eth_prio(struct mlx5_core_dev *dev,\n\t\t\t\t      struct mlx5_ib_sq *sq, u8 sl)\n{\n\tvoid *in;\n\tvoid *tisc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tis_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_tis_in, in, bitmask.prio, 1);\n\n\ttisc = MLX5_ADDR_OF(modify_tis_in, in, ctx);\n\tMLX5_SET(tisc, tisc, prio, ((sl & 0x7) << 1));\n\n\terr = mlx5_core_modify_tis(dev, sq->tisn, in, inlen);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int modify_raw_packet_tx_affinity(struct mlx5_core_dev *dev,\n\t\t\t\t\t struct mlx5_ib_sq *sq, u8 tx_affinity)\n{\n\tvoid *in;\n\tvoid *tisc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tis_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_tis_in, in, bitmask.lag_tx_port_affinity, 1);\n\n\ttisc = MLX5_ADDR_OF(modify_tis_in, in, ctx);\n\tMLX5_SET(tisc, tisc, lag_tx_port_affinity, tx_affinity);\n\n\terr = mlx5_core_modify_tis(dev, sq->tisn, in, inlen);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int mlx5_set_path(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t const struct rdma_ah_attr *ah,\n\t\t\t struct mlx5_qp_path *path, u8 port, int attr_mask,\n\t\t\t u32 path_flags, const struct ib_qp_attr *attr,\n\t\t\t bool alt)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah);\n\tint err;\n\tenum ib_gid_type gid_type;\n\tu8 ah_flags = rdma_ah_get_ah_flags(ah);\n\tu8 sl = rdma_ah_get_sl(ah);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tpath->pkey_index = cpu_to_be16(alt ? attr->alt_pkey_index :\n\t\t\t\t\t\t     attr->pkey_index);\n\n\tif (ah_flags & IB_AH_GRH) {\n\t\tif (grh->sgid_index >=\n\t\t    dev->mdev->port_caps[port - 1].gid_table_len) {\n\t\t\tpr_err(\"sgid_index (%u) too large. max is %d\\n\",\n\t\t\t       grh->sgid_index,\n\t\t\t       dev->mdev->port_caps[port - 1].gid_table_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ah->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tif (!(ah_flags & IB_AH_GRH))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(path->rmac, ah->roce.dmac, sizeof(ah->roce.dmac));\n\t\tif (qp->ibqp.qp_type == IB_QPT_RC ||\n\t\t    qp->ibqp.qp_type == IB_QPT_UC ||\n\t\t    qp->ibqp.qp_type == IB_QPT_XRC_INI ||\n\t\t    qp->ibqp.qp_type == IB_QPT_XRC_TGT)\n\t\t\tpath->udp_sport =\n\t\t\t\tmlx5_get_roce_udp_sport(dev, ah->grh.sgid_attr);\n\t\tpath->dci_cfi_prio_sl = (sl & 0x7) << 4;\n\t\tgid_type = ah->grh.sgid_attr->gid_type;\n\t\tif (gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)\n\t\t\tpath->ecn_dscp = (grh->traffic_class >> 2) & 0x3f;\n\t} else {\n\t\tpath->fl_free_ar = (path_flags & MLX5_PATH_FLAG_FL) ? 0x80 : 0;\n\t\tpath->fl_free_ar |=\n\t\t\t(path_flags & MLX5_PATH_FLAG_FREE_AR) ? 0x40 : 0;\n\t\tpath->rlid = cpu_to_be16(rdma_ah_get_dlid(ah));\n\t\tpath->grh_mlid = rdma_ah_get_path_bits(ah) & 0x7f;\n\t\tif (ah_flags & IB_AH_GRH)\n\t\t\tpath->grh_mlid\t|= 1 << 7;\n\t\tpath->dci_cfi_prio_sl = sl & 0xf;\n\t}\n\n\tif (ah_flags & IB_AH_GRH) {\n\t\tpath->mgid_index = grh->sgid_index;\n\t\tpath->hop_limit  = grh->hop_limit;\n\t\tpath->tclass_flowlabel =\n\t\t\tcpu_to_be32((grh->traffic_class << 20) |\n\t\t\t\t    (grh->flow_label));\n\t\tmemcpy(path->rgid, grh->dgid.raw, 16);\n\t}\n\n\terr = ib_rate_to_mlx5(dev, rdma_ah_get_static_rate(ah));\n\tif (err < 0)\n\t\treturn err;\n\tpath->static_rate = err;\n\tpath->port = port;\n\n\tif (attr_mask & IB_QP_TIMEOUT)\n\t\tpath->ackto_lt = (alt ? attr->alt_timeout : attr->timeout) << 3;\n\n\tif ((qp->ibqp.qp_type == IB_QPT_RAW_PACKET) && qp->sq.wqe_cnt)\n\t\treturn modify_raw_packet_eth_prio(dev->mdev,\n\t\t\t\t\t\t  &qp->raw_packet_qp.sq,\n\t\t\t\t\t\t  sl & 0xf);\n\n\treturn 0;\n}\n\nstatic enum mlx5_qp_optpar opt_mask[MLX5_QP_NUM_STATE][MLX5_QP_NUM_STATE][MLX5_QP_ST_MAX] = {\n\t[MLX5_QP_STATE_INIT] = {\n\t\t[MLX5_QP_STATE_INIT] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_Q_KEY\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t},\n\t\t[MLX5_QP_STATE_RTR] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH  |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH  |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_PKEY_INDEX     |\n\t\t\t\t\t  MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_XRC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_RTR] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_RTS] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_SRQN\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_CQN_RCV,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_SQER] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_UD]\t = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_UC]\t = MLX5_QP_OPTPAR_RWE,\n\t\t\t[MLX5_QP_ST_RC]\t = MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RRE,\n\t\t},\n\t},\n};\n\nstatic int ib_nr_to_mlx5_nr(int ib_mask)\n{\n\tswitch (ib_mask) {\n\tcase IB_QP_STATE:\n\t\treturn 0;\n\tcase IB_QP_CUR_STATE:\n\t\treturn 0;\n\tcase IB_QP_EN_SQD_ASYNC_NOTIFY:\n\t\treturn 0;\n\tcase IB_QP_ACCESS_FLAGS:\n\t\treturn MLX5_QP_OPTPAR_RWE | MLX5_QP_OPTPAR_RRE |\n\t\t\tMLX5_QP_OPTPAR_RAE;\n\tcase IB_QP_PKEY_INDEX:\n\t\treturn MLX5_QP_OPTPAR_PKEY_INDEX;\n\tcase IB_QP_PORT:\n\t\treturn MLX5_QP_OPTPAR_PRI_PORT;\n\tcase IB_QP_QKEY:\n\t\treturn MLX5_QP_OPTPAR_Q_KEY;\n\tcase IB_QP_AV:\n\t\treturn MLX5_QP_OPTPAR_PRIMARY_ADDR_PATH |\n\t\t\tMLX5_QP_OPTPAR_PRI_PORT;\n\tcase IB_QP_PATH_MTU:\n\t\treturn 0;\n\tcase IB_QP_TIMEOUT:\n\t\treturn MLX5_QP_OPTPAR_ACK_TIMEOUT;\n\tcase IB_QP_RETRY_CNT:\n\t\treturn MLX5_QP_OPTPAR_RETRY_COUNT;\n\tcase IB_QP_RNR_RETRY:\n\t\treturn MLX5_QP_OPTPAR_RNR_RETRY;\n\tcase IB_QP_RQ_PSN:\n\t\treturn 0;\n\tcase IB_QP_MAX_QP_RD_ATOMIC:\n\t\treturn MLX5_QP_OPTPAR_SRA_MAX;\n\tcase IB_QP_ALT_PATH:\n\t\treturn MLX5_QP_OPTPAR_ALT_ADDR_PATH;\n\tcase IB_QP_MIN_RNR_TIMER:\n\t\treturn MLX5_QP_OPTPAR_RNR_TIMEOUT;\n\tcase IB_QP_SQ_PSN:\n\t\treturn 0;\n\tcase IB_QP_MAX_DEST_RD_ATOMIC:\n\t\treturn MLX5_QP_OPTPAR_RRA_MAX | MLX5_QP_OPTPAR_RWE |\n\t\t\tMLX5_QP_OPTPAR_RRE | MLX5_QP_OPTPAR_RAE;\n\tcase IB_QP_PATH_MIG_STATE:\n\t\treturn MLX5_QP_OPTPAR_PM_STATE;\n\tcase IB_QP_CAP:\n\t\treturn 0;\n\tcase IB_QP_DEST_QPN:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int ib_mask_to_mlx5_opt(int ib_mask)\n{\n\tint result = 0;\n\tint i;\n\n\tfor (i = 0; i < 8 * sizeof(int); i++) {\n\t\tif ((1 << i) & ib_mask)\n\t\t\tresult |= ib_nr_to_mlx5_nr(1 << i);\n\t}\n\n\treturn result;\n}\n\nstatic int modify_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_rq *rq, int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tvoid *in;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_rq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_rq_in, in, rq_state, rq->state);\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\tMLX5_SET(rqc, rqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID) {\n\t\tif (MLX5_CAP_GEN(dev->mdev, modify_rq_counter_set_id)) {\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\t\t\tMLX5_SET(rqc, rqc, counter_set_id, raw_qp_param->rq_q_ctr_id);\n\t\t} else\n\t\t\tpr_info_once(\"%s: RAW PACKET QP counters are not supported on current FW\\n\",\n\t\t\t\t     dev->ib_dev.name);\n\t}\n\n\terr = mlx5_core_modify_rq(dev->mdev, rq->base.mqp.qpn, in, inlen);\n\tif (err)\n\t\tgoto out;\n\n\trq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int modify_raw_packet_qp_sq(struct mlx5_core_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq,\n\t\t\t\t   int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tstruct mlx5_ib_qp *ibqp = sq->base.container_mibqp;\n\tstruct mlx5_rate_limit old_rl = ibqp->rl;\n\tstruct mlx5_rate_limit new_rl = old_rl;\n\tbool new_rate_added = false;\n\tu16 rl_index = 0;\n\tvoid *in;\n\tvoid *sqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, sq_state, sq->state);\n\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_RATE_LIMIT) {\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tpr_warn(\"%s: Rate limit can only be changed when SQ is moving to RDY\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tnew_rl = raw_qp_param->rl;\n\t}\n\n\tif (!mlx5_rl_are_equal(&old_rl, &new_rl)) {\n\t\tif (new_rl.rate) {\n\t\t\terr = mlx5_rl_add_rate(dev, &rl_index, &new_rl);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed configuring rate limit(err %d): \\\n\t\t\t\t       rate %u, max_burst_sz %u, typical_pkt_sz %u\\n\",\n\t\t\t\t       err, new_rl.rate, new_rl.max_burst_sz,\n\t\t\t\t       new_rl.typical_pkt_sz);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnew_rate_added = true;\n\t\t}\n\n\t\tMLX5_SET64(modify_sq_in, in, modify_bitmask, 1);\n\t\t/* index 0 means no limit */\n\t\tMLX5_SET(sqc, sqc, packet_pacing_rate_limit_index, rl_index);\n\t}\n\n\terr = mlx5_core_modify_sq(dev, sq->base.mqp.qpn, in, inlen);\n\tif (err) {\n\t\t/* Remove new rate from table if failed */\n\t\tif (new_rate_added)\n\t\t\tmlx5_rl_remove_rate(dev, &new_rl);\n\t\tgoto out;\n\t}\n\n\t/* Only remove the old rate after new rate was set */\n\tif ((old_rl.rate &&\n\t     !mlx5_rl_are_equal(&old_rl, &new_rl)) ||\n\t    (new_state != MLX5_SQC_STATE_RDY))\n\t\tmlx5_rl_remove_rate(dev, &old_rl);\n\n\tibqp->rl = new_rl;\n\tsq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct mlx5_modify_raw_qp_param *raw_qp_param,\n\t\t\t\tu8 tx_affinity)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tint modify_rq = !!qp->rq.wqe_cnt;\n\tint modify_sq = !!qp->sq.wqe_cnt;\n\tint rq_state;\n\tint sq_state;\n\tint err;\n\n\tswitch (raw_qp_param->operation) {\n\tcase MLX5_CMD_OP_RST2INIT_QP:\n\t\trq_state = MLX5_RQC_STATE_RDY;\n\t\tsq_state = MLX5_SQC_STATE_RDY;\n\t\tbreak;\n\tcase MLX5_CMD_OP_2ERR_QP:\n\t\trq_state = MLX5_RQC_STATE_ERR;\n\t\tsq_state = MLX5_SQC_STATE_ERR;\n\t\tbreak;\n\tcase MLX5_CMD_OP_2RST_QP:\n\t\trq_state = MLX5_RQC_STATE_RST;\n\t\tsq_state = MLX5_SQC_STATE_RST;\n\t\tbreak;\n\tcase MLX5_CMD_OP_RTR2RTS_QP:\n\tcase MLX5_CMD_OP_RTS2RTS_QP:\n\t\tif (raw_qp_param->set_mask ==\n\t\t    MLX5_RAW_QP_RATE_LIMIT) {\n\t\t\tmodify_rq = 0;\n\t\t\tsq_state = sq->state;\n\t\t} else {\n\t\t\treturn raw_qp_param->set_mask ? -EINVAL : 0;\n\t\t}\n\t\tbreak;\n\tcase MLX5_CMD_OP_INIT2INIT_QP:\n\tcase MLX5_CMD_OP_INIT2RTR_QP:\n\t\tif (raw_qp_param->set_mask)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (modify_rq) {\n\t\terr =  modify_raw_packet_qp_rq(dev, rq, rq_state, raw_qp_param);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (modify_sq) {\n\t\tif (tx_affinity) {\n\t\t\terr = modify_raw_packet_tx_affinity(dev->mdev, sq,\n\t\t\t\t\t\t\t    tx_affinity);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\treturn modify_raw_packet_qp_sq(dev->mdev, sq, sq_state, raw_qp_param);\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlx5_ib_modify_qp(struct ib_qp *ibqp,\n\t\t\t       const struct ib_qp_attr *attr, int attr_mask,\n\t\t\t       enum ib_qp_state cur_state, enum ib_qp_state new_state,\n\t\t\t       const struct mlx5_ib_modify_qp *ucmd)\n{\n\tstatic const u16 optab[MLX5_QP_NUM_STATE][MLX5_QP_NUM_STATE] = {\n\t\t[MLX5_QP_STATE_RST] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_INIT]\t= MLX5_CMD_OP_RST2INIT_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_INIT]  = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_INIT]\t= MLX5_CMD_OP_INIT2INIT_QP,\n\t\t\t[MLX5_QP_STATE_RTR]\t= MLX5_CMD_OP_INIT2RTR_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_RTR]   = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_RTR2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_RTS]   = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_RTS2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_SQD] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_SQER] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_SQERR2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_ERR] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t}\n\t};\n\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct mlx5_ib_cq *send_cq, *recv_cq;\n\tstruct mlx5_qp_context *context;\n\tstruct mlx5_ib_pd *pd;\n\tstruct mlx5_ib_port *mibport = NULL;\n\tenum mlx5_qp_state mlx5_cur, mlx5_new;\n\tenum mlx5_qp_optpar optpar;\n\tint mlx5_st;\n\tint err;\n\tu16 op;\n\tu8 tx_affinity = 0;\n\n\tmlx5_st = to_mlx5_st(ibqp->qp_type == IB_QPT_DRIVER ?\n\t\t\t     qp->qp_sub_type : ibqp->qp_type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tcontext->flags = cpu_to_be32(mlx5_st << 16);\n\n\tif (!(attr_mask & IB_QP_PATH_MIG_STATE)) {\n\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_MIGRATED << 11);\n\t} else {\n\t\tswitch (attr->path_mig_state) {\n\t\tcase IB_MIG_MIGRATED:\n\t\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_MIGRATED << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_REARM:\n\t\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_REARM << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_ARMED:\n\t\t\tcontext->flags |= cpu_to_be32(MLX5_QP_PM_ARMED << 11);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((cur_state == IB_QPS_RESET) && (new_state == IB_QPS_INIT)) {\n\t\tif ((ibqp->qp_type == IB_QPT_RC) ||\n\t\t    (ibqp->qp_type == IB_QPT_UD &&\n\t\t     !(qp->flags & MLX5_IB_QP_SQPN_QP1)) ||\n\t\t    (ibqp->qp_type == IB_QPT_UC) ||\n\t\t    (ibqp->qp_type == IB_QPT_RAW_PACKET) ||\n\t\t    (ibqp->qp_type == IB_QPT_XRC_INI) ||\n\t\t    (ibqp->qp_type == IB_QPT_XRC_TGT)) {\n\t\t\tif (mlx5_lag_is_active(dev->mdev)) {\n\t\t\t\tu8 p = mlx5_core_native_port_num(dev->mdev);\n\t\t\t\ttx_affinity = (unsigned int)atomic_add_return(1,\n\t\t\t\t\t\t&dev->roce[p].next_port) %\n\t\t\t\t\t\tMLX5_MAX_PORTS + 1;\n\t\t\t\tcontext->flags |= cpu_to_be32(tx_affinity << 24);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_sqp(ibqp->qp_type)) {\n\t\tcontext->mtu_msgmax = (IB_MTU_256 << 5) | 8;\n\t} else if ((ibqp->qp_type == IB_QPT_UD &&\n\t\t    !(qp->flags & MLX5_IB_QP_UNDERLAY)) ||\n\t\t   ibqp->qp_type == MLX5_IB_QPT_REG_UMR) {\n\t\tcontext->mtu_msgmax = (IB_MTU_4096 << 5) | 12;\n\t} else if (attr_mask & IB_QP_PATH_MTU) {\n\t\tif (attr->path_mtu < IB_MTU_256 ||\n\t\t    attr->path_mtu > IB_MTU_4096) {\n\t\t\tmlx5_ib_warn(dev, \"invalid mtu %d\\n\", attr->path_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->mtu_msgmax = (attr->path_mtu << 5) |\n\t\t\t\t      (u8)MLX5_CAP_GEN(dev->mdev, log_max_msg);\n\t}\n\n\tif (attr_mask & IB_QP_DEST_QPN)\n\t\tcontext->log_pg_sz_remote_qpn = cpu_to_be32(attr->dest_qp_num);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tcontext->pri_path.pkey_index = cpu_to_be16(attr->pkey_index);\n\n\t/* todo implement counter_index functionality */\n\n\tif (is_sqp(ibqp->qp_type))\n\t\tcontext->pri_path.port = qp->port;\n\n\tif (attr_mask & IB_QP_PORT)\n\t\tcontext->pri_path.port = attr->port_num;\n\n\tif (attr_mask & IB_QP_AV) {\n\t\terr = mlx5_set_path(dev, qp, &attr->ah_attr, &context->pri_path,\n\t\t\t\t    attr_mask & IB_QP_PORT ? attr->port_num : qp->port,\n\t\t\t\t    attr_mask, 0, attr, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_TIMEOUT)\n\t\tcontext->pri_path.ackto_lt |= attr->timeout << 3;\n\n\tif (attr_mask & IB_QP_ALT_PATH) {\n\t\terr = mlx5_set_path(dev, qp, &attr->alt_ah_attr,\n\t\t\t\t    &context->alt_path,\n\t\t\t\t    attr->alt_port_num,\n\t\t\t\t    attr_mask | IB_QP_PKEY_INDEX | IB_QP_TIMEOUT,\n\t\t\t\t    0, attr, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tpd = get_pd(qp);\n\tget_cqs(qp->ibqp.qp_type, qp->ibqp.send_cq, qp->ibqp.recv_cq,\n\t\t&send_cq, &recv_cq);\n\n\tcontext->flags_pd = cpu_to_be32(pd ? pd->pdn : to_mpd(dev->devr.p0)->pdn);\n\tcontext->cqn_send = send_cq ? cpu_to_be32(send_cq->mcq.cqn) : 0;\n\tcontext->cqn_recv = recv_cq ? cpu_to_be32(recv_cq->mcq.cqn) : 0;\n\tcontext->params1  = cpu_to_be32(MLX5_IB_ACK_REQ_FREQ << 28);\n\n\tif (attr_mask & IB_QP_RNR_RETRY)\n\t\tcontext->params1 |= cpu_to_be32(attr->rnr_retry << 13);\n\n\tif (attr_mask & IB_QP_RETRY_CNT)\n\t\tcontext->params1 |= cpu_to_be32(attr->retry_cnt << 16);\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tif (attr->max_rd_atomic)\n\t\t\tcontext->params1 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_rd_atomic - 1) << 21);\n\t}\n\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tcontext->next_send_psn = cpu_to_be32(attr->sq_psn);\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tif (attr->max_dest_rd_atomic)\n\t\t\tcontext->params2 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_dest_rd_atomic - 1) << 21);\n\t}\n\n\tif (attr_mask & (IB_QP_ACCESS_FLAGS | IB_QP_MAX_DEST_RD_ATOMIC))\n\t\tcontext->params2 |= to_mlx5_access_flags(qp, attr, attr_mask);\n\n\tif (attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tcontext->rnr_nextrecvpsn |= cpu_to_be32(attr->min_rnr_timer << 24);\n\n\tif (attr_mask & IB_QP_RQ_PSN)\n\t\tcontext->rnr_nextrecvpsn |= cpu_to_be32(attr->rq_psn);\n\n\tif (attr_mask & IB_QP_QKEY)\n\t\tcontext->qkey = cpu_to_be32(attr->qkey);\n\n\tif (qp->rq.wqe_cnt && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\n\t\tcontext->db_rec_addr = cpu_to_be64(qp->db.dma);\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\tu8 port_num = (attr_mask & IB_QP_PORT ? attr->port_num :\n\t\t\t       qp->port) - 1;\n\n\t\t/* Underlay port should be used - index 0 function per port */\n\t\tif (qp->flags & MLX5_IB_QP_UNDERLAY)\n\t\t\tport_num = 0;\n\n\t\tmibport = &dev->port[port_num];\n\t\tcontext->qp_counter_set_usr_page |=\n\t\t\tcpu_to_be32((u32)(mibport->cnts.set_id) << 24);\n\t}\n\n\tif (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\n\t\tcontext->sq_crq_size |= cpu_to_be16(1 << 4);\n\n\tif (qp->flags & MLX5_IB_QP_SQPN_QP1)\n\t\tcontext->deth_sqpn = cpu_to_be32(1);\n\n\tmlx5_cur = to_mlx5_state(cur_state);\n\tmlx5_new = to_mlx5_state(new_state);\n\n\tif (mlx5_cur >= MLX5_QP_NUM_STATE || mlx5_new >= MLX5_QP_NUM_STATE ||\n\t    !optab[mlx5_cur][mlx5_new]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\top = optab[mlx5_cur][mlx5_new];\n\toptpar = ib_mask_to_mlx5_opt(attr_mask);\n\toptpar &= opt_mask[mlx5_cur][mlx5_new][mlx5_st];\n\n\tif (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tstruct mlx5_modify_raw_qp_param raw_qp_param = {};\n\n\t\traw_qp_param.operation = op;\n\t\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\t\traw_qp_param.rq_q_ctr_id = mibport->cnts.set_id;\n\t\t\traw_qp_param.set_mask |= MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID;\n\t\t}\n\n\t\tif (attr_mask & IB_QP_RATE_LIMIT) {\n\t\t\traw_qp_param.rl.rate = attr->rate_limit;\n\n\t\t\tif (ucmd->burst_info.max_burst_sz) {\n\t\t\t\tif (attr->rate_limit &&\n\t\t\t\t    MLX5_CAP_QOS(dev->mdev, packet_pacing_burst_bound)) {\n\t\t\t\t\traw_qp_param.rl.max_burst_sz =\n\t\t\t\t\t\tucmd->burst_info.max_burst_sz;\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ucmd->burst_info.typical_pkt_sz) {\n\t\t\t\tif (attr->rate_limit &&\n\t\t\t\t    MLX5_CAP_QOS(dev->mdev, packet_pacing_typical_size)) {\n\t\t\t\t\traw_qp_param.rl.typical_pkt_sz =\n\t\t\t\t\t\tucmd->burst_info.typical_pkt_sz;\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\traw_qp_param.set_mask |= MLX5_RAW_QP_RATE_LIMIT;\n\t\t}\n\n\t\terr = modify_raw_packet_qp(dev, qp, &raw_qp_param, tx_affinity);\n\t} else {\n\t\terr = mlx5_core_qp_modify(dev->mdev, op, optpar, context,\n\t\t\t\t\t  &base->mqp);\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\tqp->state = new_state;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\tqp->trans_qp.atomic_rd_en = attr->qp_access_flags;\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tqp->trans_qp.resp_depth = attr->max_dest_rd_atomic;\n\tif (attr_mask & IB_QP_PORT)\n\t\tqp->port = attr->port_num;\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\tqp->trans_qp.alt_port = attr->alt_port_num;\n\n\t/*\n\t * If we moved a kernel QP to RESET, clean up all old CQ\n\t * entries and reinitialize the QP.\n\t */\n\tif (new_state == IB_QPS_RESET &&\n\t    !ibqp->uobject && ibqp->qp_type != IB_QPT_XRC_TGT) {\n\t\tmlx5_ib_cq_clean(recv_cq, base->mqp.qpn,\n\t\t\t\t ibqp->srq ? to_msrq(ibqp->srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\tmlx5_ib_cq_clean(send_cq, base->mqp.qpn, NULL);\n\n\t\tqp->rq.head = 0;\n\t\tqp->rq.tail = 0;\n\t\tqp->sq.head = 0;\n\t\tqp->sq.tail = 0;\n\t\tqp->sq.cur_post = 0;\n\t\tqp->sq.last_poll = 0;\n\t\tqp->db.db[MLX5_RCV_DBR] = 0;\n\t\tqp->db.db[MLX5_SND_DBR] = 0;\n\t}\n\nout:\n\tkfree(context);\n\treturn err;\n}\n\nstatic inline bool is_valid_mask(int mask, int req, int opt)\n{\n\tif ((mask & req) != req)\n\t\treturn false;\n\n\tif (mask & ~(req | opt))\n\t\treturn false;\n\n\treturn true;\n}\n\n/* check valid transition for driver QP types\n * for now the only QP type that this function supports is DCI\n */\nstatic bool modify_dci_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state new_state,\n\t\t\t\tenum ib_qp_attr_mask attr_mask)\n{\n\tint req = IB_QP_STATE;\n\tint opt = 0;\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\treq |= IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_INIT) {\n\t\topt = IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\treq |= IB_QP_PATH_MTU;\n\t\topt = IB_QP_PKEY_INDEX;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTR && new_state == IB_QPS_RTS) {\n\t\treq |= IB_QP_TIMEOUT | IB_QP_RETRY_CNT | IB_QP_RNR_RETRY |\n\t\t       IB_QP_MAX_QP_RD_ATOMIC | IB_QP_SQ_PSN;\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTS && new_state == IB_QPS_RTS) {\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state != IB_QPS_RESET && new_state == IB_QPS_ERR) {\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t}\n\treturn false;\n}\n\n/* mlx5_ib_modify_dct: modify a DCT QP\n * valid transitions are:\n * RESET to INIT: must set access_flags, pkey_index and port\n * INIT  to RTR : must set min_rnr_timer, tclass, flow_label,\n *\t\t\t   mtu, gid_index and hop_limit\n * Other transitions and attributes are illegal\n */\nstatic int mlx5_ib_modify_dct(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tenum ib_qp_state cur_state, new_state;\n\tint err = 0;\n\tint required = IB_QP_STATE;\n\tvoid *dctc;\n\n\tif (!(attr_mask & IB_QP_STATE))\n\t\treturn -EINVAL;\n\n\tcur_state = qp->state;\n\tnew_state = attr->qp_state;\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\trequired |= IB_QP_ACCESS_FLAGS | IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\tif (!is_valid_mask(attr_mask, required, 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (attr->port_num == 0 ||\n\t\t    attr->port_num > MLX5_CAP_GEN(dev->mdev, num_ports)) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid port number %d. number of ports is %d\\n\",\n\t\t\t\t    attr->port_num, dev->num_ports);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ)\n\t\t\tMLX5_SET(dctc, dctc, rre, 1);\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\t\tMLX5_SET(dctc, dctc, rwe, 1);\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_ATOMIC) {\n\t\t\tif (!mlx5_ib_dc_atomic_is_supported(dev))\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tMLX5_SET(dctc, dctc, rae, 1);\n\t\t\tMLX5_SET(dctc, dctc, atomic_mode, MLX5_ATOMIC_MODE_DCT_CX);\n\t\t}\n\t\tMLX5_SET(dctc, dctc, pkey_index, attr->pkey_index);\n\t\tMLX5_SET(dctc, dctc, port, attr->port_num);\n\t\tMLX5_SET(dctc, dctc, counter_set_id, dev->port[attr->port_num - 1].cnts.set_id);\n\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\tstruct mlx5_ib_modify_qp_resp resp = {};\n\t\tu32 min_resp_len = offsetof(typeof(resp), dctn) +\n\t\t\t\t   sizeof(resp.dctn);\n\n\t\tif (udata->outlen < min_resp_len)\n\t\t\treturn -EINVAL;\n\t\tresp.response_length = min_resp_len;\n\n\t\trequired |= IB_QP_MIN_RNR_TIMER | IB_QP_AV | IB_QP_PATH_MTU;\n\t\tif (!is_valid_mask(attr_mask, required, 0))\n\t\t\treturn -EINVAL;\n\t\tMLX5_SET(dctc, dctc, min_rnr_nak, attr->min_rnr_timer);\n\t\tMLX5_SET(dctc, dctc, tclass, attr->ah_attr.grh.traffic_class);\n\t\tMLX5_SET(dctc, dctc, flow_label, attr->ah_attr.grh.flow_label);\n\t\tMLX5_SET(dctc, dctc, mtu, attr->path_mtu);\n\t\tMLX5_SET(dctc, dctc, my_addr_index, attr->ah_attr.grh.sgid_index);\n\t\tMLX5_SET(dctc, dctc, hop_limit, attr->ah_attr.grh.hop_limit);\n\n\t\terr = mlx5_core_create_dct(dev->mdev, &qp->dct.mdct, qp->dct.in,\n\t\t\t\t\t   MLX5_ST_SZ_BYTES(create_dct_in));\n\t\tif (err)\n\t\t\treturn err;\n\t\tresp.dctn = qp->dct.mdct.mqp.qpn;\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err) {\n\t\t\tmlx5_core_destroy_dct(dev->mdev, &qp->dct.mdct);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tmlx5_ib_warn(dev, \"Modify DCT: Invalid transition from %d to %d\\n\", cur_state, new_state);\n\t\treturn -EINVAL;\n\t}\n\tif (err)\n\t\tqp->state = IB_QPS_ERR;\n\telse\n\t\tqp->state = new_state;\n\treturn err;\n}\n\nint mlx5_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_modify_qp ucmd = {};\n\tenum ib_qp_type qp_type;\n\tenum ib_qp_state cur_state, new_state;\n\tsize_t required_cmd_sz;\n\tint err = -EINVAL;\n\tint port;\n\tenum rdma_link_layer ll = IB_LINK_LAYER_UNSPECIFIED;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -ENOSYS;\n\n\tif (udata && udata->inlen) {\n\t\trequired_cmd_sz = offsetof(typeof(ucmd), reserved) +\n\t\t\tsizeof(ucmd.reserved);\n\t\tif (udata->inlen < required_cmd_sz)\n\t\t\treturn -EINVAL;\n\n\t\tif (udata->inlen > sizeof(ucmd) &&\n\t\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (ib_copy_from_udata(&ucmd, udata,\n\t\t\t\t       min(udata->inlen, sizeof(ucmd))))\n\t\t\treturn -EFAULT;\n\n\t\tif (ucmd.comp_mask ||\n\t\t    memchr_inv(&ucmd.reserved, 0, sizeof(ucmd.reserved)) ||\n\t\t    memchr_inv(&ucmd.burst_info.reserved, 0,\n\t\t\t       sizeof(ucmd.burst_info.reserved)))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_modify_qp(ibqp, attr, attr_mask);\n\n\tif (ibqp->qp_type == IB_QPT_DRIVER)\n\t\tqp_type = qp->qp_sub_type;\n\telse\n\t\tqp_type = (unlikely(ibqp->qp_type == MLX5_IB_QPT_HW_GSI)) ?\n\t\t\tIB_QPT_GSI : ibqp->qp_type;\n\n\tif (qp_type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_modify_dct(ibqp, attr, attr_mask, udata);\n\n\tmutex_lock(&qp->mutex);\n\n\tcur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;\n\tnew_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;\n\n\tif (!(cur_state == new_state && cur_state == IB_QPS_RESET)) {\n\t\tport = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\t\tll = dev->ib_dev.get_link_layer(&dev->ib_dev, port);\n\t}\n\n\tif (qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tif (attr_mask & ~(IB_QP_STATE | IB_QP_CUR_STATE)) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid attr_mask 0x%x when underlay QP is used\\n\",\n\t\t\t\t    attr_mask);\n\t\t\tgoto out;\n\t\t}\n\t} else if (qp_type != MLX5_IB_QPT_REG_UMR &&\n\t\t   qp_type != MLX5_IB_QPT_DCI &&\n\t\t   !ib_modify_qp_is_ok(cur_state, new_state, qp_type, attr_mask, ll)) {\n\t\tmlx5_ib_dbg(dev, \"invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\\n\",\n\t\t\t    cur_state, new_state, ibqp->qp_type, attr_mask);\n\t\tgoto out;\n\t} else if (qp_type == MLX5_IB_QPT_DCI &&\n\t\t   !modify_dci_qp_is_ok(cur_state, new_state, attr_mask)) {\n\t\tmlx5_ib_dbg(dev, \"invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\\n\",\n\t\t\t    cur_state, new_state, qp_type, attr_mask);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PORT) &&\n\t    (attr->port_num == 0 ||\n\t     attr->port_num > dev->num_ports)) {\n\t\tmlx5_ib_dbg(dev, \"invalid port number %d. number of ports is %d\\n\",\n\t\t\t    attr->port_num, dev->num_ports);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tport = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\t\tif (attr->pkey_index >=\n\t\t    dev->mdev->port_caps[port - 1].pkey_table_len) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid pkey index %d\\n\",\n\t\t\t\t    attr->pkey_index);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&\n\t    attr->max_rd_atomic >\n\t    (1 << MLX5_CAP_GEN(dev->mdev, log_max_ra_res_qp))) {\n\t\tmlx5_ib_dbg(dev, \"invalid max_rd_atomic value %d\\n\",\n\t\t\t    attr->max_rd_atomic);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&\n\t    attr->max_dest_rd_atomic >\n\t    (1 << MLX5_CAP_GEN(dev->mdev, log_max_ra_req_qp))) {\n\t\tmlx5_ib_dbg(dev, \"invalid max_dest_rd_atomic value %d\\n\",\n\t\t\t    attr->max_dest_rd_atomic);\n\t\tgoto out;\n\t}\n\n\tif (cur_state == new_state && cur_state == IB_QPS_RESET) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = __mlx5_ib_modify_qp(ibqp, attr, attr_mask, cur_state,\n\t\t\t\t  new_state, &ucmd);\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstatic int mlx5_wq_overflow(struct mlx5_ib_wq *wq, int nreq, struct ib_cq *ib_cq)\n{\n\tstruct mlx5_ib_cq *cq;\n\tunsigned cur;\n\n\tcur = wq->head - wq->tail;\n\tif (likely(cur + nreq < wq->max_post))\n\t\treturn 0;\n\n\tcq = to_mcq(ib_cq);\n\tspin_lock(&cq->lock);\n\tcur = wq->head - wq->tail;\n\tspin_unlock(&cq->lock);\n\n\treturn cur + nreq >= wq->max_post;\n}\n\nstatic __always_inline void set_raddr_seg(struct mlx5_wqe_raddr_seg *rseg,\n\t\t\t\t\t  u64 remote_addr, u32 rkey)\n{\n\trseg->raddr    = cpu_to_be64(remote_addr);\n\trseg->rkey     = cpu_to_be32(rkey);\n\trseg->reserved = 0;\n}\n\nstatic void *set_eth_seg(struct mlx5_wqe_eth_seg *eseg,\n\t\t\t const struct ib_send_wr *wr, void *qend,\n\t\t\t struct mlx5_ib_qp *qp, int *size)\n{\n\tvoid *seg = eseg;\n\n\tmemset(eseg, 0, sizeof(struct mlx5_wqe_eth_seg));\n\n\tif (wr->send_flags & IB_SEND_IP_CSUM)\n\t\teseg->cs_flags = MLX5_ETH_WQE_L3_CSUM |\n\t\t\t\t MLX5_ETH_WQE_L4_CSUM;\n\n\tseg += sizeof(struct mlx5_wqe_eth_seg);\n\t*size += sizeof(struct mlx5_wqe_eth_seg) / 16;\n\n\tif (wr->opcode == IB_WR_LSO) {\n\t\tstruct ib_ud_wr *ud_wr = container_of(wr, struct ib_ud_wr, wr);\n\t\tint size_of_inl_hdr_start = sizeof(eseg->inline_hdr.start);\n\t\tu64 left, leftlen, copysz;\n\t\tvoid *pdata = ud_wr->header;\n\n\t\tleft = ud_wr->hlen;\n\t\teseg->mss = cpu_to_be16(ud_wr->mss);\n\t\teseg->inline_hdr.sz = cpu_to_be16(left);\n\n\t\t/*\n\t\t * check if there is space till the end of queue, if yes,\n\t\t * copy all in one shot, otherwise copy till the end of queue,\n\t\t * rollback and than the copy the left\n\t\t */\n\t\tleftlen = qend - (void *)eseg->inline_hdr.start;\n\t\tcopysz = min_t(u64, leftlen, left);\n\n\t\tmemcpy(seg - size_of_inl_hdr_start, pdata, copysz);\n\n\t\tif (likely(copysz > size_of_inl_hdr_start)) {\n\t\t\tseg += ALIGN(copysz - size_of_inl_hdr_start, 16);\n\t\t\t*size += ALIGN(copysz - size_of_inl_hdr_start, 16) / 16;\n\t\t}\n\n\t\tif (unlikely(copysz < left)) { /* the last wqe in the queue */\n\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tleft -= copysz;\n\t\t\tpdata += copysz;\n\t\t\tmemcpy(seg, pdata, left);\n\t\t\tseg += ALIGN(left, 16);\n\t\t\t*size += ALIGN(left, 16) / 16;\n\t\t}\n\t}\n\n\treturn seg;\n}\n\nstatic void set_datagram_seg(struct mlx5_wqe_datagram_seg *dseg,\n\t\t\t     const struct ib_send_wr *wr)\n{\n\tmemcpy(&dseg->av, &to_mah(ud_wr(wr)->ah)->av, sizeof(struct mlx5_av));\n\tdseg->av.dqp_dct = cpu_to_be32(ud_wr(wr)->remote_qpn | MLX5_EXTENDED_UD_AV);\n\tdseg->av.key.qkey.qkey = cpu_to_be32(ud_wr(wr)->remote_qkey);\n}\n\nstatic void set_data_ptr_seg(struct mlx5_wqe_data_seg *dseg, struct ib_sge *sg)\n{\n\tdseg->byte_count = cpu_to_be32(sg->length);\n\tdseg->lkey       = cpu_to_be32(sg->lkey);\n\tdseg->addr       = cpu_to_be64(sg->addr);\n}\n\nstatic u64 get_xlt_octo(u64 bytes)\n{\n\treturn ALIGN(bytes, MLX5_IB_UMR_XLT_ALIGNMENT) /\n\t       MLX5_IB_UMR_OCTOWORD;\n}\n\nstatic __be64 frwr_mkey_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LEN\t\t|\n\t\tMLX5_MKEY_MASK_PAGE_SIZE\t|\n\t\tMLX5_MKEY_MASK_START_ADDR\t|\n\t\tMLX5_MKEY_MASK_EN_RINVAL\t|\n\t\tMLX5_MKEY_MASK_KEY\t\t|\n\t\tMLX5_MKEY_MASK_LR\t\t|\n\t\tMLX5_MKEY_MASK_LW\t\t|\n\t\tMLX5_MKEY_MASK_RR\t\t|\n\t\tMLX5_MKEY_MASK_RW\t\t|\n\t\tMLX5_MKEY_MASK_A\t\t|\n\t\tMLX5_MKEY_MASK_SMALL_FENCE\t|\n\t\tMLX5_MKEY_MASK_FREE;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 sig_mkey_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LEN\t\t|\n\t\tMLX5_MKEY_MASK_PAGE_SIZE\t|\n\t\tMLX5_MKEY_MASK_START_ADDR\t|\n\t\tMLX5_MKEY_MASK_EN_SIGERR\t|\n\t\tMLX5_MKEY_MASK_EN_RINVAL\t|\n\t\tMLX5_MKEY_MASK_KEY\t\t|\n\t\tMLX5_MKEY_MASK_LR\t\t|\n\t\tMLX5_MKEY_MASK_LW\t\t|\n\t\tMLX5_MKEY_MASK_RR\t\t|\n\t\tMLX5_MKEY_MASK_RW\t\t|\n\t\tMLX5_MKEY_MASK_SMALL_FENCE\t|\n\t\tMLX5_MKEY_MASK_FREE\t\t|\n\t\tMLX5_MKEY_MASK_BSF_EN;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic void set_reg_umr_seg(struct mlx5_wqe_umr_ctrl_seg *umr,\n\t\t\t    struct mlx5_ib_mr *mr, bool umr_inline)\n{\n\tint size = mr->ndescs * mr->desc_size;\n\n\tmemset(umr, 0, sizeof(*umr));\n\n\tumr->flags = MLX5_UMR_CHECK_NOT_FREE;\n\tif (umr_inline)\n\t\tumr->flags |= MLX5_UMR_INLINE;\n\tumr->xlt_octowords = cpu_to_be16(get_xlt_octo(size));\n\tumr->mkey_mask = frwr_mkey_mask();\n}\n\nstatic void set_linv_umr_seg(struct mlx5_wqe_umr_ctrl_seg *umr)\n{\n\tmemset(umr, 0, sizeof(*umr));\n\tumr->mkey_mask = cpu_to_be64(MLX5_MKEY_MASK_FREE);\n\tumr->flags = MLX5_UMR_INLINE;\n}\n\nstatic __be64 get_umr_enable_mr_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_KEY |\n\t\t MLX5_MKEY_MASK_FREE;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_disable_mr_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_FREE;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_update_translation_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LEN |\n\t\t MLX5_MKEY_MASK_PAGE_SIZE |\n\t\t MLX5_MKEY_MASK_START_ADDR;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_update_access_mask(int atomic)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_LR |\n\t\t MLX5_MKEY_MASK_LW |\n\t\t MLX5_MKEY_MASK_RR |\n\t\t MLX5_MKEY_MASK_RW;\n\n\tif (atomic)\n\t\tresult |= MLX5_MKEY_MASK_A;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic __be64 get_umr_update_pd_mask(void)\n{\n\tu64 result;\n\n\tresult = MLX5_MKEY_MASK_PD;\n\n\treturn cpu_to_be64(result);\n}\n\nstatic int umr_check_mkey_mask(struct mlx5_ib_dev *dev, u64 mask)\n{\n\tif ((mask & MLX5_MKEY_MASK_PAGE_SIZE &&\n\t     MLX5_CAP_GEN(dev->mdev, umr_modify_entity_size_disabled)) ||\n\t    (mask & MLX5_MKEY_MASK_A &&\n\t     MLX5_CAP_GEN(dev->mdev, umr_modify_atomic_disabled)))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic int set_reg_umr_segment(struct mlx5_ib_dev *dev,\n\t\t\t       struct mlx5_wqe_umr_ctrl_seg *umr,\n\t\t\t       const struct ib_send_wr *wr, int atomic)\n{\n\tconst struct mlx5_umr_wr *umrwr = umr_wr(wr);\n\n\tmemset(umr, 0, sizeof(*umr));\n\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_FAIL_IF_FREE)\n\t\tumr->flags = MLX5_UMR_CHECK_FREE; /* fail if free */\n\telse\n\t\tumr->flags = MLX5_UMR_CHECK_NOT_FREE; /* fail if not free */\n\n\tumr->xlt_octowords = cpu_to_be16(get_xlt_octo(umrwr->xlt_size));\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_XLT) {\n\t\tu64 offset = get_xlt_octo(umrwr->offset);\n\n\t\tumr->xlt_offset = cpu_to_be16(offset & 0xffff);\n\t\tumr->xlt_offset_47_16 = cpu_to_be32(offset >> 16);\n\t\tumr->flags |= MLX5_UMR_TRANSLATION_OFFSET_EN;\n\t}\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_TRANSLATION)\n\t\tumr->mkey_mask |= get_umr_update_translation_mask();\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_PD_ACCESS) {\n\t\tumr->mkey_mask |= get_umr_update_access_mask(atomic);\n\t\tumr->mkey_mask |= get_umr_update_pd_mask();\n\t}\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_ENABLE_MR)\n\t\tumr->mkey_mask |= get_umr_enable_mr_mask();\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_DISABLE_MR)\n\t\tumr->mkey_mask |= get_umr_disable_mr_mask();\n\n\tif (!wr->num_sge)\n\t\tumr->flags |= MLX5_UMR_INLINE;\n\n\treturn umr_check_mkey_mask(dev, be64_to_cpu(umr->mkey_mask));\n}\n\nstatic u8 get_umr_flags(int acc)\n{\n\treturn (acc & IB_ACCESS_REMOTE_ATOMIC ? MLX5_PERM_ATOMIC       : 0) |\n\t       (acc & IB_ACCESS_REMOTE_WRITE  ? MLX5_PERM_REMOTE_WRITE : 0) |\n\t       (acc & IB_ACCESS_REMOTE_READ   ? MLX5_PERM_REMOTE_READ  : 0) |\n\t       (acc & IB_ACCESS_LOCAL_WRITE   ? MLX5_PERM_LOCAL_WRITE  : 0) |\n\t\tMLX5_PERM_LOCAL_READ | MLX5_PERM_UMR_EN;\n}\n\nstatic void set_reg_mkey_seg(struct mlx5_mkey_seg *seg,\n\t\t\t     struct mlx5_ib_mr *mr,\n\t\t\t     u32 key, int access)\n{\n\tint ndescs = ALIGN(mr->ndescs, 8) >> 1;\n\n\tmemset(seg, 0, sizeof(*seg));\n\n\tif (mr->access_mode == MLX5_MKC_ACCESS_MODE_MTT)\n\t\tseg->log2_page_size = ilog2(mr->ibmr.page_size);\n\telse if (mr->access_mode == MLX5_MKC_ACCESS_MODE_KLMS)\n\t\t/* KLMs take twice the size of MTTs */\n\t\tndescs *= 2;\n\n\tseg->flags = get_umr_flags(access) | mr->access_mode;\n\tseg->qpn_mkey7_0 = cpu_to_be32((key & 0xff) | 0xffffff00);\n\tseg->flags_pd = cpu_to_be32(MLX5_MKEY_REMOTE_INVAL);\n\tseg->start_addr = cpu_to_be64(mr->ibmr.iova);\n\tseg->len = cpu_to_be64(mr->ibmr.length);\n\tseg->xlt_oct_size = cpu_to_be32(ndescs);\n}\n\nstatic void set_linv_mkey_seg(struct mlx5_mkey_seg *seg)\n{\n\tmemset(seg, 0, sizeof(*seg));\n\tseg->status = MLX5_MKEY_STATUS_FREE;\n}\n\nstatic void set_reg_mkey_segment(struct mlx5_mkey_seg *seg,\n\t\t\t\t const struct ib_send_wr *wr)\n{\n\tconst struct mlx5_umr_wr *umrwr = umr_wr(wr);\n\n\tmemset(seg, 0, sizeof(*seg));\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_DISABLE_MR)\n\t\tseg->status = MLX5_MKEY_STATUS_FREE;\n\n\tseg->flags = convert_access(umrwr->access_flags);\n\tif (umrwr->pd)\n\t\tseg->flags_pd = cpu_to_be32(to_mpd(umrwr->pd)->pdn);\n\tif (wr->send_flags & MLX5_IB_SEND_UMR_UPDATE_TRANSLATION &&\n\t    !umrwr->length)\n\t\tseg->flags_pd |= cpu_to_be32(MLX5_MKEY_LEN64);\n\n\tseg->start_addr = cpu_to_be64(umrwr->virt_addr);\n\tseg->len = cpu_to_be64(umrwr->length);\n\tseg->log2_page_size = umrwr->page_shift;\n\tseg->qpn_mkey7_0 = cpu_to_be32(0xffffff00 |\n\t\t\t\t       mlx5_mkey_variant(umrwr->mkey));\n}\n\nstatic void set_reg_data_seg(struct mlx5_wqe_data_seg *dseg,\n\t\t\t     struct mlx5_ib_mr *mr,\n\t\t\t     struct mlx5_ib_pd *pd)\n{\n\tint bcount = mr->desc_size * mr->ndescs;\n\n\tdseg->addr = cpu_to_be64(mr->desc_map);\n\tdseg->byte_count = cpu_to_be32(ALIGN(bcount, 64));\n\tdseg->lkey = cpu_to_be32(pd->ibpd.local_dma_lkey);\n}\n\nstatic void set_reg_umr_inline_seg(void *seg, struct mlx5_ib_qp *qp,\n\t\t\t\t   struct mlx5_ib_mr *mr, int mr_list_size)\n{\n\tvoid *qend = qp->sq.qend;\n\tvoid *addr = mr->descs;\n\tint copy;\n\n\tif (unlikely(seg + mr_list_size > qend)) {\n\t\tcopy = qend - seg;\n\t\tmemcpy(seg, addr, copy);\n\t\taddr += copy;\n\t\tmr_list_size -= copy;\n\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t}\n\tmemcpy(seg, addr, mr_list_size);\n\tseg += mr_list_size;\n}\n\nstatic __be32 send_ieth(const struct ib_send_wr *wr)\n{\n\tswitch (wr->opcode) {\n\tcase IB_WR_SEND_WITH_IMM:\n\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\treturn wr->ex.imm_data;\n\n\tcase IB_WR_SEND_WITH_INV:\n\t\treturn cpu_to_be32(wr->ex.invalidate_rkey);\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 calc_sig(void *wqe, int size)\n{\n\tu8 *p = wqe;\n\tu8 res = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tres ^= p[i];\n\n\treturn ~res;\n}\n\nstatic u8 wq_sig(void *wqe)\n{\n\treturn calc_sig(wqe, (*((u8 *)wqe + 8) & 0x3f) << 4);\n}\n\nstatic int set_data_inl_seg(struct mlx5_ib_qp *qp, const struct ib_send_wr *wr,\n\t\t\t    void *wqe, int *sz)\n{\n\tstruct mlx5_wqe_inline_seg *seg;\n\tvoid *qend = qp->sq.qend;\n\tvoid *addr;\n\tint inl = 0;\n\tint copy;\n\tint len;\n\tint i;\n\n\tseg = wqe;\n\twqe += sizeof(*seg);\n\tfor (i = 0; i < wr->num_sge; i++) {\n\t\taddr = (void *)(unsigned long)(wr->sg_list[i].addr);\n\t\tlen  = wr->sg_list[i].length;\n\t\tinl += len;\n\n\t\tif (unlikely(inl > qp->max_inline_data))\n\t\t\treturn -ENOMEM;\n\n\t\tif (unlikely(wqe + len > qend)) {\n\t\t\tcopy = qend - wqe;\n\t\t\tmemcpy(wqe, addr, copy);\n\t\t\taddr += copy;\n\t\t\tlen -= copy;\n\t\t\twqe = mlx5_get_send_wqe(qp, 0);\n\t\t}\n\t\tmemcpy(wqe, addr, len);\n\t\twqe += len;\n\t}\n\n\tseg->byte_count = cpu_to_be32(inl | MLX5_INLINE_SEG);\n\n\t*sz = ALIGN(inl + sizeof(seg->byte_count), 16) / 16;\n\n\treturn 0;\n}\n\nstatic u16 prot_field_size(enum ib_signature_type type)\n{\n\tswitch (type) {\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\treturn MLX5_DIF_SIZE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 bs_selector(int block_size)\n{\n\tswitch (block_size) {\n\tcase 512:\t    return 0x1;\n\tcase 520:\t    return 0x2;\n\tcase 4096:\t    return 0x3;\n\tcase 4160:\t    return 0x4;\n\tcase 1073741824:    return 0x5;\n\tdefault:\t    return 0;\n\t}\n}\n\nstatic void mlx5_fill_inl_bsf(struct ib_sig_domain *domain,\n\t\t\t      struct mlx5_bsf_inl *inl)\n{\n\t/* Valid inline section and allow BSF refresh */\n\tinl->vld_refresh = cpu_to_be16(MLX5_BSF_INL_VALID |\n\t\t\t\t       MLX5_BSF_REFRESH_DIF);\n\tinl->dif_apptag = cpu_to_be16(domain->sig.dif.app_tag);\n\tinl->dif_reftag = cpu_to_be32(domain->sig.dif.ref_tag);\n\t/* repeating block */\n\tinl->rp_inv_seed = MLX5_BSF_REPEAT_BLOCK;\n\tinl->sig_type = domain->sig.dif.bg_type == IB_T10DIF_CRC ?\n\t\t\tMLX5_DIF_CRC : MLX5_DIF_IPCS;\n\n\tif (domain->sig.dif.ref_remap)\n\t\tinl->dif_inc_ref_guard_check |= MLX5_BSF_INC_REFTAG;\n\n\tif (domain->sig.dif.app_escape) {\n\t\tif (domain->sig.dif.ref_escape)\n\t\t\tinl->dif_inc_ref_guard_check |= MLX5_BSF_APPREF_ESCAPE;\n\t\telse\n\t\t\tinl->dif_inc_ref_guard_check |= MLX5_BSF_APPTAG_ESCAPE;\n\t}\n\n\tinl->dif_app_bitmask_check =\n\t\tcpu_to_be16(domain->sig.dif.apptag_check_mask);\n}\n\nstatic int mlx5_set_bsf(struct ib_mr *sig_mr,\n\t\t\tstruct ib_sig_attrs *sig_attrs,\n\t\t\tstruct mlx5_bsf *bsf, u32 data_size)\n{\n\tstruct mlx5_core_sig_ctx *msig = to_mmr(sig_mr)->sig;\n\tstruct mlx5_bsf_basic *basic = &bsf->basic;\n\tstruct ib_sig_domain *mem = &sig_attrs->mem;\n\tstruct ib_sig_domain *wire = &sig_attrs->wire;\n\n\tmemset(bsf, 0, sizeof(*bsf));\n\n\t/* Basic + Extended + Inline */\n\tbasic->bsf_size_sbs = 1 << 7;\n\t/* Input domain check byte mask */\n\tbasic->check_byte_mask = sig_attrs->check_mask;\n\tbasic->raw_data_size = cpu_to_be32(data_size);\n\n\t/* Memory domain */\n\tswitch (sig_attrs->mem.sig_type) {\n\tcase IB_SIG_TYPE_NONE:\n\t\tbreak;\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\tbasic->mem.bs_selector = bs_selector(mem->sig.dif.pi_interval);\n\t\tbasic->m_bfs_psv = cpu_to_be32(msig->psv_memory.psv_idx);\n\t\tmlx5_fill_inl_bsf(mem, &bsf->m_inl);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Wire domain */\n\tswitch (sig_attrs->wire.sig_type) {\n\tcase IB_SIG_TYPE_NONE:\n\t\tbreak;\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\tif (mem->sig.dif.pi_interval == wire->sig.dif.pi_interval &&\n\t\t    mem->sig_type == wire->sig_type) {\n\t\t\t/* Same block structure */\n\t\t\tbasic->bsf_size_sbs |= 1 << 4;\n\t\t\tif (mem->sig.dif.bg_type == wire->sig.dif.bg_type)\n\t\t\t\tbasic->wire.copy_byte_mask |= MLX5_CPY_GRD_MASK;\n\t\t\tif (mem->sig.dif.app_tag == wire->sig.dif.app_tag)\n\t\t\t\tbasic->wire.copy_byte_mask |= MLX5_CPY_APP_MASK;\n\t\t\tif (mem->sig.dif.ref_tag == wire->sig.dif.ref_tag)\n\t\t\t\tbasic->wire.copy_byte_mask |= MLX5_CPY_REF_MASK;\n\t\t} else\n\t\t\tbasic->wire.bs_selector = bs_selector(wire->sig.dif.pi_interval);\n\n\t\tbasic->w_bfs_psv = cpu_to_be32(msig->psv_wire.psv_idx);\n\t\tmlx5_fill_inl_bsf(wire, &bsf->w_inl);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_sig_data_segment(const struct ib_sig_handover_wr *wr,\n\t\t\t\tstruct mlx5_ib_qp *qp, void **seg, int *size)\n{\n\tstruct ib_sig_attrs *sig_attrs = wr->sig_attrs;\n\tstruct ib_mr *sig_mr = wr->sig_mr;\n\tstruct mlx5_bsf *bsf;\n\tu32 data_len = wr->wr.sg_list->length;\n\tu32 data_key = wr->wr.sg_list->lkey;\n\tu64 data_va = wr->wr.sg_list->addr;\n\tint ret;\n\tint wqe_size;\n\n\tif (!wr->prot ||\n\t    (data_key == wr->prot->lkey &&\n\t     data_va == wr->prot->addr &&\n\t     data_len == wr->prot->length)) {\n\t\t/**\n\t\t * Source domain doesn't contain signature information\n\t\t * or data and protection are interleaved in memory.\n\t\t * So need construct:\n\t\t *                  ------------------\n\t\t *                 |     data_klm     |\n\t\t *                  ------------------\n\t\t *                 |       BSF        |\n\t\t *                  ------------------\n\t\t **/\n\t\tstruct mlx5_klm *data_klm = *seg;\n\n\t\tdata_klm->bcount = cpu_to_be32(data_len);\n\t\tdata_klm->key = cpu_to_be32(data_key);\n\t\tdata_klm->va = cpu_to_be64(data_va);\n\t\twqe_size = ALIGN(sizeof(*data_klm), 64);\n\t} else {\n\t\t/**\n\t\t * Source domain contains signature information\n\t\t * So need construct a strided block format:\n\t\t *               ---------------------------\n\t\t *              |     stride_block_ctrl     |\n\t\t *               ---------------------------\n\t\t *              |          data_klm         |\n\t\t *               ---------------------------\n\t\t *              |          prot_klm         |\n\t\t *               ---------------------------\n\t\t *              |             BSF           |\n\t\t *               ---------------------------\n\t\t **/\n\t\tstruct mlx5_stride_block_ctrl_seg *sblock_ctrl;\n\t\tstruct mlx5_stride_block_entry *data_sentry;\n\t\tstruct mlx5_stride_block_entry *prot_sentry;\n\t\tu32 prot_key = wr->prot->lkey;\n\t\tu64 prot_va = wr->prot->addr;\n\t\tu16 block_size = sig_attrs->mem.sig.dif.pi_interval;\n\t\tint prot_size;\n\n\t\tsblock_ctrl = *seg;\n\t\tdata_sentry = (void *)sblock_ctrl + sizeof(*sblock_ctrl);\n\t\tprot_sentry = (void *)data_sentry + sizeof(*data_sentry);\n\n\t\tprot_size = prot_field_size(sig_attrs->mem.sig_type);\n\t\tif (!prot_size) {\n\t\t\tpr_err(\"Bad block size given: %u\\n\", block_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsblock_ctrl->bcount_per_cycle = cpu_to_be32(block_size +\n\t\t\t\t\t\t\t    prot_size);\n\t\tsblock_ctrl->op = cpu_to_be32(MLX5_STRIDE_BLOCK_OP);\n\t\tsblock_ctrl->repeat_count = cpu_to_be32(data_len / block_size);\n\t\tsblock_ctrl->num_entries = cpu_to_be16(2);\n\n\t\tdata_sentry->bcount = cpu_to_be16(block_size);\n\t\tdata_sentry->key = cpu_to_be32(data_key);\n\t\tdata_sentry->va = cpu_to_be64(data_va);\n\t\tdata_sentry->stride = cpu_to_be16(block_size);\n\n\t\tprot_sentry->bcount = cpu_to_be16(prot_size);\n\t\tprot_sentry->key = cpu_to_be32(prot_key);\n\t\tprot_sentry->va = cpu_to_be64(prot_va);\n\t\tprot_sentry->stride = cpu_to_be16(prot_size);\n\n\t\twqe_size = ALIGN(sizeof(*sblock_ctrl) + sizeof(*data_sentry) +\n\t\t\t\t sizeof(*prot_sentry), 64);\n\t}\n\n\t*seg += wqe_size;\n\t*size += wqe_size / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tbsf = *seg;\n\tret = mlx5_set_bsf(sig_mr, sig_attrs, bsf, data_len);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t*seg += sizeof(*bsf);\n\t*size += sizeof(*bsf) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\treturn 0;\n}\n\nstatic void set_sig_mkey_segment(struct mlx5_mkey_seg *seg,\n\t\t\t\t const struct ib_sig_handover_wr *wr, u32 size,\n\t\t\t\t u32 length, u32 pdn)\n{\n\tstruct ib_mr *sig_mr = wr->sig_mr;\n\tu32 sig_key = sig_mr->rkey;\n\tu8 sigerr = to_mmr(sig_mr)->sig->sigerr_count & 1;\n\n\tmemset(seg, 0, sizeof(*seg));\n\n\tseg->flags = get_umr_flags(wr->access_flags) |\n\t\t\t\t   MLX5_MKC_ACCESS_MODE_KLMS;\n\tseg->qpn_mkey7_0 = cpu_to_be32((sig_key & 0xff) | 0xffffff00);\n\tseg->flags_pd = cpu_to_be32(MLX5_MKEY_REMOTE_INVAL | sigerr << 26 |\n\t\t\t\t    MLX5_MKEY_BSF_EN | pdn);\n\tseg->len = cpu_to_be64(length);\n\tseg->xlt_oct_size = cpu_to_be32(get_xlt_octo(size));\n\tseg->bsfs_octo_size = cpu_to_be32(MLX5_MKEY_BSF_OCTO_SIZE);\n}\n\nstatic void set_sig_umr_segment(struct mlx5_wqe_umr_ctrl_seg *umr,\n\t\t\t\tu32 size)\n{\n\tmemset(umr, 0, sizeof(*umr));\n\n\tumr->flags = MLX5_FLAGS_INLINE | MLX5_FLAGS_CHECK_FREE;\n\tumr->xlt_octowords = cpu_to_be16(get_xlt_octo(size));\n\tumr->bsf_octowords = cpu_to_be16(MLX5_MKEY_BSF_OCTO_SIZE);\n\tumr->mkey_mask = sig_mkey_mask();\n}\n\n\nstatic int set_sig_umr_wr(const struct ib_send_wr *send_wr,\n\t\t\t  struct mlx5_ib_qp *qp, void **seg, int *size)\n{\n\tconst struct ib_sig_handover_wr *wr = sig_handover_wr(send_wr);\n\tstruct mlx5_ib_mr *sig_mr = to_mmr(wr->sig_mr);\n\tu32 pdn = get_pd(qp)->pdn;\n\tu32 xlt_size;\n\tint region_len, ret;\n\n\tif (unlikely(wr->wr.num_sge != 1) ||\n\t    unlikely(wr->access_flags & IB_ACCESS_REMOTE_ATOMIC) ||\n\t    unlikely(!sig_mr->sig) || unlikely(!qp->signature_en) ||\n\t    unlikely(!sig_mr->sig->sig_status_checked))\n\t\treturn -EINVAL;\n\n\t/* length of the protected region, data + protection */\n\tregion_len = wr->wr.sg_list->length;\n\tif (wr->prot &&\n\t    (wr->prot->lkey != wr->wr.sg_list->lkey  ||\n\t     wr->prot->addr != wr->wr.sg_list->addr  ||\n\t     wr->prot->length != wr->wr.sg_list->length))\n\t\tregion_len += wr->prot->length;\n\n\t/**\n\t * KLM octoword size - if protection was provided\n\t * then we use strided block format (3 octowords),\n\t * else we use single KLM (1 octoword)\n\t **/\n\txlt_size = wr->prot ? 0x30 : sizeof(struct mlx5_klm);\n\n\tset_sig_umr_segment(*seg, xlt_size);\n\t*seg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t*size += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tset_sig_mkey_segment(*seg, wr, xlt_size, region_len, pdn);\n\t*seg += sizeof(struct mlx5_mkey_seg);\n\t*size += sizeof(struct mlx5_mkey_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tret = set_sig_data_segment(wr, qp, seg, size);\n\tif (ret)\n\t\treturn ret;\n\n\tsig_mr->sig->sig_status_checked = false;\n\treturn 0;\n}\n\nstatic int set_psv_wr(struct ib_sig_domain *domain,\n\t\t      u32 psv_idx, void **seg, int *size)\n{\n\tstruct mlx5_seg_set_psv *psv_seg = *seg;\n\n\tmemset(psv_seg, 0, sizeof(*psv_seg));\n\tpsv_seg->psv_num = cpu_to_be32(psv_idx);\n\tswitch (domain->sig_type) {\n\tcase IB_SIG_TYPE_NONE:\n\t\tbreak;\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\tpsv_seg->transient_sig = cpu_to_be32(domain->sig.dif.bg << 16 |\n\t\t\t\t\t\t     domain->sig.dif.app_tag);\n\t\tpsv_seg->ref_tag = cpu_to_be32(domain->sig.dif.ref_tag);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Bad signature type (%d) is given.\\n\",\n\t\t       domain->sig_type);\n\t\treturn -EINVAL;\n\t}\n\n\t*seg += sizeof(*psv_seg);\n\t*size += sizeof(*psv_seg) / 16;\n\n\treturn 0;\n}\n\nstatic int set_reg_wr(struct mlx5_ib_qp *qp,\n\t\t      const struct ib_reg_wr *wr,\n\t\t      void **seg, int *size)\n{\n\tstruct mlx5_ib_mr *mr = to_mmr(wr->mr);\n\tstruct mlx5_ib_pd *pd = to_mpd(qp->ibqp.pd);\n\tint mr_list_size = mr->ndescs * mr->desc_size;\n\tbool umr_inline = mr_list_size <= MLX5_IB_SQ_UMR_INLINE_THRESHOLD;\n\n\tif (unlikely(wr->wr.send_flags & IB_SEND_INLINE)) {\n\t\tmlx5_ib_warn(to_mdev(qp->ibqp.device),\n\t\t\t     \"Invalid IB_SEND_INLINE send flag\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset_reg_umr_seg(*seg, mr, umr_inline);\n\t*seg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t*size += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tset_reg_mkey_seg(*seg, mr, wr->key, wr->access);\n\t*seg += sizeof(struct mlx5_mkey_seg);\n\t*size += sizeof(struct mlx5_mkey_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\n\tif (umr_inline) {\n\t\tset_reg_umr_inline_seg(*seg, qp, mr, mr_list_size);\n\t\t*size += get_xlt_octo(mr_list_size);\n\t} else {\n\t\tset_reg_data_seg(*seg, mr, pd);\n\t\t*seg += sizeof(struct mlx5_wqe_data_seg);\n\t\t*size += (sizeof(struct mlx5_wqe_data_seg) / 16);\n\t}\n\treturn 0;\n}\n\nstatic void set_linv_wr(struct mlx5_ib_qp *qp, void **seg, int *size)\n{\n\tset_linv_umr_seg(*seg);\n\t*seg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t*size += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n\tset_linv_mkey_seg(*seg);\n\t*seg += sizeof(struct mlx5_mkey_seg);\n\t*size += sizeof(struct mlx5_mkey_seg) / 16;\n\tif (unlikely((*seg == qp->sq.qend)))\n\t\t*seg = mlx5_get_send_wqe(qp, 0);\n}\n\nstatic void dump_wqe(struct mlx5_ib_qp *qp, int idx, int size_16)\n{\n\t__be32 *p = NULL;\n\tint tidx = idx;\n\tint i, j;\n\n\tpr_debug(\"dump wqe at %p\\n\", mlx5_get_send_wqe(qp, tidx));\n\tfor (i = 0, j = 0; i < size_16 * 4; i += 4, j += 4) {\n\t\tif ((i & 0xf) == 0) {\n\t\t\tvoid *buf = mlx5_get_send_wqe(qp, tidx);\n\t\t\ttidx = (tidx + 1) & (qp->sq.wqe_cnt - 1);\n\t\t\tp = buf;\n\t\t\tj = 0;\n\t\t}\n\t\tpr_debug(\"%08x %08x %08x %08x\\n\", be32_to_cpu(p[j]),\n\t\t\t be32_to_cpu(p[j + 1]), be32_to_cpu(p[j + 2]),\n\t\t\t be32_to_cpu(p[j + 3]));\n\t}\n}\n\nstatic int __begin_wqe(struct mlx5_ib_qp *qp, void **seg,\n\t\t     struct mlx5_wqe_ctrl_seg **ctrl,\n\t\t     const struct ib_send_wr *wr, unsigned *idx,\n\t\t     int *size, int nreq, bool send_signaled, bool solicited)\n{\n\tif (unlikely(mlx5_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)))\n\t\treturn -ENOMEM;\n\n\t*idx = qp->sq.cur_post & (qp->sq.wqe_cnt - 1);\n\t*seg = mlx5_get_send_wqe(qp, *idx);\n\t*ctrl = *seg;\n\t*(uint32_t *)(*seg + 8) = 0;\n\t(*ctrl)->imm = send_ieth(wr);\n\t(*ctrl)->fm_ce_se = qp->sq_signal_bits |\n\t\t(send_signaled ? MLX5_WQE_CTRL_CQ_UPDATE : 0) |\n\t\t(solicited ? MLX5_WQE_CTRL_SOLICITED : 0);\n\n\t*seg += sizeof(**ctrl);\n\t*size = sizeof(**ctrl) / 16;\n\n\treturn 0;\n}\n\nstatic int begin_wqe(struct mlx5_ib_qp *qp, void **seg,\n\t\t     struct mlx5_wqe_ctrl_seg **ctrl,\n\t\t     const struct ib_send_wr *wr, unsigned *idx,\n\t\t     int *size, int nreq)\n{\n\treturn __begin_wqe(qp, seg, ctrl, wr, idx, size, nreq,\n\t\t\t   wr->send_flags & IB_SEND_SIGNALED,\n\t\t\t   wr->send_flags & IB_SEND_SOLICITED);\n}\n\nstatic void finish_wqe(struct mlx5_ib_qp *qp,\n\t\t       struct mlx5_wqe_ctrl_seg *ctrl,\n\t\t       u8 size, unsigned idx, u64 wr_id,\n\t\t       int nreq, u8 fence, u32 mlx5_opcode)\n{\n\tu8 opmod = 0;\n\n\tctrl->opmod_idx_opcode = cpu_to_be32(((u32)(qp->sq.cur_post) << 8) |\n\t\t\t\t\t     mlx5_opcode | ((u32)opmod << 24));\n\tctrl->qpn_ds = cpu_to_be32(size | (qp->trans_qp.base.mqp.qpn << 8));\n\tctrl->fm_ce_se |= fence;\n\tif (unlikely(qp->wq_sig))\n\t\tctrl->signature = wq_sig(ctrl);\n\n\tqp->sq.wrid[idx] = wr_id;\n\tqp->sq.w_list[idx].opcode = mlx5_opcode;\n\tqp->sq.wqe_head[idx] = qp->sq.head + nreq;\n\tqp->sq.cur_post += DIV_ROUND_UP(size * 16, MLX5_SEND_WQE_BB);\n\tqp->sq.w_list[idx].next = qp->sq.cur_post;\n}\n\nstatic int _mlx5_ib_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t\t      const struct ib_send_wr **bad_wr, bool drain)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl = NULL;  /* compiler warning */\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_qp *qp;\n\tstruct mlx5_ib_mr *mr;\n\tstruct mlx5_wqe_data_seg *dpseg;\n\tstruct mlx5_wqe_xrc_seg *xrc;\n\tstruct mlx5_bf *bf;\n\tint uninitialized_var(size);\n\tvoid *qend;\n\tunsigned long flags;\n\tunsigned idx;\n\tint err = 0;\n\tint num_sge;\n\tvoid *seg;\n\tint nreq;\n\tint i;\n\tu8 next_fence = 0;\n\tu8 fence;\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_post_send(ibqp, wr, bad_wr);\n\n\tqp = to_mqp(ibqp);\n\tbf = &qp->bf;\n\tqend = qp->sq.qend;\n\n\tspin_lock_irqsave(&qp->sq.lock, flags);\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR && !drain) {\n\t\terr = -EIO;\n\t\t*bad_wr = wr;\n\t\tnreq = 0;\n\t\tgoto out;\n\t}\n\n\tfor (nreq = 0; wr; nreq++, wr = wr->next) {\n\t\tif (unlikely(wr->opcode >= ARRAY_SIZE(mlx5_ib_opcode))) {\n\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_sge = wr->num_sge;\n\t\tif (unlikely(num_sge > qp->sq.max_gs)) {\n\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = begin_wqe(qp, &seg, &ctrl, wr, &idx, &size, nreq);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (wr->opcode == IB_WR_LOCAL_INV ||\n\t\t    wr->opcode == IB_WR_REG_MR) {\n\t\t\tfence = dev->umr_fence;\n\t\t\tnext_fence = MLX5_FENCE_MODE_INITIATOR_SMALL;\n\t\t} else if (wr->send_flags & IB_SEND_FENCE) {\n\t\t\tif (qp->next_fence)\n\t\t\t\tfence = MLX5_FENCE_MODE_SMALL_AND_FENCE;\n\t\t\telse\n\t\t\t\tfence = MLX5_FENCE_MODE_FENCE;\n\t\t} else {\n\t\t\tfence = qp->next_fence;\n\t\t}\n\n\t\tswitch (ibqp->qp_type) {\n\t\tcase IB_QPT_XRC_INI:\n\t\t\txrc = seg;\n\t\t\tseg += sizeof(*xrc);\n\t\t\tsize += sizeof(*xrc) / 16;\n\t\t\t/* fall through */\n\t\tcase IB_QPT_RC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_RDMA_READ:\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(seg, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\tseg += sizeof(struct mlx5_wqe_raddr_seg);\n\t\t\t\tsize += sizeof(struct mlx5_wqe_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\tcase IB_WR_MASKED_ATOMIC_CMP_AND_SWP:\n\t\t\t\tmlx5_ib_warn(dev, \"Atomic operations are not supported yet\\n\");\n\t\t\t\terr = -ENOSYS;\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\n\t\t\tcase IB_WR_LOCAL_INV:\n\t\t\t\tqp->sq.wr_data[idx] = IB_WR_LOCAL_INV;\n\t\t\t\tctrl->imm = cpu_to_be32(wr->ex.invalidate_rkey);\n\t\t\t\tset_linv_wr(qp, &seg, &size);\n\t\t\t\tnum_sge = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_REG_MR:\n\t\t\t\tqp->sq.wr_data[idx] = IB_WR_REG_MR;\n\t\t\t\tctrl->imm = cpu_to_be32(reg_wr(wr)->key);\n\t\t\t\terr = set_reg_wr(qp, reg_wr(wr), &seg, &size);\n\t\t\t\tif (err) {\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tnum_sge = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_REG_SIG_MR:\n\t\t\t\tqp->sq.wr_data[idx] = IB_WR_REG_SIG_MR;\n\t\t\t\tmr = to_mmr(sig_handover_wr(wr)->sig_mr);\n\n\t\t\t\tctrl->imm = cpu_to_be32(mr->ibmr.rkey);\n\t\t\t\terr = set_sig_umr_wr(wr, qp, &seg, &size);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq,\n\t\t\t\t\t   fence, MLX5_OPCODE_UMR);\n\t\t\t\t/*\n\t\t\t\t * SET_PSV WQEs are not signaled and solicited\n\t\t\t\t * on error\n\t\t\t\t */\n\t\t\t\terr = __begin_wqe(qp, &seg, &ctrl, wr, &idx,\n\t\t\t\t\t\t  &size, nreq, false, true);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\terr = set_psv_wr(&sig_handover_wr(wr)->sig_attrs->mem,\n\t\t\t\t\t\t mr->sig->psv_memory.psv_idx, &seg,\n\t\t\t\t\t\t &size);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq,\n\t\t\t\t\t   fence, MLX5_OPCODE_SET_PSV);\n\t\t\t\terr = __begin_wqe(qp, &seg, &ctrl, wr, &idx,\n\t\t\t\t\t\t  &size, nreq, false, true);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\terr = set_psv_wr(&sig_handover_wr(wr)->sig_attrs->wire,\n\t\t\t\t\t\t mr->sig->psv_wire.psv_idx, &seg,\n\t\t\t\t\t\t &size);\n\t\t\t\tif (err) {\n\t\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq,\n\t\t\t\t\t   fence, MLX5_OPCODE_SET_PSV);\n\t\t\t\tqp->next_fence = MLX5_FENCE_MODE_INITIATOR_SMALL;\n\t\t\t\tnum_sge = 0;\n\t\t\t\tgoto skip_psv;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_QPT_UC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(seg, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\tseg  += sizeof(struct mlx5_wqe_raddr_seg);\n\t\t\t\tsize += sizeof(struct mlx5_wqe_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_QPT_SMI:\n\t\t\tif (unlikely(!mdev->port_caps[qp->port - 1].has_smi)) {\n\t\t\t\tmlx5_ib_warn(dev, \"Send SMP MADs is not allowed\\n\");\n\t\t\t\terr = -EPERM;\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase MLX5_IB_QPT_HW_GSI:\n\t\t\tset_datagram_seg(seg, wr);\n\t\t\tseg += sizeof(struct mlx5_wqe_datagram_seg);\n\t\t\tsize += sizeof(struct mlx5_wqe_datagram_seg) / 16;\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tbreak;\n\t\tcase IB_QPT_UD:\n\t\t\tset_datagram_seg(seg, wr);\n\t\t\tseg += sizeof(struct mlx5_wqe_datagram_seg);\n\t\t\tsize += sizeof(struct mlx5_wqe_datagram_seg) / 16;\n\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\n\t\t\t/* handle qp that supports ud offload */\n\t\t\tif (qp->flags & IB_QP_CREATE_IPOIB_UD_LSO) {\n\t\t\t\tstruct mlx5_wqe_eth_pad *pad;\n\n\t\t\t\tpad = seg;\n\t\t\t\tmemset(pad, 0, sizeof(struct mlx5_wqe_eth_pad));\n\t\t\t\tseg += sizeof(struct mlx5_wqe_eth_pad);\n\t\t\t\tsize += sizeof(struct mlx5_wqe_eth_pad) / 16;\n\n\t\t\t\tseg = set_eth_seg(seg, wr, qend, qp, &size);\n\n\t\t\t\tif (unlikely((seg == qend)))\n\t\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MLX5_IB_QPT_REG_UMR:\n\t\t\tif (wr->opcode != MLX5_IB_WR_UMR) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tmlx5_ib_warn(dev, \"bad opcode\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tqp->sq.wr_data[idx] = MLX5_IB_WR_UMR;\n\t\t\tctrl->imm = cpu_to_be32(umr_wr(wr)->mkey);\n\t\t\terr = set_reg_umr_segment(dev, seg, wr, !!(MLX5_CAP_GEN(mdev, atomic)));\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out;\n\t\t\tseg += sizeof(struct mlx5_wqe_umr_ctrl_seg);\n\t\t\tsize += sizeof(struct mlx5_wqe_umr_ctrl_seg) / 16;\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tset_reg_mkey_segment(seg, wr);\n\t\t\tseg += sizeof(struct mlx5_mkey_seg);\n\t\t\tsize += sizeof(struct mlx5_mkey_seg) / 16;\n\t\t\tif (unlikely((seg == qend)))\n\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wr->send_flags & IB_SEND_INLINE && num_sge) {\n\t\t\tint uninitialized_var(sz);\n\n\t\t\terr = set_data_inl_seg(qp, wr, seg, &sz);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tmlx5_ib_warn(dev, \"\\n\");\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsize += sz;\n\t\t} else {\n\t\t\tdpseg = seg;\n\t\t\tfor (i = 0; i < num_sge; i++) {\n\t\t\t\tif (unlikely(dpseg == qend)) {\n\t\t\t\t\tseg = mlx5_get_send_wqe(qp, 0);\n\t\t\t\t\tdpseg = seg;\n\t\t\t\t}\n\t\t\t\tif (likely(wr->sg_list[i].length)) {\n\t\t\t\t\tset_data_ptr_seg(dpseg, wr->sg_list + i);\n\t\t\t\t\tsize += sizeof(struct mlx5_wqe_data_seg) / 16;\n\t\t\t\t\tdpseg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqp->next_fence = next_fence;\n\t\tfinish_wqe(qp, ctrl, size, idx, wr->wr_id, nreq, fence,\n\t\t\t   mlx5_ib_opcode[wr->opcode]);\nskip_psv:\n\t\tif (0)\n\t\t\tdump_wqe(qp, idx, size);\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tqp->sq.head += nreq;\n\n\t\t/* Make sure that descriptors are written before\n\t\t * updating doorbell record and ringing the doorbell\n\t\t */\n\t\twmb();\n\n\t\tqp->db.db[MLX5_SND_DBR] = cpu_to_be32(qp->sq.cur_post);\n\n\t\t/* Make sure doorbell record is visible to the HCA before\n\t\t * we hit doorbell */\n\t\twmb();\n\n\t\t/* currently we support only regular doorbells */\n\t\tmlx5_write64((__be32 *)ctrl, bf->bfreg->map + bf->offset, NULL);\n\t\t/* Make sure doorbells don't leak out of SQ spinlock\n\t\t * and reach the HCA out of order.\n\t\t */\n\t\tmmiowb();\n\t\tbf->offset ^= bf->buf_size;\n\t}\n\n\tspin_unlock_irqrestore(&qp->sq.lock, flags);\n\n\treturn err;\n}\n\nint mlx5_ib_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t      const struct ib_send_wr **bad_wr)\n{\n\treturn _mlx5_ib_post_send(ibqp, wr, bad_wr, false);\n}\n\nstatic void set_sig_seg(struct mlx5_rwqe_sig *sig, int size)\n{\n\tsig->signature = calc_sig(sig, size);\n}\n\nstatic int _mlx5_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t      const struct ib_recv_wr **bad_wr, bool drain)\n{\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_wqe_data_seg *scat;\n\tstruct mlx5_rwqe_sig *sig;\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint ind;\n\tint i;\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_post_recv(ibqp, wr, bad_wr);\n\n\tspin_lock_irqsave(&qp->rq.lock, flags);\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR && !drain) {\n\t\terr = -EIO;\n\t\t*bad_wr = wr;\n\t\tnreq = 0;\n\t\tgoto out;\n\t}\n\n\tind = qp->rq.head & (qp->rq.wqe_cnt - 1);\n\n\tfor (nreq = 0; wr; nreq++, wr = wr->next) {\n\t\tif (mlx5_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (unlikely(wr->num_sge > qp->rq.max_gs)) {\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tscat = get_recv_wqe(qp, ind);\n\t\tif (qp->wq_sig)\n\t\t\tscat++;\n\n\t\tfor (i = 0; i < wr->num_sge; i++)\n\t\t\tset_data_ptr_seg(scat + i, wr->sg_list + i);\n\n\t\tif (i < qp->rq.max_gs) {\n\t\t\tscat[i].byte_count = 0;\n\t\t\tscat[i].lkey       = cpu_to_be32(MLX5_INVALID_LKEY);\n\t\t\tscat[i].addr       = 0;\n\t\t}\n\n\t\tif (qp->wq_sig) {\n\t\t\tsig = (struct mlx5_rwqe_sig *)scat;\n\t\t\tset_sig_seg(sig, (qp->rq.max_gs + 1) << 2);\n\t\t}\n\n\t\tqp->rq.wrid[ind] = wr->wr_id;\n\n\t\tind = (ind + 1) & (qp->rq.wqe_cnt - 1);\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tqp->rq.head += nreq;\n\n\t\t/* Make sure that descriptors are written before\n\t\t * doorbell record.\n\t\t */\n\t\twmb();\n\n\t\t*qp->db.db = cpu_to_be32(qp->rq.head & 0xffff);\n\t}\n\n\tspin_unlock_irqrestore(&qp->rq.lock, flags);\n\n\treturn err;\n}\n\nint mlx5_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t      const struct ib_recv_wr **bad_wr)\n{\n\treturn _mlx5_ib_post_recv(ibqp, wr, bad_wr, false);\n}\n\nstatic inline enum ib_qp_state to_ib_qp_state(enum mlx5_qp_state mlx5_state)\n{\n\tswitch (mlx5_state) {\n\tcase MLX5_QP_STATE_RST:      return IB_QPS_RESET;\n\tcase MLX5_QP_STATE_INIT:     return IB_QPS_INIT;\n\tcase MLX5_QP_STATE_RTR:      return IB_QPS_RTR;\n\tcase MLX5_QP_STATE_RTS:      return IB_QPS_RTS;\n\tcase MLX5_QP_STATE_SQ_DRAINING:\n\tcase MLX5_QP_STATE_SQD:      return IB_QPS_SQD;\n\tcase MLX5_QP_STATE_SQER:     return IB_QPS_SQE;\n\tcase MLX5_QP_STATE_ERR:      return IB_QPS_ERR;\n\tdefault:\t\t     return -1;\n\t}\n}\n\nstatic inline enum ib_mig_state to_ib_mig_state(int mlx5_mig_state)\n{\n\tswitch (mlx5_mig_state) {\n\tcase MLX5_QP_PM_ARMED:\t\treturn IB_MIG_ARMED;\n\tcase MLX5_QP_PM_REARM:\t\treturn IB_MIG_REARM;\n\tcase MLX5_QP_PM_MIGRATED:\treturn IB_MIG_MIGRATED;\n\tdefault: return -1;\n\t}\n}\n\nstatic int to_ib_qp_access_flags(int mlx5_flags)\n{\n\tint ib_flags = 0;\n\n\tif (mlx5_flags & MLX5_QP_BIT_RRE)\n\t\tib_flags |= IB_ACCESS_REMOTE_READ;\n\tif (mlx5_flags & MLX5_QP_BIT_RWE)\n\t\tib_flags |= IB_ACCESS_REMOTE_WRITE;\n\tif (mlx5_flags & MLX5_QP_BIT_RAE)\n\t\tib_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\n\treturn ib_flags;\n}\n\nstatic void to_rdma_ah_attr(struct mlx5_ib_dev *ibdev,\n\t\t\t    struct rdma_ah_attr *ah_attr,\n\t\t\t    struct mlx5_qp_path *path)\n{\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\n\tif (!path->port || path->port > ibdev->num_ports)\n\t\treturn;\n\n\tah_attr->type = rdma_ah_find_type(&ibdev->ib_dev, path->port);\n\n\trdma_ah_set_port_num(ah_attr, path->port);\n\trdma_ah_set_sl(ah_attr, path->dci_cfi_prio_sl & 0xf);\n\n\trdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));\n\trdma_ah_set_path_bits(ah_attr, path->grh_mlid & 0x7f);\n\trdma_ah_set_static_rate(ah_attr,\n\t\t\t\tpath->static_rate ? path->static_rate - 5 : 0);\n\tif (path->grh_mlid & (1 << 7)) {\n\t\tu32 tc_fl = be32_to_cpu(path->tclass_flowlabel);\n\n\t\trdma_ah_set_grh(ah_attr, NULL,\n\t\t\t\ttc_fl & 0xfffff,\n\t\t\t\tpath->mgid_index,\n\t\t\t\tpath->hop_limit,\n\t\t\t\t(tc_fl >> 20) & 0xff);\n\t\trdma_ah_set_dgid_raw(ah_attr, path->rgid);\n\t}\n}\n\nstatic int query_raw_packet_qp_sq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_sq *sq,\n\t\t\t\t\tu8 *sq_state)\n{\n\tint err;\n\n\terr = mlx5_core_query_sq_state(dev->mdev, sq->base.mqp.qpn, sq_state);\n\tif (err)\n\t\tgoto out;\n\tsq->state = *sq_state;\n\nout:\n\treturn err;\n}\n\nstatic int query_raw_packet_qp_rq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_rq *rq,\n\t\t\t\t\tu8 *rq_state)\n{\n\tvoid *out;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(query_rq_out);\n\tout = kvzalloc(inlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_query_rq(dev->mdev, rq->base.mqp.qpn, out);\n\tif (err)\n\t\tgoto out;\n\n\trqc = MLX5_ADDR_OF(query_rq_out, out, rq_context);\n\t*rq_state = MLX5_GET(rqc, rqc, state);\n\trq->state = *rq_state;\n\nout:\n\tkvfree(out);\n\treturn err;\n}\n\nstatic int sqrq_state_to_qp_state(u8 sq_state, u8 rq_state,\n\t\t\t\t  struct mlx5_ib_qp *qp, u8 *qp_state)\n{\n\tstatic const u8 sqrq_trans[MLX5_RQ_NUM_STATE][MLX5_SQ_NUM_STATE] = {\n\t\t[MLX5_RQC_STATE_RST] = {\n\t\t\t[MLX5_SQC_STATE_RST]\t= IB_QPS_RESET,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQ_STATE_NA]\t= IB_QPS_RESET,\n\t\t},\n\t\t[MLX5_RQC_STATE_RDY] = {\n\t\t\t[MLX5_SQC_STATE_RST]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= IB_QPS_SQE,\n\t\t\t[MLX5_SQ_STATE_NA]\t= MLX5_QP_STATE,\n\t\t},\n\t\t[MLX5_RQC_STATE_ERR] = {\n\t\t\t[MLX5_SQC_STATE_RST]    = MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= IB_QPS_ERR,\n\t\t\t[MLX5_SQ_STATE_NA]\t= IB_QPS_ERR,\n\t\t},\n\t\t[MLX5_RQ_STATE_NA] = {\n\t\t\t[MLX5_SQC_STATE_RST]    = IB_QPS_RESET,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQ_STATE_NA]\t= MLX5_QP_STATE_BAD,\n\t\t},\n\t};\n\n\t*qp_state = sqrq_trans[rq_state][sq_state];\n\n\tif (*qp_state == MLX5_QP_STATE_BAD) {\n\t\tWARN(1, \"Buggy Raw Packet QP state, SQ 0x%x state: 0x%x, RQ 0x%x state: 0x%x\",\n\t\t     qp->raw_packet_qp.sq.base.mqp.qpn, sq_state,\n\t\t     qp->raw_packet_qp.rq.base.mqp.qpn, rq_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*qp_state == MLX5_QP_STATE)\n\t\t*qp_state = qp->state;\n\n\treturn 0;\n}\n\nstatic int query_raw_packet_qp_state(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_qp *qp,\n\t\t\t\t     u8 *raw_packet_qp_state)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tint err;\n\tu8 sq_state = MLX5_SQ_STATE_NA;\n\tu8 rq_state = MLX5_RQ_STATE_NA;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_sq_state(dev, sq, &sq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_rq_state(dev, rq, &rq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn sqrq_state_to_qp_state(sq_state, rq_state, qp,\n\t\t\t\t      raw_packet_qp_state);\n}\n\nstatic int query_qp_attr(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t struct ib_qp_attr *qp_attr)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_qp_out);\n\tstruct mlx5_qp_context *context;\n\tint mlx5_state;\n\tu32 *outb;\n\tint err = 0;\n\n\toutb = kzalloc(outlen, GFP_KERNEL);\n\tif (!outb)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_qp_query(dev->mdev, &qp->trans_qp.base.mqp, outb,\n\t\t\t\t outlen);\n\tif (err)\n\t\tgoto out;\n\n\t/* FIXME: use MLX5_GET rather than mlx5_qp_context manual struct */\n\tcontext = (struct mlx5_qp_context *)MLX5_ADDR_OF(query_qp_out, outb, qpc);\n\n\tmlx5_state = be32_to_cpu(context->flags) >> 28;\n\n\tqp->state\t\t     = to_ib_qp_state(mlx5_state);\n\tqp_attr->path_mtu\t     = context->mtu_msgmax >> 5;\n\tqp_attr->path_mig_state\t     =\n\t\tto_ib_mig_state((be32_to_cpu(context->flags) >> 11) & 0x3);\n\tqp_attr->qkey\t\t     = be32_to_cpu(context->qkey);\n\tqp_attr->rq_psn\t\t     = be32_to_cpu(context->rnr_nextrecvpsn) & 0xffffff;\n\tqp_attr->sq_psn\t\t     = be32_to_cpu(context->next_send_psn) & 0xffffff;\n\tqp_attr->dest_qp_num\t     = be32_to_cpu(context->log_pg_sz_remote_qpn) & 0xffffff;\n\tqp_attr->qp_access_flags     =\n\t\tto_ib_qp_access_flags(be32_to_cpu(context->params2));\n\n\tif (qp->ibqp.qp_type == IB_QPT_RC || qp->ibqp.qp_type == IB_QPT_UC) {\n\t\tto_rdma_ah_attr(dev, &qp_attr->ah_attr, &context->pri_path);\n\t\tto_rdma_ah_attr(dev, &qp_attr->alt_ah_attr, &context->alt_path);\n\t\tqp_attr->alt_pkey_index =\n\t\t\tbe16_to_cpu(context->alt_path.pkey_index);\n\t\tqp_attr->alt_port_num\t=\n\t\t\trdma_ah_get_port_num(&qp_attr->alt_ah_attr);\n\t}\n\n\tqp_attr->pkey_index = be16_to_cpu(context->pri_path.pkey_index);\n\tqp_attr->port_num = context->pri_path.port;\n\n\t/* qp_attr->en_sqd_async_notify is only applicable in modify qp */\n\tqp_attr->sq_draining = mlx5_state == MLX5_QP_STATE_SQ_DRAINING;\n\n\tqp_attr->max_rd_atomic = 1 << ((be32_to_cpu(context->params1) >> 21) & 0x7);\n\n\tqp_attr->max_dest_rd_atomic =\n\t\t1 << ((be32_to_cpu(context->params2) >> 21) & 0x7);\n\tqp_attr->min_rnr_timer\t    =\n\t\t(be32_to_cpu(context->rnr_nextrecvpsn) >> 24) & 0x1f;\n\tqp_attr->timeout\t    = context->pri_path.ackto_lt >> 3;\n\tqp_attr->retry_cnt\t    = (be32_to_cpu(context->params1) >> 16) & 0x7;\n\tqp_attr->rnr_retry\t    = (be32_to_cpu(context->params1) >> 13) & 0x7;\n\tqp_attr->alt_timeout\t    = context->alt_path.ackto_lt >> 3;\n\nout:\n\tkfree(outb);\n\treturn err;\n}\n\nstatic int mlx5_ib_dct_query_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *mqp,\n\t\t\t\tstruct ib_qp_attr *qp_attr, int qp_attr_mask,\n\t\t\t\tstruct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_core_dct\t*dct = &mqp->dct.mdct;\n\tu32 *out;\n\tu32 access_flags = 0;\n\tint outlen = MLX5_ST_SZ_BYTES(query_dct_out);\n\tvoid *dctc;\n\tint err;\n\tint supported_mask = IB_QP_STATE |\n\t\t\t     IB_QP_ACCESS_FLAGS |\n\t\t\t     IB_QP_PORT |\n\t\t\t     IB_QP_MIN_RNR_TIMER |\n\t\t\t     IB_QP_AV |\n\t\t\t     IB_QP_PATH_MTU |\n\t\t\t     IB_QP_PKEY_INDEX;\n\n\tif (qp_attr_mask & ~supported_mask)\n\t\treturn -EINVAL;\n\tif (mqp->state != IB_QPS_RTR)\n\t\treturn -EINVAL;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_dct_query(dev->mdev, dct, out, outlen);\n\tif (err)\n\t\tgoto out;\n\n\tdctc = MLX5_ADDR_OF(query_dct_out, out, dct_context_entry);\n\n\tif (qp_attr_mask & IB_QP_STATE)\n\t\tqp_attr->qp_state = IB_QPS_RTR;\n\n\tif (qp_attr_mask & IB_QP_ACCESS_FLAGS) {\n\t\tif (MLX5_GET(dctc, dctc, rre))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_READ;\n\t\tif (MLX5_GET(dctc, dctc, rwe))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_WRITE;\n\t\tif (MLX5_GET(dctc, dctc, rae))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\t\tqp_attr->qp_access_flags = access_flags;\n\t}\n\n\tif (qp_attr_mask & IB_QP_PORT)\n\t\tqp_attr->port_num = MLX5_GET(dctc, dctc, port);\n\tif (qp_attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tqp_attr->min_rnr_timer = MLX5_GET(dctc, dctc, min_rnr_nak);\n\tif (qp_attr_mask & IB_QP_AV) {\n\t\tqp_attr->ah_attr.grh.traffic_class = MLX5_GET(dctc, dctc, tclass);\n\t\tqp_attr->ah_attr.grh.flow_label = MLX5_GET(dctc, dctc, flow_label);\n\t\tqp_attr->ah_attr.grh.sgid_index = MLX5_GET(dctc, dctc, my_addr_index);\n\t\tqp_attr->ah_attr.grh.hop_limit = MLX5_GET(dctc, dctc, hop_limit);\n\t}\n\tif (qp_attr_mask & IB_QP_PATH_MTU)\n\t\tqp_attr->path_mtu = MLX5_GET(dctc, dctc, mtu);\n\tif (qp_attr_mask & IB_QP_PKEY_INDEX)\n\t\tqp_attr->pkey_index = MLX5_GET(dctc, dctc, pkey_index);\nout:\n\tkfree(out);\n\treturn err;\n}\n\nint mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,\n\t\t     int qp_attr_mask, struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tint err = 0;\n\tu8 raw_packet_qp_state;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -ENOSYS;\n\n\tif (unlikely(ibqp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_query_qp(ibqp, qp_attr, qp_attr_mask,\n\t\t\t\t\t    qp_init_attr);\n\n\t/* Not all of output fields are applicable, make sure to zero them */\n\tmemset(qp_init_attr, 0, sizeof(*qp_init_attr));\n\tmemset(qp_attr, 0, sizeof(*qp_attr));\n\n\tif (unlikely(qp->qp_sub_type == MLX5_IB_QPT_DCT))\n\t\treturn mlx5_ib_dct_query_qp(dev, qp, qp_attr,\n\t\t\t\t\t    qp_attr_mask, qp_init_attr);\n\n\tmutex_lock(&qp->mutex);\n\n\tif (qp->ibqp.qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\terr = query_raw_packet_qp_state(dev, qp, &raw_packet_qp_state);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tqp->state = raw_packet_qp_state;\n\t\tqp_attr->port_num = 1;\n\t} else {\n\t\terr = query_qp_attr(dev, qp, qp_attr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tqp_attr->qp_state\t     = qp->state;\n\tqp_attr->cur_qp_state\t     = qp_attr->qp_state;\n\tqp_attr->cap.max_recv_wr     = qp->rq.wqe_cnt;\n\tqp_attr->cap.max_recv_sge    = qp->rq.max_gs;\n\n\tif (!ibqp->uobject) {\n\t\tqp_attr->cap.max_send_wr  = qp->sq.max_post;\n\t\tqp_attr->cap.max_send_sge = qp->sq.max_gs;\n\t\tqp_init_attr->qp_context = ibqp->qp_context;\n\t} else {\n\t\tqp_attr->cap.max_send_wr  = 0;\n\t\tqp_attr->cap.max_send_sge = 0;\n\t}\n\n\tqp_init_attr->qp_type = ibqp->qp_type;\n\tqp_init_attr->recv_cq = ibqp->recv_cq;\n\tqp_init_attr->send_cq = ibqp->send_cq;\n\tqp_init_attr->srq = ibqp->srq;\n\tqp_attr->cap.max_inline_data = qp->max_inline_data;\n\n\tqp_init_attr->cap\t     = qp_attr->cap;\n\n\tqp_init_attr->create_flags = 0;\n\tif (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\n\n\tif (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_CROSS_CHANNEL;\n\tif (qp->flags & MLX5_IB_QP_MANAGED_SEND)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_MANAGED_SEND;\n\tif (qp->flags & MLX5_IB_QP_MANAGED_RECV)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_MANAGED_RECV;\n\tif (qp->flags & MLX5_IB_QP_SQPN_QP1)\n\t\tqp_init_attr->create_flags |= mlx5_ib_create_qp_sqpn_qp1();\n\n\tqp_init_attr->sq_sig_type = qp->sq_signal_bits & MLX5_WQE_CTRL_CQ_UPDATE ?\n\t\tIB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstruct ib_xrcd *mlx5_ib_alloc_xrcd(struct ib_device *ibdev,\n\t\t\t\t\t  struct ib_ucontext *context,\n\t\t\t\t\t  struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tstruct mlx5_ib_xrcd *xrcd;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, xrc))\n\t\treturn ERR_PTR(-ENOSYS);\n\n\txrcd = kmalloc(sizeof(*xrcd), GFP_KERNEL);\n\tif (!xrcd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlx5_core_xrcd_alloc(dev->mdev, &xrcd->xrcdn);\n\tif (err) {\n\t\tkfree(xrcd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &xrcd->ibxrcd;\n}\n\nint mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(xrcd->device);\n\tu32 xrcdn = to_mxrcd(xrcd)->xrcdn;\n\tint err;\n\n\terr = mlx5_core_xrcd_dealloc(dev->mdev, xrcdn);\n\tif (err)\n\t\tmlx5_ib_warn(dev, \"failed to dealloc xrcdn 0x%x\\n\", xrcdn);\n\n\tkfree(xrcd);\n\treturn 0;\n}\n\nstatic void mlx5_ib_wq_event(struct mlx5_core_qp *core_qp, int type)\n{\n\tstruct mlx5_ib_rwq *rwq = to_mibrwq(core_qp);\n\tstruct mlx5_ib_dev *dev = to_mdev(rwq->ibwq.device);\n\tstruct ib_event event;\n\n\tif (rwq->ibwq.event_handler) {\n\t\tevent.device     = rwq->ibwq.device;\n\t\tevent.element.wq = &rwq->ibwq;\n\t\tswitch (type) {\n\t\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\t\tevent.event = IB_EVENT_WQ_FATAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlx5_ib_warn(dev, \"Unexpected event type %d on WQ %06x\\n\", type, core_qp->qpn);\n\t\t\treturn;\n\t\t}\n\n\t\trwq->ibwq.event_handler(&event, rwq->ibwq.wq_context);\n\t}\n}\n\nstatic int set_delay_drop(struct mlx5_ib_dev *dev)\n{\n\tint err = 0;\n\n\tmutex_lock(&dev->delay_drop.lock);\n\tif (dev->delay_drop.activate)\n\t\tgoto out;\n\n\terr = mlx5_core_set_delay_drop(dev->mdev, dev->delay_drop.timeout);\n\tif (err)\n\t\tgoto out;\n\n\tdev->delay_drop.activate = true;\nout:\n\tmutex_unlock(&dev->delay_drop.lock);\n\n\tif (!err)\n\t\tatomic_inc(&dev->delay_drop.rqs_cnt);\n\treturn err;\n}\n\nstatic int  create_rq(struct mlx5_ib_rwq *rwq, struct ib_pd *pd,\n\t\t      struct ib_wq_init_attr *init_attr)\n{\n\tstruct mlx5_ib_dev *dev;\n\tint has_net_offloads;\n\t__be64 *rq_pas0;\n\tvoid *in;\n\tvoid *rqc;\n\tvoid *wq;\n\tint inlen;\n\tint err;\n\n\tdev = to_mdev(pd->device);\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rq_in) + sizeof(u64) * rwq->rq_num_pas;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(create_rq_in, in, ctx);\n\tMLX5_SET(rqc,  rqc, mem_rq_type,\n\t\t MLX5_RQC_MEM_RQ_TYPE_MEMORY_RQ_INLINE);\n\tMLX5_SET(rqc, rqc, user_index, rwq->user_index);\n\tMLX5_SET(rqc,  rqc, cqn, to_mcq(init_attr->cq)->mcq.cqn);\n\tMLX5_SET(rqc,  rqc, state, MLX5_RQC_STATE_RST);\n\tMLX5_SET(rqc,  rqc, flush_in_error_en, 1);\n\twq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tMLX5_SET(wq, wq, wq_type,\n\t\t rwq->create_flags & MLX5_IB_WQ_FLAGS_STRIDING_RQ ?\n\t\t MLX5_WQ_TYPE_CYCLIC_STRIDING_RQ : MLX5_WQ_TYPE_CYCLIC);\n\tif (init_attr->create_flags & IB_WQ_FLAGS_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tMLX5_SET(wq, wq, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t}\n\t}\n\tMLX5_SET(wq, wq, log_wq_stride, rwq->log_rq_stride);\n\tif (rwq->create_flags & MLX5_IB_WQ_FLAGS_STRIDING_RQ) {\n\t\tMLX5_SET(wq, wq, two_byte_shift_en, rwq->two_byte_shift_en);\n\t\tMLX5_SET(wq, wq, log_wqe_stride_size,\n\t\t\t rwq->single_stride_log_num_of_bytes -\n\t\t\t MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES);\n\t\tMLX5_SET(wq, wq, log_wqe_num_of_strides, rwq->log_num_strides -\n\t\t\t MLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES);\n\t}\n\tMLX5_SET(wq, wq, log_wq_sz, rwq->log_rq_size);\n\tMLX5_SET(wq, wq, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(wq, wq, page_offset, rwq->rq_page_offset);\n\tMLX5_SET(wq, wq, log_wq_pg_sz, rwq->log_page_size);\n\tMLX5_SET(wq, wq, wq_signature, rwq->wq_sig);\n\tMLX5_SET64(wq, wq, dbr_addr, rwq->db.dma);\n\thas_net_offloads = MLX5_CAP_GEN(dev->mdev, eth_net_offloads);\n\tif (init_attr->create_flags & IB_WQ_FLAGS_CVLAN_STRIPPING) {\n\t\tif (!(has_net_offloads && MLX5_CAP_ETH(dev->mdev, vlan_cap))) {\n\t\t\tmlx5_ib_dbg(dev, \"VLAN offloads are not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tMLX5_SET(rqc, rqc, vsd, 1);\n\t}\n\tif (init_attr->create_flags & IB_WQ_FLAGS_SCATTER_FCS) {\n\t\tif (!(has_net_offloads && MLX5_CAP_ETH(dev->mdev, scatter_fcs))) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(rqc, rqc, scatter_fcs, 1);\n\t}\n\tif (init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP) {\n\t\tif (!(dev->ib_dev.attrs.raw_packet_caps &\n\t\t      IB_RAW_PACKET_CAP_DELAY_DROP)) {\n\t\t\tmlx5_ib_dbg(dev, \"Delay drop is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(rqc, rqc, delay_drop_en, 1);\n\t}\n\trq_pas0 = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(dev, rwq->umem, rwq->page_shift, rq_pas0, 0);\n\terr = mlx5_core_create_rq_tracked(dev->mdev, in, inlen, &rwq->core_qp);\n\tif (!err && init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP) {\n\t\terr = set_delay_drop(dev);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"Failed to enable delay drop err=%d\\n\",\n\t\t\t\t     err);\n\t\t\tmlx5_core_destroy_rq_tracked(dev->mdev, &rwq->core_qp);\n\t\t} else {\n\t\t\trwq->create_flags |= MLX5_IB_WQ_FLAGS_DELAY_DROP;\n\t\t}\n\t}\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int set_user_rq_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_wq_init_attr *wq_init_attr,\n\t\t\t    struct mlx5_ib_create_wq *ucmd,\n\t\t\t    struct mlx5_ib_rwq *rwq)\n{\n\t/* Sanity check RQ size before proceeding */\n\tif (wq_init_attr->max_wr > (1 << MLX5_CAP_GEN(dev->mdev, log_max_wq_sz)))\n\t\treturn -EINVAL;\n\n\tif (!ucmd->rq_wqe_count)\n\t\treturn -EINVAL;\n\n\trwq->wqe_count = ucmd->rq_wqe_count;\n\trwq->wqe_shift = ucmd->rq_wqe_shift;\n\tif (check_shl_overflow(rwq->wqe_count, rwq->wqe_shift, &rwq->buf_size))\n\t\treturn -EINVAL;\n\n\trwq->log_rq_stride = rwq->wqe_shift;\n\trwq->log_rq_size = ilog2(rwq->wqe_count);\n\treturn 0;\n}\n\nstatic int prepare_user_rq(struct ib_pd *pd,\n\t\t\t   struct ib_wq_init_attr *init_attr,\n\t\t\t   struct ib_udata *udata,\n\t\t\t   struct mlx5_ib_rwq *rwq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tstruct mlx5_ib_create_wq ucmd = {};\n\tint err;\n\tsize_t required_cmd_sz;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), single_stride_log_num_of_bytes)\n\t\t+ sizeof(ucmd.single_stride_log_num_of_bytes);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tmlx5_ib_dbg(dev, \"invalid inlen\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tmlx5_ib_dbg(dev, \"inlen is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen))) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ucmd.comp_mask & (~MLX5_IB_CREATE_WQ_STRIDING_RQ)) {\n\t\tmlx5_ib_dbg(dev, \"invalid comp mask\\n\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (ucmd.comp_mask & MLX5_IB_CREATE_WQ_STRIDING_RQ) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, striding_rq)) {\n\t\t\tmlx5_ib_dbg(dev, \"Striding RQ is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif ((ucmd.single_stride_log_num_of_bytes <\n\t\t    MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES) ||\n\t\t    (ucmd.single_stride_log_num_of_bytes >\n\t\t     MLX5_MAX_SINGLE_STRIDE_LOG_NUM_BYTES)) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid log stride size (%u. Range is %u - %u)\\n\",\n\t\t\t\t    ucmd.single_stride_log_num_of_bytes,\n\t\t\t\t    MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES,\n\t\t\t\t    MLX5_MAX_SINGLE_STRIDE_LOG_NUM_BYTES);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((ucmd.single_wqe_log_num_of_strides >\n\t\t    MLX5_MAX_SINGLE_WQE_LOG_NUM_STRIDES) ||\n\t\t     (ucmd.single_wqe_log_num_of_strides <\n\t\t\tMLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES)) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid log num strides (%u. Range is %u - %u)\\n\",\n\t\t\t\t    ucmd.single_wqe_log_num_of_strides,\n\t\t\t\t    MLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES,\n\t\t\t\t    MLX5_MAX_SINGLE_WQE_LOG_NUM_STRIDES);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trwq->single_stride_log_num_of_bytes =\n\t\t\tucmd.single_stride_log_num_of_bytes;\n\t\trwq->log_num_strides = ucmd.single_wqe_log_num_of_strides;\n\t\trwq->two_byte_shift_en = !!ucmd.two_byte_shift_en;\n\t\trwq->create_flags |= MLX5_IB_WQ_FLAGS_STRIDING_RQ;\n\t}\n\n\terr = set_user_rq_size(dev, init_attr, &ucmd, rwq);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = create_user_rq(dev, pd, rwq, &ucmd);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\trwq->user_index = ucmd.user_index;\n\treturn 0;\n}\n\nstruct ib_wq *mlx5_ib_create_wq(struct ib_pd *pd,\n\t\t\t\tstruct ib_wq_init_attr *init_attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev;\n\tstruct mlx5_ib_rwq *rwq;\n\tstruct mlx5_ib_create_wq_resp resp = {};\n\tsize_t min_resp_len;\n\tint err;\n\n\tif (!udata)\n\t\treturn ERR_PTR(-ENOSYS);\n\n\tmin_resp_len = offsetof(typeof(resp), reserved) + sizeof(resp.reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = to_mdev(pd->device);\n\tswitch (init_attr->wq_type) {\n\tcase IB_WQT_RQ:\n\t\trwq = kzalloc(sizeof(*rwq), GFP_KERNEL);\n\t\tif (!rwq)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = prepare_user_rq(pd, init_attr, udata, rwq);\n\t\tif (err)\n\t\t\tgoto err;\n\t\terr = create_rq(rwq, pd, init_attr);\n\t\tif (err)\n\t\t\tgoto err_user_rq;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_ib_dbg(dev, \"unsupported wq type %d\\n\",\n\t\t\t    init_attr->wq_type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trwq->ibwq.wq_num = rwq->core_qp.qpn;\n\trwq->ibwq.state = IB_WQS_RESET;\n\tif (udata->outlen) {\n\t\tresp.response_length = offsetof(typeof(resp), response_length) +\n\t\t\t\tsizeof(resp.response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\tgoto err_copy;\n\t}\n\n\trwq->core_qp.event = mlx5_ib_wq_event;\n\trwq->ibwq.event_handler = init_attr->event_handler;\n\treturn &rwq->ibwq;\n\nerr_copy:\n\tmlx5_core_destroy_rq_tracked(dev->mdev, &rwq->core_qp);\nerr_user_rq:\n\tdestroy_user_rq(dev, pd, rwq);\nerr:\n\tkfree(rwq);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_ib_destroy_wq(struct ib_wq *wq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(wq->device);\n\tstruct mlx5_ib_rwq *rwq = to_mrwq(wq);\n\n\tmlx5_core_destroy_rq_tracked(dev->mdev, &rwq->core_qp);\n\tdestroy_user_rq(dev, wq->pd, rwq);\n\tkfree(rwq);\n\n\treturn 0;\n}\n\nstruct ib_rwq_ind_table *mlx5_ib_create_rwq_ind_table(struct ib_device *device,\n\t\t\t\t\t\t      struct ib_rwq_ind_table_init_attr *init_attr,\n\t\t\t\t\t\t      struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_ib_rwq_ind_table *rwq_ind_tbl;\n\tint sz = 1 << init_attr->log_ind_tbl_size;\n\tstruct mlx5_ib_create_rwq_ind_tbl_resp resp = {};\n\tsize_t min_resp_len;\n\tint inlen;\n\tint err;\n\tint i;\n\tu32 *in;\n\tvoid *rqtc;\n\n\tif (udata->inlen > 0 &&\n\t    !ib_is_udata_cleared(udata, 0,\n\t\t\t\t udata->inlen))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (init_attr->log_ind_tbl_size >\n\t    MLX5_CAP_GEN(dev->mdev, log_max_rqt_size)) {\n\t\tmlx5_ib_dbg(dev, \"log_ind_tbl_size = %d is bigger than supported = %d\\n\",\n\t\t\t    init_attr->log_ind_tbl_size,\n\t\t\t    MLX5_CAP_GEN(dev->mdev, log_max_rqt_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmin_resp_len = offsetof(typeof(resp), reserved) + sizeof(resp.reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trwq_ind_tbl = kzalloc(sizeof(*rwq_ind_tbl), GFP_KERNEL);\n\tif (!rwq_ind_tbl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\trqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);\n\n\tMLX5_SET(rqtc, rqtc, rqt_actual_size, sz);\n\tMLX5_SET(rqtc, rqtc, rqt_max_size, sz);\n\n\tfor (i = 0; i < sz; i++)\n\t\tMLX5_SET(rqtc, rqtc, rq_num[i], init_attr->ind_tbl[i]->wq_num);\n\n\terr = mlx5_core_create_rqt(dev->mdev, in, inlen, &rwq_ind_tbl->rqtn);\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err;\n\n\trwq_ind_tbl->ib_rwq_ind_tbl.ind_tbl_num = rwq_ind_tbl->rqtn;\n\tif (udata->outlen) {\n\t\tresp.response_length = offsetof(typeof(resp), response_length) +\n\t\t\t\t\tsizeof(resp.response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\tgoto err_copy;\n\t}\n\n\treturn &rwq_ind_tbl->ib_rwq_ind_tbl;\n\nerr_copy:\n\tmlx5_core_destroy_rqt(dev->mdev, rwq_ind_tbl->rqtn);\nerr:\n\tkfree(rwq_ind_tbl);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_ib_destroy_rwq_ind_table(struct ib_rwq_ind_table *ib_rwq_ind_tbl)\n{\n\tstruct mlx5_ib_rwq_ind_table *rwq_ind_tbl = to_mrwq_ind_table(ib_rwq_ind_tbl);\n\tstruct mlx5_ib_dev *dev = to_mdev(ib_rwq_ind_tbl->device);\n\n\tmlx5_core_destroy_rqt(dev->mdev, rwq_ind_tbl->rqtn);\n\n\tkfree(rwq_ind_tbl);\n\treturn 0;\n}\n\nint mlx5_ib_modify_wq(struct ib_wq *wq, struct ib_wq_attr *wq_attr,\n\t\t      u32 wq_attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(wq->device);\n\tstruct mlx5_ib_rwq *rwq = to_mrwq(wq);\n\tstruct mlx5_ib_modify_wq ucmd = {};\n\tsize_t required_cmd_sz;\n\tint curr_wq_state;\n\tint wq_state;\n\tint inlen;\n\tint err;\n\tvoid *rqc;\n\tvoid *in;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), reserved) + sizeof(ucmd.reserved);\n\tif (udata->inlen < required_cmd_sz)\n\t\treturn -EINVAL;\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen)))\n\t\treturn -EFAULT;\n\n\tif (ucmd.comp_mask || ucmd.reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_rq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\n\tcurr_wq_state = (wq_attr_mask & IB_WQ_CUR_STATE) ?\n\t\twq_attr->curr_wq_state : wq->state;\n\twq_state = (wq_attr_mask & IB_WQ_STATE) ?\n\t\twq_attr->wq_state : curr_wq_state;\n\tif (curr_wq_state == IB_WQS_ERR)\n\t\tcurr_wq_state = MLX5_RQC_STATE_ERR;\n\tif (wq_state == IB_WQS_ERR)\n\t\twq_state = MLX5_RQC_STATE_ERR;\n\tMLX5_SET(modify_rq_in, in, rq_state, curr_wq_state);\n\tMLX5_SET(rqc, rqc, state, wq_state);\n\n\tif (wq_attr_mask & IB_WQ_FLAGS) {\n\t\tif (wq_attr->flags_mask & IB_WQ_FLAGS_CVLAN_STRIPPING) {\n\t\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap))) {\n\t\t\t\tmlx5_ib_dbg(dev, \"VLAN offloads are not \"\n\t\t\t\t\t    \"supported\\n\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_VSD);\n\t\t\tMLX5_SET(rqc, rqc, vsd,\n\t\t\t\t (wq_attr->flags & IB_WQ_FLAGS_CVLAN_STRIPPING) ? 0 : 1);\n\t\t}\n\n\t\tif (wq_attr->flags_mask & IB_WQ_FLAGS_PCI_WRITE_END_PADDING) {\n\t\t\tmlx5_ib_dbg(dev, \"Modifying scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (curr_wq_state == IB_WQS_RESET && wq_state == IB_WQS_RDY) {\n\t\tif (MLX5_CAP_GEN(dev->mdev, modify_rq_counter_set_id)) {\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\t\t\tMLX5_SET(rqc, rqc, counter_set_id,\n\t\t\t\t dev->port->cnts.set_id);\n\t\t} else\n\t\t\tpr_info_once(\"%s: Receive WQ counters are not supported on current FW\\n\",\n\t\t\t\t     dev->ib_dev.name);\n\t}\n\n\terr = mlx5_core_modify_rq(dev->mdev, rwq->core_qp.qpn, in, inlen);\n\tif (!err)\n\t\trwq->ibwq.state = (wq_state == MLX5_RQC_STATE_ERR) ? IB_WQS_ERR : wq_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstruct mlx5_ib_drain_cqe {\n\tstruct ib_cqe cqe;\n\tstruct completion done;\n};\n\nstatic void mlx5_ib_drain_qp_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_drain_cqe *cqe = container_of(wc->wr_cqe,\n\t\t\t\t\t\t     struct mlx5_ib_drain_cqe,\n\t\t\t\t\t\t     cqe);\n\n\tcomplete(&cqe->done);\n}\n\n/* This function returns only once the drained WR was completed */\nstatic void handle_drain_completion(struct ib_cq *cq,\n\t\t\t\t    struct mlx5_ib_drain_cqe *sdrain,\n\t\t\t\t    struct mlx5_ib_dev *dev)\n{\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tif (cq->poll_ctx == IB_POLL_DIRECT) {\n\t\twhile (wait_for_completion_timeout(&sdrain->done, HZ / 10) <= 0)\n\t\t\tib_process_cq_direct(cq, -1);\n\t\treturn;\n\t}\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tstruct mlx5_ib_cq *mcq = to_mcq(cq);\n\t\tbool triggered = false;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\t\t/* Make sure that the CQ handler won't run if wasn't run yet */\n\t\tif (!mcq->mcq.reset_notify_added)\n\t\t\tmcq->mcq.reset_notify_added = 1;\n\t\telse\n\t\t\ttriggered = true;\n\t\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\t\tif (triggered) {\n\t\t\t/* Wait for any scheduled/running task to be ended */\n\t\t\tswitch (cq->poll_ctx) {\n\t\t\tcase IB_POLL_SOFTIRQ:\n\t\t\t\tirq_poll_disable(&cq->iop);\n\t\t\t\tirq_poll_enable(&cq->iop);\n\t\t\t\tbreak;\n\t\t\tcase IB_POLL_WORKQUEUE:\n\t\t\t\tcancel_work_sync(&cq->work);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t}\n\t\t}\n\n\t\t/* Run the CQ handler - this makes sure that the drain WR will\n\t\t * be processed if wasn't processed yet.\n\t\t */\n\t\tmcq->mcq.comp(&mcq->mcq);\n\t}\n\n\twait_for_completion(&sdrain->done);\n}\n\nvoid mlx5_ib_drain_sq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->send_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx5_ib_drain_cqe sdrain;\n\tconst struct ib_send_wr *bad_swr;\n\tstruct ib_rdma_wr swr = {\n\t\t.wr = {\n\t\t\t.next = NULL,\n\t\t\t{ .wr_cqe\t= &sdrain.cqe, },\n\t\t\t.opcode\t= IB_WR_RDMA_WRITE,\n\t\t},\n\t};\n\tint ret;\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tsdrain.cqe.done = mlx5_ib_drain_qp_done;\n\tinit_completion(&sdrain.done);\n\n\tret = _mlx5_ib_post_send(qp, &swr.wr, &bad_swr, true);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &sdrain, dev);\n}\n\nvoid mlx5_ib_drain_rq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->recv_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx5_ib_drain_cqe rdrain;\n\tstruct ib_recv_wr rwr = {};\n\tconst struct ib_recv_wr *bad_rwr;\n\tint ret;\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\trwr.wr_cqe = &rdrain.cqe;\n\trdrain.cqe.done = mlx5_ib_drain_qp_done;\n\tinit_completion(&rdrain.done);\n\n\tret = _mlx5_ib_post_recv(qp, &rwr, &bad_rwr, true);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &rdrain, dev);\n}\n"], "filenames": ["drivers/infiniband/hw/mlx5/qp.c"], "buggy_code_start_loc": [1610], "buggy_code_end_loc": [1611], "fixing_code_start_loc": [1610], "fixing_code_end_loc": [1611], "type": "CWE-119", "message": "An issue was discovered in the Linux kernel before 4.18.7. In create_qp_common in drivers/infiniband/hw/mlx5/qp.c, mlx5_ib_create_qp_resp was never initialized, resulting in a leak of stack memory to userspace.", "other": {"cve": {"id": "CVE-2018-20855", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-26T05:15:10.423", "lastModified": "2019-11-20T15:31:14.893", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.18.7. In create_qp_common in drivers/infiniband/hw/mlx5/qp.c, mlx5_ib_create_qp_resp was never initialized, resulting in a leak of stack memory to userspace."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux anterior a versi\u00f3n 4.18.7. En create_qp_common en archivo drivers/infiniband/hw/mlx5/qp.c, la funci\u00f3n mlx5_ib_create_qp_resp nunca fue inicializada, resultando en una p\u00e9rdida de memoria de pila en el espacio de usuario."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.18.7", "matchCriteriaId": "92C6CD12-AE92-4AFB-91FA-F2A97F5537D8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_performance_analytics_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "83077160-BB98-408B-81F0-8EF9E566BF28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:*:*:*:*:*:vmware_vsphere:*:*", "versionStartIncluding": "9.5", "matchCriteriaId": "0CB28AF5-5AF0-4475-A7B6-12E1795FFDCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00055.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00056.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.18.7", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0625b4ba1a5d4703c7fb01c497bd6c156908af00", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190905-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00"}}