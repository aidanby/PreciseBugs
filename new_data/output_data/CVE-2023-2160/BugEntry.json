{"buggy_code": ["\"\"\"Core forms.\"\"\"\n\nimport oath\n\nfrom django import forms\nfrom django.contrib.auth import (\n    forms as auth_forms, get_user_model, password_validation\n)\nfrom django.db.models import Q\nfrom django.utils.translation import ugettext as _, ugettext_lazy\n\nimport django_otp\n\nfrom modoboa.core.models import User\nfrom modoboa.lib.form_utils import UserKwargModelFormMixin\nfrom modoboa.parameters import tools as param_tools\n\n\nclass LoginForm(forms.Form):\n    \"\"\"User login form.\"\"\"\n\n    username = forms.CharField(\n        label=ugettext_lazy(\"Username\"),\n        widget=forms.TextInput(attrs={\"class\": \"form-control\"})\n    )\n    password = forms.CharField(\n        label=ugettext_lazy(\"Password\"),\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n    rememberme = forms.BooleanField(\n        initial=False,\n        required=False\n    )\n\n\nclass ProfileForm(forms.ModelForm):\n    \"\"\"Form to update User profile.\"\"\"\n\n    oldpassword = forms.CharField(\n        label=ugettext_lazy(\"Old password\"), required=False,\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n    newpassword = forms.CharField(\n        label=ugettext_lazy(\"New password\"), required=False,\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n    confirmation = forms.CharField(\n        label=ugettext_lazy(\"Confirmation\"), required=False,\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n\n    class Meta(object):\n        model = User\n        fields = (\"first_name\", \"last_name\", \"language\",\n                  \"phone_number\", \"secondary_email\")\n        widgets = {\n            \"first_name\": forms.TextInput(attrs={\"class\": \"form-control\"}),\n            \"last_name\": forms.TextInput(attrs={\"class\": \"form-control\"})\n        }\n\n    def __init__(self, update_password, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not update_password:\n            del self.fields[\"oldpassword\"]\n            del self.fields[\"newpassword\"]\n            del self.fields[\"confirmation\"]\n\n    def clean_oldpassword(self):\n        if self.cleaned_data[\"oldpassword\"] == \"\":\n            return self.cleaned_data[\"oldpassword\"]\n\n        if param_tools.get_global_parameter(\"authentication_type\") != \"local\":\n            return self.cleaned_data[\"oldpassword\"]\n\n        if not self.instance.check_password(self.cleaned_data[\"oldpassword\"]):\n            raise forms.ValidationError(_(\"Old password mismatchs\"))\n        return self.cleaned_data[\"oldpassword\"]\n\n    def clean(self):\n        super().clean()\n        if self.errors:\n            return self.cleaned_data\n        oldpassword = self.cleaned_data.get(\"oldpassword\")\n        newpassword = self.cleaned_data.get(\"newpassword\")\n        confirmation = self.cleaned_data.get(\"confirmation\")\n        if newpassword and confirmation:\n            if oldpassword:\n                if newpassword != confirmation:\n                    self.add_error(\"confirmation\", _(\"Passwords mismatch\"))\n                else:\n                    password_validation.validate_password(\n                        confirmation, self.instance)\n            else:\n                self.add_error(\"oldpassword\", _(\"This field is required.\"))\n        return self.cleaned_data\n\n    def save(self, commit=True):\n        user = super().save(commit=False)\n        if commit:\n            if self.cleaned_data.get(\"confirmation\", \"\") != \"\":\n                user.set_password(\n                    self.cleaned_data[\"confirmation\"],\n                    self.cleaned_data[\"oldpassword\"]\n                )\n            user.save()\n        return user\n\n\nclass APIAccessForm(forms.Form):\n    \"\"\"Form to control API access.\"\"\"\n\n    enable_api_access = forms.BooleanField(\n        label=ugettext_lazy(\"Enable API access\"), required=False)\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize form.\"\"\"\n        user = kwargs.pop(\"user\")\n        super(APIAccessForm, self).__init__(*args, **kwargs)\n        self.fields[\"enable_api_access\"].initial = hasattr(user, \"auth_token\")\n\n\nclass PasswordResetForm(auth_forms.PasswordResetForm):\n    \"\"\"Custom password reset form.\"\"\"\n\n    def get_users(self, email):\n        \"\"\"Return matching user(s) who should receive a reset.\"\"\"\n        return (\n            get_user_model()._default_manager.filter(\n                email__iexact=email, is_active=True)\n            .exclude(Q(secondary_email__isnull=True) | Q(secondary_email=\"\"))\n        )\n\n    def send_mail(self, subject_template_name, email_template_name,\n                  context, from_email, to_email,\n                  html_email_template_name=None):\n        \"\"\"Send message to secondary email instead.\"\"\"\n        to_email = context[\"user\"].secondary_email\n        super(PasswordResetForm, self).send_mail(\n            subject_template_name, email_template_name,\n            context, from_email, to_email, html_email_template_name)\n\n\nclass VerifySMSCodeForm(forms.Form):\n    \"\"\"A form to verify a code received by SMS.\"\"\"\n\n    code = forms.CharField(\n        label=ugettext_lazy(\"Verification code\"),\n        widget=forms.widgets.TextInput(attrs={\"class\": \"form-control\"})\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.totp_secret = kwargs.pop(\"totp_secret\")\n        super().__init__(*args, **kwargs)\n\n    def clean_code(self):\n        code = self.cleaned_data[\"code\"]\n        if not oath.accept_totp(self.totp_secret, code)[0]:\n            raise forms.ValidationError(_(\"Invalid code\"))\n        return code\n\n\nclass Verify2FACodeForm(UserKwargModelFormMixin, forms.Form):\n    \"\"\"A form to verify 2FA codes validity.\"\"\"\n\n    tfa_code = forms.CharField()\n\n    def clean_tfa_code(self):\n        code = self.cleaned_data[\"tfa_code\"]\n        device = django_otp.match_token(self.user, code)\n        if device is None:\n            raise forms.ValidationError(_(\"This code is invalid\"))\n        return device\n", "\"\"\"Tests for core application.\"\"\"\n\nfrom io import StringIO\n\nimport httmock\nfrom dateutil.relativedelta import relativedelta\n\nfrom django.core import mail\nfrom django.core import management\nfrom django.test import TestCase\nfrom django.urls import reverse\nfrom django.utils import timezone\n\nfrom modoboa.lib.tests import ModoTestCase, SimpleModoTestCase\nfrom .. import factories, mocks, models\n\n\nclass AuthenticationTestCase(ModoTestCase):\n\n    \"\"\"Validate authentication scenarios.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):  # NOQA:N802\n        \"\"\"Create test data.\"\"\"\n        super(AuthenticationTestCase, cls).setUpTestData()\n        cls.account = factories.UserFactory(\n            username=\"user@test.com\", groups=(\"SimpleUsers\",)\n        )\n\n    def test_authentication(self):\n        \"\"\"Validate simple case.\"\"\"\n        self.client.logout()\n        data = {\"username\": \"user@test.com\", \"password\": \"toto\"}\n        response = self.client.post(reverse(\"core:login\"), data)\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response.url.endswith(reverse(\"core:user_index\")))\n\n        response = self.client.post(reverse(\"core:logout\"), {})\n        self.assertEqual(response.status_code, 302)\n\n        data = {\"username\": \"admin\", \"password\": \"password\"}\n        response = self.client.post(reverse(\"core:login\"), data)\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response.url.endswith(reverse(\"core:dashboard\")))\n\n\nclass ManagementCommandsTestCase(SimpleModoTestCase):\n    \"\"\"Test management commands.\"\"\"\n\n    def test_change_default_admin(self):\n        \"\"\"Use dedicated option.\"\"\"\n        management.call_command(\n            \"load_initial_data\", \"--admin-username\", \"modoadmin\")\n        self.assertTrue(\n            self.client.login(username=\"modoadmin\", password=\"password\"))\n\n    def test_clean_logs(self):\n        \"\"\"Run cleanlogs command.\"\"\"\n        log1 = factories.LogFactory()\n        factories.LogFactory()\n        log1.date_created -= relativedelta(years=2)\n        log1.save(update_fields=[\"date_created\"])\n        management.call_command(\"cleanlogs\")\n        self.assertEqual(models.Log.objects.count(), 1)\n\n    def test_clean_inactive_accounts(self):\n        \"\"\"Run clean_inactive_accounts command.\"\"\"\n        management.call_command(\"load_initial_data\")\n\n        # no inactive account, should exit normaly\n        management.call_command(\"clean_inactive_accounts\")\n\n        last_login = timezone.now() - relativedelta(days=45)\n        account = factories.UserFactory(\n            username=\"user1@domain.test\", groups=(\"SimpleUsers\", ),\n            last_login=last_login\n        )\n        management.call_command(\"clean_inactive_accounts\", \"--dry-run\")\n        account.refresh_from_db()\n        self.assertTrue(account.is_active)\n\n        out = StringIO()\n        management.call_command(\n            \"clean_inactive_accounts\", \"--verbose\", \"--dry-run\", stdout=out)\n        self.assertIn(\"user1@domain.test\", out.getvalue())\n\n        # Disable account account threshold\n        self.set_global_parameter(\"enable_inactive_accounts\", False)\n        out = StringIO()\n        management.call_command(\n            \"clean_inactive_accounts\", \"--verbose\", stdout=out)\n        self.assertIn(\"Inactive accounts detection is disabled.\",\n                      out.getvalue())\n\n        self.set_global_parameter(\"enable_inactive_accounts\", True)\n        management.call_command(\"clean_inactive_accounts\", \"--silent\")\n        account.refresh_from_db()\n        self.assertFalse(account.is_active)\n\n        account.is_active = True\n        account.save(update_fields=[\"is_active\"])\n\n        management.call_command(\n            \"clean_inactive_accounts\", \"--silent\", \"--delete\")\n        with self.assertRaises(models.User.DoesNotExist):\n            account.refresh_from_db()\n\n\nclass ProfileTestCase(ModoTestCase):\n    \"\"\"Profile related tests.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):  # NOQA:N802\n        \"\"\"Create test data.\"\"\"\n        super(ProfileTestCase, cls).setUpTestData()\n        cls.account = factories.UserFactory(\n            username=\"user@test.com\", groups=(\"SimpleUsers\",)\n        )\n\n    def test_update_profile(self):\n        \"\"\"Update profile without password.\"\"\"\n        data = {\n            \"first_name\": \"Homer\", \"last_name\": \"Simpson\",\n            \"phone_number\": \"+33612345678\", \"language\": \"en\"\n        }\n        self.ajax_post(reverse(\"core:user_profile\"), data)\n        admin = models.User.objects.get(username=\"admin\")\n        self.assertEqual(admin.last_name, \"Simpson\")\n\n    def test_update_password(self):\n        \"\"\"Password update\n\n        Two cases:\n        * The default admin changes his password (no associated Mailbox)\n        * A normal user changes his password\n        \"\"\"\n        self.ajax_post(reverse(\"core:user_profile\"),\n                       {\"language\": \"en\", \"oldpassword\": \"password\",\n                        \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"})\n        self.client.logout()\n\n        self.assertEqual(\n            self.client.login(username=\"admin\", password=\"12345Toi\"), True\n        )\n        self.assertEqual(\n            self.client.login(username=\"user@test.com\", password=\"toto\"), True\n        )\n\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"oldpassword\": \"toto\",\n             \"newpassword\": \"tutu\", \"confirmation\": \"tutu\"},\n            status=400\n        )\n\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"language\": \"en\", \"oldpassword\": \"toto\",\n             \"newpassword\": \"Toto1234\", \"confirmation\": \"Toto1234\"}\n        )\n        self.client.logout()\n        self.assertTrue(\n            self.client.login(username=\"user@test.com\", password=\"Toto1234\")\n        )\n\n    def test_update_password_restrictions(self):\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"language\": \"en\", \"oldpassword\": \"\",\n             \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"},\n            status=400\n        )\n        self.client.logout()\n\n        self.assertEqual(\n            self.client.login(username=\"admin\", password=\"12345Toi\"), False\n        )\n\n    def test_update_password_url(self):\n        \"\"\"Check if external is used when defined.\"\"\"\n        self.set_global_parameter(\n            \"update_password_url\", \"http://update.password\")\n        non_local_user = factories.UserFactory(\n            username=\"user@external.com\", groups=(\"SimpleUsers\",),\n            is_local=False\n        )\n        self.client.force_login(non_local_user)\n        url = reverse(\"core:user_profile\")\n        response = self.client.get(url)\n        self.assertContains(response, \"http://update.password\")\n\n        self.client.force_login(self.account)\n        response = self.client.get(url)\n        self.assertNotContains(response, \"http://update.password\")\n\n\nclass APIAccessFormTestCase(ModoTestCase):\n\n    \"\"\"Check form access.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):  # NOQA:N802\n        \"\"\"Create test data.\"\"\"\n        super(APIAccessFormTestCase, cls).setUpTestData()\n        cls.account = factories.UserFactory(\n            username=\"user@test.com\", groups=(\"SimpleUsers\",)\n        )\n\n    def test_form_access(self):\n        \"\"\"Check access restrictions.\"\"\"\n        url = reverse(\"core:user_api_access\")\n        self.ajax_get(url)\n        self.client.logout()\n        self.client.login(username=\"user@test.com\", password=\"toto\")\n        response = self.client.get(url, HTTP_X_REQUESTED_WITH=\"XMLHttpRequest\")\n        self.assertEqual(response.status_code, 278)\n\n    def test_form(self):\n        \"\"\"Check that token is created/removed.\"\"\"\n        url = reverse(\"core:user_api_access\")\n        self.ajax_post(url, {\"enable_api_access\": True})\n        user = models.User.objects.get(username=\"admin\")\n        self.assertTrue(hasattr(user, \"auth_token\"))\n        self.ajax_post(url, {\"enable_api_access\": False})\n        user = models.User.objects.get(username=\"admin\")\n        self.assertFalse(hasattr(user, \"auth_token\"))\n\n\nclass APICommunicationTestCase(ModoTestCase):\n    \"\"\"Check communication with the API.\"\"\"\n\n    def test_management_command(self):\n        \"\"\"Check command.\"\"\"\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(models.LocalConfig.objects.first().api_pk, 100)\n        self.assertEqual(len(mail.outbox), 0)\n\n        url = reverse(\"core:information\")\n        response = self.ajax_request(\"get\", url)\n        self.assertIn(\"9.0.0\", response[\"content\"])\n\n        # Enable notifications\n        self.set_global_parameter(\"send_new_versions_email\", True)\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(len(mail.outbox), 1)\n\n        # Call once again and check no new notification has been sent\n        self.set_global_parameter(\"send_new_versions_email\", True)\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(len(mail.outbox), 1)\n\n        # Make sure no new notification is sent when no updates\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions_no_update):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(len(mail.outbox), 1)\n"], "fixing_code": ["\"\"\"Core forms.\"\"\"\n\nimport oath\n\nfrom django import forms\nfrom django.contrib.auth import (\n    forms as auth_forms, get_user_model, password_validation\n)\nfrom django.db.models import Q\nfrom django.utils.translation import ugettext as _, ugettext_lazy\n\nimport django_otp\n\nfrom modoboa.core.models import User\nfrom modoboa.lib.form_utils import UserKwargModelFormMixin\nfrom modoboa.parameters import tools as param_tools\n\n\nclass LoginForm(forms.Form):\n    \"\"\"User login form.\"\"\"\n\n    username = forms.CharField(\n        label=ugettext_lazy(\"Username\"),\n        widget=forms.TextInput(attrs={\"class\": \"form-control\"})\n    )\n    password = forms.CharField(\n        label=ugettext_lazy(\"Password\"),\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n    rememberme = forms.BooleanField(\n        initial=False,\n        required=False\n    )\n\n\nclass ProfileForm(forms.ModelForm):\n    \"\"\"Form to update User profile.\"\"\"\n\n    oldpassword = forms.CharField(\n        label=ugettext_lazy(\"Old password\"), required=False,\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n    newpassword = forms.CharField(\n        label=ugettext_lazy(\"New password\"), required=False,\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n    confirmation = forms.CharField(\n        label=ugettext_lazy(\"Confirmation\"), required=False,\n        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})\n    )\n\n    class Meta(object):\n        model = User\n        fields = (\"first_name\", \"last_name\", \"language\",\n                  \"phone_number\", \"secondary_email\")\n        widgets = {\n            \"first_name\": forms.TextInput(attrs={\"class\": \"form-control\"}),\n            \"last_name\": forms.TextInput(attrs={\"class\": \"form-control\"})\n        }\n\n    def __init__(self, update_password, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not update_password:\n            del self.fields[\"oldpassword\"]\n            del self.fields[\"newpassword\"]\n            del self.fields[\"confirmation\"]\n\n    def clean_oldpassword(self):\n        if self.cleaned_data[\"oldpassword\"] == \"\":\n            return self.cleaned_data[\"oldpassword\"]\n\n        if param_tools.get_global_parameter(\"authentication_type\") != \"local\":\n            return self.cleaned_data[\"oldpassword\"]\n\n        if not self.instance.check_password(self.cleaned_data[\"oldpassword\"]):\n            raise forms.ValidationError(_(\"Old password mismatchs\"))\n        return self.cleaned_data[\"oldpassword\"]\n\n    def clean(self):\n        super().clean()\n        if self.errors:\n            return self.cleaned_data\n        oldpassword = self.cleaned_data.get(\"oldpassword\")\n        newpassword = self.cleaned_data.get(\"newpassword\")\n        confirmation = self.cleaned_data.get(\"confirmation\")\n        if newpassword and confirmation:\n            if oldpassword:\n                if newpassword != confirmation:\n                    self.add_error(\"confirmation\", _(\"Passwords mismatch\"))\n                else:\n                    password_validation.validate_password(\n                        confirmation, self.instance)\n            else:\n                self.add_error(\"oldpassword\", _(\"This field is required.\"))\n        elif newpassword or confirmation:\n            if not confirmation:\n                self.add_error(\"confirmation\", _(\"This field is required.\"))\n            else:\n                self.add_error(\"newpassword\", _(\"This field is required.\"))\n        return self.cleaned_data\n\n    def save(self, commit=True):\n        user = super().save(commit=False)\n        if commit:\n            if self.cleaned_data.get(\"confirmation\", \"\") != \"\":\n                user.set_password(\n                    self.cleaned_data[\"confirmation\"],\n                    self.cleaned_data[\"oldpassword\"]\n                )\n            user.save()\n        return user\n\n\nclass APIAccessForm(forms.Form):\n    \"\"\"Form to control API access.\"\"\"\n\n    enable_api_access = forms.BooleanField(\n        label=ugettext_lazy(\"Enable API access\"), required=False)\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize form.\"\"\"\n        user = kwargs.pop(\"user\")\n        super(APIAccessForm, self).__init__(*args, **kwargs)\n        self.fields[\"enable_api_access\"].initial = hasattr(user, \"auth_token\")\n\n\nclass PasswordResetForm(auth_forms.PasswordResetForm):\n    \"\"\"Custom password reset form.\"\"\"\n\n    def get_users(self, email):\n        \"\"\"Return matching user(s) who should receive a reset.\"\"\"\n        return (\n            get_user_model()._default_manager.filter(\n                email__iexact=email, is_active=True)\n            .exclude(Q(secondary_email__isnull=True) | Q(secondary_email=\"\"))\n        )\n\n    def send_mail(self, subject_template_name, email_template_name,\n                  context, from_email, to_email,\n                  html_email_template_name=None):\n        \"\"\"Send message to secondary email instead.\"\"\"\n        to_email = context[\"user\"].secondary_email\n        super(PasswordResetForm, self).send_mail(\n            subject_template_name, email_template_name,\n            context, from_email, to_email, html_email_template_name)\n\n\nclass VerifySMSCodeForm(forms.Form):\n    \"\"\"A form to verify a code received by SMS.\"\"\"\n\n    code = forms.CharField(\n        label=ugettext_lazy(\"Verification code\"),\n        widget=forms.widgets.TextInput(attrs={\"class\": \"form-control\"})\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.totp_secret = kwargs.pop(\"totp_secret\")\n        super().__init__(*args, **kwargs)\n\n    def clean_code(self):\n        code = self.cleaned_data[\"code\"]\n        if not oath.accept_totp(self.totp_secret, code)[0]:\n            raise forms.ValidationError(_(\"Invalid code\"))\n        return code\n\n\nclass Verify2FACodeForm(UserKwargModelFormMixin, forms.Form):\n    \"\"\"A form to verify 2FA codes validity.\"\"\"\n\n    tfa_code = forms.CharField()\n\n    def clean_tfa_code(self):\n        code = self.cleaned_data[\"tfa_code\"]\n        device = django_otp.match_token(self.user, code)\n        if device is None:\n            raise forms.ValidationError(_(\"This code is invalid\"))\n        return device\n", "\"\"\"Tests for core application.\"\"\"\n\nfrom io import StringIO\n\nimport httmock\nfrom dateutil.relativedelta import relativedelta\n\nfrom django.core import mail\nfrom django.core import management\nfrom django.test import TestCase\nfrom django.urls import reverse\nfrom django.utils import timezone\n\nfrom modoboa.lib.tests import ModoTestCase, SimpleModoTestCase\nfrom .. import factories, mocks, models\n\n\nclass AuthenticationTestCase(ModoTestCase):\n\n    \"\"\"Validate authentication scenarios.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):  # NOQA:N802\n        \"\"\"Create test data.\"\"\"\n        super(AuthenticationTestCase, cls).setUpTestData()\n        cls.account = factories.UserFactory(\n            username=\"user@test.com\", groups=(\"SimpleUsers\",)\n        )\n\n    def test_authentication(self):\n        \"\"\"Validate simple case.\"\"\"\n        self.client.logout()\n        data = {\"username\": \"user@test.com\", \"password\": \"toto\"}\n        response = self.client.post(reverse(\"core:login\"), data)\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response.url.endswith(reverse(\"core:user_index\")))\n\n        response = self.client.post(reverse(\"core:logout\"), {})\n        self.assertEqual(response.status_code, 302)\n\n        data = {\"username\": \"admin\", \"password\": \"password\"}\n        response = self.client.post(reverse(\"core:login\"), data)\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response.url.endswith(reverse(\"core:dashboard\")))\n\n\nclass ManagementCommandsTestCase(SimpleModoTestCase):\n    \"\"\"Test management commands.\"\"\"\n\n    def test_change_default_admin(self):\n        \"\"\"Use dedicated option.\"\"\"\n        management.call_command(\n            \"load_initial_data\", \"--admin-username\", \"modoadmin\")\n        self.assertTrue(\n            self.client.login(username=\"modoadmin\", password=\"password\"))\n\n    def test_clean_logs(self):\n        \"\"\"Run cleanlogs command.\"\"\"\n        log1 = factories.LogFactory()\n        factories.LogFactory()\n        log1.date_created -= relativedelta(years=2)\n        log1.save(update_fields=[\"date_created\"])\n        management.call_command(\"cleanlogs\")\n        self.assertEqual(models.Log.objects.count(), 1)\n\n    def test_clean_inactive_accounts(self):\n        \"\"\"Run clean_inactive_accounts command.\"\"\"\n        management.call_command(\"load_initial_data\")\n\n        # no inactive account, should exit normaly\n        management.call_command(\"clean_inactive_accounts\")\n\n        last_login = timezone.now() - relativedelta(days=45)\n        account = factories.UserFactory(\n            username=\"user1@domain.test\", groups=(\"SimpleUsers\", ),\n            last_login=last_login\n        )\n        management.call_command(\"clean_inactive_accounts\", \"--dry-run\")\n        account.refresh_from_db()\n        self.assertTrue(account.is_active)\n\n        out = StringIO()\n        management.call_command(\n            \"clean_inactive_accounts\", \"--verbose\", \"--dry-run\", stdout=out)\n        self.assertIn(\"user1@domain.test\", out.getvalue())\n\n        # Disable account account threshold\n        self.set_global_parameter(\"enable_inactive_accounts\", False)\n        out = StringIO()\n        management.call_command(\n            \"clean_inactive_accounts\", \"--verbose\", stdout=out)\n        self.assertIn(\"Inactive accounts detection is disabled.\",\n                      out.getvalue())\n\n        self.set_global_parameter(\"enable_inactive_accounts\", True)\n        management.call_command(\"clean_inactive_accounts\", \"--silent\")\n        account.refresh_from_db()\n        self.assertFalse(account.is_active)\n\n        account.is_active = True\n        account.save(update_fields=[\"is_active\"])\n\n        management.call_command(\n            \"clean_inactive_accounts\", \"--silent\", \"--delete\")\n        with self.assertRaises(models.User.DoesNotExist):\n            account.refresh_from_db()\n\n\nclass ProfileTestCase(ModoTestCase):\n    \"\"\"Profile related tests.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):  # NOQA:N802\n        \"\"\"Create test data.\"\"\"\n        super(ProfileTestCase, cls).setUpTestData()\n        cls.account = factories.UserFactory(\n            username=\"user@test.com\", groups=(\"SimpleUsers\",)\n        )\n\n    def test_update_profile(self):\n        \"\"\"Update profile without password.\"\"\"\n        data = {\n            \"first_name\": \"Homer\", \"last_name\": \"Simpson\",\n            \"phone_number\": \"+33612345678\", \"language\": \"en\"\n        }\n        self.ajax_post(reverse(\"core:user_profile\"), data)\n        admin = models.User.objects.get(username=\"admin\")\n        self.assertEqual(admin.last_name, \"Simpson\")\n\n    def test_update_password(self):\n        \"\"\"Password update\n\n        Two cases:\n        * The default admin changes his password (no associated Mailbox)\n        * A normal user changes his password\n        \"\"\"\n        self.ajax_post(reverse(\"core:user_profile\"),\n                       {\"language\": \"en\", \"oldpassword\": \"password\",\n                        \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"})\n        self.client.logout()\n\n        self.assertEqual(\n            self.client.login(username=\"admin\", password=\"12345Toi\"), True\n        )\n        self.assertEqual(\n            self.client.login(username=\"user@test.com\", password=\"toto\"), True\n        )\n\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"oldpassword\": \"toto\",\n             \"confirmation\": \"tutu\"},\n            status=400\n        )\n\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"oldpassword\": \"toto\",\n             \"newpassword\": \"tutu\", \"confirmation\": \"tutu\"},\n            status=400\n        )\n\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"language\": \"en\", \"oldpassword\": \"toto\",\n             \"newpassword\": \"Toto1234\", \"confirmation\": \"Toto1234\"}\n        )\n        self.client.logout()\n        self.assertTrue(\n            self.client.login(username=\"user@test.com\", password=\"Toto1234\")\n        )\n\n    def test_update_password_restrictions(self):\n        self.ajax_post(\n            reverse(\"core:user_profile\"),\n            {\"language\": \"en\", \"oldpassword\": \"\",\n             \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"},\n            status=400\n        )\n        self.client.logout()\n\n        self.assertEqual(\n            self.client.login(username=\"admin\", password=\"12345Toi\"), False\n        )\n\n    def test_update_password_url(self):\n        \"\"\"Check if external is used when defined.\"\"\"\n        self.set_global_parameter(\n            \"update_password_url\", \"http://update.password\")\n        non_local_user = factories.UserFactory(\n            username=\"user@external.com\", groups=(\"SimpleUsers\",),\n            is_local=False\n        )\n        self.client.force_login(non_local_user)\n        url = reverse(\"core:user_profile\")\n        response = self.client.get(url)\n        self.assertContains(response, \"http://update.password\")\n\n        self.client.force_login(self.account)\n        response = self.client.get(url)\n        self.assertNotContains(response, \"http://update.password\")\n\n\nclass APIAccessFormTestCase(ModoTestCase):\n\n    \"\"\"Check form access.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):  # NOQA:N802\n        \"\"\"Create test data.\"\"\"\n        super(APIAccessFormTestCase, cls).setUpTestData()\n        cls.account = factories.UserFactory(\n            username=\"user@test.com\", groups=(\"SimpleUsers\",)\n        )\n\n    def test_form_access(self):\n        \"\"\"Check access restrictions.\"\"\"\n        url = reverse(\"core:user_api_access\")\n        self.ajax_get(url)\n        self.client.logout()\n        self.client.login(username=\"user@test.com\", password=\"toto\")\n        response = self.client.get(url, HTTP_X_REQUESTED_WITH=\"XMLHttpRequest\")\n        self.assertEqual(response.status_code, 278)\n\n    def test_form(self):\n        \"\"\"Check that token is created/removed.\"\"\"\n        url = reverse(\"core:user_api_access\")\n        self.ajax_post(url, {\"enable_api_access\": True})\n        user = models.User.objects.get(username=\"admin\")\n        self.assertTrue(hasattr(user, \"auth_token\"))\n        self.ajax_post(url, {\"enable_api_access\": False})\n        user = models.User.objects.get(username=\"admin\")\n        self.assertFalse(hasattr(user, \"auth_token\"))\n\n\nclass APICommunicationTestCase(ModoTestCase):\n    \"\"\"Check communication with the API.\"\"\"\n\n    def test_management_command(self):\n        \"\"\"Check command.\"\"\"\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(models.LocalConfig.objects.first().api_pk, 100)\n        self.assertEqual(len(mail.outbox), 0)\n\n        url = reverse(\"core:information\")\n        response = self.ajax_request(\"get\", url)\n        self.assertIn(\"9.0.0\", response[\"content\"])\n\n        # Enable notifications\n        self.set_global_parameter(\"send_new_versions_email\", True)\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(len(mail.outbox), 1)\n\n        # Call once again and check no new notification has been sent\n        self.set_global_parameter(\"send_new_versions_email\", True)\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(len(mail.outbox), 1)\n\n        # Make sure no new notification is sent when no updates\n        with httmock.HTTMock(\n                mocks.modo_api_instance_search,\n                mocks.modo_api_instance_create,\n                mocks.modo_api_instance_update,\n                mocks.modo_api_versions_no_update):\n            management.call_command(\"communicate_with_public_api\")\n        self.assertEqual(len(mail.outbox), 1)\n"], "filenames": ["modoboa/core/forms.py", "modoboa/core/tests/test_core.py"], "buggy_code_start_loc": [94, 151], "buggy_code_end_loc": [94, 151], "fixing_code_start_loc": [95, 152], "fixing_code_end_loc": [100, 159], "type": "CWE-521", "message": "Weak Password Requirements in GitHub repository modoboa/modoboa prior to 2.1.0.", "other": {"cve": {"id": "CVE-2023-2160", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-18T16:15:09.283", "lastModified": "2023-04-27T19:53:28.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Weak Password Requirements in GitHub repository modoboa/modoboa prior to 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-521"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:modoboa:modoboa:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "EDF096DF-1D51-43ED-9F11-D69473204DEE"}]}]}], "references": [{"url": "https://github.com/modoboa/modoboa/commit/130257c96a2392ada795785a91178e656e27015c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/54fb6d6a-6b39-45b6-b62a-930260ba484b", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/modoboa/modoboa/commit/130257c96a2392ada795785a91178e656e27015c"}}