{"buggy_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth SCO sockets. */\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <net/sock.h>\n\n#include <asm/system.h>\n#include <linux/uaccess.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/sco.h>\n\n#define VERSION \"0.6\"\n\nstatic int disable_esco;\n\nstatic const struct proto_ops sco_sock_ops;\n\nstatic struct bt_sock_list sco_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(sco_sk_list.lock)\n};\n\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent);\nstatic void sco_chan_del(struct sock *sk, int err);\n\nstatic int  sco_conn_del(struct hci_conn *conn, int err);\n\nstatic void sco_sock_close(struct sock *sk);\nstatic void sco_sock_kill(struct sock *sk);\n\n/* ---- SCO timers ---- */\nstatic void sco_sock_timeout(unsigned long arg)\n{\n\tstruct sock *sk = (struct sock *) arg;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tbh_lock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\tbh_unlock_sock(sk);\n\n\tsco_sock_kill(sk);\n\tsock_put(sk);\n}\n\nstatic void sco_sock_set_timer(struct sock *sk, long timeout)\n{\n\tBT_DBG(\"sock %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tsk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);\n}\n\nstatic void sco_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}\n\n/* ---- SCO connections ---- */\nstatic struct sco_conn *sco_conn_add(struct hci_conn *hcon, __u8 status)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (conn || status)\n\t\treturn conn;\n\n\tconn = kzalloc(sizeof(struct sco_conn), GFP_ATOMIC);\n\tif (!conn)\n\t\treturn NULL;\n\n\tspin_lock_init(&conn->lock);\n\n\thcon->sco_data = conn;\n\tconn->hcon = hcon;\n\n\tconn->src = &hdev->bdaddr;\n\tconn->dst = &hcon->dst;\n\n\tif (hdev->sco_mtu > 0)\n\t\tconn->mtu = hdev->sco_mtu;\n\telse\n\t\tconn->mtu = 60;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\treturn conn;\n}\n\nstatic inline struct sock *sco_chan_get(struct sco_conn *conn)\n{\n\tstruct sock *sk = NULL;\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\treturn sk;\n}\n\nstatic int sco_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn 0;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t/* Kill socket */\n\tsk = sco_chan_get(conn);\n\tif (sk) {\n\t\tbh_lock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsco_chan_del(sk, err);\n\t\tbh_unlock_sock(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\n\thcon->sco_data = NULL;\n\tkfree(conn);\n\treturn 0;\n}\n\nstatic inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tint err = 0;\n\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\n\tsco_conn_unlock(conn);\n\treturn err;\n}\n\nstatic int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock_bh(hdev);\n\n\terr = -ENOMEM;\n\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(src, conn->src);\n\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\n\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\n\nstatic inline int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err, count;\n\n\t/* Check outgoing MTU */\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\tcount = min_t(unsigned int, conn->mtu, len);\n\tskb = bt_skb_send_alloc(sk, count,\n\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\thci_send_sco(conn->hcon, skb);\n\n\treturn count;\n}\n\nstatic inline void sco_recv_frame(struct sco_conn *conn, struct sk_buff *skb)\n{\n\tstruct sock *sk = sco_chan_get(conn);\n\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\treturn;\n\ndrop:\n\tkfree_skb(skb);\n}\n\n/* -------- Socket interface ---------- */\nstatic struct sock *__sco_get_sock_by_addr(bdaddr_t *ba)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &sco_sk_list.head)\n\t\tif (!bacmp(&bt_sk(sk)->src, ba))\n\t\t\tgoto found;\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n/* Find socket listening on source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *sco_get_sock_listen(bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\tstruct hlist_node *node;\n\n\tread_lock(&sco_sk_list.lock);\n\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\t/* Exact match. */\n\t\tif (!bacmp(&bt_sk(sk)->src, src))\n\t\t\tbreak;\n\n\t\t/* Closest match */\n\t\tif (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))\n\t\t\tsk1 = sk;\n\t}\n\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn node ? sk : sk1;\n}\n\nstatic void sco_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void sco_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&sco_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __sco_sock_close(struct sock *sk)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tsco_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tsco_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Must be called on unlocked socket. */\nstatic void sco_sock_close(struct sock *sk)\n{\n\tsco_sock_clear_timer(sk);\n\tlock_sock(sk);\n\t__sco_sock_close(sk);\n\trelease_sock(sk);\n\tsco_sock_kill(sk);\n}\n\nstatic void sco_sock_init(struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent)\n\t\tsk->sk_type = parent->sk_type;\n}\n\nstatic struct proto sco_proto = {\n\t.name\t\t= \"SCO\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct sco_pinfo)\n};\n\nstatic struct sock *sco_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = sco_sock_destruct;\n\tsk->sk_sndtimeo = SCO_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\tsetup_timer(&sk->sk_timer, sco_sock_timeout, (unsigned long)sk);\n\n\tbt_sock_link(&sco_sk_list, sk);\n\treturn sk;\n}\n\nstatic int sco_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &sco_sock_ops;\n\n\tsk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsco_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tbdaddr_t *src = &sa->sco_bdaddr;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %s\", sk, batostr(&sa->sco_bdaddr));\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\twrite_lock_bh(&sco_sk_list.lock);\n\n\tif (bacmp(src, BDADDR_ANY) && __sco_get_sock_by_addr(src)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock_bh(&sco_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t/* Set destination address and psm */\n\tbacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);\n\n\terr = sco_connect(sk);\n\tif (err)\n\t\tgoto done;\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *ch;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_LISTEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(ch = bt_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", ch);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_sco);\n\n\tif (peer)\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);\n\n\treturn 0;\n}\n\nstatic int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tsco_sock_clear_timer(sk);\n\t\t__sco_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t\tsk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsco_sock_close(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime) {\n\t\tlock_sock(sk);\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t\trelease_sock(sk);\n\t}\n\n\tsock_orphan(sk);\n\tsco_sock_kill(sk);\n\treturn err;\n}\n\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk);\n}\n\n/* Delete channel.\n * Must be called on the locked socket. */\nstatic void sco_chan_del(struct sock *sk, int err)\n{\n\tstruct sco_conn *conn;\n\n\tconn = sco_pi(sk)->conn;\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\tsco_conn_lock(conn);\n\t\tconn->sk = NULL;\n\t\tsco_pi(sk)->conn = NULL;\n\t\tsco_conn_unlock(conn);\n\t\thci_conn_put(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsk->sk_err   = err;\n\tsk->sk_state_change(sk);\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n}\n\nstatic void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tsco_conn_lock(conn);\n\n\tif (sk) {\n\t\tsco_sock_clear_timer(sk);\n\t\tbh_lock_sock(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\tbh_unlock_sock(sk);\n\t} else {\n\t\tparent = sco_get_sock_listen(conn->src);\n\t\tif (!parent)\n\t\t\tgoto done;\n\n\t\tbh_lock_sock(parent);\n\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\tBTPROTO_SCO, GFP_ATOMIC);\n\t\tif (!sk) {\n\t\t\tbh_unlock_sock(parent);\n\t\t\tgoto done;\n\t\t}\n\n\t\tsco_sock_init(sk, parent);\n\n\t\tbacpy(&bt_sk(sk)->src, conn->src);\n\t\tbacpy(&bt_sk(sk)->dst, conn->dst);\n\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\n\t\tsk->sk_state = BT_CONNECTED;\n\n\t\t/* Wake up parent */\n\t\tparent->sk_data_ready(parent, 1);\n\n\t\tbh_unlock_sock(parent);\n\t}\n\ndone:\n\tsco_conn_unlock(conn);\n}\n\n/* ----- SCO interface with lower layer (HCI) ----- */\nstatic int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)\n{\n\tregister struct sock *sk;\n\tstruct hlist_node *node;\n\tint lm = 0;\n\n\tif (type != SCO_LINK && type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"hdev %s, bdaddr %s\", hdev->name, batostr(bdaddr));\n\n\t/* Find listening sockets */\n\tread_lock(&sco_sk_list.lock);\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||\n\t\t\t\t!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\n\t\t\tlm |= HCI_LM_ACCEPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn lm;\n}\n\nstatic int sco_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tBT_DBG(\"hcon %p bdaddr %s status %d\", hcon, batostr(&hcon->dst), status);\n\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tif (!status) {\n\t\tstruct sco_conn *conn;\n\n\t\tconn = sco_conn_add(hcon, status);\n\t\tif (conn)\n\t\t\tsco_conn_ready(conn);\n\t} else\n\t\tsco_conn_del(hcon, bt_err(status));\n\n\treturn 0;\n}\n\nstatic int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)\n{\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tsco_conn_del(hcon, bt_err(reason));\n\n\treturn 0;\n}\n\nstatic int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d\", conn, skb->len);\n\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn 0;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int sco_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tread_lock_bh(&sco_sk_list.lock);\n\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tseq_printf(f, \"%s %s %d\\n\", batostr(&bt_sk(sk)->src),\n\t\t\t\tbatostr(&bt_sk(sk)->dst), sk->sk_state);\n\t}\n\n\tread_unlock_bh(&sco_sk_list.lock);\n\n\treturn 0;\n}\n\nstatic int sco_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, sco_debugfs_show, inode->i_private);\n}\n\nstatic const struct file_operations sco_debugfs_fops = {\n\t.open\t\t= sco_debugfs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic struct dentry *sco_debugfs;\n\nstatic const struct proto_ops sco_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= sco_sock_release,\n\t.bind\t\t= sco_sock_bind,\n\t.connect\t= sco_sock_connect,\n\t.listen\t\t= sco_sock_listen,\n\t.accept\t\t= sco_sock_accept,\n\t.getname\t= sco_sock_getname,\n\t.sendmsg\t= sco_sock_sendmsg,\n\t.recvmsg\t= bt_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= sco_sock_shutdown,\n\t.setsockopt\t= sco_sock_setsockopt,\n\t.getsockopt\t= sco_sock_getsockopt\n};\n\nstatic const struct net_proto_family sco_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= sco_sock_create,\n};\n\nstatic struct hci_proto sco_hci_proto = {\n\t.name\t\t= \"SCO\",\n\t.id\t\t= HCI_PROTO_SCO,\n\t.connect_ind\t= sco_connect_ind,\n\t.connect_cfm\t= sco_connect_cfm,\n\t.disconn_cfm\t= sco_disconn_cfm,\n\t.recv_scodata\t= sco_recv_scodata\n};\n\nstatic int __init sco_init(void)\n{\n\tint err;\n\n\terr = proto_register(&sco_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_SCO, &sco_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"SCO socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = hci_register_proto(&sco_hci_proto);\n\tif (err < 0) {\n\t\tBT_ERR(\"SCO protocol registration failed\");\n\t\tbt_sock_unregister(BTPROTO_SCO);\n\t\tgoto error;\n\t}\n\n\tif (bt_debugfs) {\n\t\tsco_debugfs = debugfs_create_file(\"sco\", 0444,\n\t\t\t\t\tbt_debugfs, NULL, &sco_debugfs_fops);\n\t\tif (!sco_debugfs)\n\t\t\tBT_ERR(\"Failed to create SCO debug file\");\n\t}\n\n\tBT_INFO(\"SCO (Voice Link) ver %s\", VERSION);\n\tBT_INFO(\"SCO socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&sco_proto);\n\treturn err;\n}\n\nstatic void __exit sco_exit(void)\n{\n\tdebugfs_remove(sco_debugfs);\n\n\tif (bt_sock_unregister(BTPROTO_SCO) < 0)\n\t\tBT_ERR(\"SCO socket unregistration failed\");\n\n\tif (hci_unregister_proto(&sco_hci_proto) < 0)\n\t\tBT_ERR(\"SCO protocol unregistration failed\");\n\n\tproto_unregister(&sco_proto);\n}\n\nmodule_init(sco_init);\nmodule_exit(sco_exit);\n\nmodule_param(disable_esco, bool, 0644);\nMODULE_PARM_DESC(disable_esco, \"Disable eSCO connection creation\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth SCO ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-2\");\n"], "fixing_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth SCO sockets. */\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <net/sock.h>\n\n#include <asm/system.h>\n#include <linux/uaccess.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/sco.h>\n\n#define VERSION \"0.6\"\n\nstatic int disable_esco;\n\nstatic const struct proto_ops sco_sock_ops;\n\nstatic struct bt_sock_list sco_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(sco_sk_list.lock)\n};\n\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent);\nstatic void sco_chan_del(struct sock *sk, int err);\n\nstatic int  sco_conn_del(struct hci_conn *conn, int err);\n\nstatic void sco_sock_close(struct sock *sk);\nstatic void sco_sock_kill(struct sock *sk);\n\n/* ---- SCO timers ---- */\nstatic void sco_sock_timeout(unsigned long arg)\n{\n\tstruct sock *sk = (struct sock *) arg;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tbh_lock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\tbh_unlock_sock(sk);\n\n\tsco_sock_kill(sk);\n\tsock_put(sk);\n}\n\nstatic void sco_sock_set_timer(struct sock *sk, long timeout)\n{\n\tBT_DBG(\"sock %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tsk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);\n}\n\nstatic void sco_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}\n\n/* ---- SCO connections ---- */\nstatic struct sco_conn *sco_conn_add(struct hci_conn *hcon, __u8 status)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (conn || status)\n\t\treturn conn;\n\n\tconn = kzalloc(sizeof(struct sco_conn), GFP_ATOMIC);\n\tif (!conn)\n\t\treturn NULL;\n\n\tspin_lock_init(&conn->lock);\n\n\thcon->sco_data = conn;\n\tconn->hcon = hcon;\n\n\tconn->src = &hdev->bdaddr;\n\tconn->dst = &hcon->dst;\n\n\tif (hdev->sco_mtu > 0)\n\t\tconn->mtu = hdev->sco_mtu;\n\telse\n\t\tconn->mtu = 60;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\treturn conn;\n}\n\nstatic inline struct sock *sco_chan_get(struct sco_conn *conn)\n{\n\tstruct sock *sk = NULL;\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\treturn sk;\n}\n\nstatic int sco_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn 0;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t/* Kill socket */\n\tsk = sco_chan_get(conn);\n\tif (sk) {\n\t\tbh_lock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsco_chan_del(sk, err);\n\t\tbh_unlock_sock(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\n\thcon->sco_data = NULL;\n\tkfree(conn);\n\treturn 0;\n}\n\nstatic inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tint err = 0;\n\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\n\tsco_conn_unlock(conn);\n\treturn err;\n}\n\nstatic int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock_bh(hdev);\n\n\terr = -ENOMEM;\n\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(src, conn->src);\n\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\n\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\n\nstatic inline int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err, count;\n\n\t/* Check outgoing MTU */\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\tcount = min_t(unsigned int, conn->mtu, len);\n\tskb = bt_skb_send_alloc(sk, count,\n\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\thci_send_sco(conn->hcon, skb);\n\n\treturn count;\n}\n\nstatic inline void sco_recv_frame(struct sco_conn *conn, struct sk_buff *skb)\n{\n\tstruct sock *sk = sco_chan_get(conn);\n\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\treturn;\n\ndrop:\n\tkfree_skb(skb);\n}\n\n/* -------- Socket interface ---------- */\nstatic struct sock *__sco_get_sock_by_addr(bdaddr_t *ba)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &sco_sk_list.head)\n\t\tif (!bacmp(&bt_sk(sk)->src, ba))\n\t\t\tgoto found;\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n/* Find socket listening on source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *sco_get_sock_listen(bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\tstruct hlist_node *node;\n\n\tread_lock(&sco_sk_list.lock);\n\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\t/* Exact match. */\n\t\tif (!bacmp(&bt_sk(sk)->src, src))\n\t\t\tbreak;\n\n\t\t/* Closest match */\n\t\tif (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))\n\t\t\tsk1 = sk;\n\t}\n\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn node ? sk : sk1;\n}\n\nstatic void sco_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void sco_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&sco_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __sco_sock_close(struct sock *sk)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tsco_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tsco_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Must be called on unlocked socket. */\nstatic void sco_sock_close(struct sock *sk)\n{\n\tsco_sock_clear_timer(sk);\n\tlock_sock(sk);\n\t__sco_sock_close(sk);\n\trelease_sock(sk);\n\tsco_sock_kill(sk);\n}\n\nstatic void sco_sock_init(struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent)\n\t\tsk->sk_type = parent->sk_type;\n}\n\nstatic struct proto sco_proto = {\n\t.name\t\t= \"SCO\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct sco_pinfo)\n};\n\nstatic struct sock *sco_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = sco_sock_destruct;\n\tsk->sk_sndtimeo = SCO_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\tsetup_timer(&sk->sk_timer, sco_sock_timeout, (unsigned long)sk);\n\n\tbt_sock_link(&sco_sk_list, sk);\n\treturn sk;\n}\n\nstatic int sco_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &sco_sock_ops;\n\n\tsk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsco_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tbdaddr_t *src = &sa->sco_bdaddr;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %s\", sk, batostr(&sa->sco_bdaddr));\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\twrite_lock_bh(&sco_sk_list.lock);\n\n\tif (bacmp(src, BDADDR_ANY) && __sco_get_sock_by_addr(src)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock_bh(&sco_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t/* Set destination address and psm */\n\tbacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);\n\n\terr = sco_connect(sk);\n\tif (err)\n\t\tgoto done;\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *ch;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_LISTEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(ch = bt_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", ch);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_sco);\n\n\tif (peer)\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);\n\n\treturn 0;\n}\n\nstatic int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tsco_sock_clear_timer(sk);\n\t\t__sco_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t\tsk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsco_sock_close(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime) {\n\t\tlock_sock(sk);\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t\trelease_sock(sk);\n\t}\n\n\tsock_orphan(sk);\n\tsco_sock_kill(sk);\n\treturn err;\n}\n\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk);\n}\n\n/* Delete channel.\n * Must be called on the locked socket. */\nstatic void sco_chan_del(struct sock *sk, int err)\n{\n\tstruct sco_conn *conn;\n\n\tconn = sco_pi(sk)->conn;\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\tsco_conn_lock(conn);\n\t\tconn->sk = NULL;\n\t\tsco_pi(sk)->conn = NULL;\n\t\tsco_conn_unlock(conn);\n\t\thci_conn_put(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsk->sk_err   = err;\n\tsk->sk_state_change(sk);\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n}\n\nstatic void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tsco_conn_lock(conn);\n\n\tif (sk) {\n\t\tsco_sock_clear_timer(sk);\n\t\tbh_lock_sock(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\tbh_unlock_sock(sk);\n\t} else {\n\t\tparent = sco_get_sock_listen(conn->src);\n\t\tif (!parent)\n\t\t\tgoto done;\n\n\t\tbh_lock_sock(parent);\n\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\tBTPROTO_SCO, GFP_ATOMIC);\n\t\tif (!sk) {\n\t\t\tbh_unlock_sock(parent);\n\t\t\tgoto done;\n\t\t}\n\n\t\tsco_sock_init(sk, parent);\n\n\t\tbacpy(&bt_sk(sk)->src, conn->src);\n\t\tbacpy(&bt_sk(sk)->dst, conn->dst);\n\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\n\t\tsk->sk_state = BT_CONNECTED;\n\n\t\t/* Wake up parent */\n\t\tparent->sk_data_ready(parent, 1);\n\n\t\tbh_unlock_sock(parent);\n\t}\n\ndone:\n\tsco_conn_unlock(conn);\n}\n\n/* ----- SCO interface with lower layer (HCI) ----- */\nstatic int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)\n{\n\tregister struct sock *sk;\n\tstruct hlist_node *node;\n\tint lm = 0;\n\n\tif (type != SCO_LINK && type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"hdev %s, bdaddr %s\", hdev->name, batostr(bdaddr));\n\n\t/* Find listening sockets */\n\tread_lock(&sco_sk_list.lock);\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||\n\t\t\t\t!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\n\t\t\tlm |= HCI_LM_ACCEPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn lm;\n}\n\nstatic int sco_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tBT_DBG(\"hcon %p bdaddr %s status %d\", hcon, batostr(&hcon->dst), status);\n\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tif (!status) {\n\t\tstruct sco_conn *conn;\n\n\t\tconn = sco_conn_add(hcon, status);\n\t\tif (conn)\n\t\t\tsco_conn_ready(conn);\n\t} else\n\t\tsco_conn_del(hcon, bt_err(status));\n\n\treturn 0;\n}\n\nstatic int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)\n{\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tsco_conn_del(hcon, bt_err(reason));\n\n\treturn 0;\n}\n\nstatic int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d\", conn, skb->len);\n\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn 0;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int sco_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tread_lock_bh(&sco_sk_list.lock);\n\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tseq_printf(f, \"%s %s %d\\n\", batostr(&bt_sk(sk)->src),\n\t\t\t\tbatostr(&bt_sk(sk)->dst), sk->sk_state);\n\t}\n\n\tread_unlock_bh(&sco_sk_list.lock);\n\n\treturn 0;\n}\n\nstatic int sco_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, sco_debugfs_show, inode->i_private);\n}\n\nstatic const struct file_operations sco_debugfs_fops = {\n\t.open\t\t= sco_debugfs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic struct dentry *sco_debugfs;\n\nstatic const struct proto_ops sco_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= sco_sock_release,\n\t.bind\t\t= sco_sock_bind,\n\t.connect\t= sco_sock_connect,\n\t.listen\t\t= sco_sock_listen,\n\t.accept\t\t= sco_sock_accept,\n\t.getname\t= sco_sock_getname,\n\t.sendmsg\t= sco_sock_sendmsg,\n\t.recvmsg\t= bt_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= sco_sock_shutdown,\n\t.setsockopt\t= sco_sock_setsockopt,\n\t.getsockopt\t= sco_sock_getsockopt\n};\n\nstatic const struct net_proto_family sco_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= sco_sock_create,\n};\n\nstatic struct hci_proto sco_hci_proto = {\n\t.name\t\t= \"SCO\",\n\t.id\t\t= HCI_PROTO_SCO,\n\t.connect_ind\t= sco_connect_ind,\n\t.connect_cfm\t= sco_connect_cfm,\n\t.disconn_cfm\t= sco_disconn_cfm,\n\t.recv_scodata\t= sco_recv_scodata\n};\n\nstatic int __init sco_init(void)\n{\n\tint err;\n\n\terr = proto_register(&sco_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_SCO, &sco_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"SCO socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = hci_register_proto(&sco_hci_proto);\n\tif (err < 0) {\n\t\tBT_ERR(\"SCO protocol registration failed\");\n\t\tbt_sock_unregister(BTPROTO_SCO);\n\t\tgoto error;\n\t}\n\n\tif (bt_debugfs) {\n\t\tsco_debugfs = debugfs_create_file(\"sco\", 0444,\n\t\t\t\t\tbt_debugfs, NULL, &sco_debugfs_fops);\n\t\tif (!sco_debugfs)\n\t\t\tBT_ERR(\"Failed to create SCO debug file\");\n\t}\n\n\tBT_INFO(\"SCO (Voice Link) ver %s\", VERSION);\n\tBT_INFO(\"SCO socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&sco_proto);\n\treturn err;\n}\n\nstatic void __exit sco_exit(void)\n{\n\tdebugfs_remove(sco_debugfs);\n\n\tif (bt_sock_unregister(BTPROTO_SCO) < 0)\n\t\tBT_ERR(\"SCO socket unregistration failed\");\n\n\tif (hci_unregister_proto(&sco_hci_proto) < 0)\n\t\tBT_ERR(\"SCO protocol unregistration failed\");\n\n\tproto_unregister(&sco_proto);\n}\n\nmodule_init(sco_init);\nmodule_exit(sco_exit);\n\nmodule_param(disable_esco, bool, 0644);\nMODULE_PARM_DESC(disable_esco, \"Disable eSCO connection creation\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth SCO ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-2\");\n"], "filenames": ["net/bluetooth/sco.c"], "buggy_code_start_loc": [705], "buggy_code_end_loc": [705], "fixing_code_start_loc": [706], "fixing_code_end_loc": [707], "type": "CWE-200", "message": "The sco_sock_getsockopt_old function in net/bluetooth/sco.c in the Linux kernel before 2.6.39 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory via the SCO_CONNINFO option.", "other": {"cve": {"id": "CVE-2011-1078", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:01.990", "lastModified": "2023-02-13T04:29:02.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The sco_sock_getsockopt_old function in net/bluetooth/sco.c in the Linux kernel before 2.6.39 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory via the SCO_CONNINFO option."}, {"lang": "es", "value": "La funci\u00f3n sco_sock_getsockopt_old en net/bluetooth/sco.c en el kernel de Linux anteriores a v2.6.39 no inicializa una estructura concreta, lo que permite a usuarios locales obtener informaci\u00f3n sensible de la de pila memoria del n\u00facleo a trav\u00e9s de la opci\u00f3n SCO_CONNINFO."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:*:*:*:*:*:*:*", "matchCriteriaId": "7462DB6D-E0A6-4DBB-8E21-66B875184FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DDCB342-4F5F-4BF1-9624-882BBC57330D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc2:*:*:*:*:*:*", "matchCriteriaId": "C3AB4113-BF83-4587-8A85-0E4FECEE7D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc3:*:*:*:*:*:*", "matchCriteriaId": "4B57F5AD-A697-4090-89B9-81BC12993A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc4:*:*:*:*:*:*", "matchCriteriaId": "CA141BCB-A705-4DF5-9EED-746B62C86111"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc5:*:*:*:*:*:*", "matchCriteriaId": "E9ECE134-58A3-4B9D-B9B3-F836C0EDD64C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc6:*:*:*:*:*:*", "matchCriteriaId": "56186720-6B4C-4D71-85C5-7EAC5C5D84A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc7:*:*:*:*:*:*", "matchCriteriaId": "9BBB4630-CBED-43B9-B203-BE65BBF011AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD375A78-63D7-441A-9FB0-7BC878AB4EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5BEFFDD-02BB-4A05-8372-891DBDB9AC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.2:*:*:*:*:*:*:*", "matchCriteriaId": "766E193D-819C-42EA-8411-AE0013AC15FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.3:*:*:*:*:*:*:*", "matchCriteriaId": "3B39B6AF-6A83-48C2-BED2-79228F8513A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.4:*:*:*:*:*:*:*", "matchCriteriaId": "CD8A68D1-DFE9-4ADB-9FB8-4D69AB4CAFF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.5:*:*:*:*:*:*:*", "matchCriteriaId": "0D6EF951-AF15-4C30-A3A5-3392AA61813C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.6:*:*:*:*:*:*:*", "matchCriteriaId": "15154FA0-65DC-4855-AC70-3ACF92313F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.7:*:*:*:*:*:*:*", "matchCriteriaId": "F4B3A9F4-A61F-4919-A173-3E459F0C5AF8"}]}]}], "references": [{"url": "http://downloads.avaya.com/css/P8/documents/100145416", "source": "secalert@redhat.com"}, {"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=c4c896e1471aec3b004a693c689f60be3b17ac86", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2011-0833.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1156.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/03/01/10", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=681259", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86"}}