{"buggy_code": ["<?php\n\n/**\n * IdP implementation for SAML 2.0 protocol.\n *\n * @package SimpleSAMLphp\n */\nclass sspmod_saml_IdP_SAML2 {\n\n\t/**\n\t * Send a response to the SP.\n\t *\n\t * @param array $state  The authentication state.\n\t */\n\tpublic static function sendResponse(array $state) {\n\t\tassert('isset($state[\"Attributes\"])');\n\t\tassert('isset($state[\"SPMetadata\"])');\n\t\tassert('isset($state[\"saml:ConsumerURL\"])');\n\t\tassert('array_key_exists(\"saml:RequestId\", $state)'); // Can be NULL\n\t\tassert('array_key_exists(\"saml:RelayState\", $state)'); // Can be NULL.\n\n\t\t$spMetadata = $state[\"SPMetadata\"];\n\t\t$spEntityId = $spMetadata['entityid'];\n\t\t$spMetadata = SimpleSAML_Configuration::loadFromArray($spMetadata,\n\t\t\t'$metadata[' . var_export($spEntityId, TRUE) . ']');\n\n\t\tSimpleSAML_Logger::info('Sending SAML 2.0 Response to ' . var_export($spEntityId, TRUE));\n\n\t\t$requestId = $state['saml:RequestId'];\n\t\t$relayState = $state['saml:RelayState'];\n\t\t$consumerURL = $state['saml:ConsumerURL'];\n\t\t$protocolBinding = $state['saml:Binding'];\n\n\t\t$idp = SimpleSAML_IdP::getByState($state);\n\n\t\t$idpMetadata = $idp->getConfig();\n\n\t\t$assertion = self::buildAssertion($idpMetadata, $spMetadata, $state);\n\t\t\n\t\tif (isset($state['saml:AuthenticatingAuthority'])) {\n\t\t\t$assertion->setAuthenticatingAuthority($state['saml:AuthenticatingAuthority']);\n\t\t}\n\n\t\t// Create the session association (for logout).\n\t\t$association = array(\n\t\t\t'id' => 'saml:' . $spEntityId,\n\t\t\t'Handler' => 'sspmod_saml_IdP_SAML2',\n\t\t\t'Expires' => $assertion->getSessionNotOnOrAfter(),\n\t\t\t'saml:entityID' => $spEntityId,\n\t\t\t'saml:NameID' => $state['saml:idp:NameID'],\n\t\t\t'saml:SessionIndex' => $assertion->getSessionIndex(),\n\t\t);\n\n\t\t// Maybe encrypt the assertion.\n\t\t$assertion = self::encryptAssertion($idpMetadata, $spMetadata, $assertion);\n\n\t\t/* Create the response. */\n\t\t$ar = self::buildResponse($idpMetadata, $spMetadata, $consumerURL);\n\t\t$ar->setInResponseTo($requestId);\n\t\t$ar->setRelayState($relayState);\n\t\t$ar->setAssertions(array($assertion));\n\n\t\t/* Register the session association with the IdP. */\n\t\t$idp->addAssociation($association);\n\n\t\t$statsData = array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'protocol' => 'saml2',\n\t\t);\n\t\tif (isset($state['saml:AuthnRequestReceivedAt'])) {\n\t\t\t$statsData['logintime'] = microtime(TRUE) - $state['saml:AuthnRequestReceivedAt'];\n\t\t}\n\t\tSimpleSAML_Stats::log('saml:idp:Response', $statsData);\n\n\t\t/* Send the response. */\n\t\t$binding = SAML2_Binding::getBinding($protocolBinding);\n\t\t$binding->send($ar);\n\t}\n\n\n\t/**\n\t * Handle authentication error.\n\t *\n\t * SimpleSAML_Error_Exception $exception  The exception.\n\t * @param array $state  The error state.\n\t */\n\tpublic static function handleAuthError(SimpleSAML_Error_Exception $exception, array $state) {\n\t\tassert('isset($state[\"SPMetadata\"])');\n\t\tassert('isset($state[\"saml:ConsumerURL\"])');\n\t\tassert('array_key_exists(\"saml:RequestId\", $state)'); // Can be NULL.\n\t\tassert('array_key_exists(\"saml:RelayState\", $state)'); // Can be NULL.\n\n\t\t$spMetadata = $state[\"SPMetadata\"];\n\t\t$spEntityId = $spMetadata['entityid'];\n\t\t$spMetadata = SimpleSAML_Configuration::loadFromArray($spMetadata,\n\t\t\t'$metadata[' . var_export($spEntityId, TRUE) . ']');\n\n\t\t$requestId = $state['saml:RequestId'];\n\t\t$relayState = $state['saml:RelayState'];\n\t\t$consumerURL = $state['saml:ConsumerURL'];\n\t\t$protocolBinding = $state['saml:Binding'];\n\n\t\t$idp = SimpleSAML_IdP::getByState($state);\n\n\t\t$idpMetadata = $idp->getConfig();\n\n\t\t$error = sspmod_saml_Error::fromException($exception);\n\n\t\tSimpleSAML_Logger::warning('Returning error to sp: ' . var_export($spEntityId, TRUE));\n\t\t$error->logWarning();\n\n\t\t$ar = self::buildResponse($idpMetadata, $spMetadata, $consumerURL);\n\t\t$ar->setInResponseTo($requestId);\n\t\t$ar->setRelayState($relayState);\n\n\t\t$status = array(\n\t\t\t'Code' => $error->getStatus(),\n\t\t\t'SubCode' => $error->getSubStatus(),\n\t\t\t'Message' => $error->getStatusMessage(),\n\t\t);\n\t\t$ar->setStatus($status);\n\n\t\t$statsData = array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'protocol' => 'saml2',\n\t\t\t'error' => $status,\n\t\t);\n\t\tif (isset($state['saml:AuthnRequestReceivedAt'])) {\n\t\t\t$statsData['logintime'] = microtime(TRUE) - $state['saml:AuthnRequestReceivedAt'];\n\t\t}\n\t\tSimpleSAML_Stats::log('saml:idp:Response:error', $statsData);\n\n\t\t$binding = SAML2_Binding::getBinding($protocolBinding);\n\t\t$binding->send($ar);\n\t}\n\n\n\t/**\n\t * Find SP AssertionConsumerService based on parameter in AuthnRequest.\n\t *\n\t * @param array $supportedBindings  The bindings we allow for the response.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata for the SP.\n\t * @param string|NULL $AssertionConsumerServiceURL  AssertionConsumerServiceURL from request.\n\t * @param string|NULL $ProtocolBinding  ProtocolBinding from request.\n\t * @param int|NULL $AssertionConsumerServiceIndex  AssertionConsumerServiceIndex from request.\n\t * @return array  Array with the Location and Binding we should use for the response.\n\t */\n\tprivate static function getAssertionConsumerService(array $supportedBindings, SimpleSAML_Configuration $spMetadata,\n\t\t$AssertionConsumerServiceURL, $ProtocolBinding, $AssertionConsumerServiceIndex) {\n\t\tassert('is_string($AssertionConsumerServiceURL) || is_null($AssertionConsumerServiceURL)');\n\t\tassert('is_string($ProtocolBinding) || is_null($ProtocolBinding)');\n\t\tassert('is_int($AssertionConsumerServiceIndex) || is_null($AssertionConsumerServiceIndex)');\n\n\t\t/* We want to pick the best matching endpoint in the case where for example\n\t\t * only the ProtocolBinding is given. We therefore pick endpoints with the\n\t\t * following priority:\n\t\t *  1. isDefault=\"true\"\n\t\t *  2. isDefault unset\n\t\t *  3. isDefault=\"false\"\n\t\t */\n\t\t$firstNotFalse = NULL;\n\t\t$firstFalse = NULL;\n\t\tforeach ($spMetadata->getEndpoints('AssertionConsumerService') as $ep) {\n\n\t\t\tif ($AssertionConsumerServiceURL !== NULL && $ep['Location'] !== $AssertionConsumerServiceURL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($ProtocolBinding !== NULL && $ep['Binding'] !== $ProtocolBinding) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($AssertionConsumerServiceIndex !== NULL && $ep['index'] !== $AssertionConsumerServiceIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!in_array($ep['Binding'], $supportedBindings, TRUE)) {\n\t\t\t\t/* The endpoint has an unsupported binding. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* We have an endpoint that matches all our requirements. Check if it is the best one. */\n\n\t\t\tif (array_key_exists('isDefault', $ep)) {\n\t\t\t\tif ($ep['isDefault'] === TRUE) {\n\t\t\t\t\t/* This is the first matching endpoint with isDefault set to TRUE. */\n\t\t\t\t\treturn $ep;\n\t\t\t\t}\n\t\t\t\t/* isDefault is set to FALSE, but the endpoint is still useable. */\n\t\t\t\tif ($firstFalse === NULL) {\n\t\t\t\t\t/* This is the first endpoint that we can use. */\n\t\t\t\t\t$firstFalse = $ep;\n\t\t\t\t}\n\t\t\t} else if ($firstNotFalse === NULL) {\n\t\t\t\t/* This is the first endpoint without isDefault set. */\n\t\t\t\t$firstNotFalse = $ep;\n\t\t\t}\n\t\t}\n\n\t\tif ($firstNotFalse !== NULL) {\n\t\t\treturn $firstNotFalse;\n\t\t} elseif ($firstFalse !== NULL) {\n\t\t\treturn $firstFalse;\n\t\t}\n\n\t\tSimpleSAML_Logger::warning('Authentication request specifies invalid AssertionConsumerService:');\n\t\tif ($AssertionConsumerServiceURL !== NULL) {\n\t\t\tSimpleSAML_Logger::warning('AssertionConsumerServiceURL: ' . var_export($AssertionConsumerServiceURL, TRUE));\n\t\t}\n\t\tif ($ProtocolBinding !== NULL) {\n\t\t\tSimpleSAML_Logger::warning('ProtocolBinding: ' . var_export($ProtocolBinding, TRUE));\n\t\t}\n\t\tif ($AssertionConsumerServiceIndex !== NULL) {\n\t\t\tSimpleSAML_Logger::warning('AssertionConsumerServiceIndex: ' . var_export($AssertionConsumerServiceIndex, TRUE));\n\t\t}\n\n\t\t/* We have no good endpoints. Our last resort is to just use the default endpoint. */\n\t\treturn $spMetadata->getDefaultEndpoint('AssertionConsumerService', $supportedBindings);\n\t}\n\n\n\t/**\n\t * Receive an authentication request.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are receiving it for.\n\t */\n\tpublic static function receiveAuthnRequest(SimpleSAML_IdP $idp) {\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\n\t\t$supportedBindings = array(SAML2_Const::BINDING_HTTP_POST);\n\t\tif ($idpMetadata->getBoolean('saml20.sendartifact', FALSE)) {\n\t\t\t$supportedBindings[] = SAML2_Const::BINDING_HTTP_ARTIFACT;\n\t\t}\n\t\tif ($idpMetadata->getBoolean('saml20.hok.assertion', FALSE)) {\n\t\t\t$supportedBindings[] = SAML2_Const::BINDING_HOK_SSO;\n\t\t}\n\n\t\tif (isset($_REQUEST['spentityid'])) {\n\t\t\t/* IdP initiated authentication. */\n\n\t\t\tif (isset($_REQUEST['cookieTime'])) {\n\t\t\t\t$cookieTime = (int)$_REQUEST['cookieTime'];\n\t\t\t\tif ($cookieTime + 5 > time()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Less than five seconds has passed since we were\n\t\t\t\t\t * here the last time. Cookies are probably disabled.\n\t\t\t\t\t */\n\t\t\t\t\t\\SimpleSAML\\Utils\\HTTP::checkSessionCookie(\\SimpleSAML\\Utils\\HTTP::getSelfURL());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$spEntityId = (string)$_REQUEST['spentityid'];\n\t\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\t\tif (isset($_REQUEST['RelayState'])) {\n\t\t\t\t$relayState = (string)$_REQUEST['RelayState'];\n\t\t\t} else {\n\t\t\t\t$relayState = NULL;\n\t\t\t}\n\n\t\t\tif (isset($_REQUEST['binding'])){\n\t\t\t\t$protocolBinding = (string)$_REQUEST['binding'];\n\t\t\t} else {\n\t\t\t\t$protocolBinding = NULL;\n\t\t\t}\n\n\t\t\tif (isset($_REQUEST['NameIDFormat'])) {\n\t\t\t\t$nameIDFormat = (string)$_REQUEST['NameIDFormat'];\n\t\t\t} else {\n\t\t\t\t$nameIDFormat = NULL;\n\t\t\t}\n\n\t\t\t$requestId = NULL;\n\t\t\t$IDPList = array();\n\t\t\t$ProxyCount = NULL;\n\t\t\t$RequesterID = NULL;\n\t\t\t$forceAuthn = FALSE;\n\t\t\t$isPassive = FALSE;\n\t\t\t$consumerURL = NULL;\n\t\t\t$consumerIndex = NULL;\n\t\t\t$extensions = NULL;\n\t\t\t$allowCreate = TRUE;\n\n\t\t\t$idpInit = TRUE;\n\n\t\t\tSimpleSAML_Logger::info('SAML2.0 - IdP.SSOService: IdP initiated authentication: '. var_export($spEntityId, TRUE));\n\n\t\t} else {\n\n\t\t\t$binding = SAML2_Binding::getCurrentBinding();\n\t\t\t$request = $binding->receive();\n\n\t\t\tif (!($request instanceof SAML2_AuthnRequest)) {\n\t\t\t\tthrow new SimpleSAML_Error_BadRequest('Message received on authentication request endpoint wasn\\'t an authentication request.');\n\t\t\t}\n\n\t\t\t$spEntityId = $request->getIssuer();\n\t\t\tif ($spEntityId === NULL) {\n\t\t\t\tthrow new SimpleSAML_Error_BadRequest('Received message on authentication request endpoint without issuer.');\n\t\t\t}\n\t\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\t\tsspmod_saml_Message::validateMessage($spMetadata, $idpMetadata, $request);\n\n\t\t\t$relayState = $request->getRelayState();\n\n\t\t\t$requestId = $request->getId();\n\t\t\t$IDPList = $request->getIDPList();\n\t\t\t$ProxyCount = $request->getProxyCount();\n\t\t\tif ($ProxyCount !== null) $ProxyCount--;\n\t\t\t$RequesterID = $request->getRequesterID();\n\t\t\t$forceAuthn = $request->getForceAuthn();\n\t\t\t$isPassive = $request->getIsPassive();\n\t\t\t$consumerURL = $request->getAssertionConsumerServiceURL();\n\t\t\t$protocolBinding = $request->getProtocolBinding();\n\t\t\t$consumerIndex = $request->getAssertionConsumerServiceIndex();\n\t\t\t$extensions = $request->getExtensions();\n\n\t\t\t$nameIdPolicy = $request->getNameIdPolicy();\n\t\t\tif (isset($nameIdPolicy['Format'])) {\n\t\t\t\t$nameIDFormat = $nameIdPolicy['Format'];\n\t\t\t} else {\n\t\t\t\t$nameIDFormat = NULL;\n\t\t\t}\n\t\t\tif (isset($nameIdPolicy['AllowCreate'])) {\n\t\t\t\t$allowCreate = $nameIdPolicy['AllowCreate'];\n\t\t\t} else {\n\t\t\t\t$allowCreate = FALSE;\n\t\t\t}\n\n\t\t\t$idpInit = FALSE;\n\n\t\t\tSimpleSAML_Logger::info('SAML2.0 - IdP.SSOService: incoming authentication request: '. var_export($spEntityId, TRUE));\n\t\t}\n\n\t\tSimpleSAML_Stats::log('saml:idp:AuthnRequest', array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'forceAuthn' => $forceAuthn,\n\t\t\t'isPassive' => $isPassive,\n\t\t\t'protocol' => 'saml2',\n\t\t\t'idpInit' => $idpInit,\n\t\t));\n\n\t\t$acsEndpoint = self::getAssertionConsumerService($supportedBindings, $spMetadata, $consumerURL, $protocolBinding, $consumerIndex);\n\n\t\t$IDPList = array_unique(array_merge($IDPList, $spMetadata->getArrayizeString('IDPList', array())));\n\t\tif ($ProxyCount === null) $ProxyCount = $spMetadata->getInteger('ProxyCount', null);\n\n\t\tif (!$forceAuthn) {\n\t\t\t$forceAuthn = $spMetadata->getBoolean('ForceAuthn', FALSE);\n\t\t}\n\n\t\t$sessionLostParams = array(\n\t\t\t'spentityid' => $spEntityId,\n\t\t\t'cookieTime' => time(),\n\t\t);\n\t\tif ($relayState !== NULL) {\n\t\t\t$sessionLostParams['RelayState'] = $relayState;\n\t\t}\n\n\t\t$sessionLostURL = \\SimpleSAML\\Utils\\HTTP::addURLParameters(\n            \\SimpleSAML\\Utils\\HTTP::getSelfURLNoQuery(),\n\t\t\t$sessionLostParams);\n\n\t\t$state = array(\n\t\t\t'Responder' => array('sspmod_saml_IdP_SAML2', 'sendResponse'),\n\t\t\tSimpleSAML_Auth_State::EXCEPTION_HANDLER_FUNC => array('sspmod_saml_IdP_SAML2', 'handleAuthError'),\n\t\t\tSimpleSAML_Auth_State::RESTART => $sessionLostURL,\n\n\t\t\t'SPMetadata' => $spMetadata->toArray(),\n\t\t\t'saml:RelayState' => $relayState,\n\t\t\t'saml:RequestId' => $requestId,\n\t\t\t'saml:IDPList' => $IDPList,\n\t\t\t'saml:ProxyCount' => $ProxyCount,\n\t\t\t'saml:RequesterID' => $RequesterID,\n\t\t\t'ForceAuthn' => $forceAuthn,\n\t\t\t'isPassive' => $isPassive,\n\t\t\t'saml:ConsumerURL' => $acsEndpoint['Location'],\n\t\t\t'saml:Binding' => $acsEndpoint['Binding'],\n\t\t\t'saml:NameIDFormat' => $nameIDFormat,\n\t\t\t'saml:AllowCreate' => $allowCreate,\n\t\t\t'saml:Extensions' => $extensions,\n\t\t\t'saml:AuthnRequestReceivedAt' => microtime(TRUE),\n\t\t);\n\n\t\t$idp->handleAuthenticationRequest($state);\n\t}\n\n\n\t/**\n\t * Send a logout request to a given association.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are sending a logout request from.\n\t * @param array $association  The association that should be terminated.\n\t * @param string|NULL $relayState  An id that should be carried across the logout.\n\t */\n\tpublic static function sendLogoutRequest(SimpleSAML_IdP $idp, array $association, $relayState) {\n\t\tassert('is_string($relayState) || is_null($relayState)');\n\n\t\tSimpleSAML_Logger::info('Sending SAML 2.0 LogoutRequest to: '. var_export($association['saml:entityID'], TRUE));\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($association['saml:entityID'], 'saml20-sp-remote');\n\n\t\tSimpleSAML_Stats::log('saml:idp:LogoutRequest:sent', array(\n\t\t\t'spEntityID' => $association['saml:entityID'],\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t));\n\n\t\t$dst = $spMetadata->getEndpointPrioritizedByBinding('SingleLogoutService', array(\n\t\t\tSAML2_Const::BINDING_HTTP_REDIRECT,\n\t\t\tSAML2_Const::BINDING_HTTP_POST)\n\t\t);\n\t\t$binding = SAML2_Binding::getBinding($dst['Binding']);\n\t\t$lr = self::buildLogoutRequest($idpMetadata, $spMetadata, $association, $relayState);\n\t\t$lr->setDestination($dst['Location']);\n\n\t\t$binding->send($lr);\n\t}\n\n\n\t/**\n\t * Send a logout response.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are sending a logout request from.\n\t * @param array &$state  The logout state array.\n\t */\n\tpublic static function sendLogoutResponse(SimpleSAML_IdP $idp, array $state) {\n\t\tassert('isset($state[\"saml:SPEntityId\"])');\n\t\tassert('isset($state[\"saml:RequestId\"])');\n\t\tassert('array_key_exists(\"saml:RelayState\", $state)'); // Can be NULL.\n\n\t\t$spEntityId = $state['saml:SPEntityId'];\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\t$lr = sspmod_saml_Message::buildLogoutResponse($idpMetadata, $spMetadata);\n\t\t$lr->setInResponseTo($state['saml:RequestId']);\n\t\t$lr->setRelayState($state['saml:RelayState']);\n\n\t\tif (isset($state['core:Failed']) && $state['core:Failed']) {\n\t\t\t$partial = TRUE;\n\t\t\t$lr->setStatus(array(\n\t\t\t\t'Code' => SAML2_Const::STATUS_SUCCESS,\n\t\t\t\t'SubCode' => SAML2_Const::STATUS_PARTIAL_LOGOUT,\n\t\t\t));\n\t\t\tSimpleSAML_Logger::info('Sending logout response for partial logout to SP ' . var_export($spEntityId, TRUE));\n\t\t} else {\n\t\t\t$partial = FALSE;\n\t\t\tSimpleSAML_Logger::debug('Sending logout response to SP ' . var_export($spEntityId, TRUE));\n\t\t}\n\n\t\tSimpleSAML_Stats::log('saml:idp:LogoutResponse:sent', array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'partial' => $partial\n\t\t));\n\t\t$dst = $spMetadata->getEndpointPrioritizedByBinding('SingleLogoutService', array(\n\t\t\tSAML2_Const::BINDING_HTTP_REDIRECT,\n\t\t\tSAML2_Const::BINDING_HTTP_POST)\n\t\t);\n\t\t$binding = SAML2_Binding::getBinding($dst['Binding']);\n\t\tif (isset($dst['ResponseLocation'])) {\n\t\t\t$dst = $dst['ResponseLocation'];\n\t\t} else {\n\t\t\t$dst = $dst['Location'];\n\t\t}\n\t\t$lr->setDestination($dst);\n\n\t\t$binding->send($lr);\n\t}\n\n\n\t/**\n\t * Receive a logout message.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are receiving it for.\n\t */\n\tpublic static function receiveLogoutMessage(SimpleSAML_IdP $idp) {\n\n\t\t$binding = SAML2_Binding::getCurrentBinding();\n\t\t$message = $binding->receive();\n\n\t\t$spEntityId = $message->getIssuer();\n\t\tif ($spEntityId === NULL) {\n\t\t\t/* Without an issuer we have no way to respond to the message. */\n\t\t\tthrow new SimpleSAML_Error_BadRequest('Received message on logout endpoint without issuer.');\n\t\t}\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\tsspmod_saml_Message::validateMessage($spMetadata, $idpMetadata, $message);\n\n\t\tif ($message instanceof SAML2_LogoutResponse) {\n\n\t\t\tSimpleSAML_Logger::info('Received SAML 2.0 LogoutResponse from: '. var_export($spEntityId, TRUE));\n\t\t\t$statsData = array(\n\t\t\t\t'spEntityID' => $spEntityId,\n\t\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t);\n\t\t\tif (!$message->isSuccess()) {\n\t\t\t\t$statsData['error'] = $message->getStatus();\n\t\t\t}\n\t\t\tSimpleSAML_Stats::log('saml:idp:LogoutResponse:recv', $statsData);\n\n\t\t\t$relayState = $message->getRelayState();\n\n\t\t\tif (!$message->isSuccess()) {\n\t\t\t\t$logoutError = sspmod_saml_Message::getResponseError($message);\n\t\t\t\tSimpleSAML_Logger::warning('Unsuccessful logout. Status was: ' . $logoutError);\n\t\t\t} else {\n\t\t\t\t$logoutError = NULL;\n\t\t\t}\n\n\t\t\t$assocId = 'saml:' . $spEntityId;\n\n\t\t\t$idp->handleLogoutResponse($assocId, $relayState, $logoutError);\n\n\n\t\t} elseif ($message instanceof SAML2_LogoutRequest) {\n\n\t\t\tSimpleSAML_Logger::info('Received SAML 2.0 LogoutRequest from: '. var_export($spEntityId, TRUE));\n\t\t\tSimpleSAML_Stats::log('saml:idp:LogoutRequest:recv', array(\n\t\t\t\t'spEntityID' => $spEntityId,\n\t\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t));\n\n\t\t\t$spStatsId = $spMetadata->getString('core:statistics-id', $spEntityId);\n\t\t\tSimpleSAML_Logger::stats('saml20-idp-SLO spinit ' . $spStatsId . ' ' . $idpMetadata->getString('entityid'));\n\n\t\t\t$state = array(\n\t\t\t\t'Responder' => array('sspmod_saml_IdP_SAML2', 'sendLogoutResponse'),\n\t\t\t\t'saml:SPEntityId' => $spEntityId,\n\t\t\t\t'saml:RelayState' => $message->getRelayState(),\n\t\t\t\t'saml:RequestId' => $message->getId(),\n\t\t\t);\n\n\t\t\t$assocId = 'saml:' . $spEntityId;\n\t\t\t$idp->handleLogoutRequest($state, $assocId);\n\n\t\t} else {\n\t\t\tthrow new SimpleSAML_Error_BadRequest('Unknown message received on logout endpoint: ' . get_class($message));\n\t\t}\n\n\t}\n\n\n\t/**\n     * Retrieve a logout URL for a given logout association.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are sending a logout request from.\n\t * @param array $association  The association that should be terminated.\n\t * @param string|NULL $relayState  An id that should be carried across the logout.\n\t */\n\tpublic static function getLogoutURL(SimpleSAML_IdP $idp, array $association, $relayState) {\n\t\tassert('is_string($relayState) || is_null($relayState)');\n\n\t\tSimpleSAML_Logger::info('Sending SAML 2.0 LogoutRequest to: '. var_export($association['saml:entityID'], TRUE));\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($association['saml:entityID'], 'saml20-sp-remote');\n\n\t\t$bindings = array(SAML2_Const::BINDING_HTTP_REDIRECT,\n\t\t\t\t\t\t  SAML2_Const::BINDING_HTTP_POST);\n\t\t$dst = $spMetadata->getEndpointPrioritizedByBinding('SingleLogoutService', $bindings);\n\n\t\tif ($dst['Binding'] === SAML2_Const::BINDING_HTTP_POST) {\n\t\t\t$params = array('association' => $association['id'], 'idp' => $idp->getId());\n\t\t\tif ($relayState !== NULL) {\n\t\t\t\t$params['RelayState'] = $relayState;\n\t\t\t}\n\t\t\treturn SimpleSAML_Module::getModuleURL('core/idp/logout-iframe-post.php', $params);\n\t\t}\n\n\t\t$lr = self::buildLogoutRequest($idpMetadata, $spMetadata, $association, $relayState);\n\t\t$lr->setDestination($dst['Location']);\n\n\t\t$binding = new SAML2_HTTPRedirect();\n\t\treturn $binding->getRedirectURL($lr);\n\t}\n\n\n\t/**\n\t * Retrieve the metadata for the given SP association.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP the association belongs to.\n\t * @param array $association  The SP association.\n\t * @return SimpleSAML_Configuration  Configuration object for the SP metadata.\n\t */\n\tpublic static function getAssociationConfig(SimpleSAML_IdP $idp, array $association) {\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\ttry {\n\t\t\treturn $metadata->getMetaDataConfig($association['saml:entityID'], 'saml20-sp-remote');\n\t\t} catch (Exception $e) {\n\t\t\treturn SimpleSAML_Configuration::loadFromArray(array(), 'Unknown SAML 2 entity.');\n\t\t}\n\t}\n\n\n\t/**\n\t * Calculate the NameID value that should be used.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $dstMetadata  The metadata of the SP.\n\t * @param array &$state  The authentication state of the user.\n\t * @return string  The NameID value.\n\t */\n\tprivate static function generateNameIdValue(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array &$state) {\n\n\t\t$attribute = $spMetadata->getString('simplesaml.nameidattribute', NULL);\n\t\tif ($attribute === NULL) {\n\t\t\t$attribute = $idpMetadata->getString('simplesaml.nameidattribute', NULL);\n\t\t\tif ($attribute === NULL) {\n\t\t\t\tif (!isset($state['UserID'])) {\n\t\t\t\t\tSimpleSAML_Logger::error('Unable to generate NameID. Check the userid.attribute option.');\n\t\t\t\t}\n\t\t\t\t$attributeValue = $state['UserID'];\n\t\t\t\t$idpEntityId = $idpMetadata->getString('entityid');\n\t\t\t\t$spEntityId = $spMetadata->getString('entityid');\n\n\t\t\t\t$secretSalt = SimpleSAML\\Utils\\Config::getSecretSalt();\n\n\t\t\t\t$uidData = 'uidhashbase' . $secretSalt;\n\t\t\t\t$uidData .= strlen($idpEntityId) . ':' . $idpEntityId;\n\t\t\t\t$uidData .= strlen($spEntityId) . ':' . $spEntityId;\n\t\t\t\t$uidData .= strlen($attributeValue) . ':' . $attributeValue;\n\t\t\t\t$uidData .= $secretSalt;\n\n\t\t\t\treturn hash('sha1', $uidData);\n\t\t\t}\n\t\t}\n\n\t\t$attributes = $state['Attributes'];\n\t\tif (!array_key_exists($attribute, $attributes)) {\n\t\t\tSimpleSAML_Logger::error('Unable to add NameID: Missing ' . var_export($attribute, TRUE) .\n\t\t\t\t' in the attributes of the user.');\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn $attributes[$attribute][0];\n\t}\n\n\n\t/**\n\t * Helper function for encoding attributes.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param array $attributes  The attributes of the user\n\t * @return array  The encoded attributes.\n\t */\n\tprivate static function encodeAttributes(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array $attributes) {\n\n\t\t$base64Attributes = $spMetadata->getBoolean('base64attributes', NULL);\n\t\tif ($base64Attributes === NULL) {\n\t\t\t$base64Attributes = $idpMetadata->getBoolean('base64attributes', FALSE);\n\t\t}\n\n\t\tif ($base64Attributes) {\n\t\t\t$defaultEncoding = 'base64';\n\t\t} else {\n\t\t\t$defaultEncoding = 'string';\n\t\t}\n\n\t\t$srcEncodings = $idpMetadata->getArray('attributeencodings', array());\n\t\t$dstEncodings = $spMetadata->getArray('attributeencodings', array());\n\n\t\t/*\n\t\t * Merge the two encoding arrays. Encodings specified in the target metadata\n\t\t * takes precedence over the source metadata.\n\t\t */\n\t\t$encodings = array_merge($srcEncodings, $dstEncodings);\n\n\t\t$ret = array();\n\t\tforeach ($attributes as $name => $values) {\n\t\t\t$ret[$name] = array();\n\t\t\tif (array_key_exists($name, $encodings)) {\n\t\t\t\t$encoding = $encodings[$name];\n\t\t\t} else {\n\t\t\t\t$encoding = $defaultEncoding;\n\t\t\t}\n\n\t\t\tforeach ($values as $value) {\n                // allow null values\n                if ($value === null) {\n                    $ret[$name][] = $value;\n                    continue;\n                }\n\n\t\t\t\t$attrval = $value;\n\t\t\t\tif ($value instanceof DOMNodeList) {\n\t\t\t\t\t$attrval = new SAML2_XML_saml_AttributeValue($value->item(0)->parentNode);\n\t\t\t\t}\n\n\t\t\t\tswitch ($encoding) {\n\t\t\t\tcase 'string':\n\t\t\t\t\t$value = (string)$attrval;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'base64':\n\t\t\t\t\t$value = base64_encode((string)$attrval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'raw':\n\t\t\t\t\tif (is_string($value)) {\n\t\t\t\t\t\t$doc = SAML2_DOMDocumentFactory::fromString('<root>' . $value . '</root>');\n\t\t\t\t\t\t$value = $doc->firstChild->childNodes;\n\t\t\t\t\t}\n\t\t\t\t\tassert('$value instanceof DOMNodeList');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new SimpleSAML_Error_Exception('Invalid encoding for attribute ' .\n\t\t\t\t\t\tvar_export($name, TRUE) . ': ' . var_export($encoding, TRUE));\n\t\t\t\t}\n\t\t\t\t$ret[$name][] = $value;\n\t\t\t}\n\t\t}\n\n\t\treturn $ret;\n\t}\n\n\n\t/**\n\t * Determine which NameFormat we should use for attributes.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @return string  The NameFormat.\n\t */\n\tprivate static function getAttributeNameFormat(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata) {\n\n\t\t/* Try SP metadata first. */\n\t\t$attributeNameFormat = $spMetadata->getString('attributes.NameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\t\t$attributeNameFormat = $spMetadata->getString('AttributeNameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\n\t\t/* Look in IdP metadata. */\n\t\t$attributeNameFormat = $idpMetadata->getString('attributes.NameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\t\t$attributeNameFormat = $idpMetadata->getString('AttributeNameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\n\t\t/* Default. */\n\t\treturn 'urn:oasis:names:tc:SAML:2.0:attrname-format:basic';\n\t}\n\n\n\t/**\n\t * Build an assertion based on information in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param array &$state  The state array with information about the request.\n\t * @return SAML2_Assertion  The assertion.\n\t */\n\tprivate static function buildAssertion(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array &$state) {\n\t\tassert('isset($state[\"Attributes\"])');\n\t\tassert('isset($state[\"saml:ConsumerURL\"])');\n\n\t\t$now = time();\n\n\t\t$signAssertion = $spMetadata->getBoolean('saml20.sign.assertion', NULL);\n\t\tif ($signAssertion === NULL) {\n\t\t\t$signAssertion = $idpMetadata->getBoolean('saml20.sign.assertion', TRUE);\n\t\t}\n\n\t\t$config = SimpleSAML_Configuration::getInstance();\n\n\t\t$a = new SAML2_Assertion();\n\t\tif ($signAssertion) {\n\t\t\tsspmod_saml_Message::addSign($idpMetadata, $spMetadata, $a);\n\t\t}\n\n\t\t$a->setIssuer($idpMetadata->getString('entityid'));\n\t\t$a->setValidAudiences(array($spMetadata->getString('entityid')));\n\n\t\t$a->setNotBefore($now - 30);\n\n\t\t$assertionLifetime = $spMetadata->getInteger('assertion.lifetime', NULL);\n\t\tif ($assertionLifetime === NULL) {\n\t\t\t$assertionLifetime = $idpMetadata->getInteger('assertion.lifetime', 300);\n\t\t}\n\t\t$a->setNotOnOrAfter($now + $assertionLifetime);\n\n\t\tif (isset($state['saml:AuthnContextClassRef'])) {\n\t\t\t$a->setAuthnContext($state['saml:AuthnContextClassRef']);\n\t\t} else {\n\t\t\t$a->setAuthnContext(SAML2_Const::AC_PASSWORD);\n\t\t}\n\n\t\t$sessionStart = $now;\n\t\tif (isset($state['AuthnInstant'])) {\n\t\t\t$a->setAuthnInstant($state['AuthnInstant']);\n\t\t\t$sessionStart = $state['AuthnInstant'];\n\t\t}\n\n\t\t$sessionLifetime = $config->getInteger('session.duration', 8*60*60);\n\t\t$a->setSessionNotOnOrAfter($sessionStart + $sessionLifetime);\n\n\t\t$a->setSessionIndex(SimpleSAML\\Utils\\Random::generateID());\n\n\t\t$sc = new SAML2_XML_saml_SubjectConfirmation();\n\t\t$sc->SubjectConfirmationData = new SAML2_XML_saml_SubjectConfirmationData();\n\t\t$sc->SubjectConfirmationData->NotOnOrAfter = $now + $assertionLifetime;\n\t\t$sc->SubjectConfirmationData->Recipient = $state['saml:ConsumerURL'];\n\t\t$sc->SubjectConfirmationData->InResponseTo = $state['saml:RequestId'];\n\n\t\t/* ProtcolBinding of SP's <AuthnRequest> overwrites IdP hosted metadata configuration. */\n\t\t$hokAssertion = NULL;\n\t\tif ($state['saml:Binding'] === SAML2_Const::BINDING_HOK_SSO) {\n\t\t    $hokAssertion = TRUE;\n\t\t}\n\t\tif ($hokAssertion === NULL) {\n\t\t\t$hokAssertion = $idpMetadata->getBoolean('saml20.hok.assertion', FALSE);\n\t\t}\n\n\t\tif ($hokAssertion) {\n\t\t\t/* Holder-of-Key */\n\t\t\t$sc->Method = SAML2_Const::CM_HOK;\n\t\t\tif (\\SimpleSAML\\Utils\\HTTP::isHTTPS()) {\n\t\t\t\tif (isset($_SERVER['SSL_CLIENT_CERT']) && !empty($_SERVER['SSL_CLIENT_CERT'])) {\n\t\t\t\t\t/* Extract certificate data (if this is a certificate). */\n\t\t\t\t\t$clientCert = $_SERVER['SSL_CLIENT_CERT'];\n\t\t\t\t\t$pattern = '/^-----BEGIN CERTIFICATE-----([^-]*)^-----END CERTIFICATE-----/m';\n\t\t\t\t\tif (preg_match($pattern, $clientCert, $matches)) {\n\t\t\t\t\t\t/* We have a client certificate from the browser which we add to the HoK assertion. */\n\t\t\t\t\t\t$x509Certificate = new SAML2_XML_ds_X509Certificate();\n\t\t\t\t\t\t$x509Certificate->certificate = str_replace(array(\"\\r\", \"\\n\", \" \"), '', $matches[1]);\n\n\t\t\t\t\t\t$x509Data = new SAML2_XML_ds_X509Data();\n\t\t\t\t\t\t$x509Data->data[] = $x509Certificate;\n\n\t\t\t\t\t\t$keyInfo = new SAML2_XML_ds_KeyInfo();\n\t\t\t\t\t\t$keyInfo->info[] = $x509Data;\n\n\t\t\t\t\t\t$sc->SubjectConfirmationData->info[] = $keyInfo;\n\t\t\t\t\t} else throw new SimpleSAML_Error_Exception('Error creating HoK assertion: No valid client certificate provided during TLS handshake with IdP');\n\t\t\t\t} else throw new SimpleSAML_Error_Exception('Error creating HoK assertion: No client certificate provided during TLS handshake with IdP');\n\t\t\t} else throw new SimpleSAML_Error_Exception('Error creating HoK assertion: No HTTPS connection to IdP, but required for Holder-of-Key SSO');\n\t\t} else {\n\t\t\t/* Bearer */\n\t\t\t$sc->Method = SAML2_Const::CM_BEARER;\n\t\t}\n\t\t$a->setSubjectConfirmation(array($sc));\n\n\t\t/* Add attributes. */\n\n\t\tif ($spMetadata->getBoolean('simplesaml.attributes', TRUE)) {\n\t\t\t$attributeNameFormat = self::getAttributeNameFormat($idpMetadata, $spMetadata);\n\t\t\t$a->setAttributeNameFormat($attributeNameFormat);\n\t\t\t$attributes = self::encodeAttributes($idpMetadata, $spMetadata, $state['Attributes']);\n\t\t\t$a->setAttributes($attributes);\n\t\t}\n\n\n\t\t/* Generate the NameID for the assertion. */\n\n\t\tif (isset($state['saml:NameIDFormat'])) {\n\t\t\t$nameIdFormat = $state['saml:NameIDFormat'];\n\t\t} else {\n\t\t\t$nameIdFormat = NULL;\n\t\t}\n\n\t\tif ($nameIdFormat === NULL || !isset($state['saml:NameID'][$nameIdFormat])) {\n\t\t\t/* Either not set in request, or not set to a format we supply. Fall back to old generation method. */\n\t\t\t$nameIdFormat = $spMetadata->getString('NameIDFormat', NULL);\n\t\t\tif ($nameIdFormat === NULL) {\n\t\t\t\t$nameIdFormat = $idpMetadata->getString('NameIDFormat', SAML2_Const::NAMEID_TRANSIENT);\n\t\t\t}\n\t\t}\n\n\t\tif (isset($state['saml:NameID'][$nameIdFormat])) {\n\t\t\t$nameId = $state['saml:NameID'][$nameIdFormat];\n\t\t\t$nameId['Format'] = $nameIdFormat;\n\t\t} else {\n\t\t\t$spNameQualifier = $spMetadata->getString('SPNameQualifier', NULL);\n\t\t\tif ($spNameQualifier === NULL) {\n\t\t\t\t$spNameQualifier = $spMetadata->getString('entityid');\n\t\t\t}\n\n\t\t\tif ($nameIdFormat === SAML2_Const::NAMEID_TRANSIENT) {\n\t\t\t\t/* generate a random id */\n\t\t\t\t$nameIdValue = SimpleSAML\\Utils\\Random::generateID();\n\t\t\t} else {\n\t\t\t\t/* this code will end up generating either a fixed assigned id (via nameid.attribute)\n\t\t\t\t   or random id if not assigned/configured */\n\t\t\t\t$nameIdValue = self::generateNameIdValue($idpMetadata, $spMetadata, $state);\n\t\t\t\tif ($nameIdValue === NULL) {\n\t\t\t\t\tSimpleSAML_Logger::warning('Falling back to transient NameID.');\n\t\t\t\t\t$nameIdFormat = SAML2_Const::NAMEID_TRANSIENT;\n\t\t\t\t\t$nameIdValue = SimpleSAML\\Utils\\Random::generateID();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$nameId = array(\n\t\t\t\t'Format' => $nameIdFormat,\n\t\t\t\t'Value' => $nameIdValue,\n\t\t\t\t'SPNameQualifier' => $spNameQualifier,\n\t\t\t);\n\t\t}\n\n\t\t$state['saml:idp:NameID'] = $nameId;\n\n\t\t$a->setNameId($nameId);\n\n\t\t$encryptNameId = $spMetadata->getBoolean('nameid.encryption', NULL);\n\t\tif ($encryptNameId === NULL) {\n\t\t\t$encryptNameId = $idpMetadata->getBoolean('nameid.encryption', FALSE);\n\t\t}\n\t\tif ($encryptNameId) {\n\t\t\t$a->encryptNameId(sspmod_saml_Message::getEncryptionKey($spMetadata));\n\t\t}\n\n\t\treturn $a;\n\t}\n\n\n\t/**\n\t * Encrypt an assertion.\n\t *\n\t * This function takes in a SAML2_Assertion and encrypts it if encryption of\n\t * assertions are enabled in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param SAML2_Assertion $assertion  The assertion we are encrypting.\n\t * @return SAML2_Assertion|SAML2_EncryptedAssertion  The assertion.\n\t */\n\tprivate static function encryptAssertion(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, SAML2_Assertion $assertion) {\n\n\t\t$encryptAssertion = $spMetadata->getBoolean('assertion.encryption', NULL);\n\t\tif ($encryptAssertion === NULL) {\n\t\t\t$encryptAssertion = $idpMetadata->getBoolean('assertion.encryption', FALSE);\n\t\t}\n\t\tif (!$encryptAssertion) {\n\t\t\t/* We are _not_ encrypting this assertion, and are therefore done. */\n\t\t\treturn $assertion;\n\t\t}\n\n\n\t\t$sharedKey = $spMetadata->getString('sharedkey', NULL);\n\t\tif ($sharedKey !== NULL) {\n\t\t\t$key = new XMLSecurityKey(XMLSecurityKey::AES128_CBC);\n\t\t\t$key->loadKey($sharedKey);\n\t\t} else {\n\t\t\t$keys = $spMetadata->getPublicKeys('encryption', TRUE);\n\t\t\t$key = $keys[0];\n\t\t\tswitch ($key['type']) {\n\t\t\tcase 'X509Certificate':\n\t\t\t\t$pemKey = \"-----BEGIN CERTIFICATE-----\\n\" .\n\t\t\t\t\tchunk_split($key['X509Certificate'], 64) .\n\t\t\t\t\t\"-----END CERTIFICATE-----\\n\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new SimpleSAML_Error_Exception('Unsupported encryption key type: ' . $key['type']);\n\t\t\t}\n\n\t\t\t/* Extract the public key from the certificate for encryption. */\n\t\t\t$key = new XMLSecurityKey(XMLSecurityKey::RSA_OAEP_MGF1P, array('type'=>'public'));\n\t\t\t$key->loadKey($pemKey);\n\t\t}\n\n\t\t$ea = new SAML2_EncryptedAssertion();\n\t\t$ea->setAssertion($assertion, $key);\n\t\treturn $ea;\n\t}\n\n\n\t/**\n\t * Build a logout request based on information in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration spMetadata  The metadata of the SP.\n\t * @param array $association  The SP association.\n\t * @param string|NULL $relayState  An id that should be carried across the logout.\n\t */\n\tprivate static function buildLogoutRequest(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array $association, $relayState) {\n\n\t\t$lr = sspmod_saml_Message::buildLogoutRequest($idpMetadata, $spMetadata);\n\t\t$lr->setRelayState($relayState);\n\t\t$lr->setSessionIndex($association['saml:SessionIndex']);\n\t\t$lr->setNameId($association['saml:NameID']);\n\n\t\t$assertionLifetime = $spMetadata->getInteger('assertion.lifetime', NULL);\n\t\tif ($assertionLifetime === NULL) {\n\t\t\t$assertionLifetime = $idpMetadata->getInteger('assertion.lifetime', 300);\n\t\t}\n\t\t$lr->setNotOnOrAfter(time() + $assertionLifetime);\n\n\t\t$encryptNameId = $spMetadata->getBoolean('nameid.encryption', NULL);\n\t\tif ($encryptNameId === NULL) {\n\t\t\t$encryptNameId = $idpMetadata->getBoolean('nameid.encryption', FALSE);\n\t\t}\n\t\tif ($encryptNameId) {\n\t\t\t$lr->encryptNameId(sspmod_saml_Message::getEncryptionKey($spMetadata));\n\t\t}\n\n\t\treturn $lr;\n\t}\n\n\n\t/**\n\t * Build a authentication response based on information in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param string $consumerURL  The Destination URL of the response.\n\t */\n\tprivate static function buildResponse(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, $consumerURL) {\n\n\t\t$signResponse = $spMetadata->getBoolean('saml20.sign.response', NULL);\n\t\tif ($signResponse === NULL) {\n\t\t\t$signResponse = $idpMetadata->getBoolean('saml20.sign.response', TRUE);\n\t\t}\n\n\t\t$r = new SAML2_Response();\n\n\t\t$r->setIssuer($idpMetadata->getString('entityid'));\n\t\t$r->setDestination($consumerURL);\n\n\t\tif ($signResponse) {\n\t\t\tsspmod_saml_Message::addSign($idpMetadata, $spMetadata, $r);\n\t\t}\n\n\t\treturn $r;\n\t}\n\n}"], "fixing_code": ["<?php\n\n/**\n * IdP implementation for SAML 2.0 protocol.\n *\n * @package SimpleSAMLphp\n */\nclass sspmod_saml_IdP_SAML2 {\n\n\t/**\n\t * Send a response to the SP.\n\t *\n\t * @param array $state  The authentication state.\n\t */\n\tpublic static function sendResponse(array $state) {\n\t\tassert('isset($state[\"Attributes\"])');\n\t\tassert('isset($state[\"SPMetadata\"])');\n\t\tassert('isset($state[\"saml:ConsumerURL\"])');\n\t\tassert('array_key_exists(\"saml:RequestId\", $state)'); // Can be NULL\n\t\tassert('array_key_exists(\"saml:RelayState\", $state)'); // Can be NULL.\n\n\t\t$spMetadata = $state[\"SPMetadata\"];\n\t\t$spEntityId = $spMetadata['entityid'];\n\t\t$spMetadata = SimpleSAML_Configuration::loadFromArray($spMetadata,\n\t\t\t'$metadata[' . var_export($spEntityId, TRUE) . ']');\n\n\t\tSimpleSAML_Logger::info('Sending SAML 2.0 Response to ' . var_export($spEntityId, TRUE));\n\n\t\t$requestId = $state['saml:RequestId'];\n\t\t$relayState = $state['saml:RelayState'];\n\t\t$consumerURL = $state['saml:ConsumerURL'];\n\t\t$protocolBinding = $state['saml:Binding'];\n\n\t\t$idp = SimpleSAML_IdP::getByState($state);\n\n\t\t$idpMetadata = $idp->getConfig();\n\n\t\t$assertion = self::buildAssertion($idpMetadata, $spMetadata, $state);\n\t\t\n\t\tif (isset($state['saml:AuthenticatingAuthority'])) {\n\t\t\t$assertion->setAuthenticatingAuthority($state['saml:AuthenticatingAuthority']);\n\t\t}\n\n\t\t// Create the session association (for logout).\n\t\t$association = array(\n\t\t\t'id' => 'saml:' . $spEntityId,\n\t\t\t'Handler' => 'sspmod_saml_IdP_SAML2',\n\t\t\t'Expires' => $assertion->getSessionNotOnOrAfter(),\n\t\t\t'saml:entityID' => $spEntityId,\n\t\t\t'saml:NameID' => $state['saml:idp:NameID'],\n\t\t\t'saml:SessionIndex' => $assertion->getSessionIndex(),\n\t\t);\n\n\t\t// Maybe encrypt the assertion.\n\t\t$assertion = self::encryptAssertion($idpMetadata, $spMetadata, $assertion);\n\n\t\t/* Create the response. */\n\t\t$ar = self::buildResponse($idpMetadata, $spMetadata, $consumerURL);\n\t\t$ar->setInResponseTo($requestId);\n\t\t$ar->setRelayState($relayState);\n\t\t$ar->setAssertions(array($assertion));\n\n\t\t/* Register the session association with the IdP. */\n\t\t$idp->addAssociation($association);\n\n\t\t$statsData = array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'protocol' => 'saml2',\n\t\t);\n\t\tif (isset($state['saml:AuthnRequestReceivedAt'])) {\n\t\t\t$statsData['logintime'] = microtime(TRUE) - $state['saml:AuthnRequestReceivedAt'];\n\t\t}\n\t\tSimpleSAML_Stats::log('saml:idp:Response', $statsData);\n\n\t\t/* Send the response. */\n\t\t$binding = SAML2_Binding::getBinding($protocolBinding);\n\t\t$binding->send($ar);\n\t}\n\n\n\t/**\n\t * Handle authentication error.\n\t *\n\t * SimpleSAML_Error_Exception $exception  The exception.\n\t * @param array $state  The error state.\n\t */\n\tpublic static function handleAuthError(SimpleSAML_Error_Exception $exception, array $state) {\n\t\tassert('isset($state[\"SPMetadata\"])');\n\t\tassert('isset($state[\"saml:ConsumerURL\"])');\n\t\tassert('array_key_exists(\"saml:RequestId\", $state)'); // Can be NULL.\n\t\tassert('array_key_exists(\"saml:RelayState\", $state)'); // Can be NULL.\n\n\t\t$spMetadata = $state[\"SPMetadata\"];\n\t\t$spEntityId = $spMetadata['entityid'];\n\t\t$spMetadata = SimpleSAML_Configuration::loadFromArray($spMetadata,\n\t\t\t'$metadata[' . var_export($spEntityId, TRUE) . ']');\n\n\t\t$requestId = $state['saml:RequestId'];\n\t\t$relayState = $state['saml:RelayState'];\n\t\t$consumerURL = $state['saml:ConsumerURL'];\n\t\t$protocolBinding = $state['saml:Binding'];\n\n\t\t$idp = SimpleSAML_IdP::getByState($state);\n\n\t\t$idpMetadata = $idp->getConfig();\n\n\t\t$error = sspmod_saml_Error::fromException($exception);\n\n\t\tSimpleSAML_Logger::warning('Returning error to sp: ' . var_export($spEntityId, TRUE));\n\t\t$error->logWarning();\n\n\t\t$ar = self::buildResponse($idpMetadata, $spMetadata, $consumerURL);\n\t\t$ar->setInResponseTo($requestId);\n\t\t$ar->setRelayState($relayState);\n\n\t\t$status = array(\n\t\t\t'Code' => $error->getStatus(),\n\t\t\t'SubCode' => $error->getSubStatus(),\n\t\t\t'Message' => $error->getStatusMessage(),\n\t\t);\n\t\t$ar->setStatus($status);\n\n\t\t$statsData = array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'protocol' => 'saml2',\n\t\t\t'error' => $status,\n\t\t);\n\t\tif (isset($state['saml:AuthnRequestReceivedAt'])) {\n\t\t\t$statsData['logintime'] = microtime(TRUE) - $state['saml:AuthnRequestReceivedAt'];\n\t\t}\n\t\tSimpleSAML_Stats::log('saml:idp:Response:error', $statsData);\n\n\t\t$binding = SAML2_Binding::getBinding($protocolBinding);\n\t\t$binding->send($ar);\n\t}\n\n\n\t/**\n\t * Find SP AssertionConsumerService based on parameter in AuthnRequest.\n\t *\n\t * @param array $supportedBindings  The bindings we allow for the response.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata for the SP.\n\t * @param string|NULL $AssertionConsumerServiceURL  AssertionConsumerServiceURL from request.\n\t * @param string|NULL $ProtocolBinding  ProtocolBinding from request.\n\t * @param int|NULL $AssertionConsumerServiceIndex  AssertionConsumerServiceIndex from request.\n\t * @return array  Array with the Location and Binding we should use for the response.\n\t */\n\tprivate static function getAssertionConsumerService(array $supportedBindings, SimpleSAML_Configuration $spMetadata,\n\t\t$AssertionConsumerServiceURL, $ProtocolBinding, $AssertionConsumerServiceIndex) {\n\t\tassert('is_string($AssertionConsumerServiceURL) || is_null($AssertionConsumerServiceURL)');\n\t\tassert('is_string($ProtocolBinding) || is_null($ProtocolBinding)');\n\t\tassert('is_int($AssertionConsumerServiceIndex) || is_null($AssertionConsumerServiceIndex)');\n\n\t\t/* We want to pick the best matching endpoint in the case where for example\n\t\t * only the ProtocolBinding is given. We therefore pick endpoints with the\n\t\t * following priority:\n\t\t *  1. isDefault=\"true\"\n\t\t *  2. isDefault unset\n\t\t *  3. isDefault=\"false\"\n\t\t */\n\t\t$firstNotFalse = NULL;\n\t\t$firstFalse = NULL;\n\t\tforeach ($spMetadata->getEndpoints('AssertionConsumerService') as $ep) {\n\n\t\t\tif ($AssertionConsumerServiceURL !== NULL && $ep['Location'] !== $AssertionConsumerServiceURL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($ProtocolBinding !== NULL && $ep['Binding'] !== $ProtocolBinding) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($AssertionConsumerServiceIndex !== NULL && $ep['index'] !== $AssertionConsumerServiceIndex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!in_array($ep['Binding'], $supportedBindings, TRUE)) {\n\t\t\t\t/* The endpoint has an unsupported binding. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* We have an endpoint that matches all our requirements. Check if it is the best one. */\n\n\t\t\tif (array_key_exists('isDefault', $ep)) {\n\t\t\t\tif ($ep['isDefault'] === TRUE) {\n\t\t\t\t\t/* This is the first matching endpoint with isDefault set to TRUE. */\n\t\t\t\t\treturn $ep;\n\t\t\t\t}\n\t\t\t\t/* isDefault is set to FALSE, but the endpoint is still useable. */\n\t\t\t\tif ($firstFalse === NULL) {\n\t\t\t\t\t/* This is the first endpoint that we can use. */\n\t\t\t\t\t$firstFalse = $ep;\n\t\t\t\t}\n\t\t\t} else if ($firstNotFalse === NULL) {\n\t\t\t\t/* This is the first endpoint without isDefault set. */\n\t\t\t\t$firstNotFalse = $ep;\n\t\t\t}\n\t\t}\n\n\t\tif ($firstNotFalse !== NULL) {\n\t\t\treturn $firstNotFalse;\n\t\t} elseif ($firstFalse !== NULL) {\n\t\t\treturn $firstFalse;\n\t\t}\n\n\t\tSimpleSAML_Logger::warning('Authentication request specifies invalid AssertionConsumerService:');\n\t\tif ($AssertionConsumerServiceURL !== NULL) {\n\t\t\tSimpleSAML_Logger::warning('AssertionConsumerServiceURL: ' . var_export($AssertionConsumerServiceURL, TRUE));\n\t\t}\n\t\tif ($ProtocolBinding !== NULL) {\n\t\t\tSimpleSAML_Logger::warning('ProtocolBinding: ' . var_export($ProtocolBinding, TRUE));\n\t\t}\n\t\tif ($AssertionConsumerServiceIndex !== NULL) {\n\t\t\tSimpleSAML_Logger::warning('AssertionConsumerServiceIndex: ' . var_export($AssertionConsumerServiceIndex, TRUE));\n\t\t}\n\n\t\t/* We have no good endpoints. Our last resort is to just use the default endpoint. */\n\t\treturn $spMetadata->getDefaultEndpoint('AssertionConsumerService', $supportedBindings);\n\t}\n\n\n\t/**\n\t * Receive an authentication request.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are receiving it for.\n\t */\n\tpublic static function receiveAuthnRequest(SimpleSAML_IdP $idp) {\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\n\t\t$supportedBindings = array(SAML2_Const::BINDING_HTTP_POST);\n\t\tif ($idpMetadata->getBoolean('saml20.sendartifact', FALSE)) {\n\t\t\t$supportedBindings[] = SAML2_Const::BINDING_HTTP_ARTIFACT;\n\t\t}\n\t\tif ($idpMetadata->getBoolean('saml20.hok.assertion', FALSE)) {\n\t\t\t$supportedBindings[] = SAML2_Const::BINDING_HOK_SSO;\n\t\t}\n\n\t\tif (isset($_REQUEST['spentityid'])) {\n\t\t\t/* IdP initiated authentication. */\n\n\t\t\tif (isset($_REQUEST['cookieTime'])) {\n\t\t\t\t$cookieTime = (int)$_REQUEST['cookieTime'];\n\t\t\t\tif ($cookieTime + 5 > time()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Less than five seconds has passed since we were\n\t\t\t\t\t * here the last time. Cookies are probably disabled.\n\t\t\t\t\t */\n\t\t\t\t\t\\SimpleSAML\\Utils\\HTTP::checkSessionCookie(\\SimpleSAML\\Utils\\HTTP::getSelfURL());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$spEntityId = (string)$_REQUEST['spentityid'];\n\t\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\t\tif (isset($_REQUEST['RelayState'])) {\n\t\t\t\t$relayState = (string)$_REQUEST['RelayState'];\n\t\t\t} else {\n\t\t\t\t$relayState = NULL;\n\t\t\t}\n\n\t\t\tif (isset($_REQUEST['binding'])){\n\t\t\t\t$protocolBinding = (string)$_REQUEST['binding'];\n\t\t\t} else {\n\t\t\t\t$protocolBinding = NULL;\n\t\t\t}\n\n\t\t\tif (isset($_REQUEST['NameIDFormat'])) {\n\t\t\t\t$nameIDFormat = (string)$_REQUEST['NameIDFormat'];\n\t\t\t} else {\n\t\t\t\t$nameIDFormat = NULL;\n\t\t\t}\n\n\t\t\t$requestId = NULL;\n\t\t\t$IDPList = array();\n\t\t\t$ProxyCount = NULL;\n\t\t\t$RequesterID = NULL;\n\t\t\t$forceAuthn = FALSE;\n\t\t\t$isPassive = FALSE;\n\t\t\t$consumerURL = NULL;\n\t\t\t$consumerIndex = NULL;\n\t\t\t$extensions = NULL;\n\t\t\t$allowCreate = TRUE;\n\n\t\t\t$idpInit = TRUE;\n\n\t\t\tSimpleSAML_Logger::info('SAML2.0 - IdP.SSOService: IdP initiated authentication: '. var_export($spEntityId, TRUE));\n\n\t\t} else {\n\n\t\t\t$binding = SAML2_Binding::getCurrentBinding();\n\t\t\t$request = $binding->receive();\n\n\t\t\tif (!($request instanceof SAML2_AuthnRequest)) {\n\t\t\t\tthrow new SimpleSAML_Error_BadRequest('Message received on authentication request endpoint wasn\\'t an authentication request.');\n\t\t\t}\n\n\t\t\t$spEntityId = $request->getIssuer();\n\t\t\tif ($spEntityId === NULL) {\n\t\t\t\tthrow new SimpleSAML_Error_BadRequest('Received message on authentication request endpoint without issuer.');\n\t\t\t}\n\t\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\t\tsspmod_saml_Message::validateMessage($spMetadata, $idpMetadata, $request);\n\n\t\t\t$relayState = $request->getRelayState();\n\n\t\t\t$requestId = $request->getId();\n\t\t\t$IDPList = $request->getIDPList();\n\t\t\t$ProxyCount = $request->getProxyCount();\n\t\t\tif ($ProxyCount !== null) $ProxyCount--;\n\t\t\t$RequesterID = $request->getRequesterID();\n\t\t\t$forceAuthn = $request->getForceAuthn();\n\t\t\t$isPassive = $request->getIsPassive();\n\t\t\t$consumerURL = $request->getAssertionConsumerServiceURL();\n\t\t\t$protocolBinding = $request->getProtocolBinding();\n\t\t\t$consumerIndex = $request->getAssertionConsumerServiceIndex();\n\t\t\t$extensions = $request->getExtensions();\n\n\t\t\t$nameIdPolicy = $request->getNameIdPolicy();\n\t\t\tif (isset($nameIdPolicy['Format'])) {\n\t\t\t\t$nameIDFormat = $nameIdPolicy['Format'];\n\t\t\t} else {\n\t\t\t\t$nameIDFormat = NULL;\n\t\t\t}\n\t\t\tif (isset($nameIdPolicy['AllowCreate'])) {\n\t\t\t\t$allowCreate = $nameIdPolicy['AllowCreate'];\n\t\t\t} else {\n\t\t\t\t$allowCreate = FALSE;\n\t\t\t}\n\n\t\t\t$idpInit = FALSE;\n\n\t\t\tSimpleSAML_Logger::info('SAML2.0 - IdP.SSOService: incoming authentication request: '. var_export($spEntityId, TRUE));\n\t\t}\n\n\t\tSimpleSAML_Stats::log('saml:idp:AuthnRequest', array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'forceAuthn' => $forceAuthn,\n\t\t\t'isPassive' => $isPassive,\n\t\t\t'protocol' => 'saml2',\n\t\t\t'idpInit' => $idpInit,\n\t\t));\n\n\t\t$acsEndpoint = self::getAssertionConsumerService($supportedBindings, $spMetadata, $consumerURL, $protocolBinding, $consumerIndex);\n\n\t\t$IDPList = array_unique(array_merge($IDPList, $spMetadata->getArrayizeString('IDPList', array())));\n\t\tif ($ProxyCount === null) $ProxyCount = $spMetadata->getInteger('ProxyCount', null);\n\n\t\tif (!$forceAuthn) {\n\t\t\t$forceAuthn = $spMetadata->getBoolean('ForceAuthn', FALSE);\n\t\t}\n\n\t\t$sessionLostParams = array(\n\t\t\t'spentityid' => $spEntityId,\n\t\t\t'cookieTime' => time(),\n\t\t);\n\t\tif ($relayState !== NULL) {\n\t\t\t$sessionLostParams['RelayState'] = $relayState;\n\t\t}\n\n\t\t$sessionLostURL = \\SimpleSAML\\Utils\\HTTP::addURLParameters(\n            \\SimpleSAML\\Utils\\HTTP::getSelfURLNoQuery(),\n\t\t\t$sessionLostParams);\n\n\t\t$state = array(\n\t\t\t'Responder' => array('sspmod_saml_IdP_SAML2', 'sendResponse'),\n\t\t\tSimpleSAML_Auth_State::EXCEPTION_HANDLER_FUNC => array('sspmod_saml_IdP_SAML2', 'handleAuthError'),\n\t\t\tSimpleSAML_Auth_State::RESTART => $sessionLostURL,\n\n\t\t\t'SPMetadata' => $spMetadata->toArray(),\n\t\t\t'saml:RelayState' => $relayState,\n\t\t\t'saml:RequestId' => $requestId,\n\t\t\t'saml:IDPList' => $IDPList,\n\t\t\t'saml:ProxyCount' => $ProxyCount,\n\t\t\t'saml:RequesterID' => $RequesterID,\n\t\t\t'ForceAuthn' => $forceAuthn,\n\t\t\t'isPassive' => $isPassive,\n\t\t\t'saml:ConsumerURL' => $acsEndpoint['Location'],\n\t\t\t'saml:Binding' => $acsEndpoint['Binding'],\n\t\t\t'saml:NameIDFormat' => $nameIDFormat,\n\t\t\t'saml:AllowCreate' => $allowCreate,\n\t\t\t'saml:Extensions' => $extensions,\n\t\t\t'saml:AuthnRequestReceivedAt' => microtime(TRUE),\n\t\t);\n\n\t\t$idp->handleAuthenticationRequest($state);\n\t}\n\n\n\t/**\n\t * Send a logout request to a given association.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are sending a logout request from.\n\t * @param array $association  The association that should be terminated.\n\t * @param string|NULL $relayState  An id that should be carried across the logout.\n\t */\n\tpublic static function sendLogoutRequest(SimpleSAML_IdP $idp, array $association, $relayState) {\n\t\tassert('is_string($relayState) || is_null($relayState)');\n\n\t\tSimpleSAML_Logger::info('Sending SAML 2.0 LogoutRequest to: '. var_export($association['saml:entityID'], TRUE));\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($association['saml:entityID'], 'saml20-sp-remote');\n\n\t\tSimpleSAML_Stats::log('saml:idp:LogoutRequest:sent', array(\n\t\t\t'spEntityID' => $association['saml:entityID'],\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t));\n\n\t\t$dst = $spMetadata->getEndpointPrioritizedByBinding('SingleLogoutService', array(\n\t\t\tSAML2_Const::BINDING_HTTP_REDIRECT,\n\t\t\tSAML2_Const::BINDING_HTTP_POST)\n\t\t);\n\t\t$binding = SAML2_Binding::getBinding($dst['Binding']);\n\t\t$lr = self::buildLogoutRequest($idpMetadata, $spMetadata, $association, $relayState);\n\t\t$lr->setDestination($dst['Location']);\n\n\t\t$binding->send($lr);\n\t}\n\n\n\t/**\n\t * Send a logout response.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are sending a logout request from.\n\t * @param array &$state  The logout state array.\n\t */\n\tpublic static function sendLogoutResponse(SimpleSAML_IdP $idp, array $state) {\n\t\tassert('isset($state[\"saml:SPEntityId\"])');\n\t\tassert('isset($state[\"saml:RequestId\"])');\n\t\tassert('array_key_exists(\"saml:RelayState\", $state)'); // Can be NULL.\n\n\t\t$spEntityId = $state['saml:SPEntityId'];\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\t$lr = sspmod_saml_Message::buildLogoutResponse($idpMetadata, $spMetadata);\n\t\t$lr->setInResponseTo($state['saml:RequestId']);\n\t\t$lr->setRelayState($state['saml:RelayState']);\n\n\t\tif (isset($state['core:Failed']) && $state['core:Failed']) {\n\t\t\t$partial = TRUE;\n\t\t\t$lr->setStatus(array(\n\t\t\t\t'Code' => SAML2_Const::STATUS_SUCCESS,\n\t\t\t\t'SubCode' => SAML2_Const::STATUS_PARTIAL_LOGOUT,\n\t\t\t));\n\t\t\tSimpleSAML_Logger::info('Sending logout response for partial logout to SP ' . var_export($spEntityId, TRUE));\n\t\t} else {\n\t\t\t$partial = FALSE;\n\t\t\tSimpleSAML_Logger::debug('Sending logout response to SP ' . var_export($spEntityId, TRUE));\n\t\t}\n\n\t\tSimpleSAML_Stats::log('saml:idp:LogoutResponse:sent', array(\n\t\t\t'spEntityID' => $spEntityId,\n\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t'partial' => $partial\n\t\t));\n\t\t$dst = $spMetadata->getEndpointPrioritizedByBinding('SingleLogoutService', array(\n\t\t\tSAML2_Const::BINDING_HTTP_REDIRECT,\n\t\t\tSAML2_Const::BINDING_HTTP_POST)\n\t\t);\n\t\t$binding = SAML2_Binding::getBinding($dst['Binding']);\n\t\tif (isset($dst['ResponseLocation'])) {\n\t\t\t$dst = $dst['ResponseLocation'];\n\t\t} else {\n\t\t\t$dst = $dst['Location'];\n\t\t}\n\t\t$lr->setDestination($dst);\n\n\t\t$binding->send($lr);\n\t}\n\n\n\t/**\n\t * Receive a logout message.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are receiving it for.\n\t */\n\tpublic static function receiveLogoutMessage(SimpleSAML_IdP $idp) {\n\n\t\t$binding = SAML2_Binding::getCurrentBinding();\n\t\t$message = $binding->receive();\n\n\t\t$spEntityId = $message->getIssuer();\n\t\tif ($spEntityId === NULL) {\n\t\t\t/* Without an issuer we have no way to respond to the message. */\n\t\t\tthrow new SimpleSAML_Error_BadRequest('Received message on logout endpoint without issuer.');\n\t\t}\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($spEntityId, 'saml20-sp-remote');\n\n\t\tsspmod_saml_Message::validateMessage($spMetadata, $idpMetadata, $message);\n\n\t\tif ($message instanceof SAML2_LogoutResponse) {\n\n\t\t\tSimpleSAML_Logger::info('Received SAML 2.0 LogoutResponse from: '. var_export($spEntityId, TRUE));\n\t\t\t$statsData = array(\n\t\t\t\t'spEntityID' => $spEntityId,\n\t\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t);\n\t\t\tif (!$message->isSuccess()) {\n\t\t\t\t$statsData['error'] = $message->getStatus();\n\t\t\t}\n\t\t\tSimpleSAML_Stats::log('saml:idp:LogoutResponse:recv', $statsData);\n\n\t\t\t$relayState = $message->getRelayState();\n\n\t\t\tif (!$message->isSuccess()) {\n\t\t\t\t$logoutError = sspmod_saml_Message::getResponseError($message);\n\t\t\t\tSimpleSAML_Logger::warning('Unsuccessful logout. Status was: ' . $logoutError);\n\t\t\t} else {\n\t\t\t\t$logoutError = NULL;\n\t\t\t}\n\n\t\t\t$assocId = 'saml:' . $spEntityId;\n\n\t\t\t$idp->handleLogoutResponse($assocId, $relayState, $logoutError);\n\n\n\t\t} elseif ($message instanceof SAML2_LogoutRequest) {\n\n\t\t\tSimpleSAML_Logger::info('Received SAML 2.0 LogoutRequest from: '. var_export($spEntityId, TRUE));\n\t\t\tSimpleSAML_Stats::log('saml:idp:LogoutRequest:recv', array(\n\t\t\t\t'spEntityID' => $spEntityId,\n\t\t\t\t'idpEntityID' => $idpMetadata->getString('entityid'),\n\t\t\t));\n\n\t\t\t$spStatsId = $spMetadata->getString('core:statistics-id', $spEntityId);\n\t\t\tSimpleSAML_Logger::stats('saml20-idp-SLO spinit ' . $spStatsId . ' ' . $idpMetadata->getString('entityid'));\n\n\t\t\t$state = array(\n\t\t\t\t'Responder' => array('sspmod_saml_IdP_SAML2', 'sendLogoutResponse'),\n\t\t\t\t'saml:SPEntityId' => $spEntityId,\n\t\t\t\t'saml:RelayState' => $message->getRelayState(),\n\t\t\t\t'saml:RequestId' => $message->getId(),\n\t\t\t);\n\n\t\t\t$assocId = 'saml:' . $spEntityId;\n\t\t\t$idp->handleLogoutRequest($state, $assocId);\n\n\t\t} else {\n\t\t\tthrow new SimpleSAML_Error_BadRequest('Unknown message received on logout endpoint: ' . get_class($message));\n\t\t}\n\n\t}\n\n\n\t/**\n     * Retrieve a logout URL for a given logout association.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP we are sending a logout request from.\n\t * @param array $association  The association that should be terminated.\n\t * @param string|NULL $relayState  An id that should be carried across the logout.\n\t */\n\tpublic static function getLogoutURL(SimpleSAML_IdP $idp, array $association, $relayState) {\n\t\tassert('is_string($relayState) || is_null($relayState)');\n\n\t\tSimpleSAML_Logger::info('Sending SAML 2.0 LogoutRequest to: '. var_export($association['saml:entityID'], TRUE));\n\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\t$idpMetadata = $idp->getConfig();\n\t\t$spMetadata = $metadata->getMetaDataConfig($association['saml:entityID'], 'saml20-sp-remote');\n\n\t\t$bindings = array(SAML2_Const::BINDING_HTTP_REDIRECT,\n\t\t\t\t\t\t  SAML2_Const::BINDING_HTTP_POST);\n\t\t$dst = $spMetadata->getEndpointPrioritizedByBinding('SingleLogoutService', $bindings);\n\n\t\tif ($dst['Binding'] === SAML2_Const::BINDING_HTTP_POST) {\n\t\t\t$params = array('association' => $association['id'], 'idp' => $idp->getId());\n\t\t\tif ($relayState !== NULL) {\n\t\t\t\t$params['RelayState'] = $relayState;\n\t\t\t}\n\t\t\treturn SimpleSAML_Module::getModuleURL('core/idp/logout-iframe-post.php', $params);\n\t\t}\n\n\t\t$lr = self::buildLogoutRequest($idpMetadata, $spMetadata, $association, $relayState);\n\t\t$lr->setDestination($dst['Location']);\n\n\t\t$binding = new SAML2_HTTPRedirect();\n\t\treturn $binding->getRedirectURL($lr);\n\t}\n\n\n\t/**\n\t * Retrieve the metadata for the given SP association.\n\t *\n\t * @param SimpleSAML_IdP $idp  The IdP the association belongs to.\n\t * @param array $association  The SP association.\n\t * @return SimpleSAML_Configuration  Configuration object for the SP metadata.\n\t */\n\tpublic static function getAssociationConfig(SimpleSAML_IdP $idp, array $association) {\n\t\t$metadata = SimpleSAML_Metadata_MetaDataStorageHandler::getMetadataHandler();\n\t\ttry {\n\t\t\treturn $metadata->getMetaDataConfig($association['saml:entityID'], 'saml20-sp-remote');\n\t\t} catch (Exception $e) {\n\t\t\treturn SimpleSAML_Configuration::loadFromArray(array(), 'Unknown SAML 2 entity.');\n\t\t}\n\t}\n\n\n\t/**\n\t * Calculate the NameID value that should be used.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $dstMetadata  The metadata of the SP.\n\t * @param array &$state  The authentication state of the user.\n\t * @return string  The NameID value.\n\t */\n\tprivate static function generateNameIdValue(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array &$state) {\n\n\t\t$attribute = $spMetadata->getString('simplesaml.nameidattribute', NULL);\n\t\tif ($attribute === NULL) {\n\t\t\t$attribute = $idpMetadata->getString('simplesaml.nameidattribute', NULL);\n\t\t\tif ($attribute === NULL) {\n\t\t\t\tif (!isset($state['UserID'])) {\n\t\t\t\t\tSimpleSAML_Logger::error('Unable to generate NameID. Check the userid.attribute option.');\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t$attributeValue = $state['UserID'];\n\t\t\t\t$idpEntityId = $idpMetadata->getString('entityid');\n\t\t\t\t$spEntityId = $spMetadata->getString('entityid');\n\n\t\t\t\t$secretSalt = SimpleSAML\\Utils\\Config::getSecretSalt();\n\n\t\t\t\t$uidData = 'uidhashbase' . $secretSalt;\n\t\t\t\t$uidData .= strlen($idpEntityId) . ':' . $idpEntityId;\n\t\t\t\t$uidData .= strlen($spEntityId) . ':' . $spEntityId;\n\t\t\t\t$uidData .= strlen($attributeValue) . ':' . $attributeValue;\n\t\t\t\t$uidData .= $secretSalt;\n\n\t\t\t\treturn hash('sha1', $uidData);\n\t\t\t}\n\t\t}\n\n\t\t$attributes = $state['Attributes'];\n\t\tif (!array_key_exists($attribute, $attributes)) {\n\t\t\tSimpleSAML_Logger::error('Unable to add NameID: Missing ' . var_export($attribute, TRUE) .\n\t\t\t\t' in the attributes of the user.');\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn $attributes[$attribute][0];\n\t}\n\n\n\t/**\n\t * Helper function for encoding attributes.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param array $attributes  The attributes of the user\n\t * @return array  The encoded attributes.\n\t */\n\tprivate static function encodeAttributes(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array $attributes) {\n\n\t\t$base64Attributes = $spMetadata->getBoolean('base64attributes', NULL);\n\t\tif ($base64Attributes === NULL) {\n\t\t\t$base64Attributes = $idpMetadata->getBoolean('base64attributes', FALSE);\n\t\t}\n\n\t\tif ($base64Attributes) {\n\t\t\t$defaultEncoding = 'base64';\n\t\t} else {\n\t\t\t$defaultEncoding = 'string';\n\t\t}\n\n\t\t$srcEncodings = $idpMetadata->getArray('attributeencodings', array());\n\t\t$dstEncodings = $spMetadata->getArray('attributeencodings', array());\n\n\t\t/*\n\t\t * Merge the two encoding arrays. Encodings specified in the target metadata\n\t\t * takes precedence over the source metadata.\n\t\t */\n\t\t$encodings = array_merge($srcEncodings, $dstEncodings);\n\n\t\t$ret = array();\n\t\tforeach ($attributes as $name => $values) {\n\t\t\t$ret[$name] = array();\n\t\t\tif (array_key_exists($name, $encodings)) {\n\t\t\t\t$encoding = $encodings[$name];\n\t\t\t} else {\n\t\t\t\t$encoding = $defaultEncoding;\n\t\t\t}\n\n\t\t\tforeach ($values as $value) {\n                // allow null values\n                if ($value === null) {\n                    $ret[$name][] = $value;\n                    continue;\n                }\n\n\t\t\t\t$attrval = $value;\n\t\t\t\tif ($value instanceof DOMNodeList) {\n\t\t\t\t\t$attrval = new SAML2_XML_saml_AttributeValue($value->item(0)->parentNode);\n\t\t\t\t}\n\n\t\t\t\tswitch ($encoding) {\n\t\t\t\tcase 'string':\n\t\t\t\t\t$value = (string)$attrval;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'base64':\n\t\t\t\t\t$value = base64_encode((string)$attrval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'raw':\n\t\t\t\t\tif (is_string($value)) {\n\t\t\t\t\t\t$doc = SAML2_DOMDocumentFactory::fromString('<root>' . $value . '</root>');\n\t\t\t\t\t\t$value = $doc->firstChild->childNodes;\n\t\t\t\t\t}\n\t\t\t\t\tassert('$value instanceof DOMNodeList');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new SimpleSAML_Error_Exception('Invalid encoding for attribute ' .\n\t\t\t\t\t\tvar_export($name, TRUE) . ': ' . var_export($encoding, TRUE));\n\t\t\t\t}\n\t\t\t\t$ret[$name][] = $value;\n\t\t\t}\n\t\t}\n\n\t\treturn $ret;\n\t}\n\n\n\t/**\n\t * Determine which NameFormat we should use for attributes.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @return string  The NameFormat.\n\t */\n\tprivate static function getAttributeNameFormat(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata) {\n\n\t\t/* Try SP metadata first. */\n\t\t$attributeNameFormat = $spMetadata->getString('attributes.NameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\t\t$attributeNameFormat = $spMetadata->getString('AttributeNameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\n\t\t/* Look in IdP metadata. */\n\t\t$attributeNameFormat = $idpMetadata->getString('attributes.NameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\t\t$attributeNameFormat = $idpMetadata->getString('AttributeNameFormat', NULL);\n\t\tif ($attributeNameFormat !== NULL) {\n\t\t\treturn $attributeNameFormat;\n\t\t}\n\n\t\t/* Default. */\n\t\treturn 'urn:oasis:names:tc:SAML:2.0:attrname-format:basic';\n\t}\n\n\n\t/**\n\t * Build an assertion based on information in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param array &$state  The state array with information about the request.\n\t * @return SAML2_Assertion  The assertion.\n\t */\n\tprivate static function buildAssertion(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array &$state) {\n\t\tassert('isset($state[\"Attributes\"])');\n\t\tassert('isset($state[\"saml:ConsumerURL\"])');\n\n\t\t$now = time();\n\n\t\t$signAssertion = $spMetadata->getBoolean('saml20.sign.assertion', NULL);\n\t\tif ($signAssertion === NULL) {\n\t\t\t$signAssertion = $idpMetadata->getBoolean('saml20.sign.assertion', TRUE);\n\t\t}\n\n\t\t$config = SimpleSAML_Configuration::getInstance();\n\n\t\t$a = new SAML2_Assertion();\n\t\tif ($signAssertion) {\n\t\t\tsspmod_saml_Message::addSign($idpMetadata, $spMetadata, $a);\n\t\t}\n\n\t\t$a->setIssuer($idpMetadata->getString('entityid'));\n\t\t$a->setValidAudiences(array($spMetadata->getString('entityid')));\n\n\t\t$a->setNotBefore($now - 30);\n\n\t\t$assertionLifetime = $spMetadata->getInteger('assertion.lifetime', NULL);\n\t\tif ($assertionLifetime === NULL) {\n\t\t\t$assertionLifetime = $idpMetadata->getInteger('assertion.lifetime', 300);\n\t\t}\n\t\t$a->setNotOnOrAfter($now + $assertionLifetime);\n\n\t\tif (isset($state['saml:AuthnContextClassRef'])) {\n\t\t\t$a->setAuthnContext($state['saml:AuthnContextClassRef']);\n\t\t} else {\n\t\t\t$a->setAuthnContext(SAML2_Const::AC_PASSWORD);\n\t\t}\n\n\t\t$sessionStart = $now;\n\t\tif (isset($state['AuthnInstant'])) {\n\t\t\t$a->setAuthnInstant($state['AuthnInstant']);\n\t\t\t$sessionStart = $state['AuthnInstant'];\n\t\t}\n\n\t\t$sessionLifetime = $config->getInteger('session.duration', 8*60*60);\n\t\t$a->setSessionNotOnOrAfter($sessionStart + $sessionLifetime);\n\n\t\t$a->setSessionIndex(SimpleSAML\\Utils\\Random::generateID());\n\n\t\t$sc = new SAML2_XML_saml_SubjectConfirmation();\n\t\t$sc->SubjectConfirmationData = new SAML2_XML_saml_SubjectConfirmationData();\n\t\t$sc->SubjectConfirmationData->NotOnOrAfter = $now + $assertionLifetime;\n\t\t$sc->SubjectConfirmationData->Recipient = $state['saml:ConsumerURL'];\n\t\t$sc->SubjectConfirmationData->InResponseTo = $state['saml:RequestId'];\n\n\t\t/* ProtcolBinding of SP's <AuthnRequest> overwrites IdP hosted metadata configuration. */\n\t\t$hokAssertion = NULL;\n\t\tif ($state['saml:Binding'] === SAML2_Const::BINDING_HOK_SSO) {\n\t\t    $hokAssertion = TRUE;\n\t\t}\n\t\tif ($hokAssertion === NULL) {\n\t\t\t$hokAssertion = $idpMetadata->getBoolean('saml20.hok.assertion', FALSE);\n\t\t}\n\n\t\tif ($hokAssertion) {\n\t\t\t/* Holder-of-Key */\n\t\t\t$sc->Method = SAML2_Const::CM_HOK;\n\t\t\tif (\\SimpleSAML\\Utils\\HTTP::isHTTPS()) {\n\t\t\t\tif (isset($_SERVER['SSL_CLIENT_CERT']) && !empty($_SERVER['SSL_CLIENT_CERT'])) {\n\t\t\t\t\t/* Extract certificate data (if this is a certificate). */\n\t\t\t\t\t$clientCert = $_SERVER['SSL_CLIENT_CERT'];\n\t\t\t\t\t$pattern = '/^-----BEGIN CERTIFICATE-----([^-]*)^-----END CERTIFICATE-----/m';\n\t\t\t\t\tif (preg_match($pattern, $clientCert, $matches)) {\n\t\t\t\t\t\t/* We have a client certificate from the browser which we add to the HoK assertion. */\n\t\t\t\t\t\t$x509Certificate = new SAML2_XML_ds_X509Certificate();\n\t\t\t\t\t\t$x509Certificate->certificate = str_replace(array(\"\\r\", \"\\n\", \" \"), '', $matches[1]);\n\n\t\t\t\t\t\t$x509Data = new SAML2_XML_ds_X509Data();\n\t\t\t\t\t\t$x509Data->data[] = $x509Certificate;\n\n\t\t\t\t\t\t$keyInfo = new SAML2_XML_ds_KeyInfo();\n\t\t\t\t\t\t$keyInfo->info[] = $x509Data;\n\n\t\t\t\t\t\t$sc->SubjectConfirmationData->info[] = $keyInfo;\n\t\t\t\t\t} else throw new SimpleSAML_Error_Exception('Error creating HoK assertion: No valid client certificate provided during TLS handshake with IdP');\n\t\t\t\t} else throw new SimpleSAML_Error_Exception('Error creating HoK assertion: No client certificate provided during TLS handshake with IdP');\n\t\t\t} else throw new SimpleSAML_Error_Exception('Error creating HoK assertion: No HTTPS connection to IdP, but required for Holder-of-Key SSO');\n\t\t} else {\n\t\t\t/* Bearer */\n\t\t\t$sc->Method = SAML2_Const::CM_BEARER;\n\t\t}\n\t\t$a->setSubjectConfirmation(array($sc));\n\n\t\t/* Add attributes. */\n\n\t\tif ($spMetadata->getBoolean('simplesaml.attributes', TRUE)) {\n\t\t\t$attributeNameFormat = self::getAttributeNameFormat($idpMetadata, $spMetadata);\n\t\t\t$a->setAttributeNameFormat($attributeNameFormat);\n\t\t\t$attributes = self::encodeAttributes($idpMetadata, $spMetadata, $state['Attributes']);\n\t\t\t$a->setAttributes($attributes);\n\t\t}\n\n\n\t\t/* Generate the NameID for the assertion. */\n\n\t\tif (isset($state['saml:NameIDFormat'])) {\n\t\t\t$nameIdFormat = $state['saml:NameIDFormat'];\n\t\t} else {\n\t\t\t$nameIdFormat = NULL;\n\t\t}\n\n\t\tif ($nameIdFormat === NULL || !isset($state['saml:NameID'][$nameIdFormat])) {\n\t\t\t/* Either not set in request, or not set to a format we supply. Fall back to old generation method. */\n\t\t\t$nameIdFormat = $spMetadata->getString('NameIDFormat', NULL);\n\t\t\tif ($nameIdFormat === NULL) {\n\t\t\t\t$nameIdFormat = $idpMetadata->getString('NameIDFormat', SAML2_Const::NAMEID_TRANSIENT);\n\t\t\t}\n\t\t}\n\n\t\tif (isset($state['saml:NameID'][$nameIdFormat])) {\n\t\t\t$nameId = $state['saml:NameID'][$nameIdFormat];\n\t\t\t$nameId['Format'] = $nameIdFormat;\n\t\t} else {\n\t\t\t$spNameQualifier = $spMetadata->getString('SPNameQualifier', NULL);\n\t\t\tif ($spNameQualifier === NULL) {\n\t\t\t\t$spNameQualifier = $spMetadata->getString('entityid');\n\t\t\t}\n\n\t\t\tif ($nameIdFormat === SAML2_Const::NAMEID_TRANSIENT) {\n\t\t\t\t/* generate a random id */\n\t\t\t\t$nameIdValue = SimpleSAML\\Utils\\Random::generateID();\n\t\t\t} else {\n\t\t\t\t/* this code will end up generating either a fixed assigned id (via nameid.attribute)\n\t\t\t\t   or random id if not assigned/configured */\n\t\t\t\t$nameIdValue = self::generateNameIdValue($idpMetadata, $spMetadata, $state);\n\t\t\t\tif ($nameIdValue === NULL) {\n\t\t\t\t\tSimpleSAML_Logger::warning('Falling back to transient NameID.');\n\t\t\t\t\t$nameIdFormat = SAML2_Const::NAMEID_TRANSIENT;\n\t\t\t\t\t$nameIdValue = SimpleSAML\\Utils\\Random::generateID();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$nameId = array(\n\t\t\t\t'Format' => $nameIdFormat,\n\t\t\t\t'Value' => $nameIdValue,\n\t\t\t\t'SPNameQualifier' => $spNameQualifier,\n\t\t\t);\n\t\t}\n\n\t\t$state['saml:idp:NameID'] = $nameId;\n\n\t\t$a->setNameId($nameId);\n\n\t\t$encryptNameId = $spMetadata->getBoolean('nameid.encryption', NULL);\n\t\tif ($encryptNameId === NULL) {\n\t\t\t$encryptNameId = $idpMetadata->getBoolean('nameid.encryption', FALSE);\n\t\t}\n\t\tif ($encryptNameId) {\n\t\t\t$a->encryptNameId(sspmod_saml_Message::getEncryptionKey($spMetadata));\n\t\t}\n\n\t\treturn $a;\n\t}\n\n\n\t/**\n\t * Encrypt an assertion.\n\t *\n\t * This function takes in a SAML2_Assertion and encrypts it if encryption of\n\t * assertions are enabled in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param SAML2_Assertion $assertion  The assertion we are encrypting.\n\t * @return SAML2_Assertion|SAML2_EncryptedAssertion  The assertion.\n\t */\n\tprivate static function encryptAssertion(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, SAML2_Assertion $assertion) {\n\n\t\t$encryptAssertion = $spMetadata->getBoolean('assertion.encryption', NULL);\n\t\tif ($encryptAssertion === NULL) {\n\t\t\t$encryptAssertion = $idpMetadata->getBoolean('assertion.encryption', FALSE);\n\t\t}\n\t\tif (!$encryptAssertion) {\n\t\t\t/* We are _not_ encrypting this assertion, and are therefore done. */\n\t\t\treturn $assertion;\n\t\t}\n\n\n\t\t$sharedKey = $spMetadata->getString('sharedkey', NULL);\n\t\tif ($sharedKey !== NULL) {\n\t\t\t$key = new XMLSecurityKey(XMLSecurityKey::AES128_CBC);\n\t\t\t$key->loadKey($sharedKey);\n\t\t} else {\n\t\t\t$keys = $spMetadata->getPublicKeys('encryption', TRUE);\n\t\t\t$key = $keys[0];\n\t\t\tswitch ($key['type']) {\n\t\t\tcase 'X509Certificate':\n\t\t\t\t$pemKey = \"-----BEGIN CERTIFICATE-----\\n\" .\n\t\t\t\t\tchunk_split($key['X509Certificate'], 64) .\n\t\t\t\t\t\"-----END CERTIFICATE-----\\n\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new SimpleSAML_Error_Exception('Unsupported encryption key type: ' . $key['type']);\n\t\t\t}\n\n\t\t\t/* Extract the public key from the certificate for encryption. */\n\t\t\t$key = new XMLSecurityKey(XMLSecurityKey::RSA_OAEP_MGF1P, array('type'=>'public'));\n\t\t\t$key->loadKey($pemKey);\n\t\t}\n\n\t\t$ea = new SAML2_EncryptedAssertion();\n\t\t$ea->setAssertion($assertion, $key);\n\t\treturn $ea;\n\t}\n\n\n\t/**\n\t * Build a logout request based on information in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration spMetadata  The metadata of the SP.\n\t * @param array $association  The SP association.\n\t * @param string|NULL $relayState  An id that should be carried across the logout.\n\t */\n\tprivate static function buildLogoutRequest(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, array $association, $relayState) {\n\n\t\t$lr = sspmod_saml_Message::buildLogoutRequest($idpMetadata, $spMetadata);\n\t\t$lr->setRelayState($relayState);\n\t\t$lr->setSessionIndex($association['saml:SessionIndex']);\n\t\t$lr->setNameId($association['saml:NameID']);\n\n\t\t$assertionLifetime = $spMetadata->getInteger('assertion.lifetime', NULL);\n\t\tif ($assertionLifetime === NULL) {\n\t\t\t$assertionLifetime = $idpMetadata->getInteger('assertion.lifetime', 300);\n\t\t}\n\t\t$lr->setNotOnOrAfter(time() + $assertionLifetime);\n\n\t\t$encryptNameId = $spMetadata->getBoolean('nameid.encryption', NULL);\n\t\tif ($encryptNameId === NULL) {\n\t\t\t$encryptNameId = $idpMetadata->getBoolean('nameid.encryption', FALSE);\n\t\t}\n\t\tif ($encryptNameId) {\n\t\t\t$lr->encryptNameId(sspmod_saml_Message::getEncryptionKey($spMetadata));\n\t\t}\n\n\t\treturn $lr;\n\t}\n\n\n\t/**\n\t * Build a authentication response based on information in the metadata.\n\t *\n\t * @param SimpleSAML_Configuration $idpMetadata  The metadata of the IdP.\n\t * @param SimpleSAML_Configuration $spMetadata  The metadata of the SP.\n\t * @param string $consumerURL  The Destination URL of the response.\n\t */\n\tprivate static function buildResponse(SimpleSAML_Configuration $idpMetadata,\n\t\tSimpleSAML_Configuration $spMetadata, $consumerURL) {\n\n\t\t$signResponse = $spMetadata->getBoolean('saml20.sign.response', NULL);\n\t\tif ($signResponse === NULL) {\n\t\t\t$signResponse = $idpMetadata->getBoolean('saml20.sign.response', TRUE);\n\t\t}\n\n\t\t$r = new SAML2_Response();\n\n\t\t$r->setIssuer($idpMetadata->getString('entityid'));\n\t\t$r->setDestination($consumerURL);\n\n\t\tif ($signResponse) {\n\t\t\tsspmod_saml_Message::addSign($idpMetadata, $spMetadata, $r);\n\t\t}\n\n\t\treturn $r;\n\t}\n\n}"], "filenames": ["modules/saml/lib/IdP/SAML2.php"], "buggy_code_start_loc": [625], "buggy_code_end_loc": [625], "fixing_code_start_loc": [626], "fixing_code_end_loc": [627], "type": "CWE-384", "message": "SimpleSAMLphp 1.7.0 through 1.14.10 might allow attackers to obtain sensitive information, gain unauthorized access, or have unspecified other impacts by leveraging incorrect persistent NameID generation when an Identity Provider (IdP) is misconfigured.", "other": {"cve": {"id": "CVE-2017-12873", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-01T21:29:00.593", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SimpleSAMLphp 1.7.0 through 1.14.10 might allow attackers to obtain sensitive information, gain unauthorized access, or have unspecified other impacts by leveraging incorrect persistent NameID generation when an Identity Provider (IdP) is misconfigured."}, {"lang": "es", "value": "SimpleSAMLphp 1.7.0 hasta la versi\u00f3n 1.14.10 permite que los atacantes obtengan informaci\u00f3n sensible, consigan acceso sin autorizaci\u00f3n o provoquen cualquier otro impacto sin especificar aprovechando la incorrecta generaci\u00f3n persistente de NameID cuando no se configura correctamente un Identity Provider (IdP)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simplesamlphp:simplesamlphp:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.7.0", "versionEndIncluding": "1.14.10", "matchCriteriaId": "1F513BAE-A775-44DF-980A-1CEA3A25CA35"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/simplesamlphp/simplesamlphp/commit/90dca835158495b173808273e7df127303b8b953", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://simplesamlphp.org/security/201612-04", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/simplesamlphp/simplesamlphp/commit/90dca835158495b173808273e7df127303b8b953"}}