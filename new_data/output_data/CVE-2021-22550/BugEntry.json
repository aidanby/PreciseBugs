{"buggy_code": ["/*\n *\n * Copyright 2018 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n#include \"asylo/platform/primitives/sgx/untrusted_cache_malloc.h\"\n\n#include <cstdlib>\n#include <memory>\n\n#include \"absl/memory/memory.h\"\n#include \"asylo/platform/core/trusted_spin_lock.h\"\n#include \"asylo/platform/posix/memory/memory.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/primitives/trusted_runtime.h\"\n#include \"asylo/util/lock_guard.h\"\n\nextern \"C\" {\n// Expose the untrusted memory cache via a C API. This interface allows C code\n// to depend on the global memory pool singleton.\n\nvoid *untrusted_cache_malloc(size_t size) {\n  asylo::UntrustedCacheMalloc *instance =\n      asylo::UntrustedCacheMalloc::Instance();\n  return instance->Malloc(size);\n}\n\nvoid untrusted_cache_free(void *buffer) {\n  asylo::UntrustedCacheMalloc *instance =\n      asylo::UntrustedCacheMalloc::Instance();\n  instance->Free(buffer);\n}\n\n}  // extern \"C\"\n\nnamespace asylo {\n\nusing primitives::TrustedPrimitives;\n\nbool UntrustedCacheMalloc::is_destroyed_ = false;\n\nUntrustedCacheMalloc *UntrustedCacheMalloc::Instance() {\n  static TrustedSpinLock lock(/*is_recursive=*/false);\n  static UntrustedCacheMalloc *instance = nullptr;\n  if (instance == nullptr) {\n    LockGuard guard(&lock);\n    if (instance == nullptr) {\n      instance = new UntrustedCacheMalloc();\n    }\n  }\n  return instance;\n}\n\nUntrustedCacheMalloc::UntrustedCacheMalloc() : lock_(/*is_recursive=*/true) {\n  if (is_destroyed_) {\n    return;\n  }\n  // Initialize a free list object in the trusted heap. The free list object\n  // stores an array of buffers stored in the untrusted heap.\n  free_list_ = absl::make_unique<FreeList>();\n  free_list_->buffers.reset(reinterpret_cast<void **>(\n      primitives::TrustedPrimitives::UntrustedLocalAlloc(sizeof(void *) *\n                                                         kFreeListCapacity)));\n  free_list_->count = 0;\n}\n\nUntrustedCacheMalloc::~UntrustedCacheMalloc() {\n  while (!buffer_pool_.empty()) {\n    PushToFreeList(buffer_pool_.top());\n    buffer_pool_.pop();\n  }\n\n  // Free remaining elements in the free_list_.\n  // The free_list_ object and the struct FreeList member buffers are destroyed\n  // when the unique pointers referencing them go out of scope.\n  if (free_list_->count > 0) {\n    primitives::DeAllocateUntrustedBuffers(free_list_->buffers.get(),\n                                           free_list_->count);\n  }\n  is_destroyed_ = true;\n}\n\nvoid *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n\n  if (is_pool_empty) {\n    // Free memory held by the array of buffer pointers returned by\n    // AllocateUntrustedBuffers.\n    Free(buffers);\n  }\n  return buffer;\n}\n\nvoid *UntrustedCacheMalloc::Malloc(size_t size) {\n  // Don't access UnturstedCacheMalloc if not running on normal heap, otherwise\n  // it will cause error when UntrustedCacheMalloc tries to free the memory on\n  // the normal heap.\n  if (is_destroyed_ || (size > kPoolEntrySize) || GetSwitchedHeapNext()) {\n    return primitives::TrustedPrimitives::UntrustedLocalAlloc(size);\n  }\n  return GetBuffer();\n}\n\nvoid UntrustedCacheMalloc::PushToFreeList(void *buffer) {\n  free_list_->buffers.get()[free_list_->count] = buffer;\n  free_list_->count++;\n\n  if (free_list_->count == kFreeListCapacity) {\n    primitives::DeAllocateUntrustedBuffers(free_list_->buffers.get(),\n                                           kFreeListCapacity);\n    free_list_->count = 0;\n  }\n}\n\nvoid UntrustedCacheMalloc::Free(void *buffer) {\n  if (is_destroyed_ || GetSwitchedHeapNext()) {\n    primitives::TrustedPrimitives::UntrustedLocalFree(buffer);\n    return;\n  }\n  LockGuard spin_lock(&lock_);\n\n  // Add the buffer to the free list if it was not allocated from the buffer\n  // pool and was allocated via UntrustedLocalAlloc. If the\n  // buffer was allocated from the buffer pool push it back to the pool.\n  if (busy_buffers_.find(buffer) == busy_buffers_.end()) {\n    PushToFreeList(buffer);\n    return;\n  }\n  busy_buffers_.erase(buffer);\n  buffer_pool_.push(buffer);\n}\n\n}  // namespace asylo\n"], "fixing_code": ["/*\n *\n * Copyright 2018 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n#include \"asylo/platform/primitives/sgx/untrusted_cache_malloc.h\"\n\n#include <cstdlib>\n#include <memory>\n\n#include \"absl/memory/memory.h\"\n#include \"asylo/platform/core/trusted_spin_lock.h\"\n#include \"asylo/platform/posix/memory/memory.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/primitives/trusted_runtime.h\"\n#include \"asylo/util/lock_guard.h\"\n\nextern \"C\" {\n// Expose the untrusted memory cache via a C API. This interface allows C code\n// to depend on the global memory pool singleton.\n\nvoid *untrusted_cache_malloc(size_t size) {\n  asylo::UntrustedCacheMalloc *instance =\n      asylo::UntrustedCacheMalloc::Instance();\n  return instance->Malloc(size);\n}\n\nvoid untrusted_cache_free(void *buffer) {\n  asylo::UntrustedCacheMalloc *instance =\n      asylo::UntrustedCacheMalloc::Instance();\n  instance->Free(buffer);\n}\n\n}  // extern \"C\"\n\nnamespace asylo {\n\nusing primitives::TrustedPrimitives;\n\nbool UntrustedCacheMalloc::is_destroyed_ = false;\n\nUntrustedCacheMalloc *UntrustedCacheMalloc::Instance() {\n  static TrustedSpinLock lock(/*is_recursive=*/false);\n  static UntrustedCacheMalloc *instance = nullptr;\n  if (instance == nullptr) {\n    LockGuard guard(&lock);\n    if (instance == nullptr) {\n      instance = new UntrustedCacheMalloc();\n    }\n  }\n  return instance;\n}\n\nUntrustedCacheMalloc::UntrustedCacheMalloc() : lock_(/*is_recursive=*/true) {\n  if (is_destroyed_) {\n    return;\n  }\n  // Initialize a free list object in the trusted heap. The free list object\n  // stores an array of buffers stored in the untrusted heap.\n  free_list_ = absl::make_unique<FreeList>();\n  free_list_->buffers.reset(reinterpret_cast<void **>(\n      primitives::TrustedPrimitives::UntrustedLocalAlloc(sizeof(void *) *\n                                                         kFreeListCapacity)));\n  free_list_->count = 0;\n}\n\nUntrustedCacheMalloc::~UntrustedCacheMalloc() {\n  while (!buffer_pool_.empty()) {\n    PushToFreeList(buffer_pool_.top());\n    buffer_pool_.pop();\n  }\n\n  // Free remaining elements in the free_list_.\n  // The free_list_ object and the struct FreeList member buffers are destroyed\n  // when the unique pointers referencing them go out of scope.\n  if (free_list_->count > 0) {\n    primitives::DeAllocateUntrustedBuffers(free_list_->buffers.get(),\n                                           free_list_->count);\n  }\n  is_destroyed_ = true;\n}\n\nvoid *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        void *buf = buffers[i];\n        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) {\n          TrustedPrimitives::BestEffortAbort(\n              \"Cached buffer is not outside the enclave\");\n        }\n        buffer_pool_.push(buf);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n\n  if (is_pool_empty) {\n    // Free memory held by the array of buffer pointers returned by\n    // AllocateUntrustedBuffers.\n    Free(buffers);\n  }\n  return buffer;\n}\n\nvoid *UntrustedCacheMalloc::Malloc(size_t size) {\n  // Don't access UnturstedCacheMalloc if not running on normal heap, otherwise\n  // it will cause error when UntrustedCacheMalloc tries to free the memory on\n  // the normal heap.\n  if (is_destroyed_ || (size > kPoolEntrySize) || GetSwitchedHeapNext()) {\n    return primitives::TrustedPrimitives::UntrustedLocalAlloc(size);\n  }\n  return GetBuffer();\n}\n\nvoid UntrustedCacheMalloc::PushToFreeList(void *buffer) {\n  free_list_->buffers.get()[free_list_->count] = buffer;\n  free_list_->count++;\n\n  if (free_list_->count == kFreeListCapacity) {\n    primitives::DeAllocateUntrustedBuffers(free_list_->buffers.get(),\n                                           kFreeListCapacity);\n    free_list_->count = 0;\n  }\n}\n\nvoid UntrustedCacheMalloc::Free(void *buffer) {\n  if (is_destroyed_ || GetSwitchedHeapNext()) {\n    primitives::TrustedPrimitives::UntrustedLocalFree(buffer);\n    return;\n  }\n  LockGuard spin_lock(&lock_);\n\n  // Add the buffer to the free list if it was not allocated from the buffer\n  // pool and was allocated via UntrustedLocalAlloc. If the\n  // buffer was allocated from the buffer pool push it back to the pool.\n  if (busy_buffers_.find(buffer) == busy_buffers_.end()) {\n    PushToFreeList(buffer);\n    return;\n  }\n  busy_buffers_.erase(buffer);\n  buffer_pool_.push(buffer);\n}\n\n}  // namespace asylo\n"], "filenames": ["asylo/platform/primitives/sgx/untrusted_cache_malloc.cc"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [112], "fixing_code_start_loc": [107], "fixing_code_end_loc": [113], "type": "CWE-668", "message": "An attacker can modify the pointers in enclave memory to overwrite arbitrary memory addresses within the secure enclave. It is recommended to update past 0.6.3 or git commit https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c", "other": {"cve": {"id": "CVE-2021-22550", "sourceIdentifier": "cve-coordination@google.com", "published": "2021-06-08T14:15:07.873", "lastModified": "2021-06-22T15:37:30.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An attacker can modify the pointers in enclave memory to overwrite arbitrary memory addresses within the secure enclave. It is recommended to update past 0.6.3 or git commit https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c"}, {"lang": "es", "value": "Un atacante puede modificar los punteros de la memoria del enclave para sobrescribir direcciones de memoria arbitrarias dentro del enclave seguro. Se recomienda actualizar a partir de la versi\u00f3n 0.6.3 o el git commit https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-823"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:asylo:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.3", "matchCriteriaId": "171CA70B-1C6F-45D7-B24D-97F9227D1015"}]}]}], "references": [{"url": "https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c"}}