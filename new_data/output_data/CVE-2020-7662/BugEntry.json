{"buggy_code": ["'use strict';\n\nvar TOKEN    = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/,\n    NOTOKEN  = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/g,\n    QUOTED   = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"])*)\"/,\n    PARAM    = new RegExp(TOKEN.source + '(?:=(?:' + TOKEN.source + '|' + QUOTED.source + '))?'),\n    EXT      = new RegExp(TOKEN.source + '(?: *; *' + PARAM.source + ')*', 'g'),\n    EXT_LIST = new RegExp('^' + EXT.source + '(?: *, *' + EXT.source + ')*$'),\n    NUMBER   = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar Parser = {\n  parseHeader: function(header) {\n    var offers = new Offers();\n    if (header === '' || header === undefined) return offers;\n\n    if (!EXT_LIST.test(header))\n      throw new SyntaxError('Invalid Sec-WebSocket-Extensions header: ' + header);\n\n    var values = header.match(EXT);\n\n    values.forEach(function(value) {\n      var params = value.match(new RegExp(PARAM.source, 'g')),\n          name   = params.shift(),\n          offer  = {};\n\n      params.forEach(function(param) {\n        var args = param.match(PARAM), key = args[1], data;\n\n        if (args[2] !== undefined) {\n          data = args[2];\n        } else if (args[3] !== undefined) {\n          data = args[3].replace(/\\\\/g, '');\n        } else {\n          data = true;\n        }\n        if (NUMBER.test(data)) data = parseFloat(data);\n\n        if (hasOwnProperty.call(offer, key)) {\n          offer[key] = [].concat(offer[key]);\n          offer[key].push(data);\n        } else {\n          offer[key] = data;\n        }\n      }, this);\n      offers.push(name, offer);\n    }, this);\n\n    return offers;\n  },\n\n  serializeParams: function(name, params) {\n    var values = [];\n\n    var print = function(key, value) {\n      if (value instanceof Array) {\n        value.forEach(function(v) { print(key, v) });\n      } else if (value === true) {\n        values.push(key);\n      } else if (typeof value === 'number') {\n        values.push(key + '=' + value);\n      } else if (NOTOKEN.test(value)) {\n        values.push(key + '=\"' + value.replace(/\"/g, '\\\\\"') + '\"');\n      } else {\n        values.push(key + '=' + value);\n      }\n    };\n\n    for (var key in params) print(key, params[key]);\n\n    return [name].concat(values).join('; ');\n  }\n};\n\nvar Offers = function() {\n  this._byName  = {};\n  this._inOrder = [];\n};\n\nOffers.prototype.push = function(name, params) {\n  if (!hasOwnProperty.call(this._byName, name))\n    this._byName[name] = [];\n\n  this._byName[name].push(params);\n  this._inOrder.push({ name: name, params: params });\n};\n\nOffers.prototype.eachOffer = function(callback, context) {\n  var list = this._inOrder;\n  for (var i = 0, n = list.length; i < n; i++)\n    callback.call(context, list[i].name, list[i].params);\n};\n\nOffers.prototype.byName = function(name) {\n  return this._byName[name] || [];\n};\n\nOffers.prototype.toArray = function() {\n  return this._inOrder.slice();\n};\n\nmodule.exports = Parser;\n", "var Parser = require('../lib/parser'),\n    test   = require('jstest').Test\n\ntest.describe(\"Parser\", function() { with(this) {\n  describe(\"parseHeader\", function() { with(this) {\n    define(\"parse\", function(string) {\n      return Parser.parseHeader(string).toArray()\n    })\n\n    it(\"parses an empty header\", function() { with(this) {\n      assertEqual( [], parse('') )\n    }})\n\n    it(\"parses a missing header\", function() { with(this) {\n      assertEqual( [], parse(undefined) )\n    }})\n\n    it(\"throws on invalid input\", function() { with(this) {\n      assertThrows(SyntaxError, function() { parse('a,') })\n    }})\n\n    it(\"parses one offer with no params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: {}}],\n                   parse('a') )\n    }})\n\n    it(\"parses two offers with no params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: {}}, { name: \"b\", params: {}}],\n                   parse('a, b') )\n    }})\n\n    it(\"parses a duplicate offer name\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: {}}, { name: \"a\", params: {}}],\n                   parse('a, a') )\n    }})\n\n    it(\"parses a flag\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: true }}],\n                   parse('a; b') )\n    }})\n\n    it(\"parses an unquoted param\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: 1 }}],\n                   parse('a; b=1') )\n    }})\n\n    it(\"parses a quoted param\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: 'hi, \"there' }}],\n                   parse('a; b=\"hi, \\\\\"there\"') )\n    }})\n\n    it(\"parses multiple params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: true, c: 1, d: 'hi' }}],\n                   parse('a; b; c=1; d=\"hi\"') )\n    }})\n\n    it(\"parses duplicate params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: [true, 'hi'], c: 1 }}],\n                   parse('a; b; c=1; b=\"hi\"') )\n    }})\n\n    it(\"parses multiple complex offers\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: 1 }},\n                    { name: \"c\", params: {}},\n                    { name: \"b\", params: { d: true }},\n                    { name: \"c\", params: { e: ['hi, there', true] }},\n                    { name: \"a\", params: { b: true }}],\n                   parse('a; b=1, c, b; d, c; e=\"hi, there\"; e, a; b') )\n    }})\n\n    it(\"parses an extension name that shadows an Object property\", function() { with(this) {\n      assertEqual( [{ name: \"hasOwnProperty\", params: {}}],\n                   parse('hasOwnProperty') )\n    }})\n\n    it(\"parses an extension param that shadows an Object property\", function() { with(this) {\n      var result = parse('foo; hasOwnProperty; x')[0]\n      assertEqual( result.params.hasOwnProperty, true )\n    }})\n\n  }})\n\n  describe(\"serializeParams\", function() { with(this) {\n    it(\"serializes empty params\", function() { with(this) {\n      assertEqual( 'a', Parser.serializeParams('a', {}) )\n    }})\n\n    it(\"serializes a flag\", function() { with(this) {\n      assertEqual( 'a; b', Parser.serializeParams('a', { b: true }) )\n    }})\n\n    it(\"serializes an unquoted param\", function() { with(this) {\n      assertEqual( 'a; b=42', Parser.serializeParams('a', { b: '42' }) )\n    }})\n\n    it(\"serializes a quoted param\", function() { with(this) {\n      assertEqual( 'a; b=\"hi, there\"', Parser.serializeParams('a', { b: 'hi, there' }) )\n    }})\n\n    it(\"serializes multiple params\", function() { with(this) {\n      assertEqual( 'a; b; c=1; d=hi', Parser.serializeParams('a', { b: true, c: 1, d: 'hi' }) )\n    }})\n\n    it(\"serializes duplicate params\", function() { with(this) {\n      assertEqual( 'a; b; b=hi; c=1', Parser.serializeParams('a', { b: [true, 'hi'], c: 1 }) )\n    }})\n  }})\n}})\n"], "fixing_code": ["'use strict';\n\nvar TOKEN    = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/,\n    NOTOKEN  = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/g,\n    QUOTED   = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"\\\\])*)\"/,\n    PARAM    = new RegExp(TOKEN.source + '(?:=(?:' + TOKEN.source + '|' + QUOTED.source + '))?'),\n    EXT      = new RegExp(TOKEN.source + '(?: *; *' + PARAM.source + ')*', 'g'),\n    EXT_LIST = new RegExp('^' + EXT.source + '(?: *, *' + EXT.source + ')*$'),\n    NUMBER   = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar Parser = {\n  parseHeader: function(header) {\n    var offers = new Offers();\n    if (header === '' || header === undefined) return offers;\n\n    if (!EXT_LIST.test(header))\n      throw new SyntaxError('Invalid Sec-WebSocket-Extensions header: ' + header);\n\n    var values = header.match(EXT);\n\n    values.forEach(function(value) {\n      var params = value.match(new RegExp(PARAM.source, 'g')),\n          name   = params.shift(),\n          offer  = {};\n\n      params.forEach(function(param) {\n        var args = param.match(PARAM), key = args[1], data;\n\n        if (args[2] !== undefined) {\n          data = args[2];\n        } else if (args[3] !== undefined) {\n          data = args[3].replace(/\\\\/g, '');\n        } else {\n          data = true;\n        }\n        if (NUMBER.test(data)) data = parseFloat(data);\n\n        if (hasOwnProperty.call(offer, key)) {\n          offer[key] = [].concat(offer[key]);\n          offer[key].push(data);\n        } else {\n          offer[key] = data;\n        }\n      }, this);\n      offers.push(name, offer);\n    }, this);\n\n    return offers;\n  },\n\n  serializeParams: function(name, params) {\n    var values = [];\n\n    var print = function(key, value) {\n      if (value instanceof Array) {\n        value.forEach(function(v) { print(key, v) });\n      } else if (value === true) {\n        values.push(key);\n      } else if (typeof value === 'number') {\n        values.push(key + '=' + value);\n      } else if (NOTOKEN.test(value)) {\n        values.push(key + '=\"' + value.replace(/\"/g, '\\\\\"') + '\"');\n      } else {\n        values.push(key + '=' + value);\n      }\n    };\n\n    for (var key in params) print(key, params[key]);\n\n    return [name].concat(values).join('; ');\n  }\n};\n\nvar Offers = function() {\n  this._byName  = {};\n  this._inOrder = [];\n};\n\nOffers.prototype.push = function(name, params) {\n  if (!hasOwnProperty.call(this._byName, name))\n    this._byName[name] = [];\n\n  this._byName[name].push(params);\n  this._inOrder.push({ name: name, params: params });\n};\n\nOffers.prototype.eachOffer = function(callback, context) {\n  var list = this._inOrder;\n  for (var i = 0, n = list.length; i < n; i++)\n    callback.call(context, list[i].name, list[i].params);\n};\n\nOffers.prototype.byName = function(name) {\n  return this._byName[name] || [];\n};\n\nOffers.prototype.toArray = function() {\n  return this._inOrder.slice();\n};\n\nmodule.exports = Parser;\n", "var Parser = require('../lib/parser'),\n    test   = require('jstest').Test\n\ntest.describe(\"Parser\", function() { with(this) {\n  describe(\"parseHeader\", function() { with(this) {\n    define(\"parse\", function(string) {\n      return Parser.parseHeader(string).toArray()\n    })\n\n    it(\"parses an empty header\", function() { with(this) {\n      assertEqual( [], parse('') )\n    }})\n\n    it(\"parses a missing header\", function() { with(this) {\n      assertEqual( [], parse(undefined) )\n    }})\n\n    it(\"throws on invalid input\", function() { with(this) {\n      assertThrows(SyntaxError, function() { parse('a,') })\n    }})\n\n    it(\"parses one offer with no params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: {}}],\n                   parse('a') )\n    }})\n\n    it(\"parses two offers with no params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: {}}, { name: \"b\", params: {}}],\n                   parse('a, b') )\n    }})\n\n    it(\"parses a duplicate offer name\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: {}}, { name: \"a\", params: {}}],\n                   parse('a, a') )\n    }})\n\n    it(\"parses a flag\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: true }}],\n                   parse('a; b') )\n    }})\n\n    it(\"parses an unquoted param\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: 1 }}],\n                   parse('a; b=1') )\n    }})\n\n    it(\"parses a quoted param\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: 'hi, \"there' }}],\n                   parse('a; b=\"hi, \\\\\"there\"') )\n    }})\n\n    it(\"parses multiple params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: true, c: 1, d: 'hi' }}],\n                   parse('a; b; c=1; d=\"hi\"') )\n    }})\n\n    it(\"parses duplicate params\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: [true, 'hi'], c: 1 }}],\n                   parse('a; b; c=1; b=\"hi\"') )\n    }})\n\n    it(\"parses multiple complex offers\", function() { with(this) {\n      assertEqual( [{ name: \"a\", params: { b: 1 }},\n                    { name: \"c\", params: {}},\n                    { name: \"b\", params: { d: true }},\n                    { name: \"c\", params: { e: ['hi, there', true] }},\n                    { name: \"a\", params: { b: true }}],\n                   parse('a; b=1, c, b; d, c; e=\"hi, there\"; e, a; b') )\n    }})\n\n    it(\"parses an extension name that shadows an Object property\", function() { with(this) {\n      assertEqual( [{ name: \"hasOwnProperty\", params: {}}],\n                   parse('hasOwnProperty') )\n    }})\n\n    it(\"parses an extension param that shadows an Object property\", function() { with(this) {\n      var result = parse('foo; hasOwnProperty; x')[0]\n      assertEqual( result.params.hasOwnProperty, true )\n    }})\n\n    it(\"rejects a string missing its closing quote\", function() { with(this) {\n      assertThrows(SyntaxError, function() {\n        parse('foo; bar=\"fooa\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a\\\\a')\n      })\n    }})\n  }})\n\n  describe(\"serializeParams\", function() { with(this) {\n    it(\"serializes empty params\", function() { with(this) {\n      assertEqual( 'a', Parser.serializeParams('a', {}) )\n    }})\n\n    it(\"serializes a flag\", function() { with(this) {\n      assertEqual( 'a; b', Parser.serializeParams('a', { b: true }) )\n    }})\n\n    it(\"serializes an unquoted param\", function() { with(this) {\n      assertEqual( 'a; b=42', Parser.serializeParams('a', { b: '42' }) )\n    }})\n\n    it(\"serializes a quoted param\", function() { with(this) {\n      assertEqual( 'a; b=\"hi, there\"', Parser.serializeParams('a', { b: 'hi, there' }) )\n    }})\n\n    it(\"serializes multiple params\", function() { with(this) {\n      assertEqual( 'a; b; c=1; d=hi', Parser.serializeParams('a', { b: true, c: 1, d: 'hi' }) )\n    }})\n\n    it(\"serializes duplicate params\", function() { with(this) {\n      assertEqual( 'a; b; b=hi; c=1', Parser.serializeParams('a', { b: [true, 'hi'], c: 1 }) )\n    }})\n  }})\n}})\n"], "filenames": ["lib/parser.js", "spec/parser_spec.js"], "buggy_code_start_loc": [5, 80], "buggy_code_end_loc": [6, 80], "fixing_code_start_loc": [5, 81], "fixing_code_end_loc": [6, 86], "type": "NVD-CWE-Other", "message": "websocket-extensions npm module prior to 0.1.4 allows Denial of Service (DoS) via Regex Backtracking. The extension parser may take quadratic time when parsing a header containing an unclosed string parameter value whose content is a repeating two-byte sequence of a backslash and some other character. This could be abused by an attacker to conduct Regex Denial Of Service (ReDoS) on a single-threaded server by providing a malicious payload with the Sec-WebSocket-Extensions header.", "other": {"cve": {"id": "CVE-2020-7662", "sourceIdentifier": "report@snyk.io", "published": "2020-06-02T19:15:12.403", "lastModified": "2020-12-23T18:22:38.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "websocket-extensions npm module prior to 0.1.4 allows Denial of Service (DoS) via Regex Backtracking. The extension parser may take quadratic time when parsing a header containing an unclosed string parameter value whose content is a repeating two-byte sequence of a backslash and some other character. This could be abused by an attacker to conduct Regex Denial Of Service (ReDoS) on a single-threaded server by providing a malicious payload with the Sec-WebSocket-Extensions header."}, {"lang": "es", "value": "El m\u00f3dulo de npm websocket-extensions versiones anteriores a 0.1.4 permite una denegaci\u00f3n de servicio (DoS) por medio de Regex Backtracking. El analizador de extensiones puede tardar un tiempo cuadr\u00e1tico cuando analiza un encabezado que contiene un valor de par\u00e1metro de cadena no cerrado cuyo contenido es una secuencia repetitiva de dos bytes de una barra diagonal inversa y alg\u00fan otro car\u00e1cter. Esto podr\u00eda ser abusado por un atacante para llevar a cabo una Denegaci\u00f3n de Servicio de Regex (ReDoS) en un servidor de un subproceso \u00fanico al proporcionar una carga \u00fatil maliciosa con el encabezado Sec-WebSocket-Extensions"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:websocket-extensions_project:websocket-extensions:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.1.4", "matchCriteriaId": "8DB781EF-866D-46E6-A817-2CB528145B37"}]}]}], "references": [{"url": "https://blog.jcoglan.com/2020/06/02/redos-vulnerability-in-websocket-extensions", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/faye/websocket-extensions-node/commit/29496f6838bfadfe5a2f85dff33ed0ba33873237", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/faye/websocket-extensions-node/security/advisories/GHSA-g78m-2chm-r7qv", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-WEBSOCKETEXTENSIONS-570623", "source": "report@snyk.io", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/faye/websocket-extensions-node/commit/29496f6838bfadfe5a2f85dff33ed0ba33873237"}}