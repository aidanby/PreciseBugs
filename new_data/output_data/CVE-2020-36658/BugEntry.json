{"buggy_code": ["package Apache::Session::LDAP;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = '0.4';\n@ISA     = qw(Apache::Session);\n\nuse Apache::Session;\nuse Apache::Session::Lock::Null;\nuse Apache::Session::Store::LDAP;\nuse Apache::Session::Generate::MD5;\nuse Apache::Session::Serialize::Base64;\n\nsub populate {\n    my $self = shift;\n\n    $self->{object_store} = new Apache::Session::Store::LDAP $self;\n    $self->{lock_manager} = new Apache::Session::Lock::Null $self;\n    $self->{generate}     = \\&Apache::Session::Generate::MD5::generate;\n    $self->{validate}     = \\&Apache::Session::Generate::MD5::validate;\n    $self->{serialize}    = \\&Apache::Session::Serialize::Base64::serialize;\n    $self->{unserialize}  = \\&Apache::Session::Serialize::Base64::unserialize;\n\n    return $self;\n}\n\n1;\n\n=pod\n\n=head1 NAME\n\nApache::Session::LDAP - An implementation of Apache::Session\n\n=head1 SYNOPSIS\n\n  use Apache::Session::LDAP;\n  tie %hash, 'Apache::Session::LDAP', $id, {\n    ldapServer           => 'ldap://localhost:389',\n    ldapConfBase         => 'dmdName=applications,dc=example,dc=com',\n    ldapBindDN           => 'cn=admin,dc=example,dc=com',\n    ldapBindPassword     => 'pass',\n    ldapObjectClass      => 'applicationProcess',\n    ldapAttributeId      => 'cn',\n    ldapAttributeContent => 'description',\n  };\n\n=head1 DESCRIPTION\n\nThis module is an implementation of Apache::Session. It uses an LDAP directory\nto store datas.\n\n=head1 AUTHOR\n\nXavier Guimard, E<lt>x.guimard@free.frE<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2009, 2012 by Xavier Guimard\nCopyright (C) 2014, 2015 by Clement Oudot\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\n=head1 SEE ALSO\n\nL<Apache::Session>\n\n=cut\n", "package Apache::Session::Store::LDAP;\n\nuse strict;\nuse vars qw($VERSION);\nuse Net::LDAP;\n\n$VERSION = '0.4';\n\nsub new {\n    my $class = shift;\n    return bless {}, $class;\n}\n\nsub insert {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    my $msg = $self->ldap->add(\n        $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        attrs => [\n            objectClass => $self->{args}->{ldapObjectClass},\n            $self->{args}->{ldapAttributeId} => $session->{data}->{_session_id},\n            $self->{args}->{ldapAttributeContent} => $session->{serialized},\n        ],\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub update {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    my $msg = $self->ldap->modify(\n        $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        replace =>\n          { $self->{args}->{ldapAttributeContent} => $session->{serialized}, },\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub materialize {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    my $msg = $self->ldap->search(\n        base => $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        filter => '(objectClass=' . $self->{args}->{ldapObjectClass} . ')',\n        scope  => 'base',\n        attrs  => [ $self->{args}->{ldapAttributeContent} ],\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n\n    eval {\n        $session->{serialized} = $msg->shift_entry()\n          ->get_value( $self->{args}->{ldapAttributeContent} );\n    };\n\n    if ( !defined $session->{serialized} ) {\n        die \"Object does not exist in data store\";\n    }\n}\n\nsub remove {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    $self->ldap->delete( $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase} );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n}\n\nsub ldap {\n    my $self = shift;\n    return $self->{ldap} if ( $self->{ldap} );\n\n    # Parse servers configuration\n    my $useTls = 0;\n    my $tlsParam;\n    my @servers = ();\n    foreach my $server ( split /[\\s,]+/, $self->{args}->{ldapServer} ) {\n        if ( $server =~ m{^ldap\\+tls://([^/]+)/?\\??(.*)$} ) {\n            $useTls   = 1;\n            $server   = $1;\n            $tlsParam = $2 || \"\";\n        }\n        else {\n            $useTls = 0;\n        }\n        push @servers, $server;\n    }\n\n    # Connect\n    my $ldap = Net::LDAP->new(\n        \\@servers,\n        onerror => undef,\n        (\n            $self->{args}->{ldapPort}\n            ? ( port => $self->{args}->{ldapPort} )\n            : ()\n        ),\n    ) or die( 'Unable to connect to ' . join( ' ', @servers ) );\n\n    # Start TLS if needed\n    if ($useTls) {\n        my %h = split( /[&=]/, $tlsParam );\n        $h{cafile} = $self->{args}->{caFile} if ( $self->{args}->{caFile} );\n        $h{capath} = $self->{args}->{caPath} if ( $self->{args}->{caPath} );\n        my $start_tls = $ldap->start_tls(%h);\n        if ( $start_tls->code ) {\n            $self->logError($start_tls);\n            return;\n        }\n    }\n\n    # Bind with credentials\n    my $bind = $ldap->bind( $self->{args}->{ldapBindDN},\n        password => $self->{args}->{ldapBindPassword} );\n    if ( $bind->code ) {\n        $self->logError($bind);\n        return;\n    }\n\n    $self->{ldap} = $ldap;\n    return $ldap;\n}\n\nsub logError {\n    my $self           = shift;\n    my $ldap_operation = shift;\n    die \"LDAP error \" . $ldap_operation->code . \": \" . $ldap_operation->error;\n}\n\n1;\n\n=pod\n\n=head1 NAME\n\nApache::Session::Store::LDAP - Use LDAP to store persistent objects\n\n=head1 SYNOPSIS\n\n use Apache::Session::Store::LDAP;\n\n my $store = new Apache::Session::Store::LDAP;\n\n $store->insert($ref);\n $store->update($ref);\n $store->materialize($ref);\n $store->remove($ref);\n\n=head1 DESCRIPTION\n\nThis module fulfills the storage interface of Apache::Session.  The serialized\nobjects are stored in an LDAP directory file using the Net::LDAP Perl module.\n\n=head1 OPTIONS\n\nThis module requires one argument in the usual Apache::Session style. The\nkeys ldapServer, ldapBase, ldapBindDN, ldapBindPassword are required. The keys\nldapPort, ldapObjectClass, ldapAttributeId, ldapAttributeContent are optional. \nExample:\n\n tie %s, 'Apache::Session::LDAP', undef,\n    {\n        ldapServer           => 'localhost',\n        ldapBase             => 'dc=example,dc=com',\n        ldapBindDN           => 'cn=admin,dc=example,dc=com',\n        ldapBindPassword     => 'pass',\n        ldapObjectClass      => 'applicationProcess',\n        ldapAttributeId      => 'cn',\n        ldapAttributeContent => 'description',\n    };\n\n=head1 AUTHOR\n\nXavier Guimard, E<lt>guimard@E<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2009, 2012 by Xavier Guimard\nCopyright (C) 2014, 2015 by Clement Oudot\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\n=head1 SEE ALSO\n\nL<Apache::Session>\n\n=cut\n"], "fixing_code": ["package Apache::Session::LDAP;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = '0.4';\n@ISA     = qw(Apache::Session);\n\nuse Apache::Session;\nuse Apache::Session::Lock::Null;\nuse Apache::Session::Store::LDAP;\nuse Apache::Session::Generate::MD5;\nuse Apache::Session::Serialize::Base64;\n\nsub populate {\n    my $self = shift;\n\n    $self->{object_store} = new Apache::Session::Store::LDAP $self;\n    $self->{lock_manager} = new Apache::Session::Lock::Null $self;\n    $self->{generate}     = \\&Apache::Session::Generate::MD5::generate;\n    $self->{validate}     = \\&Apache::Session::Generate::MD5::validate;\n    $self->{serialize}    = \\&Apache::Session::Serialize::Base64::serialize;\n    $self->{unserialize}  = \\&Apache::Session::Serialize::Base64::unserialize;\n\n    return $self;\n}\n\n1;\n\n=pod\n\n=head1 NAME\n\nApache::Session::LDAP - An implementation of Apache::Session\n\n=head1 SYNOPSIS\n\n  use Apache::Session::LDAP;\n  tie %hash, 'Apache::Session::LDAP', $id, {\n    ldapServer           => 'ldap://localhost:389',\n    ldapConfBase         => 'dmdName=applications,dc=example,dc=com',\n    ldapBindDN           => 'cn=admin,dc=example,dc=com',\n    ldapBindPassword     => 'pass',\n    ldapObjectClass      => 'applicationProcess',\n    ldapAttributeId      => 'cn',\n    ldapAttributeContent => 'description',\n    ldapVerify           => 'require',\n    ldapCAFile           => '/etc/ssl/certs/ca-certificates.crt',\n  };\n\n=head1 DESCRIPTION\n\nThis module is an implementation of Apache::Session. It uses an LDAP directory\nto store datas.\n\n=head1 AUTHOR\n\nXavier Guimard, E<lt>x.guimard@free.frE<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2009, 2012 by Xavier Guimard\nCopyright (C) 2014, 2015 by Clement Oudot\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\n=head1 SEE ALSO\n\nL<Apache::Session>\n\n=cut\n", "package Apache::Session::Store::LDAP;\n\nuse strict;\nuse vars qw($VERSION);\nuse Net::LDAP;\n\n$VERSION = '0.4';\n\nsub new {\n    my $class = shift;\n    return bless {}, $class;\n}\n\nsub insert {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    my $msg = $self->ldap->add(\n        $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        attrs => [\n            objectClass => $self->{args}->{ldapObjectClass},\n            $self->{args}->{ldapAttributeId} => $session->{data}->{_session_id},\n            $self->{args}->{ldapAttributeContent} => $session->{serialized},\n        ],\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub update {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    my $msg = $self->ldap->modify(\n        $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        replace =>\n          { $self->{args}->{ldapAttributeContent} => $session->{serialized}, },\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub materialize {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    my $msg = $self->ldap->search(\n        base => $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        filter => '(objectClass=' . $self->{args}->{ldapObjectClass} . ')',\n        scope  => 'base',\n        attrs  => [ $self->{args}->{ldapAttributeContent} ],\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n\n    eval {\n        $session->{serialized} = $msg->shift_entry()\n          ->get_value( $self->{args}->{ldapAttributeContent} );\n    };\n\n    if ( !defined $session->{serialized} ) {\n        die \"Object does not exist in data store\";\n    }\n}\n\nsub remove {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n\n    $self->ldap->delete( $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase} );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n}\n\nsub ldap {\n    my $self = shift;\n    return $self->{ldap} if ( $self->{ldap} );\n\n    # Parse servers configuration\n    my $useTls = 0;\n    my $tlsParam;\n    my @servers = ();\n    foreach my $server ( split /[\\s,]+/, $self->{args}->{ldapServer} ) {\n        if ( $server =~ m{^ldap\\+tls://([^/]+)/?\\??(.*)$} ) {\n            $useTls   = 1;\n            $server   = $1;\n            $tlsParam = $2 || \"\";\n        }\n        else {\n            $useTls = 0;\n        }\n        push @servers, $server;\n    }\n\n    # Compatibility\n    my $caFile = $self->{args}->{ldapCAFile} || $self->{args}->{caFile};\n    my $caPath = $self->{args}->{ldapCAPath} || $self->{args}->{caPath};\n\n    # Connect\n    my $ldap = Net::LDAP->new(\n        \\@servers,\n        onerror => undef,\n        verify  => $self->{args}->{ldapVerify} || \"require\",\n        ( $caFile ? ( cafile => $caFile ) : () ),\n        ( $caPath ? ( capath => $caPath ) : () ),\n\n        (\n            $self->{args}->{ldapPort}\n            ? ( port => $self->{args}->{ldapPort} )\n            : ()\n        ),\n    ) or die( 'Unable to connect to ' . join( ' ', @servers ) . ': ' . $@ );\n\n    # Start TLS if needed\n\n    if ($useTls) {\n        my %h = split( /[&=]/, $tlsParam );\n        $h{verify} ||= ( $self->{args}->{ldapVerify} || \"require\" );\n        $h{cafile} ||= $caFile if ($caFile);\n        $h{capath} ||= $caPath if ($caPath);\n        my $start_tls = $ldap->start_tls(%h);\n        if ( $start_tls->code ) {\n            $self->logError($start_tls);\n            return;\n        }\n    }\n\n    # Bind with credentials\n    my $bind = $ldap->bind( $self->{args}->{ldapBindDN},\n        password => $self->{args}->{ldapBindPassword} );\n    if ( $bind->code ) {\n        $self->logError($bind);\n        return;\n    }\n\n    $self->{ldap} = $ldap;\n    return $ldap;\n}\n\nsub logError {\n    my $self           = shift;\n    my $ldap_operation = shift;\n    die \"LDAP error \" . $ldap_operation->code . \": \" . $ldap_operation->error;\n}\n\n1;\n\n=pod\n\n=head1 NAME\n\nApache::Session::Store::LDAP - Use LDAP to store persistent objects\n\n=head1 SYNOPSIS\n\n use Apache::Session::Store::LDAP;\n\n my $store = new Apache::Session::Store::LDAP;\n\n $store->insert($ref);\n $store->update($ref);\n $store->materialize($ref);\n $store->remove($ref);\n\n=head1 DESCRIPTION\n\nThis module fulfills the storage interface of Apache::Session.  The serialized\nobjects are stored in an LDAP directory file using the Net::LDAP Perl module.\n\n=head1 OPTIONS\n\nThis module requires one argument in the usual Apache::Session style. The\nkeys ldapServer, ldapBase, ldapBindDN, ldapBindPassword are required. The keys\nldapPort, ldapObjectClass, ldapAttributeId, ldapAttributeContent are optional. \nExample:\n\n tie %s, 'Apache::Session::LDAP', undef,\n    {\n        ldapServer           => 'localhost',\n        ldapBase             => 'dc=example,dc=com',\n        ldapBindDN           => 'cn=admin,dc=example,dc=com',\n        ldapBindPassword     => 'pass',\n        ldapObjectClass      => 'applicationProcess',\n        ldapAttributeId      => 'cn',\n        ldapAttributeContent => 'description',\n    };\n\n=head1 AUTHOR\n\nXavier Guimard, E<lt>guimard@E<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2009, 2012 by Xavier Guimard\nCopyright (C) 2014, 2015 by Clement Oudot\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\n=head1 SEE ALSO\n\nL<Apache::Session>\n\n=cut\n"], "filenames": ["lib/Apache/Session/LDAP.pm", "lib/Apache/Session/Store/LDAP.pm"], "buggy_code_start_loc": [46, 121], "buggy_code_end_loc": [46, 138], "fixing_code_start_loc": [47, 122], "fixing_code_end_loc": [49, 148], "type": "CWE-295", "message": "In Apache::Session::LDAP before 0.5, validity of the X.509 certificate is not checked by default when connecting to remote LDAP backends, because the default configuration of the Net::LDAPS module for Perl is used. NOTE: this can, for example, be fixed in conjunction with the CVE-2020-16093 fix.", "other": {"cve": {"id": "CVE-2020-36658", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-27T05:15:12.973", "lastModified": "2023-02-06T19:50:29.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Apache::Session::LDAP before 0.5, validity of the X.509 certificate is not checked by default when connecting to remote LDAP backends, because the default configuration of the Net::LDAPS module for Perl is used. NOTE: this can, for example, be fixed in conjunction with the CVE-2020-16093 fix."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lemonldap-ng:apache\\:\\:session\\:\\:ldap:*:*:*:*:*:perl:*:*", "versionEndExcluding": "0.5", "matchCriteriaId": "28611CB5-8D0C-4204-97AF-CF86FBDD1499"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/LemonLDAPNG/Apache-Session-LDAP/commit/490722b71eed1ed1ab33d58c78578f23e043561f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00024.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LemonLDAPNG/Apache-Session-LDAP/commit/490722b71eed1ed1ab33d58c78578f23e043561f"}}