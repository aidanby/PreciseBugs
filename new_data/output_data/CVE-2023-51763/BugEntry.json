{"buggy_code": ["# frozen_string_literal: true\nmodule ActiveAdmin\n  # CSVBuilder stores CSV configuration\n  #\n  # Usage example:\n  #\n  #   csv_builder = CSVBuilder.new\n  #   csv_builder.column :id\n  #   csv_builder.column(\"Name\") { |resource| resource.full_name }\n  #   csv_builder.column(:name, humanize_name: false)\n  #   csv_builder.column(\"name\", humanize_name: false) { |resource| resource.full_name }\n  #\n  #   csv_builder = CSVBuilder.new col_sep: \";\"\n  #   csv_builder = CSVBuilder.new humanize_name: false\n  #   csv_builder.column :id\n  #\n  #\n  class CSVBuilder\n\n    # Return a default CSVBuilder for a resource\n    # The CSVBuilder's columns would be Id followed by this\n    # resource's content columns\n    def self.default_for_resource(resource)\n      new resource: resource do\n        column :id\n        resource.content_columns.each { |c| column c }\n      end\n    end\n\n    attr_reader :columns, :options, :view_context\n\n    COLUMN_TRANSITIVE_OPTIONS = [:humanize_name].freeze\n\n    def initialize(options = {}, &block)\n      @resource = options.delete(:resource)\n      @columns = []\n      @options = ActiveAdmin.application.csv_options.merge options\n      @block = block\n    end\n\n    def column(name, options = {}, &block)\n      @columns << Column.new(name, @resource, column_transitive_options.merge(options), block)\n    end\n\n    def build(controller, csv)\n      columns = exec_columns controller.view_context\n      bom = options[:byte_order_mark]\n      column_names = options.delete(:column_names) { true }\n      csv_options = options.except :encoding_options, :humanize_name, :byte_order_mark\n\n      csv << bom if bom\n\n      if column_names\n        csv << CSV.generate_line(columns.map { |c| encode c.name, options }, **csv_options)\n      end\n\n      controller.send(:in_paginated_batches) do |resource|\n        csv << CSV.generate_line(build_row(resource, columns, options), **csv_options)\n      end\n\n      csv\n    end\n\n    def exec_columns(view_context = nil)\n      @view_context = view_context\n      @columns = [] # we want to re-render these every instance\n      instance_exec &@block if @block.present?\n      columns\n    end\n\n    def build_row(resource, columns, options)\n      columns.map do |column|\n        encode call_method_or_proc_on(resource, column.data), options\n      end\n    end\n\n    def encode(content, options)\n      if options[:encoding]\n        if options[:encoding_options]\n          content.to_s.encode options[:encoding], **options[:encoding_options]\n        else\n          content.to_s.encode options[:encoding]\n        end\n      else\n        content\n      end\n    end\n\n    def method_missing(method, *args, &block)\n      if @view_context.respond_to? method\n        @view_context.public_send method, *args, &block\n      else\n        super\n      end\n    end\n\n    class Column\n      attr_reader :name, :data, :options\n\n      DEFAULT_OPTIONS = { humanize_name: true }\n\n      def initialize(name, resource = nil, options = {}, block = nil)\n        @options = options.reverse_merge(DEFAULT_OPTIONS)\n        @name = humanize_name(name, resource, @options[:humanize_name])\n        @data = block || name.to_sym\n      end\n\n      def humanize_name(name, resource, humanize_name_option)\n        if humanize_name_option\n          name.is_a?(Symbol) && resource ? resource.resource_class.human_attribute_name(name) : name.to_s.humanize\n        else\n          name.to_s\n        end\n      end\n    end\n\n    private\n\n    def column_transitive_options\n      @column_transitive_options ||= @options.slice(*COLUMN_TRANSITIVE_OPTIONS)\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"rails_helper\"\n\nRSpec.describe ActiveAdmin::CSVBuilder do\n  describe \".default_for_resource using Post\" do\n    let(:application) { ActiveAdmin::Application.new }\n    let(:namespace) { ActiveAdmin::Namespace.new(application, :admin) }\n    let(:resource) { ActiveAdmin::Resource.new(namespace, Post, {}) }\n    let(:csv_builder) { ActiveAdmin::CSVBuilder.default_for_resource(resource).tap(&:exec_columns) }\n\n    it \"returns a default csv_builder for Post\" do\n      expect(csv_builder).to be_a(ActiveAdmin::CSVBuilder)\n    end\n\n    it \"defines Id as the first column\" do\n      expect(csv_builder.columns.first.name).to eq \"Id\"\n      expect(csv_builder.columns.first.data).to eq :id\n    end\n\n    it \"has Post's content_columns\" do\n      csv_builder.columns[1..-1].each_with_index do |column, index|\n        expect(column.name).to eq resource.content_columns[index].to_s.humanize\n        expect(column.data).to eq resource.content_columns[index]\n      end\n    end\n\n    context \"when column has a localized name\" do\n      let(:localized_name) { \"Titulo\" }\n\n      before do\n        allow(Post).to receive(:human_attribute_name).and_call_original\n        allow(Post).to receive(:human_attribute_name).with(:title) { localized_name }\n      end\n\n      it \"gets name from I18n\" do\n        title_index = resource.content_columns.index(:title) + 1 # First col is always id\n        expect(csv_builder.columns[title_index].name).to eq localized_name\n      end\n    end\n\n    context \"for models having sensitive attributes\" do\n      let(:resource) { ActiveAdmin::Resource.new(namespace, User, {}) }\n\n      it \"omits sensitive fields\" do\n        expect(csv_builder.columns.map(&:data)).to_not include :encrypted_password\n      end\n    end\n  end\n\n  context \"when empty\" do\n    let(:builder) { ActiveAdmin::CSVBuilder.new.tap(&:exec_columns) }\n\n    it \"should have no columns\" do\n      expect(builder.columns).to eq []\n    end\n  end\n\n  context \"with a symbol column (:title)\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column :title\n      end.tap(&:exec_columns)\n    end\n\n    it \"should have one column\" do\n      expect(builder.columns.size).to eq 1\n    end\n\n    describe \"the column\" do\n      let(:column) { builder.columns.first }\n\n      it \"should have a name of 'Title'\" do\n        expect(column.name).to eq \"Title\"\n      end\n\n      it \"should have the data :title\" do\n        expect(column.data).to eq :title\n      end\n    end\n  end\n\n  context \"with a block and title\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column \"My title\" do\n          # nothing\n        end\n      end.tap(&:exec_columns)\n    end\n\n    it \"should have one column\" do\n      expect(builder.columns.size).to eq 1\n    end\n\n    describe \"the column\" do\n      let(:column) { builder.columns.first }\n\n      it \"should have a name of 'My title'\" do\n        expect(column.name).to eq \"My title\"\n      end\n\n      it \"should have the data :title\" do\n        expect(column.data).to be_an_instance_of(Proc)\n      end\n    end\n  end\n\n  context \"with a humanize_name column option\" do\n    context \"with symbol column name\" do\n      let(:builder) do\n        ActiveAdmin::CSVBuilder.new do\n          column :my_title, humanize_name: false\n        end.tap(&:exec_columns)\n      end\n\n      describe \"the column\" do\n        let(:column) { builder.columns.first }\n\n        it \"should have a name of 'my_title'\" do\n          expect(column.name).to eq \"my_title\"\n        end\n      end\n    end\n\n    context \"with string column name\" do\n      let(:builder) do\n        ActiveAdmin::CSVBuilder.new do\n          column \"my_title\", humanize_name: false\n        end.tap(&:exec_columns)\n      end\n\n      describe \"the column\" do\n        let(:column) { builder.columns.first }\n\n        it \"should have a name of 'my_title'\" do\n          expect(column.name).to eq \"my_title\"\n        end\n      end\n    end\n  end\n\n  context \"with a separator\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(col_sep: \";\").tap(&:exec_columns)\n    end\n\n    it \"should have proper separator\" do\n      expect(builder.options).to include(col_sep: \";\")\n    end\n  end\n\n  context \"with humanize_name option\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(humanize_name: false) do\n        column :my_title\n      end.tap(&:exec_columns)\n    end\n\n    describe \"the column\" do\n      let(:column) { builder.columns.first }\n\n      it \"should have humanize_name option set\" do\n        expect(column.options).to eq humanize_name: false\n      end\n\n      it \"should have a name of 'my_title'\" do\n        expect(column.name).to eq \"my_title\"\n      end\n    end\n  end\n\n  context \"with csv_options\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(force_quotes: true).tap(&:exec_columns)\n    end\n\n    it \"should have proper separator\" do\n      expect(builder.options).to include(force_quotes: true)\n    end\n  end\n\n  context \"with access to the controller\" do\n    let(:dummy_view_context) { double(controller: dummy_controller) }\n    let(:dummy_controller) { double(names: %w(title summary updated_at created_at)) }\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column \"id\"\n        controller.names.each do |name|\n          column(name)\n        end\n      end.tap { |b| b.exec_columns(dummy_view_context) }\n    end\n\n    it \"should build columns provided by the controller\" do\n      expect(builder.columns.map(&:data)).to match_array([:id, :title, :summary, :updated_at, :created_at])\n    end\n  end\n\n  context \"build csv using the supplied order\" do\n    before do\n      @post1 = Post.create!(title: \"Hello1\", published_date: Date.today - 2.day)\n      @post2 = Post.create!(title: \"Hello2\", published_date: Date.today - 1.day)\n    end\n    let(:dummy_controller) do\n      class DummyController\n        def in_paginated_batches(&block)\n          Post.order(\"published_date DESC\").each(&block)\n        end\n\n        def apply_decorator(resource)\n          resource\n        end\n\n        def view_context\n        end\n      end\n      DummyController.new\n    end\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column \"id\"\n        column \"title\"\n        column \"published_date\"\n      end\n    end\n\n    it \"should generate data with the supplied order\" do\n      expect(builder).to receive(:build_row).and_return([]).once.ordered { |post| expect(post.id).to eq @post2.id }\n      expect(builder).to receive(:build_row).and_return([]).once.ordered { |post| expect(post.id).to eq @post1.id }\n      builder.build dummy_controller, []\n    end\n  end\n\n  context \"build csv using specified encoding and encoding_options\" do\n    let(:dummy_controller) do\n      class DummyController\n        def in_paginated_batches(&block)\n          Post.all.each(&block)\n        end\n\n        def view_context\n        end\n      end\n      DummyController.new\n    end\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(encoding: encoding, encoding_options: opts) do\n        column \"\u304a\u306f\u3088\u3046\u3054\u3056\u3044\u307e\u3059\"\n        column \"title\"\n      end\n    end\n\n    context \"Shift-JIS with options\" do\n      let(:encoding) { Encoding::Shift_JIS }\n      let(:opts) { { invalid: :replace, undef: :replace, replace: \"?\" } }\n\n      it \"encodes the CSV\" do\n        receiver = []\n        builder.build dummy_controller, receiver\n        line = receiver.last\n        expect(line.encoding).to eq(encoding)\n      end\n    end\n\n    context \"ASCII with options\" do\n      let(:encoding) { Encoding::ASCII }\n      let(:opts) do\n        { invalid: :replace, undef: :replace, replace: \"__REPLACED__\" }\n      end\n\n      it \"encodes the CSV without errors\" do\n        receiver = []\n        builder.build dummy_controller, receiver\n        line = receiver.last\n        expect(line.encoding).to eq(encoding)\n        expect(line).to include(\"__REPLACED__\")\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\nmodule ActiveAdmin\n  # CSVBuilder stores CSV configuration\n  #\n  # Usage example:\n  #\n  #   csv_builder = CSVBuilder.new\n  #   csv_builder.column :id\n  #   csv_builder.column(\"Name\") { |resource| resource.full_name }\n  #   csv_builder.column(:name, humanize_name: false)\n  #   csv_builder.column(\"name\", humanize_name: false) { |resource| resource.full_name }\n  #\n  #   csv_builder = CSVBuilder.new col_sep: \";\"\n  #   csv_builder = CSVBuilder.new humanize_name: false\n  #   csv_builder.column :id\n  #\n  #\n  class CSVBuilder\n\n    # Return a default CSVBuilder for a resource\n    # The CSVBuilder's columns would be Id followed by this\n    # resource's content columns\n    def self.default_for_resource(resource)\n      new resource: resource do\n        column :id\n        resource.content_columns.each { |c| column c }\n      end\n    end\n\n    attr_reader :columns, :options, :view_context\n\n    COLUMN_TRANSITIVE_OPTIONS = [:humanize_name].freeze\n\n    def initialize(options = {}, &block)\n      @resource = options.delete(:resource)\n      @columns = []\n      @options = ActiveAdmin.application.csv_options.merge options\n      @block = block\n    end\n\n    def column(name, options = {}, &block)\n      @columns << Column.new(name, @resource, column_transitive_options.merge(options), block)\n    end\n\n    def build(controller, csv)\n      columns = exec_columns controller.view_context\n      bom = options[:byte_order_mark]\n      column_names = options.delete(:column_names) { true }\n      csv_options = options.except :encoding_options, :humanize_name, :byte_order_mark\n\n      csv << bom if bom\n\n      if column_names\n        csv << CSV.generate_line(columns.map { |c| sanitize(encode(c.name, options)) }, **csv_options)\n      end\n\n      controller.send(:in_paginated_batches) do |resource|\n        csv << CSV.generate_line(build_row(resource, columns, options), **csv_options)\n      end\n\n      csv\n    end\n\n    def exec_columns(view_context = nil)\n      @view_context = view_context\n      @columns = [] # we want to re-render these every instance\n      instance_exec &@block if @block.present?\n      columns\n    end\n\n    def build_row(resource, columns, options)\n      columns.map do |column|\n        sanitize(encode(call_method_or_proc_on(resource, column.data), options))\n      end\n    end\n\n    def encode(content, options)\n      if options[:encoding]\n        if options[:encoding_options]\n          content.to_s.encode options[:encoding], **options[:encoding_options]\n        else\n          content.to_s.encode options[:encoding]\n        end\n      else\n        content\n      end\n    end\n\n    def sanitize(content)\n      Sanitizer.sanitize(content)\n    end\n\n    def method_missing(method, *args, &block)\n      if @view_context.respond_to? method\n        @view_context.public_send method, *args, &block\n      else\n        super\n      end\n    end\n\n    class Column\n      attr_reader :name, :data, :options\n\n      DEFAULT_OPTIONS = { humanize_name: true }\n\n      def initialize(name, resource = nil, options = {}, block = nil)\n        @options = options.reverse_merge(DEFAULT_OPTIONS)\n        @name = humanize_name(name, resource, @options[:humanize_name])\n        @data = block || name.to_sym\n      end\n\n      def humanize_name(name, resource, humanize_name_option)\n        if humanize_name_option\n          name.is_a?(Symbol) && resource ? resource.resource_class.human_attribute_name(name) : name.to_s.humanize\n        else\n          name.to_s\n        end\n      end\n    end\n\n    private\n\n    def column_transitive_options\n      @column_transitive_options ||= @options.slice(*COLUMN_TRANSITIVE_OPTIONS)\n    end\n  end\n\n  # Prevents CSV Injection according to https://owasp.org/www-community/attacks/CSV_Injection\n  module Sanitizer\n    extend self\n\n    ATTACK_CHARACTERS = ['=', '+', '-', '@', \"\\t\", \"\\r\"].freeze\n\n    def sanitize(value)\n      return \"'#{value}\" if require_sanitization?(value)\n\n      value\n    end\n\n    def require_sanitization?(value)\n      value.is_a?(String) && value.starts_with?(*ATTACK_CHARACTERS)\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"rails_helper\"\n\nRSpec.describe ActiveAdmin::CSVBuilder do\n  describe \".default_for_resource using Post\" do\n    let(:application) { ActiveAdmin::Application.new }\n    let(:namespace) { ActiveAdmin::Namespace.new(application, :admin) }\n    let(:resource) { ActiveAdmin::Resource.new(namespace, Post, {}) }\n    let(:csv_builder) { ActiveAdmin::CSVBuilder.default_for_resource(resource).tap(&:exec_columns) }\n\n    it \"returns a default csv_builder for Post\" do\n      expect(csv_builder).to be_a(ActiveAdmin::CSVBuilder)\n    end\n\n    it \"defines Id as the first column\" do\n      expect(csv_builder.columns.first.name).to eq \"Id\"\n      expect(csv_builder.columns.first.data).to eq :id\n    end\n\n    it \"has Post's content_columns\" do\n      csv_builder.columns[1..-1].each_with_index do |column, index|\n        expect(column.name).to eq resource.content_columns[index].to_s.humanize\n        expect(column.data).to eq resource.content_columns[index]\n      end\n    end\n\n    context \"when column has a localized name\" do\n      let(:localized_name) { \"Titulo\" }\n\n      before do\n        allow(Post).to receive(:human_attribute_name).and_call_original\n        allow(Post).to receive(:human_attribute_name).with(:title) { localized_name }\n      end\n\n      it \"gets name from I18n\" do\n        title_index = resource.content_columns.index(:title) + 1 # First col is always id\n        expect(csv_builder.columns[title_index].name).to eq localized_name\n      end\n    end\n\n    context \"for models having sensitive attributes\" do\n      let(:resource) { ActiveAdmin::Resource.new(namespace, User, {}) }\n\n      it \"omits sensitive fields\" do\n        expect(csv_builder.columns.map(&:data)).to_not include :encrypted_password\n      end\n    end\n  end\n\n  context \"when empty\" do\n    let(:builder) { ActiveAdmin::CSVBuilder.new.tap(&:exec_columns) }\n\n    it \"should have no columns\" do\n      expect(builder.columns).to eq []\n    end\n  end\n\n  context \"with a symbol column (:title)\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column :title\n      end.tap(&:exec_columns)\n    end\n\n    it \"should have one column\" do\n      expect(builder.columns.size).to eq 1\n    end\n\n    describe \"the column\" do\n      let(:column) { builder.columns.first }\n\n      it \"should have a name of 'Title'\" do\n        expect(column.name).to eq \"Title\"\n      end\n\n      it \"should have the data :title\" do\n        expect(column.data).to eq :title\n      end\n    end\n  end\n\n  context \"with a block and title\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column \"My title\" do\n          # nothing\n        end\n      end.tap(&:exec_columns)\n    end\n\n    it \"should have one column\" do\n      expect(builder.columns.size).to eq 1\n    end\n\n    describe \"the column\" do\n      let(:column) { builder.columns.first }\n\n      it \"should have a name of 'My title'\" do\n        expect(column.name).to eq \"My title\"\n      end\n\n      it \"should have the data :title\" do\n        expect(column.data).to be_an_instance_of(Proc)\n      end\n    end\n  end\n\n  context \"with a humanize_name column option\" do\n    context \"with symbol column name\" do\n      let(:builder) do\n        ActiveAdmin::CSVBuilder.new do\n          column :my_title, humanize_name: false\n        end.tap(&:exec_columns)\n      end\n\n      describe \"the column\" do\n        let(:column) { builder.columns.first }\n\n        it \"should have a name of 'my_title'\" do\n          expect(column.name).to eq \"my_title\"\n        end\n      end\n    end\n\n    context \"with string column name\" do\n      let(:builder) do\n        ActiveAdmin::CSVBuilder.new do\n          column \"my_title\", humanize_name: false\n        end.tap(&:exec_columns)\n      end\n\n      describe \"the column\" do\n        let(:column) { builder.columns.first }\n\n        it \"should have a name of 'my_title'\" do\n          expect(column.name).to eq \"my_title\"\n        end\n      end\n    end\n  end\n\n  context \"with a separator\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(col_sep: \";\").tap(&:exec_columns)\n    end\n\n    it \"should have proper separator\" do\n      expect(builder.options).to include(col_sep: \";\")\n    end\n  end\n\n  context \"with humanize_name option\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(humanize_name: false) do\n        column :my_title\n      end.tap(&:exec_columns)\n    end\n\n    describe \"the column\" do\n      let(:column) { builder.columns.first }\n\n      it \"should have humanize_name option set\" do\n        expect(column.options).to eq humanize_name: false\n      end\n\n      it \"should have a name of 'my_title'\" do\n        expect(column.name).to eq \"my_title\"\n      end\n    end\n  end\n\n  context \"with csv_options\" do\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(force_quotes: true).tap(&:exec_columns)\n    end\n\n    it \"should have proper separator\" do\n      expect(builder.options).to include(force_quotes: true)\n    end\n  end\n\n  context \"with access to the controller\" do\n    let(:dummy_view_context) { double(controller: dummy_controller) }\n    let(:dummy_controller) { double(names: %w(title summary updated_at created_at)) }\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column \"id\"\n        controller.names.each do |name|\n          column(name)\n        end\n      end.tap { |b| b.exec_columns(dummy_view_context) }\n    end\n\n    it \"should build columns provided by the controller\" do\n      expect(builder.columns.map(&:data)).to match_array([:id, :title, :summary, :updated_at, :created_at])\n    end\n  end\n\n  context \"build csv using the supplied order\" do\n    before do\n      @post1 = Post.create!(title: \"Hello1\", published_date: Date.today - 2.day)\n      @post2 = Post.create!(title: \"Hello2\", published_date: Date.today - 1.day)\n    end\n    let(:dummy_controller) do\n      class DummyController\n        def in_paginated_batches(&block)\n          Post.order(\"published_date DESC\").each(&block)\n        end\n\n        def apply_decorator(resource)\n          resource\n        end\n\n        def view_context\n        end\n      end\n      DummyController.new\n    end\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column \"id\"\n        column \"title\"\n        column \"published_date\"\n      end\n    end\n\n    it \"should generate data with the supplied order\" do\n      expect(builder).to receive(:build_row).and_return([]).once.ordered { |post| expect(post.id).to eq @post2.id }\n      expect(builder).to receive(:build_row).and_return([]).once.ordered { |post| expect(post.id).to eq @post1.id }\n      builder.build dummy_controller, []\n    end\n  end\n\n  context \"build csv using specified encoding and encoding_options\" do\n    let(:dummy_controller) do\n      class DummyController\n        def in_paginated_batches(&block)\n          Post.all.each(&block)\n        end\n\n        def view_context\n        end\n      end\n      DummyController.new\n    end\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new(encoding: encoding, encoding_options: opts) do\n        column \"\u304a\u306f\u3088\u3046\u3054\u3056\u3044\u307e\u3059\"\n        column \"title\"\n      end\n    end\n\n    context \"Shift-JIS with options\" do\n      let(:encoding) { Encoding::Shift_JIS }\n      let(:opts) { { invalid: :replace, undef: :replace, replace: \"?\" } }\n\n      it \"encodes the CSV\" do\n        receiver = []\n        builder.build dummy_controller, receiver\n        line = receiver.last\n        expect(line.encoding).to eq(encoding)\n      end\n    end\n\n    context \"ASCII with options\" do\n      let(:encoding) { Encoding::ASCII }\n      let(:opts) do\n        { invalid: :replace, undef: :replace, replace: \"__REPLACED__\" }\n      end\n\n      it \"encodes the CSV without errors\" do\n        receiver = []\n        builder.build dummy_controller, receiver\n        line = receiver.last\n        expect(line.encoding).to eq(encoding)\n        expect(line).to include(\"__REPLACED__\")\n      end\n    end\n  end\n\n  context 'csv injection' do\n    let(:dummy_controller) do\n      class DummyController\n        def in_paginated_batches(&block)\n          Post.all.each(&block)\n        end\n\n        def view_context\n          MethodOrProcHelper\n        end\n      end\n      DummyController.new\n    end\n\n    let(:builder) do\n      ActiveAdmin::CSVBuilder.new do\n        column(:id)\n        column(:title)\n      end\n    end\n\n    ['=', '+', '-', '@', \"\\t\", \"\\r\"].each do |char|\n      it \"prepends a single quote when column starts with a #{char} character\" do\n        attack = \"#{char}1+2\"\n\n        escaped_attack = \"'#{attack}\"\n        escaped_attack = \"\\\"#{escaped_attack}\\\"\" if char == \"\\r\"\n\n        post = Post.create!(title: attack)\n        receiver = []\n        builder.build dummy_controller, receiver\n        line = receiver.last\n        expect(line).to eq \"#{post.id},#{escaped_attack}\\n\"\n      end\n\n      it \"accounts for the field separator when character #{char} is used to inject a formula\" do\n        attack = \"#{char}1+2'\\\" ;,#{char}1+2\"\n        escaped_attack = \"\\\"'#{attack.gsub('\"', '\"\"')}\\\"\"\n\n        post = Post.create!(title: attack)\n        receiver = []\n        builder.build dummy_controller, receiver\n        line = receiver.last\n        expect(line).to eq \"#{post.id},#{escaped_attack}\\n\"\n      end\n    end\n  end\nend\n"], "filenames": ["lib/active_admin/csv_builder.rb", "spec/unit/csv_builder_spec.rb"], "buggy_code_start_loc": [54, 279], "buggy_code_end_loc": [122, 279], "fixing_code_start_loc": [54, 280], "fixing_code_end_loc": [144, 328], "type": "CWE-1236", "message": "csv_builder.rb in ActiveAdmin (aka Active Admin) before 3.2.0 allows CSV injection.", "other": {"cve": {"id": "CVE-2023-51763", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-24T04:15:07.633", "lastModified": "2024-01-03T20:54:40.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "csv_builder.rb in ActiveAdmin (aka Active Admin) before 3.2.0 allows CSV injection."}, {"lang": "es", "value": "csv_builder.rb en ActiveAdmin (tambi\u00e9n conocido como Active Admin) anterior a 3.2.0 permite la inyecci\u00f3n de CSV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1236"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:activeadmin:active_admin:*:*:*:*:*:ruby_on_rails:*:*", "versionEndExcluding": "3.2.0", "matchCriteriaId": "853F2CE2-FAAA-4FAE-A24B-7551874574D1"}]}]}], "references": [{"url": "https://github.com/activeadmin/activeadmin/commit/697be2b183491beadc8f0b7d8b5bfb44f2387909", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/activeadmin/activeadmin/pull/8161", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/activeadmin/activeadmin/releases/tag/v3.2.0", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/activeadmin/activeadmin/commit/697be2b183491beadc8f0b7d8b5bfb44f2387909"}}