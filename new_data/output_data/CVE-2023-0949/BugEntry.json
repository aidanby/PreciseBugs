{"buggy_code": ["/**\n * Return an instance of Listing.\n *\n * @constructor\n * @param {Object} options - instance options\n */\nvar Listing = function(options) {\n    this.initialize(options);\n};\n\nListing.prototype = {\n    constructor: Listing,\n\n    listing_defaults: {\n        sortable_selector: '.sortable',\n        with_searchform: true,\n        load_page_url: null,\n        navigation_params: [\"sort_order\", \"searchquery\"],\n        scroll_container: null,\n        main_table_id: \"objects_table\",\n        eor_message: gettext(\"No more entry to show\")\n    },\n\n    initialize: function(options) {\n        this.options = $.extend({}, this.listing_defaults, options);\n        this.tag_handlers = {};\n        this.navobj = new History(this.options);\n        $(document).on(\"click\", \"a.filter\", $.proxy(this.filter_by_tag, this));\n        if (this.options.with_searchform) {\n            this.init_searchform();\n        }\n    },\n\n    /**\n     * Initialize the search form.\n     */\n    init_searchform: function() {\n        $(\"#searchquery\").focus(function() {\n            $(this).val(\"\");\n        }).blur($.proxy(function(e) {\n            var $this = $(e.target);\n            if ($this.val() === \"\") {\n                if (this.navobj.getparam(\"searchquery\")) {\n                    $this.val(this.navobj.getparam(\"searchquery\"));\n                } else {\n                    $this.val(gettext(\"Search\"));\n                }\n            }\n        }, this));\n        if (this.navobj.getparam(\"searchquery\") !== undefined) {\n            $(\"#searchquery\").val(this.navobj.getparam(\"searchquery\"));\n        }\n        $(\"#searchform\").submit($.proxy(this.do_search, this));\n    },\n\n    /**\n     * Apply the current search pattern.\n     */\n    do_search: function(e) {\n        e.preventDefault();\n        var squery = $(\"#searchquery\").val();\n        if (squery !== \"\") {\n            this.navobj.setparam(\"searchquery\", squery);\n        } else {\n            this.navobj.delparam(\"searchquery\");\n        }\n        this.navobj.update();\n    },\n\n\n    load_page: function(e) {\n        var $link = get_target(e, \"a\");\n        e.preventDefault();\n        this.navobj.updateparams($link.attr(\"href\")).update();\n    },\n\n    /**\n     * Return extra arguments used to fetch a page.\n     *\n     * @this Listing\n     */\n    get_load_page_args: function() {\n        var $this = this;\n        var args = {};\n\n        $.each(this.options.navigation_params, function(pos, param) {\n            if ($this.navobj.hasparam(param)) {\n                args[param] = $this.navobj.getparam(param);\n            }\n        });\n        return args;\n    },\n\n    /**\n     * Calculate the bottom position of the scroll container.\n     *\n     * @param {Object} $element - scroll container object\n     */\n    calculate_bottom: function($element) {\n        var $last_row = $(\"#\" + this.options.main_table_id)\n            .find(\"tr\").last();\n        return $last_row.offset().top - $element.height();\n    },\n\n    /**\n     * A new page has been received, inject it.\n     *\n     * @param {Object} data - page content\n     * @param {string} direction - scroll direction (up or down)\n     */\n    add_new_page: function(data, direction) {\n        var $container = $(\"#{0} tbody\".format(this.options.main_table_id));\n\n        if (direction == \"down\") {\n            $container.html(function(pos, oldhtml) {\n                return oldhtml + data.rows;\n            });\n        } else {\n            $container.html(function(pos, oldhtml) {\n                return data.rows + oldhtml;\n            });\n        }\n    },\n\n    /**\n     * Callback called when no more page can be loaded.\n     *\n     * @this Listing\n     */\n    end_of_list_reached: function(element) {\n        $(\"#\" + this.options.main_table_id).after(\n            $(\"<div id='eor_message' class='alert alert-info text-center'>{0}</div>\".format(\n                this.options.eor_message\n            ))\n        );\n    },\n\n    /**\n     * Update the listing with the received data.\n     *\n     * @this Listing\n     * @param {Object} data - new content\n     */\n    update_listing: function(data, with_infinite_scroll) {\n        var $this = this;\n        var $scroll_container = (this.options.scroll_container) ?\n            $(this.options.scroll_container) : $(window);\n\n        $scroll_container.scrollTop(0);\n        if (with_infinite_scroll || with_infinite_scroll === undefined) {\n            if ($scroll_container.data(\"infinite-scroll\") !== undefined) {\n                $scroll_container.infinite_scroll(\"reset_loaded_pages\", data.pages);\n                $scroll_container.infinite_scroll(\"resume\");\n                $(\"#eor_message\").remove();\n            } else {\n                $scroll_container.infinite_scroll({\n                    initial_pages: data.pages,\n                    url: this.options.load_page_url,\n                    get_args: $.proxy(this.get_load_page_args, this),\n                    calculate_bottom: $.proxy(this.calculate_bottom, this),\n                    process_results: $.proxy(this.add_new_page, this),\n                    end_of_list_reached: $.proxy(this.end_of_list_reached, this)\n                });\n            }\n        } else if ($scroll_container.data(\"infinite-scroll\") !== undefined) {\n            $scroll_container.infinite_scroll(\"pause\");\n        }\n\n        var $sortables = $(this.options.sortable_selector);\n        if ($sortables.length) {\n            $(this.options.sortable_selector).sortable({\n                onSortOrderChange: $.proxy(this.change_sort_order, this)\n            });\n            this.set_sort_order();\n        }\n    },\n\n    /**\n     * Set current sort order.\n     *\n     * @this Listing\n     */\n    set_sort_order: function() {\n        var sort_order = this.navobj.getparam(\"sort_order\");\n        var sort_dir;\n\n        if (!sort_order) {\n            return;\n        }\n        if (sort_order[0] == '-') {\n            sort_dir = \"desc\";\n            sort_order = sort_order.substr(1);\n        } else {\n            sort_dir = 'asc';\n        }\n        $(\"th[data-sort_order=\" + sort_order + \"]\").sortable('select', sort_dir);\n    },\n\n    /**\n     * Change current sort order.\n     *\n     * @this Listing\n     */\n    change_sort_order: function(sort_order, dir) {\n        if (dir == \"desc\") {\n            sort_order = \"-\" + sort_order;\n        }\n        this.navobj.setparam(\"sort_order\", sort_order).update();\n    },\n\n    /**\n     * Register a new tag handler.\n     *\n     * @this Listing\n     * @param {string} name - name of the tag\n     * @param {function} handler - reference to a function (optional)\n     */\n    register_tag_handler: function(name, handler) {\n        if (handler === undefined) {\n            handler = this.generic_tag_handler;\n        }\n        this.tag_handlers[name] = handler;\n        if (this.navobj.getparam(name + \"filter\") !== undefined) {\n            var text = this.navobj.getparam(name + \"filter\");\n            $(\"#taglist\").append(this.make_tag(text, name));\n        }\n    },\n\n    /**\n     * Default tag handler.\n     *\n     * @this Listing\n     * @param {string} tag - name of the tag\n     * @param {Object} $link - tag that was clicked\n     * @return {boolean} - return true if handler has been executed\n     */\n    generic_tag_handler: function(tag, $link) {\n        if (this.navobj.getparam(tag + \"filter\") === undefined && $link.hasClass(tag)) {\n            var text = $link.attr(\"name\");\n            this.navobj.setparam(tag + \"filter\", text).update();\n            $(\"#taglist\").append(this.make_tag(text, tag));\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Build a button to remove a specific filter.\n     *\n     * @this Listing\n     * @param {string} text - text of the button\n     * @param {string} type - tag type\n     * @return {Object} - new button object\n     */\n    make_tag: function(text, type) {\n        var $tag = $(\"<a />\", {\n            \"name\": type, \"class\" : \"btn btn-default btn-xs\",\n            \"html\": \" \" + text\n        });\n        \n        $(\"<span />\", {\"class\" : \"fa fa-remove\"}).prependTo($tag);\n        $tag.click($.proxy(this.remove_tag, this));\n        return $tag;\n    },\n\n    /**\n     * Click event : remove a tag button.\n     *\n     * @this Listing\n     * @param {Object} e - event object\n     */\n    remove_tag: function(e) {\n        var $tag = $(e.target);\n\n        if ($tag.is(\"i\")) {\n            $tag = $tag.parent();\n        }\n        e.preventDefault();\n        this.navobj.delparam($tag.attr(\"name\") + \"filter\").update();\n        $tag.remove();\n    },\n\n    /**\n     * Click event: filter the listing when a tag is clicked.\n     *\n     * @this Listing\n     * @param {Object} e - event object\n     */\n    filter_by_tag: function(e) {\n        var $link = $(e.target);\n        e.preventDefault();\n\n        for (var name in this.tag_handlers) {\n            if (this.tag_handlers[name].apply(this, [name, $link])) {\n                break;\n            }\n        }\n    }\n};\n"], "fixing_code": ["/**\n * Return an instance of Listing.\n *\n * @constructor\n * @param {Object} options - instance options\n */\nvar Listing = function(options) {\n    this.initialize(options);\n};\n\nListing.prototype = {\n    constructor: Listing,\n\n    listing_defaults: {\n        sortable_selector: '.sortable',\n        with_searchform: true,\n        load_page_url: null,\n        navigation_params: [\"sort_order\", \"searchquery\"],\n        scroll_container: null,\n        main_table_id: \"objects_table\",\n        eor_message: gettext(\"No more entry to show\")\n    },\n\n    initialize: function(options) {\n        this.options = $.extend({}, this.listing_defaults, options);\n        this.tag_handlers = {};\n        this.navobj = new History(this.options);\n        $(document).on(\"click\", \"a.filter\", $.proxy(this.filter_by_tag, this));\n        if (this.options.with_searchform) {\n            this.init_searchform();\n        }\n    },\n\n    /**\n     * Initialize the search form.\n     */\n    init_searchform: function() {\n        $(\"#searchquery\").focus(function() {\n            $(this).val(\"\");\n        }).blur($.proxy(function(e) {\n            var $this = $(e.target);\n            if ($this.val() === \"\") {\n                if (this.navobj.getparam(\"searchquery\")) {\n                    $this.val(this.navobj.getparam(\"searchquery\"));\n                } else {\n                    $this.val(gettext(\"Search\"));\n                }\n            }\n        }, this));\n        if (this.navobj.getparam(\"searchquery\") !== undefined) {\n            $(\"#searchquery\").val(this.navobj.getparam(\"searchquery\"));\n        }\n        $(\"#searchform\").submit($.proxy(this.do_search, this));\n    },\n\n    /**\n     * Apply the current search pattern.\n     */\n    do_search: function(e) {\n        e.preventDefault();\n        var squery = $(\"#searchquery\").val();\n        if (squery !== \"\") {\n            this.navobj.setparam(\"searchquery\", squery);\n        } else {\n            this.navobj.delparam(\"searchquery\");\n        }\n        this.navobj.update();\n    },\n\n\n    load_page: function(e) {\n        var $link = get_target(e, \"a\");\n        e.preventDefault();\n        this.navobj.updateparams($link.attr(\"href\")).update();\n    },\n\n    /**\n     * Return extra arguments used to fetch a page.\n     *\n     * @this Listing\n     */\n    get_load_page_args: function() {\n        var $this = this;\n        var args = {};\n\n        $.each(this.options.navigation_params, function(pos, param) {\n            if ($this.navobj.hasparam(param)) {\n                args[param] = $this.navobj.getparam(param);\n            }\n        });\n        return args;\n    },\n\n    /**\n     * Calculate the bottom position of the scroll container.\n     *\n     * @param {Object} $element - scroll container object\n     */\n    calculate_bottom: function($element) {\n        var $last_row = $(\"#\" + this.options.main_table_id)\n            .find(\"tr\").last();\n        return $last_row.offset().top - $element.height();\n    },\n\n    /**\n     * A new page has been received, inject it.\n     *\n     * @param {Object} data - page content\n     * @param {string} direction - scroll direction (up or down)\n     */\n    add_new_page: function(data, direction) {\n        var $container = $(\"#{0} tbody\".format(this.options.main_table_id));\n\n        if (direction == \"down\") {\n            $container.html(function(pos, oldhtml) {\n                return oldhtml + data.rows;\n            });\n        } else {\n            $container.html(function(pos, oldhtml) {\n                return data.rows + oldhtml;\n            });\n        }\n    },\n\n    /**\n     * Callback called when no more page can be loaded.\n     *\n     * @this Listing\n     */\n    end_of_list_reached: function(element) {\n        $(\"#\" + this.options.main_table_id).after(\n            $(\"<div id='eor_message' class='alert alert-info text-center'>{0}</div>\".format(\n                this.options.eor_message\n            ))\n        );\n    },\n\n    /**\n     * Update the listing with the received data.\n     *\n     * @this Listing\n     * @param {Object} data - new content\n     */\n    update_listing: function(data, with_infinite_scroll) {\n        var $this = this;\n        var $scroll_container = (this.options.scroll_container) ?\n            $(this.options.scroll_container) : $(window);\n\n        $scroll_container.scrollTop(0);\n        if (with_infinite_scroll || with_infinite_scroll === undefined) {\n            if ($scroll_container.data(\"infinite-scroll\") !== undefined) {\n                $scroll_container.infinite_scroll(\"reset_loaded_pages\", data.pages);\n                $scroll_container.infinite_scroll(\"resume\");\n                $(\"#eor_message\").remove();\n            } else {\n                $scroll_container.infinite_scroll({\n                    initial_pages: data.pages,\n                    url: this.options.load_page_url,\n                    get_args: $.proxy(this.get_load_page_args, this),\n                    calculate_bottom: $.proxy(this.calculate_bottom, this),\n                    process_results: $.proxy(this.add_new_page, this),\n                    end_of_list_reached: $.proxy(this.end_of_list_reached, this)\n                });\n            }\n        } else if ($scroll_container.data(\"infinite-scroll\") !== undefined) {\n            $scroll_container.infinite_scroll(\"pause\");\n        }\n\n        var $sortables = $(this.options.sortable_selector);\n        if ($sortables.length) {\n            $(this.options.sortable_selector).sortable({\n                onSortOrderChange: $.proxy(this.change_sort_order, this)\n            });\n            this.set_sort_order();\n        }\n    },\n\n    /**\n     * Set current sort order.\n     *\n     * @this Listing\n     */\n    set_sort_order: function() {\n        var sort_order = this.navobj.getparam(\"sort_order\");\n        var sort_dir;\n\n        if (!sort_order) {\n            return;\n        }\n        if (sort_order[0] == '-') {\n            sort_dir = \"desc\";\n            sort_order = sort_order.substr(1);\n        } else {\n            sort_dir = 'asc';\n        }\n        $(\"th[data-sort_order=\" + sort_order + \"]\").sortable('select', sort_dir);\n    },\n\n    /**\n     * Change current sort order.\n     *\n     * @this Listing\n     */\n    change_sort_order: function(sort_order, dir) {\n        if (dir == \"desc\") {\n            sort_order = \"-\" + sort_order;\n        }\n        this.navobj.setparam(\"sort_order\", sort_order).update();\n    },\n\n    /**\n     * Register a new tag handler.\n     *\n     * @this Listing\n     * @param {string} name - name of the tag\n     * @param {function} handler - reference to a function (optional)\n     */\n    register_tag_handler: function(name, handler) {\n        if (handler === undefined) {\n            handler = this.generic_tag_handler;\n        }\n        this.tag_handlers[name] = handler;\n        if (this.navobj.getparam(name + \"filter\") !== undefined) {\n            var text = this.navobj.getparam(name + \"filter\");\n            $(\"#taglist\").append(this.make_tag(text, name));\n        }\n    },\n\n    /**\n     * Default tag handler.\n     *\n     * @this Listing\n     * @param {string} tag - name of the tag\n     * @param {Object} $link - tag that was clicked\n     * @return {boolean} - return true if handler has been executed\n     */\n    generic_tag_handler: function(tag, $link) {\n        if (this.navobj.getparam(tag + \"filter\") === undefined && $link.hasClass(tag)) {\n            var text = $link.attr(\"name\");\n            this.navobj.setparam(tag + \"filter\", text).update();\n            $(\"#taglist\").append(this.make_tag(text, tag));\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Build a button to remove a specific filter.\n     *\n     * @this Listing\n     * @param {string} text - text of the button\n     * @param {string} type - tag type\n     * @return {Object} - new button object\n     */\n    make_tag: function(text, type) {\n        var $tag = $(\"<a />\", {\n            \"name\": type, \"class\" : \"btn btn-default btn-xs\",\n            \"html\": \" \" + htmlEncode(text)\n        });\n\n        $(\"<span />\", {\"class\" : \"fa fa-remove\"}).prependTo($tag);\n        $tag.click($.proxy(this.remove_tag, this));\n        return $tag;\n    },\n\n    /**\n     * Click event : remove a tag button.\n     *\n     * @this Listing\n     * @param {Object} e - event object\n     */\n    remove_tag: function(e) {\n        var $tag = $(e.target);\n\n        if ($tag.is(\"i\")) {\n            $tag = $tag.parent();\n        }\n        e.preventDefault();\n        this.navobj.delparam($tag.attr(\"name\") + \"filter\").update();\n        $tag.remove();\n    },\n\n    /**\n     * Click event: filter the listing when a tag is clicked.\n     *\n     * @this Listing\n     * @param {Object} e - event object\n     */\n    filter_by_tag: function(e) {\n        var $link = $(e.target);\n        e.preventDefault();\n\n        for (var name in this.tag_handlers) {\n            if (this.tag_handlers[name].apply(this, [name, $link])) {\n                break;\n            }\n        }\n    }\n};\n"], "filenames": ["modoboa/static/js/listing.js"], "buggy_code_start_loc": [258], "buggy_code_end_loc": [261], "fixing_code_start_loc": [258], "fixing_code_end_loc": [261], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository modoboa/modoboa prior to 2.0.5.", "other": {"cve": {"id": "CVE-2023-0949", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-22T09:15:10.140", "lastModified": "2023-03-02T20:09:52.483", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository modoboa/modoboa prior to 2.0.5."}, {"lang": "es", "value": "El repositorio modoboa de GitHub, en versiones anteriores a 2.0.5, es vulnerable a un Cross-site Scripting (XSS) reflejado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:modoboa:modoboa:*:*:*:*:*:modoboa:*:*", "versionEndExcluding": "2.0.5", "matchCriteriaId": "27596FAB-FEFE-415A-9AC6-BCAD3E1BEE8E"}]}]}], "references": [{"url": "https://github.com/modoboa/modoboa/commit/aa74e9a4a870162eea169e0a6a2eab841f8811b7", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/ef87be4e-493b-4ee9-9738-44c55b8acc19", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/modoboa/modoboa/commit/aa74e9a4a870162eea169e0a6a2eab841f8811b7"}}