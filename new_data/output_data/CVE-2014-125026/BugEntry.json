{"buggy_code": ["package lz4\n\n// #cgo CFLAGS: -O3\n// #include \"src/lz4.h\"\n// #include \"src/lz4.c\"\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\n// p gets a char pointer to the first byte of a []byte slice\nfunc p(in []byte) *C.char {\n\tif len(in) == 0 {\n\t\treturn (*C.char)(unsafe.Pointer(nil))\n\t}\n\treturn (*C.char)(unsafe.Pointer(&in[0]))\n}\n\n// clen gets the length of a []byte slice as a char *\nfunc clen(s []byte) C.int {\n\treturn C.int(len(s))\n}\n\n// Uncompress with a known output size. len(out) should be equal to\n// the length of the uncompressed out.\nfunc Uncompress(in, out []byte) (err error) {\n\tread := int(C.LZ4_uncompress(p(in), p(out), clen(out)))\n\n\tif read != len(in) {\n\t\terr = fmt.Errorf(\"uncompress read %d bytes should have read %d\",\n\t\t\tread, len(in))\n\t}\n\treturn\n}\n\n// CompressBound calculates the size of the output buffer needed by\n// Compress. This is based on the following macro:\n//\n// #define LZ4_COMPRESSBOUND(isize)\n//      ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)\nfunc CompressBound(in []byte) int {\n\treturn len(in) + ((len(in) / 255) + 16)\n}\n\n// Compress compresses in and puts the content in out. len(out)\n// should have enough space for the compressed data (use CompressBound\n// to calculate). Returns the number of bytes in the out slice.\nfunc Compress(in, out []byte) (outSize int, err error) {\n\toutSize = int(C.LZ4_compress_limitedOutput(p(in), p(out), clen(in), clen(out)))\n\tif outSize == 0 {\n\t\terr = fmt.Errorf(\"insufficient space for compression\")\n\t}\n\treturn\n}\n"], "fixing_code": ["package lz4\n\n// #cgo CFLAGS: -O3\n// #include \"src/lz4.h\"\n// #include \"src/lz4.c\"\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"unsafe\"\n)\n\n// p gets a char pointer to the first byte of a []byte slice\nfunc p(in []byte) *C.char {\n\tif len(in) == 0 {\n\t\treturn (*C.char)(unsafe.Pointer(nil))\n\t}\n\treturn (*C.char)(unsafe.Pointer(&in[0]))\n}\n\n// clen gets the length of a []byte slice as a char *\nfunc clen(s []byte) C.int {\n\treturn C.int(len(s))\n}\n\n// Uncompress with a known output size. len(out) should be equal to\n// the length of the uncompressed out.\nfunc Uncompress(in, out []byte) (error) {\n\tif int(C.LZ4_decompress_safe(p(in), p(out), clen(in), clen(out))) < 0 {\n\t\treturn errors.New(\"Malformed compression stream\")\n\t}\n\n\treturn nil\n}\n\n// CompressBound calculates the size of the output buffer needed by\n// Compress. This is based on the following macro:\n//\n// #define LZ4_COMPRESSBOUND(isize)\n//      ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)\nfunc CompressBound(in []byte) int {\n\treturn len(in) + ((len(in) / 255) + 16)\n}\n\n// Compress compresses in and puts the content in out. len(out)\n// should have enough space for the compressed data (use CompressBound\n// to calculate). Returns the number of bytes in the out slice.\nfunc Compress(in, out []byte) (outSize int, err error) {\n\toutSize = int(C.LZ4_compress_limitedOutput(p(in), p(out), clen(in), clen(out)))\n\tif outSize == 0 {\n\t\terr = fmt.Errorf(\"insufficient space for compression\")\n\t}\n\treturn\n}\n"], "filenames": ["lz4.go"], "buggy_code_start_loc": [8], "buggy_code_end_loc": [36], "fixing_code_start_loc": [9], "fixing_code_end_loc": [35], "type": "CWE-787", "message": "LZ4 bindings use a deprecated C API that is vulnerable to memory corruption, which could lead to arbitrary code execution if called with untrusted user input.", "other": {"cve": {"id": "CVE-2014-125026", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:10.883", "lastModified": "2023-01-06T15:24:30.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LZ4 bindings use a deprecated C API that is vulnerable to memory corruption, which could lead to arbitrary code execution if called with untrusted user input."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cloudflare:golz4:*:*:*:*:*:go:*:*", "versionEndExcluding": "2014-07-11", "matchCriteriaId": "CF7258F9-47C1-4E63-A1FD-5BB5378558BA"}]}]}], "references": [{"url": "https://github.com/cloudflare/golz4/commit/199f5f7878062ca17a98e079f2dbe1205e2ed898", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cloudflare/golz4/issues/5", "source": "security@golang.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0022", "source": "security@golang.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/cloudflare/golz4/commit/199f5f7878062ca17a98e079f2dbe1205e2ed898"}}