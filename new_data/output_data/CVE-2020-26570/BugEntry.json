{"buggy_code": ["/*\n * PKCS15 emulation layer for Oberthur card.\n *\n * Copyright (C) 2010, Viktor Tarasov <vtarasov@opentrust.com>\n * Copyright (C) 2005, Andrea Frigido <andrea@frisoft.it>\n * Copyright (C) 2005, Sirio Capizzi <graaf@virgilio.it>\n * Copyright (C) 2004, Antonino Iacono <ant_iacono@tin.it>\n * Copyright (C) 2003, Olaf Kirch <okir@suse.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"../common/compat_strlcpy.h\"\n\n#include \"pkcs15.h\"\n#include \"log.h\"\n#include \"asn1.h\"\n#include \"internal.h\"\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/bio.h>\n#include <openssl/crypto.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#endif\n\n#define OBERTHUR_ATTR_MODIFIABLE\t0x0001\n#define OBERTHUR_ATTR_TRUSTED\t\t0x0002\n#define OBERTHUR_ATTR_LOCAL\t\t0x0004\n#define OBERTHUR_ATTR_ENCRYPT\t\t0x0008\n#define OBERTHUR_ATTR_DECRYPT\t\t0x0010\n#define OBERTHUR_ATTR_SIGN\t\t0x0020\n#define OBERTHUR_ATTR_VERIFY\t\t0x0040\n#define OBERTHUR_ATTR_RSIGN\t\t0x0080\n#define OBERTHUR_ATTR_RVERIFY\t\t0x0100\n#define OBERTHUR_ATTR_WRAP\t\t0x0200\n#define OBERTHUR_ATTR_UNWRAP\t\t0x0400\n#define OBERTHUR_ATTR_DERIVE\t\t0x0800\n\n#define USAGE_PRV_ENC\t(SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT |\\\n\t\t\t SC_PKCS15_PRKEY_USAGE_WRAP | SC_PKCS15_PRKEY_USAGE_UNWRAP)\n#define USAGE_PRV_AUT\t SC_PKCS15_PRKEY_USAGE_SIGN\n#define USAGE_PRV_SIGN\t(SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_NONREPUDIATION)\n#define USAGE_PUB_ENC\t(SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_WRAP)\n#define USAGE_PUB_AUT\t SC_PKCS15_PRKEY_USAGE_VERIFY\n#define USAGE_PUB_SIGN\t(SC_PKCS15_PRKEY_USAGE_VERIFY | SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER)\n\n#define PIN_DOMAIN_LABEL\t\"SCM\"\nconst unsigned char PinDomainID[3] = {0x53, 0x43, 0x4D};\n\n#define AWP_PIN_DF\t\t\"3F005011\"\n#define AWP_TOKEN_INFO\t\t\"3F0050111000\"\n#define AWP_PUK_FILE\t\t\"3F0050112000\"\n#define AWP_CONTAINERS_MS\t\"3F0050113000\"\n#define AWP_OBJECTS_LIST_PUB\t\"3F0050114000\"\n#define AWP_OBJECTS_LIST_PRV\t\"3F0050115000\"\n#define AWP_OBJECTS_DF_PUB\t\"3F0050119001\"\n#define AWP_OBJECTS_DF_PRV\t\"3F0050119002\"\n#define AWP_BASE_RSA_PRV\t\"3F00501190023000\"\n#define AWP_BASE_RSA_PUB\t\"3F00501190011000\"\n#define AWP_BASE_CERTIFICATE\t\"3F00501190012000\"\n\n#define BASE_ID_PUB_RSA   0x10\n#define BASE_ID_CERT\t  0x20\n#define BASE_ID_PRV_RSA   0x30\n#define BASE_ID_PRV_DES   0x40\n#define BASE_ID_PUB_DATA  0x50\n#define BASE_ID_PRV_DATA  0x60\n#define BASE_ID_PUB_DES   0x70\n\nstatic int sc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *, unsigned, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *, unsigned, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *, unsigned, unsigned, int);\n\nstatic int sc_oberthur_parse_tokeninfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_containers (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_publicinfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_privateinfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\n\nstatic int sc_awp_parse_df(struct sc_pkcs15_card *, struct sc_pkcs15_df *);\nstatic void sc_awp_clear(struct sc_pkcs15_card *);\n\nstruct crypto_container {\n\tunsigned  id_pub;\n\tunsigned  id_prv;\n\tunsigned  id_cert;\n};\n\nstruct container {\n\tchar uuid[37];\n\tstruct crypto_container exchange;\n\tstruct crypto_container sign;\n\n\tstruct container *next;\n\tstruct container *prev;\n};\n\nstruct container *Containers = NULL;\n\nstatic struct {\n\tconst char *name;\n\tconst char *path;\n\tunsigned char *content;\n\tsize_t len;\n\tint (*parser)(struct sc_pkcs15_card *, unsigned char *, size_t, int);\n\tint postpone_allowed;\n} oberthur_infos[] = {\n\t/* Never change the following order */\n\t{ \"Token info\",\t\t\tAWP_TOKEN_INFO, \tNULL, 0, sc_oberthur_parse_tokeninfo, \t0},\n\t{ \"Containers MS\",\t\tAWP_CONTAINERS_MS, \tNULL, 0, sc_oberthur_parse_containers, \t0},\n\t{ \"Public objects list\",\tAWP_OBJECTS_LIST_PUB, \tNULL, 0, sc_oberthur_parse_publicinfo, \t0},\n\t{ \"Private objects list\",\tAWP_OBJECTS_LIST_PRV,\tNULL, 0, sc_oberthur_parse_privateinfo, 1},\n\t{ NULL, NULL, NULL, 0, NULL, 0}\n};\n\n\nstatic unsigned\nsc_oberthur_decode_usage(unsigned flags)\n{\n\tunsigned ret = 0;\n\n\tif (flags & OBERTHUR_ATTR_ENCRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_ENCRYPT;\n\tif (flags & OBERTHUR_ATTR_DECRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\tif (flags & OBERTHUR_ATTR_SIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGN;\n\tif (flags & OBERTHUR_ATTR_RSIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGNRECOVER;\n\tif (flags & OBERTHUR_ATTR_WRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_WRAP;\n\tif (flags & OBERTHUR_ATTR_UNWRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_UNWRAP;\n\tif (flags & OBERTHUR_ATTR_VERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFY;\n\tif (flags & OBERTHUR_ATTR_RVERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;\n\tif (flags & OBERTHUR_ATTR_DERIVE)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DERIVE;\n\treturn ret;\n}\n\n\nstatic int\nsc_oberthur_get_friends (unsigned int id, struct crypto_container *ccont)\n{\n\tstruct container *cont;\n\n\tfor (cont = Containers; cont; cont = cont->next)   {\n\t\tif (cont->exchange.id_pub == id || cont->exchange.id_prv == id || cont->exchange.id_cert == id)   {\n\t\t\tif (ccont)\n\t\t\t\tmemcpy(ccont, &cont->exchange, sizeof(struct crypto_container));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cont->sign.id_pub == id || cont->sign.id_prv == id || cont->sign.id_cert == id)   {\n\t\t\tif (ccont)\n\t\t\t\tmemcpy(ccont, &cont->sign, sizeof(struct crypto_container));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn cont ? 0 : SC_ERROR_TEMPLATE_NOT_FOUND;\n}\n\n\nstatic int\nsc_oberthur_get_certificate_authority(struct sc_pkcs15_der *der, int *out_authority)\n{\n#ifdef ENABLE_OPENSSL\n\tX509\t*x;\n\tBUF_MEM buf_mem;\n\tBIO *bio = NULL;\n\tBASIC_CONSTRAINTS *bs = NULL;\n\n\tif (!der)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tbuf_mem.data = malloc(der->len);\n\tif (!buf_mem.data)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tmemcpy(buf_mem.data, der->value, der->len);\n\tbuf_mem.max = buf_mem.length = der->len;\n\n\tbio = BIO_new(BIO_s_mem());\n\tif (!bio) {\n\t\tfree(buf_mem.data);\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tBIO_set_mem_buf(bio, &buf_mem, BIO_NOCLOSE);\n\tx = d2i_X509_bio(bio, 0);\n\tBIO_free(bio);\n\tif (!x)\n\t\treturn SC_ERROR_INVALID_DATA;\n\n\tbs = (BASIC_CONSTRAINTS *)X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL);\n\tif (out_authority)\n\t\t*out_authority = (bs && bs->ca);\n\n\tX509_free(x);\n\n\treturn SC_SUCCESS;\n#else\n\treturn SC_ERROR_NOT_SUPPORTED;\n#endif\n}\n\n\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tint rec;\n\t\tint offs = 0;\n\t\tint rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nsc_oberthur_parse_tokeninfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tchar label[0x21];\n\tunsigned flags;\n\tint ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!buff || len < 0x24)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot parse token info\");\n\n\tmemset(label, 0, sizeof(label));\n\n\tmemcpy(label, buff, 0x20);\n\tii = 0x20;\n\twhile (*(label + --ii)==' ' && ii)\n\t\t;\n\t*(label + ii + 1) = '\\0';\n\n\tflags = *(buff + 0x22) * 0x100 + *(buff + 0x23);\n\n\tset_string(&p15card->tokeninfo->label, label);\n\tset_string(&p15card->tokeninfo->manufacturer_id, \"Oberthur/OpenSC\");\n\n\tif (flags & 0x01)\n\t\tp15card->tokeninfo->flags |= SC_PKCS15_TOKEN_PRN_GENERATION;\n\n\tsc_log(ctx, \"label %s\", p15card->tokeninfo->label);\n\tsc_log(ctx, \"manufacturer_id %s\", p15card->tokeninfo->manufacturer_id);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\nsc_oberthur_parse_containers (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t offs;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\twhile (Containers)   {\n\t\tstruct container *next = Containers->next;\n\n\t\tfree (Containers);\n\t\tContainers = next;\n\t}\n\n\tfor (offs=0; offs < len;)  {\n\t\tstruct container *cont;\n\t\tunsigned char *ptr =  buff + offs + 2;\n\n\t\tsc_log(ctx,\n\t\t       \"parse contaniers offs:%\"SC_FORMAT_LEN_SIZE_T\"u, len:%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       offs, len);\n\t\tif (*(buff + offs) != 'R')\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\n\t\tcont = (struct container *)calloc(sizeof(struct container), 1);\n\t\tif (!cont)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\t\tcont->exchange.id_pub = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->exchange.id_prv = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->exchange.id_cert = *ptr * 0x100 + *(ptr + 1); ptr += 2;\n\n\t\tcont->sign.id_pub = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->sign.id_prv = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->sign.id_cert = *ptr * 0x100 + *(ptr + 1); ptr += 2;\n\n\t\tmemcpy(cont->uuid, ptr + 2, 36);\n\t\tsc_log(ctx, \"UUID: %s; 0x%X, 0x%X, 0x%X\", cont->uuid,\n\t\t\t\tcont->exchange.id_pub, cont->exchange.id_prv, cont->exchange.id_cert);\n\n\t\tif (!Containers)  {\n\t\t\tContainers = cont;\n\t\t}\n\t\telse   {\n\t\t\tcont->next = Containers;\n\t\t\tContainers->prev = (void *)cont;\n\t\t\tContainers = cont;\n\t\t}\n\n\t\toffs += *(buff + offs + 1) + 2;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\nsc_oberthur_parse_publicinfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t ii;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tfor (ii=0; ii<len; ii+=5)   {\n\t\tunsigned int file_id, size;\n\n\t\tif(*(buff+ii) != 0xFF)\n\t\t\tcontinue;\n\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add public object(file-id:%04X,size:%X)\", file_id, size);\n\n\t\tswitch (*(buff+ii + 1))   {\n\t\tcase BASE_ID_PUB_RSA :\n\t\t\trv = sc_pkcs15emu_oberthur_add_pubkey(p15card, file_id, size);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse public key info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_CERT :\n\t\t\trv = sc_pkcs15emu_oberthur_add_cert(p15card, file_id);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse certificate info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_PUB_DES :\n\t\t\tbreak;\n\t\tcase BASE_ID_PUB_DATA :\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 0);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse data info\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Public object parse error\");\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\nsc_oberthur_parse_privateinfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t ii;\n\tint rv;\n\tint no_more_private_keys = 0, no_more_private_data = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor (ii=0; ii<len; ii+=5)   {\n\t\tunsigned int file_id, size;\n\n\t\tif(*(buff+ii) != 0xFF)\n\t\t\tcontinue;\n\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add private object (file-id:%04X, size:%X)\", file_id, size);\n\n\t\tswitch (*(buff+ii + 1))   {\n\t\tcase BASE_ID_PRV_RSA :\n\t\t\tif (no_more_private_keys)\n\t\t\t\tbreak;\n\n\t\t\trv = sc_pkcs15emu_oberthur_add_prvkey(p15card, file_id, size);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tstruct sc_path path;\n\n\t\t\t\tsc_log(ctx, \"postpone adding of the private keys\");\n\t\t\t\tsc_format_path(\"5011A5A5\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_PRKDF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add PrkDF error\");\n\t\t\t\tno_more_private_keys = 1;\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private key info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_PRV_DES :\n\t\t\tbreak;\n\t\tcase BASE_ID_PRV_DATA :\n\t\t\tsc_log(ctx, \"*(buff+ii + 1):%X\", *(buff+ii + 1));\n\t\t\tif (no_more_private_data)\n\t\t\t\tbreak;\n\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 1);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tstruct sc_path path;\n\n\t\t\t\tsc_log(ctx, \"postpone adding of the private data\");\n\t\t\t\tsc_format_path(\"5011A6A6\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_DODF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add DODF error\");\n\t\t\t\tno_more_private_data = 1;\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private data info\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Private object parse error\");\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\n/* Public key info:\n * \tflags:2,\n * \tCN(len:2,value:<variable length>),\n * \tID(len:2,value:(SHA1 value)),\n * \tStartDate(Ascii:8)\n * \tEndDate(Ascii:8)\n * \t??(0x00:2)\n */\nstatic int\nsc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_pubkey_info key_info;\n\tstruct sc_pkcs15_object key_obj;\n\tchar ch_tmp[0x100];\n\tunsigned char *info_blob;\n\tsize_t len, info_len, offs;\n\tunsigned flags;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"public key(file-id:%04X,size:%X)\", file_id, size);\n\n\tmemset(&key_info, 0, sizeof(key_info));\n\tmemset(&key_obj, 0, sizeof(key_obj));\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add public key: read oberthur file error\");\n\n\t/* Flags */\n\toffs = 2;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\tkey_info.usage = sc_oberthur_decode_usage(flags);\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tkey_obj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE;\n\tsc_log(ctx, \"Public key key-usage:%04X\", key_info.usage);\n\n\t/* Label */\n\tif (offs + 2 > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'Label'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tif (len > sizeof(key_obj.label) - 1)\n\t\t\tlen = sizeof(key_obj.label) - 1;\n\t\tmemcpy(key_obj.label, info_blob + offs + 2, len);\n\t}\n\toffs += 2 + len;\n\n\t/* ID */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (!len || len > sizeof(key_info.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add public key: invalid 'ID' length\");\n\tmemcpy(key_info.id.value, info_blob + offs + 2, len);\n\tkey_info.id.len = len;\n\n\t/* Ignore Start/End dates */\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &key_info.path);\n\n\tkey_info.native = 1;\n\tkey_info.key_reference = file_id & 0xFF;\n\tkey_info.modulus_length = size;\n\n\trv = sc_pkcs15emu_add_rsa_pubkey(p15card, &key_obj, &key_info);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\n/* Certificate info:\n * \tflags:2,\n * \tLabel(len:2,value:),\n * \tID(len:2,value:(SHA1 value)),\n * \tSubject in ASN.1(len:2,value:)\n * \tIssuer in ASN.1(len:2,value:)\n * \tSerial encoded in LV or ASN.1\tFIXME\n */\nstatic int\nsc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *p15card, unsigned int file_id)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_cert_info cinfo;\n\tstruct sc_pkcs15_object cobj;\n\tunsigned char *info_blob, *cert_blob;\n\tsize_t info_len, cert_len, len, offs;\n\tunsigned flags;\n\tint rv;\n\tchar ch_tmp[0x20];\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add certificate(file-id:%04X)\", file_id);\n\n\tmemset(&cinfo, 0, sizeof(cinfo));\n\tmemset(&cobj, 0, sizeof(cobj));\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read oberthur file error\");\n\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\n\t/* Label */\n\tif (offs + 2 > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'CN'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tif (len > sizeof(cobj.label) - 1)\n\t\t\tlen = sizeof(cobj.label) - 1;\n\t\tmemcpy(cobj.label, info_blob + offs + 2, len);\n\t}\n\toffs += 2 + len;\n\n\t/* ID */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len > sizeof(cinfo.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add certificate: invalid 'ID' length\");\n\tmemcpy(cinfo.id.value, info_blob + offs + 2, len);\n\tcinfo.id.len = len;\n\n\t/* Ignore subject, issuer and serial */\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &cinfo.path);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &cert_blob, &cert_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read certificate error\");\n\n\tcinfo.value.value = cert_blob;\n\tcinfo.value.len = cert_len;\n\n\trv = sc_oberthur_get_certificate_authority(&cinfo.value, &cinfo.authority);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: get certificate attributes error\");\n\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tcobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\trv = sc_pkcs15emu_add_x509_cert(p15card, &cobj, &cinfo);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\n\n/* Private key info:\n * \tflags:2,\n * \tCN(len:2,value:),\n * \tID(len:2,value:(SHA1 value)),\n * \tStartDate(Ascii:8)\n * \tEndDate(Ascii:8)\n * \tSubject in ASN.1(len:2,value:)\n * \tmodulus(value:)\n *\texponent(length:1, value:3)\n */\nstatic int\nsc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info kinfo;\n\tstruct sc_pkcs15_object kobj;\n\tstruct crypto_container ccont;\n\tunsigned char *info_blob = NULL;\n\tsize_t info_len = 0;\n\tunsigned flags;\n\tsize_t offs, len;\n\tchar ch_tmp[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add private key(file-id:%04X,size:%04X)\", file_id, size);\n\n\tmemset(&kinfo, 0, sizeof(kinfo));\n\tmemset(&kobj, 0, sizeof(kobj));\n\tmemset(&ccont, 0, sizeof(ccont));\n\n\trv = sc_oberthur_get_friends (file_id, &ccont);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: get friends error\");\n\n\tif (ccont.id_cert)   {\n\t\tstruct sc_pkcs15_object *objs[32];\n\t\tint ii;\n\n\t\tsc_log(ctx, \"friend certificate %04X\", ccont.id_cert);\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_CERT_X509, objs, 32);\n\t\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: get certificates error\");\n\n\t\tfor (ii=0; ii<rv; ii++) {\n\t\t\tstruct sc_pkcs15_cert_info *cert = (struct sc_pkcs15_cert_info *)objs[ii]->data;\n\t\t\tstruct sc_path path = cert->path;\n\t\t\tunsigned int id = path.value[path.len - 2] * 0x100 + path.value[path.len - 1];\n\n\t\t\tif (id == ccont.id_cert)   {\n\t\t\t\tstrlcpy(kobj.label, objs[ii]->label, sizeof(kobj.label));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ii == rv)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, \"Failed to add private key: friend not found\");\n\t}\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: read oberthur file error\");\n\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\n\t/* CN */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'CN'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len && !strlen(kobj.label))   {\n\t\tif (len > sizeof(kobj.label) - 1)\n\t\t\tlen = sizeof(kobj.label) - 1;\n\t\tstrncpy(kobj.label, (char *)(info_blob + offs + 2), len);\n\t}\n\toffs += 2 + len;\n\n\t/* ID */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (!len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: zero length ID\");\n\telse if (len > sizeof(kinfo.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add private key: invalid ID length\");\n\tmemcpy(kinfo.id.value, info_blob + offs + 2, len);\n\tkinfo.id.len = len;\n\toffs += 2 + len;\n\n\t/* Ignore Start/End dates */\n\toffs += 16;\n\n\t/* Subject encoded in ASN1 */\n\tif (offs > info_len)\n\t\treturn SC_ERROR_UNKNOWN_DATA_RECEIVED;\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tkinfo.subject.value = malloc(len);\n\t\tif (!kinfo.subject.value)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Failed to add private key: memory allocation error\");\n\t\tkinfo.subject.len = len;\n\t\tmemcpy(kinfo.subject.value, info_blob + offs + 2, len);\n\t}\n\n\t/* Modulus and exponent are ignored */\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id);\n\tsc_format_path(ch_tmp, &kinfo.path);\n\tsc_log(ctx, \"Private key info path %s\", ch_tmp);\n\n\tkinfo.modulus_length\t= size;\n\tkinfo.native\t\t= 1;\n\tkinfo.key_reference\t = file_id & 0xFF;\n\n\tkinfo.usage = sc_oberthur_decode_usage(flags);\n\tkobj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tkobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tkobj.auth_id.len = sizeof(PinDomainID) > sizeof(kobj.auth_id.value)\n\t\t\t? sizeof(kobj.auth_id.value) : sizeof(PinDomainID);\n\tmemcpy(kobj.auth_id.value, PinDomainID, kobj.auth_id.len);\n\n\tsc_log(ctx, \"Parsed private key(reference:%i,usage:%X,flags:%X)\", kinfo.key_reference, kinfo.usage, kobj.flags);\n\n\trv = sc_pkcs15emu_add_rsa_prkey(p15card, &kobj, &kinfo);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nsc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size, int private)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_data_info dinfo;\n\tstruct sc_pkcs15_object dobj;\n\tunsigned flags;\n\tunsigned char *info_blob = NULL, *label = NULL, *app = NULL, *oid = NULL;\n\tsize_t info_len, label_len, app_len, oid_len, offs;\n\tchar ch_tmp[0x100];\n\tint rv;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(ctx, \"Add data(file-id:%04X,size:%i,is-private:%i)\", file_id, size, private);\n\tmemset(&dinfo, 0, sizeof(dinfo));\n\tmemset(&dobj, 0, sizeof(dobj));\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add data: read oberthur file error\");\n\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\n\t/* Label */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'label'\");\n\tlabel = info_blob + offs + 2;\n\tlabel_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (label_len > sizeof(dobj.label) - 1)\n\t\tlabel_len = sizeof(dobj.label) - 1;\n\toffs += 2 + *(info_blob + offs + 1);\n\n\t/* Application */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'application'\");\n\tapp = info_blob + offs + 2;\n\tapp_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (app_len > sizeof(dinfo.app_label) - 1)\n\t\tapp_len = sizeof(dinfo.app_label) - 1;\n\toffs += 2 + app_len;\n\n\t/* OID encode like DER(ASN.1(oid)) */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'OID'\");\n\toid_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (oid_len)   {\n\t\toid = info_blob + offs + 2;\n\t\tif (*oid != 0x06 || (*(oid + 1) != oid_len - 2))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: invalid 'OID' format\");\n\t\toid += 2;\n\t\toid_len -= 2;\n\t}\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id);\n\n\tsc_format_path(ch_tmp, &dinfo.path);\n\n\tmemcpy(dobj.label, label, label_len);\n\tmemcpy(dinfo.app_label, app, app_len);\n\tif (oid_len)\n\t\tsc_asn1_decode_object_id(oid, oid_len, &dinfo.app_oid);\n\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tif (private)   {\n\t\tdobj.auth_id.len = sizeof(PinDomainID) > sizeof(dobj.auth_id.value)\n\t\t\t\t? sizeof(dobj.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(dobj.auth_id.value, PinDomainID, dobj.auth_id.len);\n\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_PRIVATE;\n\t}\n\n\trv = sc_pkcs15emu_add_data_object(p15card, &dobj, &dinfo);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\n\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\noberthur_detect_card(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_card *card = p15card->card;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (p15card->card->type != SC_CARD_TYPE_OBERTHUR_64K)\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_WRONG_CARD);\n\tLOG_FUNC_RETURN(p15card->card->ctx, SC_SUCCESS);\n}\n\n\nint\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\n\nstatic int\nsc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *buf = NULL;\n\tsize_t buf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tif (df->enumerated)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\trv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: read private objects info failed\");\n\n\trv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);\n\n\tif (buf)\n\t\tfree(buf);\n\n\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: private info parse error\");\n\tdf->enumerated = 1;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic void\nsc_awp_clear(struct sc_pkcs15_card *p15card)\n{\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n}\n"], "fixing_code": ["/*\n * PKCS15 emulation layer for Oberthur card.\n *\n * Copyright (C) 2010, Viktor Tarasov <vtarasov@opentrust.com>\n * Copyright (C) 2005, Andrea Frigido <andrea@frisoft.it>\n * Copyright (C) 2005, Sirio Capizzi <graaf@virgilio.it>\n * Copyright (C) 2004, Antonino Iacono <ant_iacono@tin.it>\n * Copyright (C) 2003, Olaf Kirch <okir@suse.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"../common/compat_strlcpy.h\"\n\n#include \"pkcs15.h\"\n#include \"log.h\"\n#include \"asn1.h\"\n#include \"internal.h\"\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/bio.h>\n#include <openssl/crypto.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#endif\n\n#define OBERTHUR_ATTR_MODIFIABLE\t0x0001\n#define OBERTHUR_ATTR_TRUSTED\t\t0x0002\n#define OBERTHUR_ATTR_LOCAL\t\t0x0004\n#define OBERTHUR_ATTR_ENCRYPT\t\t0x0008\n#define OBERTHUR_ATTR_DECRYPT\t\t0x0010\n#define OBERTHUR_ATTR_SIGN\t\t0x0020\n#define OBERTHUR_ATTR_VERIFY\t\t0x0040\n#define OBERTHUR_ATTR_RSIGN\t\t0x0080\n#define OBERTHUR_ATTR_RVERIFY\t\t0x0100\n#define OBERTHUR_ATTR_WRAP\t\t0x0200\n#define OBERTHUR_ATTR_UNWRAP\t\t0x0400\n#define OBERTHUR_ATTR_DERIVE\t\t0x0800\n\n#define USAGE_PRV_ENC\t(SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT |\\\n\t\t\t SC_PKCS15_PRKEY_USAGE_WRAP | SC_PKCS15_PRKEY_USAGE_UNWRAP)\n#define USAGE_PRV_AUT\t SC_PKCS15_PRKEY_USAGE_SIGN\n#define USAGE_PRV_SIGN\t(SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_NONREPUDIATION)\n#define USAGE_PUB_ENC\t(SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_WRAP)\n#define USAGE_PUB_AUT\t SC_PKCS15_PRKEY_USAGE_VERIFY\n#define USAGE_PUB_SIGN\t(SC_PKCS15_PRKEY_USAGE_VERIFY | SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER)\n\n#define PIN_DOMAIN_LABEL\t\"SCM\"\nconst unsigned char PinDomainID[3] = {0x53, 0x43, 0x4D};\n\n#define AWP_PIN_DF\t\t\"3F005011\"\n#define AWP_TOKEN_INFO\t\t\"3F0050111000\"\n#define AWP_PUK_FILE\t\t\"3F0050112000\"\n#define AWP_CONTAINERS_MS\t\"3F0050113000\"\n#define AWP_OBJECTS_LIST_PUB\t\"3F0050114000\"\n#define AWP_OBJECTS_LIST_PRV\t\"3F0050115000\"\n#define AWP_OBJECTS_DF_PUB\t\"3F0050119001\"\n#define AWP_OBJECTS_DF_PRV\t\"3F0050119002\"\n#define AWP_BASE_RSA_PRV\t\"3F00501190023000\"\n#define AWP_BASE_RSA_PUB\t\"3F00501190011000\"\n#define AWP_BASE_CERTIFICATE\t\"3F00501190012000\"\n\n#define BASE_ID_PUB_RSA   0x10\n#define BASE_ID_CERT\t  0x20\n#define BASE_ID_PRV_RSA   0x30\n#define BASE_ID_PRV_DES   0x40\n#define BASE_ID_PUB_DATA  0x50\n#define BASE_ID_PRV_DATA  0x60\n#define BASE_ID_PUB_DES   0x70\n\nstatic int sc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *, unsigned, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *, unsigned, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *, unsigned, unsigned, int);\n\nstatic int sc_oberthur_parse_tokeninfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_containers (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_publicinfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_privateinfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\n\nstatic int sc_awp_parse_df(struct sc_pkcs15_card *, struct sc_pkcs15_df *);\nstatic void sc_awp_clear(struct sc_pkcs15_card *);\n\nstruct crypto_container {\n\tunsigned  id_pub;\n\tunsigned  id_prv;\n\tunsigned  id_cert;\n};\n\nstruct container {\n\tchar uuid[37];\n\tstruct crypto_container exchange;\n\tstruct crypto_container sign;\n\n\tstruct container *next;\n\tstruct container *prev;\n};\n\nstruct container *Containers = NULL;\n\nstatic struct {\n\tconst char *name;\n\tconst char *path;\n\tunsigned char *content;\n\tsize_t len;\n\tint (*parser)(struct sc_pkcs15_card *, unsigned char *, size_t, int);\n\tint postpone_allowed;\n} oberthur_infos[] = {\n\t/* Never change the following order */\n\t{ \"Token info\",\t\t\tAWP_TOKEN_INFO, \tNULL, 0, sc_oberthur_parse_tokeninfo, \t0},\n\t{ \"Containers MS\",\t\tAWP_CONTAINERS_MS, \tNULL, 0, sc_oberthur_parse_containers, \t0},\n\t{ \"Public objects list\",\tAWP_OBJECTS_LIST_PUB, \tNULL, 0, sc_oberthur_parse_publicinfo, \t0},\n\t{ \"Private objects list\",\tAWP_OBJECTS_LIST_PRV,\tNULL, 0, sc_oberthur_parse_privateinfo, 1},\n\t{ NULL, NULL, NULL, 0, NULL, 0}\n};\n\n\nstatic unsigned\nsc_oberthur_decode_usage(unsigned flags)\n{\n\tunsigned ret = 0;\n\n\tif (flags & OBERTHUR_ATTR_ENCRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_ENCRYPT;\n\tif (flags & OBERTHUR_ATTR_DECRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\tif (flags & OBERTHUR_ATTR_SIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGN;\n\tif (flags & OBERTHUR_ATTR_RSIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGNRECOVER;\n\tif (flags & OBERTHUR_ATTR_WRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_WRAP;\n\tif (flags & OBERTHUR_ATTR_UNWRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_UNWRAP;\n\tif (flags & OBERTHUR_ATTR_VERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFY;\n\tif (flags & OBERTHUR_ATTR_RVERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;\n\tif (flags & OBERTHUR_ATTR_DERIVE)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DERIVE;\n\treturn ret;\n}\n\n\nstatic int\nsc_oberthur_get_friends (unsigned int id, struct crypto_container *ccont)\n{\n\tstruct container *cont;\n\n\tfor (cont = Containers; cont; cont = cont->next)   {\n\t\tif (cont->exchange.id_pub == id || cont->exchange.id_prv == id || cont->exchange.id_cert == id)   {\n\t\t\tif (ccont)\n\t\t\t\tmemcpy(ccont, &cont->exchange, sizeof(struct crypto_container));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cont->sign.id_pub == id || cont->sign.id_prv == id || cont->sign.id_cert == id)   {\n\t\t\tif (ccont)\n\t\t\t\tmemcpy(ccont, &cont->sign, sizeof(struct crypto_container));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn cont ? 0 : SC_ERROR_TEMPLATE_NOT_FOUND;\n}\n\n\nstatic int\nsc_oberthur_get_certificate_authority(struct sc_pkcs15_der *der, int *out_authority)\n{\n#ifdef ENABLE_OPENSSL\n\tX509\t*x;\n\tBUF_MEM buf_mem;\n\tBIO *bio = NULL;\n\tBASIC_CONSTRAINTS *bs = NULL;\n\n\tif (!der)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tbuf_mem.data = malloc(der->len);\n\tif (!buf_mem.data)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tmemcpy(buf_mem.data, der->value, der->len);\n\tbuf_mem.max = buf_mem.length = der->len;\n\n\tbio = BIO_new(BIO_s_mem());\n\tif (!bio) {\n\t\tfree(buf_mem.data);\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tBIO_set_mem_buf(bio, &buf_mem, BIO_NOCLOSE);\n\tx = d2i_X509_bio(bio, 0);\n\tBIO_free(bio);\n\tif (!x)\n\t\treturn SC_ERROR_INVALID_DATA;\n\n\tbs = (BASIC_CONSTRAINTS *)X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL);\n\tif (out_authority)\n\t\t*out_authority = (bs && bs->ca);\n\n\tX509_free(x);\n\n\treturn SC_SUCCESS;\n#else\n\treturn SC_ERROR_NOT_SUPPORTED;\n#endif\n}\n\n\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nsc_oberthur_parse_tokeninfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tchar label[0x21];\n\tunsigned flags;\n\tint ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!buff || len < 0x24)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot parse token info\");\n\n\tmemset(label, 0, sizeof(label));\n\n\tmemcpy(label, buff, 0x20);\n\tii = 0x20;\n\twhile (*(label + --ii)==' ' && ii)\n\t\t;\n\t*(label + ii + 1) = '\\0';\n\n\tflags = *(buff + 0x22) * 0x100 + *(buff + 0x23);\n\n\tset_string(&p15card->tokeninfo->label, label);\n\tset_string(&p15card->tokeninfo->manufacturer_id, \"Oberthur/OpenSC\");\n\n\tif (flags & 0x01)\n\t\tp15card->tokeninfo->flags |= SC_PKCS15_TOKEN_PRN_GENERATION;\n\n\tsc_log(ctx, \"label %s\", p15card->tokeninfo->label);\n\tsc_log(ctx, \"manufacturer_id %s\", p15card->tokeninfo->manufacturer_id);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\nsc_oberthur_parse_containers (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t offs;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\twhile (Containers)   {\n\t\tstruct container *next = Containers->next;\n\n\t\tfree (Containers);\n\t\tContainers = next;\n\t}\n\n\tfor (offs=0; offs < len;)  {\n\t\tstruct container *cont;\n\t\tunsigned char *ptr =  buff + offs + 2;\n\n\t\tsc_log(ctx,\n\t\t       \"parse contaniers offs:%\"SC_FORMAT_LEN_SIZE_T\"u, len:%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       offs, len);\n\t\tif (*(buff + offs) != 'R')\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\n\t\tcont = (struct container *)calloc(sizeof(struct container), 1);\n\t\tif (!cont)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\t\tcont->exchange.id_pub = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->exchange.id_prv = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->exchange.id_cert = *ptr * 0x100 + *(ptr + 1); ptr += 2;\n\n\t\tcont->sign.id_pub = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->sign.id_prv = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->sign.id_cert = *ptr * 0x100 + *(ptr + 1); ptr += 2;\n\n\t\tmemcpy(cont->uuid, ptr + 2, 36);\n\t\tsc_log(ctx, \"UUID: %s; 0x%X, 0x%X, 0x%X\", cont->uuid,\n\t\t\t\tcont->exchange.id_pub, cont->exchange.id_prv, cont->exchange.id_cert);\n\n\t\tif (!Containers)  {\n\t\t\tContainers = cont;\n\t\t}\n\t\telse   {\n\t\t\tcont->next = Containers;\n\t\t\tContainers->prev = (void *)cont;\n\t\t\tContainers = cont;\n\t\t}\n\n\t\toffs += *(buff + offs + 1) + 2;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\nsc_oberthur_parse_publicinfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t ii;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tfor (ii=0; ii<len; ii+=5)   {\n\t\tunsigned int file_id, size;\n\n\t\tif(*(buff+ii) != 0xFF)\n\t\t\tcontinue;\n\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add public object(file-id:%04X,size:%X)\", file_id, size);\n\n\t\tswitch (*(buff+ii + 1))   {\n\t\tcase BASE_ID_PUB_RSA :\n\t\t\trv = sc_pkcs15emu_oberthur_add_pubkey(p15card, file_id, size);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse public key info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_CERT :\n\t\t\trv = sc_pkcs15emu_oberthur_add_cert(p15card, file_id);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse certificate info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_PUB_DES :\n\t\t\tbreak;\n\t\tcase BASE_ID_PUB_DATA :\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 0);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse data info\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Public object parse error\");\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\nsc_oberthur_parse_privateinfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t ii;\n\tint rv;\n\tint no_more_private_keys = 0, no_more_private_data = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor (ii=0; ii<len; ii+=5)   {\n\t\tunsigned int file_id, size;\n\n\t\tif(*(buff+ii) != 0xFF)\n\t\t\tcontinue;\n\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add private object (file-id:%04X, size:%X)\", file_id, size);\n\n\t\tswitch (*(buff+ii + 1))   {\n\t\tcase BASE_ID_PRV_RSA :\n\t\t\tif (no_more_private_keys)\n\t\t\t\tbreak;\n\n\t\t\trv = sc_pkcs15emu_oberthur_add_prvkey(p15card, file_id, size);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tstruct sc_path path;\n\n\t\t\t\tsc_log(ctx, \"postpone adding of the private keys\");\n\t\t\t\tsc_format_path(\"5011A5A5\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_PRKDF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add PrkDF error\");\n\t\t\t\tno_more_private_keys = 1;\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private key info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_PRV_DES :\n\t\t\tbreak;\n\t\tcase BASE_ID_PRV_DATA :\n\t\t\tsc_log(ctx, \"*(buff+ii + 1):%X\", *(buff+ii + 1));\n\t\t\tif (no_more_private_data)\n\t\t\t\tbreak;\n\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 1);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tstruct sc_path path;\n\n\t\t\t\tsc_log(ctx, \"postpone adding of the private data\");\n\t\t\t\tsc_format_path(\"5011A6A6\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_DODF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add DODF error\");\n\t\t\t\tno_more_private_data = 1;\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private data info\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Private object parse error\");\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\n/* Public key info:\n * \tflags:2,\n * \tCN(len:2,value:<variable length>),\n * \tID(len:2,value:(SHA1 value)),\n * \tStartDate(Ascii:8)\n * \tEndDate(Ascii:8)\n * \t??(0x00:2)\n */\nstatic int\nsc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_pubkey_info key_info;\n\tstruct sc_pkcs15_object key_obj;\n\tchar ch_tmp[0x100];\n\tunsigned char *info_blob;\n\tsize_t len, info_len, offs;\n\tunsigned flags;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"public key(file-id:%04X,size:%X)\", file_id, size);\n\n\tmemset(&key_info, 0, sizeof(key_info));\n\tmemset(&key_obj, 0, sizeof(key_obj));\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add public key: read oberthur file error\");\n\n\t/* Flags */\n\toffs = 2;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\tkey_info.usage = sc_oberthur_decode_usage(flags);\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tkey_obj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE;\n\tsc_log(ctx, \"Public key key-usage:%04X\", key_info.usage);\n\n\t/* Label */\n\tif (offs + 2 > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'Label'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tif (len > sizeof(key_obj.label) - 1)\n\t\t\tlen = sizeof(key_obj.label) - 1;\n\t\tmemcpy(key_obj.label, info_blob + offs + 2, len);\n\t}\n\toffs += 2 + len;\n\n\t/* ID */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (!len || len > sizeof(key_info.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add public key: invalid 'ID' length\");\n\tmemcpy(key_info.id.value, info_blob + offs + 2, len);\n\tkey_info.id.len = len;\n\n\t/* Ignore Start/End dates */\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &key_info.path);\n\n\tkey_info.native = 1;\n\tkey_info.key_reference = file_id & 0xFF;\n\tkey_info.modulus_length = size;\n\n\trv = sc_pkcs15emu_add_rsa_pubkey(p15card, &key_obj, &key_info);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\n/* Certificate info:\n * \tflags:2,\n * \tLabel(len:2,value:),\n * \tID(len:2,value:(SHA1 value)),\n * \tSubject in ASN.1(len:2,value:)\n * \tIssuer in ASN.1(len:2,value:)\n * \tSerial encoded in LV or ASN.1\tFIXME\n */\nstatic int\nsc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *p15card, unsigned int file_id)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_cert_info cinfo;\n\tstruct sc_pkcs15_object cobj;\n\tunsigned char *info_blob, *cert_blob;\n\tsize_t info_len, cert_len, len, offs;\n\tunsigned flags;\n\tint rv;\n\tchar ch_tmp[0x20];\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add certificate(file-id:%04X)\", file_id);\n\n\tmemset(&cinfo, 0, sizeof(cinfo));\n\tmemset(&cobj, 0, sizeof(cobj));\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read oberthur file error\");\n\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\n\t/* Label */\n\tif (offs + 2 > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'CN'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tif (len > sizeof(cobj.label) - 1)\n\t\t\tlen = sizeof(cobj.label) - 1;\n\t\tmemcpy(cobj.label, info_blob + offs + 2, len);\n\t}\n\toffs += 2 + len;\n\n\t/* ID */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len > sizeof(cinfo.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add certificate: invalid 'ID' length\");\n\tmemcpy(cinfo.id.value, info_blob + offs + 2, len);\n\tcinfo.id.len = len;\n\n\t/* Ignore subject, issuer and serial */\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &cinfo.path);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &cert_blob, &cert_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read certificate error\");\n\n\tcinfo.value.value = cert_blob;\n\tcinfo.value.len = cert_len;\n\n\trv = sc_oberthur_get_certificate_authority(&cinfo.value, &cinfo.authority);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: get certificate attributes error\");\n\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tcobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\trv = sc_pkcs15emu_add_x509_cert(p15card, &cobj, &cinfo);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\n\n/* Private key info:\n * \tflags:2,\n * \tCN(len:2,value:),\n * \tID(len:2,value:(SHA1 value)),\n * \tStartDate(Ascii:8)\n * \tEndDate(Ascii:8)\n * \tSubject in ASN.1(len:2,value:)\n * \tmodulus(value:)\n *\texponent(length:1, value:3)\n */\nstatic int\nsc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info kinfo;\n\tstruct sc_pkcs15_object kobj;\n\tstruct crypto_container ccont;\n\tunsigned char *info_blob = NULL;\n\tsize_t info_len = 0;\n\tunsigned flags;\n\tsize_t offs, len;\n\tchar ch_tmp[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add private key(file-id:%04X,size:%04X)\", file_id, size);\n\n\tmemset(&kinfo, 0, sizeof(kinfo));\n\tmemset(&kobj, 0, sizeof(kobj));\n\tmemset(&ccont, 0, sizeof(ccont));\n\n\trv = sc_oberthur_get_friends (file_id, &ccont);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: get friends error\");\n\n\tif (ccont.id_cert)   {\n\t\tstruct sc_pkcs15_object *objs[32];\n\t\tint ii;\n\n\t\tsc_log(ctx, \"friend certificate %04X\", ccont.id_cert);\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_CERT_X509, objs, 32);\n\t\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: get certificates error\");\n\n\t\tfor (ii=0; ii<rv; ii++) {\n\t\t\tstruct sc_pkcs15_cert_info *cert = (struct sc_pkcs15_cert_info *)objs[ii]->data;\n\t\t\tstruct sc_path path = cert->path;\n\t\t\tunsigned int id = path.value[path.len - 2] * 0x100 + path.value[path.len - 1];\n\n\t\t\tif (id == ccont.id_cert)   {\n\t\t\t\tstrlcpy(kobj.label, objs[ii]->label, sizeof(kobj.label));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ii == rv)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, \"Failed to add private key: friend not found\");\n\t}\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: read oberthur file error\");\n\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\n\t/* CN */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'CN'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len && !strlen(kobj.label))   {\n\t\tif (len > sizeof(kobj.label) - 1)\n\t\t\tlen = sizeof(kobj.label) - 1;\n\t\tstrncpy(kobj.label, (char *)(info_blob + offs + 2), len);\n\t}\n\toffs += 2 + len;\n\n\t/* ID */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (!len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: zero length ID\");\n\telse if (len > sizeof(kinfo.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add private key: invalid ID length\");\n\tmemcpy(kinfo.id.value, info_blob + offs + 2, len);\n\tkinfo.id.len = len;\n\toffs += 2 + len;\n\n\t/* Ignore Start/End dates */\n\toffs += 16;\n\n\t/* Subject encoded in ASN1 */\n\tif (offs > info_len)\n\t\treturn SC_ERROR_UNKNOWN_DATA_RECEIVED;\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tkinfo.subject.value = malloc(len);\n\t\tif (!kinfo.subject.value)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Failed to add private key: memory allocation error\");\n\t\tkinfo.subject.len = len;\n\t\tmemcpy(kinfo.subject.value, info_blob + offs + 2, len);\n\t}\n\n\t/* Modulus and exponent are ignored */\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id);\n\tsc_format_path(ch_tmp, &kinfo.path);\n\tsc_log(ctx, \"Private key info path %s\", ch_tmp);\n\n\tkinfo.modulus_length\t= size;\n\tkinfo.native\t\t= 1;\n\tkinfo.key_reference\t = file_id & 0xFF;\n\n\tkinfo.usage = sc_oberthur_decode_usage(flags);\n\tkobj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tkobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tkobj.auth_id.len = sizeof(PinDomainID) > sizeof(kobj.auth_id.value)\n\t\t\t? sizeof(kobj.auth_id.value) : sizeof(PinDomainID);\n\tmemcpy(kobj.auth_id.value, PinDomainID, kobj.auth_id.len);\n\n\tsc_log(ctx, \"Parsed private key(reference:%i,usage:%X,flags:%X)\", kinfo.key_reference, kinfo.usage, kobj.flags);\n\n\trv = sc_pkcs15emu_add_rsa_prkey(p15card, &kobj, &kinfo);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nsc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size, int private)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_data_info dinfo;\n\tstruct sc_pkcs15_object dobj;\n\tunsigned flags;\n\tunsigned char *info_blob = NULL, *label = NULL, *app = NULL, *oid = NULL;\n\tsize_t info_len, label_len, app_len, oid_len, offs;\n\tchar ch_tmp[0x100];\n\tint rv;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(ctx, \"Add data(file-id:%04X,size:%i,is-private:%i)\", file_id, size, private);\n\tmemset(&dinfo, 0, sizeof(dinfo));\n\tmemset(&dobj, 0, sizeof(dobj));\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add data: read oberthur file error\");\n\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\n\t/* Label */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'label'\");\n\tlabel = info_blob + offs + 2;\n\tlabel_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (label_len > sizeof(dobj.label) - 1)\n\t\tlabel_len = sizeof(dobj.label) - 1;\n\toffs += 2 + *(info_blob + offs + 1);\n\n\t/* Application */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'application'\");\n\tapp = info_blob + offs + 2;\n\tapp_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (app_len > sizeof(dinfo.app_label) - 1)\n\t\tapp_len = sizeof(dinfo.app_label) - 1;\n\toffs += 2 + app_len;\n\n\t/* OID encode like DER(ASN.1(oid)) */\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'OID'\");\n\toid_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (oid_len)   {\n\t\toid = info_blob + offs + 2;\n\t\tif (*oid != 0x06 || (*(oid + 1) != oid_len - 2))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: invalid 'OID' format\");\n\t\toid += 2;\n\t\toid_len -= 2;\n\t}\n\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id);\n\n\tsc_format_path(ch_tmp, &dinfo.path);\n\n\tmemcpy(dobj.label, label, label_len);\n\tmemcpy(dinfo.app_label, app, app_len);\n\tif (oid_len)\n\t\tsc_asn1_decode_object_id(oid, oid_len, &dinfo.app_oid);\n\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tif (private)   {\n\t\tdobj.auth_id.len = sizeof(PinDomainID) > sizeof(dobj.auth_id.value)\n\t\t\t\t? sizeof(dobj.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(dobj.auth_id.value, PinDomainID, dobj.auth_id.len);\n\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_PRIVATE;\n\t}\n\n\trv = sc_pkcs15emu_add_data_object(p15card, &dobj, &dinfo);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\n\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\noberthur_detect_card(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_card *card = p15card->card;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (p15card->card->type != SC_CARD_TYPE_OBERTHUR_64K)\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_WRONG_CARD);\n\tLOG_FUNC_RETURN(p15card->card->ctx, SC_SUCCESS);\n}\n\n\nint\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\n\nstatic int\nsc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *buf = NULL;\n\tsize_t buf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tif (df->enumerated)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\trv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: read private objects info failed\");\n\n\trv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);\n\n\tif (buf)\n\t\tfree(buf);\n\n\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: private info parse error\");\n\tdf->enumerated = 1;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic void\nsc_awp_clear(struct sc_pkcs15_card *p15card)\n{\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n}\n"], "filenames": ["src/libopensc/pkcs15-oberthur.c"], "buggy_code_start_loc": [274], "buggy_code_end_loc": [278], "fixing_code_start_loc": [274], "fixing_code_end_loc": [283], "type": "CWE-787", "message": "The Oberthur smart card software driver in OpenSC before 0.21.0-rc1 has a heap-based buffer overflow in sc_oberthur_read_file.", "other": {"cve": {"id": "CVE-2020-26570", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-06T02:15:12.990", "lastModified": "2021-11-29T17:30:06.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Oberthur smart card software driver in OpenSC before 0.21.0-rc1 has a heap-based buffer overflow in sc_oberthur_read_file."}, {"lang": "es", "value": "El controlador de software de la tarjeta inteligente Oberthur en OpenSC versiones anteriores a 0.21.0-rc1, presenta un desbordamiento en la regi\u00f3n stack de la memoria en la funci\u00f3n sc_oberthur_read_file"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.20.0", "matchCriteriaId": "E3923253-943B-433F-B8B8-A78697C322FC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2020/11/24/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24316", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00027.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EXOHFDMNMO6IDECAGUTB3SJGAGXVRT6S/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e"}}