{"buggy_code": ["#include \"MCWin32.h\" // Should be included first.\n\n#include \"MCIMAPSession.h\"\n\n#include <libetpan/libetpan.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"MCDefines.h\"\n#include \"MCIMAPSearchExpression.h\"\n#include \"MCIMAPFolder.h\"\n#include \"MCIMAPMessage.h\"\n#include \"MCIMAPPart.h\"\n#include \"MCMessageHeader.h\"\n#include \"MCAbstractPart.h\"\n#include \"MCIMAPProgressCallback.h\"\n#include \"MCIMAPNamespace.h\"\n#include \"MCIMAPSyncResult.h\"\n#include \"MCIMAPFolderStatus.h\"\n#include \"MCConnectionLogger.h\"\n#include \"MCConnectionLoggerUtils.h\"\n#include \"MCHTMLRenderer.h\"\n#include \"MCString.h\"\n#include \"MCUtils.h\"\n#include \"MCHTMLRendererIMAPDataCallback.h\"\n#include \"MCHTMLBodyRendererTemplateCallback.h\"\n#include \"MCCertificateUtils.h\"\n#include \"MCIMAPIdentity.h\"\n#include \"MCLibetpan.h\"\n#include \"MCDataStreamDecoder.h\"\n\nusing namespace mailcore;\n\nclass LoadByChunkProgress : public Object, public IMAPProgressCallback {\npublic:\n    LoadByChunkProgress();\n    virtual ~LoadByChunkProgress();\n\n    virtual void setOffset(uint32_t offset);\n    virtual void setEstimatedSize(uint32_t estimatedSize);\n    virtual void setProgressCallback(IMAPProgressCallback * progressCallback);\n\n    virtual void bodyProgress(IMAPSession * session, unsigned int current, unsigned int maximum);\n\nprivate:\n    uint32_t mOffset;\n    uint32_t mEstimatedSize;\n    IMAPProgressCallback * mProgressCallback; // non retained\n};\n\nLoadByChunkProgress::LoadByChunkProgress()\n{\n    mOffset = 0;\n    mEstimatedSize = 0;\n    mProgressCallback = NULL;\n}\n\nLoadByChunkProgress::~LoadByChunkProgress()\n{\n}\n\nvoid LoadByChunkProgress::setOffset(uint32_t offset)\n{\n    mOffset = offset;\n}\n\nvoid LoadByChunkProgress::setEstimatedSize(uint32_t estimatedSize)\n{\n    mEstimatedSize = estimatedSize;\n}\n\nvoid LoadByChunkProgress::setProgressCallback(IMAPProgressCallback * progressCallback)\n{\n    mProgressCallback = progressCallback;\n}\n\nvoid LoadByChunkProgress::bodyProgress(IMAPSession * session, unsigned int current, unsigned int maximum)\n{\n    // In case of loading attachment by chunks we need report overall progress\n    if (mEstimatedSize > 0 && mEstimatedSize > maximum) {\n        maximum = mEstimatedSize;\n        current += mOffset;\n    }\n    mProgressCallback->bodyProgress(session, current, maximum);\n}\n\nenum {\n    STATE_DISCONNECTED,\n    STATE_CONNECTED,\n    STATE_LOGGEDIN,\n    STATE_SELECTED,\n};\n\nString * mailcore::IMAPNamespacePersonal = NULL;\nString * mailcore::IMAPNamespaceOther = NULL;\nString * mailcore::IMAPNamespaceShared = NULL;\n\nstatic Array * resultsWithError(int r, clist * list, ErrorCode * pError);\n\nINITIALIZE(IMAPSEssion)\n{\n    AutoreleasePool * pool = new AutoreleasePool();\n    IMAPNamespacePersonal = (String *) MCSTR(\"IMAPNamespacePersonal\")->retain();\n    IMAPNamespaceOther = (String *) MCSTR(\"IMAPNamespaceOther\")->retain();\n    IMAPNamespaceShared = (String *) MCSTR(\"IMAPNamespaceShared\")->retain();\n    \n    pool->release();\n}\n\n#define MAX_IDLE_DELAY (9 * 60)\n\n#define LOCK() pthread_mutex_lock(&mIdleLock)\n#define UNLOCK() pthread_mutex_unlock(&mIdleLock)\n\nstatic struct mailimap_flag_list * flags_to_lep(MessageFlag value)\n{\n    struct mailimap_flag_list * flag_list;\n    \n    flag_list = mailimap_flag_list_new_empty();\n    \n    if ((value & MessageFlagSeen) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_seen());\n    }\n    \n    if ((value & MessageFlagFlagged) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flagged());\n    }\n    \n    if ((value & MessageFlagDeleted) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_deleted());\n    }\n    \n    if ((value & MessageFlagAnswered) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_answered());\n    }\n    \n    if ((value & MessageFlagDraft) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_draft());\n    }\n    \n    if ((value & MessageFlagForwarded) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$Forwarded\")));\n    }\n    \n    if ((value & MessageFlagMDNSent) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$MDNSent\")));\n    }\n    \n    if ((value & MessageFlagSubmitPending) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$SubmitPending\")));\n    }\n    \n    if ((value & MessageFlagSubmitted) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$Submitted\")));\n    }\n    \n    return flag_list;\n}\n\nstatic MessageFlag flag_from_lep(struct mailimap_flag * flag)\n{\n    switch (flag->fl_type) {\n        case MAILIMAP_FLAG_ANSWERED:\n            return MessageFlagAnswered;\n        case MAILIMAP_FLAG_FLAGGED:\n            return MessageFlagFlagged;\n        case MAILIMAP_FLAG_DELETED:\n            return MessageFlagDeleted;\n        case MAILIMAP_FLAG_SEEN:\n            return MessageFlagSeen;\n        case MAILIMAP_FLAG_DRAFT:\n            return MessageFlagDraft;\n        case MAILIMAP_FLAG_KEYWORD:\n            if (strcasecmp(flag->fl_data.fl_keyword, \"$Forwarded\") == 0) {\n                return MessageFlagForwarded;\n            }\n            else if (strcasecmp(flag->fl_data.fl_keyword, \"$MDNSent\") == 0) {\n                return MessageFlagMDNSent;\n            }\n            else if (strcasecmp(flag->fl_data.fl_keyword, \"$SubmitPending\") == 0) {\n                return MessageFlagSubmitPending;\n            }\n            else if (strcasecmp(flag->fl_data.fl_keyword, \"$Submitted\") == 0) {\n                return MessageFlagSubmitted;\n            }\n    }\n    \n    return MessageFlagNone;\n}\n\nstatic MessageFlag flags_from_lep_att_dynamic(struct mailimap_msg_att_dynamic * att_dynamic)\n{\n    if (att_dynamic->att_list == NULL)\n        return MessageFlagNone;\n    \n    MessageFlag flags;\n    clistiter * iter;\n    \n    flags = MessageFlagNone;\n    for(iter = clist_begin(att_dynamic->att_list) ;iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_flag_fetch * flag_fetch;\n        struct mailimap_flag * flag;\n        \n        flag_fetch = (struct mailimap_flag_fetch *) clist_content(iter);\n        if (flag_fetch->fl_type != MAILIMAP_FLAG_FETCH_OTHER) {\n            continue;\n        }\n        \n        flag = flag_fetch->fl_flag;\n        flags = (MessageFlag) (flags | flag_from_lep(flag));\n    }\n    \n    return flags;\n}\n\nstatic bool isKnownCustomFlag(const char * keyword)\n{\n    return !(strcmp(keyword, \"$MDNSent\") != 0 && strcmp(keyword, \"$Forwarded\") != 0 && strcmp(keyword, \"$SubmitPending\") != 0 && strcmp(keyword, \"$Submitted\") != 0);\n}\n\nstatic Array * custom_flags_from_lep_att_dynamic(struct mailimap_msg_att_dynamic * att_dynamic)\n{\n    if (att_dynamic->att_list == NULL)\n        return NULL;\n    \n    clistiter * iter;\n    bool hasCustomFlags = false;\n    \n    for (iter = clist_begin(att_dynamic->att_list); iter != NULL; iter = clist_next(iter)) {\n        struct mailimap_flag_fetch * flag_fetch;\n        struct mailimap_flag * flag;\n        \n        flag_fetch = (struct mailimap_flag_fetch *) clist_content(iter);\n        if (flag_fetch->fl_type != MAILIMAP_FLAG_FETCH_OTHER) {\n            continue;\n        }\n        \n        flag = flag_fetch->fl_flag;\n        if (flag->fl_type == MAILIMAP_FLAG_KEYWORD) {\n            if (!isKnownCustomFlag(flag->fl_data.fl_keyword)) {\n                hasCustomFlags = true;\n            }\n        }\n    }\n    \n    if (!hasCustomFlags)\n        return NULL;\n    \n    Array * result = Array::array();\n    for (iter = clist_begin(att_dynamic->att_list); iter != NULL; iter = clist_next(iter)) {\n        struct mailimap_flag_fetch * flag_fetch;\n        struct mailimap_flag * flag;\n        \n        flag_fetch = (struct mailimap_flag_fetch *) clist_content(iter);\n        if (flag_fetch->fl_type != MAILIMAP_FLAG_FETCH_OTHER) {\n            continue;\n        }\n        \n        flag = flag_fetch->fl_flag;\n        if (flag->fl_type == MAILIMAP_FLAG_KEYWORD) {\n            if (!isKnownCustomFlag(flag->fl_data.fl_keyword)) {\n                String * customFlag;\n                customFlag = String::stringWithUTF8Characters(flag->fl_data.fl_keyword);\n                result->addObject(customFlag);\n            }\n        }\n    }\n    \n    return result;\n}\n\n#pragma mark set conversion\n\nstatic Array * arrayFromSet(struct mailimap_set * imap_set)\n{\n    Array * result;\n    clistiter * iter;\n    \n    result = Array::array();\n    for(iter = clist_begin(imap_set->set_list) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set_item * item;\n        unsigned long i;\n        \n        item = (struct mailimap_set_item *) clist_content(iter);\n        for(i = item->set_first ; i <= item->set_last ; i ++) {\n            Value * nb;\n            \n            nb = Value::valueWithUnsignedLongValue(i);\n            result->addObject(nb);\n        }\n    }\n    \n    return result;\n}\n\nstatic clist * splitSet(struct mailimap_set * set, unsigned int splitCount)\n{\n    struct mailimap_set * current_set;\n    clist * result;\n    unsigned int count;\n    \n    result = clist_new();\n    \n    current_set = NULL;\n    count = 0;\n    for(clistiter * iter = clist_begin(set->set_list) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set_item * item;\n        \n        if (current_set == NULL) {\n            current_set = mailimap_set_new_empty();\n        }\n        \n        item = (struct mailimap_set_item *) clist_content(iter);\n        mailimap_set_add_interval(current_set, item->set_first, item->set_last);\n        count ++;\n        \n        if (count >= splitCount) {\n            clist_append(result, current_set);\n            current_set = NULL;\n            count = 0;\n        }\n    }\n    if (current_set != NULL) {\n        clist_append(result, current_set);\n    }\n    \n    return result;\n}\n\nstatic struct mailimap_set * setFromIndexSet(IndexSet * indexSet)\n{\n    struct mailimap_set * imap_set;\n    \n    imap_set = mailimap_set_new_empty();\n    for(unsigned int i = 0 ; i < indexSet->rangesCount() ; i ++) {\n        uint64_t left = RangeLeftBound(indexSet->allRanges()[i]);\n        uint64_t right = RangeRightBound(indexSet->allRanges()[i]);\n        if (right == UINT64_MAX) {\n            right = 0;\n        }\n        mailimap_set_add_interval(imap_set, (uint32_t) left, (uint32_t) right);\n    }\n    \n    return imap_set;\n}\n\nstatic IndexSet * indexSetFromSet(struct mailimap_set * imap_set)\n{\n    IndexSet * indexSet = IndexSet::indexSet();\n    for(clistiter * cur = clist_begin(imap_set->set_list) ; cur != NULL ; cur = clist_next(cur)) {\n        struct mailimap_set_item * item = (struct mailimap_set_item *) clist_content(cur);\n        if (item->set_last == 0) {\n            indexSet->addRange(RangeMake(item->set_first, UINT64_MAX));\n        }\n        else {\n            indexSet->addRange(RangeMake(item->set_first, item->set_last - item->set_first));\n        }\n    }\n    return indexSet;\n}\n\nvoid IMAPSession::init()\n{\n    mHostname = NULL;\n    mPort = 0;\n    mUsername = NULL;\n    mPassword = NULL;\n    mOAuth2Token = NULL;\n    mAuthType = AuthTypeSASLNone;\n    mConnectionType = ConnectionTypeClear;\n    mCheckCertificateEnabled = true;\n    mIsCertificateValid = true;\n    mVoIPEnabled = true;\n    mDelimiter = 0;\n    \n    mBodyProgressEnabled = true;\n    mIdleEnabled = false;\n    mXListEnabled = false;\n    mQResyncEnabled = false;\n    mCondstoreEnabled = false;\n    mXYMHighestModseqEnabled = false;\n    mIdentityEnabled = false;\n    mNamespaceEnabled = false;\n    mCompressionEnabled = false;\n    mIsGmail = false;\n    mAllowsNewPermanentFlags = false;\n    mWelcomeString = NULL;\n    mNeedsMboxMailWorkaround = false;\n    mDefaultNamespace = NULL;\n    mFetchedNamespace = NULL;\n    mFetchedIdentity = NULL;\n    mServerIdentity = new IMAPIdentity();\n    mClientIdentity = new IMAPIdentity();\n    mTimeout = 30;\n    mUIDValidity = 0;\n    mUIDNext = 0;\n    mModSequenceValue = 0;\n    mFolderMsgCount = 0;\n    mFirstUnseenUid = 0;\n    mYahooServer = false;\n    mRamblerRuServer = false;\n    mHermesServer = false;\n    mQipServer = false;\n    mLastFetchedSequenceNumber = 0;\n    mCurrentFolder = NULL;\n    mCurrentCapabilities = NULL;\n    pthread_mutex_init(&mIdleLock, NULL);\n    mState = STATE_DISCONNECTED;\n    mImap = NULL;\n    mProgressCallback = NULL;\n    mProgressItemsCount = 0;\n    mConnectionLogger = NULL;\n    pthread_mutex_init(&mConnectionLoggerLock, NULL);\n    mAutomaticConfigurationEnabled = true;\n    mAutomaticConfigurationDone = false;\n    mShouldDisconnect = false;\n    mNeedsReselect = false;\n    mLoginResponse = NULL;\n    mGmailUserDisplayName = NULL;\n    mUnparsedResponseData = NULL;\n}\n\nIMAPSession::IMAPSession()\n{\n    init();\n}\n\nIMAPSession::~IMAPSession()\n{\n    MC_SAFE_RELEASE(mUnparsedResponseData);\n    MC_SAFE_RELEASE(mGmailUserDisplayName);\n    MC_SAFE_RELEASE(mLoginResponse);\n    MC_SAFE_RELEASE(mFetchedIdentity);\n    MC_SAFE_RELEASE(mClientIdentity);\n    MC_SAFE_RELEASE(mServerIdentity);\n    MC_SAFE_RELEASE(mHostname);\n    MC_SAFE_RELEASE(mUsername);\n    MC_SAFE_RELEASE(mPassword);\n    MC_SAFE_RELEASE(mOAuth2Token);\n    MC_SAFE_RELEASE(mWelcomeString);\n    MC_SAFE_RELEASE(mDefaultNamespace);\n    MC_SAFE_RELEASE(mFetchedNamespace);\n    MC_SAFE_RELEASE(mCurrentFolder);\n    MC_SAFE_RELEASE(mCurrentCapabilities);\n    pthread_mutex_destroy(&mIdleLock);\n    pthread_mutex_destroy(&mConnectionLoggerLock);\n}\n\nvoid IMAPSession::setHostname(String * hostname)\n{\n    MC_SAFE_REPLACE_COPY(String, mHostname, hostname);\n}\n\nString * IMAPSession::hostname()\n{\n    return mHostname;\n}\n\nvoid IMAPSession::setPort(unsigned int port)\n{\n    mPort = port;\n}\n\nunsigned int IMAPSession::port()\n{\n    return mPort;\n}\n\nvoid IMAPSession::setUsername(String * username)\n{\n    MC_SAFE_REPLACE_COPY(String, mUsername, username);\n}\n\nString * IMAPSession::username()\n{\n    return mUsername;\n}\n\nvoid IMAPSession::setPassword(String * password)\n{\n    MC_SAFE_REPLACE_COPY(String, mPassword, password);\n}\n\nString * IMAPSession::password()\n{\n    return mPassword;\n}\n\nvoid IMAPSession::setOAuth2Token(String * token)\n{\n    MC_SAFE_REPLACE_COPY(String, mOAuth2Token, token);\n}\n\nString * IMAPSession::OAuth2Token()\n{\n    return mOAuth2Token;\n}\n\nvoid IMAPSession::setAuthType(AuthType authType)\n{\n    mAuthType = authType;\n}\n\nAuthType IMAPSession::authType()\n{\n    return mAuthType;\n}\n\nvoid IMAPSession::setConnectionType(ConnectionType connectionType)\n{\n    mConnectionType = connectionType;\n}\n\nConnectionType IMAPSession::connectionType()\n{\n    return mConnectionType;\n}\n\nvoid IMAPSession::setTimeout(time_t timeout)\n{\n    mTimeout = timeout;\n}\n\ntime_t IMAPSession::timeout()\n{\n    return mTimeout;\n}\n\nvoid IMAPSession::setCheckCertificateEnabled(bool enabled)\n{\n    mCheckCertificateEnabled = enabled;\n}\n\nbool IMAPSession::isCheckCertificateEnabled()\n{\n    return mCheckCertificateEnabled;\n}\n\nbool IMAPSession::isCertificateValid()\n{\n    return mIsCertificateValid;\n}\n\nvoid IMAPSession::setVoIPEnabled(bool enabled)\n{\n    mVoIPEnabled = enabled;\n}\n\nbool IMAPSession::isVoIPEnabled()\n{\n    return mVoIPEnabled;\n}\n\nString * IMAPSession::loginResponse()\n{\n    return mLoginResponse;\n}\n\nData * IMAPSession::unparsedResponseData()\n{\n    return mUnparsedResponseData;\n}\n\nstatic bool hasError(int errorCode)\n{\n    return ((errorCode != MAILIMAP_NO_ERROR) && (errorCode != MAILIMAP_NO_ERROR_AUTHENTICATED) &&\n            (errorCode != MAILIMAP_NO_ERROR_NON_AUTHENTICATED));\n}\n\nbool IMAPSession::checkCertificate()\n{\n    return mailcore::checkCertificate(mImap->imap_stream, hostname());\n}\n\nvoid IMAPSession::body_progress(size_t current, size_t maximum, void * context)\n{\n    IMAPSession * session;\n    \n    session = (IMAPSession *) context;\n    session->bodyProgress((unsigned int) current, (unsigned int) maximum);\n}\n\nvoid IMAPSession::items_progress(size_t current, size_t maximum, void * context)\n{\n    IMAPSession * session;\n    \n    session = (IMAPSession *) context;\n    session->itemsProgress((unsigned int) current, (unsigned int) maximum);\n}\n\nstatic void logger(mailimap * imap, int log_type, const char * buffer, size_t size, void * context)\n{\n    IMAPSession * session = (IMAPSession *) context;\n    session->lockConnectionLogger();\n\n    if (session->connectionLoggerNoLock() == NULL) {\n        session->unlockConnectionLogger();\n        return;\n    }\n    \n    ConnectionLogType type = getConnectionType(log_type);\n    if ((int) type == -1) {\n        session->unlockConnectionLogger();\n        return;\n    }\n    \n    bool isBuffer = isBufferFromLogType(log_type);\n\n    if (isBuffer) {\n        AutoreleasePool * pool = new AutoreleasePool();\n        Data * data = Data::dataWithBytes(buffer, (unsigned int) size);\n        session->connectionLoggerNoLock()->log(session, type, data);\n        pool->release();\n    }\n    else {\n        session->connectionLoggerNoLock()->log(session, type, NULL);\n    }\n    session->unlockConnectionLogger();\n}\n\nvoid IMAPSession::setup()\n{\n    if (mImap != NULL) {\n        unsetup();\n    }\n    \n    mImap = mailimap_new(0, NULL);\n    mailimap_set_timeout(mImap, timeout());\n    mailimap_set_progress_callback(mImap, body_progress, IMAPSession::items_progress, this);\n    mailimap_set_logger(mImap, logger, this);\n}\n\nvoid IMAPSession::unsetup()\n{\n    mailimap * imap;\n    \n    LOCK();\n    imap = mImap;\n    mImap = NULL;\n    mIdleEnabled = false;\n    UNLOCK();\n    \n    if (imap != NULL) {\n        if (imap->imap_stream != NULL) {\n            mailstream_close(imap->imap_stream);\n            imap->imap_stream = NULL;\n        }\n        mailimap_free(imap);\n        imap = NULL;\n    }\n    \n    mState = STATE_DISCONNECTED;\n}\n\nvoid IMAPSession::connect(ErrorCode * pError)\n{\n    int r;\n    \n    setup();\n\n    MCLog(\"connect %s\", MCUTF8DESC(this));\n\n    MCAssert(mState == STATE_DISCONNECTED);\n\n    if (mHostname == NULL) {\n        * pError = ErrorInvalidAccount;\n        goto close;\n    }\n    \n    switch (mConnectionType) {\n        case ConnectionTypeStartTLS:\n        MCLog(\"STARTTLS connect\");\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        if (hasError(r)) {\n            * pError = ErrorConnection;\n            goto close;\n        }\n\n        r = mailimap_socket_starttls(mImap);\n        if (hasError(r)) {\n            MCLog(\"no TLS %i\", r);\n            * pError = ErrorTLSNotAvailable;\n            goto close;\n        }\n        break;\n\n        case ConnectionTypeTLS:\n        r = mailimap_ssl_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"ssl connect %s %u %u\", MCUTF8(mHostname), mPort, r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n            \n        mIsCertificateValid = checkCertificate();\n        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n            * pError = ErrorCertificate;\n            goto close;\n        }\n\n        break;\n\n        default:\n        MCLog(\"socket connect %s %u\", MCUTF8(mHostname), mPort);\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"socket connect %i\", r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n        break;\n    }\n    \n    mailstream_low * low;\n    String * identifierString;\n    char * identifier;\n    \n    low = mailstream_get_low(mImap->imap_stream);\n    identifierString = String::stringWithUTF8Format(\"%s@%s:%u\", MCUTF8(mUsername), MCUTF8(mHostname), mPort);\n    identifier = strdup(identifierString->UTF8Characters());\n    mailstream_low_set_identifier(low, identifier);\n    \n    if (mImap->imap_response != NULL) {\n        MC_SAFE_REPLACE_RETAIN(String, mWelcomeString, String::stringWithUTF8Characters(mImap->imap_response));\n        mYahooServer = (mWelcomeString->locationOfString(MCSTR(\"yahoo.com\")) != -1);\n#ifdef LIBETPAN_HAS_MAILIMAP_163_WORKAROUND\n        if (mWelcomeString->locationOfString(MCSTR(\"Coremail System IMap Server Ready\")) != -1)\n            mailimap_set_163_workaround_enabled(mImap, 1);\n#endif\n        if (mWelcomeString->locationOfString(MCSTR(\"Courier-IMAP\")) != -1) {\n            LOCK();\n            mIdleEnabled = true;\n            UNLOCK();\n            mNamespaceEnabled = true;\n        }\n        mRamblerRuServer = (mHostname->locationOfString(MCSTR(\".rambler.ru\")) != -1);\n        mHermesServer = (mWelcomeString->locationOfString(MCSTR(\"Hermes\")) != -1);\n        mQipServer = (mWelcomeString->locationOfString(MCSTR(\"QIP IMAP server\")) != -1);\n    }\n    \n    mState = STATE_CONNECTED;\n    \n    if (isAutomaticConfigurationEnabled()) {\n        if (mCurrentCapabilities != NULL) {\n            applyCapabilities(mCurrentCapabilities);\n        } else {\n            IndexSet *capabilities = capability(pError);\n            if (* pError != ErrorNone) {\n                MCLog(\"capabilities failed\");\n                goto close;\n            } else {\n                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);\n                applyCapabilities(mCurrentCapabilities);\n            }\n        }\n    }\n    \n    * pError = ErrorNone;\n    MCLog(\"connect ok\");\n    return;\n    \nclose:\n    unsetup();\n}\n\nvoid IMAPSession::connectIfNeeded(ErrorCode * pError)\n{\n    if (mShouldDisconnect) {\n        disconnect();\n        mShouldDisconnect = false;\n    }\n    \n    if (mState == STATE_DISCONNECTED) {\n        connect(pError);\n    }\n    else {\n        * pError = ErrorNone;\n    }\n}\n\nvoid IMAPSession::loginIfNeeded(ErrorCode * pError)\n{\n    connectIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    if (mState == STATE_CONNECTED) {\n        login(pError);\n    }\n    else {\n        * pError = ErrorNone;\n    }\n}\n\nvoid IMAPSession::login(ErrorCode * pError)\n{\n    int r;\n    \n    MCLog(\"login\");\n    \n    MCAssert(mState == STATE_CONNECTED);\n\n    MC_SAFE_RELEASE(mLoginResponse);\n    MC_SAFE_RELEASE(mUnparsedResponseData);\n    \n    const char * utf8username;\n    const char * utf8password;\n    utf8username = MCUTF8(mUsername);\n    utf8password = MCUTF8(mPassword);\n    if (utf8username == NULL) {\n        utf8username = \"\";\n    }\n    if (utf8password == NULL) {\n        utf8password = \"\";\n    }\n    \n    switch (mAuthType) {\n        case 0:\n        default:\n            r = mailimap_login(mImap, utf8username, utf8password);\n            break;\n            \n        case AuthTypeSASLCRAMMD5:\n            r = mailimap_authenticate(mImap, \"CRAM-MD5\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLPlain:\n            r = mailimap_authenticate(mImap, \"PLAIN\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLGSSAPI:\n            // needs to be tested\n            r = mailimap_authenticate(mImap, \"GSSAPI\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL /* realm */);\n            break;\n            \n        case AuthTypeSASLDIGESTMD5:\n            r = mailimap_authenticate(mImap, \"DIGEST-MD5\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLLogin:\n            r = mailimap_authenticate(mImap, \"LOGIN\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLSRP:\n            r = mailimap_authenticate(mImap, \"SRP\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLNTLM:\n            r = mailimap_authenticate(mImap, \"NTLM\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL/* realm */);\n            break;\n            \n        case AuthTypeSASLKerberosV4:\n            r = mailimap_authenticate(mImap, \"KERBEROS_V4\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL/* realm */);\n            break;\n            \n        case AuthTypeXOAuth2:\n        case AuthTypeXOAuth2Outlook:\n            if (mOAuth2Token == NULL) {\n                r = MAILIMAP_ERROR_STREAM;\n            }\n            else {\n                r = mailimap_oauth2_authenticate(mImap, utf8username, MCUTF8(mOAuth2Token));\n            }\n            break;\n    }\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n\n        Data * unparsed_response = Data::data();\n        if (mImap->imap_stream_buffer != NULL) {\n            unparsed_response = Data::dataWithBytes(mImap->imap_stream_buffer->str, (unsigned int) mImap->imap_stream_buffer->len);\n        }\n        MC_SAFE_REPLACE_RETAIN(Data, mUnparsedResponseData, unparsed_response);\n\n        return;\n    }\n    else if (hasError(r)) {\n        String * response;\n        \n        response = MCSTR(\"\");\n        if (mImap->imap_response != NULL) {\n            response = String::stringWithUTF8Characters(mImap->imap_response);\n        }\n        MC_SAFE_REPLACE_COPY(String, mLoginResponse, response);\n        if (response->locationOfString(MCSTR(\"not enabled for IMAP use\")) != -1) {\n            * pError = ErrorGmailIMAPNotEnabled;\n        }\n        else if (response->locationOfString(MCSTR(\"IMAP access is disabled\")) != -1) {\n            * pError = ErrorGmailIMAPNotEnabled;\n        }\n        else if (response->locationOfString(MCSTR(\"bandwidth limits\")) != -1) {\n            * pError = ErrorGmailExceededBandwidthLimit;\n        }\n        else if (response->locationOfString(MCSTR(\"Too many simultaneous connections\")) != -1) {\n            * pError = ErrorGmailTooManySimultaneousConnections;\n        }\n        else if (response->locationOfString(MCSTR(\"Maximum number of connections\")) != -1) {\n            * pError = ErrorGmailTooManySimultaneousConnections;\n        }\n        else if (response->locationOfString(MCSTR(\"Application-specific password required\")) != -1) {\n            * pError = ErrorGmailApplicationSpecificPasswordRequired;\n        }\n        else if (response->locationOfString(MCSTR(\"http://me.com/move\")) != -1) {\n            * pError = ErrorMobileMeMoved;\n        }\n        else if (response->locationOfString(MCSTR(\"OCF12\")) != -1) {\n            * pError = ErrorYahooUnavailable;\n        }\n        else if (response->locationOfString(MCSTR(\"Login to your account via a web browser\")) != -1) {\n            * pError = ErrorOutlookLoginViaWebBrowser;\n        }\n        else if (response->locationOfString(MCSTR(\"Service temporarily unavailable\")) != -1) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n        }\n        else {\n            * pError = ErrorAuthentication;\n        }\n        return;\n    }\n    \n    String * loginResponse = MCSTR(\"\");\n    if (mIsGmail) {\n        if (mImap->imap_response != NULL) {\n            loginResponse = String::stringWithUTF8Characters(mImap->imap_response);\n            \n            int location = loginResponse->locationOfString(MCSTR(\" authenticated (Success)\"));\n            if (location != -1) {\n                String * emailAndName = loginResponse->substringToIndex(location);\n                location = emailAndName->locationOfString(MCSTR(\" \"));\n                MC_SAFE_RELEASE(mGmailUserDisplayName);\n                mGmailUserDisplayName = emailAndName->substringFromIndex(location + 1);\n                mGmailUserDisplayName->retain();\n            }\n        }\n    }\n    MC_SAFE_REPLACE_COPY(String, mLoginResponse, loginResponse);\n    \n    mState = STATE_LOGGEDIN;\n    \n    if (isAutomaticConfigurationEnabled()) {\n        if (mCurrentCapabilities != NULL) {\n            applyCapabilities(mCurrentCapabilities);\n        } else {\n            IndexSet *capabilities = capability(pError);\n            if (* pError != ErrorNone) {\n                MCLog(\"capabilities failed\");\n                return;\n            } else {\n                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);\n                applyCapabilities(mCurrentCapabilities);\n            }\n        }\n    }\n    else {\n        // TODO: capabilities should be shared with other sessions for non automatic capabilities sessions.\n    }\n    enableFeatures();\n\n    if (isAutomaticConfigurationEnabled()) {\n        bool hasDefaultNamespace = false;\n        if (isNamespaceEnabled()) {\n            IMAPNamespace * personalNamespace = NULL;\n            \n            if (mFetchedNamespace != NULL) {\n                personalNamespace = mFetchedNamespace;\n            } else {\n                HashMap * result = fetchNamespace(pError);\n                if (* pError != ErrorNone) {\n                    MCLog(\"fetch namespace failed\");\n                    return;\n                }\n                personalNamespace = (IMAPNamespace *) result->objectForKey(IMAPNamespacePersonal);\n            }\n            \n            if (personalNamespace != NULL) {\n                setDefaultNamespace(personalNamespace);\n                mDelimiter = defaultNamespace()->mainDelimiter();\n                if (mFetchedNamespace != personalNamespace) {\n                    MC_SAFE_REPLACE_RETAIN(IMAPNamespace, mFetchedNamespace, personalNamespace);\n                }\n                hasDefaultNamespace = true;\n            }\n        }\n        \n        if (!hasDefaultNamespace) {\n            clist * imap_folders;\n            IMAPFolder * folder;\n            Array * folders;\n            \n            r = mailimap_list(mImap, \"\", \"\", &imap_folders);\n            folders = resultsWithError(r, imap_folders, pError);\n            if (* pError != ErrorNone)\n                return;\n            \n            if (folders->count() > 0) {\n                folder = (IMAPFolder *) folders->objectAtIndex(0);\n            }\n            else {\n                folder = NULL;\n            }\n            if (folder == NULL) {\n                * pError = ErrorNonExistantFolder;\n                return;\n            }\n            \n            mDelimiter = folder->delimiter();\n            IMAPNamespace * defaultNamespace = IMAPNamespace::namespaceWithPrefix(MCSTR(\"\"), folder->delimiter());\n            setDefaultNamespace(defaultNamespace);\n        }\n        \n        if (isIdentityEnabled()) {\n//            IMAPIdentity * serverIdentity = NULL;\n//            if (mFetchedIdentity) {\n//                serverIdentity = mFetchedIdentity;\n//            } else {\n//                serverIdentity = identity(clientIdentity(), pError);\n//            }\n//            if (* pError != ErrorNone) {\n//                // Ignore identity errors\n//                MCLog(\"fetch identity failed\");\n//            }\n//            else {\n//                if (mFetchedIdentity != serverIdentity) {\n//                    MC_SAFE_REPLACE_RETAIN(IMAPIdentity, mFetchedIdentity, serverIdentity);\n//                }\n//                MC_SAFE_REPLACE_RETAIN(IMAPIdentity, mServerIdentity, serverIdentity);\n//            }\n        }\n    }\n    else {\n        // TODO: namespace should be shared with other sessions for non automatic namespace.\n    }\n    \n    mAutomaticConfigurationDone = true;\n    \n    * pError = ErrorNone;\n    MCLog(\"login ok\");\n}\n\nvoid IMAPSession::setNeedsReselect()\n{\n    mNeedsReselect = true;\n}\n\nvoid IMAPSession::setNeedsReconnect()\n{\n    mShouldDisconnect = true;\n}\n\nvoid IMAPSession::selectIfNeeded(String * folder, ErrorCode * pError)\n{\n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    if (folder == NULL) {\n        * pError = ErrorMissingFolder;\n        return;\n    }\n    \n    if (mNeedsReselect) {\n        mNeedsReselect = false;\n        select(folder, pError);\n    }\n    else if (mState == STATE_SELECTED) {\n        MCAssert(mCurrentFolder != NULL);\n        if (mCurrentFolder->caseInsensitiveCompare(folder) != 0) {\n            select(folder, pError);\n        }\n    }\n    else if (mState == STATE_LOGGEDIN) {\n        select(folder, pError);\n    }\n    else {\n        * pError = ErrorNone;\n    }\n}\n\nstatic uint64_t get_mod_sequence_value(mailimap * session)\n{\n    uint64_t mod_sequence_value;\n    clistiter * cur;\n    \n    mod_sequence_value = 0;\n    for(cur = clist_begin(session->imap_response_info->rsp_extension_list) ; cur != NULL ; cur = clist_next(cur)) {\n        struct mailimap_extension_data * ext_data;\n        struct mailimap_condstore_resptextcode * resptextcode;\n        \n        ext_data = (struct mailimap_extension_data *) clist_content(cur);\n        if (ext_data->ext_extension->ext_id != MAILIMAP_EXTENSION_CONDSTORE) {\n            continue;\n        }\n        if (ext_data->ext_type != MAILIMAP_CONDSTORE_TYPE_RESP_TEXT_CODE) {\n            continue;\n        }\n        \n        resptextcode = (struct mailimap_condstore_resptextcode *) ext_data->ext_data;\n        switch (resptextcode->cs_type) {\n            case MAILIMAP_CONDSTORE_RESPTEXTCODE_HIGHESTMODSEQ:\n                mod_sequence_value = resptextcode->cs_data.cs_modseq_value;\n                break;\n            case MAILIMAP_CONDSTORE_RESPTEXTCODE_NOMODSEQ:\n                mod_sequence_value = 0;\n                break;\n        }\n    }\n    \n    return mod_sequence_value;\n}\n\nString * IMAPSession::customCommand(String * command, ErrorCode * pError)\n{\n    int r;\n    \n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    r = mailimap_custom_command(mImap, MCUTF8(command));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCustomCommand;\n        return NULL;\n    }\n    \n    String *response = String::stringWithUTF8Characters(mImap->imap_response);\n    return response;\n}\n\nvoid IMAPSession::select(String * folder, ErrorCode * pError)\n{\n    int r;\n\n    MCLog(\"select\");\n    MCAssert(mState == STATE_LOGGEDIN || mState == STATE_SELECTED);\n\n    r = mailimap_select(mImap, MCUTF8(folder));\n    MCLog(\"select error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        MCLog(\"select error : %s %i\", MCUTF8DESC(this), * pError);\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNonExistantFolder;\n        mState = STATE_LOGGEDIN;\n        MC_SAFE_RELEASE(mCurrentFolder);\n        return;\n    }\n\n    MC_SAFE_REPLACE_COPY(String, mCurrentFolder, folder);\n\n    if (mImap->imap_selection_info != NULL) {\n        mUIDValidity = mImap->imap_selection_info->sel_uidvalidity;\n        mUIDNext = mImap->imap_selection_info->sel_uidnext;        \n        if (mImap->imap_selection_info->sel_has_exists) {\n            mFolderMsgCount = (unsigned int) (mImap->imap_selection_info->sel_exists);\n        } else {\n            mFolderMsgCount = -1;\n        }\n        \n        if (mImap->imap_selection_info->sel_first_unseen) {\n            mFirstUnseenUid = mImap->imap_selection_info->sel_first_unseen;\n        } else {\n            mFirstUnseenUid = 0;\n        }\n        \n        if (mImap->imap_selection_info->sel_unseen) {\n            mUnseenCount = mImap->imap_selection_info->sel_unseen;\n        } else {\n            mUnseenCount = 0;\n        }\n        \n        if (mImap->imap_selection_info->sel_perm_flags) {\n          clistiter * cur;\n\n          struct mailimap_flag_perm * perm_flag;\n          for(cur = clist_end(mImap->imap_selection_info->sel_perm_flags) ; cur != NULL ;\n              cur = clist_previous(cur)) {\n            perm_flag = (struct mailimap_flag_perm *)clist_content(cur);\n            mAllowsNewPermanentFlags = perm_flag->fl_type == MAILIMAP_FLAG_PERM_ALL;\n            if (mAllowsNewPermanentFlags) {\n              break;\n            }\n          }\n        }\n      \n        mModSequenceValue = get_mod_sequence_value(mImap);\n    }\n\n    mState = STATE_SELECTED;\n    * pError = ErrorNone;\n    MCLog(\"select ok\");\n}\n\n\n\n\n\nIMAPFolderStatus * IMAPSession::folderStatus(String * folder, ErrorCode * pError)\n{\n    int r;\n\n    MCLog(\"status\");\n    if (mState != STATE_LOGGEDIN && mState != STATE_SELECTED) {\n        * pError = ErrorFolderState;\n        MCLog(\"trying to fetch status in bad state\");\n        IMAPFolderStatus * empty;\n        empty = new IMAPFolderStatus();\n        empty->autorelease();\n        return empty;\n    }\n\n    if (folder == NULL) {\n        * pError = ErrorMissingFolder;\n        MCLog(\"trying to fetch status without folder\");\n        IMAPFolderStatus * empty;\n        empty = new IMAPFolderStatus();\n        empty->autorelease();\n        return empty;\n    }\n    \n    if (mImap == NULL) {\n        * pError = ErrorDisconnected;\n        MCLog(\"trying to fetch status without connection\");\n        IMAPFolderStatus * empty;\n        empty = new IMAPFolderStatus();\n        empty->autorelease();\n        return empty;\n    }\n\n    struct mailimap_mailbox_data_status * status;\n\n    struct mailimap_status_att_list * status_att_list;\n        \n    status_att_list = mailimap_status_att_list_new_empty();\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UNSEEN);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_MESSAGES);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_RECENT);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UIDNEXT);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UIDVALIDITY);\n    if (mCondstoreEnabled || mXYMHighestModseqEnabled) {\n        mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_HIGHESTMODSEQ);\n    }\n    \n    r = mailimap_status(mImap, MCUTF8(folder), status_att_list, &status);\n    \n    IMAPFolderStatus * fs;\n    fs = new IMAPFolderStatus();\n    fs->autorelease();\n    \n    MCLog(\"status error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        MCLog(\"status error : %s %i\", MCUTF8DESC(this), * pError);\n        mailimap_status_att_list_free(status_att_list);\n        return fs;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        mailimap_status_att_list_free(status_att_list);\n        return fs;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNonExistantFolder;\n        mailimap_status_att_list_free(status_att_list);\n        return fs;\n    }\n    \n    clistiter * cur;\n    \n    \n    if (status != NULL) {\n        \n            struct mailimap_status_info * status_info;\n            for(cur = clist_begin(status->st_info_list) ; cur != NULL ;\n                cur = clist_next(cur)) {                \n                \n                status_info = (struct mailimap_status_info *) clist_content(cur);\n                                \n                switch (status_info->st_att) {\n                    case MAILIMAP_STATUS_ATT_UNSEEN:\n                        fs->setUnseenCount(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_MESSAGES:\n                        fs->setMessageCount(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_RECENT:\n                        fs->setRecentCount(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_UIDNEXT:\n                        fs->setUidNext(status_info->st_value);\n                        break;                        \n                    case MAILIMAP_STATUS_ATT_UIDVALIDITY:\n                        fs->setUidValidity(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_EXTENSION: {\n                        struct mailimap_extension_data * ext_data = status_info->st_ext_data;\n                        if (ext_data->ext_extension == &mailimap_extension_condstore) {\n                            struct mailimap_condstore_status_info * status_info = (struct mailimap_condstore_status_info *) ext_data->ext_data;\n                            fs->setHighestModSeqValue(status_info->cs_highestmodseq_value);\n                        }\n                        break;\n                    }\n                }\n            }            \n\n        mailimap_mailbox_data_status_free(status);\n    }\n\n    mailimap_status_att_list_free(status_att_list);\n\n    return fs;\n}\n\nvoid IMAPSession::noop(ErrorCode * pError)\n{\n    int r;\n    \n    if (mImap == NULL)\n        return;\n    \n    MCLog(\"connect\");\n    loginIfNeeded(pError);\n    if (* pError != ErrorNone) {\n        return;\n    }\n    if (mImap->imap_stream != NULL) {\n        r = mailimap_noop(mImap);\n        if (r == MAILIMAP_ERROR_STREAM) {\n            * pError = ErrorConnection;\n        }\n        if (r == MAILIMAP_ERROR_NOOP) {\n            * pError = ErrorNoop;\n        }\n    }\n}\n\n#pragma mark mailbox flags conversion\n\nstatic struct {\n    const char * name;\n    int flag;\n} mb_keyword_flag[] = {\n    {\"Inbox\",     IMAPFolderFlagInbox},\n    {\"AllMail\",   IMAPFolderFlagAllMail},\n    {\"Sent\",      IMAPFolderFlagSentMail},\n    {\"Spam\",      IMAPFolderFlagSpam},\n    {\"Starred\",   IMAPFolderFlagStarred},\n    {\"Trash\",     IMAPFolderFlagTrash},\n    {\"Important\", IMAPFolderFlagImportant},\n    {\"Drafts\",    IMAPFolderFlagDrafts},\n    {\"Archive\",   IMAPFolderFlagArchive},\n    {\"All\",       IMAPFolderFlagAll},\n    {\"Junk\",      IMAPFolderFlagJunk},\n    {\"Flagged\",   IMAPFolderFlagFlagged},\n};\n\nstatic int imap_mailbox_flags_to_flags(struct mailimap_mbx_list_flags * imap_flags)\n{\n    int flags;\n    clistiter * cur;\n    \n    flags = 0;\n    if (imap_flags->mbf_type == MAILIMAP_MBX_LIST_FLAGS_SFLAG) {\n        switch (imap_flags->mbf_sflag) {\n            case MAILIMAP_MBX_LIST_SFLAG_MARKED:\n                flags |= IMAPFolderFlagMarked;\n                break;\n            case MAILIMAP_MBX_LIST_SFLAG_NOSELECT:\n                flags |= IMAPFolderFlagNoSelect;\n                break;\n            case MAILIMAP_MBX_LIST_SFLAG_UNMARKED:\n                flags |= IMAPFolderFlagUnmarked;\n                break;\n        }\n    }\n    \n    for(cur = clist_begin(imap_flags->mbf_oflags) ; cur != NULL ;\n        cur = clist_next(cur)) {\n        struct mailimap_mbx_list_oflag * oflag;\n        \n        oflag = (struct mailimap_mbx_list_oflag *) clist_content(cur);\n        \n        switch (oflag->of_type) {\n            case MAILIMAP_MBX_LIST_OFLAG_NOINFERIORS:\n                flags |= IMAPFolderFlagNoInferiors;\n                break;\n                \n            case MAILIMAP_MBX_LIST_OFLAG_FLAG_EXT:\n                for(unsigned int i = 0 ; i < sizeof(mb_keyword_flag) / sizeof(mb_keyword_flag[0]) ; i ++) {\n                    if (strcasecmp(mb_keyword_flag[i].name, oflag->of_flag_ext) == 0) {\n                        flags |= mb_keyword_flag[i].flag;\n                    }\n                }\n                break;\n        }\n    }\n    \n    return flags;\n}\n\nstatic Array * resultsWithError(int r, clist * list, ErrorCode * pError)\n{\n    clistiter * cur;\n    Array * result;\n    \n    result = Array::array();\n    if (r == MAILIMAP_ERROR_STREAM) {\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNonExistantFolder;\n        return NULL;\n    }\n    \n    for(cur = clist_begin(list) ; cur != NULL ; cur = cur->next) {\n        struct mailimap_mailbox_list * mb_list;\n        IMAPFolderFlag flags;\n        IMAPFolder * folder;\n        String * path;\n        \n        mb_list = (struct mailimap_mailbox_list *) cur->data;\n        \n        flags = IMAPFolderFlagNone;\n        if (mb_list->mb_flag != NULL)\n            flags = (IMAPFolderFlag) imap_mailbox_flags_to_flags(mb_list->mb_flag);\n        \n        folder = new IMAPFolder();\n        path = String::stringWithUTF8Characters(mb_list->mb_name);\n        if (path->uppercaseString()->isEqual(MCSTR(\"INBOX\"))) {\n            folder->setPath(MCSTR(\"INBOX\"));\n        }\n        else {\n            folder->setPath(path);\n        }\n        folder->setDelimiter(mb_list->mb_delimiter);\n        folder->setFlags(flags);\n        \n        result->addObject(folder);\n        \n        folder->release();\n    }\n    \n    mailimap_list_result_free(list);\n    \n    * pError = ErrorNone;\n    return result;\n}\n\n// Deprecated\nchar IMAPSession::fetchDelimiterIfNeeded(char defaultDelimiter, ErrorCode * pError)\n{\n    int r;\n    clist * imap_folders;\n    IMAPFolder * folder;\n    Array * folders;\n    \n    if (defaultDelimiter != 0)\n        return defaultDelimiter;\n    \n    r = mailimap_list(mImap, \"\", \"\", &imap_folders);\n    folders = resultsWithError(r, imap_folders, pError);\n    if (* pError == ErrorConnection || * pError == ErrorParse)\n        mShouldDisconnect = true;\n    if (* pError != ErrorNone)\n        return 0;\n    \n    if (folders->count() > 0) {\n        folder = (IMAPFolder *) folders->objectAtIndex(0);\n    }\n    else {\n        folder = NULL;\n    }\n    if (folder == NULL)\n        return 0;\n    \n    * pError = ErrorNone;\n    return folder->delimiter();\n}\n\nArray * /* IMAPFolder */ IMAPSession::fetchSubscribedFolders(ErrorCode * pError)\n{\n    int r;\n    clist * imap_folders;\n    \n    MCLog(\"fetch subscribed\");\n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    if (mDelimiter == 0) {\n        char delimiter;\n        \n        delimiter = fetchDelimiterIfNeeded(mDelimiter, pError);\n        if (* pError != ErrorNone)\n            return NULL;\n        \n        //setDelimiter(delimiter);\n        mDelimiter = delimiter;\n    }\n    \n    String * prefix;\n    prefix = defaultNamespace()->mainPrefix();\n    if (prefix == NULL) {\n        prefix = MCSTR(\"\");\n    }\n    if (prefix->length() > 0) {\n        if (!prefix->hasSuffix(String::stringWithUTF8Format(\"%c\", mDelimiter))) {\n            prefix = prefix->stringByAppendingUTF8Format(\"%c\", mDelimiter);\n        }\n    }\n    \n    r = mailimap_lsub(mImap, MCUTF8(prefix), \"*\", &imap_folders);\n    MCLog(\"fetch subscribed %u\", r);\n    Array * result = resultsWithError(r, imap_folders, pError);\n    if (* pError == ErrorConnection || * pError == ErrorParse)\n        mShouldDisconnect = true;\n    return result;\n}\n\nArray * /* IMAPFolder */ IMAPSession::fetchAllFolders(ErrorCode * pError)\n{\n    int r;\n    clist * imap_folders;\n    \n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    if (mDelimiter == 0) {\n        char delimiter;\n        \n        delimiter = fetchDelimiterIfNeeded(mDelimiter, pError);\n        if (* pError != ErrorNone)\n            return NULL;\n        \n        //setDelimiter(delimiter);\n        mDelimiter = delimiter;\n    }\n    \n    String * prefix = NULL;\n    if (defaultNamespace()) {\n        prefix = defaultNamespace()->mainPrefix();\n    }\n    if (prefix == NULL) {\n        prefix = MCSTR(\"\");\n    }\n    if (prefix->length() > 0) {\n        if (!prefix->hasSuffix(String::stringWithUTF8Format(\"%c\", mDelimiter))) {\n            prefix = prefix->stringByAppendingUTF8Format(\"%c\", mDelimiter);\n        }\n    }\n    \n    if (mXListEnabled) {\n        r = mailimap_xlist(mImap, MCUTF8(prefix), \"*\", &imap_folders);\n    }\n    else {\n        r = mailimap_list(mImap, MCUTF8(prefix), \"*\", &imap_folders);\n    }\n    Array * result = resultsWithError(r, imap_folders, pError);\n    if (* pError == ErrorConnection || * pError == ErrorParse)\n        mShouldDisconnect = true;\n    \n    if (result != NULL) {\n        bool hasInbox = false;\n        mc_foreacharray(IMAPFolder, folder, result) {\n            if (folder->path()->isEqual(MCSTR(\"INBOX\"))) {\n                hasInbox = true;\n            }\n        }\n\n        if (!hasInbox) {\n            mc_foreacharray(IMAPFolder, folder, result) {\n                if (folder->flags() & IMAPFolderFlagInbox) {\n                    // some mail providers use non-standart name for inbox folder\n                    hasInbox = true;\n                    folder->setPath(MCSTR(\"INBOX\"));\n                    break;\n                }\n            }\n\n            if (!hasInbox) {\n                r = mailimap_list(mImap, \"\", \"INBOX\", &imap_folders);\n                Array * inboxResult = resultsWithError(r, imap_folders, pError);\n                if (* pError == ErrorConnection || * pError == ErrorParse)\n                    mShouldDisconnect = true;\n                result->addObjectsFromArray(inboxResult);\n                hasInbox = true;\n            }\n        }\n    }\n    \n    return result;\n}\n\nvoid IMAPSession::renameFolder(String * folder, String * otherName, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_rename(mImap, MCUTF8(folder), MCUTF8(otherName));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorRename;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::deleteFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_delete(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorDelete;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::createFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_create(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCreate;\n        return;\n    }\n    \n    * pError = ErrorNone;\n    subscribeFolder(folder, pError);\n}\n\nvoid IMAPSession::subscribeFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_subscribe(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorSubscribe;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::unsubscribeFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_unsubscribe(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorSubscribe;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::appendMessage(String * folder, Data * messageData, MessageFlag flags,\n    IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    this->appendMessageWithCustomFlags(folder, messageData, flags, NULL, progressCallback, createdUID, pError);\n}\n\nvoid IMAPSession::appendMessageWithCustomFlags(String * folder, Data * messageData, MessageFlag flags, Array * customFlags,\n    IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    this->appendMessageWithCustomFlagsAndDate(folder, messageData, flags, NULL, (time_t) -1, progressCallback, createdUID, pError);\n}\n\nvoid IMAPSession::appendMessageWithCustomFlagsAndDate(String * folder, Data * messageData, MessageFlag flags, Array * customFlags, time_t date,\n                                                      IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    int r;\n    struct mailimap_flag_list * flag_list;\n    uint32_t uidvalidity;\n    uint32_t uidresult;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    mProgressCallback = progressCallback;\n    bodyProgress(0, messageData->length());\n    \n    flag_list = flags_to_lep(flags);\n    if (customFlags != NULL) {\n        for (unsigned int i = 0 ; i < customFlags->count() ; i ++) {\n            struct mailimap_flag * f;\n            String * customFlag = (String *) customFlags->objectAtIndex(i);\n            \n            f = mailimap_flag_new_flag_keyword(strdup(customFlag->UTF8Characters()));\n            mailimap_flag_list_add(flag_list, f);\n        }\n    }\n    struct mailimap_date_time * imap_date = NULL;\n    if (date != (time_t) -1) {\n        imap_date = imapDateFromTimestamp(date);\n    }\n    r = mailimap_uidplus_append(mImap, MCUTF8(folder), flag_list, imap_date, messageData->bytes(), messageData->length(),\n        &uidvalidity, &uidresult);\n    if (imap_date != NULL) {\n        mailimap_date_time_free(imap_date);\n    }\n    mailimap_flag_list_free(flag_list);\n    \n    bodyProgress(messageData->length(), messageData->length());\n    mProgressCallback = NULL;\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorAppend;\n        return;\n    }\n    \n    * createdUID = uidresult;\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::appendMessageWithCustomFlagsAndDate(String * folder, String * messagePath, MessageFlag flags, Array * customFlags, time_t date,\n                                                      IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    Data * messageData = Data::dataWithContentsOfFile(messagePath);\n    if (!messageData) {\n        * pError = ErrorFile;\n        return;\n    }\n\n    return appendMessageWithCustomFlagsAndDate(folder, messageData, flags, customFlags, date, progressCallback, createdUID, pError);\n}\n\nvoid IMAPSession::copyMessages(String * folder, IndexSet * uidSet, String * destFolder,\n     HashMap ** pUidMapping, ErrorCode * pError)\n{\n    int r;\n    struct mailimap_set * set;\n    struct mailimap_set * src_uid;\n    struct mailimap_set * dest_uid;\n    uint32_t uidvalidity;\n    clist * setList;\n    IndexSet * uidSetResult;\n    HashMap * uidMapping = NULL;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    set = setFromIndexSet(uidSet);\n    if (clist_count(set->set_list) == 0) {\n        mailimap_set_free(set);\n        return;\n    }\n\n    setList = splitSet(set, 10);\n    uidSetResult = NULL;\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        r = mailimap_uidplus_uid_copy(mImap, current_set, MCUTF8(destFolder),\n            &uidvalidity, &src_uid, &dest_uid);\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorCopy;\n            goto release;\n        }\n\n        if ((src_uid != NULL) && (dest_uid != NULL)) {\n            if (uidMapping == NULL) {\n                uidMapping = HashMap::hashMap();\n            }\n            \n            Array * srcUidsArray = arrayFromSet(src_uid);\n            Array * destUidsArray = arrayFromSet(dest_uid);\n\n            for(int i = 0 ; i < srcUidsArray->count() && i < destUidsArray->count() ; i ++) {\n                uidMapping->setObjectForKey(srcUidsArray->objectAtIndex(i), destUidsArray->objectAtIndex(i));\n            }\n        }\n\n        if (src_uid != NULL) {\n            mailimap_set_free(src_uid);\n        }\n\n        if (dest_uid != NULL) {\n            mailimap_set_free(dest_uid);\n        }\n    }\n    if (pUidMapping != NULL) {\n        * pUidMapping = uidMapping;\n    }\n    * pError = ErrorNone;\n\n    release:\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_set_free(set);\n}\n\nvoid IMAPSession::moveMessages(String * folder, IndexSet * uidSet, String * destFolder,\n     HashMap ** pUidMapping, ErrorCode * pError)\n{\n    int r;\n    struct mailimap_set * set;\n    struct mailimap_set * src_uid;\n    struct mailimap_set * dest_uid;\n    uint32_t uidvalidity;\n    clist * setList;\n    IndexSet * uidSetResult;\n    HashMap * uidMapping = NULL;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    set = setFromIndexSet(uidSet);\n    if (clist_count(set->set_list) == 0) {\n        mailimap_set_free(set);\n        return;\n    }\n\n    setList = splitSet(set, 10);\n    uidSetResult = NULL;\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        r = mailimap_uidplus_uid_move(mImap, current_set, MCUTF8(destFolder),\n            &uidvalidity, &src_uid, &dest_uid);\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorCopy;\n            goto release;\n        }\n\n        if ((src_uid != NULL) && (dest_uid != NULL)) {\n            if (uidMapping == NULL) {\n                uidMapping = HashMap::hashMap();\n            }\n            \n            Array * srcUidsArray = arrayFromSet(src_uid);\n            Array * destUidsArray = arrayFromSet(dest_uid);\n\n            for(int i = 0 ; i < srcUidsArray->count() && i < destUidsArray->count() ; i ++) {\n                uidMapping->setObjectForKey(srcUidsArray->objectAtIndex(i), destUidsArray->objectAtIndex(i));\n            }\n        }\n\n        if (src_uid != NULL) {\n            mailimap_set_free(src_uid);\n        }\n\n        if (dest_uid != NULL) {\n            mailimap_set_free(dest_uid);\n        }\n    }\n    if (pUidMapping != NULL) {\n        * pUidMapping = uidMapping;\n    }\n    * pError = ErrorNone;\n\n    release:\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_set_free(set);\n}\n\nvoid IMAPSession::expunge(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_expunge(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorExpunge;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nstatic int\nfetch_imap(mailimap * imap, bool identifier_is_uid, uint32_t identifier,\n           struct mailimap_fetch_type * fetch_type,\n           char ** result, size_t * result_len)\n{\n    int r;\n    struct mailimap_msg_att * msg_att;\n    struct mailimap_msg_att_item * msg_att_item;\n    clist * fetch_result;\n    struct mailimap_set * set;\n    char * text;\n    size_t text_length;\n    clistiter * cur;\n    \n    set = mailimap_set_new_single(identifier);\n    if (identifier_is_uid) {\n        r = mailimap_uid_fetch(imap, set, fetch_type, &fetch_result);\n    }\n    else {\n        r = mailimap_fetch(imap, set, fetch_type, &fetch_result);\n    }\n    \n    mailimap_set_free(set);\n    \n    switch (r) {\n        case MAILIMAP_NO_ERROR:\n            break;\n        default:\n            return r;\n    }\n    \n    if (clist_isempty(fetch_result)) {\n        mailimap_fetch_list_free(fetch_result);\n        return MAILIMAP_ERROR_FETCH;\n    }\n    \n    msg_att = (struct mailimap_msg_att *) clist_begin(fetch_result)->data;\n    \n    text = NULL;\n    text_length = 0;\n    \n    for(cur = clist_begin(msg_att->att_list) ; cur != NULL ;\n        cur = clist_next(cur)) {\n        msg_att_item = (struct mailimap_msg_att_item *) clist_content(cur);\n        \n        if (msg_att_item->att_type != MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            continue;\n        }\n        \n        if (msg_att_item->att_data.att_static->att_type !=\n            MAILIMAP_MSG_ATT_BODY_SECTION) {\n            continue;\n        }\n        \n        text = msg_att_item->att_data.att_static->att_data.att_body_section->sec_body_part;\n        msg_att_item->att_data.att_static->att_data.att_body_section->sec_body_part = NULL;\n        text_length = msg_att_item->att_data.att_static->att_data.att_body_section->sec_length;\n    }\n    \n    mailimap_fetch_list_free(fetch_result);\n    \n    if (text == NULL)\n        return MAILIMAP_ERROR_FETCH;\n    \n    * result = text;\n    * result_len = text_length;\n    \n    return MAILIMAP_NO_ERROR;\n}\n\nHashMap * IMAPSession::fetchMessageNumberUIDMapping(String * folder, uint32_t fromUID, uint32_t toUID,\n    ErrorCode * pError)\n{\n    struct mailimap_set * imap_set;\n    struct mailimap_fetch_type * fetch_type;\n    clist * fetch_result;\n    HashMap * result;\n    struct mailimap_fetch_att * fetch_att;\n    int r;\n    clistiter * iter;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    result = HashMap::hashMap();\n    \n    imap_set = mailimap_set_new_interval(fromUID, toUID);\n    fetch_type = mailimap_fetch_type_new_fetch_att_list_empty();\n    fetch_att = mailimap_fetch_att_new_uid();\n    mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    \n    r = mailimap_uid_fetch(mImap, imap_set, fetch_type, &fetch_result);\n    mailimap_fetch_type_free(fetch_type);\n    mailimap_set_free(imap_set);\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        MCLog(\"error stream\");\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        MCLog(\"error parse\");\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        MCLog(\"error fetch\");\n        * pError = ErrorFetch;\n        return NULL;\n    }\n    \n    for(iter = clist_begin(fetch_result) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_msg_att * msg_att;\n        clistiter * item_iter;\n        uint32_t uid;\n        \n        msg_att = (struct mailimap_msg_att *) clist_content(iter);\n        uid = 0;\n        for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {\n            struct mailimap_msg_att_item * att_item;\n            \n            att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);\n            if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {\n                struct mailimap_msg_att_static * att_static;\n                \n                att_static = att_item->att_data.att_static;\n                if (att_static->att_type == MAILIMAP_MSG_ATT_UID) {\n                    uid = att_static->att_data.att_uid;\n                }\n            }\n        }\n        \n        if (uid < fromUID) {\n            uid = 0;\n        }\n        \n        if (uid != 0) {\n            result->setObjectForKey(Value::valueWithUnsignedLongValue(msg_att->att_number),\n                Value::valueWithUnsignedLongValue(uid));\n        }\n    }\n    \n    mailimap_fetch_list_free(fetch_result);\n    * pError = ErrorNone;\n    \n    return result;\n}\n\nstruct msg_att_handler_data {\n    IndexSet * uidsFilter;\n    IndexSet * numbersFilter;\n    bool fetchByUID;\n    Array * result;\n    IMAPMessagesRequestKind requestKind;\n    uint32_t mLastFetchedSequenceNumber;\n    HashMap * mapping;\n    bool needsHeader;\n    bool needsBody;\n    bool needsFlags;\n    bool needsGmailLabels;\n    bool needsGmailMessageID;\n    bool needsGmailThreadID;\n};\n\nstatic void msg_att_handler(struct mailimap_msg_att * msg_att, void * context)\n{\n    clistiter * item_iter;\n    uint32_t uid;\n    IMAPMessage * msg;\n    bool hasHeader;\n    bool hasBody;\n    bool hasFlags;\n    bool hasGmailLabels;\n    bool hasGmailMessageID;\n    bool hasGmailThreadID;\n    struct msg_att_handler_data * msg_att_context;\n    bool fetchByUID;\n    Array * result;\n    IMAPMessagesRequestKind requestKind;\n    uint32_t mLastFetchedSequenceNumber;\n    HashMap * mapping;\n    bool needsHeader;\n    bool needsBody;\n    bool needsFlags;\n    bool needsGmailLabels;\n    bool needsGmailMessageID;\n    bool needsGmailThreadID;\n    IndexSet * uidsFilter;\n    IndexSet * numbersFilter;\n    \n    msg_att_context = (struct msg_att_handler_data *) context;\n    uidsFilter = msg_att_context->uidsFilter;\n    numbersFilter = msg_att_context->numbersFilter;\n    fetchByUID = msg_att_context->fetchByUID;\n    result = msg_att_context->result;\n    requestKind = msg_att_context->requestKind;\n    mapping = msg_att_context->mapping;\n    needsHeader = msg_att_context->needsHeader;\n    needsBody = msg_att_context->needsBody;\n    needsFlags = msg_att_context->needsFlags;\n    needsGmailLabels = msg_att_context->needsGmailLabels;\n    needsGmailMessageID = msg_att_context->needsGmailMessageID;\n    needsGmailThreadID = msg_att_context->needsGmailThreadID;\n\n    hasHeader = false;\n    hasBody = false;\n    hasFlags = false;\n    hasGmailLabels = false;\n    hasGmailMessageID = false;\n    hasGmailThreadID = false;\n    \n    if (numbersFilter != NULL) {\n        if (!numbersFilter->containsIndex((uint64_t) msg_att->att_number)) {\n            return;\n        }\n    }\n\n    msg = new IMAPMessage();\n    \n    uid = 0;\n    mLastFetchedSequenceNumber = msg_att->att_number;\n    if (mapping != NULL) {\n        uid = (uint32_t) ((Value *) mapping->objectForKey(Value::valueWithUnsignedLongValue(msg_att->att_number)))->longLongValue();\n    }\n\n    msg->setSequenceNumber(msg_att->att_number);\n    for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {\n        struct mailimap_msg_att_item * att_item;\n        \n        att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);\n        if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_DYNAMIC) {\n            MessageFlag flags;\n            \n            flags = flags_from_lep_att_dynamic(att_item->att_data.att_dyn);\n            msg->setFlags(flags);\n            msg->setOriginalFlags(flags);\n            hasFlags = true;\n            \n            Array * customFlags;\n            customFlags = custom_flags_from_lep_att_dynamic(att_item->att_data.att_dyn);\n            msg->setCustomFlags(customFlags);\n        }\n        else if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            struct mailimap_msg_att_static * att_static;\n            \n            att_static = att_item->att_data.att_static;\n            if (att_static->att_type == MAILIMAP_MSG_ATT_UID) {\n                uid = att_static->att_data.att_uid;\n            }\n            else if (att_static->att_type == MAILIMAP_MSG_ATT_ENVELOPE) {\n                struct mailimap_envelope * env;\n                \n                MCLog(\"parse envelope %lu\", (unsigned long) uid);\n                env = att_static->att_data.att_env;\n                if ((requestKind & IMAPMessagesRequestKindMessageId) != 0) {\n                    msg->header()->importPartialIMAPEnvelope(env);\n                } else {\n                    msg->header()->importIMAPEnvelope(env);\n                }\n                hasHeader = true;\n            }\n            else if (att_static->att_type == MAILIMAP_MSG_ATT_BODY_SECTION) {\n                if ((requestKind & IMAPMessagesRequestKindFullHeaders) != 0 ||\n                    (requestKind & IMAPMessagesRequestKindExtraHeaders) != 0) {\n                    char * bytes;\n                    size_t length;\n                    \n                    bytes = att_static->att_data.att_body_section->sec_body_part;\n                    length = att_static->att_data.att_body_section->sec_length;\n                    \n                    msg->header()->importHeadersData(Data::dataWithBytes(bytes, (unsigned int) length));\n                    hasHeader = true;\n                }\n                else {\n                    char * references;\n                    size_t ref_size;\n                    \n                    // references\n                    references = att_static->att_data.att_body_section->sec_body_part;\n                    ref_size = att_static->att_data.att_body_section->sec_length;\n                    \n                    msg->header()->importIMAPReferences(Data::dataWithBytes(references, (unsigned int) ref_size));\n                }\n            }\n            else if (att_static->att_type == MAILIMAP_MSG_ATT_BODYSTRUCTURE) {\n                AbstractPart * mainPart;\n                \n                // bodystructure\n                mainPart = IMAPPart::attachmentWithIMAPBody(att_static->att_data.att_body);\n                msg->setMainPart(mainPart);\n                hasBody = true;\n            }\n        }\n        else if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_EXTENSION) {\n            struct mailimap_extension_data * ext_data;\n            \n            ext_data = att_item->att_data.att_extension_data;\n            if (ext_data->ext_extension == &mailimap_extension_condstore) {\n                struct mailimap_condstore_fetch_mod_resp * fetch_data;\n                \n                fetch_data = (struct mailimap_condstore_fetch_mod_resp *) ext_data->ext_data;\n                msg->setModSeqValue(fetch_data->cs_modseq_value);\n            }\n            else if (ext_data->ext_extension == &mailimap_extension_xgmlabels) {\n                struct mailimap_msg_att_xgmlabels * cLabels;\n                Array * labels;\n                clistiter * cur;\n                \n                labels = new Array();\n                hasGmailLabels = true;\n                cLabels = (struct mailimap_msg_att_xgmlabels *) ext_data->ext_data;\n                for(cur = clist_begin(cLabels->att_labels) ; cur != NULL ; cur = clist_next(cur)) {\n                    char * cLabel;\n                    String * label;\n                    \n                    cLabel = (char *) clist_content(cur);\n                    label = String::stringWithUTF8Characters(cLabel);\n                    labels->addObject(label);\n                }\n                if (labels->count() > 0) {\n                    msg->setGmailLabels(labels);\n                }\n                labels->release();\n            }\n            else if (ext_data->ext_extension == &mailimap_extension_xgmthrid) {\n                uint64_t * threadID;\n                \n                threadID = (uint64_t *) ext_data->ext_data;\n                msg->setGmailThreadID(*threadID);\n                hasGmailThreadID = true;\n            }\n            else if (ext_data->ext_extension == &mailimap_extension_xgmmsgid) {\n                uint64_t * msgID;\n                \n                msgID = (uint64_t *) ext_data->ext_data;\n                msg->setGmailMessageID(*msgID);\n                hasGmailMessageID = true;\n            }\n        }\n    }\n    for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {\n        struct mailimap_msg_att_item * att_item;\n        \n        att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);\n        if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            struct mailimap_msg_att_static * att_static;\n            \n            att_static = att_item->att_data.att_static;\n            if (att_static->att_type == MAILIMAP_MSG_ATT_INTERNALDATE) {\n                msg->header()->importIMAPInternalDate(att_static->att_data.att_internal_date);\n            } else if (att_static->att_type == MAILIMAP_MSG_ATT_RFC822_SIZE) {\n                msg->setSize(att_static->att_data.att_rfc822_size);\n            }\n        }\n    }\n    \n    if (needsBody && !hasBody) {\n        msg->release();\n        return;\n    }\n    if (needsHeader && !hasHeader) {\n        msg->release();\n        return;\n    }\n    if (needsFlags && !hasFlags) {\n        msg->release();\n        return;\n    }\n    if (needsGmailThreadID && !hasGmailThreadID) {\n        msg->release();\n        return;\n    }\n    if (needsGmailMessageID && !hasGmailMessageID) {\n        msg->release();\n        return;\n    }\n    if (needsGmailLabels && !hasGmailLabels) {\n        msg->release();\n        return;\n    }\n    if (uid != 0) {\n        msg->setUid(uid);\n    }\n    else {\n        msg->release();\n        return;\n    }\n\n    if (uidsFilter != NULL) {\n        if (!uidsFilter->containsIndex((uint64_t) uid)) {\n            msg->release();\n            return;\n        }\n    }\n    \n    result->addObject(msg);\n    msg->release();\n    \n    msg_att_context->mLastFetchedSequenceNumber = mLastFetchedSequenceNumber;\n}\n\nIMAPSyncResult * IMAPSession::fetchMessages(String * folder, IMAPMessagesRequestKind requestKind, bool fetchByUID,\n                                            struct mailimap_set * imapset, IndexSet * uidsFilter, IndexSet * numbersFilter,\n                                            uint64_t modseq, HashMap * mapping,\n                                            IMAPProgressCallback * progressCallback, Array * extraHeaders, ErrorCode * pError)\n{\n    struct mailimap_fetch_type * fetch_type;\n    clist * fetch_result;\n    struct mailimap_qresync_vanished * vanished;\n    struct mailimap_fetch_att * fetch_att;\n    int r;\n    bool needsHeader;\n    bool needsBody;\n    bool needsFlags;\n    bool needsGmailLabels;\n    bool needsGmailMessageID;\n    bool needsGmailThreadID;\n    Array * messages;\n    IndexSet * vanishedMessages;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    if (mNeedsMboxMailWorkaround && ((requestKind & IMAPMessagesRequestKindHeaders) != 0)) {\n        requestKind = (IMAPMessagesRequestKind) (requestKind & ~IMAPMessagesRequestKindHeaders);\n        requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindFullHeaders);\n    }\n    if (extraHeaders != NULL) {\n        requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindExtraHeaders);\n    }\n    \n    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {\n        mProgressItemsCount = 0;\n        mProgressCallback = progressCallback;\n    }\n    \n    messages = Array::array();\n    \n    needsHeader = false;\n    needsBody = false;\n    needsFlags = false;\n    needsGmailLabels = false;\n    needsGmailMessageID = false;\n    needsGmailThreadID = false;\n    clist * hdrlist = clist_new();\n    \n    fetch_type = mailimap_fetch_type_new_fetch_att_list_empty();\n    fetch_att = mailimap_fetch_att_new_uid();\n    mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    if ((requestKind & IMAPMessagesRequestKindFlags) != 0) {\n        MCLog(\"request flags\");\n        fetch_att = mailimap_fetch_att_new_flags();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsFlags = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindGmailLabels) != 0) {\n        MCLog(\"request flags\");\n        fetch_att = mailimap_fetch_att_new_xgmlabels();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsGmailLabels = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindGmailThreadID) != 0) {\n        fetch_att = mailimap_fetch_att_new_xgmthrid();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsGmailThreadID = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindGmailMessageID) != 0) {\n        fetch_att = mailimap_fetch_att_new_xgmmsgid();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsGmailMessageID = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindFullHeaders) != 0) {\n        char * header;\n        \n        MCLog(\"request envelope\");\n        \n        // most important header\n        header = strdup(\"Date\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Subject\");\n        clist_append(hdrlist, header);\n        header = strdup(\"From\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Sender\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Reply-To\");\n        clist_append(hdrlist, header);\n        header = strdup(\"To\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Cc\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Message-ID\");\n        clist_append(hdrlist, header);\n        header = strdup(\"References\");\n        clist_append(hdrlist, header);\n        header = strdup(\"In-Reply-To\");\n        clist_append(hdrlist, header);\n    }\n    if ((requestKind & IMAPMessagesRequestKindMessageId) != 0) {\n        char * header;\n        // envelope\n        fetch_att = mailimap_fetch_att_new_envelope();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        MCLog(\"request envelope\");\n        header = strdup(\"Message-ID\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Subject\");\n        clist_append(hdrlist, header);\n    }\n    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {\n        char * header;\n        \n        MCLog(\"request envelope\");\n        // envelope\n        fetch_att = mailimap_fetch_att_new_envelope();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        \n        // references header\n        header = strdup(\"References\");\n        clist_append(hdrlist, header);\n        if ((requestKind & IMAPMessagesRequestKindHeaderSubject) != 0) {\n            header = strdup(\"Subject\");\n            clist_append(hdrlist, header);\n        }\n    }\n    if ((requestKind & IMAPMessagesRequestKindSize) != 0) {\n        // message structure\n        MCLog(\"request size\");\n        fetch_att = mailimap_fetch_att_new_rfc822_size();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    }\n    \n    if ((requestKind & IMAPMessagesRequestKindStructure) != 0) {\n        // message structure\n        MCLog(\"request bodystructure\");\n        fetch_att = mailimap_fetch_att_new_bodystructure();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsBody = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindInternalDate) != 0) {\n        // internal date\n        fetch_att = mailimap_fetch_att_new_internaldate();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    }\n    if ((requestKind & IMAPMessagesRequestKindBody) != 0) {\n        fetch_att = mailimap_fetch_att_new_body_peek_section(mailimap_section_new(NULL));\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    }\n    if ((requestKind & IMAPMessagesRequestKindExtraHeaders) != 0) {\n        // custom header request\n        char * header;\n        \n        if (extraHeaders && extraHeaders->count() > 0) {\n            for (unsigned int i = 0; i < extraHeaders->count(); i++) {\n                String * headerString = (String *)extraHeaders->objectAtIndex(i);\n                header = strdup(headerString->UTF8Characters());\n                clist_append(hdrlist, header);\n            }\n        }\n    }\n    \n    if (clist_begin(hdrlist) != NULL) {\n        struct mailimap_header_list * imap_hdrlist;\n        struct mailimap_section * section;\n        \n        imap_hdrlist = mailimap_header_list_new(hdrlist);\n        section = mailimap_section_new_header_fields(imap_hdrlist);\n        fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsHeader = true;\n    }\n    else {\n        clist_free(hdrlist);\n    }\n    \n    struct msg_att_handler_data msg_att_data;\n    \n    memset(&msg_att_data, 0, sizeof(msg_att_data));\n    msg_att_data.uidsFilter = uidsFilter;\n    msg_att_data.numbersFilter = numbersFilter;\n    msg_att_data.fetchByUID = fetchByUID;\n    msg_att_data.result = messages;\n    msg_att_data.requestKind = requestKind;\n    msg_att_data.mLastFetchedSequenceNumber = mLastFetchedSequenceNumber;\n    msg_att_data.mapping = mapping;\n    msg_att_data.needsHeader = needsHeader;\n    msg_att_data.needsBody = needsBody;\n    msg_att_data.needsFlags = needsFlags;\n    msg_att_data.needsGmailLabels = needsGmailLabels;\n    msg_att_data.needsGmailMessageID = needsGmailMessageID;\n    msg_att_data.needsGmailThreadID = needsGmailThreadID;\n    mailimap_set_msg_att_handler(mImap, msg_att_handler, &msg_att_data);\n    \n    mBodyProgressEnabled = false;\n    vanished = NULL;\n    \n    if (fetchByUID) {\n        if ((modseq != 0) && (mCondstoreEnabled || mQResyncEnabled)) {\n            if (mQResyncEnabled) {\n                r = mailimap_uid_fetch_qresync(mImap, imapset, fetch_type, modseq,\n                                               &fetch_result,  &vanished);\n            }\n            else { /* condstore */\n                r = mailimap_uid_fetch_changedsince(mImap, imapset, fetch_type, modseq,\n                                                    &fetch_result);\n            }\n        }\n        else {\n            r = mailimap_uid_fetch(mImap, imapset, fetch_type, &fetch_result);\n        }\n    } else {\n        if ((modseq != 0) && (mCondstoreEnabled || mQResyncEnabled)) {\n            if (mQResyncEnabled) {\n                r = mailimap_fetch_qresync(mImap, imapset, fetch_type, modseq,\n                                           &fetch_result,  &vanished);\n            }\n            else { /* condstore */\n                r = mailimap_fetch_changedsince(mImap, imapset, fetch_type, modseq,\n                                                &fetch_result);\n            }\n        }\n        else {\n            r = mailimap_fetch(mImap, imapset, fetch_type, &fetch_result);\n        }\n    }\n    \n    vanishedMessages = NULL;\n    if (vanished != NULL) {\n        vanishedMessages = indexSetFromSet(vanished->qr_known_uids);\n    }\n    \n    mBodyProgressEnabled = true;\n    \n    mProgressCallback = NULL;\n    \n    mLastFetchedSequenceNumber = msg_att_data.mLastFetchedSequenceNumber;\n    \n    mailimap_fetch_type_free(fetch_type);\n    \n    mailimap_set_msg_att_handler(mImap, NULL, NULL);\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        MCLog(\"error stream\");\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        MCLog(\"error parse\");\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        MCLog(\"error fetch\");\n        * pError = ErrorFetch;\n        return NULL;\n    }\n    \n    IMAPSyncResult * result;\n    result = new IMAPSyncResult();\n    result->setModifiedOrAddedMessages(messages);\n    result->setVanishedMessages(vanishedMessages);\n    result->autorelease();\n    \n    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {\n        if (messages->count() == 0) {\n            unsigned int count;\n            \n            count = clist_count(fetch_result);\n            if (count > 0) {\n                requestKind = (IMAPMessagesRequestKind) (requestKind & ~IMAPMessagesRequestKindHeaders);\n                requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindFullHeaders);\n\n                result = fetchMessages(folder, requestKind, fetchByUID,\n                    imapset, uidsFilter, numbersFilter,\n                    modseq, NULL, progressCallback, extraHeaders, pError);\n                if (result != NULL) {\n                    if (result->modifiedOrAddedMessages() != NULL) {\n                        if (result->modifiedOrAddedMessages()->count() > 0) {\n                            mNeedsMboxMailWorkaround = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    mailimap_fetch_list_free(fetch_result);\n    * pError = ErrorNone;\n    \n    return result;\n}\n\nArray * IMAPSession::fetchMessagesByUID(String * folder, IMAPMessagesRequestKind requestKind,\n                                        IndexSet * uids, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessagesByUIDWithExtraHeaders(folder, requestKind, uids, progressCallback, NULL, pError);\n}\n\n\nArray * IMAPSession::fetchMessagesByUIDWithExtraHeaders(String * folder, IMAPMessagesRequestKind requestKind,\n                                                        IndexSet * uids, IMAPProgressCallback * progressCallback,\n                                                        Array * extraHeaders, ErrorCode * pError)\n{\n    struct mailimap_set * imapset = setFromIndexSet(uids);\n    IMAPSyncResult * syncResult = fetchMessages(folder, requestKind, true, imapset, uids, NULL, 0, NULL,\n                                                progressCallback, extraHeaders, pError);\n    if (syncResult == NULL) {\n        mailimap_set_free(imapset);\n        return NULL;\n    }\n    Array * result = syncResult->modifiedOrAddedMessages();\n    result->retain()->autorelease();\n    mailimap_set_free(imapset);\n    return result;\n}\n\nArray * IMAPSession::fetchMessagesByNumber(String * folder, IMAPMessagesRequestKind requestKind,\n                                           IndexSet * numbers, IMAPProgressCallback * progressCallback,\n                                           ErrorCode * pError)\n{\n    return fetchMessagesByNumberWithExtraHeaders(folder, requestKind, numbers, progressCallback, NULL, pError);\n}\n\nArray * IMAPSession::fetchMessagesByNumberWithExtraHeaders(String * folder, IMAPMessagesRequestKind requestKind,\n                                                           IndexSet * numbers, IMAPProgressCallback * progressCallback,\n                                                           Array * extraHeaders, ErrorCode * pError)\n{\n    struct mailimap_set * imapset = setFromIndexSet(numbers);\n    IMAPSyncResult * syncResult = fetchMessages(folder, requestKind, false, imapset, NULL, numbers, 0, NULL,\n                                                progressCallback, extraHeaders, pError);\n    if (syncResult == NULL) {\n        mailimap_set_free(imapset);\n        return NULL;\n    }\n    Array * result = syncResult->modifiedOrAddedMessages();\n    result->retain()->autorelease();\n    mailimap_set_free(imapset);\n    return result;\n}\n\nstatic int fetch_rfc822(mailimap * session, bool identifier_is_uid,\n                        uint32_t identifier, char ** result, size_t * result_len)\n{\n    struct mailimap_section * section;\n    struct mailimap_fetch_att * fetch_att;\n    struct mailimap_fetch_type * fetch_type;\n    \n    section = mailimap_section_new(NULL);\n    fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);\n    int r = fetch_imap(session, identifier_is_uid, identifier,\n                       fetch_type, result, result_len);\n    mailimap_fetch_type_free(fetch_type);\n    \n    return r;\n    \n#if 0\n    int r;\n    clist * fetch_list;\n    struct mailimap_section * section;\n    struct mailimap_fetch_att * fetch_att;\n    struct mailimap_fetch_type * fetch_type;\n    struct mailimap_set * set;\n    struct mailimap_msg_att * msg_att;\n    struct mailimap_msg_att_item * item;\n    int res;\n    clistiter * cur;\n    \n    section = mailimap_section_new(NULL);\n    fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);\n    \n    set = mailimap_set_new_single(identifier);\n    \n    if (identifier_is_uid) {\n        r = mailimap_uid_fetch(session, set, fetch_type, &fetch_list);\n    }\n    else {\n        r = mailimap_fetch(session, set, fetch_type, &fetch_list);\n    }\n    \n    mailimap_set_free(set);\n    mailimap_fetch_type_free(fetch_type);\n    \n    if (r != MAILIMAP_NO_ERROR) {\n        res = r;\n        goto err;\n    }\n    \n    if (clist_isempty(fetch_list)) {\n        res = MAILIMAP_ERROR_FETCH;\n        goto free;\n    }\n    \n    msg_att = (struct mailimap_msg_att *) clist_begin(fetch_list)->data;\n    \n    for(cur = clist_begin(msg_att->att_list) ; cur != NULL ; cur = clist_next(cur)) {\n        item = (struct mailimap_msg_att_item *) clist_content(cur);\n        \n        if (item->att_type != MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            continue;\n        }\n        if (item->att_data.att_static->att_type != MAILIMAP_MSG_ATT_BODY_SECTION) {\n            continue;\n        }\n        \n        * result = item->att_data.att_static->att_data.att_body_section->sec_body_part;\n        item->att_data.att_static->att_data.att_body_section->sec_body_part = NULL;\n        mailimap_fetch_list_free(fetch_list);\n        \n        return MAILIMAP_NO_ERROR;\n    }\n    \n    res = MAILIMAP_ERROR_FETCH;\n    \nfree:\n    mailimap_fetch_list_free(fetch_list);\nerr:\n    return res;\n#endif\n}\n\nData * IMAPSession::fetchMessageByUID(String * folder, uint32_t uid,\n    IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessage(folder, true, uid, progressCallback, pError);\n}\n\nData * IMAPSession::fetchMessageByNumber(String * folder, uint32_t number,\n                                         IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessage(folder, false, number, progressCallback, pError);\n}\n\nData * IMAPSession::fetchMessage(String * folder, bool identifier_is_uid, uint32_t identifier,\n                                 IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    char * rfc822;\n    size_t rfc822_len;\n    int r;\n    Data * data;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    mProgressItemsCount = 0;\n    mProgressCallback = progressCallback;\n    \n    rfc822 = NULL;\n    r = fetch_rfc822(mImap, identifier_is_uid, identifier, &rfc822, &rfc822_len);\n    if (r == MAILIMAP_NO_ERROR) {\n        size_t len;\n        \n        len = 0;\n        if (rfc822 != NULL) {\n            len = strlen(rfc822);\n        }\n        bodyProgress((unsigned int) len, (unsigned int) len);\n    }\n    mProgressCallback = NULL;\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return NULL;\n    }\n    \n    if (rfc822 == NULL) {\n        data = Data::data();\n    }\n    else {\n        data = Data::dataWithBytes(rfc822, (unsigned int) rfc822_len);\n    }\n    \n    mailimap_nstring_free(rfc822);\n    * pError = ErrorNone;\n    \n    return data;\n}\n\nstatic void nstringDeallocator(char * bytes, unsigned int length) {\n    mailimap_nstring_free(bytes);\n};\n\nData * IMAPSession::fetchNonDecodedMessageAttachment(String * folder, bool identifier_is_uid,\n                                           uint32_t identifier, String * partID,\n                                           bool wholePart, uint32_t offset, uint32_t length,\n                                           Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    struct mailimap_fetch_type * fetch_type;\n    struct mailimap_fetch_att * fetch_att;\n    struct mailimap_section * section;\n    struct mailimap_section_part * section_part;\n    clist * sec_list;\n    Array * partIDArray;\n    int r;\n    char * text = NULL;\n    size_t text_length = 0;\n    Data * data;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    mProgressItemsCount = 0;\n    mProgressCallback = progressCallback;\n    bodyProgress(0, 0);\n\n    partIDArray = partID->componentsSeparatedByString(MCSTR(\".\"));\n    sec_list = clist_new();\n    for(unsigned int i = 0 ; i < partIDArray->count() ; i ++) {\n        uint32_t * value;\n        String * element;\n\n        element = (String *) partIDArray->objectAtIndex(i);\n        value = (uint32_t *) malloc(sizeof(* value));\n        * value = element->intValue();\n        clist_append(sec_list, value);\n    }\n    section_part = mailimap_section_part_new(sec_list);\n    section = mailimap_section_new_part(section_part);\n    if (wholePart) {\n        fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n    }\n    else {\n        fetch_att = mailimap_fetch_att_new_body_peek_section_partial(section, offset, length);\n    }\n    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);\n\n#ifdef LIBETPAN_HAS_MAILIMAP_RAMBLER_WORKAROUND\n    if (mRamblerRuServer && (encoding == EncodingBase64 || encoding == EncodingUUEncode)) {\n        mailimap_set_rambler_workaround_enabled(mImap, 1);\n    }\n#endif\n\n    r = fetch_imap(mImap, identifier_is_uid, identifier, fetch_type, &text, &text_length);\n    mailimap_fetch_type_free(fetch_type);\n\n#ifdef LIBETPAN_HAS_MAILIMAP_RAMBLER_WORKAROUND\n    mailimap_set_rambler_workaround_enabled(mImap, 0);\n#endif\n\n    mProgressCallback = NULL;\n    \n    MCLog(\"had error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return NULL;\n    }\n\n    data = Data::data();\n    data->takeBytesOwnership(text, (unsigned int) text_length, nstringDeallocator);\n    \n    * pError = ErrorNone;\n    \n    return data;\n}\n\nData * IMAPSession::fetchMessageAttachment(String * folder, bool identifier_is_uid,\n                                           uint32_t identifier, String * partID,\n                                           Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    Data * data = fetchNonDecodedMessageAttachment(folder, identifier_is_uid, identifier, partID, true, 0, 0, encoding, progressCallback, pError);\n    if (data) {\n        data = data->decodedDataUsingEncoding(encoding);\n    }\n    return data;\n}\n\nData * IMAPSession::fetchMessageAttachmentByUID(String * folder, uint32_t uid, String * partID,\n                                                Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessageAttachment(folder, true, uid, partID, encoding, progressCallback, pError);\n}\n\nData * IMAPSession::fetchMessageAttachmentByNumber(String * folder, uint32_t number, String * partID,\n                                              Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessageAttachment(folder, false, number, partID, encoding, progressCallback, pError);\n}\n\nvoid IMAPSession::fetchMessageAttachmentToFileByChunksByUID(String * folder, uint32_t uid, String * partID,\n                                                    uint32_t estimatedSize, Encoding encoding,\n                                                    String * outputFile, uint32_t chunkSize,\n                                                    IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    DataStreamDecoder * decoder = new DataStreamDecoder();\n    decoder->setEncoding(encoding);\n    decoder->setFilename(outputFile);\n\n    int nRetries = 0;\n    int const maxRetries = 3;\n    ErrorCode error = ErrorNone;\n    uint32_t offset = 0;\n    while (1) {\n        AutoreleasePool * pool = new AutoreleasePool();\n\n        LoadByChunkProgress * chunkProgressCallback = new LoadByChunkProgress();\n        chunkProgressCallback->setOffset(offset);\n        chunkProgressCallback->setEstimatedSize(estimatedSize);\n        chunkProgressCallback->setProgressCallback(progressCallback);\n\n        Data * data = fetchNonDecodedMessageAttachment(folder, true, uid, partID, false, offset, chunkSize, encoding, chunkProgressCallback, &error);\n\n        MC_SAFE_RELEASE(chunkProgressCallback);\n\n        if (error != ErrorNone) {\n            pool->release();\n            if ((error == ErrorConnection || error == ErrorParse) && nRetries < maxRetries) {\n                error = ErrorNone;\n                nRetries++;\n                continue;\n            }\n            break;\n        } else {\n            nRetries = 0;\n        }\n\n        if (data == NULL) {\n            break;\n        }\n\n        uint32_t encodedSize = data->length();\n        if (encodedSize == 0) {\n            pool->release();\n            break;\n        }\n\n        error = decoder->appendData(data);\n\n        pool->release();\n\n        if (error != ErrorNone) {\n            break;\n        }\n\n        offset += encodedSize;\n\n        // Try detect is this chunk last.\n        // Estimated size (extracted from BODYSTRUCTURE info) may be incorrect.\n        // Also, server may return chunk with size less than requested.\n        // So this detection is some tricky.\n        bool endOfPart = ((encodedSize == 0) ||\n                          (estimatedSize > 0 && (estimatedSize <= offset) && (encodedSize != chunkSize)) ||\n                          (estimatedSize == 0 && encodedSize < chunkSize));\n        if (endOfPart) {\n            break;\n        }\n    }\n\n    if (error == ErrorNone) {\n        decoder->flushData();\n    }\n\n    MC_SAFE_RELEASE(decoder);\n\n    * pError = error;\n}\n\nstatic bool msg_body_handler(int msg_att_type, struct mailimap_msg_att_body_section * section,\n                             const char * bytes, size_t len, void * context)\n{\n    DataStreamDecoder * decoder = (DataStreamDecoder *)context;\n\n    AutoreleasePool * pool = new AutoreleasePool();\n\n    Data * data = Data::dataWithBytes(bytes, (unsigned int) len);\n    ErrorCode error = decoder->appendData(data);\n\n    pool->release();\n\n    return error == ErrorNone;\n}\n\nvoid IMAPSession::fetchMessageAttachmentToFileByUID(String * folder, uint32_t uid, String * partID,\n                                                    Encoding encoding, String * outputFile,\n                                                    IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    DataStreamDecoder * decoder = new DataStreamDecoder();\n    decoder->setEncoding(encoding);\n    decoder->setFilename(outputFile);\n\n    ErrorCode error = ErrorNone;\n    selectIfNeeded(folder, &error);\n    if (error != ErrorNone) {\n        * pError = error;\n        return;\n    }\n\n    mailimap_set_msg_body_handler(mImap, msg_body_handler, decoder);\n\n    fetchNonDecodedMessageAttachment(folder, true, uid, partID, true, 0, 0, encoding, progressCallback, &error);\n\n    mailimap_set_msg_body_handler(mImap, NULL, NULL);\n\n    if (error == ErrorNone) {\n        error = decoder->flushData();\n    }\n\n    MC_SAFE_RELEASE(decoder);\n\n    * pError = error;\n}\n\nIndexSet * IMAPSession::search(String * folder, IMAPSearchKind kind, String * searchString, ErrorCode * pError)\n{\n    IMAPSearchExpression * expr;\n    \n    expr = NULL;\n    switch (kind) {\n        case IMAPSearchKindAll:\n        {\n            expr = IMAPSearchExpression::searchAll();\n            break;\n        }\n        case IMAPSearchKindFrom:\n        {\n            expr = IMAPSearchExpression::searchFrom(searchString);\n            break;\n        }\n        case IMAPSearchKindTo:\n        {\n            expr = IMAPSearchExpression::searchTo(searchString);\n            break;\n        }\n        case IMAPSearchKindCc:\n        {\n            expr = IMAPSearchExpression::searchCc(searchString);\n            break;\n        }\n        case IMAPSearchKindBcc:\n        {\n            expr = IMAPSearchExpression::searchBcc(searchString);\n            break;\n        }\n        case IMAPSearchKindRecipient:\n        {\n            expr = IMAPSearchExpression::searchRecipient(searchString);\n            break;\n        }\n        case IMAPSearchKindSubject:\n        {\n            expr = IMAPSearchExpression::searchSubject(searchString);\n            break;\n        }\n        case IMAPSearchKindContent:\n        {\n            expr = IMAPSearchExpression::searchContent(searchString);\n            break;\n        }\n        case IMAPSearchKindBody:\n        {\n            expr = IMAPSearchExpression::searchBody(searchString);\n            break;\n        }\n        case IMAPSearchKindRead:\n        {\n            expr = IMAPSearchExpression::searchRead();\n            break;\n        }\n        case IMAPSearchKindUnread:\n        {\n            expr = IMAPSearchExpression::searchUnread();\n            break;\n        }\n        case IMAPSearchKindFlagged:\n        {\n            expr = IMAPSearchExpression::searchFlagged();\n            break;\n        }\n        case IMAPSearchKindUnflagged:\n        {\n            expr = IMAPSearchExpression::searchUnflagged();\n            break;\n        }\n        case IMAPSearchKindAnswered:\n        {\n            expr = IMAPSearchExpression::searchAnswered();\n            break;\n        }\n        case IMAPSearchKindUnanswered:\n        {\n            expr = IMAPSearchExpression::searchUnanswered();\n            break;\n        }\n        case IMAPSearchKindDraft:\n        {\n            expr = IMAPSearchExpression::searchDraft();\n            break;\n        }\n        case IMAPSearchKindUndraft:\n        {\n            expr = IMAPSearchExpression::searchUndraft();\n            break;\n        }\n        case IMAPSearchKindDeleted:\n        {\n            expr = IMAPSearchExpression::searchDeleted();\n            break;\n        }\n        case IMAPSearchKindSpam:\n        {\n            expr = IMAPSearchExpression::searchSpam();\n            break;\n        }\n        case IMAPSearchKindHeader:\n        {\n            String *header = new String(\"Message-ID\");\n            expr = IMAPSearchExpression::searchHeader(header, searchString);\n            break;\n        }\n        default:\n        {\n            MCAssert(0);\n            break;\n        }\n    }\n    return search(folder, expr, pError);\n}\n\nstatic struct mailimap_search_key * searchKeyFromSearchExpression(IMAPSearchExpression * expression)\n{\n    switch (expression->kind()) {\n        case IMAPSearchKindAll:\n        {\n            return mailimap_search_key_new_all();\n        }\n        case IMAPSearchKindFrom:\n        {\n            return mailimap_search_key_new_from(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindTo:\n        {\n            return mailimap_search_key_new_to(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindCc:\n        {\n            return mailimap_search_key_new_cc(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindBcc:\n        {\n            return mailimap_search_key_new_bcc(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindRecipient:\n        {\n            struct mailimap_search_key * to_search;\n            struct mailimap_search_key * cc_search;\n            struct mailimap_search_key * bcc_search;\n            struct mailimap_search_key * or_search1;\n            struct mailimap_search_key * or_search2;\n            \n            to_search = mailimap_search_key_new_to(strdup(expression->value()->UTF8Characters()));\n            cc_search = mailimap_search_key_new_cc(strdup(expression->value()->UTF8Characters()));\n            bcc_search = mailimap_search_key_new_bcc(strdup(expression->value()->UTF8Characters()));\n            \n            or_search1 = mailimap_search_key_new_or(to_search, cc_search);\n            or_search2 = mailimap_search_key_new_or(or_search1, bcc_search);\n            \n            return or_search2;\n        }\n        case IMAPSearchKindSubject:\n        {\n            return mailimap_search_key_new_subject(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindContent:\n        {\n            return mailimap_search_key_new_text(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindBody:\n        {\n            return mailimap_search_key_new_body(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindUIDs:\n        {\n            return mailimap_search_key_new_uid(setFromIndexSet(expression->uids()));\n        }\n        case IMAPSearchKindNumbers:\n        {\n            return mailimap_search_key_new_set(setFromIndexSet(expression->numbers()));\n        }\n        case IMAPSearchKindHeader:\n        {\n            return mailimap_search_key_new_header(strdup(expression->header()->UTF8Characters()), strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindBeforeDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_sentbefore(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindOnDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_senton(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindSinceDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_sentsince(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindBeforeReceivedDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_before(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindOnReceivedDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_on(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindSinceReceivedDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_since(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindGmailThreadID:\n        {\n            return mailimap_search_key_new_xgmthrid(expression->longNumber());\n        }\n        case IMAPSearchKindGmailMessageID:\n        {\n            return mailimap_search_key_new_xgmmsgid(expression->longNumber());\n        }\n        case IMAPSearchKindRead:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_SEEN, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUnread:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNSEEN, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindFlagged:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_FLAGGED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUnflagged:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNFLAGGED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindAnswered:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_ANSWERED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUnanswered:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNANSWERED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindDraft:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_DRAFT, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUndraft:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNDRAFT, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindDeleted:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_DELETED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindSpam:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_KEYWORD, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           strdup(\"Junk\"), NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindSizeLarger:\n        {\n            return mailimap_search_key_new_larger( (uint32_t) expression->longNumber());\n        }\n        case IMAPSearchKindSizeSmaller:\n        {\n            return mailimap_search_key_new_smaller( (uint32_t) expression->longNumber());\n        }\n        case IMAPSearchKindGmailRaw:\n        {\n            return mailimap_search_key_new_xgmraw(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindOr:\n        {\n            return mailimap_search_key_new_or(searchKeyFromSearchExpression(expression->leftExpression()), searchKeyFromSearchExpression(expression->rightExpression()));\n        }\n        case IMAPSearchKindAnd:\n        {\n            clist * list;\n            list = clist_new();\n            clist_append(list, searchKeyFromSearchExpression(expression->leftExpression()));\n            clist_append(list, searchKeyFromSearchExpression(expression->rightExpression()));\n            return mailimap_search_key_new_multiple(list);\n        }\n        case IMAPSearchKindNot:\n        {\n            return mailimap_search_key_new_not(searchKeyFromSearchExpression(expression->leftExpression()));\n        }\n\n        default:\n        MCAssert(0);\n        return NULL;\n    }\n}\n\nIndexSet * IMAPSession::search(String * folder, IMAPSearchExpression * expression, ErrorCode * pError)\n{\n    struct mailimap_search_key * key;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    clist * result_list = NULL;\n    \n    const char * charset = \"utf-8\";\n    if (mYahooServer) {\n        charset = NULL;\n    }\n    \n    int r;\n    key = searchKeyFromSearchExpression(expression);\n    if (mIsGmail) {\n        r = mailimap_uid_search_literalplus(mImap, charset, key, &result_list);\n    }\n    else {\n        r = mailimap_uid_search(mImap, charset, key, &result_list);\n    }\n    mailimap_search_key_free(key);\n    MCLog(\"had error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return NULL;\n    }\n\n    IndexSet * result = IndexSet::indexSet();\n    for(clistiter * cur = clist_begin(result_list) ; cur != NULL ; cur = clist_next(cur))  {\n        uint32_t * uid = (uint32_t *) clist_content(cur);\n        result->addIndex(* uid);\n    }\n    mailimap_search_result_free(result_list);\n    * pError = ErrorNone;\n    return result;\n}\n\nvoid IMAPSession::getQuota(uint32_t *usage, uint32_t *limit, ErrorCode * pError)\n{\n    mailimap_quota_complete_data *quota_data;\n    \n    int r = mailimap_quota_getquotaroot(mImap, \"INBOX\", &quota_data);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return;\n    }\n    for(clistiter * cur = clist_begin(quota_data->quota_list); cur != NULL; cur = clist_next(cur)) {\n        mailimap_quota_quota_data *quota = (mailimap_quota_quota_data*)clist_content(cur);\n        for (clistiter *cur2 = clist_begin(quota->quota_list); cur2 != NULL; cur2 = clist_next(cur2)) {\n            mailimap_quota_quota_resource *res = (mailimap_quota_quota_resource*)clist_content(cur2);\n            if (!strcasecmp(\"STORAGE\", res->resource_name)) {\n                *usage = res->usage;\n                *limit = res->limit;\n            }\n        }\n    }\n    mailimap_quota_complete_data_free(quota_data);    \n}\n\nbool IMAPSession::setupIdle()\n{\n    // main thread\n    LOCK();\n    bool canIdle = mIdleEnabled;\n    if (mIdleEnabled) {\n        mailstream_setup_idle(mImap->imap_stream);\n    }\n    UNLOCK();\n    return canIdle;\n}\n\nvoid IMAPSession::idle(String * folder, uint32_t lastKnownUID, Data ** response, ErrorCode * pError)\n{\n    int r;\n    \n    setNeedsReselect();\n\n    // connection thread\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    if (lastKnownUID != 0) {\n        Array * msgs;\n        \n        msgs = fetchMessagesByUID(folder, IMAPMessagesRequestKindUid, IndexSet::indexSetWithRange(RangeMake(lastKnownUID, UINT64_MAX)),\n                                  NULL, pError);\n        if (* pError != ErrorNone)\n            return;\n        if (msgs->count() > 0) {\n            IMAPMessage * msg;\n            \n            msg = (IMAPMessage *) msgs->objectAtIndex(0);\n            if (msg->uid() > lastKnownUID) {\n                MCLog(\"found msg UID %u %u\", (unsigned int) msg->uid(), (unsigned int) lastKnownUID);\n                return;\n            }\n        }\n    }\n    \n    r = mailimap_idle(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorIdle;\n        return;\n    }\n    \n    if (!mImap->imap_selection_info->sel_has_exists && !mImap->imap_selection_info->sel_has_recent) {\n        int r;\n        r = mailstream_wait_idle(mImap->imap_stream, MAX_IDLE_DELAY);\n        switch (r) {\n            case MAILSTREAM_IDLE_ERROR:\n            case MAILSTREAM_IDLE_CANCELLED:\n            {\n                mShouldDisconnect = true;\n                * pError = ErrorConnection;\n                MCLog(\"error or cancelled\");\n                return;\n            }\n            case MAILSTREAM_IDLE_INTERRUPTED:\n                * pError = ErrorIdleInterrupted;\n                MCLog(\"interrupted by user\");\n                break;\n            case MAILSTREAM_IDLE_HASDATA:\n                MCLog(\"something on the socket\");\n                break;\n            case MAILSTREAM_IDLE_TIMEOUT:\n                MCLog(\"idle timeout\");\n                break;\n        }\n    }\n    else {\n        MCLog(\"found info before idling\");\n    }\n    \n    r = mailimap_idle_done(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorIdle;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::interruptIdle()\n{\n    // main thread\n    LOCK();\n    if (mIdleEnabled) {\n        mailstream_interrupt_idle(mImap->imap_stream);\n    }\n    UNLOCK();\n}\n\nvoid IMAPSession::unsetupIdle()\n{\n    // main thread\n    LOCK();\n    if (mIdleEnabled) {\n        mailstream_unsetup_idle(mImap->imap_stream);\n    }\n    UNLOCK();\n}\n\nvoid IMAPSession::disconnect()\n{\n    unsetup();\n}\n\nvoid IMAPSession::reconnect(ErrorCode * pError)\n{\n    mShouldDisconnect = true;\n    connectIfNeeded(pError);\n}\n\nIMAPIdentity * IMAPSession::identity(IMAPIdentity * clientIdentity, ErrorCode * pError)\n{\n    connectIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    struct mailimap_id_params_list * client_identification;\n\n    client_identification = mailimap_id_params_list_new_empty();\n\n    mc_foreacharray(String, key, clientIdentity->allInfoKeys()) {\n        MMAPString * mmap_str_name = mmap_string_new(key->UTF8Characters());\n        MMAPString * mmap_str_value = mmap_string_new(clientIdentity->infoForKey(key)->UTF8Characters());\n        mmap_string_ref(mmap_str_name);\n        mmap_string_ref(mmap_str_value);\n        mailimap_id_params_list_add_name_value(client_identification, mmap_str_name->str, mmap_str_value->str);\n    }\n\n    int r;\n    struct mailimap_id_params_list * server_identification;\n    r = mailimap_id(mImap, client_identification, &server_identification);\n    mailimap_id_params_list_free(client_identification);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorIdentity;\n        return NULL;\n    }\n\n    IMAPIdentity * result = new IMAPIdentity();\n    \n    clistiter * cur;\n    for(cur = clist_begin(server_identification->idpa_list) ; cur != NULL ; cur = clist_next(cur)) {\n        struct mailimap_id_param * param;\n\n        param = (struct mailimap_id_param *) clist_content(cur);\n        \n        String * responseKey;\n        String * responseValue;\n        responseKey = String::stringWithUTF8Characters(param->idpa_name);\n        responseValue = String::stringWithUTF8Characters(param->idpa_value);\n        result->setInfoForKey(responseKey, responseValue);\n    }\n\n    mailimap_id_params_list_free(server_identification);\n    * pError = ErrorNone;\n\n    result->autorelease();\n    return result;\n}\n\nvoid IMAPSession::bodyProgress(unsigned int current, unsigned int maximum)\n{\n    if (!mBodyProgressEnabled)\n        return;\n    \n    if (mProgressCallback != NULL) {\n        mProgressCallback->bodyProgress(this, current, maximum);\n    }\n}\n\nvoid IMAPSession::itemsProgress(unsigned int current, unsigned int maximum)\n{\n    mProgressItemsCount ++;\n    if (mProgressCallback != NULL) {\n        mProgressCallback->itemsProgress(this, mProgressItemsCount, maximum);\n    }\n}\n\nIMAPNamespace * IMAPSession::defaultNamespace()\n{\n    return mDefaultNamespace;\n}\n\nvoid IMAPSession::setDefaultNamespace(IMAPNamespace * ns)\n{\n    MC_SAFE_REPLACE_RETAIN(IMAPNamespace, mDefaultNamespace, ns);\n}\n\nIMAPIdentity * IMAPSession::serverIdentity()\n{\n    return mServerIdentity;\n}\n\nIMAPIdentity * IMAPSession::clientIdentity()\n{\n    return mClientIdentity;\n}\n\nvoid IMAPSession::setClientIdentity(IMAPIdentity * identity)\n{\n    MC_SAFE_REPLACE_COPY(IMAPIdentity, mClientIdentity, identity);\n}\n\nHashMap * IMAPSession::fetchNamespace(ErrorCode * pError)\n{\n    HashMap * result;\n    struct mailimap_namespace_data * namespace_data;\n    int r;\n    \n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    result = HashMap::hashMap();\n    r = mailimap_namespace(mImap, &namespace_data);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNamespace;\n        return NULL;\n    }\n    \n    IMAPNamespace * ns;\n    \n    if (namespace_data->ns_personal != NULL) {\n        ns = new IMAPNamespace();\n        ns->importIMAPNamespace(namespace_data->ns_personal);\n        result->setObjectForKey(IMAPNamespacePersonal, ns);\n        ns->release();\n    }\n    \n    if (namespace_data->ns_other != NULL) {\n        ns = new IMAPNamespace();\n        ns->importIMAPNamespace(namespace_data->ns_other);\n        result->setObjectForKey(IMAPNamespaceOther, ns);\n        ns->release();\n    }\n    \n    if (namespace_data->ns_shared != NULL) {\n        ns = new IMAPNamespace();\n        ns->importIMAPNamespace(namespace_data->ns_shared);\n        result->setObjectForKey(IMAPNamespaceShared, ns);\n        ns->release();\n    }\n    \n    mailimap_namespace_data_free(namespace_data);\n    * pError = ErrorNone;\n    \n    return result;\n}\n\nvoid IMAPSession::storeFlagsByUID(String * folder, IndexSet * uids, IMAPStoreFlagsRequestKind kind, MessageFlag flags, ErrorCode * pError)\n{\n    this->storeFlagsAndCustomFlagsByUID(folder, uids, kind, flags, NULL, pError);\n}\n\nvoid IMAPSession::storeFlagsAndCustomFlagsByUID(String * folder, IndexSet * uids, IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)\n{\n    storeFlagsAndCustomFlags(folder, true, uids, kind, flags, customFlags, pError);\n}\n\nvoid IMAPSession::storeFlagsAndCustomFlags(String * folder, bool identifier_is_uid, IndexSet * identifiers,\n                                                      IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)\n{\n    struct mailimap_set * imap_set;\n    struct mailimap_store_att_flags * store_att_flags;\n    struct mailimap_flag_list * flag_list;\n    int r;\n    clist * setList;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    imap_set = setFromIndexSet(identifiers);\n    if (clist_count(imap_set->set_list) == 0) {\n        mailimap_set_free(imap_set);\n        return;\n    }\n\n    setList = splitSet(imap_set, 50);\n\n    flag_list = mailimap_flag_list_new_empty();\n    if ((flags & MessageFlagSeen) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_seen();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagAnswered) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_answered();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagFlagged) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flagged();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagDeleted) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_deleted();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagDraft) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_draft();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagMDNSent) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flag_keyword(strdup(\"$MDNSent\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagForwarded) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flag_keyword(strdup(\"$Forwarded\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagSubmitPending) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flag_keyword(strdup(\"$SubmitPending\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagSubmitted) != 0) {\n        struct mailimap_flag * f;\n        \n        f = mailimap_flag_new_flag_keyword(strdup(\"$Submitted\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    \n    if (customFlags != NULL) {\n        for (unsigned int i = 0 ; i < customFlags->count() ; i ++) {\n            struct mailimap_flag * f;\n            String * customFlag = (String *) customFlags->objectAtIndex(i);\n            \n            f = mailimap_flag_new_flag_keyword(strdup(customFlag->UTF8Characters()));\n            mailimap_flag_list_add(flag_list, f);\n        }\n    }\n\n    store_att_flags = NULL;\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        switch (kind) {\n            case IMAPStoreFlagsRequestKindRemove:\n            store_att_flags = mailimap_store_att_flags_new_remove_flags_silent(flag_list);\n            break;\n            case IMAPStoreFlagsRequestKindAdd:\n            store_att_flags = mailimap_store_att_flags_new_add_flags_silent(flag_list);\n            break;\n            case IMAPStoreFlagsRequestKindSet:\n            store_att_flags = mailimap_store_att_flags_new_set_flags_silent(flag_list);\n            break;\n        }\n\n#ifdef LIBETPAN_HAS_MAILIMAP_QIP_WORKAROUND\n        if (mQipServer) {\n            mailimap_set_qip_workaround_enabled(mImap, 1);\n        }\n#endif\n\n        if (identifier_is_uid) {\n            r = mailimap_uid_store(mImap, current_set, store_att_flags);\n        }\n        else {\n            r = mailimap_store(mImap, current_set, store_att_flags);\n        }\n\n#ifdef LIBETPAN_HAS_MAILIMAP_QIP_WORKAROUND\n        mailimap_set_qip_workaround_enabled(mImap, 0);\n#endif\n\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorStore;\n            goto release;\n        }\n    }\n    * pError = ErrorNone;\n\n    release:\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_store_att_flags_free(store_att_flags);\n    mailimap_set_free(imap_set);\n}\n\nvoid IMAPSession::storeFlagsByNumber(String * folder, IndexSet * numbers, IMAPStoreFlagsRequestKind kind, MessageFlag flags, ErrorCode * pError)\n{\n    this->storeFlagsAndCustomFlagsByNumber(folder, numbers, kind, flags, NULL, pError);\n}\n\nvoid IMAPSession::storeFlagsAndCustomFlagsByNumber(String * folder, IndexSet * numbers, IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)\n{\n    storeFlagsAndCustomFlags(folder, false, numbers, kind, flags, customFlags, pError);\n}\n\nvoid IMAPSession::storeLabelsByUID(String * folder, IndexSet * uids, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)\n{\n    storeLabels(folder, true, uids, kind, labels, pError);\n}\n\nvoid IMAPSession::storeLabelsByNumber(String * folder, IndexSet * numbers, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)\n{\n    storeLabels(folder, false, numbers, kind, labels, pError);\n}\n\nvoid IMAPSession::storeLabels(String * folder, bool identifier_is_uid, IndexSet * identifiers, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)\n{\n    struct mailimap_set * imap_set;\n    struct mailimap_msg_att_xgmlabels * xgmlabels;\n    int r;\n    clist * setList;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    imap_set = setFromIndexSet(identifiers);\n    if (clist_count(imap_set->set_list) == 0) {\n        mailimap_set_free(imap_set);\n        return;\n    }\n\n    setList = splitSet(imap_set, 10);\n\n    xgmlabels = mailimap_msg_att_xgmlabels_new_empty();\n    for(unsigned int i = 0 ; i < labels->count() ; i ++) {\n        String * label = (String *) labels->objectAtIndex(i);\n        mailimap_msg_att_xgmlabels_add(xgmlabels, strdup(label->UTF8Characters()));\n    }\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n        int fl_sign;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        switch (kind) {\n            case IMAPStoreFlagsRequestKindRemove:\n            fl_sign = -1;\n            break;\n            case IMAPStoreFlagsRequestKindAdd:\n            fl_sign = 1;\n            break;\n            case IMAPStoreFlagsRequestKindSet:\n            fl_sign = 0;\n            break;\n        }\n        if (identifier_is_uid) {\n            r = mailimap_uid_store_xgmlabels(mImap, current_set, fl_sign, 1, xgmlabels);\n        }\n        else {\n            r = mailimap_store_xgmlabels(mImap, current_set, fl_sign, 1, xgmlabels);\n        }\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorStore;\n            goto release;\n        }\n    }\n    * pError = ErrorNone;\n\n    release:\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_msg_att_xgmlabels_free(xgmlabels);\n    mailimap_set_free(imap_set);\n}\n\nuint32_t IMAPSession::uidValidity()\n{\n    return mUIDValidity;\n}\n\nuint32_t IMAPSession::uidNext()\n{\n    return mUIDNext;\n}\n\nuint64_t IMAPSession::modSequenceValue()\n{\n    return mModSequenceValue;\n}\n\nunsigned int IMAPSession::lastFolderMessageCount()\n{\n    return mFolderMsgCount;\n}\n\nuint32_t IMAPSession::firstUnseenUid()\n{\n    return mFirstUnseenUid;\n}\n\nuint32_t IMAPSession::unseenCount()\n{\n    return mUnseenCount;\n}\n\nIMAPSyncResult * IMAPSession::syncMessagesByUID(String * folder, IMAPMessagesRequestKind requestKind,\n                                                IndexSet * uids, uint64_t modseq,\n                                                IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return syncMessagesByUIDWithExtraHeaders(folder, requestKind, uids, modseq, progressCallback, NULL, pError);\n}\n\nIMAPSyncResult * IMAPSession::syncMessagesByUIDWithExtraHeaders(String * folder, IMAPMessagesRequestKind requestKind,\n                                                IndexSet * uids, uint64_t modseq,\n                                                IMAPProgressCallback * progressCallback, Array * extraHeaders,\n                                                ErrorCode * pError)\n{\n    struct mailimap_set * imapset = setFromIndexSet(uids);\n    IMAPSyncResult * result = fetchMessages(folder, requestKind, true, imapset,\n                                            uids, NULL,\n                                            modseq, NULL,\n                                            progressCallback, extraHeaders, pError);\n    mailimap_set_free(imapset);\n    return result;\n\n}\n\nIndexSet * IMAPSession::capability(ErrorCode * pError)\n{\n    int r;\n    struct mailimap_capability_data * cap;\n    \n    connectIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    r = mailimap_capability(mImap, &cap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCapability;\n        return NULL;\n    }\n    \n    mailimap_capability_data_free(cap);\n    \n    IndexSet * result = new IndexSet();\n    capabilitySetWithSessionState(result);\n    \n    * pError = ErrorNone;\n    result->autorelease();\n    return result;\n}\n\nvoid IMAPSession::capabilitySetWithSessionState(IndexSet * capabilities)\n{\n    if (mailimap_has_extension(mImap, (char *)\"STARTTLS\")) {\n        capabilities->addIndex(IMAPCapabilityStartTLS);\n    }\n    if (mailimap_has_authentication(mImap, (char *)\"PLAIN\")) {\n        capabilities->addIndex(IMAPCapabilityAuthPlain);\n    }\n    if (mailimap_has_authentication(mImap, (char *)\"LOGIN\")) {\n        capabilities->addIndex(IMAPCapabilityAuthLogin);\n    }\n    if (mailimap_has_idle(mImap)) {\n        capabilities->addIndex(IMAPCapabilityIdle);\n    }\n    if (mailimap_has_id(mImap)) {\n        capabilities->addIndex(IMAPCapabilityId);\n    }\n    if (mailimap_has_xlist(mImap)) {\n        capabilities->addIndex(IMAPCapabilityXList);\n    }\n    if (mailimap_has_extension(mImap, (char *) \"X-GM-EXT-1\")) {\n        // Disable use of XLIST if this is the Gmail IMAP server because it implements\n        // RFC 6154.\n        capabilities->addIndex(IMAPCapabilityGmail);\n    }\n    if (mailimap_has_condstore(mImap)) {\n        capabilities->addIndex(IMAPCapabilityCondstore);\n    }\n    if (mailimap_has_qresync(mImap)) {\n        capabilities->addIndex(IMAPCapabilityQResync);\n    }\n    if (mailimap_has_xoauth2(mImap)) {\n        capabilities->addIndex(IMAPCapabilityXOAuth2);\n    }\n    if (mailimap_has_namespace(mImap)) {\n        capabilities->addIndex(IMAPCapabilityNamespace);\n    }\n    if (mailimap_has_compress_deflate(mImap)) {\n        capabilities->addIndex(IMAPCapabilityCompressDeflate);\n    }\n    if (mailimap_has_extension(mImap, (char *)\"CHILDREN\")) {\n        capabilities->addIndex(IMAPCapabilityChildren);\n    }\n    if (mailimap_has_extension(mImap, (char *)\"MOVE\")) {\n        capabilities->addIndex(IMAPCapabilityMove);\n    }\n    if (mailimap_has_extension(mImap, (char *)\"XYMHIGHESTMODSEQ\")) {\n        capabilities->addIndex(IMAPCapabilityXYMHighestModseq);\n    }\n    applyCapabilities(capabilities);\n}\n\nIndexSet * IMAPSession::storedCapabilities() {\n    return (IndexSet *)MC_SAFE_COPY(mCurrentCapabilities);\n}\n\nvoid IMAPSession::applyCapabilities(IndexSet * capabilities)\n{\n    if (capabilities->containsIndex(IMAPCapabilityId)) {\n        mIdentityEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityXList)) {\n        mXListEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityGmail)) {\n        mXListEnabled = false;\n        mCondstoreEnabled = true;\n        mIsGmail = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityIdle)) {\n        LOCK();\n        mIdleEnabled = true;\n        UNLOCK();\n    }\n    if (capabilities->containsIndex(IMAPCapabilityCondstore)) {\n        mCondstoreEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityQResync)) {\n        mQResyncEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityXYMHighestModseq)) {\n        mXYMHighestModseqEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityXOAuth2)) {\n        mXOauth2Enabled = true;\n    }\n    if (mHermesServer) {\n        // Hermes server improperly advertise a namespace capability.\n    }\n    else {\n        if (capabilities->containsIndex(IMAPCapabilityNamespace)) {\n            mNamespaceEnabled = true;\n        }\n    }\n    if (capabilities->containsIndex(IMAPCapabilityCompressDeflate)) {\n        mCompressionEnabled = true;\n    }\n}\n\nbool IMAPSession::isIdleEnabled()\n{\n    LOCK();\n    bool idleEnabled = mIdleEnabled;\n    UNLOCK();\n    return idleEnabled;\n}\n\nbool IMAPSession::isXListEnabled()\n{\n    return mXListEnabled;\n}\n\nbool IMAPSession::isCondstoreEnabled()\n{\n    return mCondstoreEnabled;\n}\n\nbool IMAPSession::isQResyncEnabled()\n{\n    return mQResyncEnabled;\n}\n\nbool IMAPSession::isIdentityEnabled()\n{\n    return mIdentityEnabled;\n}\n\nbool IMAPSession::isXOAuthEnabled()\n{\n    return mXOauth2Enabled;\n}\n\nbool IMAPSession::isNamespaceEnabled()\n{\n    return mNamespaceEnabled;\n}\n\nbool IMAPSession::isCompressionEnabled()\n{\n    return mCompressionEnabled;\n}\n\nbool IMAPSession::allowsNewPermanentFlags() {\n    return mAllowsNewPermanentFlags;\n}\n\nbool IMAPSession::isDisconnected()\n{\n    return mState == STATE_DISCONNECTED;\n}\n\nvoid IMAPSession::setConnectionLogger(ConnectionLogger * logger)\n{\n    lockConnectionLogger();\n    mConnectionLogger = logger;\n    unlockConnectionLogger();\n}\n\nConnectionLogger * IMAPSession::connectionLogger()\n{\n    ConnectionLogger * result;\n\n    lockConnectionLogger();\n    result = mConnectionLogger;\n    unlockConnectionLogger();\n\n    return result;\n}\n\nvoid IMAPSession::lockConnectionLogger()\n{\n    pthread_mutex_lock(&mConnectionLoggerLock);\n}\n\nvoid IMAPSession::unlockConnectionLogger()\n{\n    pthread_mutex_unlock(&mConnectionLoggerLock);\n}\n\nConnectionLogger * IMAPSession::connectionLoggerNoLock()\n{\n    return mConnectionLogger;\n}\n\nString * IMAPSession::htmlRendering(IMAPMessage * message, String * folder, ErrorCode * pError)\n{\n    HTMLRendererIMAPDataCallback * dataCallback = new HTMLRendererIMAPDataCallback(this, message->uid());\n    String * htmlString = HTMLRenderer::htmlForIMAPMessage(folder,\n                                                           message,\n                                                           dataCallback,\n                                                           NULL);\n    * pError = dataCallback->error();\n    \n    MC_SAFE_RELEASE(dataCallback);\n\n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    return htmlString;\n}\n\nString * IMAPSession::htmlBodyRendering(IMAPMessage * message, String * folder, ErrorCode * pError)\n{\n    MCAssert(folder != NULL);\n    HTMLRendererIMAPDataCallback * dataCallback = new HTMLRendererIMAPDataCallback(this, message->uid());\n    HTMLBodyRendererTemplateCallback * htmlCallback = new HTMLBodyRendererTemplateCallback();\n    \n    String * htmlBodyString = HTMLRenderer::htmlForIMAPMessage(folder,\n                                                               message,\n                                                               dataCallback,\n                                                               htmlCallback);\n\n    * pError = dataCallback->error();\n    \n    MC_SAFE_RELEASE(dataCallback);\n    MC_SAFE_RELEASE(htmlCallback);\n\n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    return htmlBodyString;\n}\n\nString * IMAPSession::plainTextRendering(IMAPMessage * message, String * folder, ErrorCode * pError)\n{\n    String * htmlString = htmlRendering(message, folder, pError);\n    \n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    String * plainTextString = htmlString->flattenHTML();\n    return plainTextString;\n}\n\nString * IMAPSession::plainTextBodyRendering(IMAPMessage * message, String * folder, bool stripWhitespace, ErrorCode * pError)\n{\n    MCAssert(folder != NULL);\n    String * htmlBodyString = htmlBodyRendering(message, folder, pError);\n    \n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    String * plainTextBodyString = htmlBodyString->flattenHTML();\n    if (stripWhitespace) {\n        return plainTextBodyString->stripWhitespace();\n    }\n    \n    return plainTextBodyString;\n}\n\nvoid IMAPSession::setAutomaticConfigurationEnabled(bool enabled)\n{\n    mAutomaticConfigurationEnabled = enabled;\n}\n\nbool IMAPSession::isAutomaticConfigurationEnabled()\n{\n    return mAutomaticConfigurationEnabled;\n}\n\nbool IMAPSession::enableFeature(String * feature)\n{\n    struct mailimap_capability_data * caps;\n    clist * cap_list;\n    struct mailimap_capability * cap;\n    int r;\n    \n    cap_list = clist_new();\n    cap = mailimap_capability_new(MAILIMAP_CAPABILITY_NAME, NULL, strdup(MCUTF8(feature)));\n    clist_append(cap_list, cap);\n    caps = mailimap_capability_data_new(cap_list);\n    \n    struct mailimap_capability_data * result;\n    r = mailimap_enable(mImap, caps, &result);\n    mailimap_capability_data_free(caps);\n    if (r != MAILIMAP_NO_ERROR)\n        return false;\n    \n    mailimap_capability_data_free(result);\n    \n    return true;\n}\n\nvoid IMAPSession::enableFeatures()\n{\n    if (isCompressionEnabled()) {\n        ErrorCode error;\n        enableCompression(&error);\n        if (error != ErrorNone) {\n            MCLog(\"could not enable compression\");\n        }\n    }\n    \n    if (isQResyncEnabled()) {\n        enableFeature(MCSTR(\"QRESYNC\"));\n    }\n    else if (isCondstoreEnabled()) {\n        enableFeature(MCSTR(\"CONDSTORE\"));\n    }\n}\n\nvoid IMAPSession::enableCompression(ErrorCode * pError)\n{\n    int r;\n    r = mailimap_compress(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCompression;\n        return;\n    }\n    \n    * pError = ErrorNone;\n}\n\nbool IMAPSession::isAutomaticConfigurationDone()\n{\n    return mAutomaticConfigurationDone;\n}\n\nvoid IMAPSession::resetAutomaticConfigurationDone()\n{\n    mAutomaticConfigurationDone = false;\n}\n\nString * IMAPSession::gmailUserDisplayName()\n{\n    return mGmailUserDisplayName;\n}\n"], "fixing_code": ["#include \"MCWin32.h\" // Should be included first.\n\n#include \"MCIMAPSession.h\"\n\n#include <libetpan/libetpan.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"MCDefines.h\"\n#include \"MCIMAPSearchExpression.h\"\n#include \"MCIMAPFolder.h\"\n#include \"MCIMAPMessage.h\"\n#include \"MCIMAPPart.h\"\n#include \"MCMessageHeader.h\"\n#include \"MCAbstractPart.h\"\n#include \"MCIMAPProgressCallback.h\"\n#include \"MCIMAPNamespace.h\"\n#include \"MCIMAPSyncResult.h\"\n#include \"MCIMAPFolderStatus.h\"\n#include \"MCConnectionLogger.h\"\n#include \"MCConnectionLoggerUtils.h\"\n#include \"MCHTMLRenderer.h\"\n#include \"MCString.h\"\n#include \"MCUtils.h\"\n#include \"MCHTMLRendererIMAPDataCallback.h\"\n#include \"MCHTMLBodyRendererTemplateCallback.h\"\n#include \"MCCertificateUtils.h\"\n#include \"MCIMAPIdentity.h\"\n#include \"MCLibetpan.h\"\n#include \"MCDataStreamDecoder.h\"\n\nusing namespace mailcore;\n\nclass LoadByChunkProgress : public Object, public IMAPProgressCallback {\npublic:\n    LoadByChunkProgress();\n    virtual ~LoadByChunkProgress();\n\n    virtual void setOffset(uint32_t offset);\n    virtual void setEstimatedSize(uint32_t estimatedSize);\n    virtual void setProgressCallback(IMAPProgressCallback * progressCallback);\n\n    virtual void bodyProgress(IMAPSession * session, unsigned int current, unsigned int maximum);\n\nprivate:\n    uint32_t mOffset;\n    uint32_t mEstimatedSize;\n    IMAPProgressCallback * mProgressCallback; // non retained\n};\n\nLoadByChunkProgress::LoadByChunkProgress()\n{\n    mOffset = 0;\n    mEstimatedSize = 0;\n    mProgressCallback = NULL;\n}\n\nLoadByChunkProgress::~LoadByChunkProgress()\n{\n}\n\nvoid LoadByChunkProgress::setOffset(uint32_t offset)\n{\n    mOffset = offset;\n}\n\nvoid LoadByChunkProgress::setEstimatedSize(uint32_t estimatedSize)\n{\n    mEstimatedSize = estimatedSize;\n}\n\nvoid LoadByChunkProgress::setProgressCallback(IMAPProgressCallback * progressCallback)\n{\n    mProgressCallback = progressCallback;\n}\n\nvoid LoadByChunkProgress::bodyProgress(IMAPSession * session, unsigned int current, unsigned int maximum)\n{\n    // In case of loading attachment by chunks we need report overall progress\n    if (mEstimatedSize > 0 && mEstimatedSize > maximum) {\n        maximum = mEstimatedSize;\n        current += mOffset;\n    }\n    mProgressCallback->bodyProgress(session, current, maximum);\n}\n\nenum {\n    STATE_DISCONNECTED,\n    STATE_CONNECTED,\n    STATE_LOGGEDIN,\n    STATE_SELECTED,\n};\n\nString * mailcore::IMAPNamespacePersonal = NULL;\nString * mailcore::IMAPNamespaceOther = NULL;\nString * mailcore::IMAPNamespaceShared = NULL;\n\nstatic Array * resultsWithError(int r, clist * list, ErrorCode * pError);\n\nINITIALIZE(IMAPSEssion)\n{\n    AutoreleasePool * pool = new AutoreleasePool();\n    IMAPNamespacePersonal = (String *) MCSTR(\"IMAPNamespacePersonal\")->retain();\n    IMAPNamespaceOther = (String *) MCSTR(\"IMAPNamespaceOther\")->retain();\n    IMAPNamespaceShared = (String *) MCSTR(\"IMAPNamespaceShared\")->retain();\n    \n    pool->release();\n}\n\n#define MAX_IDLE_DELAY (9 * 60)\n\n#define LOCK() pthread_mutex_lock(&mIdleLock)\n#define UNLOCK() pthread_mutex_unlock(&mIdleLock)\n\nstatic struct mailimap_flag_list * flags_to_lep(MessageFlag value)\n{\n    struct mailimap_flag_list * flag_list;\n    \n    flag_list = mailimap_flag_list_new_empty();\n    \n    if ((value & MessageFlagSeen) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_seen());\n    }\n    \n    if ((value & MessageFlagFlagged) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flagged());\n    }\n    \n    if ((value & MessageFlagDeleted) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_deleted());\n    }\n    \n    if ((value & MessageFlagAnswered) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_answered());\n    }\n    \n    if ((value & MessageFlagDraft) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_draft());\n    }\n    \n    if ((value & MessageFlagForwarded) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$Forwarded\")));\n    }\n    \n    if ((value & MessageFlagMDNSent) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$MDNSent\")));\n    }\n    \n    if ((value & MessageFlagSubmitPending) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$SubmitPending\")));\n    }\n    \n    if ((value & MessageFlagSubmitted) != 0) {\n        mailimap_flag_list_add(flag_list, mailimap_flag_new_flag_keyword(strdup(\"$Submitted\")));\n    }\n    \n    return flag_list;\n}\n\nstatic MessageFlag flag_from_lep(struct mailimap_flag * flag)\n{\n    switch (flag->fl_type) {\n        case MAILIMAP_FLAG_ANSWERED:\n            return MessageFlagAnswered;\n        case MAILIMAP_FLAG_FLAGGED:\n            return MessageFlagFlagged;\n        case MAILIMAP_FLAG_DELETED:\n            return MessageFlagDeleted;\n        case MAILIMAP_FLAG_SEEN:\n            return MessageFlagSeen;\n        case MAILIMAP_FLAG_DRAFT:\n            return MessageFlagDraft;\n        case MAILIMAP_FLAG_KEYWORD:\n            if (strcasecmp(flag->fl_data.fl_keyword, \"$Forwarded\") == 0) {\n                return MessageFlagForwarded;\n            }\n            else if (strcasecmp(flag->fl_data.fl_keyword, \"$MDNSent\") == 0) {\n                return MessageFlagMDNSent;\n            }\n            else if (strcasecmp(flag->fl_data.fl_keyword, \"$SubmitPending\") == 0) {\n                return MessageFlagSubmitPending;\n            }\n            else if (strcasecmp(flag->fl_data.fl_keyword, \"$Submitted\") == 0) {\n                return MessageFlagSubmitted;\n            }\n    }\n    \n    return MessageFlagNone;\n}\n\nstatic MessageFlag flags_from_lep_att_dynamic(struct mailimap_msg_att_dynamic * att_dynamic)\n{\n    if (att_dynamic->att_list == NULL)\n        return MessageFlagNone;\n    \n    MessageFlag flags;\n    clistiter * iter;\n    \n    flags = MessageFlagNone;\n    for(iter = clist_begin(att_dynamic->att_list) ;iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_flag_fetch * flag_fetch;\n        struct mailimap_flag * flag;\n        \n        flag_fetch = (struct mailimap_flag_fetch *) clist_content(iter);\n        if (flag_fetch->fl_type != MAILIMAP_FLAG_FETCH_OTHER) {\n            continue;\n        }\n        \n        flag = flag_fetch->fl_flag;\n        flags = (MessageFlag) (flags | flag_from_lep(flag));\n    }\n    \n    return flags;\n}\n\nstatic bool isKnownCustomFlag(const char * keyword)\n{\n    return !(strcmp(keyword, \"$MDNSent\") != 0 && strcmp(keyword, \"$Forwarded\") != 0 && strcmp(keyword, \"$SubmitPending\") != 0 && strcmp(keyword, \"$Submitted\") != 0);\n}\n\nstatic Array * custom_flags_from_lep_att_dynamic(struct mailimap_msg_att_dynamic * att_dynamic)\n{\n    if (att_dynamic->att_list == NULL)\n        return NULL;\n    \n    clistiter * iter;\n    bool hasCustomFlags = false;\n    \n    for (iter = clist_begin(att_dynamic->att_list); iter != NULL; iter = clist_next(iter)) {\n        struct mailimap_flag_fetch * flag_fetch;\n        struct mailimap_flag * flag;\n        \n        flag_fetch = (struct mailimap_flag_fetch *) clist_content(iter);\n        if (flag_fetch->fl_type != MAILIMAP_FLAG_FETCH_OTHER) {\n            continue;\n        }\n        \n        flag = flag_fetch->fl_flag;\n        if (flag->fl_type == MAILIMAP_FLAG_KEYWORD) {\n            if (!isKnownCustomFlag(flag->fl_data.fl_keyword)) {\n                hasCustomFlags = true;\n            }\n        }\n    }\n    \n    if (!hasCustomFlags)\n        return NULL;\n    \n    Array * result = Array::array();\n    for (iter = clist_begin(att_dynamic->att_list); iter != NULL; iter = clist_next(iter)) {\n        struct mailimap_flag_fetch * flag_fetch;\n        struct mailimap_flag * flag;\n        \n        flag_fetch = (struct mailimap_flag_fetch *) clist_content(iter);\n        if (flag_fetch->fl_type != MAILIMAP_FLAG_FETCH_OTHER) {\n            continue;\n        }\n        \n        flag = flag_fetch->fl_flag;\n        if (flag->fl_type == MAILIMAP_FLAG_KEYWORD) {\n            if (!isKnownCustomFlag(flag->fl_data.fl_keyword)) {\n                String * customFlag;\n                customFlag = String::stringWithUTF8Characters(flag->fl_data.fl_keyword);\n                result->addObject(customFlag);\n            }\n        }\n    }\n    \n    return result;\n}\n\n#pragma mark set conversion\n\nstatic Array * arrayFromSet(struct mailimap_set * imap_set)\n{\n    Array * result;\n    clistiter * iter;\n    \n    result = Array::array();\n    for(iter = clist_begin(imap_set->set_list) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set_item * item;\n        unsigned long i;\n        \n        item = (struct mailimap_set_item *) clist_content(iter);\n        for(i = item->set_first ; i <= item->set_last ; i ++) {\n            Value * nb;\n            \n            nb = Value::valueWithUnsignedLongValue(i);\n            result->addObject(nb);\n        }\n    }\n    \n    return result;\n}\n\nstatic clist * splitSet(struct mailimap_set * set, unsigned int splitCount)\n{\n    struct mailimap_set * current_set;\n    clist * result;\n    unsigned int count;\n    \n    result = clist_new();\n    \n    current_set = NULL;\n    count = 0;\n    for(clistiter * iter = clist_begin(set->set_list) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set_item * item;\n        \n        if (current_set == NULL) {\n            current_set = mailimap_set_new_empty();\n        }\n        \n        item = (struct mailimap_set_item *) clist_content(iter);\n        mailimap_set_add_interval(current_set, item->set_first, item->set_last);\n        count ++;\n        \n        if (count >= splitCount) {\n            clist_append(result, current_set);\n            current_set = NULL;\n            count = 0;\n        }\n    }\n    if (current_set != NULL) {\n        clist_append(result, current_set);\n    }\n    \n    return result;\n}\n\nstatic struct mailimap_set * setFromIndexSet(IndexSet * indexSet)\n{\n    struct mailimap_set * imap_set;\n    \n    imap_set = mailimap_set_new_empty();\n    for(unsigned int i = 0 ; i < indexSet->rangesCount() ; i ++) {\n        uint64_t left = RangeLeftBound(indexSet->allRanges()[i]);\n        uint64_t right = RangeRightBound(indexSet->allRanges()[i]);\n        if (right == UINT64_MAX) {\n            right = 0;\n        }\n        mailimap_set_add_interval(imap_set, (uint32_t) left, (uint32_t) right);\n    }\n    \n    return imap_set;\n}\n\nstatic IndexSet * indexSetFromSet(struct mailimap_set * imap_set)\n{\n    IndexSet * indexSet = IndexSet::indexSet();\n    for(clistiter * cur = clist_begin(imap_set->set_list) ; cur != NULL ; cur = clist_next(cur)) {\n        struct mailimap_set_item * item = (struct mailimap_set_item *) clist_content(cur);\n        if (item->set_last == 0) {\n            indexSet->addRange(RangeMake(item->set_first, UINT64_MAX));\n        }\n        else {\n            indexSet->addRange(RangeMake(item->set_first, item->set_last - item->set_first));\n        }\n    }\n    return indexSet;\n}\n\nvoid IMAPSession::init()\n{\n    mHostname = NULL;\n    mPort = 0;\n    mUsername = NULL;\n    mPassword = NULL;\n    mOAuth2Token = NULL;\n    mAuthType = AuthTypeSASLNone;\n    mConnectionType = ConnectionTypeClear;\n    mCheckCertificateEnabled = true;\n    mIsCertificateValid = true;\n    mVoIPEnabled = true;\n    mDelimiter = 0;\n    \n    mBodyProgressEnabled = true;\n    mIdleEnabled = false;\n    mXListEnabled = false;\n    mQResyncEnabled = false;\n    mCondstoreEnabled = false;\n    mXYMHighestModseqEnabled = false;\n    mIdentityEnabled = false;\n    mNamespaceEnabled = false;\n    mCompressionEnabled = false;\n    mIsGmail = false;\n    mAllowsNewPermanentFlags = false;\n    mWelcomeString = NULL;\n    mNeedsMboxMailWorkaround = false;\n    mDefaultNamespace = NULL;\n    mFetchedNamespace = NULL;\n    mFetchedIdentity = NULL;\n    mServerIdentity = new IMAPIdentity();\n    mClientIdentity = new IMAPIdentity();\n    mTimeout = 30;\n    mUIDValidity = 0;\n    mUIDNext = 0;\n    mModSequenceValue = 0;\n    mFolderMsgCount = 0;\n    mFirstUnseenUid = 0;\n    mYahooServer = false;\n    mRamblerRuServer = false;\n    mHermesServer = false;\n    mQipServer = false;\n    mLastFetchedSequenceNumber = 0;\n    mCurrentFolder = NULL;\n    mCurrentCapabilities = NULL;\n    pthread_mutex_init(&mIdleLock, NULL);\n    mState = STATE_DISCONNECTED;\n    mImap = NULL;\n    mProgressCallback = NULL;\n    mProgressItemsCount = 0;\n    mConnectionLogger = NULL;\n    pthread_mutex_init(&mConnectionLoggerLock, NULL);\n    mAutomaticConfigurationEnabled = true;\n    mAutomaticConfigurationDone = false;\n    mShouldDisconnect = false;\n    mNeedsReselect = false;\n    mLoginResponse = NULL;\n    mGmailUserDisplayName = NULL;\n    mUnparsedResponseData = NULL;\n}\n\nIMAPSession::IMAPSession()\n{\n    init();\n}\n\nIMAPSession::~IMAPSession()\n{\n    MC_SAFE_RELEASE(mUnparsedResponseData);\n    MC_SAFE_RELEASE(mGmailUserDisplayName);\n    MC_SAFE_RELEASE(mLoginResponse);\n    MC_SAFE_RELEASE(mFetchedIdentity);\n    MC_SAFE_RELEASE(mClientIdentity);\n    MC_SAFE_RELEASE(mServerIdentity);\n    MC_SAFE_RELEASE(mHostname);\n    MC_SAFE_RELEASE(mUsername);\n    MC_SAFE_RELEASE(mPassword);\n    MC_SAFE_RELEASE(mOAuth2Token);\n    MC_SAFE_RELEASE(mWelcomeString);\n    MC_SAFE_RELEASE(mDefaultNamespace);\n    MC_SAFE_RELEASE(mFetchedNamespace);\n    MC_SAFE_RELEASE(mCurrentFolder);\n    MC_SAFE_RELEASE(mCurrentCapabilities);\n    pthread_mutex_destroy(&mIdleLock);\n    pthread_mutex_destroy(&mConnectionLoggerLock);\n}\n\nvoid IMAPSession::setHostname(String * hostname)\n{\n    MC_SAFE_REPLACE_COPY(String, mHostname, hostname);\n}\n\nString * IMAPSession::hostname()\n{\n    return mHostname;\n}\n\nvoid IMAPSession::setPort(unsigned int port)\n{\n    mPort = port;\n}\n\nunsigned int IMAPSession::port()\n{\n    return mPort;\n}\n\nvoid IMAPSession::setUsername(String * username)\n{\n    MC_SAFE_REPLACE_COPY(String, mUsername, username);\n}\n\nString * IMAPSession::username()\n{\n    return mUsername;\n}\n\nvoid IMAPSession::setPassword(String * password)\n{\n    MC_SAFE_REPLACE_COPY(String, mPassword, password);\n}\n\nString * IMAPSession::password()\n{\n    return mPassword;\n}\n\nvoid IMAPSession::setOAuth2Token(String * token)\n{\n    MC_SAFE_REPLACE_COPY(String, mOAuth2Token, token);\n}\n\nString * IMAPSession::OAuth2Token()\n{\n    return mOAuth2Token;\n}\n\nvoid IMAPSession::setAuthType(AuthType authType)\n{\n    mAuthType = authType;\n}\n\nAuthType IMAPSession::authType()\n{\n    return mAuthType;\n}\n\nvoid IMAPSession::setConnectionType(ConnectionType connectionType)\n{\n    mConnectionType = connectionType;\n}\n\nConnectionType IMAPSession::connectionType()\n{\n    return mConnectionType;\n}\n\nvoid IMAPSession::setTimeout(time_t timeout)\n{\n    mTimeout = timeout;\n}\n\ntime_t IMAPSession::timeout()\n{\n    return mTimeout;\n}\n\nvoid IMAPSession::setCheckCertificateEnabled(bool enabled)\n{\n    mCheckCertificateEnabled = enabled;\n}\n\nbool IMAPSession::isCheckCertificateEnabled()\n{\n    return mCheckCertificateEnabled;\n}\n\nbool IMAPSession::isCertificateValid()\n{\n    return mIsCertificateValid;\n}\n\nvoid IMAPSession::setVoIPEnabled(bool enabled)\n{\n    mVoIPEnabled = enabled;\n}\n\nbool IMAPSession::isVoIPEnabled()\n{\n    return mVoIPEnabled;\n}\n\nString * IMAPSession::loginResponse()\n{\n    return mLoginResponse;\n}\n\nData * IMAPSession::unparsedResponseData()\n{\n    return mUnparsedResponseData;\n}\n\nstatic bool hasError(int errorCode)\n{\n    return ((errorCode != MAILIMAP_NO_ERROR) && (errorCode != MAILIMAP_NO_ERROR_AUTHENTICATED) &&\n            (errorCode != MAILIMAP_NO_ERROR_NON_AUTHENTICATED));\n}\n\nbool IMAPSession::checkCertificate()\n{\n    return mailcore::checkCertificate(mImap->imap_stream, hostname());\n}\n\nvoid IMAPSession::body_progress(size_t current, size_t maximum, void * context)\n{\n    IMAPSession * session;\n    \n    session = (IMAPSession *) context;\n    session->bodyProgress((unsigned int) current, (unsigned int) maximum);\n}\n\nvoid IMAPSession::items_progress(size_t current, size_t maximum, void * context)\n{\n    IMAPSession * session;\n    \n    session = (IMAPSession *) context;\n    session->itemsProgress((unsigned int) current, (unsigned int) maximum);\n}\n\nstatic void logger(mailimap * imap, int log_type, const char * buffer, size_t size, void * context)\n{\n    IMAPSession * session = (IMAPSession *) context;\n    session->lockConnectionLogger();\n\n    if (session->connectionLoggerNoLock() == NULL) {\n        session->unlockConnectionLogger();\n        return;\n    }\n    \n    ConnectionLogType type = getConnectionType(log_type);\n    if ((int) type == -1) {\n        session->unlockConnectionLogger();\n        return;\n    }\n    \n    bool isBuffer = isBufferFromLogType(log_type);\n\n    if (isBuffer) {\n        AutoreleasePool * pool = new AutoreleasePool();\n        Data * data = Data::dataWithBytes(buffer, (unsigned int) size);\n        session->connectionLoggerNoLock()->log(session, type, data);\n        pool->release();\n    }\n    else {\n        session->connectionLoggerNoLock()->log(session, type, NULL);\n    }\n    session->unlockConnectionLogger();\n}\n\nvoid IMAPSession::setup()\n{\n    if (mImap != NULL) {\n        unsetup();\n    }\n    \n    mImap = mailimap_new(0, NULL);\n    mailimap_set_timeout(mImap, timeout());\n    mailimap_set_progress_callback(mImap, body_progress, IMAPSession::items_progress, this);\n    mailimap_set_logger(mImap, logger, this);\n}\n\nvoid IMAPSession::unsetup()\n{\n    mailimap * imap;\n    \n    LOCK();\n    imap = mImap;\n    mImap = NULL;\n    mIdleEnabled = false;\n    UNLOCK();\n    \n    if (imap != NULL) {\n        if (imap->imap_stream != NULL) {\n            mailstream_close(imap->imap_stream);\n            imap->imap_stream = NULL;\n        }\n        mailimap_free(imap);\n        imap = NULL;\n    }\n    \n    mState = STATE_DISCONNECTED;\n}\n\nvoid IMAPSession::connect(ErrorCode * pError)\n{\n    int r;\n    \n    setup();\n\n    MCLog(\"connect %s\", MCUTF8DESC(this));\n\n    MCAssert(mState == STATE_DISCONNECTED);\n\n    if (mHostname == NULL) {\n        * pError = ErrorInvalidAccount;\n        goto close;\n    }\n    \n    switch (mConnectionType) {\n        case ConnectionTypeStartTLS:\n        MCLog(\"STARTTLS connect\");\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        if (hasError(r)) {\n            * pError = ErrorConnection;\n            goto close;\n        }\n\n        r = mailimap_socket_starttls(mImap);\n        if (hasError(r)) {\n            MCLog(\"no TLS %i\", r);\n            * pError = ErrorTLSNotAvailable;\n            goto close;\n        }\n            \n        mIsCertificateValid = checkCertificate();\n        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n            * pError = ErrorCertificate;\n            goto close;\n        }\n            \n        break;\n\n        case ConnectionTypeTLS:\n        r = mailimap_ssl_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"ssl connect %s %u %u\", MCUTF8(mHostname), mPort, r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n            \n        mIsCertificateValid = checkCertificate();\n        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n            * pError = ErrorCertificate;\n            goto close;\n        }\n\n        break;\n\n        default:\n        MCLog(\"socket connect %s %u\", MCUTF8(mHostname), mPort);\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"socket connect %i\", r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n        break;\n    }\n    \n    mailstream_low * low;\n    String * identifierString;\n    char * identifier;\n    \n    low = mailstream_get_low(mImap->imap_stream);\n    identifierString = String::stringWithUTF8Format(\"%s@%s:%u\", MCUTF8(mUsername), MCUTF8(mHostname), mPort);\n    identifier = strdup(identifierString->UTF8Characters());\n    mailstream_low_set_identifier(low, identifier);\n    \n    if (mImap->imap_response != NULL) {\n        MC_SAFE_REPLACE_RETAIN(String, mWelcomeString, String::stringWithUTF8Characters(mImap->imap_response));\n        mYahooServer = (mWelcomeString->locationOfString(MCSTR(\"yahoo.com\")) != -1);\n#ifdef LIBETPAN_HAS_MAILIMAP_163_WORKAROUND\n        if (mWelcomeString->locationOfString(MCSTR(\"Coremail System IMap Server Ready\")) != -1)\n            mailimap_set_163_workaround_enabled(mImap, 1);\n#endif\n        if (mWelcomeString->locationOfString(MCSTR(\"Courier-IMAP\")) != -1) {\n            LOCK();\n            mIdleEnabled = true;\n            UNLOCK();\n            mNamespaceEnabled = true;\n        }\n        mRamblerRuServer = (mHostname->locationOfString(MCSTR(\".rambler.ru\")) != -1);\n        mHermesServer = (mWelcomeString->locationOfString(MCSTR(\"Hermes\")) != -1);\n        mQipServer = (mWelcomeString->locationOfString(MCSTR(\"QIP IMAP server\")) != -1);\n    }\n    \n    mState = STATE_CONNECTED;\n    \n    if (isAutomaticConfigurationEnabled()) {\n        if (mCurrentCapabilities != NULL) {\n            applyCapabilities(mCurrentCapabilities);\n        } else {\n            IndexSet *capabilities = capability(pError);\n            if (* pError != ErrorNone) {\n                MCLog(\"capabilities failed\");\n                goto close;\n            } else {\n                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);\n                applyCapabilities(mCurrentCapabilities);\n            }\n        }\n    }\n    \n    * pError = ErrorNone;\n    MCLog(\"connect ok\");\n    return;\n    \nclose:\n    unsetup();\n}\n\nvoid IMAPSession::connectIfNeeded(ErrorCode * pError)\n{\n    if (mShouldDisconnect) {\n        disconnect();\n        mShouldDisconnect = false;\n    }\n    \n    if (mState == STATE_DISCONNECTED) {\n        connect(pError);\n    }\n    else {\n        * pError = ErrorNone;\n    }\n}\n\nvoid IMAPSession::loginIfNeeded(ErrorCode * pError)\n{\n    connectIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    if (mState == STATE_CONNECTED) {\n        login(pError);\n    }\n    else {\n        * pError = ErrorNone;\n    }\n}\n\nvoid IMAPSession::login(ErrorCode * pError)\n{\n    int r;\n    \n    MCLog(\"login\");\n    \n    MCAssert(mState == STATE_CONNECTED);\n\n    MC_SAFE_RELEASE(mLoginResponse);\n    MC_SAFE_RELEASE(mUnparsedResponseData);\n    \n    const char * utf8username;\n    const char * utf8password;\n    utf8username = MCUTF8(mUsername);\n    utf8password = MCUTF8(mPassword);\n    if (utf8username == NULL) {\n        utf8username = \"\";\n    }\n    if (utf8password == NULL) {\n        utf8password = \"\";\n    }\n    \n    switch (mAuthType) {\n        case 0:\n        default:\n            r = mailimap_login(mImap, utf8username, utf8password);\n            break;\n            \n        case AuthTypeSASLCRAMMD5:\n            r = mailimap_authenticate(mImap, \"CRAM-MD5\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLPlain:\n            r = mailimap_authenticate(mImap, \"PLAIN\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLGSSAPI:\n            // needs to be tested\n            r = mailimap_authenticate(mImap, \"GSSAPI\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL /* realm */);\n            break;\n            \n        case AuthTypeSASLDIGESTMD5:\n            r = mailimap_authenticate(mImap, \"DIGEST-MD5\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLLogin:\n            r = mailimap_authenticate(mImap, \"LOGIN\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLSRP:\n            r = mailimap_authenticate(mImap, \"SRP\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL);\n            break;\n            \n        case AuthTypeSASLNTLM:\n            r = mailimap_authenticate(mImap, \"NTLM\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL/* realm */);\n            break;\n            \n        case AuthTypeSASLKerberosV4:\n            r = mailimap_authenticate(mImap, \"KERBEROS_V4\",\n                                      MCUTF8(mHostname),\n                                      NULL,\n                                      NULL,\n                                      utf8username, utf8username,\n                                      utf8password, NULL/* realm */);\n            break;\n            \n        case AuthTypeXOAuth2:\n        case AuthTypeXOAuth2Outlook:\n            if (mOAuth2Token == NULL) {\n                r = MAILIMAP_ERROR_STREAM;\n            }\n            else {\n                r = mailimap_oauth2_authenticate(mImap, utf8username, MCUTF8(mOAuth2Token));\n            }\n            break;\n    }\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n\n        Data * unparsed_response = Data::data();\n        if (mImap->imap_stream_buffer != NULL) {\n            unparsed_response = Data::dataWithBytes(mImap->imap_stream_buffer->str, (unsigned int) mImap->imap_stream_buffer->len);\n        }\n        MC_SAFE_REPLACE_RETAIN(Data, mUnparsedResponseData, unparsed_response);\n\n        return;\n    }\n    else if (hasError(r)) {\n        String * response;\n        \n        response = MCSTR(\"\");\n        if (mImap->imap_response != NULL) {\n            response = String::stringWithUTF8Characters(mImap->imap_response);\n        }\n        MC_SAFE_REPLACE_COPY(String, mLoginResponse, response);\n        if (response->locationOfString(MCSTR(\"not enabled for IMAP use\")) != -1) {\n            * pError = ErrorGmailIMAPNotEnabled;\n        }\n        else if (response->locationOfString(MCSTR(\"IMAP access is disabled\")) != -1) {\n            * pError = ErrorGmailIMAPNotEnabled;\n        }\n        else if (response->locationOfString(MCSTR(\"bandwidth limits\")) != -1) {\n            * pError = ErrorGmailExceededBandwidthLimit;\n        }\n        else if (response->locationOfString(MCSTR(\"Too many simultaneous connections\")) != -1) {\n            * pError = ErrorGmailTooManySimultaneousConnections;\n        }\n        else if (response->locationOfString(MCSTR(\"Maximum number of connections\")) != -1) {\n            * pError = ErrorGmailTooManySimultaneousConnections;\n        }\n        else if (response->locationOfString(MCSTR(\"Application-specific password required\")) != -1) {\n            * pError = ErrorGmailApplicationSpecificPasswordRequired;\n        }\n        else if (response->locationOfString(MCSTR(\"http://me.com/move\")) != -1) {\n            * pError = ErrorMobileMeMoved;\n        }\n        else if (response->locationOfString(MCSTR(\"OCF12\")) != -1) {\n            * pError = ErrorYahooUnavailable;\n        }\n        else if (response->locationOfString(MCSTR(\"Login to your account via a web browser\")) != -1) {\n            * pError = ErrorOutlookLoginViaWebBrowser;\n        }\n        else if (response->locationOfString(MCSTR(\"Service temporarily unavailable\")) != -1) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n        }\n        else {\n            * pError = ErrorAuthentication;\n        }\n        return;\n    }\n    \n    String * loginResponse = MCSTR(\"\");\n    if (mIsGmail) {\n        if (mImap->imap_response != NULL) {\n            loginResponse = String::stringWithUTF8Characters(mImap->imap_response);\n            \n            int location = loginResponse->locationOfString(MCSTR(\" authenticated (Success)\"));\n            if (location != -1) {\n                String * emailAndName = loginResponse->substringToIndex(location);\n                location = emailAndName->locationOfString(MCSTR(\" \"));\n                MC_SAFE_RELEASE(mGmailUserDisplayName);\n                mGmailUserDisplayName = emailAndName->substringFromIndex(location + 1);\n                mGmailUserDisplayName->retain();\n            }\n        }\n    }\n    MC_SAFE_REPLACE_COPY(String, mLoginResponse, loginResponse);\n    \n    mState = STATE_LOGGEDIN;\n    \n    if (isAutomaticConfigurationEnabled()) {\n        if (mCurrentCapabilities != NULL) {\n            applyCapabilities(mCurrentCapabilities);\n        } else {\n            IndexSet *capabilities = capability(pError);\n            if (* pError != ErrorNone) {\n                MCLog(\"capabilities failed\");\n                return;\n            } else {\n                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);\n                applyCapabilities(mCurrentCapabilities);\n            }\n        }\n    }\n    else {\n        // TODO: capabilities should be shared with other sessions for non automatic capabilities sessions.\n    }\n    enableFeatures();\n\n    if (isAutomaticConfigurationEnabled()) {\n        bool hasDefaultNamespace = false;\n        if (isNamespaceEnabled()) {\n            IMAPNamespace * personalNamespace = NULL;\n            \n            if (mFetchedNamespace != NULL) {\n                personalNamespace = mFetchedNamespace;\n            } else {\n                HashMap * result = fetchNamespace(pError);\n                if (* pError != ErrorNone) {\n                    MCLog(\"fetch namespace failed\");\n                    return;\n                }\n                personalNamespace = (IMAPNamespace *) result->objectForKey(IMAPNamespacePersonal);\n            }\n            \n            if (personalNamespace != NULL) {\n                setDefaultNamespace(personalNamespace);\n                mDelimiter = defaultNamespace()->mainDelimiter();\n                if (mFetchedNamespace != personalNamespace) {\n                    MC_SAFE_REPLACE_RETAIN(IMAPNamespace, mFetchedNamespace, personalNamespace);\n                }\n                hasDefaultNamespace = true;\n            }\n        }\n        \n        if (!hasDefaultNamespace) {\n            clist * imap_folders;\n            IMAPFolder * folder;\n            Array * folders;\n            \n            r = mailimap_list(mImap, \"\", \"\", &imap_folders);\n            folders = resultsWithError(r, imap_folders, pError);\n            if (* pError != ErrorNone)\n                return;\n            \n            if (folders->count() > 0) {\n                folder = (IMAPFolder *) folders->objectAtIndex(0);\n            }\n            else {\n                folder = NULL;\n            }\n            if (folder == NULL) {\n                * pError = ErrorNonExistantFolder;\n                return;\n            }\n            \n            mDelimiter = folder->delimiter();\n            IMAPNamespace * defaultNamespace = IMAPNamespace::namespaceWithPrefix(MCSTR(\"\"), folder->delimiter());\n            setDefaultNamespace(defaultNamespace);\n        }\n        \n        if (isIdentityEnabled()) {\n//            IMAPIdentity * serverIdentity = NULL;\n//            if (mFetchedIdentity) {\n//                serverIdentity = mFetchedIdentity;\n//            } else {\n//                serverIdentity = identity(clientIdentity(), pError);\n//            }\n//            if (* pError != ErrorNone) {\n//                // Ignore identity errors\n//                MCLog(\"fetch identity failed\");\n//            }\n//            else {\n//                if (mFetchedIdentity != serverIdentity) {\n//                    MC_SAFE_REPLACE_RETAIN(IMAPIdentity, mFetchedIdentity, serverIdentity);\n//                }\n//                MC_SAFE_REPLACE_RETAIN(IMAPIdentity, mServerIdentity, serverIdentity);\n//            }\n        }\n    }\n    else {\n        // TODO: namespace should be shared with other sessions for non automatic namespace.\n    }\n    \n    mAutomaticConfigurationDone = true;\n    \n    * pError = ErrorNone;\n    MCLog(\"login ok\");\n}\n\nvoid IMAPSession::setNeedsReselect()\n{\n    mNeedsReselect = true;\n}\n\nvoid IMAPSession::setNeedsReconnect()\n{\n    mShouldDisconnect = true;\n}\n\nvoid IMAPSession::selectIfNeeded(String * folder, ErrorCode * pError)\n{\n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    if (folder == NULL) {\n        * pError = ErrorMissingFolder;\n        return;\n    }\n    \n    if (mNeedsReselect) {\n        mNeedsReselect = false;\n        select(folder, pError);\n    }\n    else if (mState == STATE_SELECTED) {\n        MCAssert(mCurrentFolder != NULL);\n        if (mCurrentFolder->caseInsensitiveCompare(folder) != 0) {\n            select(folder, pError);\n        }\n    }\n    else if (mState == STATE_LOGGEDIN) {\n        select(folder, pError);\n    }\n    else {\n        * pError = ErrorNone;\n    }\n}\n\nstatic uint64_t get_mod_sequence_value(mailimap * session)\n{\n    uint64_t mod_sequence_value;\n    clistiter * cur;\n    \n    mod_sequence_value = 0;\n    for(cur = clist_begin(session->imap_response_info->rsp_extension_list) ; cur != NULL ; cur = clist_next(cur)) {\n        struct mailimap_extension_data * ext_data;\n        struct mailimap_condstore_resptextcode * resptextcode;\n        \n        ext_data = (struct mailimap_extension_data *) clist_content(cur);\n        if (ext_data->ext_extension->ext_id != MAILIMAP_EXTENSION_CONDSTORE) {\n            continue;\n        }\n        if (ext_data->ext_type != MAILIMAP_CONDSTORE_TYPE_RESP_TEXT_CODE) {\n            continue;\n        }\n        \n        resptextcode = (struct mailimap_condstore_resptextcode *) ext_data->ext_data;\n        switch (resptextcode->cs_type) {\n            case MAILIMAP_CONDSTORE_RESPTEXTCODE_HIGHESTMODSEQ:\n                mod_sequence_value = resptextcode->cs_data.cs_modseq_value;\n                break;\n            case MAILIMAP_CONDSTORE_RESPTEXTCODE_NOMODSEQ:\n                mod_sequence_value = 0;\n                break;\n        }\n    }\n    \n    return mod_sequence_value;\n}\n\nString * IMAPSession::customCommand(String * command, ErrorCode * pError)\n{\n    int r;\n    \n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    r = mailimap_custom_command(mImap, MCUTF8(command));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCustomCommand;\n        return NULL;\n    }\n    \n    String *response = String::stringWithUTF8Characters(mImap->imap_response);\n    return response;\n}\n\nvoid IMAPSession::select(String * folder, ErrorCode * pError)\n{\n    int r;\n\n    MCLog(\"select\");\n    MCAssert(mState == STATE_LOGGEDIN || mState == STATE_SELECTED);\n\n    r = mailimap_select(mImap, MCUTF8(folder));\n    MCLog(\"select error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        MCLog(\"select error : %s %i\", MCUTF8DESC(this), * pError);\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNonExistantFolder;\n        mState = STATE_LOGGEDIN;\n        MC_SAFE_RELEASE(mCurrentFolder);\n        return;\n    }\n\n    MC_SAFE_REPLACE_COPY(String, mCurrentFolder, folder);\n\n    if (mImap->imap_selection_info != NULL) {\n        mUIDValidity = mImap->imap_selection_info->sel_uidvalidity;\n        mUIDNext = mImap->imap_selection_info->sel_uidnext;        \n        if (mImap->imap_selection_info->sel_has_exists) {\n            mFolderMsgCount = (unsigned int) (mImap->imap_selection_info->sel_exists);\n        } else {\n            mFolderMsgCount = -1;\n        }\n        \n        if (mImap->imap_selection_info->sel_first_unseen) {\n            mFirstUnseenUid = mImap->imap_selection_info->sel_first_unseen;\n        } else {\n            mFirstUnseenUid = 0;\n        }\n        \n        if (mImap->imap_selection_info->sel_unseen) {\n            mUnseenCount = mImap->imap_selection_info->sel_unseen;\n        } else {\n            mUnseenCount = 0;\n        }\n        \n        if (mImap->imap_selection_info->sel_perm_flags) {\n          clistiter * cur;\n\n          struct mailimap_flag_perm * perm_flag;\n          for(cur = clist_end(mImap->imap_selection_info->sel_perm_flags) ; cur != NULL ;\n              cur = clist_previous(cur)) {\n            perm_flag = (struct mailimap_flag_perm *)clist_content(cur);\n            mAllowsNewPermanentFlags = perm_flag->fl_type == MAILIMAP_FLAG_PERM_ALL;\n            if (mAllowsNewPermanentFlags) {\n              break;\n            }\n          }\n        }\n      \n        mModSequenceValue = get_mod_sequence_value(mImap);\n    }\n\n    mState = STATE_SELECTED;\n    * pError = ErrorNone;\n    MCLog(\"select ok\");\n}\n\n\n\n\n\nIMAPFolderStatus * IMAPSession::folderStatus(String * folder, ErrorCode * pError)\n{\n    int r;\n\n    MCLog(\"status\");\n    if (mState != STATE_LOGGEDIN && mState != STATE_SELECTED) {\n        * pError = ErrorFolderState;\n        MCLog(\"trying to fetch status in bad state\");\n        IMAPFolderStatus * empty;\n        empty = new IMAPFolderStatus();\n        empty->autorelease();\n        return empty;\n    }\n\n    if (folder == NULL) {\n        * pError = ErrorMissingFolder;\n        MCLog(\"trying to fetch status without folder\");\n        IMAPFolderStatus * empty;\n        empty = new IMAPFolderStatus();\n        empty->autorelease();\n        return empty;\n    }\n    \n    if (mImap == NULL) {\n        * pError = ErrorDisconnected;\n        MCLog(\"trying to fetch status without connection\");\n        IMAPFolderStatus * empty;\n        empty = new IMAPFolderStatus();\n        empty->autorelease();\n        return empty;\n    }\n\n    struct mailimap_mailbox_data_status * status;\n\n    struct mailimap_status_att_list * status_att_list;\n        \n    status_att_list = mailimap_status_att_list_new_empty();\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UNSEEN);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_MESSAGES);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_RECENT);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UIDNEXT);\n    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UIDVALIDITY);\n    if (mCondstoreEnabled || mXYMHighestModseqEnabled) {\n        mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_HIGHESTMODSEQ);\n    }\n    \n    r = mailimap_status(mImap, MCUTF8(folder), status_att_list, &status);\n    \n    IMAPFolderStatus * fs;\n    fs = new IMAPFolderStatus();\n    fs->autorelease();\n    \n    MCLog(\"status error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        MCLog(\"status error : %s %i\", MCUTF8DESC(this), * pError);\n        mailimap_status_att_list_free(status_att_list);\n        return fs;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        mailimap_status_att_list_free(status_att_list);\n        return fs;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNonExistantFolder;\n        mailimap_status_att_list_free(status_att_list);\n        return fs;\n    }\n    \n    clistiter * cur;\n    \n    \n    if (status != NULL) {\n        \n            struct mailimap_status_info * status_info;\n            for(cur = clist_begin(status->st_info_list) ; cur != NULL ;\n                cur = clist_next(cur)) {                \n                \n                status_info = (struct mailimap_status_info *) clist_content(cur);\n                                \n                switch (status_info->st_att) {\n                    case MAILIMAP_STATUS_ATT_UNSEEN:\n                        fs->setUnseenCount(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_MESSAGES:\n                        fs->setMessageCount(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_RECENT:\n                        fs->setRecentCount(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_UIDNEXT:\n                        fs->setUidNext(status_info->st_value);\n                        break;                        \n                    case MAILIMAP_STATUS_ATT_UIDVALIDITY:\n                        fs->setUidValidity(status_info->st_value);\n                        break;\n                    case MAILIMAP_STATUS_ATT_EXTENSION: {\n                        struct mailimap_extension_data * ext_data = status_info->st_ext_data;\n                        if (ext_data->ext_extension == &mailimap_extension_condstore) {\n                            struct mailimap_condstore_status_info * status_info = (struct mailimap_condstore_status_info *) ext_data->ext_data;\n                            fs->setHighestModSeqValue(status_info->cs_highestmodseq_value);\n                        }\n                        break;\n                    }\n                }\n            }            \n\n        mailimap_mailbox_data_status_free(status);\n    }\n\n    mailimap_status_att_list_free(status_att_list);\n\n    return fs;\n}\n\nvoid IMAPSession::noop(ErrorCode * pError)\n{\n    int r;\n    \n    if (mImap == NULL)\n        return;\n    \n    MCLog(\"connect\");\n    loginIfNeeded(pError);\n    if (* pError != ErrorNone) {\n        return;\n    }\n    if (mImap->imap_stream != NULL) {\n        r = mailimap_noop(mImap);\n        if (r == MAILIMAP_ERROR_STREAM) {\n            * pError = ErrorConnection;\n        }\n        if (r == MAILIMAP_ERROR_NOOP) {\n            * pError = ErrorNoop;\n        }\n    }\n}\n\n#pragma mark mailbox flags conversion\n\nstatic struct {\n    const char * name;\n    int flag;\n} mb_keyword_flag[] = {\n    {\"Inbox\",     IMAPFolderFlagInbox},\n    {\"AllMail\",   IMAPFolderFlagAllMail},\n    {\"Sent\",      IMAPFolderFlagSentMail},\n    {\"Spam\",      IMAPFolderFlagSpam},\n    {\"Starred\",   IMAPFolderFlagStarred},\n    {\"Trash\",     IMAPFolderFlagTrash},\n    {\"Important\", IMAPFolderFlagImportant},\n    {\"Drafts\",    IMAPFolderFlagDrafts},\n    {\"Archive\",   IMAPFolderFlagArchive},\n    {\"All\",       IMAPFolderFlagAll},\n    {\"Junk\",      IMAPFolderFlagJunk},\n    {\"Flagged\",   IMAPFolderFlagFlagged},\n};\n\nstatic int imap_mailbox_flags_to_flags(struct mailimap_mbx_list_flags * imap_flags)\n{\n    int flags;\n    clistiter * cur;\n    \n    flags = 0;\n    if (imap_flags->mbf_type == MAILIMAP_MBX_LIST_FLAGS_SFLAG) {\n        switch (imap_flags->mbf_sflag) {\n            case MAILIMAP_MBX_LIST_SFLAG_MARKED:\n                flags |= IMAPFolderFlagMarked;\n                break;\n            case MAILIMAP_MBX_LIST_SFLAG_NOSELECT:\n                flags |= IMAPFolderFlagNoSelect;\n                break;\n            case MAILIMAP_MBX_LIST_SFLAG_UNMARKED:\n                flags |= IMAPFolderFlagUnmarked;\n                break;\n        }\n    }\n    \n    for(cur = clist_begin(imap_flags->mbf_oflags) ; cur != NULL ;\n        cur = clist_next(cur)) {\n        struct mailimap_mbx_list_oflag * oflag;\n        \n        oflag = (struct mailimap_mbx_list_oflag *) clist_content(cur);\n        \n        switch (oflag->of_type) {\n            case MAILIMAP_MBX_LIST_OFLAG_NOINFERIORS:\n                flags |= IMAPFolderFlagNoInferiors;\n                break;\n                \n            case MAILIMAP_MBX_LIST_OFLAG_FLAG_EXT:\n                for(unsigned int i = 0 ; i < sizeof(mb_keyword_flag) / sizeof(mb_keyword_flag[0]) ; i ++) {\n                    if (strcasecmp(mb_keyword_flag[i].name, oflag->of_flag_ext) == 0) {\n                        flags |= mb_keyword_flag[i].flag;\n                    }\n                }\n                break;\n        }\n    }\n    \n    return flags;\n}\n\nstatic Array * resultsWithError(int r, clist * list, ErrorCode * pError)\n{\n    clistiter * cur;\n    Array * result;\n    \n    result = Array::array();\n    if (r == MAILIMAP_ERROR_STREAM) {\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNonExistantFolder;\n        return NULL;\n    }\n    \n    for(cur = clist_begin(list) ; cur != NULL ; cur = cur->next) {\n        struct mailimap_mailbox_list * mb_list;\n        IMAPFolderFlag flags;\n        IMAPFolder * folder;\n        String * path;\n        \n        mb_list = (struct mailimap_mailbox_list *) cur->data;\n        \n        flags = IMAPFolderFlagNone;\n        if (mb_list->mb_flag != NULL)\n            flags = (IMAPFolderFlag) imap_mailbox_flags_to_flags(mb_list->mb_flag);\n        \n        folder = new IMAPFolder();\n        path = String::stringWithUTF8Characters(mb_list->mb_name);\n        if (path->uppercaseString()->isEqual(MCSTR(\"INBOX\"))) {\n            folder->setPath(MCSTR(\"INBOX\"));\n        }\n        else {\n            folder->setPath(path);\n        }\n        folder->setDelimiter(mb_list->mb_delimiter);\n        folder->setFlags(flags);\n        \n        result->addObject(folder);\n        \n        folder->release();\n    }\n    \n    mailimap_list_result_free(list);\n    \n    * pError = ErrorNone;\n    return result;\n}\n\n// Deprecated\nchar IMAPSession::fetchDelimiterIfNeeded(char defaultDelimiter, ErrorCode * pError)\n{\n    int r;\n    clist * imap_folders;\n    IMAPFolder * folder;\n    Array * folders;\n    \n    if (defaultDelimiter != 0)\n        return defaultDelimiter;\n    \n    r = mailimap_list(mImap, \"\", \"\", &imap_folders);\n    folders = resultsWithError(r, imap_folders, pError);\n    if (* pError == ErrorConnection || * pError == ErrorParse)\n        mShouldDisconnect = true;\n    if (* pError != ErrorNone)\n        return 0;\n    \n    if (folders->count() > 0) {\n        folder = (IMAPFolder *) folders->objectAtIndex(0);\n    }\n    else {\n        folder = NULL;\n    }\n    if (folder == NULL)\n        return 0;\n    \n    * pError = ErrorNone;\n    return folder->delimiter();\n}\n\nArray * /* IMAPFolder */ IMAPSession::fetchSubscribedFolders(ErrorCode * pError)\n{\n    int r;\n    clist * imap_folders;\n    \n    MCLog(\"fetch subscribed\");\n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    if (mDelimiter == 0) {\n        char delimiter;\n        \n        delimiter = fetchDelimiterIfNeeded(mDelimiter, pError);\n        if (* pError != ErrorNone)\n            return NULL;\n        \n        //setDelimiter(delimiter);\n        mDelimiter = delimiter;\n    }\n    \n    String * prefix;\n    prefix = defaultNamespace()->mainPrefix();\n    if (prefix == NULL) {\n        prefix = MCSTR(\"\");\n    }\n    if (prefix->length() > 0) {\n        if (!prefix->hasSuffix(String::stringWithUTF8Format(\"%c\", mDelimiter))) {\n            prefix = prefix->stringByAppendingUTF8Format(\"%c\", mDelimiter);\n        }\n    }\n    \n    r = mailimap_lsub(mImap, MCUTF8(prefix), \"*\", &imap_folders);\n    MCLog(\"fetch subscribed %u\", r);\n    Array * result = resultsWithError(r, imap_folders, pError);\n    if (* pError == ErrorConnection || * pError == ErrorParse)\n        mShouldDisconnect = true;\n    return result;\n}\n\nArray * /* IMAPFolder */ IMAPSession::fetchAllFolders(ErrorCode * pError)\n{\n    int r;\n    clist * imap_folders;\n    \n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    if (mDelimiter == 0) {\n        char delimiter;\n        \n        delimiter = fetchDelimiterIfNeeded(mDelimiter, pError);\n        if (* pError != ErrorNone)\n            return NULL;\n        \n        //setDelimiter(delimiter);\n        mDelimiter = delimiter;\n    }\n    \n    String * prefix = NULL;\n    if (defaultNamespace()) {\n        prefix = defaultNamespace()->mainPrefix();\n    }\n    if (prefix == NULL) {\n        prefix = MCSTR(\"\");\n    }\n    if (prefix->length() > 0) {\n        if (!prefix->hasSuffix(String::stringWithUTF8Format(\"%c\", mDelimiter))) {\n            prefix = prefix->stringByAppendingUTF8Format(\"%c\", mDelimiter);\n        }\n    }\n    \n    if (mXListEnabled) {\n        r = mailimap_xlist(mImap, MCUTF8(prefix), \"*\", &imap_folders);\n    }\n    else {\n        r = mailimap_list(mImap, MCUTF8(prefix), \"*\", &imap_folders);\n    }\n    Array * result = resultsWithError(r, imap_folders, pError);\n    if (* pError == ErrorConnection || * pError == ErrorParse)\n        mShouldDisconnect = true;\n    \n    if (result != NULL) {\n        bool hasInbox = false;\n        mc_foreacharray(IMAPFolder, folder, result) {\n            if (folder->path()->isEqual(MCSTR(\"INBOX\"))) {\n                hasInbox = true;\n            }\n        }\n\n        if (!hasInbox) {\n            mc_foreacharray(IMAPFolder, folder, result) {\n                if (folder->flags() & IMAPFolderFlagInbox) {\n                    // some mail providers use non-standart name for inbox folder\n                    hasInbox = true;\n                    folder->setPath(MCSTR(\"INBOX\"));\n                    break;\n                }\n            }\n\n            if (!hasInbox) {\n                r = mailimap_list(mImap, \"\", \"INBOX\", &imap_folders);\n                Array * inboxResult = resultsWithError(r, imap_folders, pError);\n                if (* pError == ErrorConnection || * pError == ErrorParse)\n                    mShouldDisconnect = true;\n                result->addObjectsFromArray(inboxResult);\n                hasInbox = true;\n            }\n        }\n    }\n    \n    return result;\n}\n\nvoid IMAPSession::renameFolder(String * folder, String * otherName, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_rename(mImap, MCUTF8(folder), MCUTF8(otherName));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorRename;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::deleteFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_delete(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorDelete;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::createFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_create(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCreate;\n        return;\n    }\n    \n    * pError = ErrorNone;\n    subscribeFolder(folder, pError);\n}\n\nvoid IMAPSession::subscribeFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_subscribe(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorSubscribe;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::unsubscribeFolder(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(MCSTR(\"INBOX\"), pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_unsubscribe(mImap, MCUTF8(folder));\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorSubscribe;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::appendMessage(String * folder, Data * messageData, MessageFlag flags,\n    IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    this->appendMessageWithCustomFlags(folder, messageData, flags, NULL, progressCallback, createdUID, pError);\n}\n\nvoid IMAPSession::appendMessageWithCustomFlags(String * folder, Data * messageData, MessageFlag flags, Array * customFlags,\n    IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    this->appendMessageWithCustomFlagsAndDate(folder, messageData, flags, NULL, (time_t) -1, progressCallback, createdUID, pError);\n}\n\nvoid IMAPSession::appendMessageWithCustomFlagsAndDate(String * folder, Data * messageData, MessageFlag flags, Array * customFlags, time_t date,\n                                                      IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    int r;\n    struct mailimap_flag_list * flag_list;\n    uint32_t uidvalidity;\n    uint32_t uidresult;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    mProgressCallback = progressCallback;\n    bodyProgress(0, messageData->length());\n    \n    flag_list = flags_to_lep(flags);\n    if (customFlags != NULL) {\n        for (unsigned int i = 0 ; i < customFlags->count() ; i ++) {\n            struct mailimap_flag * f;\n            String * customFlag = (String *) customFlags->objectAtIndex(i);\n            \n            f = mailimap_flag_new_flag_keyword(strdup(customFlag->UTF8Characters()));\n            mailimap_flag_list_add(flag_list, f);\n        }\n    }\n    struct mailimap_date_time * imap_date = NULL;\n    if (date != (time_t) -1) {\n        imap_date = imapDateFromTimestamp(date);\n    }\n    r = mailimap_uidplus_append(mImap, MCUTF8(folder), flag_list, imap_date, messageData->bytes(), messageData->length(),\n        &uidvalidity, &uidresult);\n    if (imap_date != NULL) {\n        mailimap_date_time_free(imap_date);\n    }\n    mailimap_flag_list_free(flag_list);\n    \n    bodyProgress(messageData->length(), messageData->length());\n    mProgressCallback = NULL;\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorAppend;\n        return;\n    }\n    \n    * createdUID = uidresult;\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::appendMessageWithCustomFlagsAndDate(String * folder, String * messagePath, MessageFlag flags, Array * customFlags, time_t date,\n                                                      IMAPProgressCallback * progressCallback, uint32_t * createdUID, ErrorCode * pError)\n{\n    Data * messageData = Data::dataWithContentsOfFile(messagePath);\n    if (!messageData) {\n        * pError = ErrorFile;\n        return;\n    }\n\n    return appendMessageWithCustomFlagsAndDate(folder, messageData, flags, customFlags, date, progressCallback, createdUID, pError);\n}\n\nvoid IMAPSession::copyMessages(String * folder, IndexSet * uidSet, String * destFolder,\n     HashMap ** pUidMapping, ErrorCode * pError)\n{\n    int r;\n    struct mailimap_set * set;\n    struct mailimap_set * src_uid;\n    struct mailimap_set * dest_uid;\n    uint32_t uidvalidity;\n    clist * setList;\n    IndexSet * uidSetResult;\n    HashMap * uidMapping = NULL;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    set = setFromIndexSet(uidSet);\n    if (clist_count(set->set_list) == 0) {\n        mailimap_set_free(set);\n        return;\n    }\n\n    setList = splitSet(set, 10);\n    uidSetResult = NULL;\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        r = mailimap_uidplus_uid_copy(mImap, current_set, MCUTF8(destFolder),\n            &uidvalidity, &src_uid, &dest_uid);\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorCopy;\n            goto release;\n        }\n\n        if ((src_uid != NULL) && (dest_uid != NULL)) {\n            if (uidMapping == NULL) {\n                uidMapping = HashMap::hashMap();\n            }\n            \n            Array * srcUidsArray = arrayFromSet(src_uid);\n            Array * destUidsArray = arrayFromSet(dest_uid);\n\n            for(int i = 0 ; i < srcUidsArray->count() && i < destUidsArray->count() ; i ++) {\n                uidMapping->setObjectForKey(srcUidsArray->objectAtIndex(i), destUidsArray->objectAtIndex(i));\n            }\n        }\n\n        if (src_uid != NULL) {\n            mailimap_set_free(src_uid);\n        }\n\n        if (dest_uid != NULL) {\n            mailimap_set_free(dest_uid);\n        }\n    }\n    if (pUidMapping != NULL) {\n        * pUidMapping = uidMapping;\n    }\n    * pError = ErrorNone;\n\n    release:\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_set_free(set);\n}\n\nvoid IMAPSession::moveMessages(String * folder, IndexSet * uidSet, String * destFolder,\n     HashMap ** pUidMapping, ErrorCode * pError)\n{\n    int r;\n    struct mailimap_set * set;\n    struct mailimap_set * src_uid;\n    struct mailimap_set * dest_uid;\n    uint32_t uidvalidity;\n    clist * setList;\n    IndexSet * uidSetResult;\n    HashMap * uidMapping = NULL;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    set = setFromIndexSet(uidSet);\n    if (clist_count(set->set_list) == 0) {\n        mailimap_set_free(set);\n        return;\n    }\n\n    setList = splitSet(set, 10);\n    uidSetResult = NULL;\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        r = mailimap_uidplus_uid_move(mImap, current_set, MCUTF8(destFolder),\n            &uidvalidity, &src_uid, &dest_uid);\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorCopy;\n            goto release;\n        }\n\n        if ((src_uid != NULL) && (dest_uid != NULL)) {\n            if (uidMapping == NULL) {\n                uidMapping = HashMap::hashMap();\n            }\n            \n            Array * srcUidsArray = arrayFromSet(src_uid);\n            Array * destUidsArray = arrayFromSet(dest_uid);\n\n            for(int i = 0 ; i < srcUidsArray->count() && i < destUidsArray->count() ; i ++) {\n                uidMapping->setObjectForKey(srcUidsArray->objectAtIndex(i), destUidsArray->objectAtIndex(i));\n            }\n        }\n\n        if (src_uid != NULL) {\n            mailimap_set_free(src_uid);\n        }\n\n        if (dest_uid != NULL) {\n            mailimap_set_free(dest_uid);\n        }\n    }\n    if (pUidMapping != NULL) {\n        * pUidMapping = uidMapping;\n    }\n    * pError = ErrorNone;\n\n    release:\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_set_free(set);\n}\n\nvoid IMAPSession::expunge(String * folder, ErrorCode * pError)\n{\n    int r;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    r = mailimap_expunge(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorExpunge;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nstatic int\nfetch_imap(mailimap * imap, bool identifier_is_uid, uint32_t identifier,\n           struct mailimap_fetch_type * fetch_type,\n           char ** result, size_t * result_len)\n{\n    int r;\n    struct mailimap_msg_att * msg_att;\n    struct mailimap_msg_att_item * msg_att_item;\n    clist * fetch_result;\n    struct mailimap_set * set;\n    char * text;\n    size_t text_length;\n    clistiter * cur;\n    \n    set = mailimap_set_new_single(identifier);\n    if (identifier_is_uid) {\n        r = mailimap_uid_fetch(imap, set, fetch_type, &fetch_result);\n    }\n    else {\n        r = mailimap_fetch(imap, set, fetch_type, &fetch_result);\n    }\n    \n    mailimap_set_free(set);\n    \n    switch (r) {\n        case MAILIMAP_NO_ERROR:\n            break;\n        default:\n            return r;\n    }\n    \n    if (clist_isempty(fetch_result)) {\n        mailimap_fetch_list_free(fetch_result);\n        return MAILIMAP_ERROR_FETCH;\n    }\n    \n    msg_att = (struct mailimap_msg_att *) clist_begin(fetch_result)->data;\n    \n    text = NULL;\n    text_length = 0;\n    \n    for(cur = clist_begin(msg_att->att_list) ; cur != NULL ;\n        cur = clist_next(cur)) {\n        msg_att_item = (struct mailimap_msg_att_item *) clist_content(cur);\n        \n        if (msg_att_item->att_type != MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            continue;\n        }\n        \n        if (msg_att_item->att_data.att_static->att_type !=\n            MAILIMAP_MSG_ATT_BODY_SECTION) {\n            continue;\n        }\n        \n        text = msg_att_item->att_data.att_static->att_data.att_body_section->sec_body_part;\n        msg_att_item->att_data.att_static->att_data.att_body_section->sec_body_part = NULL;\n        text_length = msg_att_item->att_data.att_static->att_data.att_body_section->sec_length;\n    }\n    \n    mailimap_fetch_list_free(fetch_result);\n    \n    if (text == NULL)\n        return MAILIMAP_ERROR_FETCH;\n    \n    * result = text;\n    * result_len = text_length;\n    \n    return MAILIMAP_NO_ERROR;\n}\n\nHashMap * IMAPSession::fetchMessageNumberUIDMapping(String * folder, uint32_t fromUID, uint32_t toUID,\n    ErrorCode * pError)\n{\n    struct mailimap_set * imap_set;\n    struct mailimap_fetch_type * fetch_type;\n    clist * fetch_result;\n    HashMap * result;\n    struct mailimap_fetch_att * fetch_att;\n    int r;\n    clistiter * iter;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    result = HashMap::hashMap();\n    \n    imap_set = mailimap_set_new_interval(fromUID, toUID);\n    fetch_type = mailimap_fetch_type_new_fetch_att_list_empty();\n    fetch_att = mailimap_fetch_att_new_uid();\n    mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    \n    r = mailimap_uid_fetch(mImap, imap_set, fetch_type, &fetch_result);\n    mailimap_fetch_type_free(fetch_type);\n    mailimap_set_free(imap_set);\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        MCLog(\"error stream\");\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        MCLog(\"error parse\");\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        MCLog(\"error fetch\");\n        * pError = ErrorFetch;\n        return NULL;\n    }\n    \n    for(iter = clist_begin(fetch_result) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_msg_att * msg_att;\n        clistiter * item_iter;\n        uint32_t uid;\n        \n        msg_att = (struct mailimap_msg_att *) clist_content(iter);\n        uid = 0;\n        for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {\n            struct mailimap_msg_att_item * att_item;\n            \n            att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);\n            if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {\n                struct mailimap_msg_att_static * att_static;\n                \n                att_static = att_item->att_data.att_static;\n                if (att_static->att_type == MAILIMAP_MSG_ATT_UID) {\n                    uid = att_static->att_data.att_uid;\n                }\n            }\n        }\n        \n        if (uid < fromUID) {\n            uid = 0;\n        }\n        \n        if (uid != 0) {\n            result->setObjectForKey(Value::valueWithUnsignedLongValue(msg_att->att_number),\n                Value::valueWithUnsignedLongValue(uid));\n        }\n    }\n    \n    mailimap_fetch_list_free(fetch_result);\n    * pError = ErrorNone;\n    \n    return result;\n}\n\nstruct msg_att_handler_data {\n    IndexSet * uidsFilter;\n    IndexSet * numbersFilter;\n    bool fetchByUID;\n    Array * result;\n    IMAPMessagesRequestKind requestKind;\n    uint32_t mLastFetchedSequenceNumber;\n    HashMap * mapping;\n    bool needsHeader;\n    bool needsBody;\n    bool needsFlags;\n    bool needsGmailLabels;\n    bool needsGmailMessageID;\n    bool needsGmailThreadID;\n};\n\nstatic void msg_att_handler(struct mailimap_msg_att * msg_att, void * context)\n{\n    clistiter * item_iter;\n    uint32_t uid;\n    IMAPMessage * msg;\n    bool hasHeader;\n    bool hasBody;\n    bool hasFlags;\n    bool hasGmailLabels;\n    bool hasGmailMessageID;\n    bool hasGmailThreadID;\n    struct msg_att_handler_data * msg_att_context;\n    bool fetchByUID;\n    Array * result;\n    IMAPMessagesRequestKind requestKind;\n    uint32_t mLastFetchedSequenceNumber;\n    HashMap * mapping;\n    bool needsHeader;\n    bool needsBody;\n    bool needsFlags;\n    bool needsGmailLabels;\n    bool needsGmailMessageID;\n    bool needsGmailThreadID;\n    IndexSet * uidsFilter;\n    IndexSet * numbersFilter;\n    \n    msg_att_context = (struct msg_att_handler_data *) context;\n    uidsFilter = msg_att_context->uidsFilter;\n    numbersFilter = msg_att_context->numbersFilter;\n    fetchByUID = msg_att_context->fetchByUID;\n    result = msg_att_context->result;\n    requestKind = msg_att_context->requestKind;\n    mapping = msg_att_context->mapping;\n    needsHeader = msg_att_context->needsHeader;\n    needsBody = msg_att_context->needsBody;\n    needsFlags = msg_att_context->needsFlags;\n    needsGmailLabels = msg_att_context->needsGmailLabels;\n    needsGmailMessageID = msg_att_context->needsGmailMessageID;\n    needsGmailThreadID = msg_att_context->needsGmailThreadID;\n\n    hasHeader = false;\n    hasBody = false;\n    hasFlags = false;\n    hasGmailLabels = false;\n    hasGmailMessageID = false;\n    hasGmailThreadID = false;\n    \n    if (numbersFilter != NULL) {\n        if (!numbersFilter->containsIndex((uint64_t) msg_att->att_number)) {\n            return;\n        }\n    }\n\n    msg = new IMAPMessage();\n    \n    uid = 0;\n    mLastFetchedSequenceNumber = msg_att->att_number;\n    if (mapping != NULL) {\n        uid = (uint32_t) ((Value *) mapping->objectForKey(Value::valueWithUnsignedLongValue(msg_att->att_number)))->longLongValue();\n    }\n\n    msg->setSequenceNumber(msg_att->att_number);\n    for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {\n        struct mailimap_msg_att_item * att_item;\n        \n        att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);\n        if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_DYNAMIC) {\n            MessageFlag flags;\n            \n            flags = flags_from_lep_att_dynamic(att_item->att_data.att_dyn);\n            msg->setFlags(flags);\n            msg->setOriginalFlags(flags);\n            hasFlags = true;\n            \n            Array * customFlags;\n            customFlags = custom_flags_from_lep_att_dynamic(att_item->att_data.att_dyn);\n            msg->setCustomFlags(customFlags);\n        }\n        else if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            struct mailimap_msg_att_static * att_static;\n            \n            att_static = att_item->att_data.att_static;\n            if (att_static->att_type == MAILIMAP_MSG_ATT_UID) {\n                uid = att_static->att_data.att_uid;\n            }\n            else if (att_static->att_type == MAILIMAP_MSG_ATT_ENVELOPE) {\n                struct mailimap_envelope * env;\n                \n                MCLog(\"parse envelope %lu\", (unsigned long) uid);\n                env = att_static->att_data.att_env;\n                if ((requestKind & IMAPMessagesRequestKindMessageId) != 0) {\n                    msg->header()->importPartialIMAPEnvelope(env);\n                } else {\n                    msg->header()->importIMAPEnvelope(env);\n                }\n                hasHeader = true;\n            }\n            else if (att_static->att_type == MAILIMAP_MSG_ATT_BODY_SECTION) {\n                if ((requestKind & IMAPMessagesRequestKindFullHeaders) != 0 ||\n                    (requestKind & IMAPMessagesRequestKindExtraHeaders) != 0) {\n                    char * bytes;\n                    size_t length;\n                    \n                    bytes = att_static->att_data.att_body_section->sec_body_part;\n                    length = att_static->att_data.att_body_section->sec_length;\n                    \n                    msg->header()->importHeadersData(Data::dataWithBytes(bytes, (unsigned int) length));\n                    hasHeader = true;\n                }\n                else {\n                    char * references;\n                    size_t ref_size;\n                    \n                    // references\n                    references = att_static->att_data.att_body_section->sec_body_part;\n                    ref_size = att_static->att_data.att_body_section->sec_length;\n                    \n                    msg->header()->importIMAPReferences(Data::dataWithBytes(references, (unsigned int) ref_size));\n                }\n            }\n            else if (att_static->att_type == MAILIMAP_MSG_ATT_BODYSTRUCTURE) {\n                AbstractPart * mainPart;\n                \n                // bodystructure\n                mainPart = IMAPPart::attachmentWithIMAPBody(att_static->att_data.att_body);\n                msg->setMainPart(mainPart);\n                hasBody = true;\n            }\n        }\n        else if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_EXTENSION) {\n            struct mailimap_extension_data * ext_data;\n            \n            ext_data = att_item->att_data.att_extension_data;\n            if (ext_data->ext_extension == &mailimap_extension_condstore) {\n                struct mailimap_condstore_fetch_mod_resp * fetch_data;\n                \n                fetch_data = (struct mailimap_condstore_fetch_mod_resp *) ext_data->ext_data;\n                msg->setModSeqValue(fetch_data->cs_modseq_value);\n            }\n            else if (ext_data->ext_extension == &mailimap_extension_xgmlabels) {\n                struct mailimap_msg_att_xgmlabels * cLabels;\n                Array * labels;\n                clistiter * cur;\n                \n                labels = new Array();\n                hasGmailLabels = true;\n                cLabels = (struct mailimap_msg_att_xgmlabels *) ext_data->ext_data;\n                for(cur = clist_begin(cLabels->att_labels) ; cur != NULL ; cur = clist_next(cur)) {\n                    char * cLabel;\n                    String * label;\n                    \n                    cLabel = (char *) clist_content(cur);\n                    label = String::stringWithUTF8Characters(cLabel);\n                    labels->addObject(label);\n                }\n                if (labels->count() > 0) {\n                    msg->setGmailLabels(labels);\n                }\n                labels->release();\n            }\n            else if (ext_data->ext_extension == &mailimap_extension_xgmthrid) {\n                uint64_t * threadID;\n                \n                threadID = (uint64_t *) ext_data->ext_data;\n                msg->setGmailThreadID(*threadID);\n                hasGmailThreadID = true;\n            }\n            else if (ext_data->ext_extension == &mailimap_extension_xgmmsgid) {\n                uint64_t * msgID;\n                \n                msgID = (uint64_t *) ext_data->ext_data;\n                msg->setGmailMessageID(*msgID);\n                hasGmailMessageID = true;\n            }\n        }\n    }\n    for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {\n        struct mailimap_msg_att_item * att_item;\n        \n        att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);\n        if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            struct mailimap_msg_att_static * att_static;\n            \n            att_static = att_item->att_data.att_static;\n            if (att_static->att_type == MAILIMAP_MSG_ATT_INTERNALDATE) {\n                msg->header()->importIMAPInternalDate(att_static->att_data.att_internal_date);\n            } else if (att_static->att_type == MAILIMAP_MSG_ATT_RFC822_SIZE) {\n                msg->setSize(att_static->att_data.att_rfc822_size);\n            }\n        }\n    }\n    \n    if (needsBody && !hasBody) {\n        msg->release();\n        return;\n    }\n    if (needsHeader && !hasHeader) {\n        msg->release();\n        return;\n    }\n    if (needsFlags && !hasFlags) {\n        msg->release();\n        return;\n    }\n    if (needsGmailThreadID && !hasGmailThreadID) {\n        msg->release();\n        return;\n    }\n    if (needsGmailMessageID && !hasGmailMessageID) {\n        msg->release();\n        return;\n    }\n    if (needsGmailLabels && !hasGmailLabels) {\n        msg->release();\n        return;\n    }\n    if (uid != 0) {\n        msg->setUid(uid);\n    }\n    else {\n        msg->release();\n        return;\n    }\n\n    if (uidsFilter != NULL) {\n        if (!uidsFilter->containsIndex((uint64_t) uid)) {\n            msg->release();\n            return;\n        }\n    }\n    \n    result->addObject(msg);\n    msg->release();\n    \n    msg_att_context->mLastFetchedSequenceNumber = mLastFetchedSequenceNumber;\n}\n\nIMAPSyncResult * IMAPSession::fetchMessages(String * folder, IMAPMessagesRequestKind requestKind, bool fetchByUID,\n                                            struct mailimap_set * imapset, IndexSet * uidsFilter, IndexSet * numbersFilter,\n                                            uint64_t modseq, HashMap * mapping,\n                                            IMAPProgressCallback * progressCallback, Array * extraHeaders, ErrorCode * pError)\n{\n    struct mailimap_fetch_type * fetch_type;\n    clist * fetch_result;\n    struct mailimap_qresync_vanished * vanished;\n    struct mailimap_fetch_att * fetch_att;\n    int r;\n    bool needsHeader;\n    bool needsBody;\n    bool needsFlags;\n    bool needsGmailLabels;\n    bool needsGmailMessageID;\n    bool needsGmailThreadID;\n    Array * messages;\n    IndexSet * vanishedMessages;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    if (mNeedsMboxMailWorkaround && ((requestKind & IMAPMessagesRequestKindHeaders) != 0)) {\n        requestKind = (IMAPMessagesRequestKind) (requestKind & ~IMAPMessagesRequestKindHeaders);\n        requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindFullHeaders);\n    }\n    if (extraHeaders != NULL) {\n        requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindExtraHeaders);\n    }\n    \n    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {\n        mProgressItemsCount = 0;\n        mProgressCallback = progressCallback;\n    }\n    \n    messages = Array::array();\n    \n    needsHeader = false;\n    needsBody = false;\n    needsFlags = false;\n    needsGmailLabels = false;\n    needsGmailMessageID = false;\n    needsGmailThreadID = false;\n    clist * hdrlist = clist_new();\n    \n    fetch_type = mailimap_fetch_type_new_fetch_att_list_empty();\n    fetch_att = mailimap_fetch_att_new_uid();\n    mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    if ((requestKind & IMAPMessagesRequestKindFlags) != 0) {\n        MCLog(\"request flags\");\n        fetch_att = mailimap_fetch_att_new_flags();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsFlags = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindGmailLabels) != 0) {\n        MCLog(\"request flags\");\n        fetch_att = mailimap_fetch_att_new_xgmlabels();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsGmailLabels = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindGmailThreadID) != 0) {\n        fetch_att = mailimap_fetch_att_new_xgmthrid();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsGmailThreadID = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindGmailMessageID) != 0) {\n        fetch_att = mailimap_fetch_att_new_xgmmsgid();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsGmailMessageID = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindFullHeaders) != 0) {\n        char * header;\n        \n        MCLog(\"request envelope\");\n        \n        // most important header\n        header = strdup(\"Date\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Subject\");\n        clist_append(hdrlist, header);\n        header = strdup(\"From\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Sender\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Reply-To\");\n        clist_append(hdrlist, header);\n        header = strdup(\"To\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Cc\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Message-ID\");\n        clist_append(hdrlist, header);\n        header = strdup(\"References\");\n        clist_append(hdrlist, header);\n        header = strdup(\"In-Reply-To\");\n        clist_append(hdrlist, header);\n    }\n    if ((requestKind & IMAPMessagesRequestKindMessageId) != 0) {\n        char * header;\n        // envelope\n        fetch_att = mailimap_fetch_att_new_envelope();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        MCLog(\"request envelope\");\n        header = strdup(\"Message-ID\");\n        clist_append(hdrlist, header);\n        header = strdup(\"Subject\");\n        clist_append(hdrlist, header);\n    }\n    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {\n        char * header;\n        \n        MCLog(\"request envelope\");\n        // envelope\n        fetch_att = mailimap_fetch_att_new_envelope();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        \n        // references header\n        header = strdup(\"References\");\n        clist_append(hdrlist, header);\n        if ((requestKind & IMAPMessagesRequestKindHeaderSubject) != 0) {\n            header = strdup(\"Subject\");\n            clist_append(hdrlist, header);\n        }\n    }\n    if ((requestKind & IMAPMessagesRequestKindSize) != 0) {\n        // message structure\n        MCLog(\"request size\");\n        fetch_att = mailimap_fetch_att_new_rfc822_size();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    }\n    \n    if ((requestKind & IMAPMessagesRequestKindStructure) != 0) {\n        // message structure\n        MCLog(\"request bodystructure\");\n        fetch_att = mailimap_fetch_att_new_bodystructure();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsBody = true;\n    }\n    if ((requestKind & IMAPMessagesRequestKindInternalDate) != 0) {\n        // internal date\n        fetch_att = mailimap_fetch_att_new_internaldate();\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    }\n    if ((requestKind & IMAPMessagesRequestKindBody) != 0) {\n        fetch_att = mailimap_fetch_att_new_body_peek_section(mailimap_section_new(NULL));\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n    }\n    if ((requestKind & IMAPMessagesRequestKindExtraHeaders) != 0) {\n        // custom header request\n        char * header;\n        \n        if (extraHeaders && extraHeaders->count() > 0) {\n            for (unsigned int i = 0; i < extraHeaders->count(); i++) {\n                String * headerString = (String *)extraHeaders->objectAtIndex(i);\n                header = strdup(headerString->UTF8Characters());\n                clist_append(hdrlist, header);\n            }\n        }\n    }\n    \n    if (clist_begin(hdrlist) != NULL) {\n        struct mailimap_header_list * imap_hdrlist;\n        struct mailimap_section * section;\n        \n        imap_hdrlist = mailimap_header_list_new(hdrlist);\n        section = mailimap_section_new_header_fields(imap_hdrlist);\n        fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);\n        needsHeader = true;\n    }\n    else {\n        clist_free(hdrlist);\n    }\n    \n    struct msg_att_handler_data msg_att_data;\n    \n    memset(&msg_att_data, 0, sizeof(msg_att_data));\n    msg_att_data.uidsFilter = uidsFilter;\n    msg_att_data.numbersFilter = numbersFilter;\n    msg_att_data.fetchByUID = fetchByUID;\n    msg_att_data.result = messages;\n    msg_att_data.requestKind = requestKind;\n    msg_att_data.mLastFetchedSequenceNumber = mLastFetchedSequenceNumber;\n    msg_att_data.mapping = mapping;\n    msg_att_data.needsHeader = needsHeader;\n    msg_att_data.needsBody = needsBody;\n    msg_att_data.needsFlags = needsFlags;\n    msg_att_data.needsGmailLabels = needsGmailLabels;\n    msg_att_data.needsGmailMessageID = needsGmailMessageID;\n    msg_att_data.needsGmailThreadID = needsGmailThreadID;\n    mailimap_set_msg_att_handler(mImap, msg_att_handler, &msg_att_data);\n    \n    mBodyProgressEnabled = false;\n    vanished = NULL;\n    \n    if (fetchByUID) {\n        if ((modseq != 0) && (mCondstoreEnabled || mQResyncEnabled)) {\n            if (mQResyncEnabled) {\n                r = mailimap_uid_fetch_qresync(mImap, imapset, fetch_type, modseq,\n                                               &fetch_result,  &vanished);\n            }\n            else { /* condstore */\n                r = mailimap_uid_fetch_changedsince(mImap, imapset, fetch_type, modseq,\n                                                    &fetch_result);\n            }\n        }\n        else {\n            r = mailimap_uid_fetch(mImap, imapset, fetch_type, &fetch_result);\n        }\n    } else {\n        if ((modseq != 0) && (mCondstoreEnabled || mQResyncEnabled)) {\n            if (mQResyncEnabled) {\n                r = mailimap_fetch_qresync(mImap, imapset, fetch_type, modseq,\n                                           &fetch_result,  &vanished);\n            }\n            else { /* condstore */\n                r = mailimap_fetch_changedsince(mImap, imapset, fetch_type, modseq,\n                                                &fetch_result);\n            }\n        }\n        else {\n            r = mailimap_fetch(mImap, imapset, fetch_type, &fetch_result);\n        }\n    }\n    \n    vanishedMessages = NULL;\n    if (vanished != NULL) {\n        vanishedMessages = indexSetFromSet(vanished->qr_known_uids);\n    }\n    \n    mBodyProgressEnabled = true;\n    \n    mProgressCallback = NULL;\n    \n    mLastFetchedSequenceNumber = msg_att_data.mLastFetchedSequenceNumber;\n    \n    mailimap_fetch_type_free(fetch_type);\n    \n    mailimap_set_msg_att_handler(mImap, NULL, NULL);\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        MCLog(\"error stream\");\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        MCLog(\"error parse\");\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        MCLog(\"error fetch\");\n        * pError = ErrorFetch;\n        return NULL;\n    }\n    \n    IMAPSyncResult * result;\n    result = new IMAPSyncResult();\n    result->setModifiedOrAddedMessages(messages);\n    result->setVanishedMessages(vanishedMessages);\n    result->autorelease();\n    \n    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {\n        if (messages->count() == 0) {\n            unsigned int count;\n            \n            count = clist_count(fetch_result);\n            if (count > 0) {\n                requestKind = (IMAPMessagesRequestKind) (requestKind & ~IMAPMessagesRequestKindHeaders);\n                requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindFullHeaders);\n\n                result = fetchMessages(folder, requestKind, fetchByUID,\n                    imapset, uidsFilter, numbersFilter,\n                    modseq, NULL, progressCallback, extraHeaders, pError);\n                if (result != NULL) {\n                    if (result->modifiedOrAddedMessages() != NULL) {\n                        if (result->modifiedOrAddedMessages()->count() > 0) {\n                            mNeedsMboxMailWorkaround = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    mailimap_fetch_list_free(fetch_result);\n    * pError = ErrorNone;\n    \n    return result;\n}\n\nArray * IMAPSession::fetchMessagesByUID(String * folder, IMAPMessagesRequestKind requestKind,\n                                        IndexSet * uids, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessagesByUIDWithExtraHeaders(folder, requestKind, uids, progressCallback, NULL, pError);\n}\n\n\nArray * IMAPSession::fetchMessagesByUIDWithExtraHeaders(String * folder, IMAPMessagesRequestKind requestKind,\n                                                        IndexSet * uids, IMAPProgressCallback * progressCallback,\n                                                        Array * extraHeaders, ErrorCode * pError)\n{\n    struct mailimap_set * imapset = setFromIndexSet(uids);\n    IMAPSyncResult * syncResult = fetchMessages(folder, requestKind, true, imapset, uids, NULL, 0, NULL,\n                                                progressCallback, extraHeaders, pError);\n    if (syncResult == NULL) {\n        mailimap_set_free(imapset);\n        return NULL;\n    }\n    Array * result = syncResult->modifiedOrAddedMessages();\n    result->retain()->autorelease();\n    mailimap_set_free(imapset);\n    return result;\n}\n\nArray * IMAPSession::fetchMessagesByNumber(String * folder, IMAPMessagesRequestKind requestKind,\n                                           IndexSet * numbers, IMAPProgressCallback * progressCallback,\n                                           ErrorCode * pError)\n{\n    return fetchMessagesByNumberWithExtraHeaders(folder, requestKind, numbers, progressCallback, NULL, pError);\n}\n\nArray * IMAPSession::fetchMessagesByNumberWithExtraHeaders(String * folder, IMAPMessagesRequestKind requestKind,\n                                                           IndexSet * numbers, IMAPProgressCallback * progressCallback,\n                                                           Array * extraHeaders, ErrorCode * pError)\n{\n    struct mailimap_set * imapset = setFromIndexSet(numbers);\n    IMAPSyncResult * syncResult = fetchMessages(folder, requestKind, false, imapset, NULL, numbers, 0, NULL,\n                                                progressCallback, extraHeaders, pError);\n    if (syncResult == NULL) {\n        mailimap_set_free(imapset);\n        return NULL;\n    }\n    Array * result = syncResult->modifiedOrAddedMessages();\n    result->retain()->autorelease();\n    mailimap_set_free(imapset);\n    return result;\n}\n\nstatic int fetch_rfc822(mailimap * session, bool identifier_is_uid,\n                        uint32_t identifier, char ** result, size_t * result_len)\n{\n    struct mailimap_section * section;\n    struct mailimap_fetch_att * fetch_att;\n    struct mailimap_fetch_type * fetch_type;\n    \n    section = mailimap_section_new(NULL);\n    fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);\n    int r = fetch_imap(session, identifier_is_uid, identifier,\n                       fetch_type, result, result_len);\n    mailimap_fetch_type_free(fetch_type);\n    \n    return r;\n    \n#if 0\n    int r;\n    clist * fetch_list;\n    struct mailimap_section * section;\n    struct mailimap_fetch_att * fetch_att;\n    struct mailimap_fetch_type * fetch_type;\n    struct mailimap_set * set;\n    struct mailimap_msg_att * msg_att;\n    struct mailimap_msg_att_item * item;\n    int res;\n    clistiter * cur;\n    \n    section = mailimap_section_new(NULL);\n    fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);\n    \n    set = mailimap_set_new_single(identifier);\n    \n    if (identifier_is_uid) {\n        r = mailimap_uid_fetch(session, set, fetch_type, &fetch_list);\n    }\n    else {\n        r = mailimap_fetch(session, set, fetch_type, &fetch_list);\n    }\n    \n    mailimap_set_free(set);\n    mailimap_fetch_type_free(fetch_type);\n    \n    if (r != MAILIMAP_NO_ERROR) {\n        res = r;\n        goto err;\n    }\n    \n    if (clist_isempty(fetch_list)) {\n        res = MAILIMAP_ERROR_FETCH;\n        goto free;\n    }\n    \n    msg_att = (struct mailimap_msg_att *) clist_begin(fetch_list)->data;\n    \n    for(cur = clist_begin(msg_att->att_list) ; cur != NULL ; cur = clist_next(cur)) {\n        item = (struct mailimap_msg_att_item *) clist_content(cur);\n        \n        if (item->att_type != MAILIMAP_MSG_ATT_ITEM_STATIC) {\n            continue;\n        }\n        if (item->att_data.att_static->att_type != MAILIMAP_MSG_ATT_BODY_SECTION) {\n            continue;\n        }\n        \n        * result = item->att_data.att_static->att_data.att_body_section->sec_body_part;\n        item->att_data.att_static->att_data.att_body_section->sec_body_part = NULL;\n        mailimap_fetch_list_free(fetch_list);\n        \n        return MAILIMAP_NO_ERROR;\n    }\n    \n    res = MAILIMAP_ERROR_FETCH;\n    \nfree:\n    mailimap_fetch_list_free(fetch_list);\nerr:\n    return res;\n#endif\n}\n\nData * IMAPSession::fetchMessageByUID(String * folder, uint32_t uid,\n    IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessage(folder, true, uid, progressCallback, pError);\n}\n\nData * IMAPSession::fetchMessageByNumber(String * folder, uint32_t number,\n                                         IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessage(folder, false, number, progressCallback, pError);\n}\n\nData * IMAPSession::fetchMessage(String * folder, bool identifier_is_uid, uint32_t identifier,\n                                 IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    char * rfc822;\n    size_t rfc822_len;\n    int r;\n    Data * data;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    mProgressItemsCount = 0;\n    mProgressCallback = progressCallback;\n    \n    rfc822 = NULL;\n    r = fetch_rfc822(mImap, identifier_is_uid, identifier, &rfc822, &rfc822_len);\n    if (r == MAILIMAP_NO_ERROR) {\n        size_t len;\n        \n        len = 0;\n        if (rfc822 != NULL) {\n            len = strlen(rfc822);\n        }\n        bodyProgress((unsigned int) len, (unsigned int) len);\n    }\n    mProgressCallback = NULL;\n    \n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return NULL;\n    }\n    \n    if (rfc822 == NULL) {\n        data = Data::data();\n    }\n    else {\n        data = Data::dataWithBytes(rfc822, (unsigned int) rfc822_len);\n    }\n    \n    mailimap_nstring_free(rfc822);\n    * pError = ErrorNone;\n    \n    return data;\n}\n\nstatic void nstringDeallocator(char * bytes, unsigned int length) {\n    mailimap_nstring_free(bytes);\n};\n\nData * IMAPSession::fetchNonDecodedMessageAttachment(String * folder, bool identifier_is_uid,\n                                           uint32_t identifier, String * partID,\n                                           bool wholePart, uint32_t offset, uint32_t length,\n                                           Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    struct mailimap_fetch_type * fetch_type;\n    struct mailimap_fetch_att * fetch_att;\n    struct mailimap_section * section;\n    struct mailimap_section_part * section_part;\n    clist * sec_list;\n    Array * partIDArray;\n    int r;\n    char * text = NULL;\n    size_t text_length = 0;\n    Data * data;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    mProgressItemsCount = 0;\n    mProgressCallback = progressCallback;\n    bodyProgress(0, 0);\n\n    partIDArray = partID->componentsSeparatedByString(MCSTR(\".\"));\n    sec_list = clist_new();\n    for(unsigned int i = 0 ; i < partIDArray->count() ; i ++) {\n        uint32_t * value;\n        String * element;\n\n        element = (String *) partIDArray->objectAtIndex(i);\n        value = (uint32_t *) malloc(sizeof(* value));\n        * value = element->intValue();\n        clist_append(sec_list, value);\n    }\n    section_part = mailimap_section_part_new(sec_list);\n    section = mailimap_section_new_part(section_part);\n    if (wholePart) {\n        fetch_att = mailimap_fetch_att_new_body_peek_section(section);\n    }\n    else {\n        fetch_att = mailimap_fetch_att_new_body_peek_section_partial(section, offset, length);\n    }\n    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);\n\n#ifdef LIBETPAN_HAS_MAILIMAP_RAMBLER_WORKAROUND\n    if (mRamblerRuServer && (encoding == EncodingBase64 || encoding == EncodingUUEncode)) {\n        mailimap_set_rambler_workaround_enabled(mImap, 1);\n    }\n#endif\n\n    r = fetch_imap(mImap, identifier_is_uid, identifier, fetch_type, &text, &text_length);\n    mailimap_fetch_type_free(fetch_type);\n\n#ifdef LIBETPAN_HAS_MAILIMAP_RAMBLER_WORKAROUND\n    mailimap_set_rambler_workaround_enabled(mImap, 0);\n#endif\n\n    mProgressCallback = NULL;\n    \n    MCLog(\"had error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return NULL;\n    }\n\n    data = Data::data();\n    data->takeBytesOwnership(text, (unsigned int) text_length, nstringDeallocator);\n    \n    * pError = ErrorNone;\n    \n    return data;\n}\n\nData * IMAPSession::fetchMessageAttachment(String * folder, bool identifier_is_uid,\n                                           uint32_t identifier, String * partID,\n                                           Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    Data * data = fetchNonDecodedMessageAttachment(folder, identifier_is_uid, identifier, partID, true, 0, 0, encoding, progressCallback, pError);\n    if (data) {\n        data = data->decodedDataUsingEncoding(encoding);\n    }\n    return data;\n}\n\nData * IMAPSession::fetchMessageAttachmentByUID(String * folder, uint32_t uid, String * partID,\n                                                Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessageAttachment(folder, true, uid, partID, encoding, progressCallback, pError);\n}\n\nData * IMAPSession::fetchMessageAttachmentByNumber(String * folder, uint32_t number, String * partID,\n                                              Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return fetchMessageAttachment(folder, false, number, partID, encoding, progressCallback, pError);\n}\n\nvoid IMAPSession::fetchMessageAttachmentToFileByChunksByUID(String * folder, uint32_t uid, String * partID,\n                                                    uint32_t estimatedSize, Encoding encoding,\n                                                    String * outputFile, uint32_t chunkSize,\n                                                    IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    DataStreamDecoder * decoder = new DataStreamDecoder();\n    decoder->setEncoding(encoding);\n    decoder->setFilename(outputFile);\n\n    int nRetries = 0;\n    int const maxRetries = 3;\n    ErrorCode error = ErrorNone;\n    uint32_t offset = 0;\n    while (1) {\n        AutoreleasePool * pool = new AutoreleasePool();\n\n        LoadByChunkProgress * chunkProgressCallback = new LoadByChunkProgress();\n        chunkProgressCallback->setOffset(offset);\n        chunkProgressCallback->setEstimatedSize(estimatedSize);\n        chunkProgressCallback->setProgressCallback(progressCallback);\n\n        Data * data = fetchNonDecodedMessageAttachment(folder, true, uid, partID, false, offset, chunkSize, encoding, chunkProgressCallback, &error);\n\n        MC_SAFE_RELEASE(chunkProgressCallback);\n\n        if (error != ErrorNone) {\n            pool->release();\n            if ((error == ErrorConnection || error == ErrorParse) && nRetries < maxRetries) {\n                error = ErrorNone;\n                nRetries++;\n                continue;\n            }\n            break;\n        } else {\n            nRetries = 0;\n        }\n\n        if (data == NULL) {\n            break;\n        }\n\n        uint32_t encodedSize = data->length();\n        if (encodedSize == 0) {\n            pool->release();\n            break;\n        }\n\n        error = decoder->appendData(data);\n\n        pool->release();\n\n        if (error != ErrorNone) {\n            break;\n        }\n\n        offset += encodedSize;\n\n        // Try detect is this chunk last.\n        // Estimated size (extracted from BODYSTRUCTURE info) may be incorrect.\n        // Also, server may return chunk with size less than requested.\n        // So this detection is some tricky.\n        bool endOfPart = ((encodedSize == 0) ||\n                          (estimatedSize > 0 && (estimatedSize <= offset) && (encodedSize != chunkSize)) ||\n                          (estimatedSize == 0 && encodedSize < chunkSize));\n        if (endOfPart) {\n            break;\n        }\n    }\n\n    if (error == ErrorNone) {\n        decoder->flushData();\n    }\n\n    MC_SAFE_RELEASE(decoder);\n\n    * pError = error;\n}\n\nstatic bool msg_body_handler(int msg_att_type, struct mailimap_msg_att_body_section * section,\n                             const char * bytes, size_t len, void * context)\n{\n    DataStreamDecoder * decoder = (DataStreamDecoder *)context;\n\n    AutoreleasePool * pool = new AutoreleasePool();\n\n    Data * data = Data::dataWithBytes(bytes, (unsigned int) len);\n    ErrorCode error = decoder->appendData(data);\n\n    pool->release();\n\n    return error == ErrorNone;\n}\n\nvoid IMAPSession::fetchMessageAttachmentToFileByUID(String * folder, uint32_t uid, String * partID,\n                                                    Encoding encoding, String * outputFile,\n                                                    IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    DataStreamDecoder * decoder = new DataStreamDecoder();\n    decoder->setEncoding(encoding);\n    decoder->setFilename(outputFile);\n\n    ErrorCode error = ErrorNone;\n    selectIfNeeded(folder, &error);\n    if (error != ErrorNone) {\n        * pError = error;\n        return;\n    }\n\n    mailimap_set_msg_body_handler(mImap, msg_body_handler, decoder);\n\n    fetchNonDecodedMessageAttachment(folder, true, uid, partID, true, 0, 0, encoding, progressCallback, &error);\n\n    mailimap_set_msg_body_handler(mImap, NULL, NULL);\n\n    if (error == ErrorNone) {\n        error = decoder->flushData();\n    }\n\n    MC_SAFE_RELEASE(decoder);\n\n    * pError = error;\n}\n\nIndexSet * IMAPSession::search(String * folder, IMAPSearchKind kind, String * searchString, ErrorCode * pError)\n{\n    IMAPSearchExpression * expr;\n    \n    expr = NULL;\n    switch (kind) {\n        case IMAPSearchKindAll:\n        {\n            expr = IMAPSearchExpression::searchAll();\n            break;\n        }\n        case IMAPSearchKindFrom:\n        {\n            expr = IMAPSearchExpression::searchFrom(searchString);\n            break;\n        }\n        case IMAPSearchKindTo:\n        {\n            expr = IMAPSearchExpression::searchTo(searchString);\n            break;\n        }\n        case IMAPSearchKindCc:\n        {\n            expr = IMAPSearchExpression::searchCc(searchString);\n            break;\n        }\n        case IMAPSearchKindBcc:\n        {\n            expr = IMAPSearchExpression::searchBcc(searchString);\n            break;\n        }\n        case IMAPSearchKindRecipient:\n        {\n            expr = IMAPSearchExpression::searchRecipient(searchString);\n            break;\n        }\n        case IMAPSearchKindSubject:\n        {\n            expr = IMAPSearchExpression::searchSubject(searchString);\n            break;\n        }\n        case IMAPSearchKindContent:\n        {\n            expr = IMAPSearchExpression::searchContent(searchString);\n            break;\n        }\n        case IMAPSearchKindBody:\n        {\n            expr = IMAPSearchExpression::searchBody(searchString);\n            break;\n        }\n        case IMAPSearchKindRead:\n        {\n            expr = IMAPSearchExpression::searchRead();\n            break;\n        }\n        case IMAPSearchKindUnread:\n        {\n            expr = IMAPSearchExpression::searchUnread();\n            break;\n        }\n        case IMAPSearchKindFlagged:\n        {\n            expr = IMAPSearchExpression::searchFlagged();\n            break;\n        }\n        case IMAPSearchKindUnflagged:\n        {\n            expr = IMAPSearchExpression::searchUnflagged();\n            break;\n        }\n        case IMAPSearchKindAnswered:\n        {\n            expr = IMAPSearchExpression::searchAnswered();\n            break;\n        }\n        case IMAPSearchKindUnanswered:\n        {\n            expr = IMAPSearchExpression::searchUnanswered();\n            break;\n        }\n        case IMAPSearchKindDraft:\n        {\n            expr = IMAPSearchExpression::searchDraft();\n            break;\n        }\n        case IMAPSearchKindUndraft:\n        {\n            expr = IMAPSearchExpression::searchUndraft();\n            break;\n        }\n        case IMAPSearchKindDeleted:\n        {\n            expr = IMAPSearchExpression::searchDeleted();\n            break;\n        }\n        case IMAPSearchKindSpam:\n        {\n            expr = IMAPSearchExpression::searchSpam();\n            break;\n        }\n        case IMAPSearchKindHeader:\n        {\n            String *header = new String(\"Message-ID\");\n            expr = IMAPSearchExpression::searchHeader(header, searchString);\n            break;\n        }\n        default:\n        {\n            MCAssert(0);\n            break;\n        }\n    }\n    return search(folder, expr, pError);\n}\n\nstatic struct mailimap_search_key * searchKeyFromSearchExpression(IMAPSearchExpression * expression)\n{\n    switch (expression->kind()) {\n        case IMAPSearchKindAll:\n        {\n            return mailimap_search_key_new_all();\n        }\n        case IMAPSearchKindFrom:\n        {\n            return mailimap_search_key_new_from(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindTo:\n        {\n            return mailimap_search_key_new_to(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindCc:\n        {\n            return mailimap_search_key_new_cc(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindBcc:\n        {\n            return mailimap_search_key_new_bcc(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindRecipient:\n        {\n            struct mailimap_search_key * to_search;\n            struct mailimap_search_key * cc_search;\n            struct mailimap_search_key * bcc_search;\n            struct mailimap_search_key * or_search1;\n            struct mailimap_search_key * or_search2;\n            \n            to_search = mailimap_search_key_new_to(strdup(expression->value()->UTF8Characters()));\n            cc_search = mailimap_search_key_new_cc(strdup(expression->value()->UTF8Characters()));\n            bcc_search = mailimap_search_key_new_bcc(strdup(expression->value()->UTF8Characters()));\n            \n            or_search1 = mailimap_search_key_new_or(to_search, cc_search);\n            or_search2 = mailimap_search_key_new_or(or_search1, bcc_search);\n            \n            return or_search2;\n        }\n        case IMAPSearchKindSubject:\n        {\n            return mailimap_search_key_new_subject(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindContent:\n        {\n            return mailimap_search_key_new_text(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindBody:\n        {\n            return mailimap_search_key_new_body(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindUIDs:\n        {\n            return mailimap_search_key_new_uid(setFromIndexSet(expression->uids()));\n        }\n        case IMAPSearchKindNumbers:\n        {\n            return mailimap_search_key_new_set(setFromIndexSet(expression->numbers()));\n        }\n        case IMAPSearchKindHeader:\n        {\n            return mailimap_search_key_new_header(strdup(expression->header()->UTF8Characters()), strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindBeforeDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_sentbefore(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindOnDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_senton(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindSinceDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_sentsince(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindBeforeReceivedDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_before(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindOnReceivedDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_on(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindSinceReceivedDate:\n        {\n            time_t date = expression->date();\n            struct tm timeinfo;\n            localtime_r(&date, &timeinfo);\n            return mailimap_search_key_new_since(mailimap_date_new(timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900));\n        }\n        case IMAPSearchKindGmailThreadID:\n        {\n            return mailimap_search_key_new_xgmthrid(expression->longNumber());\n        }\n        case IMAPSearchKindGmailMessageID:\n        {\n            return mailimap_search_key_new_xgmmsgid(expression->longNumber());\n        }\n        case IMAPSearchKindRead:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_SEEN, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUnread:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNSEEN, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindFlagged:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_FLAGGED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUnflagged:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNFLAGGED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindAnswered:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_ANSWERED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUnanswered:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNANSWERED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindDraft:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_DRAFT, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindUndraft:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_UNDRAFT, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindDeleted:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_DELETED, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindSpam:\n        {\n            return mailimap_search_key_new(MAILIMAP_SEARCH_KEY_KEYWORD, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           strdup(\"Junk\"), NULL, NULL, NULL, NULL, \n                                           NULL, NULL, NULL, NULL, 0, \n                                           NULL, NULL, NULL, NULL, NULL, \n                                           NULL, 0, NULL, NULL, NULL);\n        }\n        case IMAPSearchKindSizeLarger:\n        {\n            return mailimap_search_key_new_larger( (uint32_t) expression->longNumber());\n        }\n        case IMAPSearchKindSizeSmaller:\n        {\n            return mailimap_search_key_new_smaller( (uint32_t) expression->longNumber());\n        }\n        case IMAPSearchKindGmailRaw:\n        {\n            return mailimap_search_key_new_xgmraw(strdup(expression->value()->UTF8Characters()));\n        }\n        case IMAPSearchKindOr:\n        {\n            return mailimap_search_key_new_or(searchKeyFromSearchExpression(expression->leftExpression()), searchKeyFromSearchExpression(expression->rightExpression()));\n        }\n        case IMAPSearchKindAnd:\n        {\n            clist * list;\n            list = clist_new();\n            clist_append(list, searchKeyFromSearchExpression(expression->leftExpression()));\n            clist_append(list, searchKeyFromSearchExpression(expression->rightExpression()));\n            return mailimap_search_key_new_multiple(list);\n        }\n        case IMAPSearchKindNot:\n        {\n            return mailimap_search_key_new_not(searchKeyFromSearchExpression(expression->leftExpression()));\n        }\n\n        default:\n        MCAssert(0);\n        return NULL;\n    }\n}\n\nIndexSet * IMAPSession::search(String * folder, IMAPSearchExpression * expression, ErrorCode * pError)\n{\n    struct mailimap_search_key * key;\n    \n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    clist * result_list = NULL;\n    \n    const char * charset = \"utf-8\";\n    if (mYahooServer) {\n        charset = NULL;\n    }\n    \n    int r;\n    key = searchKeyFromSearchExpression(expression);\n    if (mIsGmail) {\n        r = mailimap_uid_search_literalplus(mImap, charset, key, &result_list);\n    }\n    else {\n        r = mailimap_uid_search(mImap, charset, key, &result_list);\n    }\n    mailimap_search_key_free(key);\n    MCLog(\"had error : %i\", r);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return NULL;\n    }\n\n    IndexSet * result = IndexSet::indexSet();\n    for(clistiter * cur = clist_begin(result_list) ; cur != NULL ; cur = clist_next(cur))  {\n        uint32_t * uid = (uint32_t *) clist_content(cur);\n        result->addIndex(* uid);\n    }\n    mailimap_search_result_free(result_list);\n    * pError = ErrorNone;\n    return result;\n}\n\nvoid IMAPSession::getQuota(uint32_t *usage, uint32_t *limit, ErrorCode * pError)\n{\n    mailimap_quota_complete_data *quota_data;\n    \n    int r = mailimap_quota_getquotaroot(mImap, \"INBOX\", &quota_data);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorFetch;\n        return;\n    }\n    for(clistiter * cur = clist_begin(quota_data->quota_list); cur != NULL; cur = clist_next(cur)) {\n        mailimap_quota_quota_data *quota = (mailimap_quota_quota_data*)clist_content(cur);\n        for (clistiter *cur2 = clist_begin(quota->quota_list); cur2 != NULL; cur2 = clist_next(cur2)) {\n            mailimap_quota_quota_resource *res = (mailimap_quota_quota_resource*)clist_content(cur2);\n            if (!strcasecmp(\"STORAGE\", res->resource_name)) {\n                *usage = res->usage;\n                *limit = res->limit;\n            }\n        }\n    }\n    mailimap_quota_complete_data_free(quota_data);    \n}\n\nbool IMAPSession::setupIdle()\n{\n    // main thread\n    LOCK();\n    bool canIdle = mIdleEnabled;\n    if (mIdleEnabled) {\n        mailstream_setup_idle(mImap->imap_stream);\n    }\n    UNLOCK();\n    return canIdle;\n}\n\nvoid IMAPSession::idle(String * folder, uint32_t lastKnownUID, Data ** response, ErrorCode * pError)\n{\n    int r;\n    \n    setNeedsReselect();\n\n    // connection thread\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n    \n    if (lastKnownUID != 0) {\n        Array * msgs;\n        \n        msgs = fetchMessagesByUID(folder, IMAPMessagesRequestKindUid, IndexSet::indexSetWithRange(RangeMake(lastKnownUID, UINT64_MAX)),\n                                  NULL, pError);\n        if (* pError != ErrorNone)\n            return;\n        if (msgs->count() > 0) {\n            IMAPMessage * msg;\n            \n            msg = (IMAPMessage *) msgs->objectAtIndex(0);\n            if (msg->uid() > lastKnownUID) {\n                MCLog(\"found msg UID %u %u\", (unsigned int) msg->uid(), (unsigned int) lastKnownUID);\n                return;\n            }\n        }\n    }\n    \n    r = mailimap_idle(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorIdle;\n        return;\n    }\n    \n    if (!mImap->imap_selection_info->sel_has_exists && !mImap->imap_selection_info->sel_has_recent) {\n        int r;\n        r = mailstream_wait_idle(mImap->imap_stream, MAX_IDLE_DELAY);\n        switch (r) {\n            case MAILSTREAM_IDLE_ERROR:\n            case MAILSTREAM_IDLE_CANCELLED:\n            {\n                mShouldDisconnect = true;\n                * pError = ErrorConnection;\n                MCLog(\"error or cancelled\");\n                return;\n            }\n            case MAILSTREAM_IDLE_INTERRUPTED:\n                * pError = ErrorIdleInterrupted;\n                MCLog(\"interrupted by user\");\n                break;\n            case MAILSTREAM_IDLE_HASDATA:\n                MCLog(\"something on the socket\");\n                break;\n            case MAILSTREAM_IDLE_TIMEOUT:\n                MCLog(\"idle timeout\");\n                break;\n        }\n    }\n    else {\n        MCLog(\"found info before idling\");\n    }\n    \n    r = mailimap_idle_done(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorIdle;\n        return;\n    }\n    * pError = ErrorNone;\n}\n\nvoid IMAPSession::interruptIdle()\n{\n    // main thread\n    LOCK();\n    if (mIdleEnabled) {\n        mailstream_interrupt_idle(mImap->imap_stream);\n    }\n    UNLOCK();\n}\n\nvoid IMAPSession::unsetupIdle()\n{\n    // main thread\n    LOCK();\n    if (mIdleEnabled) {\n        mailstream_unsetup_idle(mImap->imap_stream);\n    }\n    UNLOCK();\n}\n\nvoid IMAPSession::disconnect()\n{\n    unsetup();\n}\n\nvoid IMAPSession::reconnect(ErrorCode * pError)\n{\n    mShouldDisconnect = true;\n    connectIfNeeded(pError);\n}\n\nIMAPIdentity * IMAPSession::identity(IMAPIdentity * clientIdentity, ErrorCode * pError)\n{\n    connectIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n\n    struct mailimap_id_params_list * client_identification;\n\n    client_identification = mailimap_id_params_list_new_empty();\n\n    mc_foreacharray(String, key, clientIdentity->allInfoKeys()) {\n        MMAPString * mmap_str_name = mmap_string_new(key->UTF8Characters());\n        MMAPString * mmap_str_value = mmap_string_new(clientIdentity->infoForKey(key)->UTF8Characters());\n        mmap_string_ref(mmap_str_name);\n        mmap_string_ref(mmap_str_value);\n        mailimap_id_params_list_add_name_value(client_identification, mmap_str_name->str, mmap_str_value->str);\n    }\n\n    int r;\n    struct mailimap_id_params_list * server_identification;\n    r = mailimap_id(mImap, client_identification, &server_identification);\n    mailimap_id_params_list_free(client_identification);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorIdentity;\n        return NULL;\n    }\n\n    IMAPIdentity * result = new IMAPIdentity();\n    \n    clistiter * cur;\n    for(cur = clist_begin(server_identification->idpa_list) ; cur != NULL ; cur = clist_next(cur)) {\n        struct mailimap_id_param * param;\n\n        param = (struct mailimap_id_param *) clist_content(cur);\n        \n        String * responseKey;\n        String * responseValue;\n        responseKey = String::stringWithUTF8Characters(param->idpa_name);\n        responseValue = String::stringWithUTF8Characters(param->idpa_value);\n        result->setInfoForKey(responseKey, responseValue);\n    }\n\n    mailimap_id_params_list_free(server_identification);\n    * pError = ErrorNone;\n\n    result->autorelease();\n    return result;\n}\n\nvoid IMAPSession::bodyProgress(unsigned int current, unsigned int maximum)\n{\n    if (!mBodyProgressEnabled)\n        return;\n    \n    if (mProgressCallback != NULL) {\n        mProgressCallback->bodyProgress(this, current, maximum);\n    }\n}\n\nvoid IMAPSession::itemsProgress(unsigned int current, unsigned int maximum)\n{\n    mProgressItemsCount ++;\n    if (mProgressCallback != NULL) {\n        mProgressCallback->itemsProgress(this, mProgressItemsCount, maximum);\n    }\n}\n\nIMAPNamespace * IMAPSession::defaultNamespace()\n{\n    return mDefaultNamespace;\n}\n\nvoid IMAPSession::setDefaultNamespace(IMAPNamespace * ns)\n{\n    MC_SAFE_REPLACE_RETAIN(IMAPNamespace, mDefaultNamespace, ns);\n}\n\nIMAPIdentity * IMAPSession::serverIdentity()\n{\n    return mServerIdentity;\n}\n\nIMAPIdentity * IMAPSession::clientIdentity()\n{\n    return mClientIdentity;\n}\n\nvoid IMAPSession::setClientIdentity(IMAPIdentity * identity)\n{\n    MC_SAFE_REPLACE_COPY(IMAPIdentity, mClientIdentity, identity);\n}\n\nHashMap * IMAPSession::fetchNamespace(ErrorCode * pError)\n{\n    HashMap * result;\n    struct mailimap_namespace_data * namespace_data;\n    int r;\n    \n    loginIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    result = HashMap::hashMap();\n    r = mailimap_namespace(mImap, &namespace_data);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorNamespace;\n        return NULL;\n    }\n    \n    IMAPNamespace * ns;\n    \n    if (namespace_data->ns_personal != NULL) {\n        ns = new IMAPNamespace();\n        ns->importIMAPNamespace(namespace_data->ns_personal);\n        result->setObjectForKey(IMAPNamespacePersonal, ns);\n        ns->release();\n    }\n    \n    if (namespace_data->ns_other != NULL) {\n        ns = new IMAPNamespace();\n        ns->importIMAPNamespace(namespace_data->ns_other);\n        result->setObjectForKey(IMAPNamespaceOther, ns);\n        ns->release();\n    }\n    \n    if (namespace_data->ns_shared != NULL) {\n        ns = new IMAPNamespace();\n        ns->importIMAPNamespace(namespace_data->ns_shared);\n        result->setObjectForKey(IMAPNamespaceShared, ns);\n        ns->release();\n    }\n    \n    mailimap_namespace_data_free(namespace_data);\n    * pError = ErrorNone;\n    \n    return result;\n}\n\nvoid IMAPSession::storeFlagsByUID(String * folder, IndexSet * uids, IMAPStoreFlagsRequestKind kind, MessageFlag flags, ErrorCode * pError)\n{\n    this->storeFlagsAndCustomFlagsByUID(folder, uids, kind, flags, NULL, pError);\n}\n\nvoid IMAPSession::storeFlagsAndCustomFlagsByUID(String * folder, IndexSet * uids, IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)\n{\n    storeFlagsAndCustomFlags(folder, true, uids, kind, flags, customFlags, pError);\n}\n\nvoid IMAPSession::storeFlagsAndCustomFlags(String * folder, bool identifier_is_uid, IndexSet * identifiers,\n                                                      IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)\n{\n    struct mailimap_set * imap_set;\n    struct mailimap_store_att_flags * store_att_flags;\n    struct mailimap_flag_list * flag_list;\n    int r;\n    clist * setList;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    imap_set = setFromIndexSet(identifiers);\n    if (clist_count(imap_set->set_list) == 0) {\n        mailimap_set_free(imap_set);\n        return;\n    }\n\n    setList = splitSet(imap_set, 50);\n\n    flag_list = mailimap_flag_list_new_empty();\n    if ((flags & MessageFlagSeen) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_seen();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagAnswered) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_answered();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagFlagged) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flagged();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagDeleted) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_deleted();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagDraft) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_draft();\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagMDNSent) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flag_keyword(strdup(\"$MDNSent\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagForwarded) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flag_keyword(strdup(\"$Forwarded\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagSubmitPending) != 0) {\n        struct mailimap_flag * f;\n\n        f = mailimap_flag_new_flag_keyword(strdup(\"$SubmitPending\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    if ((flags & MessageFlagSubmitted) != 0) {\n        struct mailimap_flag * f;\n        \n        f = mailimap_flag_new_flag_keyword(strdup(\"$Submitted\"));\n        mailimap_flag_list_add(flag_list, f);\n    }\n    \n    if (customFlags != NULL) {\n        for (unsigned int i = 0 ; i < customFlags->count() ; i ++) {\n            struct mailimap_flag * f;\n            String * customFlag = (String *) customFlags->objectAtIndex(i);\n            \n            f = mailimap_flag_new_flag_keyword(strdup(customFlag->UTF8Characters()));\n            mailimap_flag_list_add(flag_list, f);\n        }\n    }\n\n    store_att_flags = NULL;\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        switch (kind) {\n            case IMAPStoreFlagsRequestKindRemove:\n            store_att_flags = mailimap_store_att_flags_new_remove_flags_silent(flag_list);\n            break;\n            case IMAPStoreFlagsRequestKindAdd:\n            store_att_flags = mailimap_store_att_flags_new_add_flags_silent(flag_list);\n            break;\n            case IMAPStoreFlagsRequestKindSet:\n            store_att_flags = mailimap_store_att_flags_new_set_flags_silent(flag_list);\n            break;\n        }\n\n#ifdef LIBETPAN_HAS_MAILIMAP_QIP_WORKAROUND\n        if (mQipServer) {\n            mailimap_set_qip_workaround_enabled(mImap, 1);\n        }\n#endif\n\n        if (identifier_is_uid) {\n            r = mailimap_uid_store(mImap, current_set, store_att_flags);\n        }\n        else {\n            r = mailimap_store(mImap, current_set, store_att_flags);\n        }\n\n#ifdef LIBETPAN_HAS_MAILIMAP_QIP_WORKAROUND\n        mailimap_set_qip_workaround_enabled(mImap, 0);\n#endif\n\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorStore;\n            goto release;\n        }\n    }\n    * pError = ErrorNone;\n\n    release:\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_store_att_flags_free(store_att_flags);\n    mailimap_set_free(imap_set);\n}\n\nvoid IMAPSession::storeFlagsByNumber(String * folder, IndexSet * numbers, IMAPStoreFlagsRequestKind kind, MessageFlag flags, ErrorCode * pError)\n{\n    this->storeFlagsAndCustomFlagsByNumber(folder, numbers, kind, flags, NULL, pError);\n}\n\nvoid IMAPSession::storeFlagsAndCustomFlagsByNumber(String * folder, IndexSet * numbers, IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)\n{\n    storeFlagsAndCustomFlags(folder, false, numbers, kind, flags, customFlags, pError);\n}\n\nvoid IMAPSession::storeLabelsByUID(String * folder, IndexSet * uids, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)\n{\n    storeLabels(folder, true, uids, kind, labels, pError);\n}\n\nvoid IMAPSession::storeLabelsByNumber(String * folder, IndexSet * numbers, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)\n{\n    storeLabels(folder, false, numbers, kind, labels, pError);\n}\n\nvoid IMAPSession::storeLabels(String * folder, bool identifier_is_uid, IndexSet * identifiers, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)\n{\n    struct mailimap_set * imap_set;\n    struct mailimap_msg_att_xgmlabels * xgmlabels;\n    int r;\n    clist * setList;\n\n    selectIfNeeded(folder, pError);\n    if (* pError != ErrorNone)\n        return;\n\n    imap_set = setFromIndexSet(identifiers);\n    if (clist_count(imap_set->set_list) == 0) {\n        mailimap_set_free(imap_set);\n        return;\n    }\n\n    setList = splitSet(imap_set, 10);\n\n    xgmlabels = mailimap_msg_att_xgmlabels_new_empty();\n    for(unsigned int i = 0 ; i < labels->count() ; i ++) {\n        String * label = (String *) labels->objectAtIndex(i);\n        mailimap_msg_att_xgmlabels_add(xgmlabels, strdup(label->UTF8Characters()));\n    }\n\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n        int fl_sign;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n\n        switch (kind) {\n            case IMAPStoreFlagsRequestKindRemove:\n            fl_sign = -1;\n            break;\n            case IMAPStoreFlagsRequestKindAdd:\n            fl_sign = 1;\n            break;\n            case IMAPStoreFlagsRequestKindSet:\n            fl_sign = 0;\n            break;\n        }\n        if (identifier_is_uid) {\n            r = mailimap_uid_store_xgmlabels(mImap, current_set, fl_sign, 1, xgmlabels);\n        }\n        else {\n            r = mailimap_store_xgmlabels(mImap, current_set, fl_sign, 1, xgmlabels);\n        }\n        if (r == MAILIMAP_ERROR_STREAM) {\n            mShouldDisconnect = true;\n            * pError = ErrorConnection;\n            goto release;\n        }\n        else if (r == MAILIMAP_ERROR_PARSE) {\n            mShouldDisconnect = true;\n            * pError = ErrorParse;\n            goto release;\n        }\n        else if (hasError(r)) {\n            * pError = ErrorStore;\n            goto release;\n        }\n    }\n    * pError = ErrorNone;\n\n    release:\n    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {\n        struct mailimap_set * current_set;\n\n        current_set = (struct mailimap_set *) clist_content(iter);\n        mailimap_set_free(current_set);\n    }\n    clist_free(setList);\n    mailimap_msg_att_xgmlabels_free(xgmlabels);\n    mailimap_set_free(imap_set);\n}\n\nuint32_t IMAPSession::uidValidity()\n{\n    return mUIDValidity;\n}\n\nuint32_t IMAPSession::uidNext()\n{\n    return mUIDNext;\n}\n\nuint64_t IMAPSession::modSequenceValue()\n{\n    return mModSequenceValue;\n}\n\nunsigned int IMAPSession::lastFolderMessageCount()\n{\n    return mFolderMsgCount;\n}\n\nuint32_t IMAPSession::firstUnseenUid()\n{\n    return mFirstUnseenUid;\n}\n\nuint32_t IMAPSession::unseenCount()\n{\n    return mUnseenCount;\n}\n\nIMAPSyncResult * IMAPSession::syncMessagesByUID(String * folder, IMAPMessagesRequestKind requestKind,\n                                                IndexSet * uids, uint64_t modseq,\n                                                IMAPProgressCallback * progressCallback, ErrorCode * pError)\n{\n    return syncMessagesByUIDWithExtraHeaders(folder, requestKind, uids, modseq, progressCallback, NULL, pError);\n}\n\nIMAPSyncResult * IMAPSession::syncMessagesByUIDWithExtraHeaders(String * folder, IMAPMessagesRequestKind requestKind,\n                                                IndexSet * uids, uint64_t modseq,\n                                                IMAPProgressCallback * progressCallback, Array * extraHeaders,\n                                                ErrorCode * pError)\n{\n    struct mailimap_set * imapset = setFromIndexSet(uids);\n    IMAPSyncResult * result = fetchMessages(folder, requestKind, true, imapset,\n                                            uids, NULL,\n                                            modseq, NULL,\n                                            progressCallback, extraHeaders, pError);\n    mailimap_set_free(imapset);\n    return result;\n\n}\n\nIndexSet * IMAPSession::capability(ErrorCode * pError)\n{\n    int r;\n    struct mailimap_capability_data * cap;\n    \n    connectIfNeeded(pError);\n    if (* pError != ErrorNone)\n        return NULL;\n    \n    r = mailimap_capability(mImap, &cap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return NULL;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return NULL;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCapability;\n        return NULL;\n    }\n    \n    mailimap_capability_data_free(cap);\n    \n    IndexSet * result = new IndexSet();\n    capabilitySetWithSessionState(result);\n    \n    * pError = ErrorNone;\n    result->autorelease();\n    return result;\n}\n\nvoid IMAPSession::capabilitySetWithSessionState(IndexSet * capabilities)\n{\n    if (mailimap_has_extension(mImap, (char *)\"STARTTLS\")) {\n        capabilities->addIndex(IMAPCapabilityStartTLS);\n    }\n    if (mailimap_has_authentication(mImap, (char *)\"PLAIN\")) {\n        capabilities->addIndex(IMAPCapabilityAuthPlain);\n    }\n    if (mailimap_has_authentication(mImap, (char *)\"LOGIN\")) {\n        capabilities->addIndex(IMAPCapabilityAuthLogin);\n    }\n    if (mailimap_has_idle(mImap)) {\n        capabilities->addIndex(IMAPCapabilityIdle);\n    }\n    if (mailimap_has_id(mImap)) {\n        capabilities->addIndex(IMAPCapabilityId);\n    }\n    if (mailimap_has_xlist(mImap)) {\n        capabilities->addIndex(IMAPCapabilityXList);\n    }\n    if (mailimap_has_extension(mImap, (char *) \"X-GM-EXT-1\")) {\n        // Disable use of XLIST if this is the Gmail IMAP server because it implements\n        // RFC 6154.\n        capabilities->addIndex(IMAPCapabilityGmail);\n    }\n    if (mailimap_has_condstore(mImap)) {\n        capabilities->addIndex(IMAPCapabilityCondstore);\n    }\n    if (mailimap_has_qresync(mImap)) {\n        capabilities->addIndex(IMAPCapabilityQResync);\n    }\n    if (mailimap_has_xoauth2(mImap)) {\n        capabilities->addIndex(IMAPCapabilityXOAuth2);\n    }\n    if (mailimap_has_namespace(mImap)) {\n        capabilities->addIndex(IMAPCapabilityNamespace);\n    }\n    if (mailimap_has_compress_deflate(mImap)) {\n        capabilities->addIndex(IMAPCapabilityCompressDeflate);\n    }\n    if (mailimap_has_extension(mImap, (char *)\"CHILDREN\")) {\n        capabilities->addIndex(IMAPCapabilityChildren);\n    }\n    if (mailimap_has_extension(mImap, (char *)\"MOVE\")) {\n        capabilities->addIndex(IMAPCapabilityMove);\n    }\n    if (mailimap_has_extension(mImap, (char *)\"XYMHIGHESTMODSEQ\")) {\n        capabilities->addIndex(IMAPCapabilityXYMHighestModseq);\n    }\n    applyCapabilities(capabilities);\n}\n\nIndexSet * IMAPSession::storedCapabilities() {\n    return (IndexSet *)MC_SAFE_COPY(mCurrentCapabilities);\n}\n\nvoid IMAPSession::applyCapabilities(IndexSet * capabilities)\n{\n    if (capabilities->containsIndex(IMAPCapabilityId)) {\n        mIdentityEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityXList)) {\n        mXListEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityGmail)) {\n        mXListEnabled = false;\n        mCondstoreEnabled = true;\n        mIsGmail = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityIdle)) {\n        LOCK();\n        mIdleEnabled = true;\n        UNLOCK();\n    }\n    if (capabilities->containsIndex(IMAPCapabilityCondstore)) {\n        mCondstoreEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityQResync)) {\n        mQResyncEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityXYMHighestModseq)) {\n        mXYMHighestModseqEnabled = true;\n    }\n    if (capabilities->containsIndex(IMAPCapabilityXOAuth2)) {\n        mXOauth2Enabled = true;\n    }\n    if (mHermesServer) {\n        // Hermes server improperly advertise a namespace capability.\n    }\n    else {\n        if (capabilities->containsIndex(IMAPCapabilityNamespace)) {\n            mNamespaceEnabled = true;\n        }\n    }\n    if (capabilities->containsIndex(IMAPCapabilityCompressDeflate)) {\n        mCompressionEnabled = true;\n    }\n}\n\nbool IMAPSession::isIdleEnabled()\n{\n    LOCK();\n    bool idleEnabled = mIdleEnabled;\n    UNLOCK();\n    return idleEnabled;\n}\n\nbool IMAPSession::isXListEnabled()\n{\n    return mXListEnabled;\n}\n\nbool IMAPSession::isCondstoreEnabled()\n{\n    return mCondstoreEnabled;\n}\n\nbool IMAPSession::isQResyncEnabled()\n{\n    return mQResyncEnabled;\n}\n\nbool IMAPSession::isIdentityEnabled()\n{\n    return mIdentityEnabled;\n}\n\nbool IMAPSession::isXOAuthEnabled()\n{\n    return mXOauth2Enabled;\n}\n\nbool IMAPSession::isNamespaceEnabled()\n{\n    return mNamespaceEnabled;\n}\n\nbool IMAPSession::isCompressionEnabled()\n{\n    return mCompressionEnabled;\n}\n\nbool IMAPSession::allowsNewPermanentFlags() {\n    return mAllowsNewPermanentFlags;\n}\n\nbool IMAPSession::isDisconnected()\n{\n    return mState == STATE_DISCONNECTED;\n}\n\nvoid IMAPSession::setConnectionLogger(ConnectionLogger * logger)\n{\n    lockConnectionLogger();\n    mConnectionLogger = logger;\n    unlockConnectionLogger();\n}\n\nConnectionLogger * IMAPSession::connectionLogger()\n{\n    ConnectionLogger * result;\n\n    lockConnectionLogger();\n    result = mConnectionLogger;\n    unlockConnectionLogger();\n\n    return result;\n}\n\nvoid IMAPSession::lockConnectionLogger()\n{\n    pthread_mutex_lock(&mConnectionLoggerLock);\n}\n\nvoid IMAPSession::unlockConnectionLogger()\n{\n    pthread_mutex_unlock(&mConnectionLoggerLock);\n}\n\nConnectionLogger * IMAPSession::connectionLoggerNoLock()\n{\n    return mConnectionLogger;\n}\n\nString * IMAPSession::htmlRendering(IMAPMessage * message, String * folder, ErrorCode * pError)\n{\n    HTMLRendererIMAPDataCallback * dataCallback = new HTMLRendererIMAPDataCallback(this, message->uid());\n    String * htmlString = HTMLRenderer::htmlForIMAPMessage(folder,\n                                                           message,\n                                                           dataCallback,\n                                                           NULL);\n    * pError = dataCallback->error();\n    \n    MC_SAFE_RELEASE(dataCallback);\n\n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    return htmlString;\n}\n\nString * IMAPSession::htmlBodyRendering(IMAPMessage * message, String * folder, ErrorCode * pError)\n{\n    MCAssert(folder != NULL);\n    HTMLRendererIMAPDataCallback * dataCallback = new HTMLRendererIMAPDataCallback(this, message->uid());\n    HTMLBodyRendererTemplateCallback * htmlCallback = new HTMLBodyRendererTemplateCallback();\n    \n    String * htmlBodyString = HTMLRenderer::htmlForIMAPMessage(folder,\n                                                               message,\n                                                               dataCallback,\n                                                               htmlCallback);\n\n    * pError = dataCallback->error();\n    \n    MC_SAFE_RELEASE(dataCallback);\n    MC_SAFE_RELEASE(htmlCallback);\n\n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    return htmlBodyString;\n}\n\nString * IMAPSession::plainTextRendering(IMAPMessage * message, String * folder, ErrorCode * pError)\n{\n    String * htmlString = htmlRendering(message, folder, pError);\n    \n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    String * plainTextString = htmlString->flattenHTML();\n    return plainTextString;\n}\n\nString * IMAPSession::plainTextBodyRendering(IMAPMessage * message, String * folder, bool stripWhitespace, ErrorCode * pError)\n{\n    MCAssert(folder != NULL);\n    String * htmlBodyString = htmlBodyRendering(message, folder, pError);\n    \n    if (* pError != ErrorNone) {\n        return NULL;\n    }\n    \n    String * plainTextBodyString = htmlBodyString->flattenHTML();\n    if (stripWhitespace) {\n        return plainTextBodyString->stripWhitespace();\n    }\n    \n    return plainTextBodyString;\n}\n\nvoid IMAPSession::setAutomaticConfigurationEnabled(bool enabled)\n{\n    mAutomaticConfigurationEnabled = enabled;\n}\n\nbool IMAPSession::isAutomaticConfigurationEnabled()\n{\n    return mAutomaticConfigurationEnabled;\n}\n\nbool IMAPSession::enableFeature(String * feature)\n{\n    struct mailimap_capability_data * caps;\n    clist * cap_list;\n    struct mailimap_capability * cap;\n    int r;\n    \n    cap_list = clist_new();\n    cap = mailimap_capability_new(MAILIMAP_CAPABILITY_NAME, NULL, strdup(MCUTF8(feature)));\n    clist_append(cap_list, cap);\n    caps = mailimap_capability_data_new(cap_list);\n    \n    struct mailimap_capability_data * result;\n    r = mailimap_enable(mImap, caps, &result);\n    mailimap_capability_data_free(caps);\n    if (r != MAILIMAP_NO_ERROR)\n        return false;\n    \n    mailimap_capability_data_free(result);\n    \n    return true;\n}\n\nvoid IMAPSession::enableFeatures()\n{\n    if (isCompressionEnabled()) {\n        ErrorCode error;\n        enableCompression(&error);\n        if (error != ErrorNone) {\n            MCLog(\"could not enable compression\");\n        }\n    }\n    \n    if (isQResyncEnabled()) {\n        enableFeature(MCSTR(\"QRESYNC\"));\n    }\n    else if (isCondstoreEnabled()) {\n        enableFeature(MCSTR(\"CONDSTORE\"));\n    }\n}\n\nvoid IMAPSession::enableCompression(ErrorCode * pError)\n{\n    int r;\n    r = mailimap_compress(mImap);\n    if (r == MAILIMAP_ERROR_STREAM) {\n        mShouldDisconnect = true;\n        * pError = ErrorConnection;\n        return;\n    }\n    else if (r == MAILIMAP_ERROR_PARSE) {\n        mShouldDisconnect = true;\n        * pError = ErrorParse;\n        return;\n    }\n    else if (hasError(r)) {\n        * pError = ErrorCompression;\n        return;\n    }\n    \n    * pError = ErrorNone;\n}\n\nbool IMAPSession::isAutomaticConfigurationDone()\n{\n    return mAutomaticConfigurationDone;\n}\n\nvoid IMAPSession::resetAutomaticConfigurationDone()\n{\n    mAutomaticConfigurationDone = false;\n}\n\nString * IMAPSession::gmailUserDisplayName()\n{\n    return mGmailUserDisplayName;\n}\n"], "filenames": ["src/core/imap/MCIMAPSession.cpp"], "buggy_code_start_loc": [684], "buggy_code_end_loc": [684], "fixing_code_start_loc": [685], "fixing_code_end_loc": [692], "type": "CWE-295", "message": "core/imap/MCIMAPSession.cpp in Canary Mail before 3.22 has Missing SSL Certificate Validation for IMAP in STARTTLS mode.", "other": {"cve": {"id": "CVE-2021-26911", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-17T21:15:12.900", "lastModified": "2021-02-24T20:07:14.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "core/imap/MCIMAPSession.cpp in Canary Mail before 3.22 has Missing SSL Certificate Validation for IMAP in STARTTLS mode."}, {"lang": "es", "value": "El archivo core/imap/MCIMAPSession.cpp en Canary Mail versiones anteriores a 3.22, tiene una Falta de Comprobaci\u00f3n de Certificado SSL para IMAP en modo STARTTLS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:canarymail:canary_mail:3.20:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "8A0F96F5-488B-485C-93D9-0DFE7DD732C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:canarymail:canary_mail:3.21:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "A3D232FE-4500-4FD5-B7B0-901134B488E2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmailcore:mailcore2:0.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "973E27F1-AE98-4C43-BE54-C4A453EEF046"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/02/17/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://apps.apple.com/us/app/canary-mail/id1236045954", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://census-labs.com/news/2021/02/17/canary-mail-app-missing-certificate-validation-check-on-imap-starttls/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://census-labs.com/news/category/advisories/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/canarymail/mailcore2/commit/45acb4efbcaa57a20ac5127dc976538671fce018", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/02/17/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/canarymail/mailcore2/commit/45acb4efbcaa57a20ac5127dc976538671fce018"}}