{"buggy_code": ["/*\n *  Copyright (C) 2012 Philip Van Hoof <philip@codeminded.be>\n *  Copyright (C) 2009 Vic Lee.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifndef _MSC_VER\n#define _XOPEN_SOURCE 500\n#endif\n\n#include <rfb/rfbclient.h>\n#include <errno.h>\n\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include <openssl/x509.h>\n#include <openssl/rand.h>\n#include <openssl/x509.h>\n\n#ifdef _MSC_VER\ntypedef CRITICAL_SECTION MUTEX_TYPE;\n#define MUTEX_INIT(mutex) InitializeCriticalSection(&mutex)\n#define MUTEX_FREE(mutex) DeleteCriticalSection(&mutex)\n#define MUTEX_LOCK(mutex) EnterCriticalSection(&mutex)\n#define MUTEX_UNLOCK(mutex) LeaveCriticalSection(&mutex)\n#define CURRENT_THREAD_ID GetCurrentThreadId()\n#else\n#include <pthread.h>\ntypedef pthread_mutex_t MUTEX_TYPE;\n#define MUTEX_INIT(mutex) {\\\n\tpthread_mutexattr_t mutexAttr;\\\n\tpthread_mutexattr_init(&mutexAttr);\\\n\tpthread_mutexattr_settype(&mutexAttr, PTHREAD_MUTEX_RECURSIVE);\\\n\tpthread_mutex_init(&mutex, &mutexAttr);\\\n}\n#define MUTEX_FREE(mutex) pthread_mutex_destroy(&mutex)\n#define MUTEX_LOCK(mutex) pthread_mutex_lock(&mutex)\n#define MUTEX_UNLOCK(mutex) pthread_mutex_unlock(&mutex)\n#define CURRENT_THREAD_ID pthread_self()\n#endif\n\n#include \"tls.h\"\n\n#ifdef _MSC_VER\n#include <BaseTsd.h> // That's for SSIZE_T\ntypedef SSIZE_T ssize_t;\n#define snprintf _snprintf\n#endif\n\nstatic rfbBool rfbTLSInitialized = FALSE;\nstatic MUTEX_TYPE *mutex_buf = NULL;\n\nstruct CRYPTO_dynlock_value {\n\tMUTEX_TYPE mutex;\n};\n\nstatic void locking_function(int mode, int n, const char *file, int line)\n{\n\tif (mode & CRYPTO_LOCK)\n\t\tMUTEX_LOCK(mutex_buf[n]);\n\telse\n\t\tMUTEX_UNLOCK(mutex_buf[n]);\n}\n\nstatic unsigned long id_function(void)\n{\n\treturn ((unsigned long) CURRENT_THREAD_ID);\n}\n\nstatic struct CRYPTO_dynlock_value *dyn_create_function(const char *file, int line)\n{\n\tstruct CRYPTO_dynlock_value *value;\n\n\tvalue = (struct CRYPTO_dynlock_value *)\n\t\tmalloc(sizeof(struct CRYPTO_dynlock_value));\n\tif (!value)\n\t\tgoto err;\n\tMUTEX_INIT(value->mutex);\n\n\treturn value;\n\nerr:\n\treturn (NULL);\n}\n\nstatic void dyn_lock_function (int mode, struct CRYPTO_dynlock_value *l, const char *file, int line)\n{\n\tif (mode & CRYPTO_LOCK)\n\t\tMUTEX_LOCK(l->mutex);\n\telse\n\t\tMUTEX_UNLOCK(l->mutex);\n}\n\n\nstatic void\ndyn_destroy_function(struct CRYPTO_dynlock_value *l, const char *file, int line)\n{\n\tMUTEX_FREE(l->mutex);\n\tfree(l);\n}\n\n\nstatic int\nssl_errno (SSL *ssl, int ret)\n{\n\tswitch (SSL_get_error (ssl, ret)) {\n\tcase SSL_ERROR_NONE:\n\t\treturn 0;\n\tcase SSL_ERROR_ZERO_RETURN:\n\t\t/* this one does not map well at all */\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_ZERO_RETURN\\n\"));\n\t\treturn EINVAL;\n\tcase SSL_ERROR_WANT_READ:   /* non-fatal; retry */\n\tcase SSL_ERROR_WANT_WRITE:  /* non-fatal; retry */\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_WANT_[READ,WRITE]\\n\"));\n\t\treturn EAGAIN;\n\tcase SSL_ERROR_SYSCALL:\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_SYSCALL\\n\"));\n\t\treturn EINTR;\n\tcase SSL_ERROR_SSL:\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_SSL  <-- very useful error...riiiiight\\n\"));\n\t\treturn EINTR;\n\tdefault:\n\t\t//d(printf (\"ssl_errno: default error\\n\"));\n\t\treturn EINTR;\n\t}\n}\n\nstatic rfbBool\nInitializeTLS(void)\n{\n  int i;\n\n  if (rfbTLSInitialized) return TRUE;\n\n  mutex_buf = malloc(CRYPTO_num_locks() * sizeof(MUTEX_TYPE));\n  if (mutex_buf == NULL) {\n    rfbClientLog(\"Failed to initialized OpenSSL: memory.\\n\");\n    return (-1);\n  }\n\n  for (i = 0; i < CRYPTO_num_locks(); i++)\n    MUTEX_INIT(mutex_buf[i]);\n\n  CRYPTO_set_locking_callback(locking_function);\n  CRYPTO_set_id_callback(id_function);\n  CRYPTO_set_dynlock_create_callback(dyn_create_function);\n  CRYPTO_set_dynlock_lock_callback(dyn_lock_function);\n  CRYPTO_set_dynlock_destroy_callback(dyn_destroy_function);\n  SSL_load_error_strings();\n  SSLeay_add_ssl_algorithms();\n  RAND_load_file(\"/dev/urandom\", 1024);\n\n  rfbClientLog(\"OpenSSL version %s initialized.\\n\", SSLeay_version(SSLEAY_VERSION));\n  rfbTLSInitialized = TRUE;\n  return TRUE;\n}\n\nstatic int sock_read_ready(SSL *ssl, uint32_t ms)\n{\n\tint r = 0;\n\tfd_set fds;\n\tstruct timeval tv;\n\n\tFD_ZERO(&fds);\n\n\tFD_SET(SSL_get_fd(ssl), &fds);\n\n\ttv.tv_sec = ms / 1000;\n\ttv.tv_usec = (ms % 1000) * 1000;\n\t\n\tr = select (SSL_get_fd(ssl) + 1, &fds, NULL, NULL, &tv); \n\n\treturn r;\n}\n\nstatic int wait_for_data(SSL *ssl, int ret, int timeout)\n{\n  int err;\n  int retval = 1;\n\n  err = SSL_get_error(ssl, ret);\n\t\n  switch(err)\n  {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      ret = sock_read_ready(ssl, timeout*1000);\n\t\t\t\n      if (ret == -1) {\n        retval = 2;\n      }\n\t\t\t\t\n      break;\n    default:\n      retval = 3;\n      long verify_res = SSL_get_verify_result(ssl);\n      if (verify_res != X509_V_OK)\n        rfbClientLog(\"Could not verify server certificate: %s.\\n\",\n                     X509_verify_cert_error_string(verify_res));\n      break;\n   }\n\t\n  ERR_clear_error();\n\t\t\t\t\n  return retval;\n}\n\nstatic rfbBool\nload_crls_from_file(char *file, SSL_CTX *ssl_ctx)\n{\n  X509_STORE *st;\n  X509_CRL *crl;\n  int i;\n  int count = 0;\n  BIO *bio;\n  STACK_OF(X509_INFO) *xis = NULL;\n  X509_INFO *xi;\n\n  st = SSL_CTX_get_cert_store(ssl_ctx);\n\n    int rv = 0;\n\n  bio = BIO_new_file(file, \"r\");\n  if (bio == NULL)\n    return FALSE;\n\n  xis = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);\n  BIO_free(bio);\n\n  for (i = 0; i < sk_X509_INFO_num(xis); i++)\n  {\n    xi = sk_X509_INFO_value(xis, i);\n    if (xi->crl)\n    {\n      X509_STORE_add_crl(st, xi->crl);\n      xi->crl = NULL;\n      count++;\n    }\n  }\n\n  sk_X509_INFO_pop_free(xis, X509_INFO_free);\n\n  if (count > 0)\n    return TRUE;\n  else\n    return FALSE;\n}\n\nstatic SSL *\nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}\n\n\nstatic rfbBool\nInitializeTLSSession(rfbClient* client, rfbBool anonTLS, rfbCredential *cred)\n{\n  if (client->tlsSession) return TRUE;\n\n  client->tlsSession = open_ssl_connection (client, client->sock, anonTLS, cred);\n\n  if (!client->tlsSession)\n    return FALSE;\n\n  rfbClientLog(\"TLS session initialized.\\n\");\n\n  return TRUE;\n}\n\nstatic rfbBool\nHandshakeTLS(rfbClient* client)\n{\n  int timeout = 15;\n  int ret;\n\nreturn TRUE;\n\n  while (timeout > 0 && (ret = SSL_do_handshake(client->tlsSession)) < 0)\n  {\n    if (ret != -1)\n    {\n      rfbClientLog(\"TLS handshake blocking.\\n\");\n#ifdef WIN32\n      Sleep(1000);\n#else\n\t  sleep(1);\n#endif\n      timeout--;\n      continue;\n    }\n    rfbClientLog(\"TLS handshake failed.\\n\");\n\n    FreeTLS(client);\n    return FALSE;\n  }\n\n  if (timeout <= 0)\n  {\n    rfbClientLog(\"TLS handshake timeout.\\n\");\n    FreeTLS(client);\n    return FALSE;\n  }\n\n  rfbClientLog(\"TLS handshake done.\\n\");\n  return TRUE;\n}\n\n/* VeNCrypt sub auth. 1 byte auth count, followed by count * 4 byte integers */\nstatic rfbBool\nReadVeNCryptSecurityType(rfbClient* client, uint32_t *result)\n{\n    uint8_t count=0;\n    uint8_t loop=0;\n    uint8_t flag=0;\n    uint32_t tAuth[256], t;\n    char buf1[500],buf2[10];\n    uint32_t authScheme;\n\n    if (!ReadFromRFBServer(client, (char *)&count, 1)) return FALSE;\n\n    if (count==0)\n    {\n        rfbClientLog(\"List of security types is ZERO. Giving up.\\n\");\n        return FALSE;\n    }\n\n    rfbClientLog(\"We have %d security types to read\\n\", count);\n    authScheme=0;\n    /* now, we have a list of available security types to read ( uint8_t[] ) */\n    for (loop=0;loop<count;loop++)\n    {\n        if (!ReadFromRFBServer(client, (char *)&tAuth[loop], 4)) return FALSE;\n        t=rfbClientSwap32IfLE(tAuth[loop]);\n        rfbClientLog(\"%d) Received security type %d\\n\", loop, t);\n        if (flag) continue;\n        if (t==rfbVeNCryptTLSNone ||\n            t==rfbVeNCryptTLSVNC ||\n            t==rfbVeNCryptTLSPlain ||\n#ifdef LIBVNCSERVER_HAVE_SASL\n            t==rfbVeNCryptTLSSASL ||\n            t==rfbVeNCryptX509SASL ||\n#endif /*LIBVNCSERVER_HAVE_SASL */\n            t==rfbVeNCryptX509None ||\n            t==rfbVeNCryptX509VNC ||\n            t==rfbVeNCryptX509Plain)\n        {\n            flag++;\n            authScheme=t;\n            rfbClientLog(\"Selecting security type %d (%d/%d in the list)\\n\", authScheme, loop, count);\n            /* send back 4 bytes (in original byte order!) indicating which security type to use */\n            if (!WriteToRFBServer(client, (char *)&tAuth[loop], 4)) return FALSE;\n        }\n        tAuth[loop]=t;\n    }\n    if (authScheme==0)\n    {\n        memset(buf1, 0, sizeof(buf1));\n        for (loop=0;loop<count;loop++)\n        {\n            if (strlen(buf1)>=sizeof(buf1)-1) break;\n            snprintf(buf2, sizeof(buf2), (loop>0 ? \", %d\" : \"%d\"), (int)tAuth[loop]);\n            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);\n        }\n        rfbClientLog(\"Unknown VeNCrypt authentication scheme from VNC server: %s\\n\",\n               buf1);\n        return FALSE;\n    }\n    *result = authScheme;\n    return TRUE;\n}\n\nrfbBool\nHandleAnonTLSAuth(rfbClient* client)\n{\n  if (!InitializeTLS() || !InitializeTLSSession(client, TRUE, NULL)) return FALSE;\n\n  if (!HandshakeTLS(client)) return FALSE;\n\n  return TRUE;\n}\n\nstatic void\nFreeX509Credential(rfbCredential *cred)\n{\n  if (cred->x509Credential.x509CACertFile) free(cred->x509Credential.x509CACertFile);\n  if (cred->x509Credential.x509CACrlFile) free(cred->x509Credential.x509CACrlFile);\n  if (cred->x509Credential.x509ClientCertFile) free(cred->x509Credential.x509ClientCertFile);\n  if (cred->x509Credential.x509ClientKeyFile) free(cred->x509Credential.x509ClientKeyFile);\n  free(cred);\n}\n\nrfbBool\nHandleVeNCryptAuth(rfbClient* client)\n{\n  uint8_t major, minor, status;\n  uint32_t authScheme;\n  rfbBool anonTLS;\n  rfbCredential *cred = NULL;\n  rfbBool result = TRUE;\n\n  if (!InitializeTLS()) return FALSE;\n\n  /* Read VeNCrypt version */\n  if (!ReadFromRFBServer(client, (char *)&major, 1) ||\n      !ReadFromRFBServer(client, (char *)&minor, 1))\n  {\n    return FALSE;\n  }\n  rfbClientLog(\"Got VeNCrypt version %d.%d from server.\\n\", (int)major, (int)minor);\n\n  if (major != 0 && minor != 2)\n  {\n    rfbClientLog(\"Unsupported VeNCrypt version.\\n\");\n    return FALSE;\n  }\n\n  if (!WriteToRFBServer(client, (char *)&major, 1) ||\n      !WriteToRFBServer(client, (char *)&minor, 1) ||\n      !ReadFromRFBServer(client, (char *)&status, 1))\n  {\n    return FALSE;\n  }\n\n  if (status != 0)\n  {\n    rfbClientLog(\"Server refused VeNCrypt version %d.%d.\\n\", (int)major, (int)minor);\n    return FALSE;\n  }\n\n  if (!ReadVeNCryptSecurityType(client, &authScheme)) return FALSE;\n  if (!ReadFromRFBServer(client, (char *)&status, 1) || status != 1)\n  {\n    rfbClientLog(\"Server refused VeNCrypt authentication %d (%d).\\n\", authScheme, (int)status);\n    return FALSE;\n  }\n  client->subAuthScheme = authScheme;\n\n  /* Some VeNCrypt security types are anonymous TLS, others are X509 */\n  switch (authScheme)\n  {\n    case rfbVeNCryptTLSNone:\n    case rfbVeNCryptTLSVNC:\n    case rfbVeNCryptTLSPlain:\n#ifdef LIBVNCSERVER_HAVE_SASL\n    case rfbVeNCryptTLSSASL:\n#endif /* LIBVNCSERVER_HAVE_SASL */\n      anonTLS = TRUE;\n      break;\n    default:\n      anonTLS = FALSE;\n      break;\n  }\n\n  /* Get X509 Credentials if it's not anonymous */\n  if (!anonTLS)\n  {\n\n    if (!client->GetCredential)\n    {\n      rfbClientLog(\"GetCredential callback is not set.\\n\");\n      return FALSE;\n    }\n    cred = client->GetCredential(client, rfbCredentialTypeX509);\n    if (!cred)\n    {\n      rfbClientLog(\"Reading credential failed\\n\");\n      return FALSE;\n    }\n  }\n\n  /* Start up the TLS session */\n  if (!InitializeTLSSession(client, anonTLS, cred)) result = FALSE;\n\n  if (!HandshakeTLS(client)) result = FALSE;\n\n  /* We are done here. The caller should continue with client->subAuthScheme\n   * to do actual sub authentication.\n   */\n  if (cred) FreeX509Credential(cred);\n  return result;\n}\n\nint\nReadFromTLS(rfbClient* client, char *out, unsigned int n)\n{\n  ssize_t ret;\n\n  ret = SSL_read (client->tlsSession, out, n);\n\n  if (ret >= 0)\n    return ret;\n  else {\n    errno = ssl_errno (client->tlsSession, ret);\n\n    if (errno != EAGAIN) {\n      rfbClientLog(\"Error reading from TLS: -.\\n\");\n    }\n  }\n\n  return -1;\n}\n\nint\nWriteToTLS(rfbClient* client, const char *buf, unsigned int n)\n{\n  unsigned int offset = 0;\n  ssize_t ret;\n\n  while (offset < n)\n  {\n\n    ret = SSL_write (client->tlsSession, buf + offset, (size_t)(n-offset));\n\n    if (ret < 0)\n      errno = ssl_errno (client->tlsSession, ret);\n\n    if (ret == 0) continue;\n    if (ret < 0)\n    {\n      if (errno == EAGAIN || errno == EWOULDBLOCK) continue;\n      rfbClientLog(\"Error writing to TLS: -\\n\");\n      return -1;\n    }\n    offset += (unsigned int)ret;\n  }\n  return offset;\n}\n\nvoid FreeTLS(rfbClient* client)\n{\n  int i;\n\n  if (mutex_buf != NULL) {\n    CRYPTO_set_dynlock_create_callback(NULL);\n    CRYPTO_set_dynlock_lock_callback(NULL);\n    CRYPTO_set_dynlock_destroy_callback(NULL);\n\n    CRYPTO_set_locking_callback(NULL);\n    CRYPTO_set_id_callback(NULL);\n\n    for (i = 0; i < CRYPTO_num_locks(); i++)\n      MUTEX_FREE(mutex_buf[i]);\n    free(mutex_buf);\n    mutex_buf = NULL;\n  }\n\n  SSL_free(client->tlsSession);\n}\n\n#ifdef LIBVNCSERVER_HAVE_SASL\nint GetTLSCipherBits(rfbClient* client)\n{\n    SSL *ssl = (SSL *)(client->tlsSession);\n\n    const SSL_CIPHER *cipher = SSL_get_current_cipher(ssl);\n\n    return SSL_CIPHER_get_bits(cipher, NULL);\n}\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n"], "fixing_code": ["/*\n *  Copyright (C) 2012 Philip Van Hoof <philip@codeminded.be>\n *  Copyright (C) 2009 Vic Lee.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifndef _MSC_VER\n#define _XOPEN_SOURCE 500\n#endif\n\n#include <rfb/rfbclient.h>\n#include <errno.h>\n\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include <openssl/x509.h>\n#include <openssl/rand.h>\n#include <openssl/x509.h>\n\n#ifdef _MSC_VER\ntypedef CRITICAL_SECTION MUTEX_TYPE;\n#define MUTEX_INIT(mutex) InitializeCriticalSection(&mutex)\n#define MUTEX_FREE(mutex) DeleteCriticalSection(&mutex)\n#define MUTEX_LOCK(mutex) EnterCriticalSection(&mutex)\n#define MUTEX_UNLOCK(mutex) LeaveCriticalSection(&mutex)\n#define CURRENT_THREAD_ID GetCurrentThreadId()\n#else\n#include <pthread.h>\ntypedef pthread_mutex_t MUTEX_TYPE;\n#define MUTEX_INIT(mutex) {\\\n\tpthread_mutexattr_t mutexAttr;\\\n\tpthread_mutexattr_init(&mutexAttr);\\\n\tpthread_mutexattr_settype(&mutexAttr, PTHREAD_MUTEX_RECURSIVE);\\\n\tpthread_mutex_init(&mutex, &mutexAttr);\\\n}\n#define MUTEX_FREE(mutex) pthread_mutex_destroy(&mutex)\n#define MUTEX_LOCK(mutex) pthread_mutex_lock(&mutex)\n#define MUTEX_UNLOCK(mutex) pthread_mutex_unlock(&mutex)\n#define CURRENT_THREAD_ID pthread_self()\n#endif\n\n#include \"tls.h\"\n\n#ifdef _MSC_VER\n#include <BaseTsd.h> // That's for SSIZE_T\ntypedef SSIZE_T ssize_t;\n#define snprintf _snprintf\n#endif\n\nstatic rfbBool rfbTLSInitialized = FALSE;\nstatic MUTEX_TYPE *mutex_buf = NULL;\n\nstruct CRYPTO_dynlock_value {\n\tMUTEX_TYPE mutex;\n};\n\nstatic void locking_function(int mode, int n, const char *file, int line)\n{\n\tif (mode & CRYPTO_LOCK)\n\t\tMUTEX_LOCK(mutex_buf[n]);\n\telse\n\t\tMUTEX_UNLOCK(mutex_buf[n]);\n}\n\nstatic unsigned long id_function(void)\n{\n\treturn ((unsigned long) CURRENT_THREAD_ID);\n}\n\nstatic struct CRYPTO_dynlock_value *dyn_create_function(const char *file, int line)\n{\n\tstruct CRYPTO_dynlock_value *value;\n\n\tvalue = (struct CRYPTO_dynlock_value *)\n\t\tmalloc(sizeof(struct CRYPTO_dynlock_value));\n\tif (!value)\n\t\tgoto err;\n\tMUTEX_INIT(value->mutex);\n\n\treturn value;\n\nerr:\n\treturn (NULL);\n}\n\nstatic void dyn_lock_function (int mode, struct CRYPTO_dynlock_value *l, const char *file, int line)\n{\n\tif (mode & CRYPTO_LOCK)\n\t\tMUTEX_LOCK(l->mutex);\n\telse\n\t\tMUTEX_UNLOCK(l->mutex);\n}\n\n\nstatic void\ndyn_destroy_function(struct CRYPTO_dynlock_value *l, const char *file, int line)\n{\n\tMUTEX_FREE(l->mutex);\n\tfree(l);\n}\n\n\nstatic int\nssl_errno (SSL *ssl, int ret)\n{\n\tswitch (SSL_get_error (ssl, ret)) {\n\tcase SSL_ERROR_NONE:\n\t\treturn 0;\n\tcase SSL_ERROR_ZERO_RETURN:\n\t\t/* this one does not map well at all */\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_ZERO_RETURN\\n\"));\n\t\treturn EINVAL;\n\tcase SSL_ERROR_WANT_READ:   /* non-fatal; retry */\n\tcase SSL_ERROR_WANT_WRITE:  /* non-fatal; retry */\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_WANT_[READ,WRITE]\\n\"));\n\t\treturn EAGAIN;\n\tcase SSL_ERROR_SYSCALL:\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_SYSCALL\\n\"));\n\t\treturn EINTR;\n\tcase SSL_ERROR_SSL:\n\t\t//d(printf (\"ssl_errno: SSL_ERROR_SSL  <-- very useful error...riiiiight\\n\"));\n\t\treturn EINTR;\n\tdefault:\n\t\t//d(printf (\"ssl_errno: default error\\n\"));\n\t\treturn EINTR;\n\t}\n}\n\nstatic rfbBool\nInitializeTLS(void)\n{\n  int i;\n\n  if (rfbTLSInitialized) return TRUE;\n\n  mutex_buf = malloc(CRYPTO_num_locks() * sizeof(MUTEX_TYPE));\n  if (mutex_buf == NULL) {\n    rfbClientLog(\"Failed to initialized OpenSSL: memory.\\n\");\n    return (-1);\n  }\n\n  for (i = 0; i < CRYPTO_num_locks(); i++)\n    MUTEX_INIT(mutex_buf[i]);\n\n  CRYPTO_set_locking_callback(locking_function);\n  CRYPTO_set_id_callback(id_function);\n  CRYPTO_set_dynlock_create_callback(dyn_create_function);\n  CRYPTO_set_dynlock_lock_callback(dyn_lock_function);\n  CRYPTO_set_dynlock_destroy_callback(dyn_destroy_function);\n  SSL_load_error_strings();\n  SSLeay_add_ssl_algorithms();\n  RAND_load_file(\"/dev/urandom\", 1024);\n\n  rfbClientLog(\"OpenSSL version %s initialized.\\n\", SSLeay_version(SSLEAY_VERSION));\n  rfbTLSInitialized = TRUE;\n  return TRUE;\n}\n\nstatic int sock_read_ready(SSL *ssl, uint32_t ms)\n{\n\tint r = 0;\n\tfd_set fds;\n\tstruct timeval tv;\n\n\tFD_ZERO(&fds);\n\n\tFD_SET(SSL_get_fd(ssl), &fds);\n\n\ttv.tv_sec = ms / 1000;\n\ttv.tv_usec = (ms % 1000) * 1000;\n\t\n\tr = select (SSL_get_fd(ssl) + 1, &fds, NULL, NULL, &tv); \n\n\treturn r;\n}\n\nstatic int wait_for_data(SSL *ssl, int ret, int timeout)\n{\n  int err;\n  int retval = 1;\n\n  err = SSL_get_error(ssl, ret);\n\t\n  switch(err)\n  {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      ret = sock_read_ready(ssl, timeout*1000);\n\t\t\t\n      if (ret == -1) {\n        retval = 2;\n      }\n\t\t\t\t\n      break;\n    default:\n      retval = 3;\n      long verify_res = SSL_get_verify_result(ssl);\n      if (verify_res != X509_V_OK)\n        rfbClientLog(\"Could not verify server certificate: %s.\\n\",\n                     X509_verify_cert_error_string(verify_res));\n      break;\n   }\n\t\n  ERR_clear_error();\n\t\t\t\t\n  return retval;\n}\n\nstatic rfbBool\nload_crls_from_file(char *file, SSL_CTX *ssl_ctx)\n{\n  X509_STORE *st;\n  X509_CRL *crl;\n  int i;\n  int count = 0;\n  BIO *bio;\n  STACK_OF(X509_INFO) *xis = NULL;\n  X509_INFO *xi;\n\n  st = SSL_CTX_get_cert_store(ssl_ctx);\n\n    int rv = 0;\n\n  bio = BIO_new_file(file, \"r\");\n  if (bio == NULL)\n    return FALSE;\n\n  xis = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);\n  BIO_free(bio);\n\n  for (i = 0; i < sk_X509_INFO_num(xis); i++)\n  {\n    xi = sk_X509_INFO_value(xis, i);\n    if (xi->crl)\n    {\n      X509_STORE_add_crl(st, xi->crl);\n      xi->crl = NULL;\n      count++;\n    }\n  }\n\n  sk_X509_INFO_pop_free(xis, X509_INFO_free);\n\n  if (count > 0)\n    return TRUE;\n  else\n    return FALSE;\n}\n\nstatic SSL *\nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}\n\n\nstatic rfbBool\nInitializeTLSSession(rfbClient* client, rfbBool anonTLS, rfbCredential *cred)\n{\n  if (client->tlsSession) return TRUE;\n\n  client->tlsSession = open_ssl_connection (client, client->sock, anonTLS, cred);\n\n  if (!client->tlsSession)\n    return FALSE;\n\n  rfbClientLog(\"TLS session initialized.\\n\");\n\n  return TRUE;\n}\n\nstatic rfbBool\nHandshakeTLS(rfbClient* client)\n{\n  int timeout = 15;\n  int ret;\n\nreturn TRUE;\n\n  while (timeout > 0 && (ret = SSL_do_handshake(client->tlsSession)) < 0)\n  {\n    if (ret != -1)\n    {\n      rfbClientLog(\"TLS handshake blocking.\\n\");\n#ifdef WIN32\n      Sleep(1000);\n#else\n\t  sleep(1);\n#endif\n      timeout--;\n      continue;\n    }\n    rfbClientLog(\"TLS handshake failed.\\n\");\n\n    FreeTLS(client);\n    return FALSE;\n  }\n\n  if (timeout <= 0)\n  {\n    rfbClientLog(\"TLS handshake timeout.\\n\");\n    FreeTLS(client);\n    return FALSE;\n  }\n\n  rfbClientLog(\"TLS handshake done.\\n\");\n  return TRUE;\n}\n\n/* VeNCrypt sub auth. 1 byte auth count, followed by count * 4 byte integers */\nstatic rfbBool\nReadVeNCryptSecurityType(rfbClient* client, uint32_t *result)\n{\n    uint8_t count=0;\n    uint8_t loop=0;\n    uint8_t flag=0;\n    uint32_t tAuth[256], t;\n    char buf1[500],buf2[10];\n    uint32_t authScheme;\n\n    if (!ReadFromRFBServer(client, (char *)&count, 1)) return FALSE;\n\n    if (count==0)\n    {\n        rfbClientLog(\"List of security types is ZERO. Giving up.\\n\");\n        return FALSE;\n    }\n\n    rfbClientLog(\"We have %d security types to read\\n\", count);\n    authScheme=0;\n    /* now, we have a list of available security types to read ( uint8_t[] ) */\n    for (loop=0;loop<count;loop++)\n    {\n        if (!ReadFromRFBServer(client, (char *)&tAuth[loop], 4)) return FALSE;\n        t=rfbClientSwap32IfLE(tAuth[loop]);\n        rfbClientLog(\"%d) Received security type %d\\n\", loop, t);\n        if (flag) continue;\n        if (t==rfbVeNCryptTLSNone ||\n            t==rfbVeNCryptTLSVNC ||\n            t==rfbVeNCryptTLSPlain ||\n#ifdef LIBVNCSERVER_HAVE_SASL\n            t==rfbVeNCryptTLSSASL ||\n            t==rfbVeNCryptX509SASL ||\n#endif /*LIBVNCSERVER_HAVE_SASL */\n            t==rfbVeNCryptX509None ||\n            t==rfbVeNCryptX509VNC ||\n            t==rfbVeNCryptX509Plain)\n        {\n            flag++;\n            authScheme=t;\n            rfbClientLog(\"Selecting security type %d (%d/%d in the list)\\n\", authScheme, loop, count);\n            /* send back 4 bytes (in original byte order!) indicating which security type to use */\n            if (!WriteToRFBServer(client, (char *)&tAuth[loop], 4)) return FALSE;\n        }\n        tAuth[loop]=t;\n    }\n    if (authScheme==0)\n    {\n        memset(buf1, 0, sizeof(buf1));\n        for (loop=0;loop<count;loop++)\n        {\n            if (strlen(buf1)>=sizeof(buf1)-1) break;\n            snprintf(buf2, sizeof(buf2), (loop>0 ? \", %d\" : \"%d\"), (int)tAuth[loop]);\n            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);\n        }\n        rfbClientLog(\"Unknown VeNCrypt authentication scheme from VNC server: %s\\n\",\n               buf1);\n        return FALSE;\n    }\n    *result = authScheme;\n    return TRUE;\n}\n\nrfbBool\nHandleAnonTLSAuth(rfbClient* client)\n{\n  if (!InitializeTLS() || !InitializeTLSSession(client, TRUE, NULL)) return FALSE;\n\n  if (!HandshakeTLS(client)) return FALSE;\n\n  return TRUE;\n}\n\nstatic void\nFreeX509Credential(rfbCredential *cred)\n{\n  if (cred->x509Credential.x509CACertFile) free(cred->x509Credential.x509CACertFile);\n  if (cred->x509Credential.x509CACrlFile) free(cred->x509Credential.x509CACrlFile);\n  if (cred->x509Credential.x509ClientCertFile) free(cred->x509Credential.x509ClientCertFile);\n  if (cred->x509Credential.x509ClientKeyFile) free(cred->x509Credential.x509ClientKeyFile);\n  free(cred);\n}\n\nrfbBool\nHandleVeNCryptAuth(rfbClient* client)\n{\n  uint8_t major, minor, status;\n  uint32_t authScheme;\n  rfbBool anonTLS;\n  rfbCredential *cred = NULL;\n  rfbBool result = TRUE;\n\n  if (!InitializeTLS()) return FALSE;\n\n  /* Read VeNCrypt version */\n  if (!ReadFromRFBServer(client, (char *)&major, 1) ||\n      !ReadFromRFBServer(client, (char *)&minor, 1))\n  {\n    return FALSE;\n  }\n  rfbClientLog(\"Got VeNCrypt version %d.%d from server.\\n\", (int)major, (int)minor);\n\n  if (major != 0 && minor != 2)\n  {\n    rfbClientLog(\"Unsupported VeNCrypt version.\\n\");\n    return FALSE;\n  }\n\n  if (!WriteToRFBServer(client, (char *)&major, 1) ||\n      !WriteToRFBServer(client, (char *)&minor, 1) ||\n      !ReadFromRFBServer(client, (char *)&status, 1))\n  {\n    return FALSE;\n  }\n\n  if (status != 0)\n  {\n    rfbClientLog(\"Server refused VeNCrypt version %d.%d.\\n\", (int)major, (int)minor);\n    return FALSE;\n  }\n\n  if (!ReadVeNCryptSecurityType(client, &authScheme)) return FALSE;\n  if (!ReadFromRFBServer(client, (char *)&status, 1) || status != 1)\n  {\n    rfbClientLog(\"Server refused VeNCrypt authentication %d (%d).\\n\", authScheme, (int)status);\n    return FALSE;\n  }\n  client->subAuthScheme = authScheme;\n\n  /* Some VeNCrypt security types are anonymous TLS, others are X509 */\n  switch (authScheme)\n  {\n    case rfbVeNCryptTLSNone:\n    case rfbVeNCryptTLSVNC:\n    case rfbVeNCryptTLSPlain:\n#ifdef LIBVNCSERVER_HAVE_SASL\n    case rfbVeNCryptTLSSASL:\n#endif /* LIBVNCSERVER_HAVE_SASL */\n      anonTLS = TRUE;\n      break;\n    default:\n      anonTLS = FALSE;\n      break;\n  }\n\n  /* Get X509 Credentials if it's not anonymous */\n  if (!anonTLS)\n  {\n\n    if (!client->GetCredential)\n    {\n      rfbClientLog(\"GetCredential callback is not set.\\n\");\n      return FALSE;\n    }\n    cred = client->GetCredential(client, rfbCredentialTypeX509);\n    if (!cred)\n    {\n      rfbClientLog(\"Reading credential failed\\n\");\n      return FALSE;\n    }\n  }\n\n  /* Start up the TLS session */\n  if (!InitializeTLSSession(client, anonTLS, cred)) result = FALSE;\n\n  if (!HandshakeTLS(client)) result = FALSE;\n\n  /* We are done here. The caller should continue with client->subAuthScheme\n   * to do actual sub authentication.\n   */\n  if (cred) FreeX509Credential(cred);\n  return result;\n}\n\nint\nReadFromTLS(rfbClient* client, char *out, unsigned int n)\n{\n  ssize_t ret;\n\n  ret = SSL_read (client->tlsSession, out, n);\n\n  if (ret >= 0)\n    return ret;\n  else {\n    errno = ssl_errno (client->tlsSession, ret);\n\n    if (errno != EAGAIN) {\n      rfbClientLog(\"Error reading from TLS: -.\\n\");\n    }\n  }\n\n  return -1;\n}\n\nint\nWriteToTLS(rfbClient* client, const char *buf, unsigned int n)\n{\n  unsigned int offset = 0;\n  ssize_t ret;\n\n  while (offset < n)\n  {\n\n    ret = SSL_write (client->tlsSession, buf + offset, (size_t)(n-offset));\n\n    if (ret < 0)\n      errno = ssl_errno (client->tlsSession, ret);\n\n    if (ret == 0) continue;\n    if (ret < 0)\n    {\n      if (errno == EAGAIN || errno == EWOULDBLOCK) continue;\n      rfbClientLog(\"Error writing to TLS: -\\n\");\n      return -1;\n    }\n    offset += (unsigned int)ret;\n  }\n  return offset;\n}\n\nvoid FreeTLS(rfbClient* client)\n{\n  int i;\n\n  if (mutex_buf != NULL) {\n    CRYPTO_set_dynlock_create_callback(NULL);\n    CRYPTO_set_dynlock_lock_callback(NULL);\n    CRYPTO_set_dynlock_destroy_callback(NULL);\n\n    CRYPTO_set_locking_callback(NULL);\n    CRYPTO_set_id_callback(NULL);\n\n    for (i = 0; i < CRYPTO_num_locks(); i++)\n      MUTEX_FREE(mutex_buf[i]);\n    free(mutex_buf);\n    mutex_buf = NULL;\n  }\n\n  SSL_free(client->tlsSession);\n}\n\n#ifdef LIBVNCSERVER_HAVE_SASL\nint GetTLSCipherBits(rfbClient* client)\n{\n    SSL *ssl = (SSL *)(client->tlsSession);\n\n    const SSL_CIPHER *cipher = SSL_get_current_cipher(ssl);\n\n    return SSL_CIPHER_get_bits(cipher, NULL);\n}\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n"], "filenames": ["libvncclient/tls_openssl.c"], "buggy_code_start_loc": [271], "buggy_code_end_loc": [283], "fixing_code_start_loc": [271], "fixing_code_end_loc": [285], "type": "CWE-476", "message": "An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference.", "other": {"cve": {"id": "CVE-2020-14396", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:11.697", "lastModified": "2022-03-10T15:15:04.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference."}, {"lang": "es", "value": "Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. La biblioteca libvncclient/tls_openssl.c presenta una desreferencia del puntero NULL"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.12", "matchCriteriaId": "A03A7282-D445-4E26-98A0-6A1597838D35"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/33441d90a506d5f3ae9388f2752901227e430553", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/33441d90a506d5f3ae9388f2752901227e430553"}}