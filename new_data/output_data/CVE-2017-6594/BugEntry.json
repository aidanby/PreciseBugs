{"buggy_code": ["Release Notes - Heimdal - Version Heimdal 7.2\n\n Bug fixes\n - Portability improvements\n - More strict parsing of encoded URI components in HTTP KDC\n - Fixed memory leak in malloc error recovery in NTLM GSSAPI mechanism\n - Avoid overly specific CPU info in krb5-config in aid of reproducible builds\n - Don't do AFS string-to-key tests when feature is disabled\n - Skip mdb_stat test when the command is not available\n - Windows: update SHA2 timestamp server\n - hdb: add missing export hdb_generate_key_set_password_with_ks_tuple\n - Fix signature of hdb_generate_key_set_password()\n - Windows: enable KX509 support in the KDC\n - kdc: fix kx509 service principal match\n - iprop: handle case where master sends nothing new\n - ipropd-slave: fix incorrect error codes\n - Allow choice of sqlite for HDB pref\n - check-iprop: don't fail to kill daemons\n - roken: pidfile -> rk_pidfile\n - kdc: _kdc_do_kx509 fix use after free error\n - Do not detect x32 as 64-bit platform.\n - No sys/ttydefaults.h on CYGWIN\n - Fix check-iprop races\n - roken_detach_prep() close pipe\n\nRelease Notes - Heimdal - Version Heimdal 7.1\n\n Security\n\n - kx509 realm-chopping security bug\n - non-authorization of alias additions/removals in kadmind\n   (CVE-2016-2400)\n\n Feature\n\n - iprop has been revamped to fix a number of race conditions that could\n   lead to inconsistent replication\n - Hierarchical capath support\n - AES Encryption with HMAC-SHA2 for Kerberos 5\n   draft-ietf-kitten-aes-cts-hmac-sha2-11\n - hcrypto is now thread safe on all platforms\n - libhcrypto has new backends: CNG (Windows), PKCS#11 (mainly for\n   Solaris), and OpenSSL.  OpenSSL is now a first-class libhcrypto backend.\n   OpenSSL 1.0.x and 1.1 are both supported. AES-NI used when supported by\n   backend\n - HDB now supports LMDB\n - Thread support on Windows\n - RFC 6113  Generalized Framework for Kerberos Pre-Authentication (FAST)\n - New GSS APIs:\n   . gss_localname\n - Allow setting what encryption types a principal should have with\n   [kadmin] default_key_rules, see krb5.conf manpage for more info\n - Unify libhcrypto with LTC (libtomcrypto)\n - asn1_compile 64-bit INTEGER functionality\n - HDB key history support including --keepold kadmin password option\n - Improved cross-realm key rollover safety\n - New krb5_kuserok() and krb5_aname_to_localname() plug-in interfaces\n - Improved MIT compatibility\n   . kadm5 API\n   . Migration from MIT KDB via \"mitdb\" HDB backend\n   . Capable of writing the HDB in MIT dump format\n - Improved Active Directory interoperability\n   . Enctype selection issues for PAC and other authz-data signatures\n   . Cross realm key rollover (kvno 0)\n - New [kdc] enctype negotiation configuration:\n   . tgt-use-strongest-session-key\n   . svc-use-strongest-session-key\n   . preauth-use-strongest-session-key\n   . use-strongest-server-key\n - The KDC process now uses a multi-process model improving\n   resiliency and performance\n - Allow batch-mode kinit with password file\n - SIGINFO support added to kinit cmd\n - New kx509 configuration options:\n   . kx509_ca\n   . kca_service\n   . kx509_include_pkinit_san\n   . kx509_template\n - Improved Heimdal library/plugin version safety\n - Name canonicalization\n   . DNS resolver searchlist\n   . Improved referral support\n   . Support host:port host-based services\n - Pluggable libheimbase interface for DBs\n - Improve IPv6 Support\n - LDAP\n   . Bind DN and password\n   . Start TLS\n - klist --json\n - DIR credential cache type\n - Updated upstream SQLite and libedit\n - Removed legacy applications: ftp, kx, login, popper, push, rcp, rsh,\n   telnet, xnlock\n - Completely remove RAND_egd support\n - Moved kadmin and ktutil to /usr/bin\n - Stricter fcache checks (see fcache_strict_checking krb5.conf setting)\n    . use O_NOFOLLOW\n    . don't follow symlinks\n    . require cache files to be owned by the user\n    . require sensible permissions (not group/other readable)\n - Implemented gss_store_cred()\n - Many more\n\n Bug fixes\n - iprop has been revamped to fix a number of race conditions that could\n   lead to data loss\n - Include non-loopback addresses assigned to loopback interfaces\n   when requesting tickets with addresses\n - KDC 1DES session key selection (for AFS rxkad-k5 compatibility)\n - Keytab file descriptor and lock leak\n - Credential cache corruption bugs\n   (NOTE: The FILE ccache is still not entirely safe due to the\n   fundamentally unsafe design of POSIX file locking)\n - gss_pseudo_random() interop bug\n - Plugins are now preferentially loaded from the run-time install tree\n - Reauthentication after password change in init_creds_password\n - Memory leak in the client kadmin library\n - TGS client requests renewable/forwardable/proxiable when possible\n - Locking issues in DB1 and DB3 HDB backends\n - Master HDB can remain locked while waiting for network I/O\n - Renewal/refresh logic when kinit is provided with a command\n - KDC handling of enterprise principals\n - Use correct bit for anon-pkinit\n - Many more\n\n Acknowledgements\n\n This release of Heimdal includes contributions from:\n\n    Abhinav Upadhyay        Heath Kehoe             Nico Williams\n    Andreas Schneider       Henry Jacques           Patrik Lundin\n    Andrew Bartlett         Howard Chu              Philip Boulain\n    Andrew Tridgell         Igor Sobrado            Ragnar Sundblad\n    Antoine Jacoutot        Ingo Schwarze           Remi Ferrand\n    Arran Cudbard-Bell      Jakub \u010cajka             Rod Widdowson\n    Arvid Requate           James Le Cuirot         Rok Pape\u017e\n    Asanka Herath           James Lee               Roland C. Dowdeswell\n    Ben Kaduk               Jeffrey Altman          Ross L Richardson\n    Benjamin Kaduk          Jeffrey Clark           Russ Allbery\n    Bernard Spil            Jeffrey Hutzelman       Samuel Cabrero\n    Brian May               Jelmer Vernooij         Samuel Thibault\n    Chas Williams           Ken Dreyer              Santosh Kumar Pradhan\n    Chaskiel Grundman       Kiran S J               Sean Davis\n    Dana Koch               Kumar Thangavelu        Sergio Gelato\n    Daniel Schepler         Landon Fuller           Simon Wilkinson\n    David Mulder            Linus Nordberg          Stef Walter\n    Douglas Bagnall         Love H\u00f6rnquist \u00c5strand  Stefan Metzmacher\n    Ed Maste                Luke Howard             Steffen Jaeckel\n    Eray Aslan              Magnus Ahltorp          Timothy Pearson\n    Florian Best            Marc Balmer             Tollef Fog Heen\n    Fredrik Pettai          Marcin Cie\u015blak          Tony Acero\n    Greg Hudson             Marco Molteni           Uri Simchoni\n    Gustavo Zacarias        Matthieu Hautreux       Viktor Dukhovni\n    G\u00fcnther Deschner        Michael Meffie          Volker Lendecke\n    Harald Barth            Moritz Lenz\n\nRelease Notes - Heimdal - Version Heimdal 1.5.3\n\n Bug fixes\n - Fix leaking file descriptors in KDC\n - Better socket/timeout handling in libkrb5\n - General bug fixes\n - Build fixes\n\nRelease Notes - Heimdal - Version Heimdal 1.5.2\n\n Security fixes\n - CVE-2011-4862 Buffer overflow in libtelnet/encrypt.c in telnetd - escalation of privilege\n - Check that key types strictly match - denial of service\n\nRelease Notes - Heimdal - Version Heimdal 1.5.1\n\n Bug fixes\n - Fix building on Solaris, requires c99\n - Fix building on Windows\n - Build system updates\n\nRelease Notes - Heimdal - Version Heimdal 1.5\n\nNew features\n\n - Support GSS name extensions/attributes\n - SHA512 support\n - No Kerberos 4 support\n - Basic support for MIT Admin protocol (SECGSS flavor)\n   in kadmind (extract keytab)\n - Replace editline with libedit\n\nRelease Notes - Heimdal - Version Heimdal 1.4\n\n New features\n \n - Support for reading MIT database file directly\n - KCM is polished up and now used in production\n - NTLM first class citizen, credentials stored in KCM\n - Table driven ASN.1 compiler, smaller!, not enabled by default\n - Native Windows client support\n\nNotes\n\n - Disabled write support NDBM hdb backend (read still in there) since\n   it can't handle large records, please migrate to a diffrent backend\n   (like BDB4)\n\nRelease Notes - Heimdal - Version Heimdal 1.3.3\n\n Bug fixes\n - Check the GSS-API checksum exists before trying to use it [CVE-2010-1321]\n - Check NULL pointers before dereference them [kdc]\n\nRelease Notes - Heimdal - Version Heimdal 1.3.2\n\n Bug fixes\n\n - Don't mix length when clearing hmac (could memset too much)\n - More paranoid underrun checking when decrypting packets\n - Check the password change requests and refuse to answer empty packets\n - Build on OpenSolaris \n - Renumber AD-SIGNED-TICKET since it was stolen from US\n - Don't cache /dev/*random file descriptor, it doesn't get unloaded\n - Make C++ safe\n - Misc warnings\n\nRelease Notes - Heimdal - Version Heimdal 1.3.1\n\n Bug fixes\n\n - Store KDC offset in credentials\n - Many many more bug fixes\n\nRelease Notes - Heimdal - Version Heimdal 1.3.1\n\n New features\n\n - Make work with OpenLDAPs krb5 overlay\n\nRelease Notes - Heimdal - Version Heimdal 1.3\n\n New features\n\n - Partial support for MIT kadmind rpc protocol in kadmind\n - Better support for finding keytab entries when using SPN aliases in the KDC\n - Support BER in ASN.1 library (needed for CMS)\n - Support decryption in Keychain private keys\n - Support for new sqlite based credential cache\n - Try both KDC referals and the common DNS reverse lookup in GSS-API\n - Fix the KCM to not leak resources on failure\n - Add IPv6 support to iprop\n - Support localization of error strings in\n   kinit/klist/kdestroy and Kerberos library\n - Remove Kerberos 4 support in application (still in KDC)\n - Deprecate DES\n - Support i18n password in windows domains (using UTF-8)\n - More complete API emulation of OpenSSL in hcrypto\n - Support for ECDSA and ECDH when linking with OpenSSL\n\n API changes\n\n - Support for settin friendly name on credential caches\n - Move to using doxygen to generate documentation.\n - Sprinkling __attribute__((__deprecated__)) for old function to be removed\n - Support to export LAST-REQUST information in AS-REQ\n - Support for client deferrals in in AS-REQ\n - Add seek support for krb5_storage.\n - Support for split AS-REQ, first step for IA-KERB\n - Fix many memory leaks and bugs\n - Improved regression test\n - Support krb5_cccol\n - Switch to krb5_set_error_message\n - Support krb5_crypto_*_iov\t\n - Switch to use EVP for most function\n - Use SOCK_CLOEXEC and O_CLOEXEC (close on exec)\n - Add support for GSS_C_DELEG_POLICY_FLAG\n - Add krb5_cc_[gs]et_config to store data in the credential caches\n - PTY testing application\n\nBugfixes\n - Make building on AIX6 possible.\n - Bugfixes in LDAP KDC code to make it more stable\n - Make ipropd-slave reconnect when master down gown\n\n\nRelease Notes - Heimdal - Version Heimdal 1.2.1\n\n* Bug\n\n  [HEIMDAL-147] - Heimdal 1.2 not compiling on Solaris\n  [HEIMDAL-151] - Make canned tests work again after cert expired\n  [HEIMDAL-152] - iprop test: use full hostname to avoid realm\n                  resolving errors\n  [HEIMDAL-153] - ftp: Use the correct length for unmap, msync\n\nRelease Notes - Heimdal - Version Heimdal 1.2\n\n* Bug\n\n  [HEIMDAL-10] - Follow-up on bug report for SEGFAULT in\n  \t\t gss_display_name/gss_export_name when using SPNEGO\n  [HEIMDAL-15] - Re: [Heimdal-bugs] potential bug in Heimdal 1.1\n  [HEIMDAL-17] - Remove support for depricated [libdefaults]capath\n  [HEIMDAL-52] - hdb overwrite aliases for db databases\n  [HEIMDAL-54] - Two issues which affect credentials delegation\n  [HEIMDAL-58] - sockbuf.c calls setsockopt with bad args\n  [HEIMDAL-62] - Fix printing of sig_atomic_t\n  [HEIMDAL-87] - heimdal 1.1 not building under cygwin in hcrypto\n  [HEIMDAL-105] - rcp: sync rcp with upstream bsd rcp codebase\n  [HEIMDAL-117] - Use libtool to detect symbol versioning (Debian Bug#453241)\n\n* Improvement\n  [HEIMDAL-67] - Fix locking and store credential in atomic writes\n                 in the FILE credential cache\n  [HEIMDAL-106] - make compile on cygwin again\n  [HEIMDAL-107] - Replace old random key generation in des module\n                  and use it with RAND_ function instead\n  [HEIMDAL-115] - Better documentation and compatibility in hcrypto\n                  in regards to OpenSSL\n\n* New Feature\n  [HEIMDAL-3] - pkinit alg agility PRF test vectors\n  [HEIMDAL-14] - Add libwind to Heimdal\n  [HEIMDAL-16] - Use libwind in hx509\n  [HEIMDAL-55] - Add flag to krb5 to not add GSS-API INT|CONF to\n                 the negotiation\n  [HEIMDAL-74] - Add support to report extended error message back\n                 in AS-REQ to support windows clients\n  [HEIMDAL-116] - test pty based application (using rkpty)\n  [HEIMDAL-120] - Use new OpenLDAP API (older deprecated)\n\n* Task\n  [HEIMDAL-63] - Dont try key usage KRB5_KU_AP_REQ_AUTH for TGS-REQ.\n                 This drop compatibility with pre 0.3d KDCs.\n  [HEIMDAL-64] - kcm: first implementation of kcm-move-cache\n  [HEIMDAL-65] - Failed to compile with --disable-pk-init\n  [HEIMDAL-80] - verify that [VU#162289]: gcc silently discards some\n                 wraparound checks doesn't apply to Heimdal\n\nChanges in release 1.1\n\n * Read-only PKCS11 provider built-in to hx509.\n\n * Documentation for hx509, hcrypto and ntlm libraries improved.\n\n * Better compatibilty with Windows 2008 Server pre-releases and Vista.\n\n * Mac OS X 10.5 support for native credential cache.\n\n * Provide pkg-config file for Heimdal (heimdal-gssapi.pc).\n\n * Bug fixes.\n\nChanges in release 1.0.2\n\n* Ubuntu packages.\n\n* Bug fixes.\n\nChanges in release 1.0.1\n\n * Serveral bug fixes to iprop.\n\n * Make work on platforms without dlopen.\n\n * Add RFC3526 modp group14 as default.\n\n * Handle [kdc] database = { } entries without realm = stanzas.\n\n * Make krb5_get_renewed_creds work.\n\n * Make kaserver preauth work again.\n\n * Bug fixes.\n\nChanges in release 1.0\n\n * Add gss_pseudo_random() for mechglue and krb5.\n\n * Make session key for the krbtgt be selected by the best encryption\n   type of the client.\n\n * Better interoperability with other PK-INIT implementations.\n\n * Inital support for Mac OS X Keychain for hx509.\n\n * Alias support for inital ticket requests.\n\n * Add symbol versioning to selected libraries on platforms that uses\n   GNU link editor: gssapi, hcrypto, heimntlm, hx509, krb5, and libkdc.\n\n * New version of imath included in hcrypto.\n\n * Fix memory leaks.\n\n * Bugs fixes.\n\nChanges in release 0.8.1\n\n * Make ASN.1 library less paranoid to with regard to NUL in string to\n   make it inter-operate with MIT Kerberos again.\n\n * Make GSS-API library work again when using gss_acquire_cred\n\n * Add symbol versioning to libgssapi when using GNU ld.\n\n * Fix memory leaks \n\n * Bugs fixes\n\nChanges in release 0.8\n\n * PK-INIT support.\n\n * HDB extensions support, used by PK-INIT.\n\n * New ASN.1 compiler.\n\n * GSS-API mechglue from FreeBSD.\n\n * Updated SPNEGO to support RFC4178.\n\n * Support for Cryptosystem Negotiation Extension (RFC 4537).\n\n * A new X.509 library (hx509) and related crypto functions.\n\n * A new ntlm library (heimntlm) and related crypto functions.\n\n * Updated the built-in crypto library with bignum support using\n   imath, support for RSA and DH and renamed it to libhcrypto.\n\n * Subsystem in the KDC, digest, that will perform the digest\n   operation in the KDC, currently supports: CHAP, MS-CHAP-V2, SASL\n   DIGEST-MD5 NTLMv1 and NTLMv2.\n\n * KDC will return the \"response too big\" error to force TCP retries\n   for large (default 1400 bytes) UDP replies.  This is common for\n   PK-INIT requests.\n\n * Libkafs defaults to use 2b tokens.\n\n * Default to use the API cache on Mac OS X.\n\n * krb5_kuserok() also checks ~/.k5login.d directory for acl files,\n   see manpage for krb5_kuserok for description.\n\n * Many, many, other updates to code and info manual and manual pages.\n\n * Bug fixes\n\nChanges in release 0.7.2\n\n* Fix security problem in rshd that enable an attacker to overwrite\n  and change ownership of any file that root could write.\n\n* Fix a DOS in telnetd. The attacker could force the server to crash\n  in a NULL de-reference before the user logged in, resulting in inetd\n  turning telnetd off because it forked too fast.\n\n* Make gss_acquire_cred(GSS_C_ACCEPT) check that the requested name\n  exists in the keytab before returning success. This allows servers\n  to check if its even possible to use GSSAPI.\n\n* Fix receiving end of token delegation for GSS-API. It still wrongly\n  uses subkey for sending for compatibility reasons, this will change\n  in 0.8.\n\n* telnetd, login and rshd are now more verbose in logging failed and\n  successful logins.\n\n* Bug fixes\n\nChanges in release 0.7.1\n\n* Bug fixes\n\nChanges in release 0.7\n\n * Support for KCM, a process based credential cache\n\n * Support CCAPI credential cache\n\n * SPNEGO support\n\n * AES (and the gssapi conterpart, CFX) support\n\n * Adding new and improve old documentation\n\n * Bug fixes\n\nChanges in release 0.6.6\n\n* Fix security problem in rshd that enable an attacker to overwrite\n  and change ownership of any file that root could write.\n\n* Fix a DOS in telnetd. The attacker could force the server to crash\n  in a NULL de-reference before the user logged in, resulting in inetd\n  turning telnetd off because it forked too fast.\n\nChanges in release 0.6.5\n\n * fix vulnerabilities in telnetd\n\n * unbreak Kerberos 4 and kaserver\n\nChanges in release 0.6.4\n\n * fix vulnerabilities in telnet\n\n * rshd: encryption without a separate error socket should now work\n\n * telnet now uses appdefaults for the encrypt and forward/forwardable\n   settings\n\n * bug fixes\n\nChanges in release 0.6.3\n\n * fix vulnerabilities in ftpd\n\n * support for linux AFS /proc \"syscalls\"\n\n * support for RFC3244 (Windows 2000 Kerberos Change/Set Password) in\n   kpasswdd\n\n * fix possible KDC denial of service\n\n * bug fixes\n\nChanges in release 0.6.2\n\n * Fix possible buffer overrun in v4 kadmin (which now defaults to off)\n\nChanges in release 0.6.1\n\n * Fixed ARCFOUR suppport\n\n * Cross realm vulnerability\n\n * kdc: fix denial of service attack\n\n * kdc: stop clients from renewing tickets into the future\n\n * bug fixes\n\t\nChanges in release 0.6\n\n* The DES3 GSS-API mechanism has been changed to inter-operate with\n  other GSSAPI implementations. See man page for gssapi(3) how to turn\n  on generation of correct MIC messages. Next major release of heimdal \n  will generate correct MIC by default.\n\n* More complete GSS-API support\n\n* Better AFS support: kdc (524) supports 2b; 524 in kdc and AFS\n  support in applications no longer requires Kerberos 4 libs\n\n* Kerberos 4 support in kdc defaults to turned off (includes ka and 524)\n\n* other bug fixes\n\nChanges in release 0.5.2\n\n * kdc: add option for disabling v4 cross-realm (defaults to off)\n\n * bug fixes\n\nChanges in release 0.5.1\n\n * kadmind: fix remote exploit\n\n * kadmind: add option to disable kerberos 4\n\n * kdc: make sure kaserver token life is positive\n\n * telnet: use the session key if there is no subkey\n\n * fix EPSV parsing in ftp\n\n * other bug fixes\n\nChanges in release 0.5\n\n * add --detach option to kdc\n\n * allow setting forward and forwardable option in telnet from\n   .telnetrc, with override from command line\n\n * accept addresses with or without ports in krb5_rd_cred\n\n * make it work with modern openssl\n\n * use our own string2key function even with openssl (that handles weak\n   keys incorrectly)\n\n * more system-specific requirements in login\n\n * do not use getlogin() to determine root in su\n\n * telnet: abort if telnetd does not support encryption\n\n * update autoconf to 2.53\n\n * update config.guess, config.sub\n\n * other bug fixes\n\nChanges in release 0.4e\n\n * improve libcrypto and database autoconf tests\n\n * do not care about salting of server principals when serving v4 requests\n\n * some improvements to gssapi library\n\n * test for existing compile_et/libcom_err\n\n * portability fixes\n\n * bug fixes\n\nChanges in release 0.4d\n\n * fix some problems when using libcrypto from openssl\n\n * handle /dev/ptmx `unix98' ptys on Linux\n\n * add some forgotten man pages\n\n * rsh: clean-up and add man page\n\n * fix -A and -a in builtin-ls in tpd\n\n * fix building problem on Irix\n\n * make `ktutil get' more efficient\n\n * bug fixes\n\nChanges in release 0.4c\n\n * fix buffer overrun in telnetd\n\n * repair some of the v4 fallback code in kinit\n\n * add more shared library dependencies\n\n * simplify and fix hprop handling of v4 databases\n\n * fix some building problems (osf's sia and osfc2 login)\n\n * bug fixes\n\nChanges in release 0.4b\n\n * update the shared library version numbers correctly\n\nChanges in release 0.4a\n\n * corrected key used for checksum in mk_safe, unfortunately this\n   makes it backwards incompatible\n\n * update to autoconf 2.50, libtool 1.4\n\n * re-write dns/config lookups (krb5_krbhst API)\n\n * make order of using subkeys consistent\n\n * add man page links\n\n * add more man pages\n\n * remove rfc2052 support, now only rfc2782 is supported\n\n * always build with kaserver protocol support in the KDC (assuming\n   KRB4 is enabled) and support for reading kaserver databases in\n   hprop\n\nChanges in release 0.3f\n\n * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,\n   the new keytab type that tries both of these in order (SRVTAB is\n   also an alias for krb4:)\n\n * improve error reporting and error handling (error messages should\n   be more detailed and more useful)\n\n * improve building with openssl\n\n * add kadmin -K, rcp -F \n\n * fix two incorrect weak DES keys\n\n * fix building of kaserver compat in KDC\n\n * the API is closer to what MIT krb5 is using\n\n * more compatible with windows 2000\n\n * removed some memory leaks\n\n * bug fixes\n\nChanges in release 0.3e\n\n * rcp program included\n\n * fix buffer overrun in ftpd\n\n * handle omitted sequence numbers as zeroes to handle MIT krb5 that\n   cannot generate zero sequence numbers\n\n * handle v4 /.k files better\n\n * configure/portability fixes\n\n * fixes in parsing of options to kadmin (sub-)commands\n\n * handle errors in kadmin load better\n\n * bug fixes\n\nChanges in release 0.3d\n\n * add krb5-config\n\n * fix a bug in 3des gss-api mechanism, making it compatible with the\n   specification and the MIT implementation\n\n * make telnetd only allow a specific list of environment variables to\n   stop it from setting `sensitive' variables\n\n * try to use an existing libdes\n\n * lib/krb5, kdc: use correct usage type for ap-req messages.  This\n   should improve compatability with MIT krb5 when using 3DES\n   encryption types\n\n * kdc: fix memory allocation problem\n\n * update config.guess and config.sub\n\n * lib/roken: more stuff implemented\n\n * bug fixes and portability enhancements\n\nChanges in release 0.3c\n\n * lib/krb5: memory caches now support the resolve operation\n\n * appl/login: set PATH to some sane default\n\n * kadmind: handle several realms\n\n * bug fixes (including memory leaks)\n\nChanges in release 0.3b\n\n * kdc: prefer default-salted keys on v5 requests\n\n * kdc: lowercase hostnames in v4 mode\n\n * hprop: handle more types of MIT salts\n\n * lib/krb5: fix memory leak\n\n * bug fixes\n\nChanges in release 0.3a:\n\n * implement arcfour-hmac-md5 to interoperate with W2K\n\n * modularise the handling of the master key, and allow for other\n   encryption types. This makes it easier to import a database from\n   some other source without having to re-encrypt all keys.\n\n * allow for better control over which encryption types are created\n\n * make kinit fallback to v4 if given a v4 KDC\n\n * make klist work better with v4 and v5, and add some more MIT\n   compatibility options\n\n * make the kdc listen on the krb524 (4444) port for compatibility\n   with MIT krb5 clients\n\n * implement more DCE/DFS support, enabled with --enable-dce, see\n   lib/kdfs and appl/dceutils\n\n * make the sequence numbers work correctly\n\n * bug fixes\n\nChanges in release 0.2t:\n\n * bug fixes\n\nChanges in release 0.2s:\n\n * add OpenLDAP support in hdb\n\n * login will get v4 tickets when it receives forwarded tickets\n\n * xnlock supports both v5 and v4\n\n * repair source routing for telnet\n\n * fix building problems with krb4 (krb_mk_req)\n\n * bug fixes\n\nChanges in release 0.2r:\n\n * fix realloc memory corruption bug in kdc\n\n * `add --key' and `cpw --key' in kadmin\n\n * klist supports listing v4 tickets\n\n * update config.guess and config.sub\n\n * make v4 -> v5 principal name conversion more robust\n\n * support for anonymous tickets\n\n * new man-pages\n\n * telnetd: do not negotiate KERBEROS5 authentication if there's no keytab.\n\n * use and set expiration and not password expiration when dumping\n   to/from ka server databases / krb4 databases\n\n * make the code happier with 64-bit time_t\n\n * follow RFC2782 and by default do not look for non-underscore SRV names\n\nChanges in release 0.2q:\n\n * bug fix in tcp-handling in kdc\n\n * bug fix in expand_hostname\n\nChanges in release 0.2p:\n\n * bug fix in `kadmin load/merge'\n\n * bug fix in krb5_parse_address\n\nChanges in release 0.2o:\n\n * gss_{import,export}_sec_context added to libgssapi\n\n * new option --addresses to kdc (for listening on an explicit set of\n   addresses)\n\n * bug fixes in the krb4 and kaserver emulation part of the kdc\n\n * other bug fixes\n\nChanges in release 0.2n:\n\n * more robust parsing of dump files in kadmin\n * changed default timestamp format for log messages to extended ISO\n   8601 format (Y-M-DTH:M:S)\n * changed md4/md5/sha1 APIes to be de-facto `standard'\n * always make hostname into lower-case before creating principal\n * small bits of more MIT-compatability\n * bug fixes\n\nChanges in release 0.2m:\n\n * handle glibc's getaddrinfo() that returns several ai_canonname\n\n * new endian test\n\n * man pages fixes\n\nChanges in release 0.2l:\n\n * bug fixes\n\nChanges in release 0.2k:\n\n * better IPv6 test\n\n * make struct sockaddr_storage in roken work better on alphas\n\n * some missing [hn]to[hn]s fixed.\n\n * allow users to change their own passwords with kadmin (with initial\n   tickets)\n\n * fix stupid bug in parsing KDC specification\n\n * add `ktutil change' and `ktutil purge'\n\nChanges in release 0.2j:\n\n * builds on Irix\n\n * ftpd works in passive mode\n\n * should build on cygwin\n\n * work around broken IPv6-code on OpenBSD 2.6, also add configure\n   option --disable-ipv6\n\nChanges in release 0.2i:\n\n * use getaddrinfo in the missing places.\n\n * fix SRV lookup for admin server\n\n * use get{addr,name}info everywhere.  and implement it in terms of\n   getipnodeby{name,addr} (which uses gethostbyname{,2} and\n   gethostbyaddr)\n\nChanges in release 0.2h:\n\n * fix typo in kx (now compiles)\n\nChanges in release 0.2g:\n\n * lots of bug fixes:\n   * push works\n   * repair appl/test programs\n   * sockaddr_storage works on solaris (alignment issues)\n   * works better with non-roken getaddrinfo\n   * rsh works\n   * some non standard C constructs removed\n\nChanges in release 0.2f:\n\n * support SRV records for kpasswd\n * look for both _kerberos and krb5-realm when doing host -> realm mapping\n\nChanges in release 0.2e:\n\n * changed copyright notices to remove `advertising'-clause.\n * get{addr,name}info added to roken and used in the other code\n   (this makes things work much better with hosts with both v4 and v6\n    addresses, among other things)\n * do pre-auth for both password and key-based get_in_tkt\n * support for having several databases\n * new command `del_enctype' in kadmin\n * strptime (and new strftime) add to roken\n * more paranoia about finding libdb\n * bug fixes\n\nChanges in release 0.2d:\n\n * new configuration option [libdefaults]default_etypes_des\n * internal ls in ftpd builds without KRB4\n * kx/rsh/push/pop_debug tries v5 and v4 consistenly\n * build bug fixes\n * other bug fixes\n\nChanges in release 0.2c:\n\n * bug fixes (see ChangeLog's for details)\n\nChanges in release 0.2b:\n\n * bug fixes\n * actually bump shared library versions\n\nChanges in release 0.2a:\n\n * a new program verify_krb5_conf for checking your /etc/krb5.conf\n * add 3DES keys when changing password\n * support null keys in database\n * support multiple local realms\n * implement a keytab backend for AFS KeyFile's\n * implement a keytab backend for v4 srvtabs\n * implement `ktutil copy'\n * support password quality control in v4 kadmind\n * improvements in v4 compat kadmind\n * handle the case of having the correct cred in the ccache but with\n   the wrong encryption type better\n * v6-ify the remaining programs.\n * internal ls in ftpd\n * rename strcpy_truncate/strcat_truncate to strlcpy/strlcat\n * add `ank --random-password' and `cpw --random-password' in kadmin\n * some programs and documentation for trying to talk to a W2K KDC\n * bug fixes\n\nChanges in release 0.1m:\n\n * support for getting default from krb5.conf for kinit/kf/rsh/telnet.\n   From Miroslav Ruda <ruda@ics.muni.cz>\n * v6-ify hprop and hpropd\n * support numeric addresses in krb5_mk_req\n * shadow support in login and su. From Miroslav Ruda <ruda@ics.muni.cz>\n * make rsh/rshd IPv6-aware\n * make the gssapi sample applications better at reporting errors\n * lots of bug fixes\n * handle systems with v6-aware libc and non-v6 kernels (like Linux\n   with glibc 2.1) better\n * hide failure of ERPT in ftp\n * lots of bug fixes\n\nChanges in release 0.1l:\n\n * make ftp and ftpd IPv6-aware\n * add inet_pton to roken\n * more IPv6-awareness\n * make mini_inetd v6 aware\n\nChanges in release 0.1k:\n\n * bump shared libraries versions\n * add roken version of inet_ntop\n * merge more changes to rshd\n\nChanges in release 0.1j:\n\n * restore back to the `old' 3DES code.  This was supposed to be done\n   in 0.1h and 0.1i but I did a CVS screw-up.\n * make telnetd handle v6 connections\n\nChanges in release 0.1i:\n\n * start using `struct sockaddr_storage' which simplifies the code\n   (with a fallback definition if it's not defined)\n * bug fixes (including in hprop and kf)\n * don't use mawk which seems to mishandle roken.awk\n * get_addrs should be able to handle v6 addresses on Linux (with the\n   required patch to the Linux kernel -- ask within)\n * rshd builds with shadow passwords\n\nChanges in release 0.1h:\n\n * kf: new program for forwarding credentials\n * portability fixes\n * make forwarding credentials work with MIT code\n * better conversion of ka database\n * add etc/services.append\n * correct `modified by' from kpasswdd\n * lots of bug fixes\n\nChanges in release 0.1g:\n\n * kgetcred: new program for explicitly obtaining tickets\n * configure fixes\n * krb5-aware kx\n * bug fixes\n\nChanges in release 0.1f;\n\n * experimental support for v4 kadmin protokoll in kadmind\n * bug fixes\n\nChanges in release 0.1e:\n\n * try to handle old DCE and MIT kdcs\n * support for older versions of credential cache files and keytabs\n * postdated tickets work\n * support for password quality checks in kpasswdd\n * new flag --enable-kaserver for kdc\n * renew fixes\n * prototype su program\n * updated (some) manpages\n * support for KDC resource records\n * should build with --without-krb4\n * bug fixes\n\nChanges in release 0.1d:\n\n * Support building with DB2 (uses 1.85-compat API)\n * Support krb5-realm.DOMAIN in DNS\n * new `ktutil srvcreate'\n * v4/kafs support in klist/kdestroy\n * bug fixes\n\nChanges in release 0.1c:\n\n * fix ASN.1 encoding of signed integers\n * somewhat working `ktutil get'\n * some documentation updates\n * update to Autoconf 2.13 and Automake 1.4\n * the usual bug fixes\n\nChanges in release 0.1b:\n\n * some old -> new crypto conversion utils\n * bug fixes\n\nChanges in release 0.1a:\n\n * new crypto code\n * more bug fixes\n * make sure we ask for DES keys in gssapi\n * support signed ints in ASN1\n * IPv6-bug fixes\n\nChanges in release 0.0u:\n\n * lots of bug fixes\n\nChanges in release 0.0t:\n\n * more robust parsing of krb5.conf\n * include net{read,write} in lib/roken\n * bug fixes\n\nChanges in release 0.0s:\n\n * kludges for parsing options to rsh\n * more robust parsing of krb5.conf\n * removed some arbitrary limits\n * bug fixes\n\nChanges in release 0.0r:\n\n * default options for some programs\n * bug fixes\n\nChanges in release 0.0q:\n\n * support for building shared libraries with libtool\n * bug fixes\n\nChanges in release 0.0p:\n\n * keytab moved to /etc/krb5.keytab\n * avoid false detection of IPv6 on Linux\n * Lots of more functionality in the gssapi-library\n * hprop can now read ka-server databases\n * bug fixes\n\nChanges in release 0.0o:\n\n * FTP with GSSAPI support.\n * Bug fixes.\n\nChanges in release 0.0n:\n\n * Incremental database propagation.\n * Somewhat improved kadmin ui; the stuff in admin is now removed.\n * Some support for using enctypes instead of keytypes.\n * Lots of other improvement and bug fixes, see ChangeLog for details.\n", "/*\n * Copyright (c) 1997-2008 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"kdc_locl.h\"\n\n/*\n * return the realm of a krbtgt-ticket or NULL\n */\n\nstatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}\n\n/*\n * The KDC might add a signed path to the ticket authorization data\n * field. This is to avoid server impersonating clients and the\n * request constrained delegation.\n *\n * This is done by storing a KRB5_AUTHDATA_IF_RELEVANT with a single\n * entry of type KRB5SignedPath.\n */\n\nstatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}\n\nkrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\nstatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 5,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_tgs_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ_BODY *b, const EncTicketPart *tgt, EncTicketPart *et)\n{\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif(!tgt->flags.invalid || tgt->starttime == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    kdc_log(context, config, 0,\n\t\t    \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    }else if(tgt->flags.invalid){\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    }else if(b->from && *b->from > kdc_time + context->max_skew){\n\tkdc_log(context, config, 0, \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n#if 0\n    /* checks for excess flags */\n    if(f.request_anonymous && !config->allow_anonymous){\n\tkdc_log(context, config, 0,\n\t\t\"Request for anonymous ticket\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n#endif\n    return 0;\n}\n\n/*\n * Determine if constrained delegation is allowed from this client to this server\n */\n\nstatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}\n\n/*\n * Determine if s4u2self is allowed from this client to this server\n *\n * For example, regardless of the principal being impersonated, if the\n * 'client' and 'server' are the same, then it's safe.\n */\n\nstatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nverify_flags (krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      const EncTicketPart *et,\n\t      const char *pstr)\n{\n    if(et->endtime < kdc_time){\n\tkdc_log(context, config, 0, \"Ticket expired (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_EXPIRED;\n    }\n    if(et->flags.invalid){\n\tkdc_log(context, config, 0, \"Ticket not valid (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_NYV;\n    }\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}\n\n\nstatic krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}\n\nstatic krb5_error_code\ntgs_check_authenticator(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t                krb5_auth_context ac,\n\t\t\tKDC_REQ_BODY *b,\n\t\t\tconst char **e_text,\n\t\t\tkrb5_keyblock *key)\n{\n    krb5_authenticator auth;\n    size_t len = 0;\n    unsigned char *buf;\n    size_t buf_size;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    krb5_auth_con_getauthenticator(context, ac, &auth);\n    if(auth->cksum == NULL){\n\tkdc_log(context, config, 0, \"No authenticator in request\");\n\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n    /*\n     * according to RFC1510 it doesn't need to be keyed,\n     * but according to the latest draft it needs to.\n     */\n    if (\n#if 0\n!krb5_checksum_is_keyed(context, auth->cksum->cksumtype)\n\t||\n#endif\n !krb5_checksum_is_collision_proof(context, auth->cksum->cksumtype)) {\n\tkdc_log(context, config, 0, \"Bad checksum type in authenticator: %d\",\n\t\tauth->cksum->cksumtype);\n\tret =  KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n\n    /* XXX should not re-encode this */\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, b, &len, ret);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REQ-BODY: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\tret = KRB5KRB_ERR_GENERIC;\n\tgoto out;\n    }\n    ret = krb5_crypto_init(context, key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    ret = krb5_verify_checksum(context,\n\t\t\t       crypto,\n\t\t\t       KRB5_KU_TGS_REQ_AUTH_CKSUM,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       auth->cksum);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to verify authenticator checksum: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\nout:\n    free_Authenticator(auth);\n    free(auth);\n    return ret;\n}\n\nstatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 0, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 0, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}\n\nstatic krb5_error_code\ntgs_parse_request(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  KDC_REQ_BODY *b,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 0, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n \tkdc_log(context, config, 0,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n    else\n\tverify_ap_req_flags = 0;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 0, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}\n\nstatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}\n\nstatic krb5_error_code\ntgs_build_reply(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ *req,\n\t\tKDC_REQ_BODY *b,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tkrb5_data *reply,\n\t\tconst char *from,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_error_code ret;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /* \n     * Always to do CANON, see comment below about returned server principal (rsp).\n     */\n    flags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 0,\n\t\t    \"No second ticket present in request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 0,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret)\n\t    goto out;\n\n\tret = verify_flags(context, config, &adtkt, spn);\n\tif (ret)\n\t    goto out;\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &spn);\n    if (ret)\n\tgoto out;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &cpn);\n    if (ret)\n\tgoto out;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,\n\t\t\tNULL, NULL, &server);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", sp);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 5,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(spn);\n        spn = NULL;\n\tret = krb5_unparse_name(context, sp, &spn);\n\tif (ret)\n\t    goto out;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                        req_rlm, TRUE, &capath, &num_capath);\n                if (ret)\n                    goto out;\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(spn);\n                spn = NULL;\n                ret = krb5_unparse_name(context, sp, &spn);\n                if (ret)\n                    goto out;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(spn);\n                spn = NULL;\n\t\tret = krb5_unparse_name(context, sp, &spn);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /* the name returned to the client depend on what was asked for,\n     * return canonical name if kdc_options.canonicalize was set, the\n     * client wants the true name of the principal, if not it just\n     * wants the name its asked for.\n     */\n\n    if (b->kdc_options.canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(context,\n\t\t\t\t  krb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t\t  server, b->etype.val, b->etype.len, &etype,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authoriation data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 1, \"Client no longer in database: %s\",\n\t\t    cpn);\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 1, \"Client not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_verify_checksum(context,\n\t\t\t\t       crypto,\n\t\t\t\t       KRB5_KU_OTHER_CKSUM,\n\t\t\t\t       datack.data,\n\t\t\t\t       datack.length,\n\t\t\t\t       &self.cksum);\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\t    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);\n\t\tif (ret) {\n\t\t    const char *msg;\n\n\t\t    /*\n\t\t     * If the client belongs to the same realm as our krbtgt, it\n\t\t     * should exist in the local database.\n\t\t     *\n\t\t     */\n\n\t\t    if (ret == HDB_ERR_NOENTRY)\n\t\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\t    msg = krb5_get_error_message(context, ret);\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"S2U4Self principal to impersonate %s not found in database: %s\",\n\t\t\t    tpn, msg);\n\t\t    krb5_free_error_message(context, msg);\n\t\t    goto out;\n\t\t}\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n\t\t    kdc_log(context, config, 0, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 0, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation, remove the forward flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 0, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(context, config,\n\t\t\t  client, cpn,\n\t\t\t  server, spn,\n\t\t\t  FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n\tkdc_log(context, config, 0, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tkdc_log(context, config, 0, \"Request from wrong address\");\n\tgoto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 0,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(context,\n\t\t\t config,\n\t\t\t b,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t spn,\n\t\t\t client,\n\t\t\t cp,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data,\n\t\t\t e_text,\n\t\t\t reply);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(spn);\n    free(cpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}\n\n/*\n *\n */\n\nkrb5_error_code\n_kdc_tgs_rep(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     KDC_REQ *req,\n\t     krb5_data *data,\n\t     const char *from,\n\t     struct sockaddr *from_addr,\n\t     int datagram_reply)\n{\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(context, config,\n\t\t\t    &req->req_body, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 10, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(context,\n\t\t\t  config,\n\t\t\t  req,\n\t\t\t  &req->req_body,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  data,\n\t\t\t  from,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 10, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(context, NULL,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2006 - 2007 Kungliga Tekniska H\u00f6gskolan\n# (Royal Institute of Technology, Stockholm, Sweden). \n# All rights reserved. \n#\n# Redistribution and use in source and binary forms, with or without \n# modification, are permitted provided that the following conditions \n# are met: \n#\n# 1. Redistributions of source code must retain the above copyright \n#    notice, this list of conditions and the following disclaimer. \n#\n# 2. Redistributions in binary form must reproduce the above copyright \n#    notice, this list of conditions and the following disclaimer in the \n#    documentation and/or other materials provided with the distribution. \n#\n# 3. Neither the name of the Institute nor the names of its contributors \n#    may be used to endorse or promote products derived from this software \n#    without specific prior written permission. \n#\n# THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND \n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n# ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE \n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS \n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY \n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF \n# SUCH DAMAGE. \n\ntop_builddir=\"@top_builddir@\"\nenv_setup=\"@env_setup@\"\nobjdir=\"@objdir@\"\n\n. ${env_setup}\n\nKRB5_CONFIG=\"${1-${objdir}/krb5.conf}\"\nexport KRB5_CONFIG\n\ntestfailed=\"echo test failed; cat messages.log; exit 1\"\n\n# If there is no useful db support compiled in, disable test\n${have_db} || exit 77\n\nR=TEST.H5L.SE\nRH=TEST-HTTP.H5L.SE\nR2=TEST2.H5L.SE\nR3=TEST3.H5L.SE\nR4=TEST4.H5L.SE\nR5=SOME-REALM5.FR\nR6=SOME-REALM6.US\nR7=SOME-REALM7.UK\n\nH1=H1.$R\nH2=H2.$R\nH3=H3.$H2\nH4=H4.$H2\n\nr=`echo \"$R\" | tr '[A-Z]' '[a-z]'`\nh1=`echo \"${H1}\" | tr '[A-Z]' '[a-z]'`\nh2=`echo \"${H2}\" | tr '[A-Z]' '[a-z]'`\nh3=`echo \"${H3}\" | tr '[A-Z]' '[a-z]'`\nh4=`echo \"${H4}\" | tr '[A-Z]' '[a-z]'`\n\nport=@port@\npwport=@pwport@\n\nkadmin=\"${kadmin} -l -r $R\"\nkadmin5=\"${kadmin} -l -r $R5\"\nkdc=\"${kdc} --addresses=localhost -P $port\"\nkpasswdd=\"${kpasswdd} --addresses=localhost -p $pwport\"\n\nserver=host/datan.test.h5l.se\nserver2=host/computer.example.com\nserverip=host/10.11.12.13\nserveripname=host/ip.test.h5l.org\nserveripname2=host/10.11.12.14\nalias1=host/datan.example.com\nalias2=host/datan\naliaskeytab=host/datan\ncache=\"FILE:${objdir}/cache.krb5\"\nocache=\"FILE:${objdir}/ocache.krb5\"\no2cache=\"FILE:${objdir}/o2cache.krb5\"\nicache=\"FILE:${objdir}/icache.krb5\"\nkeytabfile=${objdir}/server.keytab\nkeytab=\"FILE:${keytabfile}\"\nps=\"proxy-service@${R}\"\naesenctype=\"aes256-cts-hmac-sha1-96\"\n\nkinit=\"${kinit} -c $cache ${afs_no_afslog}\"\nklist=\"${klist} -c $cache\"\nkgetcred=\"${kgetcred} -c $cache\"\nkgetcred_imp=\"${kgetcred} -c $cache --out-cache=${ocache}\"\nkdestroy=\"${kdestroy} -c $cache ${afs_no_unlog}\"\nkimpersonate=\"${kimpersonate} -k ${keytab} --ccache=${ocache}\"\ntest_set_kvno0=\"${test_set_kvno0} -c $cache\"\n\nrm -f ${keytabfile}\nrm -f current-db*\nrm -f out-*\nrm -f mkey.file*\n\n> messages.log\n\necho Creating database\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R2} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R3} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R4} || exit 1\n\n${kadmin5} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R5} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R6} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R7} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H1} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H2} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H3} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H4} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${RH} || exit 1\n\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults foo@${R} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${r}@${R} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R2} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R3} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R4} || exit 1\n${kadmin5} add -p foo --use-defaults foo@${R5} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R6} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R7} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H1} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h1}@${H1} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H2} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h2}@${H2} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H3} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h3}@${H3} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H4} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h4}@${H4} || exit 1\n${kadmin} add -p bar --use-defaults bar@${R} || exit 1\n${kadmin} add -p foo --use-defaults remove@${R} || exit 1\n${kadmin} add -p nop --use-defaults ${server}@${R} || exit 1\n${kadmin} cpw -p bla --keepold ${server}@${R} || exit 1\n${kadmin} cpw -p kaka --keepold ${server}@${R} || exit 1\n${kadmin} add -p kaka --use-defaults ${server}-des3@${R} || exit 1\n${kadmin} add -p kaka --use-defaults kt-des3@${R} || exit 1\n${kadmin} add -p kaka --use-defaults foo/des3-only@${R} || exit 1\n${kadmin} add -p kaka --use-defaults bar/des3-only@${R} || exit 1\n${kadmin} add -p kaka --use-defaults foo/aes-only@${R} || exit 1\n${kadmin} add -p foo --use-defaults ${ps} || exit 1\n${kadmin} modify --attributes=+trusted-for-delegation ${ps} || exit 1\n${kadmin} modify --constrained-delegation=${server} ${ps} || exit 1\n${kadmin} ext -k ${keytab} ${server}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${ps} || exit 1\n\n${kadmin} add -p kaka --use-defaults ${server2}@${R2} || exit 1\n${kadmin} ext -k ${keytab} ${server2}@${R2} || exit 1\n${kadmin} add -p kaka --use-defaults ${serverip}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${serverip}@${R} || exit 1\n${kadmin} add -p kaka --use-defaults ${serveripname}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${serveripname}@${R} || exit 1\n${kadmin} modify --alias=${serveripname2}@${R} ${serveripname}@${R}\n${kadmin} add -p foo --use-defaults remove2@${R2} || exit 1\n\n${kadmin} add -p kaka --use-defaults ${alias1}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${alias1}@${R} || exit 1\n${kadmin} modify --alias=${alias2}@${R} ${alias1}@${R}\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R2}@${R} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R}@${R2} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R3}@${R2} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R2}@${R3} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R4}@${R2} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R2}@${R4} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R4}@${R3} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R3}@${R4} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R5}@${R} || exit 1\n${kadmin5} add -p cross2 --use-defaults krbtgt/${R}@${R5} || exit 1\n\n${kadmin5} add -p cross1 --use-defaults krbtgt/${R6}@${R5} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R5}@${R6} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R7}@${R6} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R6}@${R7} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H1}@${R} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R}@${H1} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H2}@${R} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R}@${H2} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H3}@${H2} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${H2}@${H3} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H3}@${H4} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${H4}@${H3} || exit 1\n\n${kadmin} add -p foo --use-defaults pw-expire@${R} || exit 1\n${kadmin} modify --pw-expiration-time=+1day  pw-expire@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults pw-expired@${R} || exit 1\n${kadmin} modify --pw-expiration-time=2012-06-12  pw-expired@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults account-expired@${R} || exit 1\n${kadmin} modify --expiration-time=2012-06-12  account-expired@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults foo@${RH} || exit 1\n\necho \"Check parser\"\n${kadmin} add -p foo --use-defaults -- -p || exit 1\n${kadmin} delete -- -p || exit 1\n\necho \"Doing database check\"\n${kadmin} check ${R} || exit 1\n${kadmin} check ${R2} || exit 1\n${kadmin} check ${R3} || exit 1\n${kadmin} check ${R4} || exit 1\n${kadmin5} check ${R5} || exit 1\n${kadmin} check ${R6} || exit 1\n${kadmin} check ${R7} || exit 1\n${kadmin} check ${H1} || exit 1\n${kadmin} check ${H2} || exit 1\n${kadmin} check ${H3} || exit 1\n${kadmin} check ${H4} || exit 1\n\necho \"Extracting enctypes\"\n${ktutil} -k ${keytab} list > tempfile || exit 1\n${EGREP} -v '^FILE:' tempfile | ${EGREP} -v '^Vno' | ${EGREP} -v '^$' | \\\n    ${EGREP} -v \"$server\" |                 # we did cpw for this one\n    awk '$1 !~ /1/  { exit 1 }' || exit 1\n${EGREP} -v '^FILE:' tempfile | ${EGREP} -v '^Vno' | ${EGREP} -v '^$' | \\\n    ${EGREP} \"$server\" | head -1 |\n    awk '$1 !~ /3/  { exit 1 }' || exit 1\n\n\n${kadmin} get foo@${R} > tempfile || exit 1\nenctypes=`grep Keytypes: tempfile | sed 's/(pw-salt)//g' | sed 's/,//g' | sed 's/Keytypes://' | sed 's/\\[[0-9]*\\]//g'`\n\nenctype_sans_aes=`echo $enctypes | sed 's/aes[^ ]*//g'`\nenctype_sans_des3=`echo $enctypes | sed 's/des3-cbc-sha1//g'`\n\necho \"deleting all but des enctypes on kt-des3 in keytab\"\n${kadmin} ext -k ${keytab} kt-des3@${R} || exit 1\nfor a in ${enctype_sans_des3} ; do\n   ${ktutil} -k ${keytab} remove -p kt-des3@${R} -e $a\ndone\n\necho \"checking globbing keys rules\"\n${kadmin} get foo/des3-only@${R} > tempfile || exit 1\nenctypes=`grep Keytypes: tempfile | sed 's/(pw-salt)//g' | sed 's/,//g' | sed 's/Keytypes://' | sed 's/\\[[0-9]*\\]//g' | sed 's/ //g'`\nif [ X\"$enctypes\" != Xdes3-cbc-sha1 ] ; then\n    echo \"des3 only is not only des3: $enctypes\"\n    exit 1\nfi\n\n${kadmin} get foo/aes-only@${R} > tempfile || exit 1\nenctypes=`grep Keytypes: tempfile | sed 's/(pw-salt)//g' | sed 's/,//g' | sed 's/Keytypes://' | sed 's/\\[[0-9]*\\]//g' | sed 's/ //g'`\nif [ X\"$enctypes\" != Xaes256-cts-hmac-sha1-96 ] ; then\n    echo \"aes only is not only aes: $enctypes\"\n    exit 1\nfi\n\n\necho foo > ${objdir}/foopassword\necho notfoo > ${objdir}/notfoopassword\n\necho Starting kdc ; > messages.log\nenv MallocStackLogging=1 MallocStackLoggingNoCompact=1 MallocErrorAbort=1 MallocLogFile=${objdir}/malloc-log \\\n${kdc} --detach --testing ||\n    { echo \"kdc failed to start\"; exit 1; }\nkdcpid=`getpid kdc`\n\necho Starting kpasswdd; > messages.log\nenv ${HEIM_MALLOC_DEBUG} ${kpasswdd} --detach ||\n    { echo \"kpasswdd failed to start\"; exit 1; }\nkpasswddpid=`getpid kpasswdd`\n\n\ntrap \"kill -9 ${kdcpid} ${kpasswddpid}; echo signal killing kdc kpasswdd; exit 1;\" EXIT\n\nec=0\n\necho \"Getting client initial tickets with wrong password\"; > messages.log\n${kinit} --password-file=${objdir}/notfoopassword \\\n        foo@${R} 2>kinit-log.tmp && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\ngrep 'Password incorrect' kinit-log.tmp > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"Getting client initial tickets\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"Doing krbtgt key rollover\"; > messages.log\n${kadmin} cpw -r --keepold krbtgt/${R}@${R} || exit 1\necho \"Getting tickets\"; > messages.log\n${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Listing tickets\"; > messages.log\n${klist} > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Getting client initial tickets (http transport)\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@${RH} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing capaths logic\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with capaths for $R -> $R2\"\n${kgetcred} foo@${R2} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R3\"\n${kgetcred} foo@${R3} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R4\"\n${kgetcred} foo@${R4} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R5\"\n${kgetcred} foo@${R5} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R6\"\n${kgetcred} foo@${R6} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R7\"\n${kgetcred} foo@${R7} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing capaths logic (reverse order)\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with capaths for $R -> $R4\"\n${kgetcred} foo@${R4} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R3\"\n${kgetcred} foo@${R3} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R2\"\n${kgetcred} foo@${R2} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R7\"\n${kgetcred} foo@${R7} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R6\"\n${kgetcred} foo@${R6} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R5\"\n${kgetcred} foo@${R5} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing hierarchical referral logic\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@${H3} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with hierarchical referrals for $H3 -> $H1\"\n${kgetcred} --hostbased --canonicalize foo host.${h1} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with hierarchical referrals for $H3 -> $R\"\n${kgetcred} --hostbased --canonicalize foo host.${r} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with hierarchical referrals for $H3 -> $H2\"\n${kgetcred} --hostbased --canonicalize foo host.${h2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing multi-hop [capaths] referral logic\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@${H4} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with [capaths] referrals for $H4 -> $H1\"\n${kgetcred} --hostbased --canonicalize foo/host.${h1}@${H4} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing forwardable/renewable flag copying in TGS-REQ\"\n${kinit} -f --renewable -r 5d --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${klist} -f | grep ${server} | grep FRA > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\n\necho \"Specific enctype\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\nfor a in $enctypes; do\n\techo \"Getting client initial tickets ($a)\"; > messages.log\n\t${kinit} --enctype=$a --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\n\techo \"Getting tickets\"; > messages.log\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\ndone\n\n\necho \"Getting client initial tickets\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\nfor a in $enctypes; do\n\techo \"Getting tickets ($a)\"; > messages.log\n\t${kgetcred} -e $a ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy} --credential=${server}@${R}\ndone\n${kdestroy}\n\necho \"Getting client initial tickets for cross realm case\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\nfor a in $enctypes; do\n\techo \"Getting cross realm tickets ($a)\"; > messages.log\n\t${kgetcred} -e $a ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n\techo \"  checking we we got back right ticket\"\n\t${klist} | grep ${server2}@ > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n\techo \"  checking if ticket is useful\"\n\t${test_ap_req} ${server2}@${R2} ${keytab} ${cache} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy} --credential=${server2}@${R2}\ndone\n${kdestroy}\n\necho \"Trying x-realm TGT with kvno 0 case\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Trying x-realm TGT with kvno 0 case with key rollover\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Rolling over cross realm keys\"; > messages.log\n${kadmin} cpw -r --keepold krbtgt/${R}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\necho \"Start tracing kdc, then hit return\"\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Trying x-realm TGT with no kvno case\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Trying x-realm TGT with no kvno case with key rollover\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Rolling over cross realm keys\"; > messages.log\n${kadmin} cpw -r --keepold krbtgt/${R}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\necho \"Start tracing kdc, then hit return\"\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"try all permutations\"; > messages.log\nfor a in $enctypes; do\n\techo \"Getting client initial tickets ($a)\"; > messages.log\n\t${kinit} --enctype=$a --password-file=${objdir}/foopassword foo@$R || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\tfor b in $enctypes; do\n\t\techo \"Getting tickets ($a ->  $b)\"; > messages.log\n\t\t${kgetcred} -e $b ${server}@${R} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${kdestroy} --credential=${server}@${R}\n\tdone\n\t${kdestroy}\ndone\n\necho \"Getting client initial tickets ip based name\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting ip based name tickets\"; > messages.log\n${kgetcred} ${serverip}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"  checking we we got back right ticket\"\n${klist} | grep ${serverip}@ > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\necho \"  checking if ticket is useful\"\n${test_ap_req} ${serverip}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Getting client initial tickets ip based name (alias)\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\nfor a in ${serveripname} ${serveripname2} ; do\n    echo \"Getting ip based name tickets (alias) $a\"; > messages.log\n    ${kgetcred} ${a}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n    echo \"  checking we we got back right ticket\"\n    ${klist} | grep ${a}@ > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n    echo \"  checking if ticket is useful\"\n    ${test_ap_req} --server-any ${a}@${R} ${keytab} ${cache} || \\\n    \t{ ec=1 ; eval \"${testfailed}\"; }\ndone\n${kdestroy}\n\necho \"Getting server initial tickets\"; > messages.log\n${kinit} --keytab=${keytab} ${server}@$R || { ec=1 ; eval \"${testfailed}\"; }\necho \"Listing tickets\"; > messages.log\n${klist} | grep \"Principal: ${server}\" > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Getting key for key that are a subset in keytab compared to kdb\"\n${kinit} --keytab=${keytab} kt-des3@${R}\n${klist} | grep \"Principal: kt-des3\" > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"initial tickets for deleted user test case\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword remove@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} delete remove@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"try getting ticket with deleted user\"; > messages.log\n${kgetcred} ${server}@${R} 2> /dev/null && { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"cross realm case (deleted user)\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword remove2@$R2 || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} krbtgt/${R}@${R2} 2> /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} delete remove2@${R2} || exit 1\n${kgetcred} ${server}@${R} 2> /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"rename user\"; > messages.log\n${kadmin} add -p foo --use-defaults rename@${R} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} rename rename@${R} rename2@${R} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename2@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n${kadmin} delete rename2@${R} || exit 1\n\necho \"rename user to another realm\"; > messages.log\n${kadmin} add -p foo --use-defaults rename@${R} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} rename rename@${R} rename@${R2} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename@${R2} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n${kadmin} delete rename@${R2} || exit 1\n\necho deleting all but aes enctypes on krbtgt\n${kadmin} del_enctype krbtgt/${R}@${R} ${enctype_sans_aes} || exit 1\n\necho deleting all but des enctypes on server-des3\n${kadmin} del_enctype ${server}-des3@${R} ${enctype_sans_des3} || exit 1\n${kadmin} ext -k ${keytab} ${server}-des3@${R} || exit 1\n\necho \"try all permutations (only aes)\"; > messages.log\nfor a in $enctypes; do\n\techo \"Getting client initial tickets ($a)\"; > messages.log\n\t${kinit} --enctype=$a --password-file=${objdir}/foopassword foo@${R} ||\\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\tfor b in $enctypes; do\n\t\techo \"Getting tickets ($a ->  $b)\"; > messages.log\n\t\t${kgetcred} -e $b ${server}@${R} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\n\t\techo \"Getting tickets ($a ->  $b) (server des3 only)\"; > messages.log\n\t\t${kgetcred} ${server}-des3@${R} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${test_ap_req} ${server}-des3@${R} ${keytab} ${cache} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\n\t\t${kdestroy} --credential=${server}@${R}\n\t\t${kdestroy} --credential=${server}-des3@${R}\n\tdone\n\t${kdestroy}\ndone\n\necho deleting all enctypes on krbtgt\n${kadmin} del_enctype krbtgt/${R}@${R} aes256-cts-hmac-sha1-96 || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"try initial ticket w/o and keys on krbtgt\"\n${kinit} --password-file=${objdir}/foopassword foo@${R} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"adding random aes key\"\n${kadmin} add_enctype -r krbtgt/${R}@${R} aes256-cts-hmac-sha1-96 || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"try initial ticket with random aes key on krbtgt\"\n${kinit} --password-file=${objdir}/foopassword foo@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\nrsa=yes\necdsa=yes\npkinit=no\nif ${hxtool} info | grep 'rsa: hx509 null RSA' > /dev/null ; then\n    rsa=no\nfi\nif ${hxtool} info | grep 'rand: not available' > /dev/null ; then\n    rsa=no\nfi\nif ${kinit} --help 2>&1 | grep \"CA certificates\" > /dev/null; then\n    pkinit=yes\nfi\n\nif ${hxtool} info | grep 'ecdsa: hcrypto null' > /dev/null ; then\n    ecdsa=no\nfi\n\n\n# If we support pkinit and have RSA, lets try that\nif test \"$pkinit\" = yes -a \"$rsa\" = yes ; then\n\n    echo \"try anonymous pkinit\"; > messages.log\n    ${kinit} --anonymous ${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n    ${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n    ${kdestroy}\n\n    for type in \"\" \"--pk-use-enckey\"; do\n\techo \"Trying pk-init (principal in certificate) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit.crt,${hx509_data}/pkinit.key bar@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n\techo \"Trying pk-init (principal in pki-mapping) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit.crt,${hx509_data}/pkinit.key foo@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n\techo \"Trying pk-init (password protected key) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit.crt,${hx509_data}/pkinit-pw.key --password-file=${objdir}/foopassword foo@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n\techo \"Trying pk-init (proxy cert) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit-proxy-chain.crt,${hx509_data}/pkinit-proxy.key foo@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n    done\n\n    if test \"$ecdsa\" = yes > /dev/null ; then\n\techo \"Trying pk-init (ec certificate)\"\n\t> messages.log\n\t${kinit} -C FILE:${hx509_data}/pkinit-ec.crt,${hx509_data}/pkinit-ec.key bar@${R} || \\\n\t    { ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\tgrep 'PK-INIT using ecdh' messages.log > /dev/null || \\\n\t    { ec=1 ; eval \"${testfailed}\"; }\n    fi\n\nelse\n\techo \"no pkinit (pkinit: $pkinit, rsa: $rsa)\"; > messages.log\nfi\n\necho \"tickets for impersonate test case\"; > messages.log\n${kinit} --forwardable --password-file=${objdir}/foopassword ${ps} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred_imp} --impersonate=bar@${R} ${ps} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_ap_req} ${ps} ${keytab} ${ocache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"  negative check\"\n${kgetcred_imp} --impersonate=bar@${R} foo@${R} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"test constrained delegation\"; > messages.log\n${kgetcred_imp} --forward --impersonate=bar@${R} ${ps} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} \\\n\t--out-cache=${o2cache} \\\n\t--delegation-credential-cache=${ocache} \\\n\t${server}@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"  try using the credential\"\n${test_ap_req} ${server}@${R} ${keytab} ${o2cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"  negative check\"\n${kgetcred} \\\n\t--out-cache=${o2cache} \\\n\t--delegation-credential-cache=${ocache} \\\n\tbar@${R} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"test constrained delegation impersonation (non forward)\"; > messages.log\nrm -f ocache.krb5\n${kimpersonate} -s ${ps} -c bar@${R} -t ${aesenctype} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} --out-cache=${o2cache} --delegation-credential-cache=${ocache} ${server}@${R} > /dev/null 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"test constrained delegation impersonation (missing KRB5SignedPath)\"; > messages.log\nrm -f ocache.krb5\n${kimpersonate} -s ${ps} -c bar@${R} -t ${aesenctype} -f forwardable || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} --out-cache=${o2cache} --delegation-credential-cache=${ocache} ${server}@${R} > /dev/null 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\n${kdestroy}\n\necho \"check renewing\" > messages.log\n${kinit} --renewable --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"kinit -R\"\n${kinit} -R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"check renewing MIT interface\" > messages.log\n${kinit} --renewable --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"test_renew\"\nenv KRB5CCNAME=${cache} ${test_renew} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"checking server aliases\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"Getting tickets\"; > messages.log\n${kgetcred} ${alias1}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} ${alias2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"   verify entry in keytab\"\n${test_ap_req} ${alias1}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   verify entry in keytab with any\"\n${test_ap_req} --server-any ${alias1}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   verify failure with alias entry\"\n${test_ap_req} ${alias2}@${R} ${keytab} ${cache} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   verify alias entry in keytab with any\"\n${test_ap_req} --server-any ${alias2}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"testing removal of keytab\"\n${ktutil} -k ${keytab} destroy || { ec=1 ; eval \"${testfailed}\"; }\ntest -f ${keytabfile} && { ec=1 ; eval \"${testfailed}\"; }\n\necho \"Checking client pw expire\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword \\\n        pw-expire@${R} 2>kinit-log.tmp|| \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\ngrep 'Your password will expire' kinit-log.tmp > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   kinit passes\"\n${test_gic} --client=pw-expire@${R} --password=foo > kinit-log.tmp 2>/dev/null\n${EGREP} \"^e type: 6\" kinit-log.tmp > /dev/null  || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   test_gic passes\"\n${kdestroy}\n\necho \"Checking password expiration\" ; > messages.log\n\nkinitpty=${objdir}/foopassword.rkpty\ncat > ${kinitpty} <<EOF\nexpect Password\npassword foo\\n\nexpect Password has expired\nexpect New password\npassword Foobar11\\n\nexpect password\npassword Foobar11\\n\nexpect Success: Password changed\nEOF\n\necho \"Checking client pw expire\"; > messages.log\n${rkpty} ${kinitpty} ${kinit} pw-expired@${R}|| \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\n${kdestroy}\n\n\necho \"killing kdc (${kdcpid}) kpasswdd (${kpasswddpid})\"\nsh ${leaks_kill} kdc $kdcpid || exit 1\nsh ${leaks_kill} kpasswdd $kpasswddpid || exit 1\n\ntrap \"\" EXIT\n\nexit $ec\n", "[libdefaults]\n\tdefault_realm = TEST.H5L.SE TEST2.H5L.SE\n\tno-addresses = TRUE\n\tallow_weak_crypto = @WEAK@\n\tdns_lookup_kdc = no\n\tdns_lookup_realm = no\n\n\n[appdefaults]\n\tpkinit_anchors = FILE:@srcdir@/../../lib/hx509/data/ca.crt\n\treconnect-min = 2s\n\treconnect-backoff = 2s\n\treconnect-max = 10s\n\n[realms]\n\tTEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t\tadmin_server = localhost:@admport@\n\t\tkpasswd_server = localhost:@pwport@\n\t}\n\tSUB.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tTEST2.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t\tkpasswd_server = localhost:@pwport@\n\t}\n\tTEST3.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tTEST4.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM5.FR = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM6.US = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM7.UK = {\n\t\tkdc = localhost:@port@\n\t}\n\tTEST-HTTP.H5L.SE = {\n\t\tkdc = http/localhost:@port@\n\t}\n\tH1.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tH2.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tH3.H2.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tH4.H2.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\n[domain_realm]\n\t.test.h5l.se = TEST.H5L.SE\n\t.sub.test.h5l.se = SUB.TEST.H5L.SE\n\t.h1.test.h5l.se = H1.TEST.H5L.SE\n\t.h2.test.h5l.se = H2.TEST.H5L.SE\n\t.h3.h2.test.h5l.se = H3.H2.TEST.H5L.SE\n\t.h4.h2.test.h5l.se = H4.H2.TEST.H5L.SE\n\t.example.com = TEST2.H5L.SE\n\tlocalhost = TEST.H5L.SE\n\t.localdomain = TEST.H5L.SE\n\tlocaldomain = TEST.H5L.SE\n\t.localdomain6 = TEST.H5L.SE\n\tlocaldomain6 = TEST.H5L.SE\n\t\n\n[kdc]\n\tenable-digest = true\n\tallow-anonymous = true\n\tdigests_allowed = chap-md5,digest-md5,ntlm-v1,ntlm-v1-session,ntlm-v2,ms-chap-v2\n        strict-nametypes = true\n\n\tenable-http = true\n\n\tenable-pkinit = true\n\tpkinit_identity = FILE:@srcdir@/../../lib/hx509/data/kdc.crt,@srcdir@/../../lib/hx509/data/kdc.key\n\tpkinit_anchors = FILE:@srcdir@/../../lib/hx509/data/ca.crt\n\tpkinit_pool = FILE:@srcdir@/../../lib/hx509/data/sub-ca.crt\n#\tpkinit_revoke = CRL:@srcdir@/../../lib/hx509/data/crl1.crl\n\tpkinit_mappings_file = @srcdir@/pki-mapping\n\tpkinit_allow_proxy_certificate = true\n\n\tdatabase = {\n\t\tlabel = { \n\t\t\tdbname = @db_type@:@objdir@/current-db@kdc@\n\t\t\trealm = TEST.H5L.SE\n\t\t\tmkey_file = @objdir@/mkey.file\n\t\t\tacl_file = @srcdir@/heimdal.acl\n\t\t\tlog_file = @objdir@/current@kdc@.log\n\t\t}\n\t\tlabel2 = { \n\t\t\tdbname = @db_type@:@objdir@/current-db@kdc@\n\t\t\trealm = TEST2.H5L.SE\n\t\t\tmkey_file = @objdir@/mkey.file\n\t\t\tacl_file = @srcdir@/heimdal.acl\n\t\t\tlog_file = @objdir@/current@kdc@.log\n\t\t}\n\t\tlabel3 = { \n\t\t\tdbname = sqlite:@objdir@/current-db@kdc@.sqlite3\n\t\t\trealm = SOME-REALM5.FR\n\t\t\tmkey_file = @objdir@/mkey.file\n\t\t\tacl_file = @srcdir@/heimdal.acl\n\t\t\tlog_file = @objdir@/current@kdc@.log\n\t\t}\n\t}\n\n\tsignal_socket = @objdir@/signal\n\tiprop-stats = @objdir@/iprop-stats\n\tiprop-acl = @srcdir@/iprop-acl\n        log-max-size = 40000\n\n[hdb]\n\tdb-dir = @objdir@\n\n[logging]\n\tkdc = 0-/FILE:@objdir@/messages.log\n\tkrb5 = 0-/FILE:@objdir@/messages.log\n\tdefault = 0-/FILE:@objdir@/messages.log\n\n# If you are doing preformance measurements on OSX you want to change\n# the kdc LOG line from = to - below to keep the FILE open and avoid\n# open/write/close which is blocking (rdar:// ) on OSX.\n#\tkdc = 0-/FILE=@objdir@/messages.log\n\n[kadmin]\n\tsave-password = true\n\tdefault_key_rules = {\n\t\t*/des3-only@* = des3-cbc-sha1:pw-salt\n\t\t*/aes-only@* = aes256-cts-hmac-sha1-96:pw-salt\n\t}\n\t@dk@\n\n[capaths]\n\tTEST.H5L.SE = {\n\t\tTEST2.H5L.SE = .\n\t\tSOME-REALM5.FR = 1\n\t\tTEST3.H5L.SE = TEST2.H5L.SE\n\t\tTEST4.H5L.SE = TEST2.H5L.SE\n\t\tTEST4.H5L.SE = TEST3.H5L.SE\n\t\tSOME-REALM6.US = SOME-REALM5.FR\n\t\tSOME-REALM7.UK = SOME-REALM6.US\n\t\tSOME-REALM7.UK = SOME-REALM5.FR\n\t}\n        H4.H2.TEST.H5L.SE = {\n                H1.TEST.H5L.SE = H3.H2.TEST.H5L.SE\n                H1.TEST.H5L.SE = H2.TEST.H5L.SE\n                H1.TEST.H5L.SE = TEST.H5L.SE\n\n                TEST.H5L.SE = H3.H2.TEST.H5L.SE\n                TEST.H5L.SE = H2.TEST.H5L.SE\n\n                H2.TEST.H5L.SE = H3.H2.TEST.H5L.SE\n        }\n"], "fixing_code": ["Release Notes - Heimdal - Version Heimdal 7.3\n\n Security\n\n - Fix transit path validation.  Commit f469fc6 (2010-10-02) inadvertently\n   caused the previous hop realm to not be added to the transit path\n   of issued tickets.  This may, in some cases, enable bypass of capath\n   policy in Heimdal versions 1.5 through 7.2.\n\n   Note, this may break sites that rely on the bug.  With the bug some\n   incomplete [capaths] worked, that should not have.  These may now break\n   authentication in some cross-realm configurations.\n   (CVE-2017-6594)\n\nRelease Notes - Heimdal - Version Heimdal 7.2\n\n Bug fixes\n - Portability improvements\n - More strict parsing of encoded URI components in HTTP KDC\n - Fixed memory leak in malloc error recovery in NTLM GSSAPI mechanism\n - Avoid overly specific CPU info in krb5-config in aid of reproducible builds\n - Don't do AFS string-to-key tests when feature is disabled\n - Skip mdb_stat test when the command is not available\n - Windows: update SHA2 timestamp server\n - hdb: add missing export hdb_generate_key_set_password_with_ks_tuple\n - Fix signature of hdb_generate_key_set_password()\n - Windows: enable KX509 support in the KDC\n - kdc: fix kx509 service principal match\n - iprop: handle case where master sends nothing new\n - ipropd-slave: fix incorrect error codes\n - Allow choice of sqlite for HDB pref\n - check-iprop: don't fail to kill daemons\n - roken: pidfile -> rk_pidfile\n - kdc: _kdc_do_kx509 fix use after free error\n - Do not detect x32 as 64-bit platform.\n - No sys/ttydefaults.h on CYGWIN\n - Fix check-iprop races\n - roken_detach_prep() close pipe\n\nRelease Notes - Heimdal - Version Heimdal 7.1\n\n Security\n\n - kx509 realm-chopping security bug\n - non-authorization of alias additions/removals in kadmind\n   (CVE-2016-2400)\n\n Feature\n\n - iprop has been revamped to fix a number of race conditions that could\n   lead to inconsistent replication\n - Hierarchical capath support\n - AES Encryption with HMAC-SHA2 for Kerberos 5\n   draft-ietf-kitten-aes-cts-hmac-sha2-11\n - hcrypto is now thread safe on all platforms\n - libhcrypto has new backends: CNG (Windows), PKCS#11 (mainly for\n   Solaris), and OpenSSL.  OpenSSL is now a first-class libhcrypto backend.\n   OpenSSL 1.0.x and 1.1 are both supported. AES-NI used when supported by\n   backend\n - HDB now supports LMDB\n - Thread support on Windows\n - RFC 6113  Generalized Framework for Kerberos Pre-Authentication (FAST)\n - New GSS APIs:\n   . gss_localname\n - Allow setting what encryption types a principal should have with\n   [kadmin] default_key_rules, see krb5.conf manpage for more info\n - Unify libhcrypto with LTC (libtomcrypto)\n - asn1_compile 64-bit INTEGER functionality\n - HDB key history support including --keepold kadmin password option\n - Improved cross-realm key rollover safety\n - New krb5_kuserok() and krb5_aname_to_localname() plug-in interfaces\n - Improved MIT compatibility\n   . kadm5 API\n   . Migration from MIT KDB via \"mitdb\" HDB backend\n   . Capable of writing the HDB in MIT dump format\n - Improved Active Directory interoperability\n   . Enctype selection issues for PAC and other authz-data signatures\n   . Cross realm key rollover (kvno 0)\n - New [kdc] enctype negotiation configuration:\n   . tgt-use-strongest-session-key\n   . svc-use-strongest-session-key\n   . preauth-use-strongest-session-key\n   . use-strongest-server-key\n - The KDC process now uses a multi-process model improving\n   resiliency and performance\n - Allow batch-mode kinit with password file\n - SIGINFO support added to kinit cmd\n - New kx509 configuration options:\n   . kx509_ca\n   . kca_service\n   . kx509_include_pkinit_san\n   . kx509_template\n - Improved Heimdal library/plugin version safety\n - Name canonicalization\n   . DNS resolver searchlist\n   . Improved referral support\n   . Support host:port host-based services\n - Pluggable libheimbase interface for DBs\n - Improve IPv6 Support\n - LDAP\n   . Bind DN and password\n   . Start TLS\n - klist --json\n - DIR credential cache type\n - Updated upstream SQLite and libedit\n - Removed legacy applications: ftp, kx, login, popper, push, rcp, rsh,\n   telnet, xnlock\n - Completely remove RAND_egd support\n - Moved kadmin and ktutil to /usr/bin\n - Stricter fcache checks (see fcache_strict_checking krb5.conf setting)\n    . use O_NOFOLLOW\n    . don't follow symlinks\n    . require cache files to be owned by the user\n    . require sensible permissions (not group/other readable)\n - Implemented gss_store_cred()\n - Many more\n\n Bug fixes\n - iprop has been revamped to fix a number of race conditions that could\n   lead to data loss\n - Include non-loopback addresses assigned to loopback interfaces\n   when requesting tickets with addresses\n - KDC 1DES session key selection (for AFS rxkad-k5 compatibility)\n - Keytab file descriptor and lock leak\n - Credential cache corruption bugs\n   (NOTE: The FILE ccache is still not entirely safe due to the\n   fundamentally unsafe design of POSIX file locking)\n - gss_pseudo_random() interop bug\n - Plugins are now preferentially loaded from the run-time install tree\n - Reauthentication after password change in init_creds_password\n - Memory leak in the client kadmin library\n - TGS client requests renewable/forwardable/proxiable when possible\n - Locking issues in DB1 and DB3 HDB backends\n - Master HDB can remain locked while waiting for network I/O\n - Renewal/refresh logic when kinit is provided with a command\n - KDC handling of enterprise principals\n - Use correct bit for anon-pkinit\n - Many more\n\n Acknowledgements\n\n This release of Heimdal includes contributions from:\n\n    Abhinav Upadhyay        Heath Kehoe             Nico Williams\n    Andreas Schneider       Henry Jacques           Patrik Lundin\n    Andrew Bartlett         Howard Chu              Philip Boulain\n    Andrew Tridgell         Igor Sobrado            Ragnar Sundblad\n    Antoine Jacoutot        Ingo Schwarze           Remi Ferrand\n    Arran Cudbard-Bell      Jakub \u010cajka             Rod Widdowson\n    Arvid Requate           James Le Cuirot         Rok Pape\u017e\n    Asanka Herath           James Lee               Roland C. Dowdeswell\n    Ben Kaduk               Jeffrey Altman          Ross L Richardson\n    Benjamin Kaduk          Jeffrey Clark           Russ Allbery\n    Bernard Spil            Jeffrey Hutzelman       Samuel Cabrero\n    Brian May               Jelmer Vernooij         Samuel Thibault\n    Chas Williams           Ken Dreyer              Santosh Kumar Pradhan\n    Chaskiel Grundman       Kiran S J               Sean Davis\n    Dana Koch               Kumar Thangavelu        Sergio Gelato\n    Daniel Schepler         Landon Fuller           Simon Wilkinson\n    David Mulder            Linus Nordberg          Stef Walter\n    Douglas Bagnall         Love H\u00f6rnquist \u00c5strand  Stefan Metzmacher\n    Ed Maste                Luke Howard             Steffen Jaeckel\n    Eray Aslan              Magnus Ahltorp          Timothy Pearson\n    Florian Best            Marc Balmer             Tollef Fog Heen\n    Fredrik Pettai          Marcin Cie\u015blak          Tony Acero\n    Greg Hudson             Marco Molteni           Uri Simchoni\n    Gustavo Zacarias        Matthieu Hautreux       Viktor Dukhovni\n    G\u00fcnther Deschner        Michael Meffie          Volker Lendecke\n    Harald Barth            Moritz Lenz\n\nRelease Notes - Heimdal - Version Heimdal 1.5.3\n\n Bug fixes\n - Fix leaking file descriptors in KDC\n - Better socket/timeout handling in libkrb5\n - General bug fixes\n - Build fixes\n\nRelease Notes - Heimdal - Version Heimdal 1.5.2\n\n Security fixes\n - CVE-2011-4862 Buffer overflow in libtelnet/encrypt.c in telnetd - escalation of privilege\n - Check that key types strictly match - denial of service\n\nRelease Notes - Heimdal - Version Heimdal 1.5.1\n\n Bug fixes\n - Fix building on Solaris, requires c99\n - Fix building on Windows\n - Build system updates\n\nRelease Notes - Heimdal - Version Heimdal 1.5\n\nNew features\n\n - Support GSS name extensions/attributes\n - SHA512 support\n - No Kerberos 4 support\n - Basic support for MIT Admin protocol (SECGSS flavor)\n   in kadmind (extract keytab)\n - Replace editline with libedit\n\nRelease Notes - Heimdal - Version Heimdal 1.4\n\n New features\n \n - Support for reading MIT database file directly\n - KCM is polished up and now used in production\n - NTLM first class citizen, credentials stored in KCM\n - Table driven ASN.1 compiler, smaller!, not enabled by default\n - Native Windows client support\n\nNotes\n\n - Disabled write support NDBM hdb backend (read still in there) since\n   it can't handle large records, please migrate to a diffrent backend\n   (like BDB4)\n\nRelease Notes - Heimdal - Version Heimdal 1.3.3\n\n Bug fixes\n - Check the GSS-API checksum exists before trying to use it [CVE-2010-1321]\n - Check NULL pointers before dereference them [kdc]\n\nRelease Notes - Heimdal - Version Heimdal 1.3.2\n\n Bug fixes\n\n - Don't mix length when clearing hmac (could memset too much)\n - More paranoid underrun checking when decrypting packets\n - Check the password change requests and refuse to answer empty packets\n - Build on OpenSolaris \n - Renumber AD-SIGNED-TICKET since it was stolen from US\n - Don't cache /dev/*random file descriptor, it doesn't get unloaded\n - Make C++ safe\n - Misc warnings\n\nRelease Notes - Heimdal - Version Heimdal 1.3.1\n\n Bug fixes\n\n - Store KDC offset in credentials\n - Many many more bug fixes\n\nRelease Notes - Heimdal - Version Heimdal 1.3.1\n\n New features\n\n - Make work with OpenLDAPs krb5 overlay\n\nRelease Notes - Heimdal - Version Heimdal 1.3\n\n New features\n\n - Partial support for MIT kadmind rpc protocol in kadmind\n - Better support for finding keytab entries when using SPN aliases in the KDC\n - Support BER in ASN.1 library (needed for CMS)\n - Support decryption in Keychain private keys\n - Support for new sqlite based credential cache\n - Try both KDC referals and the common DNS reverse lookup in GSS-API\n - Fix the KCM to not leak resources on failure\n - Add IPv6 support to iprop\n - Support localization of error strings in\n   kinit/klist/kdestroy and Kerberos library\n - Remove Kerberos 4 support in application (still in KDC)\n - Deprecate DES\n - Support i18n password in windows domains (using UTF-8)\n - More complete API emulation of OpenSSL in hcrypto\n - Support for ECDSA and ECDH when linking with OpenSSL\n\n API changes\n\n - Support for settin friendly name on credential caches\n - Move to using doxygen to generate documentation.\n - Sprinkling __attribute__((__deprecated__)) for old function to be removed\n - Support to export LAST-REQUST information in AS-REQ\n - Support for client deferrals in in AS-REQ\n - Add seek support for krb5_storage.\n - Support for split AS-REQ, first step for IA-KERB\n - Fix many memory leaks and bugs\n - Improved regression test\n - Support krb5_cccol\n - Switch to krb5_set_error_message\n - Support krb5_crypto_*_iov\t\n - Switch to use EVP for most function\n - Use SOCK_CLOEXEC and O_CLOEXEC (close on exec)\n - Add support for GSS_C_DELEG_POLICY_FLAG\n - Add krb5_cc_[gs]et_config to store data in the credential caches\n - PTY testing application\n\nBugfixes\n - Make building on AIX6 possible.\n - Bugfixes in LDAP KDC code to make it more stable\n - Make ipropd-slave reconnect when master down gown\n\n\nRelease Notes - Heimdal - Version Heimdal 1.2.1\n\n* Bug\n\n  [HEIMDAL-147] - Heimdal 1.2 not compiling on Solaris\n  [HEIMDAL-151] - Make canned tests work again after cert expired\n  [HEIMDAL-152] - iprop test: use full hostname to avoid realm\n                  resolving errors\n  [HEIMDAL-153] - ftp: Use the correct length for unmap, msync\n\nRelease Notes - Heimdal - Version Heimdal 1.2\n\n* Bug\n\n  [HEIMDAL-10] - Follow-up on bug report for SEGFAULT in\n  \t\t gss_display_name/gss_export_name when using SPNEGO\n  [HEIMDAL-15] - Re: [Heimdal-bugs] potential bug in Heimdal 1.1\n  [HEIMDAL-17] - Remove support for depricated [libdefaults]capath\n  [HEIMDAL-52] - hdb overwrite aliases for db databases\n  [HEIMDAL-54] - Two issues which affect credentials delegation\n  [HEIMDAL-58] - sockbuf.c calls setsockopt with bad args\n  [HEIMDAL-62] - Fix printing of sig_atomic_t\n  [HEIMDAL-87] - heimdal 1.1 not building under cygwin in hcrypto\n  [HEIMDAL-105] - rcp: sync rcp with upstream bsd rcp codebase\n  [HEIMDAL-117] - Use libtool to detect symbol versioning (Debian Bug#453241)\n\n* Improvement\n  [HEIMDAL-67] - Fix locking and store credential in atomic writes\n                 in the FILE credential cache\n  [HEIMDAL-106] - make compile on cygwin again\n  [HEIMDAL-107] - Replace old random key generation in des module\n                  and use it with RAND_ function instead\n  [HEIMDAL-115] - Better documentation and compatibility in hcrypto\n                  in regards to OpenSSL\n\n* New Feature\n  [HEIMDAL-3] - pkinit alg agility PRF test vectors\n  [HEIMDAL-14] - Add libwind to Heimdal\n  [HEIMDAL-16] - Use libwind in hx509\n  [HEIMDAL-55] - Add flag to krb5 to not add GSS-API INT|CONF to\n                 the negotiation\n  [HEIMDAL-74] - Add support to report extended error message back\n                 in AS-REQ to support windows clients\n  [HEIMDAL-116] - test pty based application (using rkpty)\n  [HEIMDAL-120] - Use new OpenLDAP API (older deprecated)\n\n* Task\n  [HEIMDAL-63] - Dont try key usage KRB5_KU_AP_REQ_AUTH for TGS-REQ.\n                 This drop compatibility with pre 0.3d KDCs.\n  [HEIMDAL-64] - kcm: first implementation of kcm-move-cache\n  [HEIMDAL-65] - Failed to compile with --disable-pk-init\n  [HEIMDAL-80] - verify that [VU#162289]: gcc silently discards some\n                 wraparound checks doesn't apply to Heimdal\n\nChanges in release 1.1\n\n * Read-only PKCS11 provider built-in to hx509.\n\n * Documentation for hx509, hcrypto and ntlm libraries improved.\n\n * Better compatibilty with Windows 2008 Server pre-releases and Vista.\n\n * Mac OS X 10.5 support for native credential cache.\n\n * Provide pkg-config file for Heimdal (heimdal-gssapi.pc).\n\n * Bug fixes.\n\nChanges in release 1.0.2\n\n* Ubuntu packages.\n\n* Bug fixes.\n\nChanges in release 1.0.1\n\n * Serveral bug fixes to iprop.\n\n * Make work on platforms without dlopen.\n\n * Add RFC3526 modp group14 as default.\n\n * Handle [kdc] database = { } entries without realm = stanzas.\n\n * Make krb5_get_renewed_creds work.\n\n * Make kaserver preauth work again.\n\n * Bug fixes.\n\nChanges in release 1.0\n\n * Add gss_pseudo_random() for mechglue and krb5.\n\n * Make session key for the krbtgt be selected by the best encryption\n   type of the client.\n\n * Better interoperability with other PK-INIT implementations.\n\n * Inital support for Mac OS X Keychain for hx509.\n\n * Alias support for inital ticket requests.\n\n * Add symbol versioning to selected libraries on platforms that uses\n   GNU link editor: gssapi, hcrypto, heimntlm, hx509, krb5, and libkdc.\n\n * New version of imath included in hcrypto.\n\n * Fix memory leaks.\n\n * Bugs fixes.\n\nChanges in release 0.8.1\n\n * Make ASN.1 library less paranoid to with regard to NUL in string to\n   make it inter-operate with MIT Kerberos again.\n\n * Make GSS-API library work again when using gss_acquire_cred\n\n * Add symbol versioning to libgssapi when using GNU ld.\n\n * Fix memory leaks \n\n * Bugs fixes\n\nChanges in release 0.8\n\n * PK-INIT support.\n\n * HDB extensions support, used by PK-INIT.\n\n * New ASN.1 compiler.\n\n * GSS-API mechglue from FreeBSD.\n\n * Updated SPNEGO to support RFC4178.\n\n * Support for Cryptosystem Negotiation Extension (RFC 4537).\n\n * A new X.509 library (hx509) and related crypto functions.\n\n * A new ntlm library (heimntlm) and related crypto functions.\n\n * Updated the built-in crypto library with bignum support using\n   imath, support for RSA and DH and renamed it to libhcrypto.\n\n * Subsystem in the KDC, digest, that will perform the digest\n   operation in the KDC, currently supports: CHAP, MS-CHAP-V2, SASL\n   DIGEST-MD5 NTLMv1 and NTLMv2.\n\n * KDC will return the \"response too big\" error to force TCP retries\n   for large (default 1400 bytes) UDP replies.  This is common for\n   PK-INIT requests.\n\n * Libkafs defaults to use 2b tokens.\n\n * Default to use the API cache on Mac OS X.\n\n * krb5_kuserok() also checks ~/.k5login.d directory for acl files,\n   see manpage for krb5_kuserok for description.\n\n * Many, many, other updates to code and info manual and manual pages.\n\n * Bug fixes\n\nChanges in release 0.7.2\n\n* Fix security problem in rshd that enable an attacker to overwrite\n  and change ownership of any file that root could write.\n\n* Fix a DOS in telnetd. The attacker could force the server to crash\n  in a NULL de-reference before the user logged in, resulting in inetd\n  turning telnetd off because it forked too fast.\n\n* Make gss_acquire_cred(GSS_C_ACCEPT) check that the requested name\n  exists in the keytab before returning success. This allows servers\n  to check if its even possible to use GSSAPI.\n\n* Fix receiving end of token delegation for GSS-API. It still wrongly\n  uses subkey for sending for compatibility reasons, this will change\n  in 0.8.\n\n* telnetd, login and rshd are now more verbose in logging failed and\n  successful logins.\n\n* Bug fixes\n\nChanges in release 0.7.1\n\n* Bug fixes\n\nChanges in release 0.7\n\n * Support for KCM, a process based credential cache\n\n * Support CCAPI credential cache\n\n * SPNEGO support\n\n * AES (and the gssapi conterpart, CFX) support\n\n * Adding new and improve old documentation\n\n * Bug fixes\n\nChanges in release 0.6.6\n\n* Fix security problem in rshd that enable an attacker to overwrite\n  and change ownership of any file that root could write.\n\n* Fix a DOS in telnetd. The attacker could force the server to crash\n  in a NULL de-reference before the user logged in, resulting in inetd\n  turning telnetd off because it forked too fast.\n\nChanges in release 0.6.5\n\n * fix vulnerabilities in telnetd\n\n * unbreak Kerberos 4 and kaserver\n\nChanges in release 0.6.4\n\n * fix vulnerabilities in telnet\n\n * rshd: encryption without a separate error socket should now work\n\n * telnet now uses appdefaults for the encrypt and forward/forwardable\n   settings\n\n * bug fixes\n\nChanges in release 0.6.3\n\n * fix vulnerabilities in ftpd\n\n * support for linux AFS /proc \"syscalls\"\n\n * support for RFC3244 (Windows 2000 Kerberos Change/Set Password) in\n   kpasswdd\n\n * fix possible KDC denial of service\n\n * bug fixes\n\nChanges in release 0.6.2\n\n * Fix possible buffer overrun in v4 kadmin (which now defaults to off)\n\nChanges in release 0.6.1\n\n * Fixed ARCFOUR suppport\n\n * Cross realm vulnerability\n\n * kdc: fix denial of service attack\n\n * kdc: stop clients from renewing tickets into the future\n\n * bug fixes\n\t\nChanges in release 0.6\n\n* The DES3 GSS-API mechanism has been changed to inter-operate with\n  other GSSAPI implementations. See man page for gssapi(3) how to turn\n  on generation of correct MIC messages. Next major release of heimdal \n  will generate correct MIC by default.\n\n* More complete GSS-API support\n\n* Better AFS support: kdc (524) supports 2b; 524 in kdc and AFS\n  support in applications no longer requires Kerberos 4 libs\n\n* Kerberos 4 support in kdc defaults to turned off (includes ka and 524)\n\n* other bug fixes\n\nChanges in release 0.5.2\n\n * kdc: add option for disabling v4 cross-realm (defaults to off)\n\n * bug fixes\n\nChanges in release 0.5.1\n\n * kadmind: fix remote exploit\n\n * kadmind: add option to disable kerberos 4\n\n * kdc: make sure kaserver token life is positive\n\n * telnet: use the session key if there is no subkey\n\n * fix EPSV parsing in ftp\n\n * other bug fixes\n\nChanges in release 0.5\n\n * add --detach option to kdc\n\n * allow setting forward and forwardable option in telnet from\n   .telnetrc, with override from command line\n\n * accept addresses with or without ports in krb5_rd_cred\n\n * make it work with modern openssl\n\n * use our own string2key function even with openssl (that handles weak\n   keys incorrectly)\n\n * more system-specific requirements in login\n\n * do not use getlogin() to determine root in su\n\n * telnet: abort if telnetd does not support encryption\n\n * update autoconf to 2.53\n\n * update config.guess, config.sub\n\n * other bug fixes\n\nChanges in release 0.4e\n\n * improve libcrypto and database autoconf tests\n\n * do not care about salting of server principals when serving v4 requests\n\n * some improvements to gssapi library\n\n * test for existing compile_et/libcom_err\n\n * portability fixes\n\n * bug fixes\n\nChanges in release 0.4d\n\n * fix some problems when using libcrypto from openssl\n\n * handle /dev/ptmx `unix98' ptys on Linux\n\n * add some forgotten man pages\n\n * rsh: clean-up and add man page\n\n * fix -A and -a in builtin-ls in tpd\n\n * fix building problem on Irix\n\n * make `ktutil get' more efficient\n\n * bug fixes\n\nChanges in release 0.4c\n\n * fix buffer overrun in telnetd\n\n * repair some of the v4 fallback code in kinit\n\n * add more shared library dependencies\n\n * simplify and fix hprop handling of v4 databases\n\n * fix some building problems (osf's sia and osfc2 login)\n\n * bug fixes\n\nChanges in release 0.4b\n\n * update the shared library version numbers correctly\n\nChanges in release 0.4a\n\n * corrected key used for checksum in mk_safe, unfortunately this\n   makes it backwards incompatible\n\n * update to autoconf 2.50, libtool 1.4\n\n * re-write dns/config lookups (krb5_krbhst API)\n\n * make order of using subkeys consistent\n\n * add man page links\n\n * add more man pages\n\n * remove rfc2052 support, now only rfc2782 is supported\n\n * always build with kaserver protocol support in the KDC (assuming\n   KRB4 is enabled) and support for reading kaserver databases in\n   hprop\n\nChanges in release 0.3f\n\n * change default keytab to ANY:FILE:/etc/krb5.keytab,krb4:/etc/srvtab,\n   the new keytab type that tries both of these in order (SRVTAB is\n   also an alias for krb4:)\n\n * improve error reporting and error handling (error messages should\n   be more detailed and more useful)\n\n * improve building with openssl\n\n * add kadmin -K, rcp -F \n\n * fix two incorrect weak DES keys\n\n * fix building of kaserver compat in KDC\n\n * the API is closer to what MIT krb5 is using\n\n * more compatible with windows 2000\n\n * removed some memory leaks\n\n * bug fixes\n\nChanges in release 0.3e\n\n * rcp program included\n\n * fix buffer overrun in ftpd\n\n * handle omitted sequence numbers as zeroes to handle MIT krb5 that\n   cannot generate zero sequence numbers\n\n * handle v4 /.k files better\n\n * configure/portability fixes\n\n * fixes in parsing of options to kadmin (sub-)commands\n\n * handle errors in kadmin load better\n\n * bug fixes\n\nChanges in release 0.3d\n\n * add krb5-config\n\n * fix a bug in 3des gss-api mechanism, making it compatible with the\n   specification and the MIT implementation\n\n * make telnetd only allow a specific list of environment variables to\n   stop it from setting `sensitive' variables\n\n * try to use an existing libdes\n\n * lib/krb5, kdc: use correct usage type for ap-req messages.  This\n   should improve compatability with MIT krb5 when using 3DES\n   encryption types\n\n * kdc: fix memory allocation problem\n\n * update config.guess and config.sub\n\n * lib/roken: more stuff implemented\n\n * bug fixes and portability enhancements\n\nChanges in release 0.3c\n\n * lib/krb5: memory caches now support the resolve operation\n\n * appl/login: set PATH to some sane default\n\n * kadmind: handle several realms\n\n * bug fixes (including memory leaks)\n\nChanges in release 0.3b\n\n * kdc: prefer default-salted keys on v5 requests\n\n * kdc: lowercase hostnames in v4 mode\n\n * hprop: handle more types of MIT salts\n\n * lib/krb5: fix memory leak\n\n * bug fixes\n\nChanges in release 0.3a:\n\n * implement arcfour-hmac-md5 to interoperate with W2K\n\n * modularise the handling of the master key, and allow for other\n   encryption types. This makes it easier to import a database from\n   some other source without having to re-encrypt all keys.\n\n * allow for better control over which encryption types are created\n\n * make kinit fallback to v4 if given a v4 KDC\n\n * make klist work better with v4 and v5, and add some more MIT\n   compatibility options\n\n * make the kdc listen on the krb524 (4444) port for compatibility\n   with MIT krb5 clients\n\n * implement more DCE/DFS support, enabled with --enable-dce, see\n   lib/kdfs and appl/dceutils\n\n * make the sequence numbers work correctly\n\n * bug fixes\n\nChanges in release 0.2t:\n\n * bug fixes\n\nChanges in release 0.2s:\n\n * add OpenLDAP support in hdb\n\n * login will get v4 tickets when it receives forwarded tickets\n\n * xnlock supports both v5 and v4\n\n * repair source routing for telnet\n\n * fix building problems with krb4 (krb_mk_req)\n\n * bug fixes\n\nChanges in release 0.2r:\n\n * fix realloc memory corruption bug in kdc\n\n * `add --key' and `cpw --key' in kadmin\n\n * klist supports listing v4 tickets\n\n * update config.guess and config.sub\n\n * make v4 -> v5 principal name conversion more robust\n\n * support for anonymous tickets\n\n * new man-pages\n\n * telnetd: do not negotiate KERBEROS5 authentication if there's no keytab.\n\n * use and set expiration and not password expiration when dumping\n   to/from ka server databases / krb4 databases\n\n * make the code happier with 64-bit time_t\n\n * follow RFC2782 and by default do not look for non-underscore SRV names\n\nChanges in release 0.2q:\n\n * bug fix in tcp-handling in kdc\n\n * bug fix in expand_hostname\n\nChanges in release 0.2p:\n\n * bug fix in `kadmin load/merge'\n\n * bug fix in krb5_parse_address\n\nChanges in release 0.2o:\n\n * gss_{import,export}_sec_context added to libgssapi\n\n * new option --addresses to kdc (for listening on an explicit set of\n   addresses)\n\n * bug fixes in the krb4 and kaserver emulation part of the kdc\n\n * other bug fixes\n\nChanges in release 0.2n:\n\n * more robust parsing of dump files in kadmin\n * changed default timestamp format for log messages to extended ISO\n   8601 format (Y-M-DTH:M:S)\n * changed md4/md5/sha1 APIes to be de-facto `standard'\n * always make hostname into lower-case before creating principal\n * small bits of more MIT-compatability\n * bug fixes\n\nChanges in release 0.2m:\n\n * handle glibc's getaddrinfo() that returns several ai_canonname\n\n * new endian test\n\n * man pages fixes\n\nChanges in release 0.2l:\n\n * bug fixes\n\nChanges in release 0.2k:\n\n * better IPv6 test\n\n * make struct sockaddr_storage in roken work better on alphas\n\n * some missing [hn]to[hn]s fixed.\n\n * allow users to change their own passwords with kadmin (with initial\n   tickets)\n\n * fix stupid bug in parsing KDC specification\n\n * add `ktutil change' and `ktutil purge'\n\nChanges in release 0.2j:\n\n * builds on Irix\n\n * ftpd works in passive mode\n\n * should build on cygwin\n\n * work around broken IPv6-code on OpenBSD 2.6, also add configure\n   option --disable-ipv6\n\nChanges in release 0.2i:\n\n * use getaddrinfo in the missing places.\n\n * fix SRV lookup for admin server\n\n * use get{addr,name}info everywhere.  and implement it in terms of\n   getipnodeby{name,addr} (which uses gethostbyname{,2} and\n   gethostbyaddr)\n\nChanges in release 0.2h:\n\n * fix typo in kx (now compiles)\n\nChanges in release 0.2g:\n\n * lots of bug fixes:\n   * push works\n   * repair appl/test programs\n   * sockaddr_storage works on solaris (alignment issues)\n   * works better with non-roken getaddrinfo\n   * rsh works\n   * some non standard C constructs removed\n\nChanges in release 0.2f:\n\n * support SRV records for kpasswd\n * look for both _kerberos and krb5-realm when doing host -> realm mapping\n\nChanges in release 0.2e:\n\n * changed copyright notices to remove `advertising'-clause.\n * get{addr,name}info added to roken and used in the other code\n   (this makes things work much better with hosts with both v4 and v6\n    addresses, among other things)\n * do pre-auth for both password and key-based get_in_tkt\n * support for having several databases\n * new command `del_enctype' in kadmin\n * strptime (and new strftime) add to roken\n * more paranoia about finding libdb\n * bug fixes\n\nChanges in release 0.2d:\n\n * new configuration option [libdefaults]default_etypes_des\n * internal ls in ftpd builds without KRB4\n * kx/rsh/push/pop_debug tries v5 and v4 consistenly\n * build bug fixes\n * other bug fixes\n\nChanges in release 0.2c:\n\n * bug fixes (see ChangeLog's for details)\n\nChanges in release 0.2b:\n\n * bug fixes\n * actually bump shared library versions\n\nChanges in release 0.2a:\n\n * a new program verify_krb5_conf for checking your /etc/krb5.conf\n * add 3DES keys when changing password\n * support null keys in database\n * support multiple local realms\n * implement a keytab backend for AFS KeyFile's\n * implement a keytab backend for v4 srvtabs\n * implement `ktutil copy'\n * support password quality control in v4 kadmind\n * improvements in v4 compat kadmind\n * handle the case of having the correct cred in the ccache but with\n   the wrong encryption type better\n * v6-ify the remaining programs.\n * internal ls in ftpd\n * rename strcpy_truncate/strcat_truncate to strlcpy/strlcat\n * add `ank --random-password' and `cpw --random-password' in kadmin\n * some programs and documentation for trying to talk to a W2K KDC\n * bug fixes\n\nChanges in release 0.1m:\n\n * support for getting default from krb5.conf for kinit/kf/rsh/telnet.\n   From Miroslav Ruda <ruda@ics.muni.cz>\n * v6-ify hprop and hpropd\n * support numeric addresses in krb5_mk_req\n * shadow support in login and su. From Miroslav Ruda <ruda@ics.muni.cz>\n * make rsh/rshd IPv6-aware\n * make the gssapi sample applications better at reporting errors\n * lots of bug fixes\n * handle systems with v6-aware libc and non-v6 kernels (like Linux\n   with glibc 2.1) better\n * hide failure of ERPT in ftp\n * lots of bug fixes\n\nChanges in release 0.1l:\n\n * make ftp and ftpd IPv6-aware\n * add inet_pton to roken\n * more IPv6-awareness\n * make mini_inetd v6 aware\n\nChanges in release 0.1k:\n\n * bump shared libraries versions\n * add roken version of inet_ntop\n * merge more changes to rshd\n\nChanges in release 0.1j:\n\n * restore back to the `old' 3DES code.  This was supposed to be done\n   in 0.1h and 0.1i but I did a CVS screw-up.\n * make telnetd handle v6 connections\n\nChanges in release 0.1i:\n\n * start using `struct sockaddr_storage' which simplifies the code\n   (with a fallback definition if it's not defined)\n * bug fixes (including in hprop and kf)\n * don't use mawk which seems to mishandle roken.awk\n * get_addrs should be able to handle v6 addresses on Linux (with the\n   required patch to the Linux kernel -- ask within)\n * rshd builds with shadow passwords\n\nChanges in release 0.1h:\n\n * kf: new program for forwarding credentials\n * portability fixes\n * make forwarding credentials work with MIT code\n * better conversion of ka database\n * add etc/services.append\n * correct `modified by' from kpasswdd\n * lots of bug fixes\n\nChanges in release 0.1g:\n\n * kgetcred: new program for explicitly obtaining tickets\n * configure fixes\n * krb5-aware kx\n * bug fixes\n\nChanges in release 0.1f;\n\n * experimental support for v4 kadmin protokoll in kadmind\n * bug fixes\n\nChanges in release 0.1e:\n\n * try to handle old DCE and MIT kdcs\n * support for older versions of credential cache files and keytabs\n * postdated tickets work\n * support for password quality checks in kpasswdd\n * new flag --enable-kaserver for kdc\n * renew fixes\n * prototype su program\n * updated (some) manpages\n * support for KDC resource records\n * should build with --without-krb4\n * bug fixes\n\nChanges in release 0.1d:\n\n * Support building with DB2 (uses 1.85-compat API)\n * Support krb5-realm.DOMAIN in DNS\n * new `ktutil srvcreate'\n * v4/kafs support in klist/kdestroy\n * bug fixes\n\nChanges in release 0.1c:\n\n * fix ASN.1 encoding of signed integers\n * somewhat working `ktutil get'\n * some documentation updates\n * update to Autoconf 2.13 and Automake 1.4\n * the usual bug fixes\n\nChanges in release 0.1b:\n\n * some old -> new crypto conversion utils\n * bug fixes\n\nChanges in release 0.1a:\n\n * new crypto code\n * more bug fixes\n * make sure we ask for DES keys in gssapi\n * support signed ints in ASN1\n * IPv6-bug fixes\n\nChanges in release 0.0u:\n\n * lots of bug fixes\n\nChanges in release 0.0t:\n\n * more robust parsing of krb5.conf\n * include net{read,write} in lib/roken\n * bug fixes\n\nChanges in release 0.0s:\n\n * kludges for parsing options to rsh\n * more robust parsing of krb5.conf\n * removed some arbitrary limits\n * bug fixes\n\nChanges in release 0.0r:\n\n * default options for some programs\n * bug fixes\n\nChanges in release 0.0q:\n\n * support for building shared libraries with libtool\n * bug fixes\n\nChanges in release 0.0p:\n\n * keytab moved to /etc/krb5.keytab\n * avoid false detection of IPv6 on Linux\n * Lots of more functionality in the gssapi-library\n * hprop can now read ka-server databases\n * bug fixes\n\nChanges in release 0.0o:\n\n * FTP with GSSAPI support.\n * Bug fixes.\n\nChanges in release 0.0n:\n\n * Incremental database propagation.\n * Somewhat improved kadmin ui; the stuff in admin is now removed.\n * Some support for using enctypes instead of keytypes.\n * Lots of other improvement and bug fixes, see ChangeLog for details.\n", "/*\n * Copyright (c) 1997-2008 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"kdc_locl.h\"\n\n/*\n * return the realm of a krbtgt-ticket or NULL\n */\n\nstatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}\n\n/*\n * The KDC might add a signed path to the ticket authorization data\n * field. This is to avoid server impersonating clients and the\n * request constrained delegation.\n *\n * This is done by storing a KRB5_AUTHDATA_IF_RELEVANT with a single\n * entry of type KRB5SignedPath.\n */\n\nstatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}\n\nkrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\nstatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 5,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ncheck_tgs_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ_BODY *b, const EncTicketPart *tgt, EncTicketPart *et)\n{\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif(!tgt->flags.invalid || tgt->starttime == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    kdc_log(context, config, 0,\n\t\t    \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    }else if(tgt->flags.invalid){\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    }else if(b->from && *b->from > kdc_time + context->max_skew){\n\tkdc_log(context, config, 0, \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n#if 0\n    /* checks for excess flags */\n    if(f.request_anonymous && !config->allow_anonymous){\n\tkdc_log(context, config, 0,\n\t\t\"Request for anonymous ticket\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n#endif\n    return 0;\n}\n\n/*\n * Determine if constrained delegation is allowed from this client to this server\n */\n\nstatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}\n\n/*\n * Determine if s4u2self is allowed from this client to this server\n *\n * For example, regardless of the principal being impersonated, if the\n * 'client' and 'server' are the same, then it's safe.\n */\n\nstatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nverify_flags (krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      const EncTicketPart *et,\n\t      const char *pstr)\n{\n    if(et->endtime < kdc_time){\n\tkdc_log(context, config, 0, \"Ticket expired (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_EXPIRED;\n    }\n    if(et->flags.invalid){\n\tkdc_log(context, config, 0, \"Ticket not valid (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_NYV;\n    }\n    return 0;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n\n    /*\n     * If the realm of the presented tgt is neither the client nor the server\n     * realm, it is a transit realm and must be added to transited set.\n     */\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}\n\n\nstatic krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n               const char *tgt_realm,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t tgt_realm);\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}\n\nstatic krb5_error_code\ntgs_check_authenticator(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t                krb5_auth_context ac,\n\t\t\tKDC_REQ_BODY *b,\n\t\t\tconst char **e_text,\n\t\t\tkrb5_keyblock *key)\n{\n    krb5_authenticator auth;\n    size_t len = 0;\n    unsigned char *buf;\n    size_t buf_size;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    krb5_auth_con_getauthenticator(context, ac, &auth);\n    if(auth->cksum == NULL){\n\tkdc_log(context, config, 0, \"No authenticator in request\");\n\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n    /*\n     * according to RFC1510 it doesn't need to be keyed,\n     * but according to the latest draft it needs to.\n     */\n    if (\n#if 0\n!krb5_checksum_is_keyed(context, auth->cksum->cksumtype)\n\t||\n#endif\n !krb5_checksum_is_collision_proof(context, auth->cksum->cksumtype)) {\n\tkdc_log(context, config, 0, \"Bad checksum type in authenticator: %d\",\n\t\tauth->cksum->cksumtype);\n\tret =  KRB5KRB_AP_ERR_INAPP_CKSUM;\n\tgoto out;\n    }\n\n    /* XXX should not re-encode this */\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, b, &len, ret);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REQ-BODY: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\tret = KRB5KRB_ERR_GENERIC;\n\tgoto out;\n    }\n    ret = krb5_crypto_init(context, key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    ret = krb5_verify_checksum(context,\n\t\t\t       crypto,\n\t\t\t       KRB5_KU_TGS_REQ_AUTH_CKSUM,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       auth->cksum);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to verify authenticator checksum: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\nout:\n    free_Authenticator(auth);\n    free(auth);\n    return ret;\n}\n\nstatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 0, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 0, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}\n\nstatic krb5_error_code\ntgs_parse_request(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  KDC_REQ_BODY *b,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 0, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n \tkdc_log(context, config, 0,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n    else\n\tverify_ap_req_flags = 0;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 0, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}\n\nstatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}\n\nstatic krb5_error_code\ntgs_build_reply(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ *req,\n\t\tKDC_REQ_BODY *b,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tkrb5_data *reply,\n\t\tconst char *from,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_error_code ret;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /* \n     * Always to do CANON, see comment below about returned server principal (rsp).\n     */\n    flags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 0,\n\t\t    \"No second ticket present in request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 0,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret)\n\t    goto out;\n\n\tret = verify_flags(context, config, &adtkt, spn);\n\tif (ret)\n\t    goto out;\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &spn);\n    if (ret)\n\tgoto out;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &cpn);\n    if (ret)\n\tgoto out;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,\n\t\t\tNULL, NULL, &server);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", sp);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 5,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(spn);\n        spn = NULL;\n\tret = krb5_unparse_name(context, sp, &spn);\n\tif (ret)\n\t    goto out;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                        req_rlm, TRUE, &capath, &num_capath);\n                if (ret)\n                    goto out;\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(spn);\n                spn = NULL;\n                ret = krb5_unparse_name(context, sp, &spn);\n                if (ret)\n                    goto out;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(spn);\n                spn = NULL;\n\t\tret = krb5_unparse_name(context, sp, &spn);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /* the name returned to the client depend on what was asked for,\n     * return canonical name if kdc_options.canonicalize was set, the\n     * client wants the true name of the principal, if not it just\n     * wants the name its asked for.\n     */\n\n    if (b->kdc_options.canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(context,\n\t\t\t\t  krb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t\t  server, b->etype.val, b->etype.len, &etype,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authoriation data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 1, \"Client no longer in database: %s\",\n\t\t    cpn);\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 1, \"Client not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_verify_checksum(context,\n\t\t\t\t       crypto,\n\t\t\t\t       KRB5_KU_OTHER_CKSUM,\n\t\t\t\t       datack.data,\n\t\t\t\t       datack.length,\n\t\t\t\t       &self.cksum);\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\t    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);\n\t\tif (ret) {\n\t\t    const char *msg;\n\n\t\t    /*\n\t\t     * If the client belongs to the same realm as our krbtgt, it\n\t\t     * should exist in the local database.\n\t\t     *\n\t\t     */\n\n\t\t    if (ret == HDB_ERR_NOENTRY)\n\t\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\t    msg = krb5_get_error_message(context, ret);\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"S2U4Self principal to impersonate %s not found in database: %s\",\n\t\t\t    tpn, msg);\n\t\t    krb5_free_error_message(context, msg);\n\t\t    goto out;\n\t\t}\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n\t\t    kdc_log(context, config, 0, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 0, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation, remove the forward flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 0, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(context, config,\n\t\t\t  client, cpn,\n\t\t\t  server, spn,\n\t\t\t  FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n\tkdc_log(context, config, 0, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tkdc_log(context, config, 0, \"Request from wrong address\");\n\tgoto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 0,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(context,\n\t\t\t config,\n\t\t\t b,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t spn,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data,\n\t\t\t e_text,\n\t\t\t reply);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(spn);\n    free(cpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}\n\n/*\n *\n */\n\nkrb5_error_code\n_kdc_tgs_rep(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     KDC_REQ *req,\n\t     krb5_data *data,\n\t     const char *from,\n\t     struct sockaddr *from_addr,\n\t     int datagram_reply)\n{\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(context, config,\n\t\t\t    &req->req_body, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 10, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(context,\n\t\t\t  config,\n\t\t\t  req,\n\t\t\t  &req->req_body,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  data,\n\t\t\t  from,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 10, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(context, NULL,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2006 - 2007 Kungliga Tekniska H\u00f6gskolan\n# (Royal Institute of Technology, Stockholm, Sweden). \n# All rights reserved. \n#\n# Redistribution and use in source and binary forms, with or without \n# modification, are permitted provided that the following conditions \n# are met: \n#\n# 1. Redistributions of source code must retain the above copyright \n#    notice, this list of conditions and the following disclaimer. \n#\n# 2. Redistributions in binary form must reproduce the above copyright \n#    notice, this list of conditions and the following disclaimer in the \n#    documentation and/or other materials provided with the distribution. \n#\n# 3. Neither the name of the Institute nor the names of its contributors \n#    may be used to endorse or promote products derived from this software \n#    without specific prior written permission. \n#\n# THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND \n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n# ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE \n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS \n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY \n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF \n# SUCH DAMAGE. \n\ntop_builddir=\"@top_builddir@\"\nenv_setup=\"@env_setup@\"\nobjdir=\"@objdir@\"\n\n. ${env_setup}\n\nKRB5_CONFIG=\"${1-${objdir}/krb5.conf}\"\nexport KRB5_CONFIG\n\ntestfailed=\"echo test failed; cat messages.log; exit 1\"\n\n# If there is no useful db support compiled in, disable test\n${have_db} || exit 77\n\nR=TEST.H5L.SE\nRH=TEST-HTTP.H5L.SE\nR2=TEST2.H5L.SE\nR3=TEST3.H5L.SE\nR4=TEST4.H5L.SE\nR5=SOME-REALM5.FR\nR6=SOME-REALM6.US\nR7=SOME-REALM7.UK\nR8=SOME-REALM8.UK\n\nH1=H1.$R\nH2=H2.$R\nH3=H3.$H2\nH4=H4.$H2\n\nr=`echo \"$R\" | tr '[A-Z]' '[a-z]'`\nh1=`echo \"${H1}\" | tr '[A-Z]' '[a-z]'`\nh2=`echo \"${H2}\" | tr '[A-Z]' '[a-z]'`\nh3=`echo \"${H3}\" | tr '[A-Z]' '[a-z]'`\nh4=`echo \"${H4}\" | tr '[A-Z]' '[a-z]'`\n\nport=@port@\npwport=@pwport@\n\nkadmin=\"${kadmin} -l -r $R\"\nkadmin5=\"${kadmin} -l -r $R5\"\nkdc=\"${kdc} --addresses=localhost -P $port\"\nkpasswdd=\"${kpasswdd} --addresses=localhost -p $pwport\"\n\nserver=host/datan.test.h5l.se\nserver2=host/computer.example.com\nserverip=host/10.11.12.13\nserveripname=host/ip.test.h5l.org\nserveripname2=host/10.11.12.14\nalias1=host/datan.example.com\nalias2=host/datan\naliaskeytab=host/datan\ncache=\"FILE:${objdir}/cache.krb5\"\nocache=\"FILE:${objdir}/ocache.krb5\"\no2cache=\"FILE:${objdir}/o2cache.krb5\"\nicache=\"FILE:${objdir}/icache.krb5\"\nkeytabfile=${objdir}/server.keytab\nkeytab=\"FILE:${keytabfile}\"\nps=\"proxy-service@${R}\"\naesenctype=\"aes256-cts-hmac-sha1-96\"\n\nkinit=\"${kinit} -c $cache ${afs_no_afslog}\"\nklist=\"${klist} -c $cache\"\nkgetcred=\"${kgetcred} -c $cache\"\nkgetcred_imp=\"${kgetcred} -c $cache --out-cache=${ocache}\"\nkdestroy=\"${kdestroy} -c $cache ${afs_no_unlog}\"\nkimpersonate=\"${kimpersonate} -k ${keytab} --ccache=${ocache}\"\ntest_set_kvno0=\"${test_set_kvno0} -c $cache\"\n\nrm -f ${keytabfile}\nrm -f current-db*\nrm -f out-*\nrm -f mkey.file*\n\n> messages.log\n\necho Creating database\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R2} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R3} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R4} || exit 1\n\n${kadmin5} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R5} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R6} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R7} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${R8} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H1} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H2} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H3} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${H4} || exit 1\n\n${kadmin} \\\n    init \\\n    --realm-max-ticket-life=1day \\\n    --realm-max-renewable-life=1month \\\n    ${RH} || exit 1\n\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n${kadmin} cpw -r krbtgt/${R}@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults foo@${R} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${r}@${R} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R2} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R3} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R4} || exit 1\n${kadmin5} add -p foo --use-defaults foo@${R5} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R6} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R7} || exit 1\n${kadmin} add -p foo --use-defaults foo@${R8} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H1} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h1}@${H1} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H2} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h2}@${H2} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H3} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h3}@${H3} || exit 1\n${kadmin} add -p foo --use-defaults foo@${H4} || exit 1\n${kadmin} add -p foo --use-defaults foo/host.${h4}@${H4} || exit 1\n${kadmin} add -p bar --use-defaults bar@${R} || exit 1\n${kadmin} add -p foo --use-defaults remove@${R} || exit 1\n${kadmin} add -p nop --use-defaults ${server}@${R} || exit 1\n${kadmin} cpw -p bla --keepold ${server}@${R} || exit 1\n${kadmin} cpw -p kaka --keepold ${server}@${R} || exit 1\n${kadmin} add -p kaka --use-defaults ${server}-des3@${R} || exit 1\n${kadmin} add -p kaka --use-defaults kt-des3@${R} || exit 1\n${kadmin} add -p kaka --use-defaults foo/des3-only@${R} || exit 1\n${kadmin} add -p kaka --use-defaults bar/des3-only@${R} || exit 1\n${kadmin} add -p kaka --use-defaults foo/aes-only@${R} || exit 1\n${kadmin} add -p foo --use-defaults ${ps} || exit 1\n${kadmin} modify --attributes=+trusted-for-delegation ${ps} || exit 1\n${kadmin} modify --constrained-delegation=${server} ${ps} || exit 1\n${kadmin} ext -k ${keytab} ${server}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${ps} || exit 1\n\n${kadmin} add -p kaka --use-defaults ${server2}@${R2} || exit 1\n${kadmin} ext -k ${keytab} ${server2}@${R2} || exit 1\n${kadmin} add -p kaka --use-defaults ${serverip}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${serverip}@${R} || exit 1\n${kadmin} add -p kaka --use-defaults ${serveripname}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${serveripname}@${R} || exit 1\n${kadmin} modify --alias=${serveripname2}@${R} ${serveripname}@${R}\n${kadmin} add -p foo --use-defaults remove2@${R2} || exit 1\n\n${kadmin} add -p kaka --use-defaults ${alias1}@${R} || exit 1\n${kadmin} ext -k ${keytab} ${alias1}@${R} || exit 1\n${kadmin} modify --alias=${alias2}@${R} ${alias1}@${R}\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R2}@${R} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R}@${R2} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R3}@${R2} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R2}@${R3} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R4}@${R2} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R2}@${R4} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R4}@${R3} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R3}@${R4} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R5}@${R} || exit 1\n${kadmin5} add -p cross2 --use-defaults krbtgt/${R}@${R5} || exit 1\n\n${kadmin5} add -p cross1 --use-defaults krbtgt/${R6}@${R5} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R5}@${R6} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R7}@${R6} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R6}@${R7} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${R8}@${R6} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R6}@${R8} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H1}@${R} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R}@${H1} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H2}@${R} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${R}@${H2} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H3}@${H2} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${H2}@${H3} || exit 1\n\n${kadmin} add -p cross1 --use-defaults krbtgt/${H3}@${H4} || exit 1\n${kadmin} add -p cross2 --use-defaults krbtgt/${H4}@${H3} || exit 1\n\n${kadmin} add -p foo --use-defaults pw-expire@${R} || exit 1\n${kadmin} modify --pw-expiration-time=+1day  pw-expire@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults pw-expired@${R} || exit 1\n${kadmin} modify --pw-expiration-time=2012-06-12  pw-expired@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults account-expired@${R} || exit 1\n${kadmin} modify --expiration-time=2012-06-12  account-expired@${R} || exit 1\n\n${kadmin} add -p foo --use-defaults foo@${RH} || exit 1\n\necho \"Check parser\"\n${kadmin} add -p foo --use-defaults -- -p || exit 1\n${kadmin} delete -- -p || exit 1\n\necho \"Doing database check\"\n${kadmin} check ${R} || exit 1\n${kadmin} check ${R2} || exit 1\n${kadmin} check ${R3} || exit 1\n${kadmin} check ${R4} || exit 1\n${kadmin5} check ${R5} || exit 1\n${kadmin} check ${R6} || exit 1\n${kadmin} check ${R7} || exit 1\n${kadmin} check ${R8} || exit 1\n${kadmin} check ${H1} || exit 1\n${kadmin} check ${H2} || exit 1\n${kadmin} check ${H3} || exit 1\n${kadmin} check ${H4} || exit 1\n\necho \"Extracting enctypes\"\n${ktutil} -k ${keytab} list > tempfile || exit 1\n${EGREP} -v '^FILE:' tempfile | ${EGREP} -v '^Vno' | ${EGREP} -v '^$' | \\\n    ${EGREP} -v \"$server\" |                 # we did cpw for this one\n    awk '$1 !~ /1/  { exit 1 }' || exit 1\n${EGREP} -v '^FILE:' tempfile | ${EGREP} -v '^Vno' | ${EGREP} -v '^$' | \\\n    ${EGREP} \"$server\" | head -1 |\n    awk '$1 !~ /3/  { exit 1 }' || exit 1\n\n\n${kadmin} get foo@${R} > tempfile || exit 1\nenctypes=`grep Keytypes: tempfile | sed 's/(pw-salt)//g' | sed 's/,//g' | sed 's/Keytypes://' | sed 's/\\[[0-9]*\\]//g'`\n\nenctype_sans_aes=`echo $enctypes | sed 's/aes[^ ]*//g'`\nenctype_sans_des3=`echo $enctypes | sed 's/des3-cbc-sha1//g'`\n\necho \"deleting all but des enctypes on kt-des3 in keytab\"\n${kadmin} ext -k ${keytab} kt-des3@${R} || exit 1\nfor a in ${enctype_sans_des3} ; do\n   ${ktutil} -k ${keytab} remove -p kt-des3@${R} -e $a\ndone\n\necho \"checking globbing keys rules\"\n${kadmin} get foo/des3-only@${R} > tempfile || exit 1\nenctypes=`grep Keytypes: tempfile | sed 's/(pw-salt)//g' | sed 's/,//g' | sed 's/Keytypes://' | sed 's/\\[[0-9]*\\]//g' | sed 's/ //g'`\nif [ X\"$enctypes\" != Xdes3-cbc-sha1 ] ; then\n    echo \"des3 only is not only des3: $enctypes\"\n    exit 1\nfi\n\n${kadmin} get foo/aes-only@${R} > tempfile || exit 1\nenctypes=`grep Keytypes: tempfile | sed 's/(pw-salt)//g' | sed 's/,//g' | sed 's/Keytypes://' | sed 's/\\[[0-9]*\\]//g' | sed 's/ //g'`\nif [ X\"$enctypes\" != Xaes256-cts-hmac-sha1-96 ] ; then\n    echo \"aes only is not only aes: $enctypes\"\n    exit 1\nfi\n\n\necho foo > ${objdir}/foopassword\necho notfoo > ${objdir}/notfoopassword\n\necho Starting kdc ; > messages.log\nenv MallocStackLogging=1 MallocStackLoggingNoCompact=1 MallocErrorAbort=1 MallocLogFile=${objdir}/malloc-log \\\n${kdc} --detach --testing ||\n    { echo \"kdc failed to start\"; exit 1; }\nkdcpid=`getpid kdc`\n\necho Starting kpasswdd; > messages.log\nenv ${HEIM_MALLOC_DEBUG} ${kpasswdd} --detach ||\n    { echo \"kpasswdd failed to start\"; exit 1; }\nkpasswddpid=`getpid kpasswdd`\n\n\ntrap \"kill -9 ${kdcpid} ${kpasswddpid}; echo signal killing kdc kpasswdd; exit 1;\" EXIT\n\nec=0\n\necho \"Getting client initial tickets with wrong password\"; > messages.log\n${kinit} --password-file=${objdir}/notfoopassword \\\n        foo@${R} 2>kinit-log.tmp && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\ngrep 'Password incorrect' kinit-log.tmp > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"Getting client initial tickets\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"Doing krbtgt key rollover\"; > messages.log\n${kadmin} cpw -r --keepold krbtgt/${R}@${R} || exit 1\necho \"Getting tickets\"; > messages.log\n${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Listing tickets\"; > messages.log\n${klist} > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Getting client initial tickets (http transport)\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@${RH} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing capaths logic\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with capaths for $R -> $R2\"\n${kgetcred} foo@${R2} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R3\"\n${kgetcred} foo@${R3} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R4\"\n${kgetcred} foo@${R4} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R5\"\n${kgetcred} foo@${R5} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R6\"\n${kgetcred} foo@${R6} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R7\"\n${kgetcred} foo@${R7} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Should not get x-realm tickets with capaths for $R -> $R8\"\n${kgetcred} foo@${R8} && { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing capaths logic (reverse order)\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with capaths for $R -> $R4\"\n${kgetcred} foo@${R4} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R3\"\n${kgetcred} foo@${R3} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R2\"\n${kgetcred} foo@${R2} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R7\"\n${kgetcred} foo@${R7} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R6\"\n${kgetcred} foo@${R6} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with capaths for $R -> $R5\"\n${kgetcred} foo@${R5} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing hierarchical referral logic\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@${H3} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with hierarchical referrals for $H3 -> $H1\"\n${kgetcred} --hostbased --canonicalize foo host.${h1} || { ec=1 ; eval \"${testfailed}\"; }\nfgrep \"cross-realm ${H3} -> ${H1} via [${H2}, ${R}]\" messages.log > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with hierarchical referrals for $H3 -> $R\"\n${kgetcred} --hostbased --canonicalize foo host.${r} || { ec=1 ; eval \"${testfailed}\"; }\nfgrep \"cross-realm ${H3} -> ${R} via [${H2}]\" messages.log > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting x-realm tickets with hierarchical referrals for $H3 -> $H2\"\n${kgetcred} --hostbased --canonicalize foo host.${h2} || { ec=1 ; eval \"${testfailed}\"; }\nfgrep \"cross-realm ${H3} -> ${H2}\" messages.log > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing multi-hop [capaths] referral logic\"\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@${H4} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"Getting x-realm tickets with [capaths] referrals for $H4 -> $H1\"\n${kgetcred} --hostbased --canonicalize foo/host.${h1}@${H4} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Testing forwardable/renewable flag copying in TGS-REQ\"\n${kinit} -f --renewable -r 5d --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${klist} -f | grep ${server} | grep FRA > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\n\necho \"Specific enctype\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword \\\n    -e ${aesenctype} -e ${aesenctype} \\\n    foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\nfor a in $enctypes; do\n\techo \"Getting client initial tickets ($a)\"; > messages.log\n\t${kinit} --enctype=$a --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\n\techo \"Getting tickets\"; > messages.log\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\ndone\n\n\necho \"Getting client initial tickets\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\nfor a in $enctypes; do\n\techo \"Getting tickets ($a)\"; > messages.log\n\t${kgetcred} -e $a ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy} --credential=${server}@${R}\ndone\n${kdestroy}\n\necho \"Getting client initial tickets for cross realm case\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\nfor a in $enctypes; do\n\techo \"Getting cross realm tickets ($a)\"; > messages.log\n\t${kgetcred} -e $a ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n\techo \"  checking we we got back right ticket\"\n\t${klist} | grep ${server2}@ > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n\techo \"  checking if ticket is useful\"\n\t${test_ap_req} ${server2}@${R2} ${keytab} ${cache} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy} --credential=${server2}@${R2}\ndone\n${kdestroy}\n\necho \"Trying x-realm TGT with kvno 0 case\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Trying x-realm TGT with kvno 0 case with key rollover\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Rolling over cross realm keys\"; > messages.log\n${kadmin} cpw -r --keepold krbtgt/${R}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\necho \"Start tracing kdc, then hit return\"\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Trying x-realm TGT with no kvno case\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Trying x-realm TGT with no kvno case with key rollover\";\n${kinit} --password-file=${objdir}/foopassword foo@$R ||\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting cross realm tickets\"; > messages.log\n${kgetcred} krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"Rolling over cross realm keys\"; > messages.log\n${kadmin} cpw -r --keepold krbtgt/${R}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kadmin} cpw -r --keepold krbtgt/${R}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${test_set_kvno0} -n || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting service ticket\"; > messages.log\necho \"Start tracing kdc, then hit return\"\n${kgetcred} ${server2}@${R2} || { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"try all permutations\"; > messages.log\nfor a in $enctypes; do\n\techo \"Getting client initial tickets ($a)\"; > messages.log\n\t${kinit} --enctype=$a --password-file=${objdir}/foopassword foo@$R || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\tfor b in $enctypes; do\n\t\techo \"Getting tickets ($a ->  $b)\"; > messages.log\n\t\t${kgetcred} -e $b ${server}@${R} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${kdestroy} --credential=${server}@${R}\n\tdone\n\t${kdestroy}\ndone\n\necho \"Getting client initial tickets ip based name\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\necho \"Getting ip based name tickets\"; > messages.log\n${kgetcred} ${serverip}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"  checking we we got back right ticket\"\n${klist} | grep ${serverip}@ > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\necho \"  checking if ticket is useful\"\n${test_ap_req} ${serverip}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Getting client initial tickets ip based name (alias)\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || { ec=1 ; eval \"${testfailed}\"; }\nfor a in ${serveripname} ${serveripname2} ; do\n    echo \"Getting ip based name tickets (alias) $a\"; > messages.log\n    ${kgetcred} ${a}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n    echo \"  checking we we got back right ticket\"\n    ${klist} | grep ${a}@ > /dev/null || { ec=1 ; eval \"${testfailed}\"; }\n    echo \"  checking if ticket is useful\"\n    ${test_ap_req} --server-any ${a}@${R} ${keytab} ${cache} || \\\n    \t{ ec=1 ; eval \"${testfailed}\"; }\ndone\n${kdestroy}\n\necho \"Getting server initial tickets\"; > messages.log\n${kinit} --keytab=${keytab} ${server}@$R || { ec=1 ; eval \"${testfailed}\"; }\necho \"Listing tickets\"; > messages.log\n${klist} | grep \"Principal: ${server}\" > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"Getting key for key that are a subset in keytab compared to kdb\"\n${kinit} --keytab=${keytab} kt-des3@${R}\n${klist} | grep \"Principal: kt-des3\" > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"initial tickets for deleted user test case\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword remove@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} delete remove@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"try getting ticket with deleted user\"; > messages.log\n${kgetcred} ${server}@${R} 2> /dev/null && { ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"cross realm case (deleted user)\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword remove2@$R2 || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} krbtgt/${R}@${R2} 2> /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} delete remove2@${R2} || exit 1\n${kgetcred} ${server}@${R} 2> /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"rename user\"; > messages.log\n${kadmin} add -p foo --use-defaults rename@${R} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} rename rename@${R} rename2@${R} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename2@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n${kadmin} delete rename2@${R} || exit 1\n\necho \"rename user to another realm\"; > messages.log\n${kadmin} add -p foo --use-defaults rename@${R} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kadmin} rename rename@${R} rename@${R2} || exit 1\n${kinit} --password-file=${objdir}/foopassword rename@${R2} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n${kadmin} delete rename@${R2} || exit 1\n\necho deleting all but aes enctypes on krbtgt\n${kadmin} del_enctype krbtgt/${R}@${R} ${enctype_sans_aes} || exit 1\n\necho deleting all but des enctypes on server-des3\n${kadmin} del_enctype ${server}-des3@${R} ${enctype_sans_des3} || exit 1\n${kadmin} ext -k ${keytab} ${server}-des3@${R} || exit 1\n\necho \"try all permutations (only aes)\"; > messages.log\nfor a in $enctypes; do\n\techo \"Getting client initial tickets ($a)\"; > messages.log\n\t${kinit} --enctype=$a --password-file=${objdir}/foopassword foo@${R} ||\\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\tfor b in $enctypes; do\n\t\techo \"Getting tickets ($a ->  $b)\"; > messages.log\n\t\t${kgetcred} -e $b ${server}@${R} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${test_ap_req} ${server}@${R} ${keytab} ${cache} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\n\t\techo \"Getting tickets ($a ->  $b) (server des3 only)\"; > messages.log\n\t\t${kgetcred} ${server}-des3@${R} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t\t${test_ap_req} ${server}-des3@${R} ${keytab} ${cache} || \\\n\t\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\n\t\t${kdestroy} --credential=${server}@${R}\n\t\t${kdestroy} --credential=${server}-des3@${R}\n\tdone\n\t${kdestroy}\ndone\n\necho deleting all enctypes on krbtgt\n${kadmin} del_enctype krbtgt/${R}@${R} aes256-cts-hmac-sha1-96 || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"try initial ticket w/o and keys on krbtgt\"\n${kinit} --password-file=${objdir}/foopassword foo@${R} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"adding random aes key\"\n${kadmin} add_enctype -r krbtgt/${R}@${R} aes256-cts-hmac-sha1-96 || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"try initial ticket with random aes key on krbtgt\"\n${kinit} --password-file=${objdir}/foopassword foo@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\nrsa=yes\necdsa=yes\npkinit=no\nif ${hxtool} info | grep 'rsa: hx509 null RSA' > /dev/null ; then\n    rsa=no\nfi\nif ${hxtool} info | grep 'rand: not available' > /dev/null ; then\n    rsa=no\nfi\nif ${kinit} --help 2>&1 | grep \"CA certificates\" > /dev/null; then\n    pkinit=yes\nfi\n\nif ${hxtool} info | grep 'ecdsa: hcrypto null' > /dev/null ; then\n    ecdsa=no\nfi\n\n\n# If we support pkinit and have RSA, lets try that\nif test \"$pkinit\" = yes -a \"$rsa\" = yes ; then\n\n    echo \"try anonymous pkinit\"; > messages.log\n    ${kinit} --anonymous ${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n    ${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n    ${kdestroy}\n\n    for type in \"\" \"--pk-use-enckey\"; do\n\techo \"Trying pk-init (principal in certificate) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit.crt,${hx509_data}/pkinit.key bar@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n\techo \"Trying pk-init (principal in pki-mapping) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit.crt,${hx509_data}/pkinit.key foo@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n\techo \"Trying pk-init (password protected key) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit.crt,${hx509_data}/pkinit-pw.key --password-file=${objdir}/foopassword foo@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n\techo \"Trying pk-init (proxy cert) $type\"; > messages.log\n\t${kinit} $type -C FILE:${hx509_data}/pkinit-proxy-chain.crt,${hx509_data}/pkinit-proxy.key foo@${R} || \\\n\t\t{ ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\n    done\n\n    if test \"$ecdsa\" = yes > /dev/null ; then\n\techo \"Trying pk-init (ec certificate)\"\n\t> messages.log\n\t${kinit} -C FILE:${hx509_data}/pkinit-ec.crt,${hx509_data}/pkinit-ec.key bar@${R} || \\\n\t    { ec=1 ; eval \"${testfailed}\"; }\n\t${kgetcred} ${server}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n\t${kdestroy}\n\tgrep 'PK-INIT using ecdh' messages.log > /dev/null || \\\n\t    { ec=1 ; eval \"${testfailed}\"; }\n    fi\n\nelse\n\techo \"no pkinit (pkinit: $pkinit, rsa: $rsa)\"; > messages.log\nfi\n\necho \"tickets for impersonate test case\"; > messages.log\n${kinit} --forwardable --password-file=${objdir}/foopassword ${ps} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred_imp} --impersonate=bar@${R} ${ps} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${test_ap_req} ${ps} ${keytab} ${ocache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"  negative check\"\n${kgetcred_imp} --impersonate=bar@${R} foo@${R} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"test constrained delegation\"; > messages.log\n${kgetcred_imp} --forward --impersonate=bar@${R} ${ps} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} \\\n\t--out-cache=${o2cache} \\\n\t--delegation-credential-cache=${ocache} \\\n\t${server}@${R} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"  try using the credential\"\n${test_ap_req} ${server}@${R} ${keytab} ${o2cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"  negative check\"\n${kgetcred} \\\n\t--out-cache=${o2cache} \\\n\t--delegation-credential-cache=${ocache} \\\n\tbar@${R} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"test constrained delegation impersonation (non forward)\"; > messages.log\nrm -f ocache.krb5\n${kimpersonate} -s ${ps} -c bar@${R} -t ${aesenctype} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} --out-cache=${o2cache} --delegation-credential-cache=${ocache} ${server}@${R} > /dev/null 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\necho \"test constrained delegation impersonation (missing KRB5SignedPath)\"; > messages.log\nrm -f ocache.krb5\n${kimpersonate} -s ${ps} -c bar@${R} -t ${aesenctype} -f forwardable || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} --out-cache=${o2cache} --delegation-credential-cache=${ocache} ${server}@${R} > /dev/null 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\n${kdestroy}\n\necho \"check renewing\" > messages.log\n${kinit} --renewable --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"kinit -R\"\n${kinit} -R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"check renewing MIT interface\" > messages.log\n${kinit} --renewable --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"test_renew\"\nenv KRB5CCNAME=${cache} ${test_renew} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"checking server aliases\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword foo@$R || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"Getting tickets\"; > messages.log\n${kgetcred} ${alias1}@${R} || { ec=1 ; eval \"${testfailed}\"; }\n${kgetcred} ${alias2}@${R} || { ec=1 ; eval \"${testfailed}\"; }\necho \"   verify entry in keytab\"\n${test_ap_req} ${alias1}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   verify entry in keytab with any\"\n${test_ap_req} --server-any ${alias1}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   verify failure with alias entry\"\n${test_ap_req} ${alias2}@${R} ${keytab} ${cache} 2>/dev/null && \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   verify alias entry in keytab with any\"\n${test_ap_req} --server-any ${alias2}@${R} ${keytab} ${cache} || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n${kdestroy}\n\necho \"testing removal of keytab\"\n${ktutil} -k ${keytab} destroy || { ec=1 ; eval \"${testfailed}\"; }\ntest -f ${keytabfile} && { ec=1 ; eval \"${testfailed}\"; }\n\necho \"Checking client pw expire\"; > messages.log\n${kinit} --password-file=${objdir}/foopassword \\\n        pw-expire@${R} 2>kinit-log.tmp|| \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\ngrep 'Your password will expire' kinit-log.tmp > /dev/null || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   kinit passes\"\n${test_gic} --client=pw-expire@${R} --password=foo > kinit-log.tmp 2>/dev/null\n${EGREP} \"^e type: 6\" kinit-log.tmp > /dev/null  || \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\necho \"   test_gic passes\"\n${kdestroy}\n\necho \"Checking password expiration\" ; > messages.log\n\nkinitpty=${objdir}/foopassword.rkpty\ncat > ${kinitpty} <<EOF\nexpect Password\npassword foo\\n\nexpect Password has expired\nexpect New password\npassword Foobar11\\n\nexpect password\npassword Foobar11\\n\nexpect Success: Password changed\nEOF\n\necho \"Checking client pw expire\"; > messages.log\n${rkpty} ${kinitpty} ${kinit} pw-expired@${R}|| \\\n\t{ ec=1 ; eval \"${testfailed}\"; }\n\n${kdestroy}\n\n\necho \"killing kdc (${kdcpid}) kpasswdd (${kpasswddpid})\"\nsh ${leaks_kill} kdc $kdcpid || exit 1\nsh ${leaks_kill} kpasswdd $kpasswddpid || exit 1\n\ntrap \"\" EXIT\n\nexit $ec\n", "[libdefaults]\n\tdefault_realm = TEST.H5L.SE TEST2.H5L.SE\n\tno-addresses = TRUE\n\tallow_weak_crypto = @WEAK@\n\tdns_lookup_kdc = no\n\tdns_lookup_realm = no\n\n\n[appdefaults]\n\tpkinit_anchors = FILE:@srcdir@/../../lib/hx509/data/ca.crt\n\treconnect-min = 2s\n\treconnect-backoff = 2s\n\treconnect-max = 10s\n\n[realms]\n\tTEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t\tadmin_server = localhost:@admport@\n\t\tkpasswd_server = localhost:@pwport@\n\t}\n\tSUB.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tTEST2.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t\tkpasswd_server = localhost:@pwport@\n\t}\n\tTEST3.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tTEST4.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM5.FR = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM6.US = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM7.UK = {\n\t\tkdc = localhost:@port@\n\t}\n\tSOME-REALM8.UK = {\n\t\tkdc = localhost:@port@\n\t}\n\tTEST-HTTP.H5L.SE = {\n\t\tkdc = http/localhost:@port@\n\t}\n\tH1.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tH2.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tH3.H2.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\tH4.H2.TEST.H5L.SE = {\n\t\tkdc = localhost:@port@\n\t}\n\n[domain_realm]\n\t.test.h5l.se = TEST.H5L.SE\n\t.sub.test.h5l.se = SUB.TEST.H5L.SE\n\t.h1.test.h5l.se = H1.TEST.H5L.SE\n\t.h2.test.h5l.se = H2.TEST.H5L.SE\n\t.h3.h2.test.h5l.se = H3.H2.TEST.H5L.SE\n\t.h4.h2.test.h5l.se = H4.H2.TEST.H5L.SE\n\t.example.com = TEST2.H5L.SE\n\tlocalhost = TEST.H5L.SE\n\t.localdomain = TEST.H5L.SE\n\tlocaldomain = TEST.H5L.SE\n\t.localdomain6 = TEST.H5L.SE\n\tlocaldomain6 = TEST.H5L.SE\n\t\n\n[kdc]\n\tenable-digest = true\n\tallow-anonymous = true\n\tdigests_allowed = chap-md5,digest-md5,ntlm-v1,ntlm-v1-session,ntlm-v2,ms-chap-v2\n        strict-nametypes = true\n\n\tenable-http = true\n\n\tenable-pkinit = true\n\tpkinit_identity = FILE:@srcdir@/../../lib/hx509/data/kdc.crt,@srcdir@/../../lib/hx509/data/kdc.key\n\tpkinit_anchors = FILE:@srcdir@/../../lib/hx509/data/ca.crt\n\tpkinit_pool = FILE:@srcdir@/../../lib/hx509/data/sub-ca.crt\n#\tpkinit_revoke = CRL:@srcdir@/../../lib/hx509/data/crl1.crl\n\tpkinit_mappings_file = @srcdir@/pki-mapping\n\tpkinit_allow_proxy_certificate = true\n\n\tdatabase = {\n\t\tlabel = { \n\t\t\tdbname = @db_type@:@objdir@/current-db@kdc@\n\t\t\trealm = TEST.H5L.SE\n\t\t\tmkey_file = @objdir@/mkey.file\n\t\t\tacl_file = @srcdir@/heimdal.acl\n\t\t\tlog_file = @objdir@/current@kdc@.log\n\t\t}\n\t\tlabel2 = { \n\t\t\tdbname = @db_type@:@objdir@/current-db@kdc@\n\t\t\trealm = TEST2.H5L.SE\n\t\t\tmkey_file = @objdir@/mkey.file\n\t\t\tacl_file = @srcdir@/heimdal.acl\n\t\t\tlog_file = @objdir@/current@kdc@.log\n\t\t}\n\t\tlabel3 = { \n\t\t\tdbname = sqlite:@objdir@/current-db@kdc@.sqlite3\n\t\t\trealm = SOME-REALM5.FR\n\t\t\tmkey_file = @objdir@/mkey.file\n\t\t\tacl_file = @srcdir@/heimdal.acl\n\t\t\tlog_file = @objdir@/current@kdc@.log\n\t\t}\n\t}\n\n\tsignal_socket = @objdir@/signal\n\tiprop-stats = @objdir@/iprop-stats\n\tiprop-acl = @srcdir@/iprop-acl\n        log-max-size = 40000\n\n[hdb]\n\tdb-dir = @objdir@\n\n[logging]\n\tkdc = 0-/FILE:@objdir@/messages.log\n\tkrb5 = 0-/FILE:@objdir@/messages.log\n\tdefault = 0-/FILE:@objdir@/messages.log\n\n# If you are doing preformance measurements on OSX you want to change\n# the kdc LOG line from = to - below to keep the FILE open and avoid\n# open/write/close which is blocking (rdar:// ) on OSX.\n#\tkdc = 0-/FILE=@objdir@/messages.log\n\n[kadmin]\n\tsave-password = true\n\tdefault_key_rules = {\n\t\t*/des3-only@* = des3-cbc-sha1:pw-salt\n\t\t*/aes-only@* = aes256-cts-hmac-sha1-96:pw-salt\n\t}\n\t@dk@\n\n[capaths]\n\tTEST.H5L.SE = {\n\t\tTEST2.H5L.SE = .\n\t\tSOME-REALM5.FR = 1\n\t\tTEST3.H5L.SE = TEST2.H5L.SE\n\t\tTEST4.H5L.SE = TEST2.H5L.SE\n\t\tTEST4.H5L.SE = TEST3.H5L.SE\n\t\tSOME-REALM6.US = SOME-REALM5.FR\n\t\tSOME-REALM7.UK = SOME-REALM6.US\n\t\tSOME-REALM7.UK = SOME-REALM5.FR\n\t\tSOME-REALM8.UK = SOME-REALM6.US\n\t}\n        H4.H2.TEST.H5L.SE = {\n                H1.TEST.H5L.SE = H3.H2.TEST.H5L.SE\n                H1.TEST.H5L.SE = H2.TEST.H5L.SE\n                H1.TEST.H5L.SE = TEST.H5L.SE\n\n                TEST.H5L.SE = H3.H2.TEST.H5L.SE\n                TEST.H5L.SE = H2.TEST.H5L.SE\n\n                H2.TEST.H5L.SE = H3.H2.TEST.H5L.SE\n        }\n"], "filenames": ["NEWS", "kdc/krb5tgs.c", "tests/kdc/check-kdc.in", "tests/kdc/krb5.conf.in"], "buggy_code_start_loc": [0, 657, 55, 40], "buggy_code_end_loc": [0, 2326, 424, 149], "fixing_code_start_loc": [1, 658, 56, 41], "fixing_code_end_loc": [15, 2335, 442, 154], "type": "CWE-295", "message": "The transit path validation code in Heimdal before 7.3 might allow attackers to bypass the capath policy protection mechanism by leveraging failure to add the previous hop realm to the transit path of issued tickets.", "other": {"cve": {"id": "CVE-2017-6594", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-28T19:29:01.400", "lastModified": "2021-08-12T17:50:27.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The transit path validation code in Heimdal before 7.3 might allow attackers to bypass the capath policy protection mechanism by leveraging failure to add the previous hop realm to the transit path of issued tickets."}, {"lang": "es", "value": "El c\u00f3digo de validaci\u00f3n de ruta de tr\u00e1nsito en Heimdal en versiones anteriores a la 7.3 podr\u00eda permitir que atacantes omitan el mecanismo de protecci\u00f3n de pol\u00edtica capath aprovech\u00e1ndose del error a la hora de a\u00f1adir el dominio de salto anterior a la ruta de tr\u00e1nsito de tickets emitidos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:heimdal_project:heimdal:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.2.0", "matchCriteriaId": "01013DC7-03C4-45E0-82FF-190E334827A6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "5F65DAB0-3DAD-49FF-BC73-3581CC3D5BF3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-08/msg00062.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.h5l.org/advisories.html?show=2017-04-13", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/heimdal/heimdal/releases/tag/heimdal-7.3.0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837"}}