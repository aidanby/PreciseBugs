{"buggy_code": ["# -*- coding: utf-8 -*-\n'''\n    feedgen.entry\n    ~~~~~~~~~~~~~\n\n    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom datetime import datetime\n\nimport dateutil.parser\nimport dateutil.tz\nimport warnings\nfrom lxml import etree\n\nfrom feedgen.compat import string_types\nfrom feedgen.util import ensure_format, formatRFC2822\n\n\ndef _add_text_elm(entry, data, name):\n    \"\"\"Add a text subelement to an entry\"\"\"\n    if not data:\n        return\n\n    elm = etree.SubElement(entry, name)\n    type_ = data.get('type')\n    if data.get('src'):\n        if name != 'content':\n            raise ValueError(\"Only the 'content' element of an entry can \"\n                             \"contain a 'src' attribute\")\n        elm.attrib['src'] = data['src']\n    elif data.get(name):\n        # Surround xhtml with a div tag, parse it and embed it\n        if type_ == 'xhtml':\n            elm.append(etree.fromstring(\n                '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +\n                data.get(name) + '</div>'))\n        elif type_ == 'CDATA':\n            elm.text = etree.CDATA(\n                    data.get(name))\n        # Parse XML and embed it\n        elif type_ and (type_.endswith('/xml') or type_.endswith('+xml')):\n            elm.append(etree.fromstring(\n                data[name]))\n        # Embed the text in escaped form\n        elif not type_ or type_.startswith('text') or type_ == 'html':\n            elm.text = data.get(name)\n        # Everything else should be included base64 encoded\n        else:\n            raise NotImplementedError(\n                'base64 encoded {} is not supported at the moment. '\n                'Pull requests adding support are welcome.'.format(name)\n            )\n    # Add type description of the content\n    if type_:\n        elm.attrib['type'] = type_\n\n\nclass FeedEntry(object):\n    '''FeedEntry call representing an ATOM feeds entry node or an RSS feeds item\n    node.\n    '''\n\n    def __init__(self):\n        # ATOM\n        # required\n        self.__atom_id = None\n        self.__atom_title = None\n        self.__atom_updated = datetime.now(dateutil.tz.tzutc())\n\n        # recommended\n        self.__atom_author = None\n        self.__atom_content = None\n        self.__atom_link = None\n        self.__atom_summary = None\n\n        # optional\n        self.__atom_category = None\n        self.__atom_contributor = None\n        self.__atom_published = None\n        self.__atom_source = None\n        self.__atom_rights = None\n\n        # RSS\n        self.__rss_author = None\n        self.__rss_category = None\n        self.__rss_comments = None\n        self.__rss_description = None\n        self.__rss_content = None\n        self.__rss_enclosure = None\n        self.__rss_guid = {}\n        self.__rss_link = None\n        self.__rss_pubDate = None\n        self.__rss_source = None\n        self.__rss_title = None\n\n        # Extension list:\n        self.__extensions = {}\n        self.__extensions_register = {}\n\n    def atom_entry(self, extensions=True):\n        '''Create an ATOM entry and return it.'''\n        entry = etree.Element('entry')\n        if not (self.__atom_id and self.__atom_title and self.__atom_updated):\n            raise ValueError('Required fields not set')\n        id = etree.SubElement(entry, 'id')\n        id.text = self.__atom_id\n        title = etree.SubElement(entry, 'title')\n        title.text = self.__atom_title\n        updated = etree.SubElement(entry, 'updated')\n        updated.text = self.__atom_updated.isoformat()\n\n        # An entry must contain an alternate link if there is no content\n        # element.\n        if not self.__atom_content:\n            links = self.__atom_link or []\n            if not [l for l in links if l.get('rel') == 'alternate']:\n                raise ValueError('Entry must contain an alternate link or ' +\n                                 'a content element.')\n\n        # Add author elements\n        for a in self.__atom_author or []:\n            # Atom requires a name. Skip elements without.\n            if not a.get('name'):\n                continue\n            author = etree.SubElement(entry, 'author')\n            name = etree.SubElement(author, 'name')\n            name.text = a.get('name')\n            if a.get('email'):\n                email = etree.SubElement(author, 'email')\n                email.text = a.get('email')\n            if a.get('uri'):\n                uri = etree.SubElement(author, 'uri')\n                uri.text = a.get('uri')\n\n        _add_text_elm(entry, self.__atom_content, 'content')\n\n        for l in self.__atom_link or []:\n            link = etree.SubElement(entry, 'link', href=l['href'])\n            if l.get('rel'):\n                link.attrib['rel'] = l['rel']\n            if l.get('type'):\n                link.attrib['type'] = l['type']\n            if l.get('hreflang'):\n                link.attrib['hreflang'] = l['hreflang']\n            if l.get('title'):\n                link.attrib['title'] = l['title']\n            if l.get('length'):\n                link.attrib['length'] = l['length']\n\n        _add_text_elm(entry, self.__atom_summary, 'summary')\n\n        for c in self.__atom_category or []:\n            cat = etree.SubElement(entry, 'category', term=c['term'])\n            if c.get('scheme'):\n                cat.attrib['scheme'] = c['scheme']\n            if c.get('label'):\n                cat.attrib['label'] = c['label']\n\n        # Add author elements\n        for c in self.__atom_contributor or []:\n            # Atom requires a name. Skip elements without.\n            if not c.get('name'):\n                continue\n            contrib = etree.SubElement(entry, 'contributor')\n            name = etree.SubElement(contrib, 'name')\n            name.text = c.get('name')\n            if c.get('email'):\n                email = etree.SubElement(contrib, 'email')\n                email.text = c.get('email')\n            if c.get('uri'):\n                uri = etree.SubElement(contrib, 'uri')\n                uri.text = c.get('uri')\n\n        if self.__atom_published:\n            published = etree.SubElement(entry, 'published')\n            published.text = self.__atom_published.isoformat()\n\n        if self.__atom_rights:\n            rights = etree.SubElement(entry, 'rights')\n            rights.text = self.__atom_rights\n\n        if self.__atom_source:\n            source = etree.SubElement(entry, 'source')\n            if self.__atom_source.get('title'):\n                source_title = etree.SubElement(source, 'title')\n                source_title.text = self.__atom_source['title']\n            if self.__atom_source.get('link'):\n                etree.SubElement(source, 'link',\n                                 href=self.__atom_source['link'])\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('atom'):\n                    ext['inst'].extend_atom(entry)\n\n        return entry\n\n    def rss_entry(self, extensions=True):\n        '''Create a RSS item and return it.'''\n        entry = etree.Element('item')\n        if not (self.__rss_title or\n                self.__rss_description or\n                self.__rss_content):\n            raise ValueError('Required fields not set')\n        if self.__rss_title:\n            title = etree.SubElement(entry, 'title')\n            title.text = self.__rss_title\n        if self.__rss_link:\n            link = etree.SubElement(entry, 'link')\n            link.text = self.__rss_link\n        if self.__rss_description and self.__rss_content:\n            description = etree.SubElement(entry, 'description')\n            description.text = self.__rss_description\n            XMLNS_CONTENT = 'http://purl.org/rss/1.0/modules/content/'\n            content = etree.SubElement(entry, '{%s}encoded' % XMLNS_CONTENT)\n            content.text = etree.CDATA(self.__rss_content['content']) \\\n                if self.__rss_content.get('type', '') == 'CDATA' \\\n                else self.__rss_content['content']\n        elif self.__rss_description:\n            description = etree.SubElement(entry, 'description')\n            description.text = self.__rss_description\n        elif self.__rss_content:\n            description = etree.SubElement(entry, 'description')\n            description.text = etree.CDATA(self.__rss_content['content']) \\\n                if self.__rss_content.get('type', '') == 'CDATA' \\\n                else self.__rss_content['content']\n        for a in self.__rss_author or []:\n            author = etree.SubElement(entry, 'author')\n            author.text = a\n        if self.__rss_guid.get('guid'):\n            guid = etree.SubElement(entry, 'guid')\n            guid.text = self.__rss_guid['guid']\n            permaLink = str(self.__rss_guid.get('permalink', False)).lower()\n            guid.attrib['isPermaLink'] = permaLink\n        for cat in self.__rss_category or []:\n            category = etree.SubElement(entry, 'category')\n            category.text = cat['value']\n            if cat.get('domain'):\n                category.attrib['domain'] = cat['domain']\n        if self.__rss_comments:\n            comments = etree.SubElement(entry, 'comments')\n            comments.text = self.__rss_comments\n        if self.__rss_enclosure:\n            enclosure = etree.SubElement(entry, 'enclosure')\n            enclosure.attrib['url'] = self.__rss_enclosure['url']\n            enclosure.attrib['length'] = self.__rss_enclosure['length']\n            enclosure.attrib['type'] = self.__rss_enclosure['type']\n        if self.__rss_pubDate:\n            pubDate = etree.SubElement(entry, 'pubDate')\n            pubDate.text = formatRFC2822(self.__rss_pubDate)\n        if self.__rss_source:\n            source = etree.SubElement(entry, 'source',\n                                      url=self.__rss_source['url'])\n            source.text = self.__rss_source['title']\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('rss'):\n                    ext['inst'].extend_rss(entry)\n\n        return entry\n\n    def title(self, title=None):\n        '''Get or set the title value of the entry. It should contain a human\n        readable title for the entry. Title is mandatory for both ATOM and RSS\n        and should not be blank.\n\n        :param title: The new title of the entry.\n        :returns: The entriess title.\n        '''\n        if title is not None:\n            self.__atom_title = title\n            self.__rss_title = title\n        return self.__atom_title\n\n    def id(self, id=None):\n        '''Get or set the entry id which identifies the entry using a\n        universally unique and permanent URI. Two entries in a feed can have\n        the same value for id if they represent the same entry at different\n        points in time. This method will also set rss:guid with permalink set\n        to False. Id is mandatory for an ATOM entry.\n\n        :param id: New Id of the entry.\n        :returns: Id of the entry.\n        '''\n        if id is not None:\n            self.__atom_id = id\n            self.__rss_guid = {'guid': id, 'permalink': False}\n        return self.__atom_id\n\n    def guid(self, guid=None, permalink=False):\n        '''Get or set the entries guid which is a string that uniquely\n        identifies the item. This will also set atom:id.\n\n        :param guid: Id of the entry.\n        :param permalink: If this is a permanent identifier for this item\n        :returns: Id and permalink setting of the entry.\n        '''\n        if guid is not None:\n            self.__atom_id = guid\n            self.__rss_guid = {'guid': guid, 'permalink': permalink}\n        return self.__rss_guid\n\n    def updated(self, updated=None):\n        '''Set or get the updated value which indicates the last time the entry\n        was modified in a significant way.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        :param updated: The modification date.\n        :returns: Modification date as datetime.datetime\n        '''\n        if updated is not None:\n            if isinstance(updated, string_types):\n                updated = dateutil.parser.parse(updated)\n            if not isinstance(updated, datetime):\n                raise ValueError('Invalid datetime format')\n            if updated.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__atom_updated = updated\n            self.__rss_lastBuildDate = updated\n\n        return self.__atom_updated\n\n    def author(self, author=None, replace=False, **kwargs):\n        '''Get or set author data. An author element is a dict containing a\n        name, an email address and a uri. Name is mandatory for ATOM, email is\n        mandatory for RSS.\n\n        This method can be called with:\n        - the fields of an author as keyword arguments\n        - the fields of an author as a dictionary\n        - a list of dictionaries containing the author fields\n\n        An author has the following fields:\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param author:  Dict or list of dicts with author data.\n        :param replace: Add or replace old data.\n\n        Example::\n\n            >>> author({'name':'John Doe', 'email':'jdoe@example.com'})\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n            >>> author([{'name': 'Mr. X'}, {'name': 'Max'}])\n            [{'name':'John Doe','email':'jdoe@example.com'},\n                    {'name':'John Doe'}, {'name':'Max'}]\n\n            >>> author(name='John Doe', email='jdoe@example.com', replace=True)\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n        '''\n        if author is None and kwargs:\n            author = kwargs\n        if author is not None:\n            if replace or self.__atom_author is None:\n                self.__atom_author = []\n            self.__atom_author += ensure_format(author,\n                                                set(['name', 'email', 'uri']),\n                                                set())\n            self.__rss_author = []\n            for a in self.__atom_author:\n                if a.get('email'):\n                    if a.get('name'):\n                        self.__rss_author.append('%(email)s (%(name)s)' % a)\n                    else:\n                        self.__rss_author.append('%(email)s' % a)\n        return self.__atom_author\n\n    def content(self, content=None, src=None, type=None):\n        '''Get or set the content of the entry which contains or links to the\n        complete content of the entry. Content must be provided for ATOM\n        entries if there is no alternate link, and should be provided if there\n        is no summary. If the content is set (not linked) it will also set\n        rss:description.\n\n        :param content: The content of the feed entry.\n        :param src: Link to the entries content.\n        :param type: If type is CDATA content would not be escaped.\n        :returns: Content element of the entry.\n        '''\n        if src is not None:\n            self.__atom_content = {'src': src}\n        elif content is not None:\n            self.__atom_content = {'content': content}\n            self.__rss_content = {'content': content}\n            if type is not None:\n                self.__atom_content['type'] = type\n                self.__rss_content['type'] = type\n        return self.__atom_content\n\n    def link(self, link=None, replace=False, **kwargs):\n        '''Get or set link data. An link element is a dict with the fields\n        href, rel, type, hreflang, title, and length. Href is mandatory for\n        ATOM.\n\n        This method can be called with:\n        - the fields of a link as keyword arguments\n        - the fields of a link as a dictionary\n        - a list of dictionaries containing the link fields\n\n        A link has the following fields:\n\n        - *href* is the URI of the referenced resource (typically a Web page)\n        - *rel* contains a single link relationship type. It can be a full URI,\n          or one of the following predefined values (default=alternate):\n\n            - *alternate* an alternate representation of the entry or feed, for\n              example a permalink to the html version of the entry, or the\n              front page of the weblog.\n            - *enclosure* a related resource which is potentially large in size\n              and might require special handling, for example an audio or video\n              recording.\n            - *related* an document related to the entry or feed.\n            - *self* the feed itself.\n            - *via* the source of the information provided in the entry.\n\n        - *type* indicates the media type of the resource.\n        - *hreflang* indicates the language of the referenced resource.\n        - *title* human readable information about the link, typically for\n          display purposes.\n        - *length* the length of the resource, in bytes.\n\n        RSS only supports one link with nothing but a URL. So for the RSS link\n        element the last link with rel=alternate is used.\n\n        RSS also supports one enclusure element per entry which is covered by\n        the link element in ATOM feed entries. So for the RSS enclusure element\n        the last link with rel=enclosure is used.\n\n        :param link:    Dict or list of dicts with data.\n        :param replace: Add or replace old data.\n        :returns: List of link data.\n        '''\n        if link is None and kwargs:\n            link = kwargs\n        if link is not None:\n            if replace or self.__atom_link is None:\n                self.__atom_link = []\n            self.__atom_link += ensure_format(\n                link,\n                set(['href', 'rel', 'type', 'hreflang', 'title', 'length']),\n                set(['href']),\n                {'rel': ['alternate', 'enclosure', 'related', 'self', 'via']},\n                {'rel': 'alternate'})\n            # RSS only needs one URL. We use the first link for RSS:\n            for l in self.__atom_link:\n                if l.get('rel') == 'alternate':\n                    self.__rss_link = l['href']\n                elif l.get('rel') == 'enclosure':\n                    self.__rss_enclosure = {'url': l['href']}\n                    self.__rss_enclosure['type'] = l.get('type')\n                    self.__rss_enclosure['length'] = l.get('length') or '0'\n        # return the set with more information (atom)\n        return self.__atom_link\n\n    def summary(self, summary=None, type=None):\n        '''Get or set the summary element of an entry which conveys a short\n        summary, abstract, or excerpt of the entry. Summary is an ATOM only\n        element and should be provided if there either is no content provided\n        for the entry, or that content is not inline (i.e., contains a src\n        attribute), or if the content is encoded in base64.  This method will\n        also set the rss:description field if it wasn't previously set or\n        contains the old value of summary.\n\n        :param summary: Summary of the entries contents.\n        :returns: Summary of the entries contents.\n        '''\n        if summary is not None:\n            # Replace the RSS description with the summary if it was the\n            # summary before. Not if it is the description.\n            if not self.__rss_description or (\n                self.__atom_summary and\n                self.__rss_description == self.__atom_summary.get(\"summary\")\n            ):\n                self.__rss_description = summary\n\n            self.__atom_summary = {'summary': summary}\n            if type is not None:\n                self.__atom_summary['type'] = type\n        return self.__atom_summary\n\n    def description(self, description=None, isSummary=False):\n        '''Get or set the description value which is the item synopsis.\n        Description is an RSS only element. For ATOM feeds it is split in\n        summary and content. The isSummary parameter can be used to control\n        which ATOM value is set when setting description.\n\n        :param description: Description of the entry.\n        :param isSummary: If the description should be used as content or\n                          summary.\n        :returns: The entries description.\n        '''\n        if description is not None:\n            self.__rss_description = description\n            if isSummary:\n                self.__atom_summary = description\n            else:\n                self.__atom_content = {'content': description}\n        return self.__rss_description\n\n    def category(self, category=None, replace=False, **kwargs):\n        '''Get or set categories that the entry belongs to.\n\n        This method can be called with:\n        - the fields of a category as keyword arguments\n        - the fields of a category as a dictionary\n        - a list of dictionaries containing the category fields\n\n        A categories has the following fields:\n        - *term* identifies the category\n        - *scheme* identifies the categorization scheme via a URI.\n        - *label* provides a human-readable label for display\n\n        If a label is present it is used for the RSS feeds. Otherwise the term\n        is used. The scheme is used for the domain attribute in RSS.\n\n        :param category:    Dict or list of dicts with data.\n        :param replace: Add or replace old data.\n        :returns: List of category data.\n        '''\n        if category is None and kwargs:\n            category = kwargs\n        if category is not None:\n            if replace or self.__atom_category is None:\n                self.__atom_category = []\n            self.__atom_category += ensure_format(\n                    category,\n                    set(['term', 'scheme', 'label']),\n                    set(['term']))\n            # Map the ATOM categories to RSS categories. Use the atom:label as\n            # name or if not present the atom:term. The atom:scheme is the\n            # rss:domain.\n            self.__rss_category = []\n            for cat in self.__atom_category:\n                rss_cat = {}\n                rss_cat['value'] = cat.get('label', cat['term'])\n                if cat.get('scheme'):\n                    rss_cat['domain'] = cat['scheme']\n                self.__rss_category.append(rss_cat)\n        return self.__atom_category\n\n    def contributor(self, contributor=None, replace=False, **kwargs):\n        '''Get or set the contributor data of the feed. This is an ATOM only\n        value.\n\n        This method can be called with:\n        - the fields of an contributor as keyword arguments\n        - the fields of an contributor as a dictionary\n        - a list of dictionaries containing the contributor fields\n\n        An contributor has the following fields:\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param contributor: Dictionary or list of dictionaries with contributor\n                            data.\n        :param replace: Add or replace old data.\n        :returns: List of contributors as dictionaries.\n        '''\n        if contributor is None and kwargs:\n            contributor = kwargs\n        if contributor is not None:\n            if replace or self.__atom_contributor is None:\n                self.__atom_contributor = []\n            self.__atom_contributor += ensure_format(\n                    contributor, set(['name', 'email', 'uri']), set(['name']))\n        return self.__atom_contributor\n\n    def published(self, published=None):\n        '''Set or get the published value which contains the time of the initial\n        creation or first availability of the entry.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        :param published: The creation date.\n        :returns: Creation date as datetime.datetime\n        '''\n        if published is not None:\n            if isinstance(published, string_types):\n                published = dateutil.parser.parse(published)\n            if not isinstance(published, datetime):\n                raise ValueError('Invalid datetime format')\n            if published.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__atom_published = published\n            self.__rss_pubDate = published\n\n        return self.__atom_published\n\n    def pubDate(self, pubDate=None):\n        '''Get or set the pubDate of the entry which indicates when the entry\n        was published. This method is just another name for the published(...)\n        method.\n        '''\n        return self.published(pubDate)\n\n    def pubdate(self, pubDate=None):\n        '''Get or set the pubDate of the entry which indicates when the entry\n        was published. This method is just another name for the published(...)\n        method.\n\n        pubdate(\u2026) is deprecated and may be removed in feedgen \u2265 0.8. Use\n        pubDate(\u2026) instead.\n        '''\n        warnings.warn('pubdate(\u2026) is deprecated and may be removed in feedgen '\n                      '\u2265 0.8. Use pubDate(\u2026) instead.')\n        return self.published(pubDate)\n\n    def rights(self, rights=None):\n        '''Get or set the rights value of the entry which conveys information\n        about rights, e.g. copyrights, held in and over the entry. This ATOM\n        value will also set rss:copyright.\n\n        :param rights: Rights information of the feed.\n        :returns: Rights information of the feed.\n        '''\n        if rights is not None:\n            self.__atom_rights = rights\n        return self.__atom_rights\n\n    def comments(self, comments=None):\n        '''Get or set the value of comments which is the URL of the comments\n        page for the item. This is a RSS only value.\n\n        :param comments: URL to the comments page.\n        :returns: URL to the comments page.\n        '''\n        if comments is not None:\n            self.__rss_comments = comments\n        return self.__rss_comments\n\n    def source(self, url=None, title=None):\n        '''Get or set the source for the current feed entry.\n\n        Note that ATOM feeds support a lot more sub elements than title and URL\n        (which is what RSS supports) but these are currently not supported.\n        Patches are welcome.\n\n        :param url: Link to the source.\n        :param title: Title of the linked resource\n        :returns: Source element as dictionaries.\n        '''\n        if url is not None and title is not None:\n            self.__rss_source = {'url': url, 'title': title}\n            self.__atom_source = {'link': url, 'title': title}\n        return self.__rss_source\n\n    def enclosure(self, url=None, length=None, type=None):\n        '''Get or set the value of enclosure which describes a media object\n        that is attached to the item. This is a RSS only value which is\n        represented by link(rel=enclosure) in ATOM. ATOM feeds can furthermore\n        contain several enclosures while RSS may contain only one. That is why\n        this method, if repeatedly called, will add more than one enclosures to\n        the feed.  However, only the last one is used for RSS.\n\n        :param url: URL of the media object.\n        :param length: Size of the media in bytes.\n        :param type: Mimetype of the linked media.\n        :returns: Data of the enclosure element.\n        '''\n        if url is not None:\n            self.link(href=url, rel='enclosure', type=type, length=length)\n        return self.__rss_enclosure\n\n    def ttl(self, ttl=None):\n        '''Get or set the ttl value. It is an RSS only element. ttl stands for\n        time to live. It's a number of minutes that indicates how long a\n        channel can be cached before refreshing from the source.\n\n        :param ttl: Integer value representing the time to live.\n        :returns: Time to live of of the entry.\n        '''\n        if ttl is not None:\n            self.__rss_ttl = int(ttl)\n        return self.__rss_ttl\n\n    def load_extension(self, name, atom=True, rss=True):\n        '''Load a specific extension by name.\n\n        :param name: Name of the extension to load.\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if name in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n\n        # Load extension\n        extname = name[0].upper() + name[1:] + 'EntryExtension'\n        try:\n            supmod = __import__('feedgen.ext.%s_entry' % name)\n            extmod = getattr(supmod.ext, name + '_entry')\n        except ImportError:\n            # Use FeedExtension module instead\n            supmod = __import__('feedgen.ext.%s' % name)\n            extmod = getattr(supmod.ext, name)\n        ext = getattr(extmod, extname)\n        self.register_extension(name, ext, atom, rss)\n\n    def register_extension(self, namespace, extension_class_entry=None,\n                           atom=True, rss=True):\n        '''Register a specific extension by classes to a namespace.\n\n        :param namespace: namespace for the extension\n        :param extension_class_entry: Class of the entry extension to load.\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        # `load_extension` ignores the \"Extension\" suffix.\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if namespace in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n        if not extension_class_entry:\n            raise ImportError('No extension class')\n\n        extinst = extension_class_entry()\n        setattr(self, namespace, extinst)\n\n        # `load_extension` registry\n        self.__extensions[namespace] = {\n                'inst': extinst,\n                'extension_class_entry': extension_class_entry,\n                'atom': atom,\n                'rss': rss\n                }\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.dc\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to add Dubline Core Elements to the feeds.\n\n    Descriptions partly taken from\n    http://dublincore.org/documents/dcmi-terms/#elements-coverage\n\n    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom lxml import etree\n\nfrom feedgen.ext.base import BaseExtension\n\n\nclass DcBaseExtension(BaseExtension):\n    '''Dublin Core Elements extension for podcasts.\n    '''\n\n    def __init__(self):\n        # http://dublincore.org/documents/usageguide/elements.shtml\n        # http://dublincore.org/documents/dces/\n        # http://dublincore.org/documents/dcmi-terms/\n        self._dcelem_contributor = None\n        self._dcelem_coverage = None\n        self._dcelem_creator = None\n        self._dcelem_date = None\n        self._dcelem_description = None\n        self._dcelem_format = None\n        self._dcelem_identifier = None\n        self._dcelem_language = None\n        self._dcelem_publisher = None\n        self._dcelem_relation = None\n        self._dcelem_rights = None\n        self._dcelem_source = None\n        self._dcelem_subject = None\n        self._dcelem_title = None\n        self._dcelem_type = None\n\n    def extend_ns(self):\n        return {'dc': 'http://purl.org/dc/elements/1.1/'}\n\n    def _extend_xml(self, xml_elem):\n        '''Extend xml_elem with set DC fields.\n\n        :param xml_elem: etree element\n        '''\n        DCELEMENTS_NS = 'http://purl.org/dc/elements/1.1/'\n\n        for elem in ['contributor', 'coverage', 'creator', 'date',\n                     'description', 'language', 'publisher', 'relation',\n                     'rights', 'source', 'subject', 'title', 'type', 'format',\n                     'identifier']:\n            if hasattr(self, '_dcelem_%s' % elem):\n                for val in getattr(self, '_dcelem_%s' % elem) or []:\n                    node = etree.SubElement(xml_elem,\n                                            '{%s}%s' % (DCELEMENTS_NS, elem))\n                    node.text = val\n\n    def extend_atom(self, atom_feed):\n        '''Extend an Atom feed with the set DC fields.\n\n        :param atom_feed: The feed root element\n        :returns: The feed root element\n        '''\n\n        self._extend_xml(atom_feed)\n\n        return atom_feed\n\n    def extend_rss(self, rss_feed):\n        '''Extend a RSS feed with the set DC fields.\n\n        :param rss_feed: The feed root element\n        :returns: The feed root element.\n        '''\n        channel = rss_feed[0]\n        self._extend_xml(channel)\n\n        return rss_feed\n\n    def dc_contributor(self, contributor=None, replace=False):\n        '''Get or set the dc:contributor which is an entity responsible for\n        making contributions to the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-contributor\n\n        :param contributor: Contributor or list of contributors.\n        :param replace: Replace alredy set contributors (deault: False).\n        :returns: List of contributors.\n        '''\n        if contributor is not None:\n            if not isinstance(contributor, list):\n                contributor = [contributor]\n            if replace or not self._dcelem_contributor:\n                self._dcelem_contributor = []\n            self._dcelem_contributor += contributor\n        return self._dcelem_contributor\n\n    def dc_coverage(self, coverage=None, replace=True):\n        '''Get or set the dc:coverage which indicated the spatial or temporal\n        topic of the resource, the spatial applicability of the resource, or\n        the jurisdiction under which the resource is relevant.\n\n        Spatial topic and spatial applicability may be a named place or a\n        location specified by its geographic coordinates. Temporal topic may be\n        a named period, date, or date range. A jurisdiction may be a named\n        administrative entity or a geographic place to which the resource\n        applies. Recommended best practice is to use a controlled vocabulary\n        such as the Thesaurus of Geographic Names [TGN]. Where appropriate,\n        named places or time periods can be used in preference to numeric\n        identifiers such as sets of coordinates or date ranges.\n\n        References:\n        [TGN] http://www.getty.edu/research/tools/vocabulary/tgn/index.html\n\n        :param coverage: Coverage of the feed.\n        :param replace: Replace already set coverage (default: True).\n        :returns: Coverage of the feed.\n        '''\n        if coverage is not None:\n            if not isinstance(coverage, list):\n                coverage = [coverage]\n            if replace or not self._dcelem_coverage:\n                self._dcelem_coverage = []\n            self._dcelem_coverage = coverage\n        return self._dcelem_coverage\n\n    def dc_creator(self, creator=None, replace=False):\n        '''Get or set the dc:creator which is an entity primarily responsible\n        for making the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-creator\n\n        :param creator: Creator or list of creators.\n        :param replace: Replace alredy set creators (deault: False).\n        :returns: List of creators.\n        '''\n        if creator is not None:\n            if not isinstance(creator, list):\n                creator = [creator]\n            if replace or not self._dcelem_creator:\n                self._dcelem_creator = []\n            self._dcelem_creator += creator\n        return self._dcelem_creator\n\n    def dc_date(self, date=None, replace=True):\n        '''Get or set the dc:date which describes a point or period of time\n        associated with an event in the lifecycle of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-date\n\n        :param date: Date or list of dates.\n        :param replace: Replace alredy set dates (deault: True).\n        :returns: List of dates.\n        '''\n        if date is not None:\n            if not isinstance(date, list):\n                date = [date]\n            if replace or not self._dcelem_date:\n                self._dcelem_date = []\n            self._dcelem_date += date\n        return self._dcelem_date\n\n    def dc_description(self, description=None, replace=True):\n        '''Get or set the dc:description which is an account of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-description\n\n        :param description: Description or list of descriptions.\n        :param replace: Replace alredy set descriptions (deault: True).\n        :returns: List of descriptions.\n        '''\n        if description is not None:\n            if not isinstance(description, list):\n                description = [description]\n            if replace or not self._dcelem_description:\n                self._dcelem_description = []\n            self._dcelem_description += description\n        return self._dcelem_description\n\n    def dc_format(self, format=None, replace=True):\n        '''Get or set the dc:format which describes the file format, physical\n        medium, or dimensions of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-format\n\n        :param format: Format of the resource or list of formats.\n        :param replace: Replace alredy set format (deault: True).\n        :returns: Format of the resource.\n        '''\n        if format is not None:\n            if not isinstance(format, list):\n                format = [format]\n            if replace or not self._dcelem_format:\n                self._dcelem_format = []\n            self._dcelem_format += format\n        return self._dcelem_format\n\n    def dc_identifier(self, identifier=None, replace=True):\n        '''Get or set the dc:identifier which should be an unambiguous\n        reference to the resource within a given context.\n\n        For more inidentifierion see:\n        http://dublincore.org/documents/dcmi-terms/#elements-identifier\n\n        :param identifier: Identifier of the resource or list of identifiers.\n        :param replace: Replace alredy set identifier (deault: True).\n        :returns: Identifiers of the resource.\n        '''\n        if identifier is not None:\n            if not isinstance(identifier, list):\n                identifier = [identifier]\n            if replace or not self._dcelem_identifier:\n                self._dcelem_identifier = []\n            self._dcelem_identifier += identifier\n        return self._dcelem_identifier\n\n    def dc_language(self, language=None, replace=True):\n        '''Get or set the dc:language which describes a language of the\n        resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-language\n\n        :param language: Language or list of languages.\n        :param replace: Replace alredy set languages (deault: True).\n        :returns: List of languages.\n        '''\n        if language is not None:\n            if not isinstance(language, list):\n                language = [language]\n            if replace or not self._dcelem_language:\n                self._dcelem_language = []\n            self._dcelem_language += language\n        return self._dcelem_language\n\n    def dc_publisher(self, publisher=None, replace=False):\n        '''Get or set the dc:publisher which is an entity responsible for\n        making the resource available.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-publisher\n\n        :param publisher: Publisher or list of publishers.\n        :param replace: Replace alredy set publishers (deault: False).\n        :returns: List of publishers.\n        '''\n        if publisher is not None:\n            if not isinstance(publisher, list):\n                publisher = [publisher]\n            if replace or not self._dcelem_publisher:\n                self._dcelem_publisher = []\n            self._dcelem_publisher += publisher\n        return self._dcelem_publisher\n\n    def dc_relation(self, relation=None, replace=False):\n        '''Get or set the dc:relation which describes a related resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-relation\n\n        :param relation: Relation or list of relations.\n        :param replace: Replace alredy set relations (deault: False).\n        :returns: List of relations.\n        '''\n        if relation is not None:\n            if not isinstance(relation, list):\n                relation = [relation]\n            if replace or not self._dcelem_relation:\n                self._dcelem_relation = []\n            self._dcelem_relation += relation\n        return self._dcelem_relation\n\n    def dc_rights(self, rights=None, replace=False):\n        '''Get or set the dc:rights which may contain information about rights\n        held in and over the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-rights\n\n        :param rights: Rights information or list of rights information.\n        :param replace: Replace alredy set rightss (deault: False).\n        :returns: List of rights information.\n        '''\n        if rights is not None:\n            if not isinstance(rights, list):\n                rights = [rights]\n            if replace or not self._dcelem_rights:\n                self._dcelem_rights = []\n            self._dcelem_rights += rights\n        return self._dcelem_rights\n\n    def dc_source(self, source=None, replace=False):\n        '''Get or set the dc:source which is a related resource from which the\n        described resource is derived.\n\n        The described resource may be derived from the related resource in\n        whole or in part. Recommended best practice is to identify the related\n        resource by means of a string conforming to a formal identification\n        system.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-source\n\n        :param source: Source or list of sources.\n        :param replace: Replace alredy set sources (deault: False).\n        :returns: List of sources.\n        '''\n        if source is not None:\n            if not isinstance(source, list):\n                source = [source]\n            if replace or not self._dcelem_source:\n                self._dcelem_source = []\n            self._dcelem_source += source\n        return self._dcelem_source\n\n    def dc_subject(self, subject=None, replace=False):\n        '''Get or set the dc:subject which describes the topic of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-subject\n\n        :param subject: Subject or list of subjects.\n        :param replace: Replace alredy set subjects (deault: False).\n        :returns: List of subjects.\n        '''\n        if subject is not None:\n            if not isinstance(subject, list):\n                subject = [subject]\n            if replace or not self._dcelem_subject:\n                self._dcelem_subject = []\n            self._dcelem_subject += subject\n        return self._dcelem_subject\n\n    def dc_title(self, title=None, replace=True):\n        '''Get or set the dc:title which is a name given to the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-title\n\n        :param title: Title or list of titles.\n        :param replace: Replace alredy set titles (deault: False).\n        :returns: List of titles.\n        '''\n        if title is not None:\n            if not isinstance(title, list):\n                title = [title]\n            if replace or not self._dcelem_title:\n                self._dcelem_title = []\n            self._dcelem_title += title\n        return self._dcelem_title\n\n    def dc_type(self, type=None, replace=False):\n        '''Get or set the dc:type which describes the nature or genre of the\n        resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-type\n\n        :param type: Type or list of types.\n        :param replace: Replace alredy set types (deault: False).\n        :returns: List of types.\n        '''\n        if type is not None:\n            if not isinstance(type, list):\n                type = [type]\n            if replace or not self._dcelem_type:\n                self._dcelem_type = []\n            self._dcelem_type += type\n        return self._dcelem_type\n\n\nclass DcExtension(DcBaseExtension):\n    '''Dublin Core Elements extension for podcasts.\n    '''\n\n\nclass DcEntryExtension(DcBaseExtension):\n    '''Dublin Core Elements extension for podcasts.\n    '''\n    def extend_atom(self, entry):\n        '''Add dc elements to an atom item. Alters the item itself.\n\n        :param entry: An atom entry element.\n        :returns: The entry element.\n        '''\n        self._extend_xml(entry)\n        return entry\n\n    def extend_rss(self, item):\n        '''Add dc elements to a RSS item. Alters the item itself.\n\n        :param item: A RSS item element.\n        :returns: The item element.\n        '''\n        self._extend_xml(item)\n        return item\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.geo_entry\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to produce Simple GeoRSS feeds.\n\n    :copyright: 2017, Bob Breznak <bob.breznak@gmail.com>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\nimport numbers\nimport warnings\n\nfrom lxml import etree\nfrom feedgen.ext.base import BaseEntryExtension\n\n\nclass GeoRSSPolygonInteriorWarning(Warning):\n    \"\"\"\n    Simple placeholder for warning about ignored polygon interiors.\n\n    Stores the original geom on a ``geom`` attribute (if required warnings are\n    raised as errors).\n    \"\"\"\n\n    def __init__(self, geom, *args, **kwargs):\n        self.geom = geom\n        super(GeoRSSPolygonInteriorWarning, self).__init__(*args, **kwargs)\n\n    def __str__(self):\n        return '{:d} interiors of polygon ignored'.format(\n            len(self.geom.__geo_interface__['coordinates']) - 1\n        )  # ignore exterior in count\n\n\nclass GeoRSSGeometryError(ValueError):\n    \"\"\"\n    Subclass of ValueError for a GeoRSS geometry error\n\n    Only some geometries are supported in Simple GeoRSS, so if not raise an\n    error. Offending geometry is stored on the ``geom`` attribute.\n    \"\"\"\n\n    def __init__(self, geom, *args, **kwargs):\n        self.geom = geom\n        super(GeoRSSGeometryError, self).__init__(*args, **kwargs)\n\n    def __str__(self):\n        msg = \"Geometry of type '{}' not in Point, Linestring or Polygon\"\n        return msg.format(\n            self.geom.__geo_interface__['type']\n        )\n\n\nclass GeoEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for Simple GeoRSS.\n    '''\n\n    def __init__(self):\n        '''Simple GeoRSS tag'''\n        # geometries\n        self.__point = None\n        self.__line = None\n        self.__polygon = None\n        self.__box = None\n\n        # additional properties\n        self.__featuretypetag = None\n        self.__relationshiptag = None\n        self.__featurename = None\n\n        # elevation\n        self.__elev = None\n        self.__floor = None\n\n        # radius\n        self.__radius = None\n\n    def extend_file(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n\n        GEO_NS = 'http://www.georss.org/georss'\n\n        if self.__point:\n            point = etree.SubElement(entry, '{%s}point' % GEO_NS)\n            point.text = self.__point\n\n        if self.__line:\n            line = etree.SubElement(entry, '{%s}line' % GEO_NS)\n            line.text = self.__line\n\n        if self.__polygon:\n            polygon = etree.SubElement(entry, '{%s}polygon' % GEO_NS)\n            polygon.text = self.__polygon\n\n        if self.__box:\n            box = etree.SubElement(entry, '{%s}box' % GEO_NS)\n            box.text = self.__box\n\n        if self.__featuretypetag:\n            featuretypetag = etree.SubElement(\n                entry,\n                '{%s}featuretypetag' % GEO_NS\n            )\n            featuretypetag.text = self.__featuretypetag\n\n        if self.__relationshiptag:\n            relationshiptag = etree.SubElement(\n                entry,\n                '{%s}relationshiptag' % GEO_NS\n            )\n            relationshiptag.text = self.__relationshiptag\n\n        if self.__featurename:\n            featurename = etree.SubElement(entry, '{%s}featurename' % GEO_NS)\n            featurename.text = self.__featurename\n\n        if self.__elev:\n            elevation = etree.SubElement(entry, '{%s}elev' % GEO_NS)\n            elevation.text = str(self.__elev)\n\n        if self.__floor:\n            floor = etree.SubElement(entry, '{%s}floor' % GEO_NS)\n            floor.text = str(self.__floor)\n\n        if self.__radius:\n            radius = etree.SubElement(entry, '{%s}radius' % GEO_NS)\n            radius.text = str(self.__radius)\n\n        return entry\n\n    def extend_rss(self, entry):\n        return self.extend_file(entry)\n\n    def extend_atom(self, entry):\n        return self.extend_file(entry)\n\n    def point(self, point=None):\n        '''Get or set the georss:point of the entry.\n\n        :param point: The GeoRSS formatted point (i.e. \"42.36 -71.05\")\n        :returns: The current georss:point of the entry.\n        '''\n\n        if point is not None:\n            self.__point = point\n\n        return self.__point\n\n    def line(self, line=None):\n        '''Get or set the georss:line of the entry\n\n        :param point: The GeoRSS formatted line (i.e. \"45.256 -110.45 46.46\n                      -109.48 43.84 -109.86\")\n        :return: The current georss:line of the entry\n        '''\n        if line is not None:\n            self.__line = line\n\n        return self.__line\n\n    def polygon(self, polygon=None):\n        '''Get or set the georss:polygon of the entry\n\n        :param polygon: The GeoRSS formatted polygon (i.e. \"45.256 -110.45\n                        46.46 -109.48 43.84 -109.86 45.256 -110.45\")\n        :return: The current georss:polygon of the entry\n        '''\n        if polygon is not None:\n            self.__polygon = polygon\n\n        return self.__polygon\n\n    def box(self, box=None):\n        '''\n        Get or set the georss:box of the entry\n\n        :param box: The GeoRSS formatted box (i.e. \"42.943 -71.032 43.039\n                    -69.856\")\n        :return: The current georss:box of the entry\n        '''\n        if box is not None:\n            self.__box = box\n\n        return self.__box\n\n    def featuretypetag(self, featuretypetag=None):\n        '''\n        Get or set the georss:featuretypetag of the entry\n\n        :param featuretypetag: The GeoRSS feaaturertyptag (e.g. \"city\")\n        :return: The current georss:featurertypetag\n        '''\n        if featuretypetag is not None:\n            self.__featuretypetag = featuretypetag\n\n        return self.__featuretypetag\n\n    def relationshiptag(self, relationshiptag=None):\n        '''\n        Get or set the georss:relationshiptag of the entry\n\n        :param relationshiptag: The GeoRSS relationshiptag (e.g.\n                                \"is-centred-at\")\n        :return: the current georss:relationshiptag\n        '''\n        if relationshiptag is not None:\n            self.__relationshiptag = relationshiptag\n\n        return self.__relationshiptag\n\n    def featurename(self, featurename=None):\n        '''\n        Get or set the georss:featurename of the entry\n\n        :param featuretypetag: The GeoRSS featurename (e.g. \"Footscray\")\n        :return: the current georss:featurename\n        '''\n        if featurename is not None:\n            self.__featurename = featurename\n\n        return self.__featurename\n\n    def elev(self, elev=None):\n        '''\n        Get or set the georss:elev of the entry\n\n        :param elev: The GeoRSS elevation (e.g. 100.3)\n        :type elev: numbers.Number\n        :return: the current georss:elev\n        '''\n        if elev is not None:\n            if not isinstance(elev, numbers.Number):\n                raise ValueError(\"elev tag must be numeric: {}\".format(elev))\n\n            self.__elev = elev\n\n        return self.__elev\n\n    def floor(self, floor=None):\n        '''\n        Get or set the georss:floor of the entry\n\n        :param floor: The GeoRSS floor (e.g. 4)\n        :type floor: int\n        :return: the current georss:floor\n        '''\n        if floor is not None:\n            if not isinstance(floor, int):\n                raise ValueError(\"floor tag must be int: {}\".format(floor))\n\n            self.__floor = floor\n\n        return self.__floor\n\n    def radius(self, radius=None):\n        '''\n        Get or set the georss:radius of the entry\n\n        :param radius: The GeoRSS radius (e.g. 100.3)\n        :type radius: numbers.Number\n        :return: the current georss:radius\n        '''\n        if radius is not None:\n            if not isinstance(radius, numbers.Number):\n                raise ValueError(\n                    \"radius tag must be numeric: {}\".format(radius)\n                )\n\n            self.__radius = radius\n\n        return self.__radius\n\n    def geom_from_geo_interface(self, geom):\n        '''\n        Generate a georss geometry from some Python object with a\n        ``__geo_interface__`` property (see the `geo_interface specification by\n        Sean Gillies`_geointerface )\n\n        Note only a subset of GeoJSON (see `geojson.org`_geojson ) can be\n        easily converted to GeoRSS:\n\n        - Point\n        - LineString\n        - Polygon (if there are holes / donuts in the polygons a warning will\n          be generaated\n\n        Other GeoJson types will raise a ``ValueError``.\n\n        .. note:: The geometry is assumed to be x, y as longitude, latitude in\n           the WGS84 projection.\n\n        .. _geointerface: https://gist.github.com/sgillies/2217756\n        .. _geojson: https://geojson.org/\n\n        :param geom: Geometry object with a __geo_interface__ property\n        :return: the formatted GeoRSS geometry\n        '''\n        geojson = geom.__geo_interface__\n\n        if geojson['type'] not in ('Point', 'LineString', 'Polygon'):\n            raise GeoRSSGeometryError(geom)\n\n        if geojson['type'] == 'Point':\n\n            coords = '{:f} {:f}'.format(\n                geojson['coordinates'][1],  # latitude is y\n                geojson['coordinates'][0]\n            )\n            return self.point(coords)\n\n        elif geojson['type'] == 'LineString':\n\n            coords = ' '.join(\n                '{:f} {:f}'.format(vertex[1], vertex[0])\n                for vertex in\n                geojson['coordinates']\n            )\n            return self.line(coords)\n\n        elif geojson['type'] == 'Polygon':\n\n            if len(geojson['coordinates']) > 1:\n                warnings.warn(GeoRSSPolygonInteriorWarning(geom))\n\n            coords = ' '.join(\n                '{:f} {:f}'.format(vertex[1], vertex[0])\n                for vertex in\n                geojson['coordinates'][0]\n            )\n            return self.polygon(coords)\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.media\n    ~~~~~~~~~~~~~~~~~\n\n    Extends the feedgen to produce media tags.\n\n    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom lxml import etree\n\nfrom feedgen.ext.base import BaseEntryExtension, BaseExtension\nfrom feedgen.util import ensure_format\n\nMEDIA_NS = 'http://search.yahoo.com/mrss/'\n\n\nclass MediaExtension(BaseExtension):\n    '''FeedGenerator extension for torrent feeds.\n    '''\n\n    def extend_ns(self):\n        return {'media': MEDIA_NS}\n\n\nclass MediaEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for media tags.\n    '''\n\n    def __init__(self):\n        self.__media_content = []\n        self.__media_thumbnail = []\n\n    def extend_atom(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n\n        groups = {None: entry}\n        for media_content in self.__media_content:\n            # Define current media:group\n            group = groups.get(media_content.get('group'))\n            if group is None:\n                group = etree.SubElement(entry, '{%s}group' % MEDIA_NS)\n                groups[media_content.get('group')] = group\n            # Add content\n            content = etree.SubElement(group, '{%s}content' % MEDIA_NS)\n            for attr in ('url', 'fileSize', 'type', 'medium', 'isDefault',\n                         'expression', 'bitrate', 'framerate', 'samplingrate',\n                         'channels', 'duration', 'height', 'width', 'lang'):\n                if media_content.get(attr):\n                    content.set(attr, media_content[attr])\n\n        for media_thumbnail in self.__media_thumbnail:\n            # Define current media:group\n            group = groups.get(media_thumbnail.get('group'))\n            if group is None:\n                group = etree.SubElement(entry, '{%s}group' % MEDIA_NS)\n                groups[media_thumbnail.get('group')] = group\n            # Add thumbnails\n            thumbnail = etree.SubElement(group, '{%s}thumbnail' % MEDIA_NS)\n            for attr in ('url', 'height', 'width', 'time'):\n                if media_thumbnail.get(attr):\n                    thumbnail.set(attr, media_thumbnail[attr])\n\n        return entry\n\n    def extend_rss(self, item):\n        return self.extend_atom(item)\n\n    def content(self, content=None, replace=False, group='default', **kwargs):\n        '''Get or set media:content data.\n\n        This method can be called with:\n        - the fields of a media:content as keyword arguments\n        - the fields of a media:content as a dictionary\n        - a list of dictionaries containing the media:content fields\n\n        <media:content> is a sub-element of either <item> or <media:group>.\n        Media objects that are not the same content should not be included in\n        the same <media:group> element. The sequence of these items implies\n        the order of presentation. While many of the attributes appear to be\n        audio/video specific, this element can be used to publish any type\n        of media. It contains 14 attributes, most of which are optional.\n\n        media:content has the following fields:\n        - *url* should specify the direct URL to the media object.\n        - *fileSize* number of bytes of the media object.\n        - *type* standard MIME type of the object.\n        - *medium* type of object (image | audio | video | document |\n          executable).\n        - *isDefault* determines if this is the default object.\n        - *expression* determines if the object is a sample or the full version\n          of the object, or even if it is a continuous stream (sample | full |\n          nonstop).\n        - *bitrate* kilobits per second rate of media.\n        - *framerate* number of frames per second for the media object.\n        - *samplingrate* number of samples per second taken to create the media\n          object. It is expressed in thousands of samples per second (kHz).\n        - *channels* number of audio channels in the media object.\n        - *duration* number of seconds the media object plays.\n        - *height* height of the media object.\n        - *width* width of the media object.\n        - *lang* is the primary language encapsulated in the media object.\n\n        :param content: Dictionary or list of dictionaries with content data.\n        :param replace: Add or replace old data.\n        :param group: Media group to put this content in.\n\n        :returns: The media content tag.\n        '''\n        # Handle kwargs\n        if content is None and kwargs:\n            content = kwargs\n        # Handle new data\n        if content is not None:\n            # Reset data if we want to replace them\n            if replace or self.__media_content is None:\n                self.__media_content = []\n            # Ensure list\n            if not isinstance(content, list):\n                content = [content]\n            # define media group\n            for c in content:\n                c['group'] = c.get('group', group)\n            self.__media_content += ensure_format(\n                    content,\n                    set(['url', 'fileSize', 'type', 'medium', 'isDefault',\n                         'expression', 'bitrate', 'framerate', 'samplingrate',\n                         'channels', 'duration', 'height', 'width', 'lang',\n                         'group']),\n                    set(['url', 'group']))\n        return self.__media_content\n\n    def thumbnail(self, thumbnail=None, replace=False, group='default',\n                  **kwargs):\n        '''Get or set media:thumbnail data.\n\n        This method can be called with:\n        - the fields of a media:content as keyword arguments\n        - the fields of a media:content as a dictionary\n        - a list of dictionaries containing the media:content fields\n\n        Allows particular images to be used as representative images for\n        the media object. If multiple thumbnails are included, and time\n        coding is not at play, it is assumed that the images are in order\n        of importance. It has one required attribute and three optional\n        attributes.\n\n        media:thumbnail has the following fields:\n        - *url* should specify the direct URL to the media object.\n        - *height* height of the media object.\n        - *width* width of the media object.\n        - *time* specifies the time offset in relation to the media object.\n\n        :param thumbnail: Dictionary or list of dictionaries with thumbnail\n                          data.\n        :param replace: Add or replace old data.\n        :param group: Media group to put this content in.\n\n        :returns: The media thumbnail tag.\n        '''\n        # Handle kwargs\n        if thumbnail is None and kwargs:\n            thumbnail = kwargs\n        # Handle new data\n        if thumbnail is not None:\n            # Reset data if we want to replace them\n            if replace or self.__media_thumbnail is None:\n                self.__media_thumbnail = []\n            # Ensure list\n            if not isinstance(thumbnail, list):\n                thumbnail = [thumbnail]\n            # Define media group\n            for t in thumbnail:\n                t['group'] = t.get('group', group)\n            self.__media_thumbnail += ensure_format(\n                    thumbnail,\n                    set(['url', 'height', 'width', 'time', 'group']),\n                    set(['url', 'group']))\n        return self.__media_thumbnail\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.podcast\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to produce podcasts.\n\n    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom lxml import etree\n\nfrom feedgen.compat import string_types\nfrom feedgen.ext.base import BaseExtension\nfrom feedgen.util import ensure_format\n\n\nclass PodcastExtension(BaseExtension):\n    '''FeedGenerator extension for podcasts.\n    '''\n\n    def __init__(self):\n        # ITunes tags\n        # http://www.apple.com/itunes/podcasts/specs.html#rss\n        self.__itunes_author = None\n        self.__itunes_block = None\n        self.__itunes_category = None\n        self.__itunes_image = None\n        self.__itunes_explicit = None\n        self.__itunes_complete = None\n        self.__itunes_new_feed_url = None\n        self.__itunes_owner = None\n        self.__itunes_subtitle = None\n        self.__itunes_summary = None\n\n    def extend_ns(self):\n        return {'itunes': 'http://www.itunes.com/dtds/podcast-1.0.dtd'}\n\n    def extend_rss(self, rss_feed):\n        '''Extend an RSS feed root with set itunes fields.\n\n        :returns: The feed root element.\n        '''\n        ITUNES_NS = 'http://www.itunes.com/dtds/podcast-1.0.dtd'\n        channel = rss_feed[0]\n\n        if self.__itunes_author:\n            author = etree.SubElement(channel, '{%s}author' % ITUNES_NS)\n            author.text = self.__itunes_author\n\n        if self.__itunes_block is not None:\n            block = etree.SubElement(channel, '{%s}block' % ITUNES_NS)\n            block.text = 'yes' if self.__itunes_block else 'no'\n\n        for c in self.__itunes_category or []:\n            if not c.get('cat'):\n                continue\n            category = channel.find(\n                    '{%s}category[@text=\"%s\"]' % (ITUNES_NS, c.get('cat')))\n            if category is None:\n                category = etree.SubElement(channel,\n                                            '{%s}category' % ITUNES_NS)\n                category.attrib['text'] = c.get('cat')\n\n            if c.get('sub'):\n                subcategory = etree.SubElement(category,\n                                               '{%s}category' % ITUNES_NS)\n                subcategory.attrib['text'] = c.get('sub')\n\n        if self.__itunes_image:\n            image = etree.SubElement(channel, '{%s}image' % ITUNES_NS)\n            image.attrib['href'] = self.__itunes_image\n\n        if self.__itunes_explicit in ('yes', 'no', 'clean'):\n            explicit = etree.SubElement(channel, '{%s}explicit' % ITUNES_NS)\n            explicit.text = self.__itunes_explicit\n\n        if self.__itunes_complete in ('yes', 'no'):\n            complete = etree.SubElement(channel, '{%s}complete' % ITUNES_NS)\n            complete.text = self.__itunes_complete\n\n        if self.__itunes_new_feed_url:\n            new_feed_url = etree.SubElement(channel,\n                                            '{%s}new-feed-url' % ITUNES_NS)\n            new_feed_url.text = self.__itunes_new_feed_url\n\n        if self.__itunes_owner:\n            owner = etree.SubElement(channel, '{%s}owner' % ITUNES_NS)\n            owner_name = etree.SubElement(owner, '{%s}name' % ITUNES_NS)\n            owner_name.text = self.__itunes_owner.get('name')\n            owner_email = etree.SubElement(owner, '{%s}email' % ITUNES_NS)\n            owner_email.text = self.__itunes_owner.get('email')\n\n        if self.__itunes_subtitle:\n            subtitle = etree.SubElement(channel, '{%s}subtitle' % ITUNES_NS)\n            subtitle.text = self.__itunes_subtitle\n\n        if self.__itunes_summary:\n            summary = etree.SubElement(channel, '{%s}summary' % ITUNES_NS)\n            summary.text = self.__itunes_summary\n\n        return rss_feed\n\n    def itunes_author(self, itunes_author=None):\n        '''Get or set the itunes:author. The content of this tag is shown in\n        the Artist column in iTunes. If the tag is not present, iTunes uses the\n        contents of the <author> tag. If <itunes:author> is not present at the\n        feed level, iTunes will use the contents of <managingEditor>.\n\n        :param itunes_author: The author of the podcast.\n        :returns: The author of the podcast.\n        '''\n        if itunes_author is not None:\n            self.__itunes_author = itunes_author\n        return self.__itunes_author\n\n    def itunes_block(self, itunes_block=None):\n        '''Get or set the ITunes block attribute. Use this to prevent the\n        entire podcast from appearing in the iTunes podcast directory.\n\n        :param itunes_block: Block the podcast.\n        :returns: If the podcast is blocked.\n        '''\n        if itunes_block is not None:\n            self.__itunes_block = itunes_block\n        return self.__itunes_block\n\n    def itunes_category(self, itunes_category=None, replace=False, **kwargs):\n        '''Get or set the ITunes category which appears in the category column\n        and in iTunes Store Browser.\n\n        The (sub-)category has to be one from the values defined at\n        http://www.apple.com/itunes/podcasts/specs.html#categories\n\n        This method can be called with:\n\n        - the fields of an itunes_category as keyword arguments\n        - the fields of an itunes_category as a dictionary\n        - a list of dictionaries containing the itunes_category fields\n\n        An itunes_category has the following fields:\n\n        - *cat* name for a category.\n        - *sub* name for a subcategory, child of category\n\n        If a podcast has more than one subcategory from the same category, the\n        category is called more than once.\n\n        Likei the parameter::\n\n            [{\"cat\":\"Arts\",\"sub\":\"Design\"},{\"cat\":\"Arts\",\"sub\":\"Food\"}]\n\n        \u2026would become::\n\n            <itunes:category text=\"Arts\">\n                <itunes:category text=\"Design\"/>\n                <itunes:category text=\"Food\"/>\n            </itunes:category>\n\n\n        :param itunes_category: Dictionary or list of dictionaries with\n                                itunes_category data.\n        :param replace: Add or replace old data.\n        :returns: List of itunes_categories as dictionaries.\n\n        ---\n\n        **Important note about deprecated parameter syntax:** Old version of\n        the feedgen did only support one category plus one subcategory which\n        would be passed to this ducntion as first two parameters. For\n        compatibility reasons, this still works but should not be used any may\n        be removed at any time.\n        '''\n        # Ensure old API still works for now. Note that the API is deprecated\n        # and this fallback may be removed at any time.\n        if isinstance(itunes_category, string_types):\n            itunes_category = {'cat': itunes_category}\n            if replace:\n                itunes_category['sub'] = replace\n            replace = True\n        if itunes_category is None and kwargs:\n            itunes_category = kwargs\n        if itunes_category is not None:\n            if replace or self.__itunes_category is None:\n                self.__itunes_category = []\n            self.__itunes_category += ensure_format(itunes_category,\n                                                    set(['cat', 'sub']),\n                                                    set(['cat']))\n        return self.__itunes_category\n\n    def itunes_image(self, itunes_image=None):\n        '''Get or set the image for the podcast. This tag specifies the artwork\n        for your podcast. Put the URL to the image in the href attribute.\n        iTunes prefers square .jpg images that are at least 1400x1400 pixels,\n        which is different from what is specified for the standard RSS image\n        tag. In order for a podcast to be eligible for an iTunes Store feature,\n        the accompanying image must be at least 1400x1400 pixels.\n\n        iTunes supports images in JPEG and PNG formats with an RGB color space\n        (CMYK is not supported). The URL must end in \".jpg\" or \".png\". If the\n        <itunes:image> tag is not present, iTunes will use the contents of the\n        RSS image tag.\n\n        If you change your podcast\u2019s image, also change the file\u2019s name. iTunes\n        may not change the image if it checks your feed and the image URL is\n        the same. The server hosting your cover art image must allow HTTP head\n        requests for iTS to be able to automatically update your cover art.\n\n        :param itunes_image: Image of the podcast.\n        :returns: Image of the podcast.\n        '''\n        if itunes_image is not None:\n            if itunes_image.endswith('.jpg') or itunes_image.endswith('.png'):\n                self.__itunes_image = itunes_image\n            else:\n                ValueError('Image file must be png or jpg')\n        return self.__itunes_image\n\n    def itunes_explicit(self, itunes_explicit=None):\n        '''Get or the the itunes:explicit value of the podcast. This tag should\n        be used to indicate whether your podcast contains explicit material.\n        The three values for this tag are \"yes\", \"no\", and \"clean\".\n\n        If you populate this tag with \"yes\", an \"explicit\" parental advisory\n        graphic will appear next to your podcast artwork on the iTunes Store\n        and in the Name column in iTunes. If the value is \"clean\", the parental\n        advisory type is considered Clean, meaning that no explicit language or\n        adult content is included anywhere in the episodes, and a \"clean\"\n        graphic will appear. If the explicit tag is present and has any other\n        value (e.g., \"no\"), you see no indicator \u2014 blank is the default\n        advisory type.\n\n        :param itunes_explicit: If the podcast contains explicit material.\n        :returns: If the podcast contains explicit material.\n        '''\n        if itunes_explicit is not None:\n            if itunes_explicit not in ('', 'yes', 'no', 'clean'):\n                raise ValueError('Invalid value for explicit tag')\n            self.__itunes_explicit = itunes_explicit\n        return self.__itunes_explicit\n\n    def itunes_complete(self, itunes_complete=None):\n        '''Get or set the itunes:complete value of the podcast. This tag can be\n        used to indicate the completion of a podcast.\n\n        If you populate this tag with \"yes\", you are indicating that no more\n        episodes will be added to the podcast. If the <itunes:complete> tag is\n        present and has any other value (e.g. \u201cno\u201d), it will have no effect on\n        the podcast.\n\n        :param itunes_complete: If the podcast is complete.\n        :returns: If the podcast is complete.\n        '''\n        if itunes_complete is not None:\n            if itunes_complete not in ('yes', 'no', '', True, False):\n                raise ValueError('Invalid value for complete tag')\n            if itunes_complete is True:\n                itunes_complete = 'yes'\n            if itunes_complete is False:\n                itunes_complete = 'no'\n            self.__itunes_complete = itunes_complete\n        return self.__itunes_complete\n\n    def itunes_new_feed_url(self, itunes_new_feed_url=None):\n        '''Get or set the new-feed-url property of the podcast. This tag allows\n        you to change the URL where the podcast feed is located\n\n        After adding the tag to your old feed, you should maintain the old feed\n        for 48 hours before retiring it. At that point, iTunes will have\n        updated the directory with the new feed URL.\n\n        :param itunes_new_feed_url: New feed URL.\n        :returns: New feed URL.\n        '''\n        if itunes_new_feed_url is not None:\n            self.__itunes_new_feed_url = itunes_new_feed_url\n        return self.__itunes_new_feed_url\n\n    def itunes_owner(self, name=None, email=None):\n        '''Get or set the itunes:owner of the podcast. This tag contains\n        information that will be used to contact the owner of the podcast for\n        communication specifically about the podcast. It will not be publicly\n        displayed.\n\n        :param itunes_owner: The owner of the feed.\n        :returns: Data of the owner of the feed.\n        '''\n        if name is not None:\n            if name and email:\n                self.__itunes_owner = {'name': name, 'email': email}\n            elif not name and not email:\n                self.__itunes_owner = None\n            else:\n                raise ValueError('Both name and email have to be set.')\n        return self.__itunes_owner\n\n    def itunes_subtitle(self, itunes_subtitle=None):\n        '''Get or set the itunes:subtitle value for the podcast. The contents of\n        this tag are shown in the Description column in iTunes. The subtitle\n        displays best if it is only a few words long.\n\n        :param itunes_subtitle: Subtitle of the podcast.\n        :returns: Subtitle of the podcast.\n        '''\n        if itunes_subtitle is not None:\n            self.__itunes_subtitle = itunes_subtitle\n        return self.__itunes_subtitle\n\n    def itunes_summary(self, itunes_summary=None):\n        '''Get or set the itunes:summary value for the podcast. The contents of\n        this tag are shown in a separate window that appears when the \"circled\n        i\" in the Description column is clicked. It also appears on the iTunes\n        page for your podcast. This field can be up to 4000 characters. If\n        `<itunes:summary>` is not included, the contents of the <description>\n        tag are used.\n\n        :param itunes_summary: Summary of the podcast.\n        :returns: Summary of the podcast.\n        '''\n        if itunes_summary is not None:\n            self.__itunes_summary = itunes_summary\n        return self.__itunes_summary\n\n    _itunes_categories = {\n            'Arts': [\n                'Design', 'Fashion & Beauty', 'Food', 'Literature',\n                'Performing Arts', 'Visual Arts'],\n            'Business': [\n                'Business News', 'Careers', 'Investing',\n                'Management & Marketing', 'Shopping'],\n            'Comedy': [],\n            'Education': [\n                'Education', 'Education Technology', 'Higher Education',\n                'K-12', 'Language Courses', 'Training'],\n            'Games & Hobbies': [\n                'Automotive', 'Aviation', 'Hobbies', 'Other Games',\n                'Video Games'],\n            'Government & Organizations': [\n                'Local', 'National', 'Non-Profit', 'Regional'],\n            'Health': [\n                'Alternative Health', 'Fitness & Nutrition', 'Self-Help',\n                'Sexuality'],\n            'Kids & Family': [],\n            'Music': [],\n            'News & Politics': [],\n            'Religion & Spirituality': [\n                'Buddhism', 'Christianity', 'Hinduism', 'Islam', 'Judaism',\n                'Other', 'Spirituality'],\n            'Science & Medicine': [\n                'Medicine', 'Natural Sciences', 'Social Sciences'],\n            'Society & Culture': [\n                'History', 'Personal Journals', 'Philosophy',\n                'Places & Travel'],\n            'Sports & Recreation': [\n                'Amateur', 'College & High School', 'Outdoor', 'Professional'],\n            'Technology': [\n                'Gadgets', 'Tech News', 'Podcasting', 'Software How-To'],\n            'TV & Film': []}\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.podcast_entry\n    ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Extends the feedgen to produce podcasts.\n\n    :copyright: 2013-2016, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom lxml import etree\n\nfrom feedgen.ext.base import BaseEntryExtension\n\n\nclass PodcastEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for podcasts.\n    '''\n\n    def __init__(self):\n        # ITunes tags\n        # http://www.apple.com/itunes/podcasts/specs.html#rss\n        self.__itunes_author = None\n        self.__itunes_block = None\n        self.__itunes_image = None\n        self.__itunes_duration = None\n        self.__itunes_explicit = None\n        self.__itunes_is_closed_captioned = None\n        self.__itunes_order = None\n        self.__itunes_subtitle = None\n        self.__itunes_summary = None\n\n    def extend_rss(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n        ITUNES_NS = 'http://www.itunes.com/dtds/podcast-1.0.dtd'\n\n        if self.__itunes_author:\n            author = etree.SubElement(entry, '{%s}author' % ITUNES_NS)\n            author.text = self.__itunes_author\n\n        if self.__itunes_block is not None:\n            block = etree.SubElement(entry, '{%s}block' % ITUNES_NS)\n            block.text = 'yes' if self.__itunes_block else 'no'\n\n        if self.__itunes_image:\n            image = etree.SubElement(entry, '{%s}image' % ITUNES_NS)\n            image.attrib['href'] = self.__itunes_image\n\n        if self.__itunes_duration:\n            duration = etree.SubElement(entry, '{%s}duration' % ITUNES_NS)\n            duration.text = self.__itunes_duration\n\n        if self.__itunes_explicit in ('yes', 'no', 'clean'):\n            explicit = etree.SubElement(entry, '{%s}explicit' % ITUNES_NS)\n            explicit.text = self.__itunes_explicit\n\n        if self.__itunes_is_closed_captioned is not None:\n            is_closed_captioned = etree.SubElement(\n                    entry, '{%s}isClosedCaptioned' % ITUNES_NS)\n            if self.__itunes_is_closed_captioned:\n                is_closed_captioned.text = 'yes'\n            else:\n                is_closed_captioned.text = 'no'\n\n        if self.__itunes_order is not None and self.__itunes_order >= 0:\n            order = etree.SubElement(entry, '{%s}order' % ITUNES_NS)\n            order.text = str(self.__itunes_order)\n\n        if self.__itunes_subtitle:\n            subtitle = etree.SubElement(entry, '{%s}subtitle' % ITUNES_NS)\n            subtitle.text = self.__itunes_subtitle\n\n        if self.__itunes_summary:\n            summary = etree.SubElement(entry, '{%s}summary' % ITUNES_NS)\n            summary.text = self.__itunes_summary\n        return entry\n\n    def itunes_author(self, itunes_author=None):\n        '''Get or set the itunes:author of the podcast episode. The content of\n        this tag is shown in the Artist column in iTunes. If the tag is not\n        present, iTunes uses the contents of the <author> tag. If\n        <itunes:author> is not present at the feed level, iTunes will use the\n        contents of <managingEditor>.\n\n        :param itunes_author: The author of the podcast.\n        :returns: The author of the podcast.\n        '''\n        if itunes_author is not None:\n            self.__itunes_author = itunes_author\n        return self.__itunes_author\n\n    def itunes_block(self, itunes_block=None):\n        '''Get or set the ITunes block attribute. Use this to prevent episodes\n        from appearing in the iTunes podcast directory.\n\n        :param itunes_block: Block podcast episodes.\n        :returns: If the podcast episode is blocked.\n        '''\n        if itunes_block is not None:\n            self.__itunes_block = itunes_block\n        return self.__itunes_block\n\n    def itunes_image(self, itunes_image=None):\n        '''Get or set the image for the podcast episode. This tag specifies the\n        artwork for your podcast. Put the URL to the image in the href\n        attribute.  iTunes prefers square .jpg images that are at least\n        1400x1400 pixels, which is different from what is specified for the\n        standard RSS image tag.  In order for a podcast to be eligible for an\n        iTunes Store feature, the accompanying image must be at least 1400x1400\n        pixels.\n\n        iTunes supports images in JPEG and PNG formats with an RGB color space\n        (CMYK is not supported). The URL must end in \".jpg\" or \".png\". If the\n        <itunes:image> tag is not present, iTunes will use the contents of the\n        RSS image tag.\n\n        If you change your podcast\u2019s image, also change the file\u2019s name. iTunes\n        may not change the image if it checks your feed and the image URL is\n        the same. The server hosting your cover art image must allow HTTP head\n        requests for iTS to be able to automatically update your cover art.\n\n        :param itunes_image: Image of the podcast.\n        :returns: Image of the podcast.\n        '''\n        if itunes_image is not None:\n            if itunes_image.endswith('.jpg') or itunes_image.endswith('.png'):\n                self.__itunes_image = itunes_image\n            else:\n                raise ValueError('Image file must be png or jpg')\n        return self.__itunes_image\n\n    def itunes_duration(self, itunes_duration=None):\n        '''Get or set the duration of the podcast episode. The content of this\n        tag is shown in the Time column in iTunes.\n\n        The tag can be formatted HH:MM:SS, H:MM:SS, MM:SS, or M:SS (H = hours,\n        M = minutes, S = seconds). If an integer is provided (no colon\n        present), the value is assumed to be in seconds. If one colon is\n        present, the number to the left is assumed to be minutes, and the\n        number to the right is assumed to be seconds. If more than two colons\n        are present, the numbers farthest to the right are ignored.\n\n        :param itunes_duration: Duration of the podcast episode.\n        :returns: Duration of the podcast episode.\n        '''\n        if itunes_duration is not None:\n            itunes_duration = str(itunes_duration)\n            if len(itunes_duration.split(':')) > 3 or \\\n                    itunes_duration.lstrip('0123456789:') != '':\n                raise ValueError('Invalid duration format')\n            self.__itunes_duration = itunes_duration\n        return self.__itunes_duration\n\n    def itunes_explicit(self, itunes_explicit=None):\n        '''Get or the the itunes:explicit value of the podcast episode. This\n        tag should be used to indicate whether your podcast episode contains\n        explicit material. The three values for this tag are \"yes\", \"no\", and\n        \"clean\".\n\n        If you populate this tag with \"yes\", an \"explicit\" parental advisory\n        graphic will appear next to your podcast artwork on the iTunes Store\n        and in the Name column in iTunes. If the value is \"clean\", the parental\n        advisory type is considered Clean, meaning that no explicit language or\n        adult content is included anywhere in the episodes, and a \"clean\"\n        graphic will appear. If the explicit tag is present and has any other\n        value (e.g., \"no\"), you see no indicator \u2014 blank is the default\n        advisory type.\n\n        :param itunes_explicit: If the podcast episode contains explicit\n                                material.\n        :returns: If the podcast episode contains explicit material.\n        '''\n        if itunes_explicit is not None:\n            if itunes_explicit not in ('', 'yes', 'no', 'clean'):\n                raise ValueError('Invalid value for explicit tag')\n            self.__itunes_explicit = itunes_explicit\n        return self.__itunes_explicit\n\n    def itunes_is_closed_captioned(self, itunes_is_closed_captioned=None):\n        '''Get or set the is_closed_captioned value of the podcast episode.\n        This tag should be used if your podcast includes a video episode with\n        embedded closed captioning support. The two values for this tag are\n        \"yes\" and \"no\u201d.\n\n        :param is_closed_captioned: If the episode has closed captioning\n                                    support.\n        :returns: If the episode has closed captioning support.\n        '''\n        if itunes_is_closed_captioned is not None:\n            self.__itunes_is_closed_captioned = \\\n                    itunes_is_closed_captioned in ('yes', True)\n        return self.__itunes_is_closed_captioned\n\n    def itunes_order(self, itunes_order=None):\n        '''Get or set the itunes:order value of the podcast episode. This tag\n        can be used to override the default ordering of episodes on the store.\n\n        This tag is used at an <item> level by populating with the number value\n        in which you would like the episode to appear on the store. For\n        example, if you would like an <item> to appear as the first episode in\n        the podcast, you would populate the <itunes:order> tag with \u201c1\u201d. If\n        conflicting order values are present in multiple episodes, the store\n        will use default ordering (pubDate).\n\n        To remove the order from the episode set the order to a value below\n        zero.\n\n        :param itunes_order: The order of the episode.\n        :returns: The order of the episode.\n        '''\n        if itunes_order is not None:\n            self.__itunes_order = int(itunes_order)\n        return self.__itunes_order\n\n    def itunes_subtitle(self, itunes_subtitle=None):\n        '''Get or set the itunes:subtitle value for the podcast episode. The\n        contents of this tag are shown in the Description column in iTunes. The\n        subtitle displays best if it is only a few words long.\n\n        :param itunes_subtitle: Subtitle of the podcast episode.\n        :returns: Subtitle of the podcast episode.\n        '''\n        if itunes_subtitle is not None:\n            self.__itunes_subtitle = itunes_subtitle\n        return self.__itunes_subtitle\n\n    def itunes_summary(self, itunes_summary=None):\n        '''Get or set the itunes:summary value for the podcast episode. The\n        contents of this tag are shown in a separate window that appears when\n        the \"circled i\" in the Description column is clicked. It also appears\n        on the iTunes page for your podcast. This field can be up to 4000\n        characters. If <itunes:summary> is not included, the contents of the\n        <description> tag are used.\n\n        :param itunes_summary: Summary of the podcast episode.\n        :returns: Summary of the podcast episode.\n        '''\n        if itunes_summary is not None:\n            self.__itunes_summary = itunes_summary\n        return self.__itunes_summary\n", "# -*- coding: utf-8 -*-\n#\n# Copyright 2015 Kenichi Sato <ksato9700@gmail.com>\n#\n\n'''\nExtends FeedGenerator to support Syndication module\n\nSee below for details\nhttp://web.resource.org/rss/1.0/modules/syndication/\n'''\n\nfrom lxml import etree\n\nfrom feedgen.ext.base import BaseExtension\n\nSYNDICATION_NS = 'http://purl.org/rss/1.0/modules/syndication/'\nPERIOD_TYPE = ('hourly', 'daily', 'weekly', 'monthly', 'yearly')\n\n\ndef _set_value(channel, name, value):\n    if value:\n        newelem = etree.SubElement(channel, '{%s}' % SYNDICATION_NS + name)\n        newelem.text = value\n\n\nclass SyndicationExtension(BaseExtension):\n    def __init__(self):\n        self._update_period = None\n        self._update_freq = None\n        self._update_base = None\n\n    def extend_ns(self):\n        return {'sy': SYNDICATION_NS}\n\n    def extend_rss(self, rss_feed):\n        channel = rss_feed[0]\n        _set_value(channel, 'UpdatePeriod', self._update_period)\n        _set_value(channel, 'UpdateFrequency', str(self._update_freq))\n        _set_value(channel, 'UpdateBase', self._update_base)\n\n    def update_period(self, value):\n        if value not in PERIOD_TYPE:\n            raise ValueError('Invalid update period value')\n        self._update_period = value\n        return self._update_period\n\n    def update_frequency(self, value):\n        if type(value) is not int or value <= 0:\n            raise ValueError('Invalid update frequency value')\n        self._update_freq = value\n        return self._update_freq\n\n    def update_base(self, value):\n        # the value should be in W3CDTF format\n        self._update_base = value\n        return self._update_base\n\n\nclass SyndicationEntryExtension(BaseExtension):\n    pass\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.torrent\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to produce torrent feeds.\n\n    :copyright: 2016, Raspbeguy <raspbeguy@hashtagueule.fr>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom lxml import etree\n\nfrom feedgen.ext.base import BaseEntryExtension, BaseExtension\n\nTORRENT_NS = 'http://xmlns.ezrss.it/0.1/dtd/'\n\n\nclass TorrentExtension(BaseExtension):\n    '''FeedGenerator extension for torrent feeds.\n    '''\n    def extend_ns(self):\n        return {'torrent': TORRENT_NS}\n\n\nclass TorrentEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for torrent feeds\n    '''\n    def __init__(self):\n        self.__torrent_filename = None\n        self.__torrent_infohash = None\n        self.__torrent_contentlength = None\n        self.__torrent_seeds = None\n        self.__torrent_peers = None\n        self.__torrent_verified = None\n\n    def extend_rss(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n        if self.__torrent_filename:\n            filename = etree.SubElement(entry, '{%s}filename' % TORRENT_NS)\n            filename.text = self.__torrent_filename\n\n        if self.__torrent_contentlength:\n            contentlength = etree.SubElement(entry,\n                                             '{%s}contentlength' % TORRENT_NS)\n            contentlength.text = self.__torrent_contentlength\n\n        if self.__torrent_infohash:\n            infohash = etree.SubElement(entry, '{%s}infohash' % TORRENT_NS)\n            infohash.text = self.__torrent_infohash\n            magnet = etree.SubElement(entry, '{%s}magneturi' % TORRENT_NS)\n            magnet.text = 'magnet:?xt=urn:btih:' + self.__torrent_infohash\n\n        if self.__torrent_seeds:\n            seeds = etree.SubElement(entry, '{%s}seed' % TORRENT_NS)\n            seeds.text = self.__torrent_seeds\n\n        if self.__torrent_peers:\n            peers = etree.SubElement(entry, '{%s}peers' % TORRENT_NS)\n            peers.text = self.__torrent_peers\n\n        if self.__torrent_verified:\n            verified = etree.SubElement(entry, '{%s}verified' % TORRENT_NS)\n            verified.text = self.__torrent_verified\n\n    def filename(self, torrent_filename=None):\n        '''Get or set the name of the torrent file.\n\n        :param torrent_filename: The name of the torrent file.\n        :returns: The name of the torrent file.\n        '''\n        if torrent_filename is not None:\n            self.__torrent_filename = torrent_filename\n        return self.__torrent_filename\n\n    def infohash(self, torrent_infohash=None):\n        '''Get or set the hash of the target file.\n\n        :param torrent_infohash: The target file hash.\n        :returns: The target hash file.\n        '''\n        if torrent_infohash is not None:\n            self.__torrent_infohash = torrent_infohash\n        return self.__torrent_infohash\n\n    def contentlength(self, torrent_contentlength=None):\n        '''Get or set the size of the target file.\n\n        :param torrent_contentlength: The target file size.\n        :returns: The target file size.\n        '''\n        if torrent_contentlength is not None:\n            self.__torrent_contentlength = torrent_contentlength\n        return self.__torrent_contentlength\n\n    def seeds(self, torrent_seeds=None):\n        '''Get or set the number of seeds.\n\n        :param torrent_seeds: The seeds number.\n        :returns: The seeds number.\n        '''\n        if torrent_seeds is not None:\n            self.__torrent_seeds = torrent_seeds\n        return self.__torrent_seeds\n\n    def peers(self, torrent_peers=None):\n        '''Get or set the number od peers\n\n        :param torrent_infohash: The peers number.\n        :returns: The peers number.\n        '''\n        if torrent_peers is not None:\n            self.__torrent_peers = torrent_peers\n        return self.__torrent_peers\n\n    def verified(self, torrent_verified=None):\n        '''Get or set the number of verified peers.\n\n        :param torrent_infohash: The verified peers number.\n        :returns: The verified peers number.\n        '''\n        if torrent_verified is not None:\n            self.__torrent_verified = torrent_verified\n        return self.__torrent_verified\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.feed\n    ~~~~~~~~~~~~\n\n    :copyright: 2013-2016, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n\n'''\n\nimport sys\nfrom datetime import datetime\n\nimport dateutil.parser\nimport dateutil.tz\nfrom lxml import etree\n\nimport feedgen.version\nfrom feedgen.compat import string_types\nfrom feedgen.entry import FeedEntry\nfrom feedgen.util import ensure_format, formatRFC2822\n\n_feedgen_version = feedgen.version.version_str\n\n\nclass FeedGenerator(object):\n    '''FeedGenerator for generating ATOM and RSS feeds.\n    '''\n\n    def __init__(self):\n        self.__feed_entries = []\n\n        # ATOM\n        # https://tools.ietf.org/html/rfc4287\n        # required\n        self.__atom_id = None\n        self.__atom_title = None\n        self.__atom_updated = datetime.now(dateutil.tz.tzutc())\n\n        # recommended\n        self.__atom_author = None  # {name*, uri, email}\n        self.__atom_link = None  # {href*, rel, type, hreflang, title, length}\n\n        # optional\n        self.__atom_category = None  # {term*, scheme, label}\n        self.__atom_contributor = None\n        self.__atom_generator = {\n                'value': 'python-feedgen',\n                'uri': 'http://lkiesow.github.io/python-feedgen',\n                'version': feedgen.version.version_str}  # {value*,uri,version}\n        self.__atom_icon = None\n        self.__atom_logo = None\n        self.__atom_rights = None\n        self.__atom_subtitle = None\n\n        # other\n        self.__atom_feed_xml_lang = None\n\n        # RSS\n        # http://www.rssboard.org/rss-specification\n        self.__rss_title = None\n        self.__rss_link = None\n        self.__rss_description = None\n\n        self.__rss_category = None\n        self.__rss_cloud = None\n        self.__rss_copyright = None\n        self.__rss_docs = 'http://www.rssboard.org/rss-specification'\n        self.__rss_generator = 'python-feedgen'\n        self.__rss_image = None\n        self.__rss_language = None\n        self.__rss_lastBuildDate = datetime.now(dateutil.tz.tzutc())\n        self.__rss_managingEditor = None\n        self.__rss_pubDate = None\n        self.__rss_rating = None\n        self.__rss_skipHours = None\n        self.__rss_skipDays = None\n        self.__rss_textInput = None\n        self.__rss_ttl = None\n        self.__rss_webMaster = None\n\n        # Extension list:\n        self.__extensions = {}\n\n    def _create_atom(self, extensions=True):\n        '''Create a ATOM feed xml structure containing all previously set\n        fields.\n\n        :returns: Tuple containing the feed root element and the element tree.\n        '''\n        nsmap = dict()\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('atom'):\n                    nsmap.update(ext['inst'].extend_ns())\n\n        feed = etree.Element('feed',\n                             xmlns='http://www.w3.org/2005/Atom',\n                             nsmap=nsmap)\n        if self.__atom_feed_xml_lang:\n            feed.attrib['{http://www.w3.org/XML/1998/namespace}lang'] = \\\n                    self.__atom_feed_xml_lang\n\n        if not (self.__atom_id and self.__atom_title and self.__atom_updated):\n            missing = ([] if self.__atom_title else ['title']) + \\\n                      ([] if self.__atom_id else ['id']) + \\\n                      ([] if self.__atom_updated else ['updated'])\n            missing = ', '.join(missing)\n            raise ValueError('Required fields not set (%s)' % missing)\n        id = etree.SubElement(feed, 'id')\n        id.text = self.__atom_id\n        title = etree.SubElement(feed, 'title')\n        title.text = self.__atom_title\n        updated = etree.SubElement(feed, 'updated')\n        updated.text = self.__atom_updated.isoformat()\n\n        # Add author elements\n        for a in self.__atom_author or []:\n            # Atom requires a name. Skip elements without.\n            if not a.get('name'):\n                continue\n            author = etree.SubElement(feed, 'author')\n            name = etree.SubElement(author, 'name')\n            name.text = a.get('name')\n            if a.get('email'):\n                email = etree.SubElement(author, 'email')\n                email.text = a.get('email')\n            if a.get('uri'):\n                uri = etree.SubElement(author, 'uri')\n                uri.text = a.get('uri')\n\n        for l in self.__atom_link or []:\n            link = etree.SubElement(feed, 'link', href=l['href'])\n            if l.get('rel'):\n                link.attrib['rel'] = l['rel']\n            if l.get('type'):\n                link.attrib['type'] = l['type']\n            if l.get('hreflang'):\n                link.attrib['hreflang'] = l['hreflang']\n            if l.get('title'):\n                link.attrib['title'] = l['title']\n            if l.get('length'):\n                link.attrib['length'] = l['length']\n\n        for c in self.__atom_category or []:\n            cat = etree.SubElement(feed, 'category', term=c['term'])\n            if c.get('scheme'):\n                cat.attrib['scheme'] = c['scheme']\n            if c.get('label'):\n                cat.attrib['label'] = c['label']\n\n        # Add author elements\n        for c in self.__atom_contributor or []:\n            # Atom requires a name. Skip elements without.\n            if not c.get('name'):\n                continue\n            contrib = etree.SubElement(feed, 'contributor')\n            name = etree.SubElement(contrib, 'name')\n            name.text = c.get('name')\n            if c.get('email'):\n                email = etree.SubElement(contrib, 'email')\n                email.text = c.get('email')\n            if c.get('uri'):\n                uri = etree.SubElement(contrib, 'uri')\n                uri.text = c.get('uri')\n\n        if self.__atom_generator and self.__atom_generator.get('value'):\n            generator = etree.SubElement(feed, 'generator')\n            generator.text = self.__atom_generator['value']\n            if self.__atom_generator.get('uri'):\n                generator.attrib['uri'] = self.__atom_generator['uri']\n            if self.__atom_generator.get('version'):\n                generator.attrib['version'] = self.__atom_generator['version']\n\n        if self.__atom_icon:\n            icon = etree.SubElement(feed, 'icon')\n            icon.text = self.__atom_icon\n\n        if self.__atom_logo:\n            logo = etree.SubElement(feed, 'logo')\n            logo.text = self.__atom_logo\n\n        if self.__atom_rights:\n            rights = etree.SubElement(feed, 'rights')\n            rights.text = self.__atom_rights\n\n        if self.__atom_subtitle:\n            subtitle = etree.SubElement(feed, 'subtitle')\n            subtitle.text = self.__atom_subtitle\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('atom'):\n                    ext['inst'].extend_atom(feed)\n\n        for entry in self.__feed_entries:\n            entry = entry.atom_entry()\n            feed.append(entry)\n\n        doc = etree.ElementTree(feed)\n        return feed, doc\n\n    def atom_str(self, pretty=False, extensions=True, encoding='UTF-8',\n                 xml_declaration=True):\n        '''Generates an ATOM feed and returns the feed XML as string.\n\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        :returns: String representation of the ATOM feed.\n\n        **Return type:** The return type may vary between different Python\n        versions and your encoding parameters passed to this method. For\n        details have a look at the `lxml documentation\n        <https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.tostring>`_\n        '''\n        feed, doc = self._create_atom(extensions=extensions)\n        return etree.tostring(feed, pretty_print=pretty, encoding=encoding,\n                              xml_declaration=xml_declaration)\n\n    def atom_file(self, filename, extensions=True, pretty=False,\n                  encoding='UTF-8', xml_declaration=True):\n        '''Generates an ATOM feed and write the resulting XML to a file.\n\n        :param filename: Name of file to write or a file-like object or a URL.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        '''\n        feed, doc = self._create_atom(extensions=extensions)\n        doc.write(filename, pretty_print=pretty, encoding=encoding,\n                  xml_declaration=xml_declaration)\n\n    def _create_rss(self, extensions=True):\n        '''Create an RSS feed xml structure containing all previously set\n        fields.\n\n        :returns: Tuple containing the feed root element and the element tree.\n        '''\n        nsmap = dict()\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('rss'):\n                    nsmap.update(ext['inst'].extend_ns())\n\n        nsmap.update({'atom':  'http://www.w3.org/2005/Atom',\n                      'content': 'http://purl.org/rss/1.0/modules/content/'})\n\n        feed = etree.Element('rss', version='2.0', nsmap=nsmap)\n        channel = etree.SubElement(feed, 'channel')\n        if not (self.__rss_title and\n                self.__rss_link and\n                self.__rss_description):\n            missing = ([] if self.__rss_title else ['title']) + \\\n                      ([] if self.__rss_link else ['link']) + \\\n                      ([] if self.__rss_description else ['description'])\n            missing = ', '.join(missing)\n            raise ValueError('Required fields not set (%s)' % missing)\n        title = etree.SubElement(channel, 'title')\n        title.text = self.__rss_title\n        link = etree.SubElement(channel, 'link')\n        link.text = self.__rss_link\n        desc = etree.SubElement(channel, 'description')\n        desc.text = self.__rss_description\n        for ln in self.__atom_link or []:\n            # It is recommended to include a atom self link in rss documents\u2026\n            if ln.get('rel') == 'self':\n                selflink = etree.SubElement(\n                        channel, '{http://www.w3.org/2005/Atom}link',\n                        href=ln['href'], rel='self')\n                if ln.get('type'):\n                    selflink.attrib['type'] = ln['type']\n                if ln.get('hreflang'):\n                    selflink.attrib['hreflang'] = ln['hreflang']\n                if ln.get('title'):\n                    selflink.attrib['title'] = ln['title']\n                if ln.get('length'):\n                    selflink.attrib['length'] = ln['length']\n                break\n        if self.__rss_category:\n            for cat in self.__rss_category:\n                category = etree.SubElement(channel, 'category')\n                category.text = cat['value']\n                if cat.get('domain'):\n                    category.attrib['domain'] = cat['domain']\n        if self.__rss_cloud:\n            cloud = etree.SubElement(channel, 'cloud')\n            cloud.attrib['domain'] = self.__rss_cloud.get('domain')\n            cloud.attrib['port'] = self.__rss_cloud.get('port')\n            cloud.attrib['path'] = self.__rss_cloud.get('path')\n            cloud.attrib['registerProcedure'] = self.__rss_cloud.get(\n                    'registerProcedure')\n            cloud.attrib['protocol'] = self.__rss_cloud.get('protocol')\n        if self.__rss_copyright:\n            copyright = etree.SubElement(channel, 'copyright')\n            copyright.text = self.__rss_copyright\n        if self.__rss_docs:\n            docs = etree.SubElement(channel, 'docs')\n            docs.text = self.__rss_docs\n        if self.__rss_generator:\n            generator = etree.SubElement(channel, 'generator')\n            generator.text = self.__rss_generator\n        if self.__rss_image:\n            image = etree.SubElement(channel, 'image')\n            url = etree.SubElement(image, 'url')\n            url.text = self.__rss_image.get('url')\n            title = etree.SubElement(image, 'title')\n            title.text = self.__rss_image.get('title', self.__rss_title)\n            link = etree.SubElement(image, 'link')\n            link.text = self.__rss_image.get('link', self.__rss_link)\n            if self.__rss_image.get('width'):\n                width = etree.SubElement(image, 'width')\n                width.text = self.__rss_image.get('width')\n            if self.__rss_image.get('height'):\n                height = etree.SubElement(image, 'height')\n                height.text = self.__rss_image.get('height')\n            if self.__rss_image.get('description'):\n                description = etree.SubElement(image, 'description')\n                description.text = self.__rss_image.get('description')\n        if self.__rss_language:\n            language = etree.SubElement(channel, 'language')\n            language.text = self.__rss_language\n        if self.__rss_lastBuildDate:\n            lastBuildDate = etree.SubElement(channel, 'lastBuildDate')\n\n            lastBuildDate.text = formatRFC2822(self.__rss_lastBuildDate)\n        if self.__rss_managingEditor:\n            managingEditor = etree.SubElement(channel, 'managingEditor')\n            managingEditor.text = self.__rss_managingEditor\n        if self.__rss_pubDate:\n            pubDate = etree.SubElement(channel, 'pubDate')\n            pubDate.text = formatRFC2822(self.__rss_pubDate)\n        if self.__rss_rating:\n            rating = etree.SubElement(channel, 'rating')\n            rating.text = self.__rss_rating\n        if self.__rss_skipHours:\n            skipHours = etree.SubElement(channel, 'skipHours')\n            for h in self.__rss_skipHours:\n                hour = etree.SubElement(skipHours, 'hour')\n                hour.text = str(h)\n        if self.__rss_skipDays:\n            skipDays = etree.SubElement(channel, 'skipDays')\n            for d in self.__rss_skipDays:\n                day = etree.SubElement(skipDays, 'day')\n                day.text = d\n        if self.__rss_textInput:\n            textInput = etree.SubElement(channel, 'textInput')\n            textInput.attrib['title'] = self.__rss_textInput.get('title')\n            textInput.attrib['description'] = \\\n                self.__rss_textInput.get('description')\n            textInput.attrib['name'] = self.__rss_textInput.get('name')\n            textInput.attrib['link'] = self.__rss_textInput.get('link')\n        if self.__rss_ttl:\n            ttl = etree.SubElement(channel, 'ttl')\n            ttl.text = str(self.__rss_ttl)\n        if self.__rss_webMaster:\n            webMaster = etree.SubElement(channel, 'webMaster')\n            webMaster.text = self.__rss_webMaster\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('rss'):\n                    ext['inst'].extend_rss(feed)\n\n        for entry in self.__feed_entries:\n            item = entry.rss_entry()\n            channel.append(item)\n\n        doc = etree.ElementTree(feed)\n        return feed, doc\n\n    def rss_str(self, pretty=False, extensions=True, encoding='UTF-8',\n                xml_declaration=True):\n        '''Generates an RSS feed and returns the feed XML as string.\n\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        :returns: String representation of the RSS feed.\n\n        **Return type:** The return type may vary between different Python\n        versions and your encoding parameters passed to this method. For\n        details have a look at the `lxml documentation\n        <https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.tostring>`_\n        '''\n        feed, doc = self._create_rss(extensions=extensions)\n        return etree.tostring(feed, pretty_print=pretty, encoding=encoding,\n                              xml_declaration=xml_declaration)\n\n    def rss_file(self, filename, extensions=True, pretty=False,\n                 encoding='UTF-8', xml_declaration=True):\n        '''Generates an RSS feed and write the resulting XML to a file.\n\n        :param filename: Name of file to write or a file-like object or a URL.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        '''\n        feed, doc = self._create_rss(extensions=extensions)\n        doc.write(filename, pretty_print=pretty, encoding=encoding,\n                  xml_declaration=xml_declaration)\n\n    def title(self, title=None):\n        '''Get or set the title value of the feed. It should contain a human\n        readable title for the feed. Often the same as the title of the\n        associated website. Title is mandatory for both ATOM and RSS and should\n        not be blank.\n\n        :param title: The new title of the feed.\n        :returns: The feeds title.\n        '''\n        if title is not None:\n            self.__atom_title = title\n            self.__rss_title = title\n        return self.__atom_title\n\n    def id(self, id=None):\n        '''Get or set the feed id which identifies the feed using a universally\n        unique and permanent URI. If you have a long-term, renewable lease on\n        your Internet domain name, then you can feel free to use your website's\n        address. This field is for ATOM only. It is mandatory for ATOM.\n\n        :param id: New Id of the ATOM feed.\n        :returns: Id of the feed.\n        '''\n\n        if id is not None:\n            self.__atom_id = id\n        return self.__atom_id\n\n    def updated(self, updated=None):\n        '''Set or get the updated value which indicates the last time the feed\n        was modified in a significant way.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        This will set both atom:updated and rss:lastBuildDate.\n\n        Default value\n            If not set, updated has as value the current date and time.\n\n        :param updated: The modification date.\n        :returns: Modification date as datetime.datetime\n        '''\n        if updated is not None:\n            if isinstance(updated, string_types):\n                updated = dateutil.parser.parse(updated)\n            if not isinstance(updated, datetime):\n                raise ValueError('Invalid datetime format')\n            if updated.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__atom_updated = updated\n            self.__rss_lastBuildDate = updated\n\n        return self.__atom_updated\n\n    def lastBuildDate(self, lastBuildDate=None):\n        '''Set or get the lastBuildDate value which indicates the last time the\n        content of the channel changed.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        This will set both atom:updated and rss:lastBuildDate.\n\n        Default value\n            If not set, lastBuildDate has as value the current date and time.\n\n        :param lastBuildDate: The modification date.\n        :returns: Modification date as datetime.datetime\n        '''\n        return self.updated(lastBuildDate)\n\n    def author(self, author=None, replace=False, **kwargs):\n        '''Get or set author data. An author element is a dictionary containing\n        a name, an email address and a URI. Name is mandatory for ATOM, email\n        is mandatory for RSS.\n\n        This method can be called with:\n\n        - the fields of an author as keyword arguments\n        - the fields of an author as a dictionary\n        - a list of dictionaries containing the author fields\n\n        An author has the following fields:\n\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param author:  Dictionary or list of dictionaries with author data.\n        :param replace: Add or replace old data.\n        :returns: List of authors as dictionaries.\n\n        Example::\n\n            >>> feedgen.author({'name':'John Doe', 'email':'jdoe@example.com'})\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n            >>> feedgen.author([{'name':'Mr. X'},{'name':'Max'}])\n            [{'name':'John Doe','email':'jdoe@example.com'},\n                    {'name':'John Doe'}, {'name':'Max'}]\n\n            >>> feedgen.author(name='John Doe', email='jdoe@example.com',\n                               replace=True)\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n        '''\n        if author is None and kwargs:\n            author = kwargs\n        if author is not None:\n            if replace or self.__atom_author is None:\n                self.__atom_author = []\n            self.__atom_author += ensure_format(author,\n                                                set(['name', 'email', 'uri']),\n                                                set(['name']))\n            self.__rss_author = []\n            for a in self.__atom_author:\n                if a.get('email'):\n                    self.__rss_author.append(a['email'])\n        return self.__atom_author\n\n    def link(self, link=None, replace=False, **kwargs):\n        '''Get or set link data. An link element is a dict with the fields\n        href, rel, type, hreflang, title, and length. Href is mandatory for\n        ATOM.\n\n        This method can be called with:\n\n        - the fields of a link as keyword arguments\n        - the fields of a link as a dictionary\n        - a list of dictionaries containing the link fields\n\n        A link has the following fields:\n\n        - *href* is the URI of the referenced resource (typically a Web page)\n        - *rel* contains a single link relationship type. It can be a full URI,\n          or one of the following predefined values (default=alternate):\n\n            - *alternate* an alternate representation of the entry or feed, for\n              example a permalink to the html version of the entry, or the\n              front page of the weblog.\n            - *enclosure* a related resource which is potentially large in size\n              and might require special handling, for example an audio or video\n              recording.\n            - *related* an document related to the entry or feed.\n            - *self* the feed itself.\n            - *via* the source of the information provided in the entry.\n\n        - *type* indicates the media type of the resource.\n        - *hreflang* indicates the language of the referenced resource.\n        - *title* human readable information about the link, typically for\n          display purposes.\n        - *length* the length of the resource, in bytes.\n\n        RSS only supports one link with URL only.\n\n        :param link:    Dict or list of dicts with data.\n        :param replace: If old links are to be replaced (default: False)\n        :returns:       Current set of link data\n\n        Example::\n\n            >>> feedgen.link( href='http://example.com/', rel='self')\n            [{'href':'http://example.com/', 'rel':'self'}]\n\n        '''\n        if link is None and kwargs:\n            link = kwargs\n        if link is not None:\n            if replace or self.__atom_link is None:\n                self.__atom_link = []\n            self.__atom_link += ensure_format(\n                link,\n                set(['href', 'rel', 'type', 'hreflang', 'title', 'length']),\n                set(['href']),\n                {'rel': [\n                    'about', 'alternate', 'appendix', 'archives', 'author',\n                    'bookmark', 'canonical', 'chapter', 'collection',\n                    'contents', 'copyright', 'create-form', 'current',\n                    'derivedfrom', 'describedby', 'describes', 'disclosure',\n                    'duplicate', 'edit', 'edit-form', 'edit-media',\n                    'enclosure', 'first', 'glossary', 'help', 'hosts', 'hub',\n                    'icon', 'index', 'item', 'last', 'latest-version',\n                    'license', 'lrdd', 'memento', 'monitor', 'monitor-group',\n                    'next', 'next-archive', 'nofollow', 'noreferrer',\n                    'original', 'payment', 'predecessor-version', 'prefetch',\n                    'prev', 'preview', 'previous', 'prev-archive',\n                    'privacy-policy', 'profile', 'related', 'replies',\n                    'search', 'section', 'self', 'service', 'start',\n                    'stylesheet', 'subsection', 'successor-version', 'tag',\n                    'terms-of-service', 'timegate', 'timemap', 'type', 'up',\n                    'version-history', 'via', 'working-copy', 'working-copy-of'\n                    ]})\n            # RSS only needs one URL. We use the first link for RSS:\n            if len(self.__atom_link) > 0:\n                self.__rss_link = self.__atom_link[-1]['href']\n        # return the set with more information (atom)\n        return self.__atom_link\n\n    def category(self, category=None, replace=False, **kwargs):\n        '''Get or set categories that the feed belongs to.\n\n        This method can be called with:\n\n        - the fields of a category as keyword arguments\n        - the fields of a category as a dictionary\n        - a list of dictionaries containing the category fields\n\n        A categories has the following fields:\n\n        - *term* identifies the category\n        - *scheme* identifies the categorization scheme via a URI.\n        - *label* provides a human-readable label for display\n\n        If a label is present it is used for the RSS feeds. Otherwise the term\n        is used. The scheme is used for the domain attribute in RSS.\n\n        :param link:    Dict or list of dicts with data.\n        :param replace: Add or replace old data.\n        :returns: List of category data.\n        '''\n        if category is None and kwargs:\n            category = kwargs\n        if category is not None:\n            if replace or self.__atom_category is None:\n                self.__atom_category = []\n            self.__atom_category += ensure_format(\n                    category,\n                    set(['term', 'scheme', 'label']),\n                    set(['term']))\n            # Map the ATOM categories to RSS categories. Use the atom:label as\n            # name or if not present the atom:term. The atom:scheme is the\n            # rss:domain.\n            self.__rss_category = []\n            for cat in self.__atom_category:\n                rss_cat = {}\n                rss_cat['value'] = cat.get('label', cat['term'])\n                if cat.get('scheme'):\n                    rss_cat['domain'] = cat['scheme']\n                self.__rss_category.append(rss_cat)\n        return self.__atom_category\n\n    def cloud(self, domain=None, port=None, path=None, registerProcedure=None,\n              protocol=None):\n        '''Set or get the cloud data of the feed. It is an RSS only attribute.\n        It specifies a web service that supports the rssCloud interface which\n        can be implemented in HTTP-POST, XML-RPC or SOAP 1.1.\n\n        :param domain: The domain where the webservice can be found.\n        :param port: The port the webservice listens to.\n        :param path: The path of the webservice.\n        :param registerProcedure: The procedure to call.\n        :param protocol: Can be either HTTP-POST, XML-RPC or SOAP 1.1.\n        :returns: Dictionary containing the cloud data.\n        '''\n        if domain is not None:\n            self.__rss_cloud = {'domain': domain, 'port': port, 'path': path,\n                                'registerProcedure': registerProcedure,\n                                'protocol': protocol}\n        return self.__rss_cloud\n\n    def contributor(self, contributor=None, replace=False, **kwargs):\n        '''Get or set the contributor data of the feed. This is an ATOM only\n        value.\n\n        This method can be called with:\n        - the fields of an contributor as keyword arguments\n        - the fields of an contributor as a dictionary\n        - a list of dictionaries containing the contributor fields\n\n        An contributor has the following fields:\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param contributor: Dictionary or list of dictionaries with contributor\n                            data.\n        :param replace: Add or replace old data.\n        :returns: List of contributors as dictionaries.\n        '''\n        if contributor is None and kwargs:\n            contributor = kwargs\n        if contributor is not None:\n            if replace or self.__atom_contributor is None:\n                self.__atom_contributor = []\n            self.__atom_contributor += ensure_format(\n                    contributor, set(['name', 'email', 'uri']), set(['name']))\n        return self.__atom_contributor\n\n    def generator(self, generator=None, version=None, uri=None):\n        '''Get or set the generator of the feed which identifies the software\n        used to generate the feed, for debugging and other purposes. Both the\n        uri and version attributes are optional and only available in the ATOM\n        feed.\n\n        :param generator: Software used to create the feed.\n        :param version: Version of the software.\n        :param uri: URI the software can be found.\n        '''\n        if generator is not None:\n            self.__atom_generator = {'value': generator}\n            if version is not None:\n                self.__atom_generator['version'] = version\n            if uri is not None:\n                self.__atom_generator['uri'] = uri\n            self.__rss_generator = generator\n        return self.__atom_generator\n\n    def icon(self, icon=None):\n        '''Get or set the icon of the feed which is a small image which\n        provides iconic visual identification for the feed. Icons should be\n        square. This is an ATOM only value.\n\n        :param icon: URI of the feeds icon.\n        :returns: URI of the feeds icon.\n        '''\n        if icon is not None:\n            self.__atom_icon = icon\n        return self.__atom_icon\n\n    def logo(self, logo=None):\n        '''Get or set the logo of the feed which is a larger image which\n        provides visual identification for the feed. Images should be twice as\n        wide as they are tall. This is an ATOM value but will also set the\n        rss:image value.\n\n        :param logo: Logo of the feed.\n        :returns: Logo of the feed.\n        '''\n        if logo is not None:\n            self.__atom_logo = logo\n            self.__rss_image = {'url': logo}\n        return self.__atom_logo\n\n    def image(self, url=None, title=None, link=None, width=None, height=None,\n              description=None):\n        '''Set the image of the feed. This element is roughly equivalent to\n        atom:logo.\n\n        :param url: The URL of a GIF, JPEG or PNG image.\n        :param title: Describes the image. The default value is the feeds\n                      title.\n        :param link: URL of the site the image will link to. The default is to\n                     use the feeds first altertate link.\n        :param width: Width of the image in pixel. The maximum is 144.\n        :param height: The height of the image. The maximum is 400.\n        :param description: Title of the link.\n        :returns: Data of the image as dictionary.\n        '''\n        if url is not None:\n            self.__rss_image = {'url': url}\n            if title is not None:\n                self.__rss_image['title'] = title\n            if link is not None:\n                self.__rss_image['link'] = link\n            if width:\n                self.__rss_image['width'] = width\n            if height:\n                self.__rss_image['height'] = height\n            self.__atom_logo = url\n        return self.__rss_image\n\n    def rights(self, rights=None):\n        '''Get or set the rights value of the feed which conveys information\n        about rights, e.g. copyrights, held in and over the feed. This ATOM\n        value will also set rss:copyright.\n\n        :param rights: Rights information of the feed.\n        '''\n        if rights is not None:\n            self.__atom_rights = rights\n            self.__rss_copyright = rights\n        return self.__atom_rights\n\n    def copyright(self, copyright=None):\n        '''Get or set the copyright notice for content in the channel. This RSS\n        value will also set the atom:rights value.\n\n        :param copyright: The copyright notice.\n        :returns: The copyright notice.\n        '''\n        return self.rights(copyright)\n\n    def subtitle(self, subtitle=None):\n        '''Get or set the subtitle value of the cannel which contains a\n        human-readable description or subtitle for the feed. This ATOM property\n        will also set the value for rss:description.\n\n        :param subtitle: The subtitle of the feed.\n        :returns: The subtitle of the feed.\n        '''\n        if subtitle is not None:\n            self.__atom_subtitle = subtitle\n            self.__rss_description = subtitle\n        return self.__atom_subtitle\n\n    def description(self, description=None):\n        '''Set and get the description of the feed. This is an RSS only element\n        which is a phrase or sentence describing the channel. It is mandatory\n        for RSS feeds. It is roughly the same as atom:subtitle. Thus setting\n        this will also set atom:subtitle.\n\n        :param description: Description of the channel.\n        :returns: Description of the channel.\n\n        '''\n        return self.subtitle(description)\n\n    def docs(self, docs=None):\n        '''Get or set the docs value of the feed. This is an RSS only value. It\n        is a URL that points to the documentation for the format used in the\n        RSS file. It is probably a pointer to [1]. It is for people who might\n        stumble across an RSS file on a Web server 25 years from now and wonder\n        what it is.\n\n        [1]: http://www.rssboard.org/rss-specification\n\n        :param docs: URL of the format documentation.\n        :returns: URL of the format documentation.\n        '''\n        if docs is not None:\n            self.__rss_docs = docs\n        return self.__rss_docs\n\n    def language(self, language=None):\n        '''Get or set the language of the feed. It indicates the language the\n        channel is written in. This allows aggregators to group all Italian\n        language sites, for example, on a single page. This is an RSS only\n        field.  However, this value will also be used to set the xml:lang\n        property of the ATOM feed node.\n        The value should be an IETF language tag.\n\n        :param language: Language of the feed.\n        :returns: Language of the feed.\n        '''\n        if language is not None:\n            self.__rss_language = language\n            self.__atom_feed_xml_lang = language\n        return self.__rss_language\n\n    def managingEditor(self, managingEditor=None):\n        '''Set or get the value for managingEditor which is the email address\n        for person responsible for editorial content.    This is a RSS only\n        value.\n\n        :param managingEditor: Email address of the managing editor.\n        :returns: Email address of the managing editor.\n        '''\n        if managingEditor is not None:\n            self.__rss_managingEditor = managingEditor\n        return self.__rss_managingEditor\n\n    def pubDate(self, pubDate=None):\n        '''Set or get the publication date for the content in the channel. For\n        example, the New York Times publishes on a daily basis, the publication\n        date flips once every 24 hours. That's when the pubDate of the channel\n        changes.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        This will set both atom:updated and rss:lastBuildDate.\n\n        :param pubDate: The publication date.\n        :returns: Publication date as datetime.datetime\n        '''\n        if pubDate is not None:\n            if isinstance(pubDate, string_types):\n                pubDate = dateutil.parser.parse(pubDate)\n            if not isinstance(pubDate, datetime):\n                raise ValueError('Invalid datetime format')\n            if pubDate.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__rss_pubDate = pubDate\n\n        return self.__rss_pubDate\n\n    def rating(self, rating=None):\n        '''Set and get the PICS rating for the channel.    It is an RSS only\n        value.\n        '''\n        if rating is not None:\n            self.__rss_rating = rating\n        return self.__rss_rating\n\n    def skipHours(self, hours=None, replace=False):\n        '''Set or get the value of skipHours, a hint for aggregators telling\n        them which hours they can skip. This is an RSS only value.\n\n        This method can be called with an hour or a list of hours. The hours\n        are represented as integer values from 0 to 23.\n\n        :param hours: List of hours the feedreaders should not check the feed.\n        :param replace: Add or replace old data.\n        :returns: List of hours the feedreaders should not check the feed.\n        '''\n        if hours is not None:\n            if not (isinstance(hours, list) or isinstance(hours, set)):\n                hours = [hours]\n            for h in hours:\n                if h not in range(24):\n                    raise ValueError('Invalid hour %s' % h)\n            if replace or not self.__rss_skipHours:\n                self.__rss_skipHours = set()\n            self.__rss_skipHours |= set(hours)\n        return self.__rss_skipHours\n\n    def skipDays(self, days=None, replace=False):\n        '''Set or get the value of skipDays, a hint for aggregators telling\n        them which days they can skip This is an RSS only value.\n\n        This method can be called with a day name or a list of day names. The\n        days are represented as strings from 'Monday' to 'Sunday'.\n\n        :param hours:   List of days the feedreaders should not check the feed.\n        :param replace: Add or replace old data.\n        :returns:       List of days the feedreaders should not check the feed.\n        '''\n        if days is not None:\n            if not (isinstance(days, list) or isinstance(days, set)):\n                days = [days]\n            for d in days:\n                if d not in ['Monday', 'Tuesday', 'Wednesday', 'Thursday',\n                             'Friday', 'Saturday', 'Sunday']:\n                    raise ValueError('Invalid day %s' % d)\n            if replace or not self.__rss_skipDays:\n                self.__rss_skipDays = set()\n            self.__rss_skipDays |= set(days)\n        return self.__rss_skipDays\n\n    def textInput(self, title=None, description=None, name=None, link=None):\n        '''Get or set the value of textInput. This is an RSS only field.  The\n        purpose of the <textInput> element is something of a mystery. You can\n        use it to specify a search engine box. Or to allow a reader to provide\n        feedback. Most aggregators ignore it.\n\n        :param title: The label of the Submit button in the text input area.\n        :param description: Explains the text input area.\n        :param name: The name of the text object in the text input area.\n        :param link: The URL of the CGI script that processes text input\n                     requests.\n        :returns: Dictionary containing textInput values.\n        '''\n        if title is not None:\n            self.__rss_textInput = {}\n            self.__rss_textInput['title'] = title\n            self.__rss_textInput['description'] = description\n            self.__rss_textInput['name'] = name\n            self.__rss_textInput['link'] = link\n        return self.__rss_textInput\n\n    def ttl(self, ttl=None):\n        '''Get or set the ttl value. It is an RSS only element. ttl stands for\n        time to live. It's a number of minutes that indicates how long a\n        channel can be cached before refreshing from the source.\n\n        :param ttl: Integer value indicating how long the channel may be\n                    cached.\n        :returns: Time to live.\n        '''\n        if ttl is not None:\n            self.__rss_ttl = int(ttl)\n        return self.__rss_ttl\n\n    def webMaster(self, webMaster=None):\n        '''Get and set the value of webMaster, which represents the email\n        address for the person responsible for technical issues relating to the\n        feed.  This is an RSS only value.\n\n        :param webMaster: Email address of the webmaster.\n        :returns: Email address of the webmaster.\n        '''\n        if webMaster is not None:\n            self.__rss_webMaster = webMaster\n        return self.__rss_webMaster\n\n    def add_entry(self, feedEntry=None, order='prepend'):\n        '''This method will add a new entry to the feed. If the feedEntry\n        argument is omittet a new Entry object is created automatically. This\n        is the preferred way to add new entries to a feed.\n\n        :param feedEntry: FeedEntry object to add.\n        :param order: If `prepend` is chosen, the entry will be inserted\n                      at the beginning of the feed. If `append` is chosen,\n                      the entry will be appended to the feed.\n                      (default: `prepend`).\n        :returns: FeedEntry object created or passed to this function.\n\n        Example::\n\n            ...\n            >>> entry = feedgen.add_entry()\n            >>> entry.title('First feed entry')\n\n        '''\n        if feedEntry is None:\n            feedEntry = FeedEntry()\n\n        version = sys.version_info[0]\n\n        if version == 2:\n            items = self.__extensions.iteritems()\n        else:\n            items = self.__extensions.items()\n\n        # Try to load extensions:\n        for extname, ext in items:\n            try:\n                feedEntry.register_extension(extname,\n                                             ext['extension_class_entry'],\n                                             ext['atom'],\n                                             ext['rss'])\n            except ImportError:\n                pass\n\n        if order == 'prepend':\n            self.__feed_entries.insert(0, feedEntry)\n        else:\n            self.__feed_entries.append(feedEntry)\n        return feedEntry\n\n    def add_item(self, item=None):\n        '''This method will add a new item to the feed. If the item argument is\n        omittet a new FeedEntry object is created automatically. This is just\n        another name for add_entry(...)\n        '''\n        return self.add_entry(item)\n\n    def entry(self, entry=None, replace=False):\n        '''Get or set feed entries. Use the add_entry() method instead to\n        automatically create the FeedEntry objects.\n\n        This method takes both a single FeedEntry object or a list of objects.\n\n        :param entry: FeedEntry object or list of FeedEntry objects.\n        :returns: List ob all feed entries.\n        '''\n        if entry is not None:\n            if not isinstance(entry, list):\n                entry = [entry]\n            if replace:\n                self.__feed_entries = []\n\n            version = sys.version_info[0]\n\n            if version == 2:\n                items = self.__extensions.iteritems()\n            else:\n                items = self.__extensions.items()\n\n            # Try to load extensions:\n            for e in entry:\n                for extname, ext in items:\n                    try:\n                        e.register_extension(extname,\n                                             ext['extension_class_entry'],\n                                             ext['atom'], ext['rss'])\n                    except ImportError:\n                        pass\n\n            self.__feed_entries += entry\n        return self.__feed_entries\n\n    def item(self, item=None, replace=False):\n        '''Get or set feed items. This is just another name for entry(...)\n        '''\n        return self.entry(item, replace)\n\n    def remove_entry(self, entry):\n        '''Remove a single entry from the feed. This method accepts both the\n        FeedEntry object to remove or the index of the entry as argument.\n\n        :param entry: Entry or index of entry to remove.\n        '''\n        if isinstance(entry, FeedEntry):\n            self.__feed_entries.remove(entry)\n        else:\n            self.__feed_entries.pop(entry)\n\n    def remove_item(self, item):\n        '''Remove a single item from the feed. This is another name for\n        remove_entry.\n        '''\n        self.remove_entry(item)\n\n    def load_extension(self, name, atom=True, rss=True):\n        '''Load a specific extension by name.\n\n        :param name: Name of the extension to load.\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if name in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n\n        # Load extension\n        extname = name[0].upper() + name[1:]\n        feedsupmod = __import__('feedgen.ext.%s' % name)\n        feedextmod = getattr(feedsupmod.ext, name)\n        try:\n            entrysupmod = __import__('feedgen.ext.%s_entry' % name)\n            entryextmod = getattr(entrysupmod.ext, name + '_entry')\n        except ImportError:\n            # Use FeedExtension module instead\n            entrysupmod = feedsupmod\n            entryextmod = feedextmod\n        feedext = getattr(feedextmod, extname + 'Extension')\n        try:\n            entryext = getattr(entryextmod, extname + 'EntryExtension')\n        except AttributeError:\n            entryext = None\n        self.register_extension(name, feedext, entryext, atom, rss)\n\n    def register_extension(self, namespace, extension_class_feed=None,\n                           extension_class_entry=None, atom=True, rss=True):\n        '''Registers an extension by class.\n\n        :param namespace: namespace for the extension\n        :param extension_class_feed: Class of the feed extension to load.\n        :param extension_class_entry: Class of the entry extension to load\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        # `load_extension` ignores the \"Extension\" suffix.\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if namespace in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n\n        # Load extension\n        extinst = extension_class_feed()\n        setattr(self, namespace, extinst)\n\n        # `load_extension` registry\n        self.__extensions[namespace] = {\n                'inst': extinst,\n                'extension_class_feed': extension_class_feed,\n                'extension_class_entry': extension_class_entry,\n                'atom': atom,\n                'rss': rss\n                }\n\n        # Try to load the extension for already existing entries:\n        for entry in self.__feed_entries:\n            try:\n                entry.register_extension(namespace,\n                                         extension_class_entry,\n                                         atom,\n                                         rss)\n            except ImportError:\n                pass\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.util\n    ~~~~~~~~~~~~\n\n    This file contains helper functions for the feed generator module.\n\n    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\nimport locale\nimport sys\n\n\ndef ensure_format(val, allowed, required, allowed_values=None, defaults=None):\n    '''Takes a dictionary or a list of dictionaries and check if all keys are in\n    the set of allowed keys, if all required keys are present and if the values\n    of a specific key are ok.\n\n    :param val:            Dictionaries to check.\n    :param allowed:        Set of allowed keys.\n    :param required:       Set of required keys.\n    :param allowed_values: Dictionary with keys and sets of their allowed\n                           values.\n    :param defaults:       Dictionary with default values.\n    :returns:              List of checked dictionaries.\n    '''\n    if not val:\n        return []\n    if allowed_values is None:\n        allowed_values = {}\n    if defaults is None:\n        defaults = {}\n    # Make shure that we have a list of dicts. Even if there is only one.\n    if not isinstance(val, list):\n        val = [val]\n    for elem in val:\n        if not isinstance(elem, dict):\n            raise ValueError('Invalid data (value is no dictionary)')\n        # Set default values\n\n        version = sys.version_info[0]\n\n        if version == 2:\n            items = defaults.iteritems()\n        else:\n            items = defaults.items()\n\n        for k, v in items:\n            elem[k] = elem.get(k, v)\n        if not set(elem.keys()) <= allowed:\n            raise ValueError('Data contains invalid keys')\n        if not set(elem.keys()) >= required:\n            raise ValueError('Data contains not all required keys')\n\n        if version == 2:\n            values = allowed_values.iteritems()\n        else:\n            values = allowed_values.items()\n\n        for k, v in values:\n            if elem.get(k) and not elem[k] in v:\n                raise ValueError('Invalid value for %s' % k)\n    return val\n\n\ndef formatRFC2822(date):\n    '''Make sure the locale setting do not interfere with the time format.\n    '''\n    old = locale.setlocale(locale.LC_ALL)\n    locale.setlocale(locale.LC_ALL, 'C')\n    date = date.strftime('%a, %d %b %Y %H:%M:%S %z')\n    locale.setlocale(locale.LC_ALL, old)\n    return date\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n'''\n    feedgen.entry\n    ~~~~~~~~~~~~~\n\n    :copyright: 2013-2020, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom datetime import datetime\n\nimport dateutil.parser\nimport dateutil.tz\nimport warnings\n\nfrom lxml.etree import CDATA  # nosec - adding CDATA entry is safe\n\nfrom feedgen.compat import string_types\nfrom feedgen.util import ensure_format, formatRFC2822, xml_fromstring, xml_elem\n\n\ndef _add_text_elm(entry, data, name):\n    \"\"\"Add a text subelement to an entry\"\"\"\n    if not data:\n        return\n\n    elm = xml_elem(name, entry)\n    type_ = data.get('type')\n    if data.get('src'):\n        if name != 'content':\n            raise ValueError(\"Only the 'content' element of an entry can \"\n                             \"contain a 'src' attribute\")\n        elm.attrib['src'] = data['src']\n    elif data.get(name):\n        # Surround xhtml with a div tag, parse it and embed it\n        if type_ == 'xhtml':\n            xhtml = '<div xmlns=\"http://www.w3.org/1999/xhtml\">' \\\n                    + data.get(name) + '</div>'\n            elm.append(xml_fromstring(xhtml))\n        elif type_ == 'CDATA':\n            elm.text = CDATA(data.get(name))\n        # Parse XML and embed it\n        elif type_ and (type_.endswith('/xml') or type_.endswith('+xml')):\n            elm.append(xml_fromstring(data[name]))\n        # Embed the text in escaped form\n        elif not type_ or type_.startswith('text') or type_ == 'html':\n            elm.text = data.get(name)\n        # Everything else should be included base64 encoded\n        else:\n            raise NotImplementedError(\n                'base64 encoded {} is not supported at the moment. '\n                'Pull requests adding support are welcome.'.format(name)\n            )\n    # Add type description of the content\n    if type_:\n        elm.attrib['type'] = type_\n\n\nclass FeedEntry(object):\n    '''FeedEntry call representing an ATOM feeds entry node or an RSS feeds item\n    node.\n    '''\n\n    def __init__(self):\n        # ATOM\n        # required\n        self.__atom_id = None\n        self.__atom_title = None\n        self.__atom_updated = datetime.now(dateutil.tz.tzutc())\n\n        # recommended\n        self.__atom_author = None\n        self.__atom_content = None\n        self.__atom_link = None\n        self.__atom_summary = None\n\n        # optional\n        self.__atom_category = None\n        self.__atom_contributor = None\n        self.__atom_published = None\n        self.__atom_source = None\n        self.__atom_rights = None\n\n        # RSS\n        self.__rss_author = None\n        self.__rss_category = None\n        self.__rss_comments = None\n        self.__rss_description = None\n        self.__rss_content = None\n        self.__rss_enclosure = None\n        self.__rss_guid = {}\n        self.__rss_link = None\n        self.__rss_pubDate = None\n        self.__rss_source = None\n        self.__rss_title = None\n\n        # Extension list:\n        self.__extensions = {}\n        self.__extensions_register = {}\n\n    def atom_entry(self, extensions=True):\n        '''Create an ATOM entry and return it.'''\n        entry = xml_elem('entry')\n        if not (self.__atom_id and self.__atom_title and self.__atom_updated):\n            raise ValueError('Required fields not set')\n        id = xml_elem('id', entry)\n        id.text = self.__atom_id\n        title = xml_elem('title', entry)\n        title.text = self.__atom_title\n        updated = xml_elem('updated', entry)\n        updated.text = self.__atom_updated.isoformat()\n\n        # An entry must contain an alternate link if there is no content\n        # element.\n        if not self.__atom_content:\n            links = self.__atom_link or []\n            if not [l for l in links if l.get('rel') == 'alternate']:\n                raise ValueError('Entry must contain an alternate link or ' +\n                                 'a content element.')\n\n        # Add author elements\n        for a in self.__atom_author or []:\n            # Atom requires a name. Skip elements without.\n            if not a.get('name'):\n                continue\n            author = xml_elem('author', entry)\n            name = xml_elem('name', author)\n            name.text = a.get('name')\n            if a.get('email'):\n                email = xml_elem('email', author)\n                email.text = a.get('email')\n            if a.get('uri'):\n                uri = xml_elem('uri', author)\n                uri.text = a.get('uri')\n\n        _add_text_elm(entry, self.__atom_content, 'content')\n\n        for l in self.__atom_link or []:\n            link = xml_elem('link', entry, href=l['href'])\n            if l.get('rel'):\n                link.attrib['rel'] = l['rel']\n            if l.get('type'):\n                link.attrib['type'] = l['type']\n            if l.get('hreflang'):\n                link.attrib['hreflang'] = l['hreflang']\n            if l.get('title'):\n                link.attrib['title'] = l['title']\n            if l.get('length'):\n                link.attrib['length'] = l['length']\n\n        _add_text_elm(entry, self.__atom_summary, 'summary')\n\n        for c in self.__atom_category or []:\n            cat = xml_elem('category', entry, term=c['term'])\n            if c.get('scheme'):\n                cat.attrib['scheme'] = c['scheme']\n            if c.get('label'):\n                cat.attrib['label'] = c['label']\n\n        # Add author elements\n        for c in self.__atom_contributor or []:\n            # Atom requires a name. Skip elements without.\n            if not c.get('name'):\n                continue\n            contrib = xml_elem('contributor', entry)\n            name = xml_elem('name', contrib)\n            name.text = c.get('name')\n            if c.get('email'):\n                email = xml_elem('email', contrib)\n                email.text = c.get('email')\n            if c.get('uri'):\n                uri = xml_elem('uri', contrib)\n                uri.text = c.get('uri')\n\n        if self.__atom_published:\n            published = xml_elem('published', entry)\n            published.text = self.__atom_published.isoformat()\n\n        if self.__atom_rights:\n            rights = xml_elem('rights', entry)\n            rights.text = self.__atom_rights\n\n        if self.__atom_source:\n            source = xml_elem('source', entry)\n            if self.__atom_source.get('title'):\n                source_title = xml_elem('title', source)\n                source_title.text = self.__atom_source['title']\n            if self.__atom_source.get('link'):\n                xml_elem('link', source, href=self.__atom_source['link'])\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('atom'):\n                    ext['inst'].extend_atom(entry)\n\n        return entry\n\n    def rss_entry(self, extensions=True):\n        '''Create a RSS item and return it.'''\n        entry = xml_elem('item')\n        if not (self.__rss_title or\n                self.__rss_description or\n                self.__rss_content):\n            raise ValueError('Required fields not set')\n        if self.__rss_title:\n            title = xml_elem('title', entry)\n            title.text = self.__rss_title\n        if self.__rss_link:\n            link = xml_elem('link', entry)\n            link.text = self.__rss_link\n        if self.__rss_description and self.__rss_content:\n            description = xml_elem('description', entry)\n            description.text = self.__rss_description\n            XMLNS_CONTENT = 'http://purl.org/rss/1.0/modules/content/'\n            content = xml_elem('{%s}encoded' % XMLNS_CONTENT, entry)\n            content.text = CDATA(self.__rss_content['content']) \\\n                if self.__rss_content.get('type', '') == 'CDATA' \\\n                else self.__rss_content['content']\n        elif self.__rss_description:\n            description = xml_elem('description', entry)\n            description.text = self.__rss_description\n        elif self.__rss_content:\n            description = xml_elem('description', entry)\n            description.text = CDATA(self.__rss_content['content']) \\\n                if self.__rss_content.get('type', '') == 'CDATA' \\\n                else self.__rss_content['content']\n        for a in self.__rss_author or []:\n            author = xml_elem('author', entry)\n            author.text = a\n        if self.__rss_guid.get('guid'):\n            guid = xml_elem('guid', entry)\n            guid.text = self.__rss_guid['guid']\n            permaLink = str(self.__rss_guid.get('permalink', False)).lower()\n            guid.attrib['isPermaLink'] = permaLink\n        for cat in self.__rss_category or []:\n            category = xml_elem('category', entry)\n            category.text = cat['value']\n            if cat.get('domain'):\n                category.attrib['domain'] = cat['domain']\n        if self.__rss_comments:\n            comments = xml_elem('comments', entry)\n            comments.text = self.__rss_comments\n        if self.__rss_enclosure:\n            enclosure = xml_elem('enclosure', entry)\n            enclosure.attrib['url'] = self.__rss_enclosure['url']\n            enclosure.attrib['length'] = self.__rss_enclosure['length']\n            enclosure.attrib['type'] = self.__rss_enclosure['type']\n        if self.__rss_pubDate:\n            pubDate = xml_elem('pubDate', entry)\n            pubDate.text = formatRFC2822(self.__rss_pubDate)\n        if self.__rss_source:\n            source = xml_elem('source', entry, url=self.__rss_source['url'])\n            source.text = self.__rss_source['title']\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('rss'):\n                    ext['inst'].extend_rss(entry)\n\n        return entry\n\n    def title(self, title=None):\n        '''Get or set the title value of the entry. It should contain a human\n        readable title for the entry. Title is mandatory for both ATOM and RSS\n        and should not be blank.\n\n        :param title: The new title of the entry.\n        :returns: The entriess title.\n        '''\n        if title is not None:\n            self.__atom_title = title\n            self.__rss_title = title\n        return self.__atom_title\n\n    def id(self, id=None):\n        '''Get or set the entry id which identifies the entry using a\n        universally unique and permanent URI. Two entries in a feed can have\n        the same value for id if they represent the same entry at different\n        points in time. This method will also set rss:guid with permalink set\n        to False. Id is mandatory for an ATOM entry.\n\n        :param id: New Id of the entry.\n        :returns: Id of the entry.\n        '''\n        if id is not None:\n            self.__atom_id = id\n            self.__rss_guid = {'guid': id, 'permalink': False}\n        return self.__atom_id\n\n    def guid(self, guid=None, permalink=False):\n        '''Get or set the entries guid which is a string that uniquely\n        identifies the item. This will also set atom:id.\n\n        :param guid: Id of the entry.\n        :param permalink: If this is a permanent identifier for this item\n        :returns: Id and permalink setting of the entry.\n        '''\n        if guid is not None:\n            self.__atom_id = guid\n            self.__rss_guid = {'guid': guid, 'permalink': permalink}\n        return self.__rss_guid\n\n    def updated(self, updated=None):\n        '''Set or get the updated value which indicates the last time the entry\n        was modified in a significant way.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        :param updated: The modification date.\n        :returns: Modification date as datetime.datetime\n        '''\n        if updated is not None:\n            if isinstance(updated, string_types):\n                updated = dateutil.parser.parse(updated)\n            if not isinstance(updated, datetime):\n                raise ValueError('Invalid datetime format')\n            if updated.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__atom_updated = updated\n            self.__rss_lastBuildDate = updated\n\n        return self.__atom_updated\n\n    def author(self, author=None, replace=False, **kwargs):\n        '''Get or set author data. An author element is a dict containing a\n        name, an email address and a uri. Name is mandatory for ATOM, email is\n        mandatory for RSS.\n\n        This method can be called with:\n        - the fields of an author as keyword arguments\n        - the fields of an author as a dictionary\n        - a list of dictionaries containing the author fields\n\n        An author has the following fields:\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param author:  Dict or list of dicts with author data.\n        :param replace: Add or replace old data.\n\n        Example::\n\n            >>> author({'name':'John Doe', 'email':'jdoe@example.com'})\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n            >>> author([{'name': 'Mr. X'}, {'name': 'Max'}])\n            [{'name':'John Doe','email':'jdoe@example.com'},\n                    {'name':'John Doe'}, {'name':'Max'}]\n\n            >>> author(name='John Doe', email='jdoe@example.com', replace=True)\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n        '''\n        if author is None and kwargs:\n            author = kwargs\n        if author is not None:\n            if replace or self.__atom_author is None:\n                self.__atom_author = []\n            self.__atom_author += ensure_format(author,\n                                                set(['name', 'email', 'uri']),\n                                                set())\n            self.__rss_author = []\n            for a in self.__atom_author:\n                if a.get('email'):\n                    if a.get('name'):\n                        self.__rss_author.append('%(email)s (%(name)s)' % a)\n                    else:\n                        self.__rss_author.append('%(email)s' % a)\n        return self.__atom_author\n\n    def content(self, content=None, src=None, type=None):\n        '''Get or set the content of the entry which contains or links to the\n        complete content of the entry. Content must be provided for ATOM\n        entries if there is no alternate link, and should be provided if there\n        is no summary. If the content is set (not linked) it will also set\n        rss:description.\n\n        :param content: The content of the feed entry.\n        :param src: Link to the entries content.\n        :param type: If type is CDATA content would not be escaped.\n        :returns: Content element of the entry.\n        '''\n        if src is not None:\n            self.__atom_content = {'src': src}\n        elif content is not None:\n            self.__atom_content = {'content': content}\n            self.__rss_content = {'content': content}\n            if type is not None:\n                self.__atom_content['type'] = type\n                self.__rss_content['type'] = type\n        return self.__atom_content\n\n    def link(self, link=None, replace=False, **kwargs):\n        '''Get or set link data. An link element is a dict with the fields\n        href, rel, type, hreflang, title, and length. Href is mandatory for\n        ATOM.\n\n        This method can be called with:\n        - the fields of a link as keyword arguments\n        - the fields of a link as a dictionary\n        - a list of dictionaries containing the link fields\n\n        A link has the following fields:\n\n        - *href* is the URI of the referenced resource (typically a Web page)\n        - *rel* contains a single link relationship type. It can be a full URI,\n          or one of the following predefined values (default=alternate):\n\n            - *alternate* an alternate representation of the entry or feed, for\n              example a permalink to the html version of the entry, or the\n              front page of the weblog.\n            - *enclosure* a related resource which is potentially large in size\n              and might require special handling, for example an audio or video\n              recording.\n            - *related* an document related to the entry or feed.\n            - *self* the feed itself.\n            - *via* the source of the information provided in the entry.\n\n        - *type* indicates the media type of the resource.\n        - *hreflang* indicates the language of the referenced resource.\n        - *title* human readable information about the link, typically for\n          display purposes.\n        - *length* the length of the resource, in bytes.\n\n        RSS only supports one link with nothing but a URL. So for the RSS link\n        element the last link with rel=alternate is used.\n\n        RSS also supports one enclusure element per entry which is covered by\n        the link element in ATOM feed entries. So for the RSS enclusure element\n        the last link with rel=enclosure is used.\n\n        :param link:    Dict or list of dicts with data.\n        :param replace: Add or replace old data.\n        :returns: List of link data.\n        '''\n        if link is None and kwargs:\n            link = kwargs\n        if link is not None:\n            if replace or self.__atom_link is None:\n                self.__atom_link = []\n            self.__atom_link += ensure_format(\n                link,\n                set(['href', 'rel', 'type', 'hreflang', 'title', 'length']),\n                set(['href']),\n                {'rel': ['alternate', 'enclosure', 'related', 'self', 'via']},\n                {'rel': 'alternate'})\n            # RSS only needs one URL. We use the first link for RSS:\n            for l in self.__atom_link:\n                if l.get('rel') == 'alternate':\n                    self.__rss_link = l['href']\n                elif l.get('rel') == 'enclosure':\n                    self.__rss_enclosure = {'url': l['href']}\n                    self.__rss_enclosure['type'] = l.get('type')\n                    self.__rss_enclosure['length'] = l.get('length') or '0'\n        # return the set with more information (atom)\n        return self.__atom_link\n\n    def summary(self, summary=None, type=None):\n        '''Get or set the summary element of an entry which conveys a short\n        summary, abstract, or excerpt of the entry. Summary is an ATOM only\n        element and should be provided if there either is no content provided\n        for the entry, or that content is not inline (i.e., contains a src\n        attribute), or if the content is encoded in base64.  This method will\n        also set the rss:description field if it wasn't previously set or\n        contains the old value of summary.\n\n        :param summary: Summary of the entries contents.\n        :returns: Summary of the entries contents.\n        '''\n        if summary is not None:\n            # Replace the RSS description with the summary if it was the\n            # summary before. Not if it is the description.\n            if not self.__rss_description or (\n                self.__atom_summary and\n                self.__rss_description == self.__atom_summary.get(\"summary\")\n            ):\n                self.__rss_description = summary\n\n            self.__atom_summary = {'summary': summary}\n            if type is not None:\n                self.__atom_summary['type'] = type\n        return self.__atom_summary\n\n    def description(self, description=None, isSummary=False):\n        '''Get or set the description value which is the item synopsis.\n        Description is an RSS only element. For ATOM feeds it is split in\n        summary and content. The isSummary parameter can be used to control\n        which ATOM value is set when setting description.\n\n        :param description: Description of the entry.\n        :param isSummary: If the description should be used as content or\n                          summary.\n        :returns: The entries description.\n        '''\n        if description is not None:\n            self.__rss_description = description\n            if isSummary:\n                self.__atom_summary = description\n            else:\n                self.__atom_content = {'content': description}\n        return self.__rss_description\n\n    def category(self, category=None, replace=False, **kwargs):\n        '''Get or set categories that the entry belongs to.\n\n        This method can be called with:\n        - the fields of a category as keyword arguments\n        - the fields of a category as a dictionary\n        - a list of dictionaries containing the category fields\n\n        A categories has the following fields:\n        - *term* identifies the category\n        - *scheme* identifies the categorization scheme via a URI.\n        - *label* provides a human-readable label for display\n\n        If a label is present it is used for the RSS feeds. Otherwise the term\n        is used. The scheme is used for the domain attribute in RSS.\n\n        :param category:    Dict or list of dicts with data.\n        :param replace: Add or replace old data.\n        :returns: List of category data.\n        '''\n        if category is None and kwargs:\n            category = kwargs\n        if category is not None:\n            if replace or self.__atom_category is None:\n                self.__atom_category = []\n            self.__atom_category += ensure_format(\n                    category,\n                    set(['term', 'scheme', 'label']),\n                    set(['term']))\n            # Map the ATOM categories to RSS categories. Use the atom:label as\n            # name or if not present the atom:term. The atom:scheme is the\n            # rss:domain.\n            self.__rss_category = []\n            for cat in self.__atom_category:\n                rss_cat = {}\n                rss_cat['value'] = cat.get('label', cat['term'])\n                if cat.get('scheme'):\n                    rss_cat['domain'] = cat['scheme']\n                self.__rss_category.append(rss_cat)\n        return self.__atom_category\n\n    def contributor(self, contributor=None, replace=False, **kwargs):\n        '''Get or set the contributor data of the feed. This is an ATOM only\n        value.\n\n        This method can be called with:\n        - the fields of an contributor as keyword arguments\n        - the fields of an contributor as a dictionary\n        - a list of dictionaries containing the contributor fields\n\n        An contributor has the following fields:\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param contributor: Dictionary or list of dictionaries with contributor\n                            data.\n        :param replace: Add or replace old data.\n        :returns: List of contributors as dictionaries.\n        '''\n        if contributor is None and kwargs:\n            contributor = kwargs\n        if contributor is not None:\n            if replace or self.__atom_contributor is None:\n                self.__atom_contributor = []\n            self.__atom_contributor += ensure_format(\n                    contributor, set(['name', 'email', 'uri']), set(['name']))\n        return self.__atom_contributor\n\n    def published(self, published=None):\n        '''Set or get the published value which contains the time of the initial\n        creation or first availability of the entry.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        :param published: The creation date.\n        :returns: Creation date as datetime.datetime\n        '''\n        if published is not None:\n            if isinstance(published, string_types):\n                published = dateutil.parser.parse(published)\n            if not isinstance(published, datetime):\n                raise ValueError('Invalid datetime format')\n            if published.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__atom_published = published\n            self.__rss_pubDate = published\n\n        return self.__atom_published\n\n    def pubDate(self, pubDate=None):\n        '''Get or set the pubDate of the entry which indicates when the entry\n        was published. This method is just another name for the published(...)\n        method.\n        '''\n        return self.published(pubDate)\n\n    def pubdate(self, pubDate=None):\n        '''Get or set the pubDate of the entry which indicates when the entry\n        was published. This method is just another name for the published(...)\n        method.\n\n        pubdate(\u2026) is deprecated and may be removed in feedgen \u2265 0.8. Use\n        pubDate(\u2026) instead.\n        '''\n        warnings.warn('pubdate(\u2026) is deprecated and may be removed in feedgen '\n                      '\u2265 0.8. Use pubDate(\u2026) instead.')\n        return self.published(pubDate)\n\n    def rights(self, rights=None):\n        '''Get or set the rights value of the entry which conveys information\n        about rights, e.g. copyrights, held in and over the entry. This ATOM\n        value will also set rss:copyright.\n\n        :param rights: Rights information of the feed.\n        :returns: Rights information of the feed.\n        '''\n        if rights is not None:\n            self.__atom_rights = rights\n        return self.__atom_rights\n\n    def comments(self, comments=None):\n        '''Get or set the value of comments which is the URL of the comments\n        page for the item. This is a RSS only value.\n\n        :param comments: URL to the comments page.\n        :returns: URL to the comments page.\n        '''\n        if comments is not None:\n            self.__rss_comments = comments\n        return self.__rss_comments\n\n    def source(self, url=None, title=None):\n        '''Get or set the source for the current feed entry.\n\n        Note that ATOM feeds support a lot more sub elements than title and URL\n        (which is what RSS supports) but these are currently not supported.\n        Patches are welcome.\n\n        :param url: Link to the source.\n        :param title: Title of the linked resource\n        :returns: Source element as dictionaries.\n        '''\n        if url is not None and title is not None:\n            self.__rss_source = {'url': url, 'title': title}\n            self.__atom_source = {'link': url, 'title': title}\n        return self.__rss_source\n\n    def enclosure(self, url=None, length=None, type=None):\n        '''Get or set the value of enclosure which describes a media object\n        that is attached to the item. This is a RSS only value which is\n        represented by link(rel=enclosure) in ATOM. ATOM feeds can furthermore\n        contain several enclosures while RSS may contain only one. That is why\n        this method, if repeatedly called, will add more than one enclosures to\n        the feed.  However, only the last one is used for RSS.\n\n        :param url: URL of the media object.\n        :param length: Size of the media in bytes.\n        :param type: Mimetype of the linked media.\n        :returns: Data of the enclosure element.\n        '''\n        if url is not None:\n            self.link(href=url, rel='enclosure', type=type, length=length)\n        return self.__rss_enclosure\n\n    def ttl(self, ttl=None):\n        '''Get or set the ttl value. It is an RSS only element. ttl stands for\n        time to live. It's a number of minutes that indicates how long a\n        channel can be cached before refreshing from the source.\n\n        :param ttl: Integer value representing the time to live.\n        :returns: Time to live of of the entry.\n        '''\n        if ttl is not None:\n            self.__rss_ttl = int(ttl)\n        return self.__rss_ttl\n\n    def load_extension(self, name, atom=True, rss=True):\n        '''Load a specific extension by name.\n\n        :param name: Name of the extension to load.\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if name in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n\n        # Load extension\n        extname = name[0].upper() + name[1:] + 'EntryExtension'\n        try:\n            supmod = __import__('feedgen.ext.%s_entry' % name)\n            extmod = getattr(supmod.ext, name + '_entry')\n        except ImportError:\n            # Use FeedExtension module instead\n            supmod = __import__('feedgen.ext.%s' % name)\n            extmod = getattr(supmod.ext, name)\n        ext = getattr(extmod, extname)\n        self.register_extension(name, ext, atom, rss)\n\n    def register_extension(self, namespace, extension_class_entry=None,\n                           atom=True, rss=True):\n        '''Register a specific extension by classes to a namespace.\n\n        :param namespace: namespace for the extension\n        :param extension_class_entry: Class of the entry extension to load.\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        # `load_extension` ignores the \"Extension\" suffix.\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if namespace in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n        if not extension_class_entry:\n            raise ImportError('No extension class')\n\n        extinst = extension_class_entry()\n        setattr(self, namespace, extinst)\n\n        # `load_extension` registry\n        self.__extensions[namespace] = {\n                'inst': extinst,\n                'extension_class_entry': extension_class_entry,\n                'atom': atom,\n                'rss': rss\n                }\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.dc\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to add Dubline Core Elements to the feeds.\n\n    Descriptions partly taken from\n    http://dublincore.org/documents/dcmi-terms/#elements-coverage\n\n    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom feedgen.ext.base import BaseExtension\nfrom feedgen.util import xml_elem\n\n\nclass DcBaseExtension(BaseExtension):\n    '''Dublin Core Elements extension for podcasts.\n    '''\n\n    def __init__(self):\n        # http://dublincore.org/documents/usageguide/elements.shtml\n        # http://dublincore.org/documents/dces/\n        # http://dublincore.org/documents/dcmi-terms/\n        self._dcelem_contributor = None\n        self._dcelem_coverage = None\n        self._dcelem_creator = None\n        self._dcelem_date = None\n        self._dcelem_description = None\n        self._dcelem_format = None\n        self._dcelem_identifier = None\n        self._dcelem_language = None\n        self._dcelem_publisher = None\n        self._dcelem_relation = None\n        self._dcelem_rights = None\n        self._dcelem_source = None\n        self._dcelem_subject = None\n        self._dcelem_title = None\n        self._dcelem_type = None\n\n    def extend_ns(self):\n        return {'dc': 'http://purl.org/dc/elements/1.1/'}\n\n    def _extend_xml(self, xml_element):\n        '''Extend xml_element with set DC fields.\n\n        :param xml_element: etree element\n        '''\n        DCELEMENTS_NS = 'http://purl.org/dc/elements/1.1/'\n\n        for elem in ['contributor', 'coverage', 'creator', 'date',\n                     'description', 'language', 'publisher', 'relation',\n                     'rights', 'source', 'subject', 'title', 'type', 'format',\n                     'identifier']:\n            if hasattr(self, '_dcelem_%s' % elem):\n                for val in getattr(self, '_dcelem_%s' % elem) or []:\n                    node = xml_elem('{%s}%s' % (DCELEMENTS_NS, elem),\n                                    xml_element)\n                    node.text = val\n\n    def extend_atom(self, atom_feed):\n        '''Extend an Atom feed with the set DC fields.\n\n        :param atom_feed: The feed root element\n        :returns: The feed root element\n        '''\n\n        self._extend_xml(atom_feed)\n\n        return atom_feed\n\n    def extend_rss(self, rss_feed):\n        '''Extend a RSS feed with the set DC fields.\n\n        :param rss_feed: The feed root element\n        :returns: The feed root element.\n        '''\n        channel = rss_feed[0]\n        self._extend_xml(channel)\n\n        return rss_feed\n\n    def dc_contributor(self, contributor=None, replace=False):\n        '''Get or set the dc:contributor which is an entity responsible for\n        making contributions to the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-contributor\n\n        :param contributor: Contributor or list of contributors.\n        :param replace: Replace alredy set contributors (deault: False).\n        :returns: List of contributors.\n        '''\n        if contributor is not None:\n            if not isinstance(contributor, list):\n                contributor = [contributor]\n            if replace or not self._dcelem_contributor:\n                self._dcelem_contributor = []\n            self._dcelem_contributor += contributor\n        return self._dcelem_contributor\n\n    def dc_coverage(self, coverage=None, replace=True):\n        '''Get or set the dc:coverage which indicated the spatial or temporal\n        topic of the resource, the spatial applicability of the resource, or\n        the jurisdiction under which the resource is relevant.\n\n        Spatial topic and spatial applicability may be a named place or a\n        location specified by its geographic coordinates. Temporal topic may be\n        a named period, date, or date range. A jurisdiction may be a named\n        administrative entity or a geographic place to which the resource\n        applies. Recommended best practice is to use a controlled vocabulary\n        such as the Thesaurus of Geographic Names [TGN]. Where appropriate,\n        named places or time periods can be used in preference to numeric\n        identifiers such as sets of coordinates or date ranges.\n\n        References:\n        [TGN] http://www.getty.edu/research/tools/vocabulary/tgn/index.html\n\n        :param coverage: Coverage of the feed.\n        :param replace: Replace already set coverage (default: True).\n        :returns: Coverage of the feed.\n        '''\n        if coverage is not None:\n            if not isinstance(coverage, list):\n                coverage = [coverage]\n            if replace or not self._dcelem_coverage:\n                self._dcelem_coverage = []\n            self._dcelem_coverage = coverage\n        return self._dcelem_coverage\n\n    def dc_creator(self, creator=None, replace=False):\n        '''Get or set the dc:creator which is an entity primarily responsible\n        for making the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-creator\n\n        :param creator: Creator or list of creators.\n        :param replace: Replace alredy set creators (deault: False).\n        :returns: List of creators.\n        '''\n        if creator is not None:\n            if not isinstance(creator, list):\n                creator = [creator]\n            if replace or not self._dcelem_creator:\n                self._dcelem_creator = []\n            self._dcelem_creator += creator\n        return self._dcelem_creator\n\n    def dc_date(self, date=None, replace=True):\n        '''Get or set the dc:date which describes a point or period of time\n        associated with an event in the lifecycle of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-date\n\n        :param date: Date or list of dates.\n        :param replace: Replace alredy set dates (deault: True).\n        :returns: List of dates.\n        '''\n        if date is not None:\n            if not isinstance(date, list):\n                date = [date]\n            if replace or not self._dcelem_date:\n                self._dcelem_date = []\n            self._dcelem_date += date\n        return self._dcelem_date\n\n    def dc_description(self, description=None, replace=True):\n        '''Get or set the dc:description which is an account of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-description\n\n        :param description: Description or list of descriptions.\n        :param replace: Replace alredy set descriptions (deault: True).\n        :returns: List of descriptions.\n        '''\n        if description is not None:\n            if not isinstance(description, list):\n                description = [description]\n            if replace or not self._dcelem_description:\n                self._dcelem_description = []\n            self._dcelem_description += description\n        return self._dcelem_description\n\n    def dc_format(self, format=None, replace=True):\n        '''Get or set the dc:format which describes the file format, physical\n        medium, or dimensions of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-format\n\n        :param format: Format of the resource or list of formats.\n        :param replace: Replace alredy set format (deault: True).\n        :returns: Format of the resource.\n        '''\n        if format is not None:\n            if not isinstance(format, list):\n                format = [format]\n            if replace or not self._dcelem_format:\n                self._dcelem_format = []\n            self._dcelem_format += format\n        return self._dcelem_format\n\n    def dc_identifier(self, identifier=None, replace=True):\n        '''Get or set the dc:identifier which should be an unambiguous\n        reference to the resource within a given context.\n\n        For more inidentifierion see:\n        http://dublincore.org/documents/dcmi-terms/#elements-identifier\n\n        :param identifier: Identifier of the resource or list of identifiers.\n        :param replace: Replace alredy set identifier (deault: True).\n        :returns: Identifiers of the resource.\n        '''\n        if identifier is not None:\n            if not isinstance(identifier, list):\n                identifier = [identifier]\n            if replace or not self._dcelem_identifier:\n                self._dcelem_identifier = []\n            self._dcelem_identifier += identifier\n        return self._dcelem_identifier\n\n    def dc_language(self, language=None, replace=True):\n        '''Get or set the dc:language which describes a language of the\n        resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-language\n\n        :param language: Language or list of languages.\n        :param replace: Replace alredy set languages (deault: True).\n        :returns: List of languages.\n        '''\n        if language is not None:\n            if not isinstance(language, list):\n                language = [language]\n            if replace or not self._dcelem_language:\n                self._dcelem_language = []\n            self._dcelem_language += language\n        return self._dcelem_language\n\n    def dc_publisher(self, publisher=None, replace=False):\n        '''Get or set the dc:publisher which is an entity responsible for\n        making the resource available.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-publisher\n\n        :param publisher: Publisher or list of publishers.\n        :param replace: Replace alredy set publishers (deault: False).\n        :returns: List of publishers.\n        '''\n        if publisher is not None:\n            if not isinstance(publisher, list):\n                publisher = [publisher]\n            if replace or not self._dcelem_publisher:\n                self._dcelem_publisher = []\n            self._dcelem_publisher += publisher\n        return self._dcelem_publisher\n\n    def dc_relation(self, relation=None, replace=False):\n        '''Get or set the dc:relation which describes a related resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-relation\n\n        :param relation: Relation or list of relations.\n        :param replace: Replace alredy set relations (deault: False).\n        :returns: List of relations.\n        '''\n        if relation is not None:\n            if not isinstance(relation, list):\n                relation = [relation]\n            if replace or not self._dcelem_relation:\n                self._dcelem_relation = []\n            self._dcelem_relation += relation\n        return self._dcelem_relation\n\n    def dc_rights(self, rights=None, replace=False):\n        '''Get or set the dc:rights which may contain information about rights\n        held in and over the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-rights\n\n        :param rights: Rights information or list of rights information.\n        :param replace: Replace alredy set rightss (deault: False).\n        :returns: List of rights information.\n        '''\n        if rights is not None:\n            if not isinstance(rights, list):\n                rights = [rights]\n            if replace or not self._dcelem_rights:\n                self._dcelem_rights = []\n            self._dcelem_rights += rights\n        return self._dcelem_rights\n\n    def dc_source(self, source=None, replace=False):\n        '''Get or set the dc:source which is a related resource from which the\n        described resource is derived.\n\n        The described resource may be derived from the related resource in\n        whole or in part. Recommended best practice is to identify the related\n        resource by means of a string conforming to a formal identification\n        system.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-source\n\n        :param source: Source or list of sources.\n        :param replace: Replace alredy set sources (deault: False).\n        :returns: List of sources.\n        '''\n        if source is not None:\n            if not isinstance(source, list):\n                source = [source]\n            if replace or not self._dcelem_source:\n                self._dcelem_source = []\n            self._dcelem_source += source\n        return self._dcelem_source\n\n    def dc_subject(self, subject=None, replace=False):\n        '''Get or set the dc:subject which describes the topic of the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-subject\n\n        :param subject: Subject or list of subjects.\n        :param replace: Replace alredy set subjects (deault: False).\n        :returns: List of subjects.\n        '''\n        if subject is not None:\n            if not isinstance(subject, list):\n                subject = [subject]\n            if replace or not self._dcelem_subject:\n                self._dcelem_subject = []\n            self._dcelem_subject += subject\n        return self._dcelem_subject\n\n    def dc_title(self, title=None, replace=True):\n        '''Get or set the dc:title which is a name given to the resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-title\n\n        :param title: Title or list of titles.\n        :param replace: Replace alredy set titles (deault: False).\n        :returns: List of titles.\n        '''\n        if title is not None:\n            if not isinstance(title, list):\n                title = [title]\n            if replace or not self._dcelem_title:\n                self._dcelem_title = []\n            self._dcelem_title += title\n        return self._dcelem_title\n\n    def dc_type(self, type=None, replace=False):\n        '''Get or set the dc:type which describes the nature or genre of the\n        resource.\n\n        For more information see:\n        http://dublincore.org/documents/dcmi-terms/#elements-type\n\n        :param type: Type or list of types.\n        :param replace: Replace alredy set types (deault: False).\n        :returns: List of types.\n        '''\n        if type is not None:\n            if not isinstance(type, list):\n                type = [type]\n            if replace or not self._dcelem_type:\n                self._dcelem_type = []\n            self._dcelem_type += type\n        return self._dcelem_type\n\n\nclass DcExtension(DcBaseExtension):\n    '''Dublin Core Elements extension for podcasts.\n    '''\n\n\nclass DcEntryExtension(DcBaseExtension):\n    '''Dublin Core Elements extension for podcasts.\n    '''\n    def extend_atom(self, entry):\n        '''Add dc elements to an atom item. Alters the item itself.\n\n        :param entry: An atom entry element.\n        :returns: The entry element.\n        '''\n        self._extend_xml(entry)\n        return entry\n\n    def extend_rss(self, item):\n        '''Add dc elements to a RSS item. Alters the item itself.\n\n        :param item: A RSS item element.\n        :returns: The item element.\n        '''\n        self._extend_xml(item)\n        return item\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.geo_entry\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to produce Simple GeoRSS feeds.\n\n    :copyright: 2017, Bob Breznak <bob.breznak@gmail.com>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\nimport numbers\nimport warnings\n\nfrom feedgen.ext.base import BaseEntryExtension\nfrom feedgen.util import xml_elem\n\n\nclass GeoRSSPolygonInteriorWarning(Warning):\n    \"\"\"\n    Simple placeholder for warning about ignored polygon interiors.\n\n    Stores the original geom on a ``geom`` attribute (if required warnings are\n    raised as errors).\n    \"\"\"\n\n    def __init__(self, geom, *args, **kwargs):\n        self.geom = geom\n        super(GeoRSSPolygonInteriorWarning, self).__init__(*args, **kwargs)\n\n    def __str__(self):\n        return '{:d} interiors of polygon ignored'.format(\n            len(self.geom.__geo_interface__['coordinates']) - 1\n        )  # ignore exterior in count\n\n\nclass GeoRSSGeometryError(ValueError):\n    \"\"\"\n    Subclass of ValueError for a GeoRSS geometry error\n\n    Only some geometries are supported in Simple GeoRSS, so if not raise an\n    error. Offending geometry is stored on the ``geom`` attribute.\n    \"\"\"\n\n    def __init__(self, geom, *args, **kwargs):\n        self.geom = geom\n        super(GeoRSSGeometryError, self).__init__(*args, **kwargs)\n\n    def __str__(self):\n        msg = \"Geometry of type '{}' not in Point, Linestring or Polygon\"\n        return msg.format(\n            self.geom.__geo_interface__['type']\n        )\n\n\nclass GeoEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for Simple GeoRSS.\n    '''\n\n    def __init__(self):\n        '''Simple GeoRSS tag'''\n        # geometries\n        self.__point = None\n        self.__line = None\n        self.__polygon = None\n        self.__box = None\n\n        # additional properties\n        self.__featuretypetag = None\n        self.__relationshiptag = None\n        self.__featurename = None\n\n        # elevation\n        self.__elev = None\n        self.__floor = None\n\n        # radius\n        self.__radius = None\n\n    def extend_file(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n\n        GEO_NS = 'http://www.georss.org/georss'\n\n        if self.__point:\n            point = xml_elem('{%s}point' % GEO_NS, entry)\n            point.text = self.__point\n\n        if self.__line:\n            line = xml_elem('{%s}line' % GEO_NS, entry)\n            line.text = self.__line\n\n        if self.__polygon:\n            polygon = xml_elem('{%s}polygon' % GEO_NS, entry)\n            polygon.text = self.__polygon\n\n        if self.__box:\n            box = xml_elem('{%s}box' % GEO_NS, entry)\n            box.text = self.__box\n\n        if self.__featuretypetag:\n            featuretypetag = xml_elem('{%s}featuretypetag' % GEO_NS, entry)\n            featuretypetag.text = self.__featuretypetag\n\n        if self.__relationshiptag:\n            relationshiptag = xml_elem('{%s}relationshiptag' % GEO_NS, entry)\n            relationshiptag.text = self.__relationshiptag\n\n        if self.__featurename:\n            featurename = xml_elem('{%s}featurename' % GEO_NS, entry)\n            featurename.text = self.__featurename\n\n        if self.__elev:\n            elevation = xml_elem('{%s}elev' % GEO_NS, entry)\n            elevation.text = str(self.__elev)\n\n        if self.__floor:\n            floor = xml_elem('{%s}floor' % GEO_NS, entry)\n            floor.text = str(self.__floor)\n\n        if self.__radius:\n            radius = xml_elem('{%s}radius' % GEO_NS, entry)\n            radius.text = str(self.__radius)\n\n        return entry\n\n    def extend_rss(self, entry):\n        return self.extend_file(entry)\n\n    def extend_atom(self, entry):\n        return self.extend_file(entry)\n\n    def point(self, point=None):\n        '''Get or set the georss:point of the entry.\n\n        :param point: The GeoRSS formatted point (i.e. \"42.36 -71.05\")\n        :returns: The current georss:point of the entry.\n        '''\n\n        if point is not None:\n            self.__point = point\n\n        return self.__point\n\n    def line(self, line=None):\n        '''Get or set the georss:line of the entry\n\n        :param point: The GeoRSS formatted line (i.e. \"45.256 -110.45 46.46\n                      -109.48 43.84 -109.86\")\n        :return: The current georss:line of the entry\n        '''\n        if line is not None:\n            self.__line = line\n\n        return self.__line\n\n    def polygon(self, polygon=None):\n        '''Get or set the georss:polygon of the entry\n\n        :param polygon: The GeoRSS formatted polygon (i.e. \"45.256 -110.45\n                        46.46 -109.48 43.84 -109.86 45.256 -110.45\")\n        :return: The current georss:polygon of the entry\n        '''\n        if polygon is not None:\n            self.__polygon = polygon\n\n        return self.__polygon\n\n    def box(self, box=None):\n        '''\n        Get or set the georss:box of the entry\n\n        :param box: The GeoRSS formatted box (i.e. \"42.943 -71.032 43.039\n                    -69.856\")\n        :return: The current georss:box of the entry\n        '''\n        if box is not None:\n            self.__box = box\n\n        return self.__box\n\n    def featuretypetag(self, featuretypetag=None):\n        '''\n        Get or set the georss:featuretypetag of the entry\n\n        :param featuretypetag: The GeoRSS feaaturertyptag (e.g. \"city\")\n        :return: The current georss:featurertypetag\n        '''\n        if featuretypetag is not None:\n            self.__featuretypetag = featuretypetag\n\n        return self.__featuretypetag\n\n    def relationshiptag(self, relationshiptag=None):\n        '''\n        Get or set the georss:relationshiptag of the entry\n\n        :param relationshiptag: The GeoRSS relationshiptag (e.g.\n                                \"is-centred-at\")\n        :return: the current georss:relationshiptag\n        '''\n        if relationshiptag is not None:\n            self.__relationshiptag = relationshiptag\n\n        return self.__relationshiptag\n\n    def featurename(self, featurename=None):\n        '''\n        Get or set the georss:featurename of the entry\n\n        :param featuretypetag: The GeoRSS featurename (e.g. \"Footscray\")\n        :return: the current georss:featurename\n        '''\n        if featurename is not None:\n            self.__featurename = featurename\n\n        return self.__featurename\n\n    def elev(self, elev=None):\n        '''\n        Get or set the georss:elev of the entry\n\n        :param elev: The GeoRSS elevation (e.g. 100.3)\n        :type elev: numbers.Number\n        :return: the current georss:elev\n        '''\n        if elev is not None:\n            if not isinstance(elev, numbers.Number):\n                raise ValueError(\"elev tag must be numeric: {}\".format(elev))\n\n            self.__elev = elev\n\n        return self.__elev\n\n    def floor(self, floor=None):\n        '''\n        Get or set the georss:floor of the entry\n\n        :param floor: The GeoRSS floor (e.g. 4)\n        :type floor: int\n        :return: the current georss:floor\n        '''\n        if floor is not None:\n            if not isinstance(floor, int):\n                raise ValueError(\"floor tag must be int: {}\".format(floor))\n\n            self.__floor = floor\n\n        return self.__floor\n\n    def radius(self, radius=None):\n        '''\n        Get or set the georss:radius of the entry\n\n        :param radius: The GeoRSS radius (e.g. 100.3)\n        :type radius: numbers.Number\n        :return: the current georss:radius\n        '''\n        if radius is not None:\n            if not isinstance(radius, numbers.Number):\n                raise ValueError(\n                    \"radius tag must be numeric: {}\".format(radius)\n                )\n\n            self.__radius = radius\n\n        return self.__radius\n\n    def geom_from_geo_interface(self, geom):\n        '''\n        Generate a georss geometry from some Python object with a\n        ``__geo_interface__`` property (see the `geo_interface specification by\n        Sean Gillies`_geointerface )\n\n        Note only a subset of GeoJSON (see `geojson.org`_geojson ) can be\n        easily converted to GeoRSS:\n\n        - Point\n        - LineString\n        - Polygon (if there are holes / donuts in the polygons a warning will\n          be generaated\n\n        Other GeoJson types will raise a ``ValueError``.\n\n        .. note:: The geometry is assumed to be x, y as longitude, latitude in\n           the WGS84 projection.\n\n        .. _geointerface: https://gist.github.com/sgillies/2217756\n        .. _geojson: https://geojson.org/\n\n        :param geom: Geometry object with a __geo_interface__ property\n        :return: the formatted GeoRSS geometry\n        '''\n        geojson = geom.__geo_interface__\n\n        if geojson['type'] not in ('Point', 'LineString', 'Polygon'):\n            raise GeoRSSGeometryError(geom)\n\n        if geojson['type'] == 'Point':\n\n            coords = '{:f} {:f}'.format(\n                geojson['coordinates'][1],  # latitude is y\n                geojson['coordinates'][0]\n            )\n            return self.point(coords)\n\n        elif geojson['type'] == 'LineString':\n\n            coords = ' '.join(\n                '{:f} {:f}'.format(vertex[1], vertex[0])\n                for vertex in\n                geojson['coordinates']\n            )\n            return self.line(coords)\n\n        elif geojson['type'] == 'Polygon':\n\n            if len(geojson['coordinates']) > 1:\n                warnings.warn(GeoRSSPolygonInteriorWarning(geom))\n\n            coords = ' '.join(\n                '{:f} {:f}'.format(vertex[1], vertex[0])\n                for vertex in\n                geojson['coordinates'][0]\n            )\n            return self.polygon(coords)\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.media\n    ~~~~~~~~~~~~~~~~~\n\n    Extends the feedgen to produce media tags.\n\n    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom feedgen.ext.base import BaseEntryExtension, BaseExtension\nfrom feedgen.util import ensure_format, xml_elem\n\nMEDIA_NS = 'http://search.yahoo.com/mrss/'\n\n\nclass MediaExtension(BaseExtension):\n    '''FeedGenerator extension for torrent feeds.\n    '''\n\n    def extend_ns(self):\n        return {'media': MEDIA_NS}\n\n\nclass MediaEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for media tags.\n    '''\n\n    def __init__(self):\n        self.__media_content = []\n        self.__media_thumbnail = []\n\n    def extend_atom(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n\n        groups = {None: entry}\n        for media_content in self.__media_content:\n            # Define current media:group\n            group = groups.get(media_content.get('group'))\n            if group is None:\n                group = xml_elem('{%s}group' % MEDIA_NS, entry)\n                groups[media_content.get('group')] = group\n            # Add content\n            content = xml_elem('{%s}content' % MEDIA_NS, group)\n            for attr in ('url', 'fileSize', 'type', 'medium', 'isDefault',\n                         'expression', 'bitrate', 'framerate', 'samplingrate',\n                         'channels', 'duration', 'height', 'width', 'lang'):\n                if media_content.get(attr):\n                    content.set(attr, media_content[attr])\n\n        for media_thumbnail in self.__media_thumbnail:\n            # Define current media:group\n            group = groups.get(media_thumbnail.get('group'))\n            if group is None:\n                group = xml_elem('{%s}group' % MEDIA_NS, entry)\n                groups[media_thumbnail.get('group')] = group\n            # Add thumbnails\n            thumbnail = xml_elem('{%s}thumbnail' % MEDIA_NS, group)\n            for attr in ('url', 'height', 'width', 'time'):\n                if media_thumbnail.get(attr):\n                    thumbnail.set(attr, media_thumbnail[attr])\n\n        return entry\n\n    def extend_rss(self, item):\n        return self.extend_atom(item)\n\n    def content(self, content=None, replace=False, group='default', **kwargs):\n        '''Get or set media:content data.\n\n        This method can be called with:\n        - the fields of a media:content as keyword arguments\n        - the fields of a media:content as a dictionary\n        - a list of dictionaries containing the media:content fields\n\n        <media:content> is a sub-element of either <item> or <media:group>.\n        Media objects that are not the same content should not be included in\n        the same <media:group> element. The sequence of these items implies\n        the order of presentation. While many of the attributes appear to be\n        audio/video specific, this element can be used to publish any type\n        of media. It contains 14 attributes, most of which are optional.\n\n        media:content has the following fields:\n        - *url* should specify the direct URL to the media object.\n        - *fileSize* number of bytes of the media object.\n        - *type* standard MIME type of the object.\n        - *medium* type of object (image | audio | video | document |\n          executable).\n        - *isDefault* determines if this is the default object.\n        - *expression* determines if the object is a sample or the full version\n          of the object, or even if it is a continuous stream (sample | full |\n          nonstop).\n        - *bitrate* kilobits per second rate of media.\n        - *framerate* number of frames per second for the media object.\n        - *samplingrate* number of samples per second taken to create the media\n          object. It is expressed in thousands of samples per second (kHz).\n        - *channels* number of audio channels in the media object.\n        - *duration* number of seconds the media object plays.\n        - *height* height of the media object.\n        - *width* width of the media object.\n        - *lang* is the primary language encapsulated in the media object.\n\n        :param content: Dictionary or list of dictionaries with content data.\n        :param replace: Add or replace old data.\n        :param group: Media group to put this content in.\n\n        :returns: The media content tag.\n        '''\n        # Handle kwargs\n        if content is None and kwargs:\n            content = kwargs\n        # Handle new data\n        if content is not None:\n            # Reset data if we want to replace them\n            if replace or self.__media_content is None:\n                self.__media_content = []\n            # Ensure list\n            if not isinstance(content, list):\n                content = [content]\n            # define media group\n            for c in content:\n                c['group'] = c.get('group', group)\n            self.__media_content += ensure_format(\n                    content,\n                    set(['url', 'fileSize', 'type', 'medium', 'isDefault',\n                         'expression', 'bitrate', 'framerate', 'samplingrate',\n                         'channels', 'duration', 'height', 'width', 'lang',\n                         'group']),\n                    set(['url', 'group']))\n        return self.__media_content\n\n    def thumbnail(self, thumbnail=None, replace=False, group='default',\n                  **kwargs):\n        '''Get or set media:thumbnail data.\n\n        This method can be called with:\n        - the fields of a media:content as keyword arguments\n        - the fields of a media:content as a dictionary\n        - a list of dictionaries containing the media:content fields\n\n        Allows particular images to be used as representative images for\n        the media object. If multiple thumbnails are included, and time\n        coding is not at play, it is assumed that the images are in order\n        of importance. It has one required attribute and three optional\n        attributes.\n\n        media:thumbnail has the following fields:\n        - *url* should specify the direct URL to the media object.\n        - *height* height of the media object.\n        - *width* width of the media object.\n        - *time* specifies the time offset in relation to the media object.\n\n        :param thumbnail: Dictionary or list of dictionaries with thumbnail\n                          data.\n        :param replace: Add or replace old data.\n        :param group: Media group to put this content in.\n\n        :returns: The media thumbnail tag.\n        '''\n        # Handle kwargs\n        if thumbnail is None and kwargs:\n            thumbnail = kwargs\n        # Handle new data\n        if thumbnail is not None:\n            # Reset data if we want to replace them\n            if replace or self.__media_thumbnail is None:\n                self.__media_thumbnail = []\n            # Ensure list\n            if not isinstance(thumbnail, list):\n                thumbnail = [thumbnail]\n            # Define media group\n            for t in thumbnail:\n                t['group'] = t.get('group', group)\n            self.__media_thumbnail += ensure_format(\n                    thumbnail,\n                    set(['url', 'height', 'width', 'time', 'group']),\n                    set(['url', 'group']))\n        return self.__media_thumbnail\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.podcast\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to produce podcasts.\n\n    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom feedgen.compat import string_types\nfrom feedgen.ext.base import BaseExtension\nfrom feedgen.util import ensure_format, xml_elem\n\n\nclass PodcastExtension(BaseExtension):\n    '''FeedGenerator extension for podcasts.\n    '''\n\n    def __init__(self):\n        # ITunes tags\n        # http://www.apple.com/itunes/podcasts/specs.html#rss\n        self.__itunes_author = None\n        self.__itunes_block = None\n        self.__itunes_category = None\n        self.__itunes_image = None\n        self.__itunes_explicit = None\n        self.__itunes_complete = None\n        self.__itunes_new_feed_url = None\n        self.__itunes_owner = None\n        self.__itunes_subtitle = None\n        self.__itunes_summary = None\n\n    def extend_ns(self):\n        return {'itunes': 'http://www.itunes.com/dtds/podcast-1.0.dtd'}\n\n    def extend_rss(self, rss_feed):\n        '''Extend an RSS feed root with set itunes fields.\n\n        :returns: The feed root element.\n        '''\n        ITUNES_NS = 'http://www.itunes.com/dtds/podcast-1.0.dtd'\n        channel = rss_feed[0]\n\n        if self.__itunes_author:\n            author = xml_elem('{%s}author' % ITUNES_NS, channel)\n            author.text = self.__itunes_author\n\n        if self.__itunes_block is not None:\n            block = xml_elem('{%s}block' % ITUNES_NS, channel)\n            block.text = 'yes' if self.__itunes_block else 'no'\n\n        for c in self.__itunes_category or []:\n            if not c.get('cat'):\n                continue\n            category = channel.find(\n                    '{%s}category[@text=\"%s\"]' % (ITUNES_NS, c.get('cat')))\n            if category is None:\n                category = xml_elem('{%s}category' % ITUNES_NS, channel)\n                category.attrib['text'] = c.get('cat')\n\n            if c.get('sub'):\n                subcategory = xml_elem('{%s}category' % ITUNES_NS, category)\n                subcategory.attrib['text'] = c.get('sub')\n\n        if self.__itunes_image:\n            image = xml_elem('{%s}image' % ITUNES_NS, channel)\n            image.attrib['href'] = self.__itunes_image\n\n        if self.__itunes_explicit in ('yes', 'no', 'clean'):\n            explicit = xml_elem('{%s}explicit' % ITUNES_NS, channel)\n            explicit.text = self.__itunes_explicit\n\n        if self.__itunes_complete in ('yes', 'no'):\n            complete = xml_elem('{%s}complete' % ITUNES_NS, channel)\n            complete.text = self.__itunes_complete\n\n        if self.__itunes_new_feed_url:\n            new_feed_url = xml_elem('{%s}new-feed-url' % ITUNES_NS, channel)\n            new_feed_url.text = self.__itunes_new_feed_url\n\n        if self.__itunes_owner:\n            owner = xml_elem('{%s}owner' % ITUNES_NS, channel)\n            owner_name = xml_elem('{%s}name' % ITUNES_NS, owner)\n            owner_name.text = self.__itunes_owner.get('name')\n            owner_email = xml_elem('{%s}email' % ITUNES_NS, owner)\n            owner_email.text = self.__itunes_owner.get('email')\n\n        if self.__itunes_subtitle:\n            subtitle = xml_elem('{%s}subtitle' % ITUNES_NS, channel)\n            subtitle.text = self.__itunes_subtitle\n\n        if self.__itunes_summary:\n            summary = xml_elem('{%s}summary' % ITUNES_NS, channel)\n            summary.text = self.__itunes_summary\n\n        return rss_feed\n\n    def itunes_author(self, itunes_author=None):\n        '''Get or set the itunes:author. The content of this tag is shown in\n        the Artist column in iTunes. If the tag is not present, iTunes uses the\n        contents of the <author> tag. If <itunes:author> is not present at the\n        feed level, iTunes will use the contents of <managingEditor>.\n\n        :param itunes_author: The author of the podcast.\n        :returns: The author of the podcast.\n        '''\n        if itunes_author is not None:\n            self.__itunes_author = itunes_author\n        return self.__itunes_author\n\n    def itunes_block(self, itunes_block=None):\n        '''Get or set the ITunes block attribute. Use this to prevent the\n        entire podcast from appearing in the iTunes podcast directory.\n\n        :param itunes_block: Block the podcast.\n        :returns: If the podcast is blocked.\n        '''\n        if itunes_block is not None:\n            self.__itunes_block = itunes_block\n        return self.__itunes_block\n\n    def itunes_category(self, itunes_category=None, replace=False, **kwargs):\n        '''Get or set the ITunes category which appears in the category column\n        and in iTunes Store Browser.\n\n        The (sub-)category has to be one from the values defined at\n        http://www.apple.com/itunes/podcasts/specs.html#categories\n\n        This method can be called with:\n\n        - the fields of an itunes_category as keyword arguments\n        - the fields of an itunes_category as a dictionary\n        - a list of dictionaries containing the itunes_category fields\n\n        An itunes_category has the following fields:\n\n        - *cat* name for a category.\n        - *sub* name for a subcategory, child of category\n\n        If a podcast has more than one subcategory from the same category, the\n        category is called more than once.\n\n        Likei the parameter::\n\n            [{\"cat\":\"Arts\",\"sub\":\"Design\"},{\"cat\":\"Arts\",\"sub\":\"Food\"}]\n\n        \u2026would become::\n\n            <itunes:category text=\"Arts\">\n                <itunes:category text=\"Design\"/>\n                <itunes:category text=\"Food\"/>\n            </itunes:category>\n\n\n        :param itunes_category: Dictionary or list of dictionaries with\n                                itunes_category data.\n        :param replace: Add or replace old data.\n        :returns: List of itunes_categories as dictionaries.\n\n        ---\n\n        **Important note about deprecated parameter syntax:** Old version of\n        the feedgen did only support one category plus one subcategory which\n        would be passed to this ducntion as first two parameters. For\n        compatibility reasons, this still works but should not be used any may\n        be removed at any time.\n        '''\n        # Ensure old API still works for now. Note that the API is deprecated\n        # and this fallback may be removed at any time.\n        if isinstance(itunes_category, string_types):\n            itunes_category = {'cat': itunes_category}\n            if replace:\n                itunes_category['sub'] = replace\n            replace = True\n        if itunes_category is None and kwargs:\n            itunes_category = kwargs\n        if itunes_category is not None:\n            if replace or self.__itunes_category is None:\n                self.__itunes_category = []\n            self.__itunes_category += ensure_format(itunes_category,\n                                                    set(['cat', 'sub']),\n                                                    set(['cat']))\n        return self.__itunes_category\n\n    def itunes_image(self, itunes_image=None):\n        '''Get or set the image for the podcast. This tag specifies the artwork\n        for your podcast. Put the URL to the image in the href attribute.\n        iTunes prefers square .jpg images that are at least 1400x1400 pixels,\n        which is different from what is specified for the standard RSS image\n        tag. In order for a podcast to be eligible for an iTunes Store feature,\n        the accompanying image must be at least 1400x1400 pixels.\n\n        iTunes supports images in JPEG and PNG formats with an RGB color space\n        (CMYK is not supported). The URL must end in \".jpg\" or \".png\". If the\n        <itunes:image> tag is not present, iTunes will use the contents of the\n        RSS image tag.\n\n        If you change your podcast\u2019s image, also change the file\u2019s name. iTunes\n        may not change the image if it checks your feed and the image URL is\n        the same. The server hosting your cover art image must allow HTTP head\n        requests for iTS to be able to automatically update your cover art.\n\n        :param itunes_image: Image of the podcast.\n        :returns: Image of the podcast.\n        '''\n        if itunes_image is not None:\n            if itunes_image.endswith('.jpg') or itunes_image.endswith('.png'):\n                self.__itunes_image = itunes_image\n            else:\n                ValueError('Image file must be png or jpg')\n        return self.__itunes_image\n\n    def itunes_explicit(self, itunes_explicit=None):\n        '''Get or the the itunes:explicit value of the podcast. This tag should\n        be used to indicate whether your podcast contains explicit material.\n        The three values for this tag are \"yes\", \"no\", and \"clean\".\n\n        If you populate this tag with \"yes\", an \"explicit\" parental advisory\n        graphic will appear next to your podcast artwork on the iTunes Store\n        and in the Name column in iTunes. If the value is \"clean\", the parental\n        advisory type is considered Clean, meaning that no explicit language or\n        adult content is included anywhere in the episodes, and a \"clean\"\n        graphic will appear. If the explicit tag is present and has any other\n        value (e.g., \"no\"), you see no indicator \u2014 blank is the default\n        advisory type.\n\n        :param itunes_explicit: If the podcast contains explicit material.\n        :returns: If the podcast contains explicit material.\n        '''\n        if itunes_explicit is not None:\n            if itunes_explicit not in ('', 'yes', 'no', 'clean'):\n                raise ValueError('Invalid value for explicit tag')\n            self.__itunes_explicit = itunes_explicit\n        return self.__itunes_explicit\n\n    def itunes_complete(self, itunes_complete=None):\n        '''Get or set the itunes:complete value of the podcast. This tag can be\n        used to indicate the completion of a podcast.\n\n        If you populate this tag with \"yes\", you are indicating that no more\n        episodes will be added to the podcast. If the <itunes:complete> tag is\n        present and has any other value (e.g. \u201cno\u201d), it will have no effect on\n        the podcast.\n\n        :param itunes_complete: If the podcast is complete.\n        :returns: If the podcast is complete.\n        '''\n        if itunes_complete is not None:\n            if itunes_complete not in ('yes', 'no', '', True, False):\n                raise ValueError('Invalid value for complete tag')\n            if itunes_complete is True:\n                itunes_complete = 'yes'\n            if itunes_complete is False:\n                itunes_complete = 'no'\n            self.__itunes_complete = itunes_complete\n        return self.__itunes_complete\n\n    def itunes_new_feed_url(self, itunes_new_feed_url=None):\n        '''Get or set the new-feed-url property of the podcast. This tag allows\n        you to change the URL where the podcast feed is located\n\n        After adding the tag to your old feed, you should maintain the old feed\n        for 48 hours before retiring it. At that point, iTunes will have\n        updated the directory with the new feed URL.\n\n        :param itunes_new_feed_url: New feed URL.\n        :returns: New feed URL.\n        '''\n        if itunes_new_feed_url is not None:\n            self.__itunes_new_feed_url = itunes_new_feed_url\n        return self.__itunes_new_feed_url\n\n    def itunes_owner(self, name=None, email=None):\n        '''Get or set the itunes:owner of the podcast. This tag contains\n        information that will be used to contact the owner of the podcast for\n        communication specifically about the podcast. It will not be publicly\n        displayed.\n\n        :param itunes_owner: The owner of the feed.\n        :returns: Data of the owner of the feed.\n        '''\n        if name is not None:\n            if name and email:\n                self.__itunes_owner = {'name': name, 'email': email}\n            elif not name and not email:\n                self.__itunes_owner = None\n            else:\n                raise ValueError('Both name and email have to be set.')\n        return self.__itunes_owner\n\n    def itunes_subtitle(self, itunes_subtitle=None):\n        '''Get or set the itunes:subtitle value for the podcast. The contents of\n        this tag are shown in the Description column in iTunes. The subtitle\n        displays best if it is only a few words long.\n\n        :param itunes_subtitle: Subtitle of the podcast.\n        :returns: Subtitle of the podcast.\n        '''\n        if itunes_subtitle is not None:\n            self.__itunes_subtitle = itunes_subtitle\n        return self.__itunes_subtitle\n\n    def itunes_summary(self, itunes_summary=None):\n        '''Get or set the itunes:summary value for the podcast. The contents of\n        this tag are shown in a separate window that appears when the \"circled\n        i\" in the Description column is clicked. It also appears on the iTunes\n        page for your podcast. This field can be up to 4000 characters. If\n        `<itunes:summary>` is not included, the contents of the <description>\n        tag are used.\n\n        :param itunes_summary: Summary of the podcast.\n        :returns: Summary of the podcast.\n        '''\n        if itunes_summary is not None:\n            self.__itunes_summary = itunes_summary\n        return self.__itunes_summary\n\n    _itunes_categories = {\n            'Arts': [\n                'Design', 'Fashion & Beauty', 'Food', 'Literature',\n                'Performing Arts', 'Visual Arts'],\n            'Business': [\n                'Business News', 'Careers', 'Investing',\n                'Management & Marketing', 'Shopping'],\n            'Comedy': [],\n            'Education': [\n                'Education', 'Education Technology', 'Higher Education',\n                'K-12', 'Language Courses', 'Training'],\n            'Games & Hobbies': [\n                'Automotive', 'Aviation', 'Hobbies', 'Other Games',\n                'Video Games'],\n            'Government & Organizations': [\n                'Local', 'National', 'Non-Profit', 'Regional'],\n            'Health': [\n                'Alternative Health', 'Fitness & Nutrition', 'Self-Help',\n                'Sexuality'],\n            'Kids & Family': [],\n            'Music': [],\n            'News & Politics': [],\n            'Religion & Spirituality': [\n                'Buddhism', 'Christianity', 'Hinduism', 'Islam', 'Judaism',\n                'Other', 'Spirituality'],\n            'Science & Medicine': [\n                'Medicine', 'Natural Sciences', 'Social Sciences'],\n            'Society & Culture': [\n                'History', 'Personal Journals', 'Philosophy',\n                'Places & Travel'],\n            'Sports & Recreation': [\n                'Amateur', 'College & High School', 'Outdoor', 'Professional'],\n            'Technology': [\n                'Gadgets', 'Tech News', 'Podcasting', 'Software How-To'],\n            'TV & Film': []}\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.podcast_entry\n    ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Extends the feedgen to produce podcasts.\n\n    :copyright: 2013-2016, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom feedgen.ext.base import BaseEntryExtension\nfrom feedgen.util import xml_elem\n\n\nclass PodcastEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for podcasts.\n    '''\n\n    def __init__(self):\n        # ITunes tags\n        # http://www.apple.com/itunes/podcasts/specs.html#rss\n        self.__itunes_author = None\n        self.__itunes_block = None\n        self.__itunes_image = None\n        self.__itunes_duration = None\n        self.__itunes_explicit = None\n        self.__itunes_is_closed_captioned = None\n        self.__itunes_order = None\n        self.__itunes_subtitle = None\n        self.__itunes_summary = None\n\n    def extend_rss(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n        ITUNES_NS = 'http://www.itunes.com/dtds/podcast-1.0.dtd'\n\n        if self.__itunes_author:\n            author = xml_elem('{%s}author' % ITUNES_NS, entry)\n            author.text = self.__itunes_author\n\n        if self.__itunes_block is not None:\n            block = xml_elem('{%s}block' % ITUNES_NS, entry)\n            block.text = 'yes' if self.__itunes_block else 'no'\n\n        if self.__itunes_image:\n            image = xml_elem('{%s}image' % ITUNES_NS, entry)\n            image.attrib['href'] = self.__itunes_image\n\n        if self.__itunes_duration:\n            duration = xml_elem('{%s}duration' % ITUNES_NS, entry)\n            duration.text = self.__itunes_duration\n\n        if self.__itunes_explicit in ('yes', 'no', 'clean'):\n            explicit = xml_elem('{%s}explicit' % ITUNES_NS, entry)\n            explicit.text = self.__itunes_explicit\n\n        if self.__itunes_is_closed_captioned is not None:\n            is_closed_captioned = xml_elem(\n                    '{%s}isClosedCaptioned' % ITUNES_NS, entry)\n            if self.__itunes_is_closed_captioned:\n                is_closed_captioned.text = 'yes'\n            else:\n                is_closed_captioned.text = 'no'\n\n        if self.__itunes_order is not None and self.__itunes_order >= 0:\n            order = xml_elem('{%s}order' % ITUNES_NS, entry)\n            order.text = str(self.__itunes_order)\n\n        if self.__itunes_subtitle:\n            subtitle = xml_elem('{%s}subtitle' % ITUNES_NS, entry)\n            subtitle.text = self.__itunes_subtitle\n\n        if self.__itunes_summary:\n            summary = xml_elem('{%s}summary' % ITUNES_NS, entry)\n            summary.text = self.__itunes_summary\n        return entry\n\n    def itunes_author(self, itunes_author=None):\n        '''Get or set the itunes:author of the podcast episode. The content of\n        this tag is shown in the Artist column in iTunes. If the tag is not\n        present, iTunes uses the contents of the <author> tag. If\n        <itunes:author> is not present at the feed level, iTunes will use the\n        contents of <managingEditor>.\n\n        :param itunes_author: The author of the podcast.\n        :returns: The author of the podcast.\n        '''\n        if itunes_author is not None:\n            self.__itunes_author = itunes_author\n        return self.__itunes_author\n\n    def itunes_block(self, itunes_block=None):\n        '''Get or set the ITunes block attribute. Use this to prevent episodes\n        from appearing in the iTunes podcast directory.\n\n        :param itunes_block: Block podcast episodes.\n        :returns: If the podcast episode is blocked.\n        '''\n        if itunes_block is not None:\n            self.__itunes_block = itunes_block\n        return self.__itunes_block\n\n    def itunes_image(self, itunes_image=None):\n        '''Get or set the image for the podcast episode. This tag specifies the\n        artwork for your podcast. Put the URL to the image in the href\n        attribute.  iTunes prefers square .jpg images that are at least\n        1400x1400 pixels, which is different from what is specified for the\n        standard RSS image tag.  In order for a podcast to be eligible for an\n        iTunes Store feature, the accompanying image must be at least 1400x1400\n        pixels.\n\n        iTunes supports images in JPEG and PNG formats with an RGB color space\n        (CMYK is not supported). The URL must end in \".jpg\" or \".png\". If the\n        <itunes:image> tag is not present, iTunes will use the contents of the\n        RSS image tag.\n\n        If you change your podcast\u2019s image, also change the file\u2019s name. iTunes\n        may not change the image if it checks your feed and the image URL is\n        the same. The server hosting your cover art image must allow HTTP head\n        requests for iTS to be able to automatically update your cover art.\n\n        :param itunes_image: Image of the podcast.\n        :returns: Image of the podcast.\n        '''\n        if itunes_image is not None:\n            if itunes_image.endswith('.jpg') or itunes_image.endswith('.png'):\n                self.__itunes_image = itunes_image\n            else:\n                raise ValueError('Image file must be png or jpg')\n        return self.__itunes_image\n\n    def itunes_duration(self, itunes_duration=None):\n        '''Get or set the duration of the podcast episode. The content of this\n        tag is shown in the Time column in iTunes.\n\n        The tag can be formatted HH:MM:SS, H:MM:SS, MM:SS, or M:SS (H = hours,\n        M = minutes, S = seconds). If an integer is provided (no colon\n        present), the value is assumed to be in seconds. If one colon is\n        present, the number to the left is assumed to be minutes, and the\n        number to the right is assumed to be seconds. If more than two colons\n        are present, the numbers farthest to the right are ignored.\n\n        :param itunes_duration: Duration of the podcast episode.\n        :returns: Duration of the podcast episode.\n        '''\n        if itunes_duration is not None:\n            itunes_duration = str(itunes_duration)\n            if len(itunes_duration.split(':')) > 3 or \\\n                    itunes_duration.lstrip('0123456789:') != '':\n                raise ValueError('Invalid duration format')\n            self.__itunes_duration = itunes_duration\n        return self.__itunes_duration\n\n    def itunes_explicit(self, itunes_explicit=None):\n        '''Get or the the itunes:explicit value of the podcast episode. This\n        tag should be used to indicate whether your podcast episode contains\n        explicit material. The three values for this tag are \"yes\", \"no\", and\n        \"clean\".\n\n        If you populate this tag with \"yes\", an \"explicit\" parental advisory\n        graphic will appear next to your podcast artwork on the iTunes Store\n        and in the Name column in iTunes. If the value is \"clean\", the parental\n        advisory type is considered Clean, meaning that no explicit language or\n        adult content is included anywhere in the episodes, and a \"clean\"\n        graphic will appear. If the explicit tag is present and has any other\n        value (e.g., \"no\"), you see no indicator \u2014 blank is the default\n        advisory type.\n\n        :param itunes_explicit: If the podcast episode contains explicit\n                                material.\n        :returns: If the podcast episode contains explicit material.\n        '''\n        if itunes_explicit is not None:\n            if itunes_explicit not in ('', 'yes', 'no', 'clean'):\n                raise ValueError('Invalid value for explicit tag')\n            self.__itunes_explicit = itunes_explicit\n        return self.__itunes_explicit\n\n    def itunes_is_closed_captioned(self, itunes_is_closed_captioned=None):\n        '''Get or set the is_closed_captioned value of the podcast episode.\n        This tag should be used if your podcast includes a video episode with\n        embedded closed captioning support. The two values for this tag are\n        \"yes\" and \"no\u201d.\n\n        :param is_closed_captioned: If the episode has closed captioning\n                                    support.\n        :returns: If the episode has closed captioning support.\n        '''\n        if itunes_is_closed_captioned is not None:\n            self.__itunes_is_closed_captioned = \\\n                    itunes_is_closed_captioned in ('yes', True)\n        return self.__itunes_is_closed_captioned\n\n    def itunes_order(self, itunes_order=None):\n        '''Get or set the itunes:order value of the podcast episode. This tag\n        can be used to override the default ordering of episodes on the store.\n\n        This tag is used at an <item> level by populating with the number value\n        in which you would like the episode to appear on the store. For\n        example, if you would like an <item> to appear as the first episode in\n        the podcast, you would populate the <itunes:order> tag with \u201c1\u201d. If\n        conflicting order values are present in multiple episodes, the store\n        will use default ordering (pubDate).\n\n        To remove the order from the episode set the order to a value below\n        zero.\n\n        :param itunes_order: The order of the episode.\n        :returns: The order of the episode.\n        '''\n        if itunes_order is not None:\n            self.__itunes_order = int(itunes_order)\n        return self.__itunes_order\n\n    def itunes_subtitle(self, itunes_subtitle=None):\n        '''Get or set the itunes:subtitle value for the podcast episode. The\n        contents of this tag are shown in the Description column in iTunes. The\n        subtitle displays best if it is only a few words long.\n\n        :param itunes_subtitle: Subtitle of the podcast episode.\n        :returns: Subtitle of the podcast episode.\n        '''\n        if itunes_subtitle is not None:\n            self.__itunes_subtitle = itunes_subtitle\n        return self.__itunes_subtitle\n\n    def itunes_summary(self, itunes_summary=None):\n        '''Get or set the itunes:summary value for the podcast episode. The\n        contents of this tag are shown in a separate window that appears when\n        the \"circled i\" in the Description column is clicked. It also appears\n        on the iTunes page for your podcast. This field can be up to 4000\n        characters. If <itunes:summary> is not included, the contents of the\n        <description> tag are used.\n\n        :param itunes_summary: Summary of the podcast episode.\n        :returns: Summary of the podcast episode.\n        '''\n        if itunes_summary is not None:\n            self.__itunes_summary = itunes_summary\n        return self.__itunes_summary\n", "# -*- coding: utf-8 -*-\n#\n# Copyright 2015 Kenichi Sato <ksato9700@gmail.com>\n#\n\n'''\nExtends FeedGenerator to support Syndication module\n\nSee below for details\nhttp://web.resource.org/rss/1.0/modules/syndication/\n'''\n\nfrom feedgen.ext.base import BaseExtension\nfrom feedgen.util import xml_elem\n\nSYNDICATION_NS = 'http://purl.org/rss/1.0/modules/syndication/'\nPERIOD_TYPE = ('hourly', 'daily', 'weekly', 'monthly', 'yearly')\n\n\ndef _set_value(channel, name, value):\n    if value:\n        newelem = xml_elem('{%s}' % SYNDICATION_NS + name, channel)\n        newelem.text = value\n\n\nclass SyndicationExtension(BaseExtension):\n    def __init__(self):\n        self._update_period = None\n        self._update_freq = None\n        self._update_base = None\n\n    def extend_ns(self):\n        return {'sy': SYNDICATION_NS}\n\n    def extend_rss(self, rss_feed):\n        channel = rss_feed[0]\n        _set_value(channel, 'UpdatePeriod', self._update_period)\n        _set_value(channel, 'UpdateFrequency', str(self._update_freq))\n        _set_value(channel, 'UpdateBase', self._update_base)\n\n    def update_period(self, value):\n        if value not in PERIOD_TYPE:\n            raise ValueError('Invalid update period value')\n        self._update_period = value\n        return self._update_period\n\n    def update_frequency(self, value):\n        if type(value) is not int or value <= 0:\n            raise ValueError('Invalid update frequency value')\n        self._update_freq = value\n        return self._update_freq\n\n    def update_base(self, value):\n        # the value should be in W3CDTF format\n        self._update_base = value\n        return self._update_base\n\n\nclass SyndicationEntryExtension(BaseExtension):\n    pass\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.ext.torrent\n    ~~~~~~~~~~~~~~~~~~~\n\n    Extends the FeedGenerator to produce torrent feeds.\n\n    :copyright: 2016, Raspbeguy <raspbeguy@hashtagueule.fr>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\n\nfrom feedgen.ext.base import BaseEntryExtension, BaseExtension\nfrom feedgen.util import xml_elem\n\nTORRENT_NS = 'http://xmlns.ezrss.it/0.1/dtd/'\n\n\nclass TorrentExtension(BaseExtension):\n    '''FeedGenerator extension for torrent feeds.\n    '''\n    def extend_ns(self):\n        return {'torrent': TORRENT_NS}\n\n\nclass TorrentEntryExtension(BaseEntryExtension):\n    '''FeedEntry extension for torrent feeds\n    '''\n    def __init__(self):\n        self.__torrent_filename = None\n        self.__torrent_infohash = None\n        self.__torrent_contentlength = None\n        self.__torrent_seeds = None\n        self.__torrent_peers = None\n        self.__torrent_verified = None\n\n    def extend_rss(self, entry):\n        '''Add additional fields to an RSS item.\n\n        :param feed: The RSS item XML element to use.\n        '''\n        if self.__torrent_filename:\n            filename = xml_elem('{%s}filename' % TORRENT_NS, entry)\n            filename.text = self.__torrent_filename\n\n        if self.__torrent_contentlength:\n            contentlength = xml_elem('{%s}contentlength' % TORRENT_NS, entry)\n            contentlength.text = self.__torrent_contentlength\n\n        if self.__torrent_infohash:\n            infohash = xml_elem('{%s}infohash' % TORRENT_NS, entry)\n            infohash.text = self.__torrent_infohash\n            magnet = xml_elem('{%s}magneturi' % TORRENT_NS, entry)\n            magnet.text = 'magnet:?xt=urn:btih:' + self.__torrent_infohash\n\n        if self.__torrent_seeds:\n            seeds = xml_elem('{%s}seed' % TORRENT_NS, entry)\n            seeds.text = self.__torrent_seeds\n\n        if self.__torrent_peers:\n            peers = xml_elem('{%s}peers' % TORRENT_NS, entry)\n            peers.text = self.__torrent_peers\n\n        if self.__torrent_verified:\n            verified = xml_elem('{%s}verified' % TORRENT_NS, entry)\n            verified.text = self.__torrent_verified\n\n    def filename(self, torrent_filename=None):\n        '''Get or set the name of the torrent file.\n\n        :param torrent_filename: The name of the torrent file.\n        :returns: The name of the torrent file.\n        '''\n        if torrent_filename is not None:\n            self.__torrent_filename = torrent_filename\n        return self.__torrent_filename\n\n    def infohash(self, torrent_infohash=None):\n        '''Get or set the hash of the target file.\n\n        :param torrent_infohash: The target file hash.\n        :returns: The target hash file.\n        '''\n        if torrent_infohash is not None:\n            self.__torrent_infohash = torrent_infohash\n        return self.__torrent_infohash\n\n    def contentlength(self, torrent_contentlength=None):\n        '''Get or set the size of the target file.\n\n        :param torrent_contentlength: The target file size.\n        :returns: The target file size.\n        '''\n        if torrent_contentlength is not None:\n            self.__torrent_contentlength = torrent_contentlength\n        return self.__torrent_contentlength\n\n    def seeds(self, torrent_seeds=None):\n        '''Get or set the number of seeds.\n\n        :param torrent_seeds: The seeds number.\n        :returns: The seeds number.\n        '''\n        if torrent_seeds is not None:\n            self.__torrent_seeds = torrent_seeds\n        return self.__torrent_seeds\n\n    def peers(self, torrent_peers=None):\n        '''Get or set the number od peers\n\n        :param torrent_infohash: The peers number.\n        :returns: The peers number.\n        '''\n        if torrent_peers is not None:\n            self.__torrent_peers = torrent_peers\n        return self.__torrent_peers\n\n    def verified(self, torrent_verified=None):\n        '''Get or set the number of verified peers.\n\n        :param torrent_infohash: The verified peers number.\n        :returns: The verified peers number.\n        '''\n        if torrent_verified is not None:\n            self.__torrent_verified = torrent_verified\n        return self.__torrent_verified\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.feed\n    ~~~~~~~~~~~~\n\n    :copyright: 2013-2020, Lars Kiesow <lkiesow@uos.de>\n\n    :license: FreeBSD and LGPL, see license.* for more details.\n\n'''\n\nimport sys\nfrom datetime import datetime\n\nimport dateutil.parser\nimport dateutil.tz\nfrom lxml import etree  # nosec - not using this for parsing\n\nimport feedgen.version\nfrom feedgen.compat import string_types\nfrom feedgen.entry import FeedEntry\nfrom feedgen.util import ensure_format, formatRFC2822, xml_elem\n\n_feedgen_version = feedgen.version.version_str\n\n\nclass FeedGenerator(object):\n    '''FeedGenerator for generating ATOM and RSS feeds.\n    '''\n\n    def __init__(self):\n        self.__feed_entries = []\n\n        # ATOM\n        # https://tools.ietf.org/html/rfc4287\n        # required\n        self.__atom_id = None\n        self.__atom_title = None\n        self.__atom_updated = datetime.now(dateutil.tz.tzutc())\n\n        # recommended\n        self.__atom_author = None  # {name*, uri, email}\n        self.__atom_link = None  # {href*, rel, type, hreflang, title, length}\n\n        # optional\n        self.__atom_category = None  # {term*, scheme, label}\n        self.__atom_contributor = None\n        self.__atom_generator = {\n                'value': 'python-feedgen',\n                'uri': 'https://lkiesow.github.io/python-feedgen',\n                'version': feedgen.version.version_str}  # {value*,uri,version}\n        self.__atom_icon = None\n        self.__atom_logo = None\n        self.__atom_rights = None\n        self.__atom_subtitle = None\n\n        # other\n        self.__atom_feed_xml_lang = None\n\n        # RSS\n        # http://www.rssboard.org/rss-specification\n        self.__rss_title = None\n        self.__rss_link = None\n        self.__rss_description = None\n\n        self.__rss_category = None\n        self.__rss_cloud = None\n        self.__rss_copyright = None\n        self.__rss_docs = 'http://www.rssboard.org/rss-specification'\n        self.__rss_generator = 'python-feedgen'\n        self.__rss_image = None\n        self.__rss_language = None\n        self.__rss_lastBuildDate = datetime.now(dateutil.tz.tzutc())\n        self.__rss_managingEditor = None\n        self.__rss_pubDate = None\n        self.__rss_rating = None\n        self.__rss_skipHours = None\n        self.__rss_skipDays = None\n        self.__rss_textInput = None\n        self.__rss_ttl = None\n        self.__rss_webMaster = None\n\n        # Extension list:\n        self.__extensions = {}\n\n    def _create_atom(self, extensions=True):\n        '''Create a ATOM feed xml structure containing all previously set\n        fields.\n\n        :returns: Tuple containing the feed root element and the element tree.\n        '''\n        nsmap = dict()\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('atom'):\n                    nsmap.update(ext['inst'].extend_ns())\n\n        feed = xml_elem('feed',\n                        xmlns='http://www.w3.org/2005/Atom',\n                        nsmap=nsmap)\n        if self.__atom_feed_xml_lang:\n            feed.attrib['{http://www.w3.org/XML/1998/namespace}lang'] = \\\n                    self.__atom_feed_xml_lang\n\n        if not (self.__atom_id and self.__atom_title and self.__atom_updated):\n            missing = ([] if self.__atom_title else ['title']) + \\\n                      ([] if self.__atom_id else ['id']) + \\\n                      ([] if self.__atom_updated else ['updated'])\n            missing = ', '.join(missing)\n            raise ValueError('Required fields not set (%s)' % missing)\n        id = xml_elem('id', feed)\n        id.text = self.__atom_id\n        title = xml_elem('title', feed)\n        title.text = self.__atom_title\n        updated = xml_elem('updated', feed)\n        updated.text = self.__atom_updated.isoformat()\n\n        # Add author elements\n        for a in self.__atom_author or []:\n            # Atom requires a name. Skip elements without.\n            if not a.get('name'):\n                continue\n            author = xml_elem('author', feed)\n            name = xml_elem('name', author)\n            name.text = a.get('name')\n            if a.get('email'):\n                email = xml_elem('email', author)\n                email.text = a.get('email')\n            if a.get('uri'):\n                uri = xml_elem('uri', author)\n                uri.text = a.get('uri')\n\n        for l in self.__atom_link or []:\n            link = xml_elem('link', feed, href=l['href'])\n            if l.get('rel'):\n                link.attrib['rel'] = l['rel']\n            if l.get('type'):\n                link.attrib['type'] = l['type']\n            if l.get('hreflang'):\n                link.attrib['hreflang'] = l['hreflang']\n            if l.get('title'):\n                link.attrib['title'] = l['title']\n            if l.get('length'):\n                link.attrib['length'] = l['length']\n\n        for c in self.__atom_category or []:\n            cat = xml_elem('category', feed, term=c['term'])\n            if c.get('scheme'):\n                cat.attrib['scheme'] = c['scheme']\n            if c.get('label'):\n                cat.attrib['label'] = c['label']\n\n        # Add author elements\n        for c in self.__atom_contributor or []:\n            # Atom requires a name. Skip elements without.\n            if not c.get('name'):\n                continue\n            contrib = xml_elem('contributor', feed)\n            name = xml_elem('name', contrib)\n            name.text = c.get('name')\n            if c.get('email'):\n                email = xml_elem('email', contrib)\n                email.text = c.get('email')\n            if c.get('uri'):\n                uri = xml_elem('uri', contrib)\n                uri.text = c.get('uri')\n\n        if self.__atom_generator and self.__atom_generator.get('value'):\n            generator = xml_elem('generator', feed)\n            generator.text = self.__atom_generator['value']\n            if self.__atom_generator.get('uri'):\n                generator.attrib['uri'] = self.__atom_generator['uri']\n            if self.__atom_generator.get('version'):\n                generator.attrib['version'] = self.__atom_generator['version']\n\n        if self.__atom_icon:\n            icon = xml_elem('icon', feed)\n            icon.text = self.__atom_icon\n\n        if self.__atom_logo:\n            logo = xml_elem('logo', feed)\n            logo.text = self.__atom_logo\n\n        if self.__atom_rights:\n            rights = xml_elem('rights', feed)\n            rights.text = self.__atom_rights\n\n        if self.__atom_subtitle:\n            subtitle = xml_elem('subtitle', feed)\n            subtitle.text = self.__atom_subtitle\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('atom'):\n                    ext['inst'].extend_atom(feed)\n\n        for entry in self.__feed_entries:\n            entry = entry.atom_entry()\n            feed.append(entry)\n\n        doc = etree.ElementTree(feed)\n        return feed, doc\n\n    def atom_str(self, pretty=False, extensions=True, encoding='UTF-8',\n                 xml_declaration=True):\n        '''Generates an ATOM feed and returns the feed XML as string.\n\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        :returns: String representation of the ATOM feed.\n\n        **Return type:** The return type may vary between different Python\n        versions and your encoding parameters passed to this method. For\n        details have a look at the `lxml documentation\n        <https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.tostring>`_\n        '''\n        feed, doc = self._create_atom(extensions=extensions)\n        return etree.tostring(feed, pretty_print=pretty, encoding=encoding,\n                              xml_declaration=xml_declaration)\n\n    def atom_file(self, filename, extensions=True, pretty=False,\n                  encoding='UTF-8', xml_declaration=True):\n        '''Generates an ATOM feed and write the resulting XML to a file.\n\n        :param filename: Name of file to write or a file-like object or a URL.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        '''\n        feed, doc = self._create_atom(extensions=extensions)\n        doc.write(filename, pretty_print=pretty, encoding=encoding,\n                  xml_declaration=xml_declaration)\n\n    def _create_rss(self, extensions=True):\n        '''Create an RSS feed xml structure containing all previously set\n        fields.\n\n        :returns: Tuple containing the feed root element and the element tree.\n        '''\n        nsmap = dict()\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('rss'):\n                    nsmap.update(ext['inst'].extend_ns())\n\n        nsmap.update({'atom':  'http://www.w3.org/2005/Atom',\n                      'content': 'http://purl.org/rss/1.0/modules/content/'})\n\n        feed = xml_elem('rss', version='2.0', nsmap=nsmap)\n        channel = xml_elem('channel', feed)\n        if not (self.__rss_title and\n                self.__rss_link and\n                self.__rss_description):\n            missing = ([] if self.__rss_title else ['title']) + \\\n                      ([] if self.__rss_link else ['link']) + \\\n                      ([] if self.__rss_description else ['description'])\n            missing = ', '.join(missing)\n            raise ValueError('Required fields not set (%s)' % missing)\n        title = xml_elem('title', channel)\n        title.text = self.__rss_title\n        link = xml_elem('link', channel)\n        link.text = self.__rss_link\n        desc = xml_elem('description', channel)\n        desc.text = self.__rss_description\n        for ln in self.__atom_link or []:\n            # It is recommended to include a atom self link in rss documents\u2026\n            if ln.get('rel') == 'self':\n                selflink = xml_elem('{http://www.w3.org/2005/Atom}link',\n                                    channel, href=ln['href'], rel='self')\n                if ln.get('type'):\n                    selflink.attrib['type'] = ln['type']\n                if ln.get('hreflang'):\n                    selflink.attrib['hreflang'] = ln['hreflang']\n                if ln.get('title'):\n                    selflink.attrib['title'] = ln['title']\n                if ln.get('length'):\n                    selflink.attrib['length'] = ln['length']\n                break\n        if self.__rss_category:\n            for cat in self.__rss_category:\n                category = xml_elem('category', channel)\n                category.text = cat['value']\n                if cat.get('domain'):\n                    category.attrib['domain'] = cat['domain']\n        if self.__rss_cloud:\n            cloud = xml_elem('cloud', channel)\n            cloud.attrib['domain'] = self.__rss_cloud.get('domain')\n            cloud.attrib['port'] = self.__rss_cloud.get('port')\n            cloud.attrib['path'] = self.__rss_cloud.get('path')\n            cloud.attrib['registerProcedure'] = self.__rss_cloud.get(\n                    'registerProcedure')\n            cloud.attrib['protocol'] = self.__rss_cloud.get('protocol')\n        if self.__rss_copyright:\n            copyright = xml_elem('copyright', channel)\n            copyright.text = self.__rss_copyright\n        if self.__rss_docs:\n            docs = xml_elem('docs', channel)\n            docs.text = self.__rss_docs\n        if self.__rss_generator:\n            generator = xml_elem('generator', channel)\n            generator.text = self.__rss_generator\n        if self.__rss_image:\n            image = xml_elem('image', channel)\n            url = xml_elem('url', image)\n            url.text = self.__rss_image.get('url')\n            title = xml_elem('title', image)\n            title.text = self.__rss_image.get('title', self.__rss_title)\n            link = xml_elem('link', image)\n            link.text = self.__rss_image.get('link', self.__rss_link)\n            if self.__rss_image.get('width'):\n                width = xml_elem('width', image)\n                width.text = self.__rss_image.get('width')\n            if self.__rss_image.get('height'):\n                height = xml_elem('height', image)\n                height.text = self.__rss_image.get('height')\n            if self.__rss_image.get('description'):\n                description = xml_elem('description', image)\n                description.text = self.__rss_image.get('description')\n        if self.__rss_language:\n            language = xml_elem('language', channel)\n            language.text = self.__rss_language\n        if self.__rss_lastBuildDate:\n            lastBuildDate = xml_elem('lastBuildDate', channel)\n\n            lastBuildDate.text = formatRFC2822(self.__rss_lastBuildDate)\n        if self.__rss_managingEditor:\n            managingEditor = xml_elem('managingEditor', channel)\n            managingEditor.text = self.__rss_managingEditor\n        if self.__rss_pubDate:\n            pubDate = xml_elem('pubDate', channel)\n            pubDate.text = formatRFC2822(self.__rss_pubDate)\n        if self.__rss_rating:\n            rating = xml_elem('rating', channel)\n            rating.text = self.__rss_rating\n        if self.__rss_skipHours:\n            skipHours = xml_elem('skipHours', channel)\n            for h in self.__rss_skipHours:\n                hour = xml_elem('hour', skipHours)\n                hour.text = str(h)\n        if self.__rss_skipDays:\n            skipDays = xml_elem('skipDays', channel)\n            for d in self.__rss_skipDays:\n                day = xml_elem('day', skipDays)\n                day.text = d\n        if self.__rss_textInput:\n            textInput = xml_elem('textInput', channel)\n            textInput.attrib['title'] = self.__rss_textInput.get('title')\n            textInput.attrib['description'] = \\\n                self.__rss_textInput.get('description')\n            textInput.attrib['name'] = self.__rss_textInput.get('name')\n            textInput.attrib['link'] = self.__rss_textInput.get('link')\n        if self.__rss_ttl:\n            ttl = xml_elem('ttl', channel)\n            ttl.text = str(self.__rss_ttl)\n        if self.__rss_webMaster:\n            webMaster = xml_elem('webMaster', channel)\n            webMaster.text = self.__rss_webMaster\n\n        if extensions:\n            for ext in self.__extensions.values() or []:\n                if ext.get('rss'):\n                    ext['inst'].extend_rss(feed)\n\n        for entry in self.__feed_entries:\n            item = entry.rss_entry()\n            channel.append(item)\n\n        doc = etree.ElementTree(feed)\n        return feed, doc\n\n    def rss_str(self, pretty=False, extensions=True, encoding='UTF-8',\n                xml_declaration=True):\n        '''Generates an RSS feed and returns the feed XML as string.\n\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        :returns: String representation of the RSS feed.\n\n        **Return type:** The return type may vary between different Python\n        versions and your encoding parameters passed to this method. For\n        details have a look at the `lxml documentation\n        <https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.tostring>`_\n        '''\n        feed, doc = self._create_rss(extensions=extensions)\n        return etree.tostring(feed, pretty_print=pretty, encoding=encoding,\n                              xml_declaration=xml_declaration)\n\n    def rss_file(self, filename, extensions=True, pretty=False,\n                 encoding='UTF-8', xml_declaration=True):\n        '''Generates an RSS feed and write the resulting XML to a file.\n\n        :param filename: Name of file to write or a file-like object or a URL.\n        :param extensions: Enable or disable the loaded extensions for the xml\n            generation (default: enabled).\n        :param pretty: If the feed should be split into multiple lines and\n            properly indented.\n        :param encoding: Encoding used in the  XML file (default: UTF-8).\n        :param xml_declaration: If an XML declaration should be added to the\n            output (Default: enabled).\n        '''\n        feed, doc = self._create_rss(extensions=extensions)\n        doc.write(filename, pretty_print=pretty, encoding=encoding,\n                  xml_declaration=xml_declaration)\n\n    def title(self, title=None):\n        '''Get or set the title value of the feed. It should contain a human\n        readable title for the feed. Often the same as the title of the\n        associated website. Title is mandatory for both ATOM and RSS and should\n        not be blank.\n\n        :param title: The new title of the feed.\n        :returns: The feeds title.\n        '''\n        if title is not None:\n            self.__atom_title = title\n            self.__rss_title = title\n        return self.__atom_title\n\n    def id(self, id=None):\n        '''Get or set the feed id which identifies the feed using a universally\n        unique and permanent URI. If you have a long-term, renewable lease on\n        your Internet domain name, then you can feel free to use your website's\n        address. This field is for ATOM only. It is mandatory for ATOM.\n\n        :param id: New Id of the ATOM feed.\n        :returns: Id of the feed.\n        '''\n\n        if id is not None:\n            self.__atom_id = id\n        return self.__atom_id\n\n    def updated(self, updated=None):\n        '''Set or get the updated value which indicates the last time the feed\n        was modified in a significant way.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        This will set both atom:updated and rss:lastBuildDate.\n\n        Default value\n            If not set, updated has as value the current date and time.\n\n        :param updated: The modification date.\n        :returns: Modification date as datetime.datetime\n        '''\n        if updated is not None:\n            if isinstance(updated, string_types):\n                updated = dateutil.parser.parse(updated)\n            if not isinstance(updated, datetime):\n                raise ValueError('Invalid datetime format')\n            if updated.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__atom_updated = updated\n            self.__rss_lastBuildDate = updated\n\n        return self.__atom_updated\n\n    def lastBuildDate(self, lastBuildDate=None):\n        '''Set or get the lastBuildDate value which indicates the last time the\n        content of the channel changed.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        This will set both atom:updated and rss:lastBuildDate.\n\n        Default value\n            If not set, lastBuildDate has as value the current date and time.\n\n        :param lastBuildDate: The modification date.\n        :returns: Modification date as datetime.datetime\n        '''\n        return self.updated(lastBuildDate)\n\n    def author(self, author=None, replace=False, **kwargs):\n        '''Get or set author data. An author element is a dictionary containing\n        a name, an email address and a URI. Name is mandatory for ATOM, email\n        is mandatory for RSS.\n\n        This method can be called with:\n\n        - the fields of an author as keyword arguments\n        - the fields of an author as a dictionary\n        - a list of dictionaries containing the author fields\n\n        An author has the following fields:\n\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param author:  Dictionary or list of dictionaries with author data.\n        :param replace: Add or replace old data.\n        :returns: List of authors as dictionaries.\n\n        Example::\n\n            >>> feedgen.author({'name':'John Doe', 'email':'jdoe@example.com'})\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n            >>> feedgen.author([{'name':'Mr. X'},{'name':'Max'}])\n            [{'name':'John Doe','email':'jdoe@example.com'},\n                    {'name':'John Doe'}, {'name':'Max'}]\n\n            >>> feedgen.author(name='John Doe', email='jdoe@example.com',\n                               replace=True)\n            [{'name':'John Doe','email':'jdoe@example.com'}]\n\n        '''\n        if author is None and kwargs:\n            author = kwargs\n        if author is not None:\n            if replace or self.__atom_author is None:\n                self.__atom_author = []\n            self.__atom_author += ensure_format(author,\n                                                set(['name', 'email', 'uri']),\n                                                set(['name']))\n            self.__rss_author = []\n            for a in self.__atom_author:\n                if a.get('email'):\n                    self.__rss_author.append(a['email'])\n        return self.__atom_author\n\n    def link(self, link=None, replace=False, **kwargs):\n        '''Get or set link data. An link element is a dict with the fields\n        href, rel, type, hreflang, title, and length. Href is mandatory for\n        ATOM.\n\n        This method can be called with:\n\n        - the fields of a link as keyword arguments\n        - the fields of a link as a dictionary\n        - a list of dictionaries containing the link fields\n\n        A link has the following fields:\n\n        - *href* is the URI of the referenced resource (typically a Web page)\n        - *rel* contains a single link relationship type. It can be a full URI,\n          or one of the following predefined values (default=alternate):\n\n            - *alternate* an alternate representation of the entry or feed, for\n              example a permalink to the html version of the entry, or the\n              front page of the weblog.\n            - *enclosure* a related resource which is potentially large in size\n              and might require special handling, for example an audio or video\n              recording.\n            - *related* an document related to the entry or feed.\n            - *self* the feed itself.\n            - *via* the source of the information provided in the entry.\n\n        - *type* indicates the media type of the resource.\n        - *hreflang* indicates the language of the referenced resource.\n        - *title* human readable information about the link, typically for\n          display purposes.\n        - *length* the length of the resource, in bytes.\n\n        RSS only supports one link with URL only.\n\n        :param link:    Dict or list of dicts with data.\n        :param replace: If old links are to be replaced (default: False)\n        :returns:       Current set of link data\n\n        Example::\n\n            >>> feedgen.link( href='http://example.com/', rel='self')\n            [{'href':'http://example.com/', 'rel':'self'}]\n\n        '''\n        if link is None and kwargs:\n            link = kwargs\n        if link is not None:\n            if replace or self.__atom_link is None:\n                self.__atom_link = []\n            self.__atom_link += ensure_format(\n                link,\n                set(['href', 'rel', 'type', 'hreflang', 'title', 'length']),\n                set(['href']),\n                {'rel': [\n                    'about', 'alternate', 'appendix', 'archives', 'author',\n                    'bookmark', 'canonical', 'chapter', 'collection',\n                    'contents', 'copyright', 'create-form', 'current',\n                    'derivedfrom', 'describedby', 'describes', 'disclosure',\n                    'duplicate', 'edit', 'edit-form', 'edit-media',\n                    'enclosure', 'first', 'glossary', 'help', 'hosts', 'hub',\n                    'icon', 'index', 'item', 'last', 'latest-version',\n                    'license', 'lrdd', 'memento', 'monitor', 'monitor-group',\n                    'next', 'next-archive', 'nofollow', 'noreferrer',\n                    'original', 'payment', 'predecessor-version', 'prefetch',\n                    'prev', 'preview', 'previous', 'prev-archive',\n                    'privacy-policy', 'profile', 'related', 'replies',\n                    'search', 'section', 'self', 'service', 'start',\n                    'stylesheet', 'subsection', 'successor-version', 'tag',\n                    'terms-of-service', 'timegate', 'timemap', 'type', 'up',\n                    'version-history', 'via', 'working-copy', 'working-copy-of'\n                    ]})\n            # RSS only needs one URL. We use the first link for RSS:\n            if len(self.__atom_link) > 0:\n                self.__rss_link = self.__atom_link[-1]['href']\n        # return the set with more information (atom)\n        return self.__atom_link\n\n    def category(self, category=None, replace=False, **kwargs):\n        '''Get or set categories that the feed belongs to.\n\n        This method can be called with:\n\n        - the fields of a category as keyword arguments\n        - the fields of a category as a dictionary\n        - a list of dictionaries containing the category fields\n\n        A categories has the following fields:\n\n        - *term* identifies the category\n        - *scheme* identifies the categorization scheme via a URI.\n        - *label* provides a human-readable label for display\n\n        If a label is present it is used for the RSS feeds. Otherwise the term\n        is used. The scheme is used for the domain attribute in RSS.\n\n        :param link:    Dict or list of dicts with data.\n        :param replace: Add or replace old data.\n        :returns: List of category data.\n        '''\n        if category is None and kwargs:\n            category = kwargs\n        if category is not None:\n            if replace or self.__atom_category is None:\n                self.__atom_category = []\n            self.__atom_category += ensure_format(\n                    category,\n                    set(['term', 'scheme', 'label']),\n                    set(['term']))\n            # Map the ATOM categories to RSS categories. Use the atom:label as\n            # name or if not present the atom:term. The atom:scheme is the\n            # rss:domain.\n            self.__rss_category = []\n            for cat in self.__atom_category:\n                rss_cat = {}\n                rss_cat['value'] = cat.get('label', cat['term'])\n                if cat.get('scheme'):\n                    rss_cat['domain'] = cat['scheme']\n                self.__rss_category.append(rss_cat)\n        return self.__atom_category\n\n    def cloud(self, domain=None, port=None, path=None, registerProcedure=None,\n              protocol=None):\n        '''Set or get the cloud data of the feed. It is an RSS only attribute.\n        It specifies a web service that supports the rssCloud interface which\n        can be implemented in HTTP-POST, XML-RPC or SOAP 1.1.\n\n        :param domain: The domain where the webservice can be found.\n        :param port: The port the webservice listens to.\n        :param path: The path of the webservice.\n        :param registerProcedure: The procedure to call.\n        :param protocol: Can be either HTTP-POST, XML-RPC or SOAP 1.1.\n        :returns: Dictionary containing the cloud data.\n        '''\n        if domain is not None:\n            self.__rss_cloud = {'domain': domain, 'port': port, 'path': path,\n                                'registerProcedure': registerProcedure,\n                                'protocol': protocol}\n        return self.__rss_cloud\n\n    def contributor(self, contributor=None, replace=False, **kwargs):\n        '''Get or set the contributor data of the feed. This is an ATOM only\n        value.\n\n        This method can be called with:\n        - the fields of an contributor as keyword arguments\n        - the fields of an contributor as a dictionary\n        - a list of dictionaries containing the contributor fields\n\n        An contributor has the following fields:\n        - *name* conveys a human-readable name for the person.\n        - *uri* contains a home page for the person.\n        - *email* contains an email address for the person.\n\n        :param contributor: Dictionary or list of dictionaries with contributor\n                            data.\n        :param replace: Add or replace old data.\n        :returns: List of contributors as dictionaries.\n        '''\n        if contributor is None and kwargs:\n            contributor = kwargs\n        if contributor is not None:\n            if replace or self.__atom_contributor is None:\n                self.__atom_contributor = []\n            self.__atom_contributor += ensure_format(\n                    contributor, set(['name', 'email', 'uri']), set(['name']))\n        return self.__atom_contributor\n\n    def generator(self, generator=None, version=None, uri=None):\n        '''Get or set the generator of the feed which identifies the software\n        used to generate the feed, for debugging and other purposes. Both the\n        uri and version attributes are optional and only available in the ATOM\n        feed.\n\n        :param generator: Software used to create the feed.\n        :param version: Version of the software.\n        :param uri: URI the software can be found.\n        '''\n        if generator is not None:\n            self.__atom_generator = {'value': generator}\n            if version is not None:\n                self.__atom_generator['version'] = version\n            if uri is not None:\n                self.__atom_generator['uri'] = uri\n            self.__rss_generator = generator\n        return self.__atom_generator\n\n    def icon(self, icon=None):\n        '''Get or set the icon of the feed which is a small image which\n        provides iconic visual identification for the feed. Icons should be\n        square. This is an ATOM only value.\n\n        :param icon: URI of the feeds icon.\n        :returns: URI of the feeds icon.\n        '''\n        if icon is not None:\n            self.__atom_icon = icon\n        return self.__atom_icon\n\n    def logo(self, logo=None):\n        '''Get or set the logo of the feed which is a larger image which\n        provides visual identification for the feed. Images should be twice as\n        wide as they are tall. This is an ATOM value but will also set the\n        rss:image value.\n\n        :param logo: Logo of the feed.\n        :returns: Logo of the feed.\n        '''\n        if logo is not None:\n            self.__atom_logo = logo\n            self.__rss_image = {'url': logo}\n        return self.__atom_logo\n\n    def image(self, url=None, title=None, link=None, width=None, height=None,\n              description=None):\n        '''Set the image of the feed. This element is roughly equivalent to\n        atom:logo.\n\n        :param url: The URL of a GIF, JPEG or PNG image.\n        :param title: Describes the image. The default value is the feeds\n                      title.\n        :param link: URL of the site the image will link to. The default is to\n                     use the feeds first altertate link.\n        :param width: Width of the image in pixel. The maximum is 144.\n        :param height: The height of the image. The maximum is 400.\n        :param description: Title of the link.\n        :returns: Data of the image as dictionary.\n        '''\n        if url is not None:\n            self.__rss_image = {'url': url}\n            if title is not None:\n                self.__rss_image['title'] = title\n            if link is not None:\n                self.__rss_image['link'] = link\n            if width:\n                self.__rss_image['width'] = width\n            if height:\n                self.__rss_image['height'] = height\n            self.__atom_logo = url\n        return self.__rss_image\n\n    def rights(self, rights=None):\n        '''Get or set the rights value of the feed which conveys information\n        about rights, e.g. copyrights, held in and over the feed. This ATOM\n        value will also set rss:copyright.\n\n        :param rights: Rights information of the feed.\n        '''\n        if rights is not None:\n            self.__atom_rights = rights\n            self.__rss_copyright = rights\n        return self.__atom_rights\n\n    def copyright(self, copyright=None):\n        '''Get or set the copyright notice for content in the channel. This RSS\n        value will also set the atom:rights value.\n\n        :param copyright: The copyright notice.\n        :returns: The copyright notice.\n        '''\n        return self.rights(copyright)\n\n    def subtitle(self, subtitle=None):\n        '''Get or set the subtitle value of the cannel which contains a\n        human-readable description or subtitle for the feed. This ATOM property\n        will also set the value for rss:description.\n\n        :param subtitle: The subtitle of the feed.\n        :returns: The subtitle of the feed.\n        '''\n        if subtitle is not None:\n            self.__atom_subtitle = subtitle\n            self.__rss_description = subtitle\n        return self.__atom_subtitle\n\n    def description(self, description=None):\n        '''Set and get the description of the feed. This is an RSS only element\n        which is a phrase or sentence describing the channel. It is mandatory\n        for RSS feeds. It is roughly the same as atom:subtitle. Thus setting\n        this will also set atom:subtitle.\n\n        :param description: Description of the channel.\n        :returns: Description of the channel.\n\n        '''\n        return self.subtitle(description)\n\n    def docs(self, docs=None):\n        '''Get or set the docs value of the feed. This is an RSS only value. It\n        is a URL that points to the documentation for the format used in the\n        RSS file. It is probably a pointer to [1]. It is for people who might\n        stumble across an RSS file on a Web server 25 years from now and wonder\n        what it is.\n\n        [1]: http://www.rssboard.org/rss-specification\n\n        :param docs: URL of the format documentation.\n        :returns: URL of the format documentation.\n        '''\n        if docs is not None:\n            self.__rss_docs = docs\n        return self.__rss_docs\n\n    def language(self, language=None):\n        '''Get or set the language of the feed. It indicates the language the\n        channel is written in. This allows aggregators to group all Italian\n        language sites, for example, on a single page. This is an RSS only\n        field.  However, this value will also be used to set the xml:lang\n        property of the ATOM feed node.\n        The value should be an IETF language tag.\n\n        :param language: Language of the feed.\n        :returns: Language of the feed.\n        '''\n        if language is not None:\n            self.__rss_language = language\n            self.__atom_feed_xml_lang = language\n        return self.__rss_language\n\n    def managingEditor(self, managingEditor=None):\n        '''Set or get the value for managingEditor which is the email address\n        for person responsible for editorial content.    This is a RSS only\n        value.\n\n        :param managingEditor: Email address of the managing editor.\n        :returns: Email address of the managing editor.\n        '''\n        if managingEditor is not None:\n            self.__rss_managingEditor = managingEditor\n        return self.__rss_managingEditor\n\n    def pubDate(self, pubDate=None):\n        '''Set or get the publication date for the content in the channel. For\n        example, the New York Times publishes on a daily basis, the publication\n        date flips once every 24 hours. That's when the pubDate of the channel\n        changes.\n\n        The value can either be a string which will automatically be parsed or\n        a datetime.datetime object. In any case it is necessary that the value\n        include timezone information.\n\n        This will set both atom:updated and rss:lastBuildDate.\n\n        :param pubDate: The publication date.\n        :returns: Publication date as datetime.datetime\n        '''\n        if pubDate is not None:\n            if isinstance(pubDate, string_types):\n                pubDate = dateutil.parser.parse(pubDate)\n            if not isinstance(pubDate, datetime):\n                raise ValueError('Invalid datetime format')\n            if pubDate.tzinfo is None:\n                raise ValueError('Datetime object has no timezone info')\n            self.__rss_pubDate = pubDate\n\n        return self.__rss_pubDate\n\n    def rating(self, rating=None):\n        '''Set and get the PICS rating for the channel.    It is an RSS only\n        value.\n        '''\n        if rating is not None:\n            self.__rss_rating = rating\n        return self.__rss_rating\n\n    def skipHours(self, hours=None, replace=False):\n        '''Set or get the value of skipHours, a hint for aggregators telling\n        them which hours they can skip. This is an RSS only value.\n\n        This method can be called with an hour or a list of hours. The hours\n        are represented as integer values from 0 to 23.\n\n        :param hours: List of hours the feedreaders should not check the feed.\n        :param replace: Add or replace old data.\n        :returns: List of hours the feedreaders should not check the feed.\n        '''\n        if hours is not None:\n            if not (isinstance(hours, list) or isinstance(hours, set)):\n                hours = [hours]\n            for h in hours:\n                if h not in range(24):\n                    raise ValueError('Invalid hour %s' % h)\n            if replace or not self.__rss_skipHours:\n                self.__rss_skipHours = set()\n            self.__rss_skipHours |= set(hours)\n        return self.__rss_skipHours\n\n    def skipDays(self, days=None, replace=False):\n        '''Set or get the value of skipDays, a hint for aggregators telling\n        them which days they can skip This is an RSS only value.\n\n        This method can be called with a day name or a list of day names. The\n        days are represented as strings from 'Monday' to 'Sunday'.\n\n        :param hours:   List of days the feedreaders should not check the feed.\n        :param replace: Add or replace old data.\n        :returns:       List of days the feedreaders should not check the feed.\n        '''\n        if days is not None:\n            if not (isinstance(days, list) or isinstance(days, set)):\n                days = [days]\n            for d in days:\n                if d not in ['Monday', 'Tuesday', 'Wednesday', 'Thursday',\n                             'Friday', 'Saturday', 'Sunday']:\n                    raise ValueError('Invalid day %s' % d)\n            if replace or not self.__rss_skipDays:\n                self.__rss_skipDays = set()\n            self.__rss_skipDays |= set(days)\n        return self.__rss_skipDays\n\n    def textInput(self, title=None, description=None, name=None, link=None):\n        '''Get or set the value of textInput. This is an RSS only field.  The\n        purpose of the <textInput> element is something of a mystery. You can\n        use it to specify a search engine box. Or to allow a reader to provide\n        feedback. Most aggregators ignore it.\n\n        :param title: The label of the Submit button in the text input area.\n        :param description: Explains the text input area.\n        :param name: The name of the text object in the text input area.\n        :param link: The URL of the CGI script that processes text input\n                     requests.\n        :returns: Dictionary containing textInput values.\n        '''\n        if title is not None:\n            self.__rss_textInput = {}\n            self.__rss_textInput['title'] = title\n            self.__rss_textInput['description'] = description\n            self.__rss_textInput['name'] = name\n            self.__rss_textInput['link'] = link\n        return self.__rss_textInput\n\n    def ttl(self, ttl=None):\n        '''Get or set the ttl value. It is an RSS only element. ttl stands for\n        time to live. It's a number of minutes that indicates how long a\n        channel can be cached before refreshing from the source.\n\n        :param ttl: Integer value indicating how long the channel may be\n                    cached.\n        :returns: Time to live.\n        '''\n        if ttl is not None:\n            self.__rss_ttl = int(ttl)\n        return self.__rss_ttl\n\n    def webMaster(self, webMaster=None):\n        '''Get and set the value of webMaster, which represents the email\n        address for the person responsible for technical issues relating to the\n        feed.  This is an RSS only value.\n\n        :param webMaster: Email address of the webmaster.\n        :returns: Email address of the webmaster.\n        '''\n        if webMaster is not None:\n            self.__rss_webMaster = webMaster\n        return self.__rss_webMaster\n\n    def add_entry(self, feedEntry=None, order='prepend'):\n        '''This method will add a new entry to the feed. If the feedEntry\n        argument is omittet a new Entry object is created automatically. This\n        is the preferred way to add new entries to a feed.\n\n        :param feedEntry: FeedEntry object to add.\n        :param order: If `prepend` is chosen, the entry will be inserted\n                      at the beginning of the feed. If `append` is chosen,\n                      the entry will be appended to the feed.\n                      (default: `prepend`).\n        :returns: FeedEntry object created or passed to this function.\n\n        Example::\n\n            ...\n            >>> entry = feedgen.add_entry()\n            >>> entry.title('First feed entry')\n\n        '''\n        if feedEntry is None:\n            feedEntry = FeedEntry()\n\n        version = sys.version_info[0]\n\n        if version == 2:\n            items = self.__extensions.iteritems()\n        else:\n            items = self.__extensions.items()\n\n        # Try to load extensions:\n        for extname, ext in items:\n            try:\n                feedEntry.register_extension(extname,\n                                             ext['extension_class_entry'],\n                                             ext['atom'],\n                                             ext['rss'])\n            except ImportError:\n                pass\n\n        if order == 'prepend':\n            self.__feed_entries.insert(0, feedEntry)\n        else:\n            self.__feed_entries.append(feedEntry)\n        return feedEntry\n\n    def add_item(self, item=None):\n        '''This method will add a new item to the feed. If the item argument is\n        omittet a new FeedEntry object is created automatically. This is just\n        another name for add_entry(...)\n        '''\n        return self.add_entry(item)\n\n    def entry(self, entry=None, replace=False):\n        '''Get or set feed entries. Use the add_entry() method instead to\n        automatically create the FeedEntry objects.\n\n        This method takes both a single FeedEntry object or a list of objects.\n\n        :param entry: FeedEntry object or list of FeedEntry objects.\n        :returns: List ob all feed entries.\n        '''\n        if entry is not None:\n            if not isinstance(entry, list):\n                entry = [entry]\n            if replace:\n                self.__feed_entries = []\n\n            version = sys.version_info[0]\n\n            if version == 2:\n                items = self.__extensions.iteritems()\n            else:\n                items = self.__extensions.items()\n\n            # Try to load extensions:\n            for e in entry:\n                for extname, ext in items:\n                    try:\n                        e.register_extension(extname,\n                                             ext['extension_class_entry'],\n                                             ext['atom'], ext['rss'])\n                    except ImportError:\n                        pass\n\n            self.__feed_entries += entry\n        return self.__feed_entries\n\n    def item(self, item=None, replace=False):\n        '''Get or set feed items. This is just another name for entry(...)\n        '''\n        return self.entry(item, replace)\n\n    def remove_entry(self, entry):\n        '''Remove a single entry from the feed. This method accepts both the\n        FeedEntry object to remove or the index of the entry as argument.\n\n        :param entry: Entry or index of entry to remove.\n        '''\n        if isinstance(entry, FeedEntry):\n            self.__feed_entries.remove(entry)\n        else:\n            self.__feed_entries.pop(entry)\n\n    def remove_item(self, item):\n        '''Remove a single item from the feed. This is another name for\n        remove_entry.\n        '''\n        self.remove_entry(item)\n\n    def load_extension(self, name, atom=True, rss=True):\n        '''Load a specific extension by name.\n\n        :param name: Name of the extension to load.\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if name in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n\n        # Load extension\n        extname = name[0].upper() + name[1:]\n        feedsupmod = __import__('feedgen.ext.%s' % name)\n        feedextmod = getattr(feedsupmod.ext, name)\n        try:\n            entrysupmod = __import__('feedgen.ext.%s_entry' % name)\n            entryextmod = getattr(entrysupmod.ext, name + '_entry')\n        except ImportError:\n            # Use FeedExtension module instead\n            entrysupmod = feedsupmod\n            entryextmod = feedextmod\n        feedext = getattr(feedextmod, extname + 'Extension')\n        try:\n            entryext = getattr(entryextmod, extname + 'EntryExtension')\n        except AttributeError:\n            entryext = None\n        self.register_extension(name, feedext, entryext, atom, rss)\n\n    def register_extension(self, namespace, extension_class_feed=None,\n                           extension_class_entry=None, atom=True, rss=True):\n        '''Registers an extension by class.\n\n        :param namespace: namespace for the extension\n        :param extension_class_feed: Class of the feed extension to load.\n        :param extension_class_entry: Class of the entry extension to load\n        :param atom: If the extension should be used for ATOM feeds.\n        :param rss: If the extension should be used for RSS feeds.\n        '''\n        # Check loaded extensions\n        # `load_extension` ignores the \"Extension\" suffix.\n        if not isinstance(self.__extensions, dict):\n            self.__extensions = {}\n        if namespace in self.__extensions.keys():\n            raise ImportError('Extension already loaded')\n\n        # Load extension\n        extinst = extension_class_feed()\n        setattr(self, namespace, extinst)\n\n        # `load_extension` registry\n        self.__extensions[namespace] = {\n                'inst': extinst,\n                'extension_class_feed': extension_class_feed,\n                'extension_class_entry': extension_class_entry,\n                'atom': atom,\n                'rss': rss\n                }\n\n        # Try to load the extension for already existing entries:\n        for entry in self.__feed_entries:\n            try:\n                entry.register_extension(namespace,\n                                         extension_class_entry,\n                                         atom,\n                                         rss)\n            except ImportError:\n                pass\n", "# -*- coding: utf-8 -*-\n'''\n    feedgen.util\n    ~~~~~~~~~~~~\n\n    This file contains helper functions for the feed generator module.\n\n    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>\n    :license: FreeBSD and LGPL, see license.* for more details.\n'''\nimport locale\nimport sys\nimport lxml  # nosec - we configure a safe parser below\n\n# Configure a safe parser which does not allow XML entity expansion\nparser = lxml.etree.XMLParser(\n        attribute_defaults=False,\n        dtd_validation=False,\n        load_dtd=False,\n        no_network=True,\n        recover=False,\n        remove_pis=True,\n        resolve_entities=False,\n        huge_tree=False)\n\n\ndef xml_fromstring(xmlstring):\n    return lxml.etree.fromstring(xmlstring, parser)  # nosec - safe parser\n\n\ndef xml_elem(name, parent=None, **kwargs):\n    if parent is not None:\n        return lxml.etree.SubElement(parent, name, **kwargs)\n    return lxml.etree.Element(name, **kwargs)\n\n\ndef ensure_format(val, allowed, required, allowed_values=None, defaults=None):\n    '''Takes a dictionary or a list of dictionaries and check if all keys are in\n    the set of allowed keys, if all required keys are present and if the values\n    of a specific key are ok.\n\n    :param val:            Dictionaries to check.\n    :param allowed:        Set of allowed keys.\n    :param required:       Set of required keys.\n    :param allowed_values: Dictionary with keys and sets of their allowed\n                           values.\n    :param defaults:       Dictionary with default values.\n    :returns:              List of checked dictionaries.\n    '''\n    if not val:\n        return []\n    if allowed_values is None:\n        allowed_values = {}\n    if defaults is None:\n        defaults = {}\n    # Make shure that we have a list of dicts. Even if there is only one.\n    if not isinstance(val, list):\n        val = [val]\n    for elem in val:\n        if not isinstance(elem, dict):\n            raise ValueError('Invalid data (value is no dictionary)')\n        # Set default values\n\n        version = sys.version_info[0]\n\n        if version == 2:\n            items = defaults.iteritems()\n        else:\n            items = defaults.items()\n\n        for k, v in items:\n            elem[k] = elem.get(k, v)\n        if not set(elem.keys()) <= allowed:\n            raise ValueError('Data contains invalid keys')\n        if not set(elem.keys()) >= required:\n            raise ValueError('Data contains not all required keys')\n\n        if version == 2:\n            values = allowed_values.iteritems()\n        else:\n            values = allowed_values.items()\n\n        for k, v in values:\n            if elem.get(k) and not elem[k] in v:\n                raise ValueError('Invalid value for %s' % k)\n    return val\n\n\ndef formatRFC2822(date):\n    '''Make sure the locale setting do not interfere with the time format.\n    '''\n    old = locale.setlocale(locale.LC_ALL)\n    locale.setlocale(locale.LC_ALL, 'C')\n    date = date.strftime('%a, %d %b %Y %H:%M:%S %z')\n    locale.setlocale(locale.LC_ALL, old)\n    return date\n"], "filenames": ["feedgen/entry.py", "feedgen/ext/dc.py", "feedgen/ext/geo_entry.py", "feedgen/ext/media.py", "feedgen/ext/podcast.py", "feedgen/ext/podcast_entry.py", "feedgen/ext/syndication.py", "feedgen/ext/torrent.py", "feedgen/feed.py", "feedgen/util.py"], "buggy_code_start_loc": [6, 16, 15, 13, 13, 13, 13, 13, 6, 12], "buggy_code_end_loc": [257, 63, 132, 66, 102, 80, 24, 68, 367, 12], "fixing_code_start_loc": [6, 15, 14, 12, 12, 12, 12, 12, 6, 13], "fixing_code_end_loc": [254, 62, 126, 64, 97, 79, 23, 66, 366, 35], "type": "CWE-776", "message": "Feedgen (python feedgen) before 0.9.0 is susceptible to XML Denial of Service attacks. The *feedgen* library allows supplying XML as content for some of the available fields. This XML will be parsed and integrated into the existing XML tree. During this process, feedgen is vulnerable to XML Denial of Service Attacks (e.g. XML Bomb). This becomes a concern in particular if feedgen is used to include content from untrused sources and if XML (including XHTML) is directly included instead of providing plain tex content only. This problem has been fixed in feedgen 0.9.0 which disallows XML entity expansion and external resources.", "other": {"cve": {"id": "CVE-2020-5227", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-28T23:15:12.670", "lastModified": "2020-02-08T04:15:12.200", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Feedgen (python feedgen) before 0.9.0 is susceptible to XML Denial of Service attacks. The *feedgen* library allows supplying XML as content for some of the available fields. This XML will be parsed and integrated into the existing XML tree. During this process, feedgen is vulnerable to XML Denial of Service Attacks (e.g. XML Bomb). This becomes a concern in particular if feedgen is used to include content from untrused sources and if XML (including XHTML) is directly included instead of providing plain tex content only. This problem has been fixed in feedgen 0.9.0 which disallows XML entity expansion and external resources."}, {"lang": "es", "value": "Feedgen (python feedgen) versiones anteriores a 0.9.0, es susceptible a ataques de Denegaci\u00f3n de Servicio XML. La biblioteca *feedgen* permite suministrar XML como contenido para algunos de los campos disponibles. Este XML ser\u00e1 analizado e integrado en el \u00e1rbol XML existente. Durante este proceso, feedgen es vulnerable a Ataques de Denegaci\u00f3n de Servicio XML (por ejemplo, XML Bomb). Esto se convierte en una preocupaci\u00f3n en particular si feedgen es usado para incluir contenido desde fuentes no confiables y si XML (incluido XHTML) es incluido directamente en lugar de proporcionar solo contenido de texto plano. Este problema ha sido corregido en feedgen versi\u00f3n 0.9.0 que no permite la expansi\u00f3n de entidades XML y recursos externos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-776"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-776"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:feedgen_project:feedgen:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "54684C43-EF38-4002-9E06-01FAEAD0B137"}]}]}], "references": [{"url": "https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/november/xml-denial-of-service-attacks-and-defenses", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory", "Vendor Advisory"]}, {"url": "https://github.com/lkiesow/python-feedgen/commit/f57a01b20fa4aaaeccfa417f28e66b4084b9d0cf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/lkiesow/python-feedgen/security/advisories/GHSA-g8q7-xv52-hf9f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/T6I5ENUYGFNMIH6ZQ62FZ6VU2WD3SIOI/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/lkiesow/python-feedgen/commit/f57a01b20fa4aaaeccfa417f28e66b4084b9d0cf"}}