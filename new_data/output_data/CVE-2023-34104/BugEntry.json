{"buggy_code": ["const {XMLParser, XMLBuilder} = require(\"../src/fxp\");\n\ndescribe(\"XMLParser Entities\", function() {\n\n    it(\"should parse attributes with valid names, default entities\", function() {\n        const xmlData = `<a:root xmlns:a=\"urn:none\" xmlns:a-b=\"urn:none\">\n        <a:a attr=\"2foo&ampbar&apos;\">1</a:a>\n        <a:b>2</a:b>\n        <a-b:b-a>2</a-b:b-a>\n        <a:c>test&amp;\\r\\n\u0442\u0435\u0441\u0442&lt;\\r\\ntest</a:c>\n        <a:el><![CDATA[<a>&lt;<a/>&lt;b&gt;2</b>]]]]>\\r\\n<![CDATA[]]]]><![CDATA[>&amp;]]>a</a:el>\n        <c:string lang=\"ru\">\\\n    &#x441;&#x442;&#x440;&#x430;&#x445;&#x43e;&#x432;&#x430;&#x43d;&#x438;&#x44f;\\\n    \u00bb &#x43e;&#x442; &#x441;&#x443;&#x43c;&#x43c;&#x44b; \\\n    &#x435;&#x433;&#x43e; &#x430;&#x43a;&#x442;&#x438;&#x432;&#x43e;&#x432;\\\n    </c:string>\n    </a:root>`;\n\n        const expected = {\n            \"a:root\": {\n                \"@_xmlns:a\": \"urn:none\",\n                \"@_xmlns:a-b\": \"urn:none\",\n                \"a:a\": {\n                    \"#text\": 1,\n                    \"@_attr\": \"2foo&ampbar'\"\n                },\n                \"a:b\": 2,\n                \"a-b:b-a\": 2,\n                \"a:c\": \"test&\\n\u0442\u0435\u0441\u0442<\\ntest\",\n                \"a:el\": \"<a><<a/><b>2</b>]]]]>&a\",\n                \"c:string\": {\n                    \"#text\": \"&#x441;&#x442;&#x440;&#x430;&#x445;&#x43e;&#x432;&#x430;&#x43d;&#x438;&#x44f;    \u00bb &#x43e;&#x442; &#x441;&#x443;&#x43c;&#x43c;&#x44b;     &#x435;&#x433;&#x43e; &#x430;&#x43a;&#x442;&#x438;&#x432;&#x43e;&#x432;\",\n                    \"@_lang\": \"ru\"\n                }\n            }\n        };\n\n        const options = {\n            allowBooleanAttributes: true,\n            ignoreAttributes:    false,\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData, true);\n\n        //console.log(JSON.stringify(result,null,4));\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should parse XML with DOCTYPE without internal DTD\", function() {\n        const xmlData = \"<?xml version='1.0' standalone='no'?><!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\" ><svg><metadata>test</metadata></svg>\";\n        const expected = {\n            \"?xml\": {\n                \"@_version\": \"1.0\",\n                \"@_standalone\": \"no\"\n            },\n            \"svg\" : {\n                \"metadata\": \"test\"\n            }\n        };\n\n        const options = {\n            allowBooleanAttributes: true,\n            ignoreAttributes:    false,\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData, true);\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should parse XML with DOCTYPE without internal DTD\", function() {\n        const xmlData = `<?xml version='1.0' standalone='no'?>\n        <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >\n        <svg>\n            <metadata>[test]</metadata>\n        </svg>`;\n        const expected = {\n            \"?xml\": {\n                \"@_version\": \"1.0\",\n                \"@_standalone\": \"no\"\n            },\n            \"svg\" : {\n                \"metadata\": \"[test]\"\n            }\n        };\n\n        const options = {\n            allowBooleanAttributes: true,\n            ignoreAttributes:    false,\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData, true);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should error for when any tag is left to close\", function(){\n        const xmlData = `<?xml version=\"1.0\"?><!DOCTYPE `;\n        expect(() =>{\n            const parser = new XMLParser();\n            parser.parse(xmlData);\n        }).toThrowError(\"Unclosed DOCTYPE\")\n    })\n\n    it(\"should parse XML with DOCTYPE\", function() {\n        const xmlData = \"<?xml version=\\\"1.0\\\" standalone=\\\"yes\\\" ?>\" +\n            \"<!--open the DOCTYPE declaration -\" +\n            \"  the open square bracket indicates an internal DTD-->\" +\n            \"<!DOCTYPE foo [\" +\n            \"<!--define the internal DTD-->\" +\n            \"<!ELEMENT foo (#PCDATA)>\" +\n            \"<!--close the DOCTYPE declaration-->\" +\n            \"]>\" +\n            \"<foo>Hello World.</foo>\";\n\n        const expected = {\n            \"?xml\": \"\",\n            foo: \"Hello World.\"\n        };\n        \n        const options = {\n\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        //console.log(JSON.stringify(result,null,4));\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should not throw error when DTD comments contain '<' or '>'\", function() {\n        const xmlData = `<!DOCTYPE greeting [<!-- < > < -->]>`;\n\n        const parser = new XMLParser();\n        parser.parse(xmlData);\n    });\n\n    it(\"should parse attributes having '>' in value\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nbsp \"&#xA0;\">\n        <!ENTITY writer \"Writer: Donald Duck.\">\n        <!ENTITY copyright \"Copyright: W3Schools.\">\n        ]>\n        \n        <note>\n            <to>Tove</to>\n            <from>Jani</from>\n            <heading>Reminder</heading>\n            <body attr=\"&writer;\">Don't forget me this weekend!</body>\n            <footer>&writer;&nbsp;&copyright;</footer>\n        </note> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"UTF-8\"\n            },\n            \"note\": {\n                \"to\": \"Tove\",\n                \"from\": \"Jani\",\n                \"heading\": \"Reminder\",\n                \"body\": {\n                    \"#text\": \"Don't forget me this weekend!\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n                \"footer\": \"Writer: Donald Duck.&nbsp;Copyright: W3Schools.\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n    it(\"should parse dynamic entity\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nbsp \"writer;\">\n        <!ENTITY writer \"Writer: Donald Duck.\">\n        <!ENTITY copyright \"Copyright: W3Schools.\">\n        ]>\n        \n        <note>\n            <heading>Reminder</heading>\n            <body attr=\"&writer;\">Don't forget me this weekend!</body>\n            <footer>&writer;&&nbsp;&copyright;</footer>\n        </note> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"UTF-8\"\n            },\n            \"note\": {\n                \"heading\": \"Reminder\",\n                \"body\": {\n                    \"#text\": \"Don't forget me this weekend!\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n                \"footer\": \"Writer: Donald Duck.Writer: Donald Duck.Copyright: W3Schools.\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should allow !ATTLIST & !NOTATION\", function() {\n        const xmlData = `<?xml version=\"1.0\"?>\n        <!DOCTYPE code [\n          <!ELEMENT code (#PCDATA)>\n          <!NOTATION vrml PUBLIC \"VRML 1.0\">\n          <!ATTLIST code lang NOTATION (vrml) #REQUIRED>\n        ]>\n        <code lang=\"vrml\">Some VRML instructions</code>`;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\"\n            },\n            \"code\": {\n                \"lang\": 'vrml',\n                \"#text\": 'Some VRML instructions'\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should build by decoding defaul entities\", function() {\n        const jsObj = {\n            \"note\": {\n                \"@heading\": \"Reminder > \\\"Alert\",\n                \"body\": {\n                    \"#text\": \" 3 < 4\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n            }\n        };\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n             3 &lt; 4\n             <attr>Writer: Donald Duck.</attr>\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n            // processEntities: true\n        };\n        const builder = new XMLBuilder(options);\n        const result = builder.build(jsObj);\n        expect(result.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n    it(\"should build by decoding defaul entities in prserve mode\", function() {\n        const jsObj = [\n            {\n                \"note\": [\n                    {\n                        \"body\": [\n                            {\n                                \"#text\": \"3 < 4\"\n                            },\n                            {\n                                \"attr\": [\n                                    {\n                                        \"#text\": \"Writer: Donald Duck.\"\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ],\n                \":@\": {\n                    \"@heading\": \"Reminder > \\\"Alert\"\n                }\n            }\n        ];\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n             3 &lt; 4\n             <attr>Writer: Donald Duck.</attr>\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n            preserveOrder: true,\n            // processEntities: false\n        };\n\n        const parser = new XMLParser(options);\n        let result = parser.parse(expected);\n        // console.log(JSON.stringify(result,null,4));\n\n        const builder = new XMLBuilder(options);\n        result = builder.build(jsObj);\n        // console.log(result);\n        expect(result.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n\n    it(\"should parse HTML entities when htmlEntities:true\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nbsp \"writer;\">\n        <!ENTITY writer \"Writer: Donald Duck.\">\n        <!ENTITY copyright \"Copyright: W3Schools.\">\n        ]>\n        \n        <note>\n            <heading>Reminder</heading>\n            <body attr=\"&writer;\">Don't forget me this weekend!&reg;</body>\n            <footer>&writer;&&nbsp;&copyright;&inr;</footer>\n        </note> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"UTF-8\"\n            },\n            \"note\": {\n                \"heading\": \"Reminder\",\n                \"body\": {\n                    \"#text\": \"Don't forget me this weekend!\u00ae\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n                \"footer\": \"Writer: Donald Duck.Writer: Donald Duck.Copyright: W3Schools.\u20b9\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true,\n            htmlEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n});\n\ndescribe(\"XMLParser External Entites\", function() {\n    it(\"should throw error when an entity value has '&'\", function() {\n        const parser = new XMLParser();\n        expect( () => {\n            parser.addEntity(\"#xD\", \"&\\r\");\n        }).toThrowError(\"Entity value can't have '&'\");\n    });\n\n    it(\"should throw error when an entity identifier has '&'\", function() {\n        const parser = new XMLParser();\n        expect( () => {\n            parser.addEntity(\"&#xD\", \"\\r\");\n        }).toThrowError(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n    });\n    \n    it(\"should throw error when an entity identifier has ';'\", function() {\n        const parser = new XMLParser();\n        expect( () => {\n            parser.addEntity(\"#xD;\", \"\\r\");\n        }).toThrowError(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n    });\n    \n    it(\"should set and parse for valid entity set externally\", function() {\n        const xmlData = `<note>&unknown;&#xD;last</note> `;\n\n        const parser = new XMLParser();\n        parser.addEntity(\"#xD\", \"\\r\\n\");\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result.note).toEqual(`&unknown;\\r\\nlast`);\n    });\n    \n    it(\"External Entity can change the behaviour of default entites\", function() {\n        const xmlData = `<note>&gt;last</note> `;\n\n        const parser = new XMLParser();\n        parser.addEntity(\"gt\", \"<>\");\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result.note).toEqual(`<>last`);\n    });\n    \n    it(\"Same external Entity can be set by multiple times\", function() {\n        const xmlData = `<note>&gt;last</note> `;\n\n        const parser = new XMLParser();\n        parser.addEntity(\"gt\", \"<>\");\n        parser.addEntity(\"gt\", \"><\");\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result.note).toEqual(`><last`);\n    });\n    it(\"should build by decoding '&' prserve mode\", function() {\n        const jsObj = [\n            {\n                \"note\": [\n                    {\n                        \"body\": [\n                            { \"#text\": \"(3 & 4) < 5\" },\n                            { \"attr\": [ { \"#text\": \"Writer: Donald Duck.\" } ] }\n                        ]\n                    }\n                ],\n                \":@\": {\n                    \"@heading\": \"Reminder > \\\"Alert\"\n                }\n            }\n        ];\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n             (3 &amp; 4) &lt; 5\n             <attr>Writer: Donald Duck.</attr>\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n            preserveOrder: true,\n            // processEntities: false\n        };\n\n        const parser = new XMLParser(options);\n        let result = parser.parse(expected);\n        // console.log(JSON.stringify(result,null,4));\n\n        const builder = new XMLBuilder(options);\n        result = builder.build(jsObj);\n        // console.log(result);\n        expect(result.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n    it(\"should build by decoding '&'\", function() {\n        const jsObj = {\n            \"note\": {\n                \"body\": {\n                    \"attr\": \"Writer: Donald Duck.\",\n                    \"#text\": \"(3 & 4) < 5\"\n                },\n                \"@heading\": \"Reminder > \\\"Alert\"\n            }\n        };\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n            <attr>Writer: Donald Duck.</attr>\n             (3 &amp; 4) &lt; 5\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n        };\n\n        const parser = new XMLParser(options);\n        let result = parser.parse(expected);\n        // console.log(JSON.stringify(result,null,4));\n        // expect(expected).toEqual(jsObj);\n\n        const builder = new XMLBuilder(options);\n        const output = builder.build(jsObj);\n        // console.log(output);\n        expect(output.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n\n    it(\"should replace '&amp;lt;' with '&lt;'\", function() {\n        const xmlData = `<SimpleScalarPropertiesInputOutput>\n        <stringValue>&amp;lt;</stringValue>\n      </SimpleScalarPropertiesInputOutput>`;\n\n        const expected = {\n            \"SimpleScalarPropertiesInputOutput\": {\n              \"stringValue\": \"&lt;\"\n            }\n          };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true,\n            // preserveOrder: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        //console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n    \n    it(\"should support entites with tags in content\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [ \n\t<!ENTITY Smile \" \n    \t<rect x='.5' y='.5' width='29' height='39' fill='black' stroke='red'/>\n\t\t<g transform='translate(0, 5)'> \n\t\t\t<circle cx='15' cy='15' r='10' fill='yellow'/>\n\t\t\t<circle cx='12' cy='12' r='1.5' fill='black'/>\n\t\t\t<circle cx='17' cy='12' r='1.5' fill='black'/>\n\t\t\t<path d='M 10 19 L 15 23 20 19' stroke='black' stroke-width='2'/></g>\"\n\t> \n]>\n<svg width=\"850px\" height=\"700px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<g transform=\"matrix(16,0,0,16,0,0)\">&Smile;</g></svg> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"utf-8\"\n            },\n            \"svg\": {\n                \"g\": {\n                    \"#text\": \" \\n    \\t<rect x='.5' y='.5' width='29' height='39' fill='black' stroke='red'/>\\n\\t\\t<g transform='translate(0, 5)'> \\n\\t\\t\\t<circle cx='15' cy='15' r='10' fill='yellow'/>\\n\\t\\t\\t<circle cx='12' cy='12' r='1.5' fill='black'/>\\n\\t\\t\\t<circle cx='17' cy='12' r='1.5' fill='black'/>\\n\\t\\t\\t<path d='M 10 19 L 15 23 20 19' stroke='black' stroke-width='2'/></g>\",\n                    \"transform\": \"matrix(16,0,0,16,0,0)\"\n                },\n                \"width\": \"850px\",\n                \"height\": \"700px\",\n                \"version\": \"1.1\",\n                \"xmlns\": \"http://www.w3.org/2000/svg\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true,\n            // preserveOrder: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n});\n", "//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ entityName ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nmodule.exports = readDocType;"], "fixing_code": ["const {XMLParser, XMLBuilder} = require(\"../src/fxp\");\n\ndescribe(\"XMLParser Entities\", function() {\n\n    it(\"should parse attributes with valid names, default entities\", function() {\n        const xmlData = `<a:root xmlns:a=\"urn:none\" xmlns:a-b=\"urn:none\">\n        <a:a attr=\"2foo&ampbar&apos;\">1</a:a>\n        <a:b>2</a:b>\n        <a-b:b-a>2</a-b:b-a>\n        <a:c>test&amp;\\r\\n\u0442\u0435\u0441\u0442&lt;\\r\\ntest</a:c>\n        <a:el><![CDATA[<a>&lt;<a/>&lt;b&gt;2</b>]]]]>\\r\\n<![CDATA[]]]]><![CDATA[>&amp;]]>a</a:el>\n        <c:string lang=\"ru\">\\\n    &#x441;&#x442;&#x440;&#x430;&#x445;&#x43e;&#x432;&#x430;&#x43d;&#x438;&#x44f;\\\n    \u00bb &#x43e;&#x442; &#x441;&#x443;&#x43c;&#x43c;&#x44b; \\\n    &#x435;&#x433;&#x43e; &#x430;&#x43a;&#x442;&#x438;&#x432;&#x43e;&#x432;\\\n    </c:string>\n    </a:root>`;\n\n        const expected = {\n            \"a:root\": {\n                \"@_xmlns:a\": \"urn:none\",\n                \"@_xmlns:a-b\": \"urn:none\",\n                \"a:a\": {\n                    \"#text\": 1,\n                    \"@_attr\": \"2foo&ampbar'\"\n                },\n                \"a:b\": 2,\n                \"a-b:b-a\": 2,\n                \"a:c\": \"test&\\n\u0442\u0435\u0441\u0442<\\ntest\",\n                \"a:el\": \"<a><<a/><b>2</b>]]]]>&a\",\n                \"c:string\": {\n                    \"#text\": \"&#x441;&#x442;&#x440;&#x430;&#x445;&#x43e;&#x432;&#x430;&#x43d;&#x438;&#x44f;    \u00bb &#x43e;&#x442; &#x441;&#x443;&#x43c;&#x43c;&#x44b;     &#x435;&#x433;&#x43e; &#x430;&#x43a;&#x442;&#x438;&#x432;&#x43e;&#x432;\",\n                    \"@_lang\": \"ru\"\n                }\n            }\n        };\n\n        const options = {\n            allowBooleanAttributes: true,\n            ignoreAttributes:    false,\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData, true);\n\n        //console.log(JSON.stringify(result,null,4));\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should parse XML with DOCTYPE without internal DTD\", function() {\n        const xmlData = \"<?xml version='1.0' standalone='no'?><!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\" ><svg><metadata>test</metadata></svg>\";\n        const expected = {\n            \"?xml\": {\n                \"@_version\": \"1.0\",\n                \"@_standalone\": \"no\"\n            },\n            \"svg\" : {\n                \"metadata\": \"test\"\n            }\n        };\n\n        const options = {\n            allowBooleanAttributes: true,\n            ignoreAttributes:    false,\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData, true);\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should parse XML with DOCTYPE without internal DTD\", function() {\n        const xmlData = `<?xml version='1.0' standalone='no'?>\n        <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >\n        <svg>\n            <metadata>[test]</metadata>\n        </svg>`;\n        const expected = {\n            \"?xml\": {\n                \"@_version\": \"1.0\",\n                \"@_standalone\": \"no\"\n            },\n            \"svg\" : {\n                \"metadata\": \"[test]\"\n            }\n        };\n\n        const options = {\n            allowBooleanAttributes: true,\n            ignoreAttributes:    false,\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData, true);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should error for when any tag is left to close\", function(){\n        const xmlData = `<?xml version=\"1.0\"?><!DOCTYPE `;\n        expect(() =>{\n            const parser = new XMLParser();\n            parser.parse(xmlData);\n        }).toThrowError(\"Unclosed DOCTYPE\")\n    })\n\n    it(\"should parse XML with DOCTYPE\", function() {\n        const xmlData = \"<?xml version=\\\"1.0\\\" standalone=\\\"yes\\\" ?>\" +\n            \"<!--open the DOCTYPE declaration -\" +\n            \"  the open square bracket indicates an internal DTD-->\" +\n            \"<!DOCTYPE foo [\" +\n            \"<!--define the internal DTD-->\" +\n            \"<!ELEMENT foo (#PCDATA)>\" +\n            \"<!--close the DOCTYPE declaration-->\" +\n            \"]>\" +\n            \"<foo>Hello World.</foo>\";\n\n        const expected = {\n            \"?xml\": \"\",\n            foo: \"Hello World.\"\n        };\n        \n        const options = {\n\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        //console.log(JSON.stringify(result,null,4));\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should not throw error when DTD comments contain '<' or '>'\", function() {\n        const xmlData = `<!DOCTYPE greeting [<!-- < > < -->]>`;\n\n        const parser = new XMLParser();\n        parser.parse(xmlData);\n    });\n\n    it(\"should parse attributes having '>' in value\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nbsp \"&#xA0;\">\n        <!ENTITY writer \"Writer: Donald Duck.\">\n        <!ENTITY copyright \"Copyright: W3Schools.\">\n        ]>\n        \n        <note>\n            <to>Tove</to>\n            <from>Jani</from>\n            <heading>Reminder</heading>\n            <body attr=\"&writer;\">Don't forget me this weekend!</body>\n            <footer>&writer;&nbsp;&copyright;</footer>\n        </note> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"UTF-8\"\n            },\n            \"note\": {\n                \"to\": \"Tove\",\n                \"from\": \"Jani\",\n                \"heading\": \"Reminder\",\n                \"body\": {\n                    \"#text\": \"Don't forget me this weekend!\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n                \"footer\": \"Writer: Donald Duck.&nbsp;Copyright: W3Schools.\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n    it(\"should parse dynamic entity\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nbsp \"writer;\">\n        <!ENTITY writer \"Writer: Donald Duck.\">\n        <!ENTITY copyright \"Copyright: W3Schools.\">\n        ]>\n        \n        <note>\n            <heading>Reminder</heading>\n            <body attr=\"&writer;\">Don't forget me this weekend!</body>\n            <footer>&writer;&&nbsp;&copyright;</footer>\n        </note> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"UTF-8\"\n            },\n            \"note\": {\n                \"heading\": \"Reminder\",\n                \"body\": {\n                    \"#text\": \"Don't forget me this weekend!\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n                \"footer\": \"Writer: Donald Duck.Writer: Donald Duck.Copyright: W3Schools.\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should allow !ATTLIST & !NOTATION\", function() {\n        const xmlData = `<?xml version=\"1.0\"?>\n        <!DOCTYPE code [\n          <!ELEMENT code (#PCDATA)>\n          <!NOTATION vrml PUBLIC \"VRML 1.0\">\n          <!ATTLIST code lang NOTATION (vrml) #REQUIRED>\n        ]>\n        <code lang=\"vrml\">Some VRML instructions</code>`;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\"\n            },\n            \"code\": {\n                \"lang\": 'vrml',\n                \"#text\": 'Some VRML instructions'\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n\n    it(\"should build by decoding defaul entities\", function() {\n        const jsObj = {\n            \"note\": {\n                \"@heading\": \"Reminder > \\\"Alert\",\n                \"body\": {\n                    \"#text\": \" 3 < 4\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n            }\n        };\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n             3 &lt; 4\n             <attr>Writer: Donald Duck.</attr>\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n            // processEntities: true\n        };\n        const builder = new XMLBuilder(options);\n        const result = builder.build(jsObj);\n        expect(result.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n    it(\"should build by decoding defaul entities in prserve mode\", function() {\n        const jsObj = [\n            {\n                \"note\": [\n                    {\n                        \"body\": [\n                            {\n                                \"#text\": \"3 < 4\"\n                            },\n                            {\n                                \"attr\": [\n                                    {\n                                        \"#text\": \"Writer: Donald Duck.\"\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ],\n                \":@\": {\n                    \"@heading\": \"Reminder > \\\"Alert\"\n                }\n            }\n        ];\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n             3 &lt; 4\n             <attr>Writer: Donald Duck.</attr>\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n            preserveOrder: true,\n            // processEntities: false\n        };\n\n        const parser = new XMLParser(options);\n        let result = parser.parse(expected);\n        // console.log(JSON.stringify(result,null,4));\n\n        const builder = new XMLBuilder(options);\n        result = builder.build(jsObj);\n        // console.log(result);\n        expect(result.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n\n    it(\"should parse HTML entities when htmlEntities:true\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nbsp \"writer;\">\n        <!ENTITY writer \"Writer: Donald Duck.\">\n        <!ENTITY copyright \"Copyright: W3Schools.\">\n        ]>\n        \n        <note>\n            <heading>Reminder</heading>\n            <body attr=\"&writer;\">Don't forget me this weekend!&reg;</body>\n            <footer>&writer;&&nbsp;&copyright;&inr;</footer>\n        </note> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"UTF-8\"\n            },\n            \"note\": {\n                \"heading\": \"Reminder\",\n                \"body\": {\n                    \"#text\": \"Don't forget me this weekend!\u00ae\",\n                    \"attr\": \"Writer: Donald Duck.\"\n                },\n                \"footer\": \"Writer: Donald Duck.Writer: Donald Duck.Copyright: W3Schools.\u20b9\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true,\n            htmlEntities: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n    it(\"should throw error if an entity name contains special char\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n        <!DOCTYPE note [\n        <!ENTITY nj$ \"writer;\">\n        <!ENTITY wr?er \"Writer: Donald Duck.\">\n        ]>`;\n\n        const options = {\n            processEntities: true,\n        };\n\n        expect(() =>{\n            const parser = new XMLParser(options);\n            parser.parse(xmlData);\n        }).toThrowError(\"Invalid character $ in entity name\")\n    });\n});\n\ndescribe(\"XMLParser External Entites\", function() {\n    it(\"should throw error when an entity value has '&'\", function() {\n        const parser = new XMLParser();\n        expect( () => {\n            parser.addEntity(\"#xD\", \"&\\r\");\n        }).toThrowError(\"Entity value can't have '&'\");\n    });\n\n    it(\"should throw error when an entity identifier has '&'\", function() {\n        const parser = new XMLParser();\n        expect( () => {\n            parser.addEntity(\"&#xD\", \"\\r\");\n        }).toThrowError(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n    });\n    \n    it(\"should throw error when an entity identifier has ';'\", function() {\n        const parser = new XMLParser();\n        expect( () => {\n            parser.addEntity(\"#xD;\", \"\\r\");\n        }).toThrowError(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n    });\n    \n    it(\"should set and parse for valid entity set externally\", function() {\n        const xmlData = `<note>&unknown;&#xD;last</note> `;\n\n        const parser = new XMLParser();\n        parser.addEntity(\"#xD\", \"\\r\\n\");\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result.note).toEqual(`&unknown;\\r\\nlast`);\n    });\n    \n    it(\"External Entity can change the behaviour of default entites\", function() {\n        const xmlData = `<note>&gt;last</note> `;\n\n        const parser = new XMLParser();\n        parser.addEntity(\"gt\", \"<>\");\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result.note).toEqual(`<>last`);\n    });\n    \n    it(\"Same external Entity can be set by multiple times\", function() {\n        const xmlData = `<note>&gt;last</note> `;\n\n        const parser = new XMLParser();\n        parser.addEntity(\"gt\", \"<>\");\n        parser.addEntity(\"gt\", \"><\");\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result.note).toEqual(`><last`);\n    });\n    it(\"should build by decoding '&' prserve mode\", function() {\n        const jsObj = [\n            {\n                \"note\": [\n                    {\n                        \"body\": [\n                            { \"#text\": \"(3 & 4) < 5\" },\n                            { \"attr\": [ { \"#text\": \"Writer: Donald Duck.\" } ] }\n                        ]\n                    }\n                ],\n                \":@\": {\n                    \"@heading\": \"Reminder > \\\"Alert\"\n                }\n            }\n        ];\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n             (3 &amp; 4) &lt; 5\n             <attr>Writer: Donald Duck.</attr>\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n            preserveOrder: true,\n            // processEntities: false\n        };\n\n        const parser = new XMLParser(options);\n        let result = parser.parse(expected);\n        // console.log(JSON.stringify(result,null,4));\n\n        const builder = new XMLBuilder(options);\n        result = builder.build(jsObj);\n        // console.log(result);\n        expect(result.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n    it(\"should build by decoding '&'\", function() {\n        const jsObj = {\n            \"note\": {\n                \"body\": {\n                    \"attr\": \"Writer: Donald Duck.\",\n                    \"#text\": \"(3 & 4) < 5\"\n                },\n                \"@heading\": \"Reminder > \\\"Alert\"\n            }\n        };\n\n        const expected = `\n        <note heading=\"Reminder &gt; &quot;Alert\">\n            <body>\n            <attr>Writer: Donald Duck.</attr>\n             (3 &amp; 4) &lt; 5\n            </body>\n        </note>`;\n\n        const options = {\n            attributeNamePrefix: \"@\",\n            ignoreAttributes:    false,\n        };\n\n        const parser = new XMLParser(options);\n        let result = parser.parse(expected);\n        // console.log(JSON.stringify(result,null,4));\n        // expect(expected).toEqual(jsObj);\n\n        const builder = new XMLBuilder(options);\n        const output = builder.build(jsObj);\n        // console.log(output);\n        expect(output.replace(/\\s+/g, \"\")).toEqual(expected.replace(/\\s+/g, \"\"));\n    });\n\n    it(\"should replace '&amp;lt;' with '&lt;'\", function() {\n        const xmlData = `<SimpleScalarPropertiesInputOutput>\n        <stringValue>&amp;lt;</stringValue>\n      </SimpleScalarPropertiesInputOutput>`;\n\n        const expected = {\n            \"SimpleScalarPropertiesInputOutput\": {\n              \"stringValue\": \"&lt;\"\n            }\n          };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true,\n            // preserveOrder: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        //console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n    \n    it(\"should support entites with tags in content\", function() {\n        const xmlData = `\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [ \n\t<!ENTITY Smile \" \n    \t<rect x='.5' y='.5' width='29' height='39' fill='black' stroke='red'/>\n\t\t<g transform='translate(0, 5)'> \n\t\t\t<circle cx='15' cy='15' r='10' fill='yellow'/>\n\t\t\t<circle cx='12' cy='12' r='1.5' fill='black'/>\n\t\t\t<circle cx='17' cy='12' r='1.5' fill='black'/>\n\t\t\t<path d='M 10 19 L 15 23 20 19' stroke='black' stroke-width='2'/></g>\"\n\t> \n]>\n<svg width=\"850px\" height=\"700px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<g transform=\"matrix(16,0,0,16,0,0)\">&Smile;</g></svg> `;\n\n        const expected = {\n            \"?xml\": {\n                \"version\": \"1.0\",\n                \"encoding\": \"utf-8\"\n            },\n            \"svg\": {\n                \"g\": {\n                    \"#text\": \" \\n    \\t<rect x='.5' y='.5' width='29' height='39' fill='black' stroke='red'/>\\n\\t\\t<g transform='translate(0, 5)'> \\n\\t\\t\\t<circle cx='15' cy='15' r='10' fill='yellow'/>\\n\\t\\t\\t<circle cx='12' cy='12' r='1.5' fill='black'/>\\n\\t\\t\\t<circle cx='17' cy='12' r='1.5' fill='black'/>\\n\\t\\t\\t<path d='M 10 19 L 15 23 20 19' stroke='black' stroke-width='2'/></g>\",\n                    \"transform\": \"matrix(16,0,0,16,0,0)\"\n                },\n                \"width\": \"850px\",\n                \"height\": \"700px\",\n                \"version\": \"1.1\",\n                \"xmlns\": \"http://www.w3.org/2000/svg\"\n            }\n        };\n\n        const options = {\n            attributeNamePrefix: \"\",\n            ignoreAttributes:    false,\n            processEntities: true,\n            // preserveOrder: true\n        };\n        const parser = new XMLParser(options);\n        let result = parser.parse(xmlData);\n        // console.log(JSON.stringify(result,null,4));\n\n        expect(result).toEqual(expected);\n    });\n});\n", "//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\n//an entity name should not contains special characters that may be used in regex\n//Eg !?\\\\\\/[]$%{}^&*()<>\nconst specialChar = \"!?\\\\\\/[]$%{}^&*()<>\";\n\nfunction validateEntityName(name){\n    for (let i = 0; i < specialChar.length; i++) {\n        const ch = specialChar[i];\n        if(name.indexOf(ch) !== -1) throw new Error(`Invalid character ${ch} in entity name`);\n    }\n    return name;\n}\n\nmodule.exports = readDocType;"], "filenames": ["spec/entities_spec.js", "src/xmlparser/DocTypeReader.js"], "buggy_code_start_loc": [378, 22], "buggy_code_end_loc": [378, 142], "fixing_code_start_loc": [379, 22], "fixing_code_end_loc": [397, 155], "type": "CWE-1333", "message": "fast-xml-parser is an open source, pure javascript xml parser. fast-xml-parser allows special characters in entity names, which are not escaped or sanitized. Since the entity name is used for creating a regex for searching and replacing entities in the XML body, an attacker can abuse it for denial of service (DoS) attacks. By crafting an entity name that results in an intentionally bad performing regex and utilizing it in the entity replacement step of the parser, this can cause the parser to stall for an indefinite amount of time. This problem has been resolved in v4.2.4. Users are advised to upgrade. Users unable to upgrade should avoid using DOCTYPE parsing by setting the `processEntities: false` option.", "other": {"cve": {"id": "CVE-2023-34104", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-06T18:15:11.643", "lastModified": "2024-01-22T18:15:20.003", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fast-xml-parser is an open source, pure javascript xml parser. fast-xml-parser allows special characters in entity names, which are not escaped or sanitized. Since the entity name is used for creating a regex for searching and replacing entities in the XML body, an attacker can abuse it for denial of service (DoS) attacks. By crafting an entity name that results in an intentionally bad performing regex and utilizing it in the entity replacement step of the parser, this can cause the parser to stall for an indefinite amount of time. This problem has been resolved in v4.2.4. Users are advised to upgrade. Users unable to upgrade should avoid using DOCTYPE parsing by setting the `processEntities: false` option."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1333"}, {"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fast-xml-parser_project:fast-xml-parser:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.2.4", "matchCriteriaId": "D11D7415-214B-458D-B675-CD7E0F3D8248"}]}]}], "references": [{"url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/39b0e050bb909e8499478657f84a3076e39ce76c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/a4bdced80369892ee413bf08e28b78795a2b0d5b", "source": "security-advisories@github.com"}, {"url": "https://github.com/NaturalIntelligence/fast-xml-parser/security/advisories/GHSA-6w63-h3fj-q4vw", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/39b0e050bb909e8499478657f84a3076e39ce76c"}}