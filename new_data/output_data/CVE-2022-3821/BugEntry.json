{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/timerfd.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"io-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"missing_timerfd.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"process-util.h\"\n#include \"stat-util.h\"\n#include \"string-table.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"time-util.h\"\n\nstatic clockid_t map_clock_id(clockid_t c) {\n\n        /* Some more exotic archs (s390, ppc, \u2026) lack the \"ALARM\" flavour of the clocks. Thus,\n         * clock_gettime() will fail for them. Since they are essentially the same as their non-ALARM\n         * pendants (their only difference is when timers are set on them), let's just map them\n         * accordingly. This way, we can get the correct time even on those archs. */\n\n        switch (c) {\n\n        case CLOCK_BOOTTIME_ALARM:\n                return CLOCK_BOOTTIME;\n\n        case CLOCK_REALTIME_ALARM:\n                return CLOCK_REALTIME;\n\n        default:\n                return c;\n        }\n}\n\nusec_t now(clockid_t clock_id) {\n        struct timespec ts;\n\n        assert_se(clock_gettime(map_clock_id(clock_id), &ts) == 0);\n\n        return timespec_load(&ts);\n}\n\nnsec_t now_nsec(clockid_t clock_id) {\n        struct timespec ts;\n\n        assert_se(clock_gettime(map_clock_id(clock_id), &ts) == 0);\n\n        return timespec_load_nsec(&ts);\n}\n\ndual_timestamp* dual_timestamp_get(dual_timestamp *ts) {\n        assert(ts);\n\n        ts->realtime = now(CLOCK_REALTIME);\n        ts->monotonic = now(CLOCK_MONOTONIC);\n\n        return ts;\n}\n\ntriple_timestamp* triple_timestamp_get(triple_timestamp *ts) {\n        assert(ts);\n\n        ts->realtime = now(CLOCK_REALTIME);\n        ts->monotonic = now(CLOCK_MONOTONIC);\n        ts->boottime = now(CLOCK_BOOTTIME);\n\n        return ts;\n}\n\nstatic usec_t map_clock_usec_internal(usec_t from, usec_t from_base, usec_t to_base) {\n\n        /* Maps the time 'from' between two clocks, based on a common reference point where the first clock\n         * is at 'from_base' and the second clock at 'to_base'. Basically calculates:\n         *\n         *         from - from_base + to_base\n         *\n         * But takes care of overflows/underflows and avoids signed operations. */\n\n        if (from >= from_base) { /* In the future */\n                usec_t delta = from - from_base;\n\n                if (to_base >= USEC_INFINITY - delta) /* overflow? */\n                        return USEC_INFINITY;\n\n                return to_base + delta;\n\n        } else { /* In the past */\n                usec_t delta = from_base - from;\n\n                if (to_base <= delta) /* underflow? */\n                        return 0;\n\n                return to_base - delta;\n        }\n}\n\nusec_t map_clock_usec(usec_t from, clockid_t from_clock, clockid_t to_clock) {\n\n        /* Try to avoid any inaccuracy needlessly added in case we convert from effectively the same clock\n         * onto itself */\n        if (map_clock_id(from_clock) == map_clock_id(to_clock))\n                return from;\n\n        /* Keep infinity as is */\n        if (from == USEC_INFINITY)\n                return from;\n\n        return map_clock_usec_internal(from, now(from_clock), now(to_clock));\n}\n\ndual_timestamp* dual_timestamp_from_realtime(dual_timestamp *ts, usec_t u) {\n        assert(ts);\n\n        if (!timestamp_is_set(u)) {\n                ts->realtime = ts->monotonic = u;\n                return ts;\n        }\n\n        ts->realtime = u;\n        ts->monotonic = map_clock_usec(u, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        return ts;\n}\n\ntriple_timestamp* triple_timestamp_from_realtime(triple_timestamp *ts, usec_t u) {\n        usec_t nowr;\n\n        assert(ts);\n\n        if (!timestamp_is_set(u)) {\n                ts->realtime = ts->monotonic = ts->boottime = u;\n                return ts;\n        }\n\n        nowr = now(CLOCK_REALTIME);\n\n        ts->realtime = u;\n        ts->monotonic = map_clock_usec_internal(u, nowr, now(CLOCK_MONOTONIC));\n        ts->boottime = map_clock_usec_internal(u, nowr, now(CLOCK_BOOTTIME));\n\n        return ts;\n}\n\ndual_timestamp* dual_timestamp_from_monotonic(dual_timestamp *ts, usec_t u) {\n        assert(ts);\n\n        if (u == USEC_INFINITY) {\n                ts->realtime = ts->monotonic = USEC_INFINITY;\n                return ts;\n        }\n\n        ts->monotonic = u;\n        ts->realtime = map_clock_usec(u, CLOCK_MONOTONIC, CLOCK_REALTIME);\n        return ts;\n}\n\ndual_timestamp* dual_timestamp_from_boottime(dual_timestamp *ts, usec_t u) {\n        usec_t nowm;\n\n        if (u == USEC_INFINITY) {\n                ts->realtime = ts->monotonic = USEC_INFINITY;\n                return ts;\n        }\n\n        nowm = now(CLOCK_BOOTTIME);\n        ts->monotonic = map_clock_usec_internal(u, nowm, now(CLOCK_MONOTONIC));\n        ts->realtime = map_clock_usec_internal(u, nowm, now(CLOCK_REALTIME));\n        return ts;\n}\n\nusec_t triple_timestamp_by_clock(triple_timestamp *ts, clockid_t clock) {\n\n        switch (clock) {\n\n        case CLOCK_REALTIME:\n        case CLOCK_REALTIME_ALARM:\n                return ts->realtime;\n\n        case CLOCK_MONOTONIC:\n                return ts->monotonic;\n\n        case CLOCK_BOOTTIME:\n        case CLOCK_BOOTTIME_ALARM:\n                return ts->boottime;\n\n        default:\n                return USEC_INFINITY;\n        }\n}\n\nusec_t timespec_load(const struct timespec *ts) {\n        assert(ts);\n\n        if (ts->tv_sec < 0 || ts->tv_nsec < 0)\n                return USEC_INFINITY;\n\n        if ((usec_t) ts->tv_sec > (UINT64_MAX - (ts->tv_nsec / NSEC_PER_USEC)) / USEC_PER_SEC)\n                return USEC_INFINITY;\n\n        return\n                (usec_t) ts->tv_sec * USEC_PER_SEC +\n                (usec_t) ts->tv_nsec / NSEC_PER_USEC;\n}\n\nnsec_t timespec_load_nsec(const struct timespec *ts) {\n        assert(ts);\n\n        if (ts->tv_sec < 0 || ts->tv_nsec < 0)\n                return NSEC_INFINITY;\n\n        if ((nsec_t) ts->tv_sec >= (UINT64_MAX - ts->tv_nsec) / NSEC_PER_SEC)\n                return NSEC_INFINITY;\n\n        return (nsec_t) ts->tv_sec * NSEC_PER_SEC + (nsec_t) ts->tv_nsec;\n}\n\nstruct timespec *timespec_store(struct timespec *ts, usec_t u)  {\n        assert(ts);\n\n        if (u == USEC_INFINITY ||\n            u / USEC_PER_SEC >= TIME_T_MAX) {\n                ts->tv_sec = (time_t) -1;\n                ts->tv_nsec = -1L;\n                return ts;\n        }\n\n        ts->tv_sec = (time_t) (u / USEC_PER_SEC);\n        ts->tv_nsec = (long) ((u % USEC_PER_SEC) * NSEC_PER_USEC);\n\n        return ts;\n}\n\nstruct timespec *timespec_store_nsec(struct timespec *ts, nsec_t n)  {\n        assert(ts);\n\n        if (n == NSEC_INFINITY ||\n            n / NSEC_PER_SEC >= TIME_T_MAX) {\n                ts->tv_sec = (time_t) -1;\n                ts->tv_nsec = -1L;\n                return ts;\n        }\n\n        ts->tv_sec = (time_t) (n / NSEC_PER_SEC);\n        ts->tv_nsec = (long) (n % NSEC_PER_SEC);\n\n        return ts;\n}\n\nusec_t timeval_load(const struct timeval *tv) {\n        assert(tv);\n\n        if (tv->tv_sec < 0 || tv->tv_usec < 0)\n                return USEC_INFINITY;\n\n        if ((usec_t) tv->tv_sec > (UINT64_MAX - tv->tv_usec) / USEC_PER_SEC)\n                return USEC_INFINITY;\n\n        return\n                (usec_t) tv->tv_sec * USEC_PER_SEC +\n                (usec_t) tv->tv_usec;\n}\n\nstruct timeval *timeval_store(struct timeval *tv, usec_t u) {\n        assert(tv);\n\n        if (u == USEC_INFINITY ||\n            u / USEC_PER_SEC > TIME_T_MAX) {\n                tv->tv_sec = (time_t) -1;\n                tv->tv_usec = (suseconds_t) -1;\n        } else {\n                tv->tv_sec = (time_t) (u / USEC_PER_SEC);\n                tv->tv_usec = (suseconds_t) (u % USEC_PER_SEC);\n        }\n\n        return tv;\n}\n\nchar *format_timestamp_style(\n                char *buf,\n                size_t l,\n                usec_t t,\n                TimestampStyle style) {\n\n        /* The weekdays in non-localized (English) form. We use this instead of the localized form, so that\n         * our generated timestamps may be parsed with parse_timestamp(), and always read the same. */\n        static const char * const weekdays[] = {\n                [0] = \"Sun\",\n                [1] = \"Mon\",\n                [2] = \"Tue\",\n                [3] = \"Wed\",\n                [4] = \"Thu\",\n                [5] = \"Fri\",\n                [6] = \"Sat\",\n        };\n\n        struct tm tm;\n        time_t sec;\n        size_t n;\n        bool utc = false, us = false;\n        int r;\n\n        assert(buf);\n\n        switch (style) {\n                case TIMESTAMP_PRETTY:\n                case TIMESTAMP_UNIX:\n                        break;\n                case TIMESTAMP_US:\n                        us = true;\n                        break;\n                case TIMESTAMP_UTC:\n                        utc = true;\n                        break;\n                case TIMESTAMP_US_UTC:\n                        us = true;\n                        utc = true;\n                        break;\n                default:\n                        return NULL;\n        }\n\n        if (l < (size_t) (3 +                  /* week day */\n                          1 + 10 +             /* space and date */\n                          1 + 8 +              /* space and time */\n                          (us ? 1 + 6 : 0) +   /* \".\" and microsecond part */\n                          1 + 1 +              /* space and shortest possible zone */\n                          1))\n                return NULL; /* Not enough space even for the shortest form. */\n        if (!timestamp_is_set(t))\n                return NULL; /* Timestamp is unset */\n\n        if (style == TIMESTAMP_UNIX) {\n                r = snprintf(buf, l, \"@\" USEC_FMT, t / USEC_PER_SEC);  /* round down \u00b5s \u2192 s */\n                if (r < 0 || (size_t) r >= l)\n                        return NULL; /* Doesn't fit */\n\n                return buf;\n        }\n\n        /* Let's not format times with years > 9999 */\n        if (t > USEC_TIMESTAMP_FORMATTABLE_MAX) {\n                assert(l >= STRLEN(\"--- XXXX-XX-XX XX:XX:XX\") + 1);\n                strcpy(buf, \"--- XXXX-XX-XX XX:XX:XX\");\n                return buf;\n        }\n\n        sec = (time_t) (t / USEC_PER_SEC); /* Round down */\n\n        if (!localtime_or_gmtime_r(&sec, &tm, utc))\n                return NULL;\n\n        /* Start with the week day */\n        assert((size_t) tm.tm_wday < ELEMENTSOF(weekdays));\n        memcpy(buf, weekdays[tm.tm_wday], 4);\n\n        /* Add the main components */\n        if (strftime(buf + 3, l - 3, \" %Y-%m-%d %H:%M:%S\", &tm) <= 0)\n                return NULL; /* Doesn't fit */\n\n        /* Append the microseconds part, if that's requested */\n        if (us) {\n                n = strlen(buf);\n                if (n + 8 > l)\n                        return NULL; /* Microseconds part doesn't fit. */\n\n                sprintf(buf + n, \".%06\"PRI_USEC, t % USEC_PER_SEC);\n        }\n\n        /* Append the timezone */\n        n = strlen(buf);\n        if (utc) {\n                /* If this is UTC then let's explicitly use the \"UTC\" string here, because gmtime_r()\n                 * normally uses the obsolete \"GMT\" instead. */\n                if (n + 5 > l)\n                        return NULL; /* \"UTC\" doesn't fit. */\n\n                strcpy(buf + n, \" UTC\");\n\n        } else if (!isempty(tm.tm_zone)) {\n                size_t tn;\n\n                /* An explicit timezone is specified, let's use it, if it fits */\n                tn = strlen(tm.tm_zone);\n                if (n + 1 + tn + 1 > l) {\n                        /* The full time zone does not fit in. Yuck. */\n\n                        if (n + 1 + _POSIX_TZNAME_MAX + 1 > l)\n                                return NULL; /* Not even enough space for the POSIX minimum (of 6)? In that\n                                              * case, complain that it doesn't fit. */\n\n                        /* So the time zone doesn't fit in fully, but the caller passed enough space for the\n                         * POSIX minimum time zone length. In this case suppress the timezone entirely, in\n                         * order not to dump an overly long, hard to read string on the user. This should be\n                         * safe, because the user will assume the local timezone anyway if none is shown. And\n                         * so does parse_timestamp(). */\n                } else {\n                        buf[n++] = ' ';\n                        strcpy(buf + n, tm.tm_zone);\n                }\n        }\n\n        return buf;\n}\n\nchar *format_timestamp_relative(char *buf, size_t l, usec_t t) {\n        const char *s;\n        usec_t n, d;\n\n        if (!timestamp_is_set(t))\n                return NULL;\n\n        n = now(CLOCK_REALTIME);\n        if (n > t) {\n                d = n - t;\n                s = \"ago\";\n        } else {\n                d = t - n;\n                s = \"left\";\n        }\n\n        if (d >= USEC_PER_YEAR) {\n                usec_t years = d / USEC_PER_YEAR;\n                usec_t months = (d % USEC_PER_YEAR) / USEC_PER_MONTH;\n\n                (void) snprintf(buf, l, USEC_FMT \" %s \" USEC_FMT \" %s %s\",\n                                years,\n                                years == 1 ? \"year\" : \"years\",\n                                months,\n                                months == 1 ? \"month\" : \"months\",\n                                s);\n        } else if (d >= USEC_PER_MONTH) {\n                usec_t months = d / USEC_PER_MONTH;\n                usec_t days = (d % USEC_PER_MONTH) / USEC_PER_DAY;\n\n                (void) snprintf(buf, l, USEC_FMT \" %s \" USEC_FMT \" %s %s\",\n                                months,\n                                months == 1 ? \"month\" : \"months\",\n                                days,\n                                days == 1 ? \"day\" : \"days\",\n                                s);\n        } else if (d >= USEC_PER_WEEK) {\n                usec_t weeks = d / USEC_PER_WEEK;\n                usec_t days = (d % USEC_PER_WEEK) / USEC_PER_DAY;\n\n                (void) snprintf(buf, l, USEC_FMT \" %s \" USEC_FMT \" %s %s\",\n                                weeks,\n                                weeks == 1 ? \"week\" : \"weeks\",\n                                days,\n                                days == 1 ? \"day\" : \"days\",\n                                s);\n        } else if (d >= 2*USEC_PER_DAY)\n                (void) snprintf(buf, l, USEC_FMT \" days %s\", d / USEC_PER_DAY, s);\n        else if (d >= 25*USEC_PER_HOUR)\n                (void) snprintf(buf, l, \"1 day \" USEC_FMT \"h %s\",\n                                (d - USEC_PER_DAY) / USEC_PER_HOUR, s);\n        else if (d >= 6*USEC_PER_HOUR)\n                (void) snprintf(buf, l, USEC_FMT \"h %s\",\n                                d / USEC_PER_HOUR, s);\n        else if (d >= USEC_PER_HOUR)\n                (void) snprintf(buf, l, USEC_FMT \"h \" USEC_FMT \"min %s\",\n                                d / USEC_PER_HOUR,\n                                (d % USEC_PER_HOUR) / USEC_PER_MINUTE, s);\n        else if (d >= 5*USEC_PER_MINUTE)\n                (void) snprintf(buf, l, USEC_FMT \"min %s\",\n                                d / USEC_PER_MINUTE, s);\n        else if (d >= USEC_PER_MINUTE)\n                (void) snprintf(buf, l, USEC_FMT \"min \" USEC_FMT \"s %s\",\n                                d / USEC_PER_MINUTE,\n                                (d % USEC_PER_MINUTE) / USEC_PER_SEC, s);\n        else if (d >= USEC_PER_SEC)\n                (void) snprintf(buf, l, USEC_FMT \"s %s\",\n                                d / USEC_PER_SEC, s);\n        else if (d >= USEC_PER_MSEC)\n                (void) snprintf(buf, l, USEC_FMT \"ms %s\",\n                                d / USEC_PER_MSEC, s);\n        else if (d > 0)\n                (void) snprintf(buf, l, USEC_FMT\"us %s\",\n                                d, s);\n        else\n                (void) snprintf(buf, l, \"now\");\n\n        buf[l-1] = 0;\n        return buf;\n}\n\nchar *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \"y\",     USEC_PER_YEAR   },\n                { \"month\", USEC_PER_MONTH  },\n                { \"w\",     USEC_PER_WEEK   },\n                { \"d\",     USEC_PER_DAY    },\n                { \"h\",     USEC_PER_HOUR   },\n                { \"min\",   USEC_PER_MINUTE },\n                { \"s\",     USEC_PER_SEC    },\n                { \"ms\",    USEC_PER_MSEC   },\n                { \"us\",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \"infinity\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \"0\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \"%s\"USEC_FMT\".%0*\"PRI_USEC\"%s\",\n                                             p > buf ? \" \" : \"\",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \"%s\"USEC_FMT\"%s\",\n                                     p > buf ? \" \" : \"\",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n        *p = 0;\n\n        return buf;\n}\n\nstatic int parse_timestamp_impl(const char *t, usec_t *usec, bool with_tz) {\n        static const struct {\n                const char *name;\n                const int nr;\n        } day_nr[] = {\n                { \"Sunday\",    0 },\n                { \"Sun\",       0 },\n                { \"Monday\",    1 },\n                { \"Mon\",       1 },\n                { \"Tuesday\",   2 },\n                { \"Tue\",       2 },\n                { \"Wednesday\", 3 },\n                { \"Wed\",       3 },\n                { \"Thursday\",  4 },\n                { \"Thu\",       4 },\n                { \"Friday\",    5 },\n                { \"Fri\",       5 },\n                { \"Saturday\",  6 },\n                { \"Sat\",       6 },\n        };\n\n        const char *k, *utc = NULL, *tzn = NULL;\n        struct tm tm, copy;\n        time_t x;\n        usec_t x_usec, plus = 0, minus = 0, ret;\n        int r, weekday = -1, dst = -1;\n        size_t i;\n\n        /* Allowed syntaxes:\n         *\n         *   2012-09-22 16:34:22\n         *   2012-09-22 16:34     (seconds will be set to 0)\n         *   2012-09-22           (time will be set to 00:00:00)\n         *   16:34:22             (date will be set to today)\n         *   16:34                (date will be set to today, seconds to 0)\n         *   now\n         *   yesterday            (time is set to 00:00:00)\n         *   today                (time is set to 00:00:00)\n         *   tomorrow             (time is set to 00:00:00)\n         *   +5min\n         *   -5days\n         *   @2147483647          (seconds since epoch)\n         */\n\n        assert(t);\n\n        if (t[0] == '@' && !with_tz)\n                return parse_sec(t + 1, usec);\n\n        ret = now(CLOCK_REALTIME);\n\n        if (!with_tz) {\n                if (streq(t, \"now\"))\n                        goto finish;\n\n                else if (t[0] == '+') {\n                        r = parse_sec(t+1, &plus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n\n                } else if (t[0] == '-') {\n                        r = parse_sec(t+1, &minus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n\n                } else if ((k = endswith(t, \" ago\"))) {\n                        t = strndupa_safe(t, k - t);\n\n                        r = parse_sec(t, &minus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n\n                } else if ((k = endswith(t, \" left\"))) {\n                        t = strndupa_safe(t, k - t);\n\n                        r = parse_sec(t, &plus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n                }\n\n                /* See if the timestamp is suffixed with UTC */\n                utc = endswith_no_case(t, \" UTC\");\n                if (utc)\n                        t = strndupa_safe(t, utc - t);\n                else {\n                        const char *e = NULL;\n                        int j;\n\n                        tzset();\n\n                        /* See if the timestamp is suffixed by either the DST or non-DST local timezone. Note\n                         * that we only support the local timezones here, nothing else. Not because we\n                         * wouldn't want to, but simply because there are no nice APIs available to cover\n                         * this. By accepting the local time zone strings, we make sure that all timestamps\n                         * written by format_timestamp() can be parsed correctly, even though we don't\n                         * support arbitrary timezone specifications. */\n\n                        for (j = 0; j <= 1; j++) {\n\n                                if (isempty(tzname[j]))\n                                        continue;\n\n                                e = endswith_no_case(t, tzname[j]);\n                                if (!e)\n                                        continue;\n                                if (e == t)\n                                        continue;\n                                if (e[-1] != ' ')\n                                        continue;\n\n                                break;\n                        }\n\n                        if (IN_SET(j, 0, 1)) {\n                                /* Found one of the two timezones specified. */\n                                t = strndupa_safe(t, e - t - 1);\n                                dst = j;\n                                tzn = tzname[j];\n                        }\n                }\n        }\n\n        x = (time_t) (ret / USEC_PER_SEC);\n        x_usec = 0;\n\n        if (!localtime_or_gmtime_r(&x, &tm, utc))\n                return -EINVAL;\n\n        tm.tm_isdst = dst;\n        if (!with_tz && tzn)\n                tm.tm_zone = tzn;\n\n        if (streq(t, \"today\")) {\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n\n        } else if (streq(t, \"yesterday\")) {\n                tm.tm_mday--;\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n\n        } else if (streq(t, \"tomorrow\")) {\n                tm.tm_mday++;\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n        }\n\n        for (i = 0; i < ELEMENTSOF(day_nr); i++) {\n                size_t skip;\n\n                if (!startswith_no_case(t, day_nr[i].name))\n                        continue;\n\n                skip = strlen(day_nr[i].name);\n                if (t[skip] != ' ')\n                        continue;\n\n                weekday = day_nr[i].nr;\n                t += skip + 1;\n                break;\n        }\n\n        copy = tm;\n        k = strptime(t, \"%y-%m-%d %H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%Y-%m-%d %H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        /* Support OUTPUT_SHORT and OUTPUT_SHORT_PRECISE formats */\n        tm = copy;\n        k = strptime(t, \"%b %d %H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%y-%m-%d %H:%M\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%Y-%m-%d %H:%M\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%y-%m-%d\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%Y-%m-%d\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%H:%M\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = 0;\n                goto from_tm;\n        }\n\n        return -EINVAL;\n\nparse_usec:\n        {\n                unsigned add;\n\n                k++;\n                r = parse_fractional_part_u(&k, 6, &add);\n                if (r < 0)\n                        return -EINVAL;\n\n                if (*k)\n                        return -EINVAL;\n\n                x_usec = add;\n        }\n\nfrom_tm:\n        if (weekday >= 0 && tm.tm_wday != weekday)\n                return -EINVAL;\n\n        x = mktime_or_timegm(&tm, utc);\n        if (x < 0)\n                return -EINVAL;\n\n        ret = (usec_t) x * USEC_PER_SEC + x_usec;\n        if (ret > USEC_TIMESTAMP_FORMATTABLE_MAX)\n                return -EINVAL;\n\nfinish:\n        if (ret + plus < ret) /* overflow? */\n                return -EINVAL;\n        ret += plus;\n        if (ret > USEC_TIMESTAMP_FORMATTABLE_MAX)\n                return -EINVAL;\n\n        if (ret >= minus)\n                ret -= minus;\n        else\n                return -EINVAL;\n\n        if (usec)\n                *usec = ret;\n        return 0;\n}\n\ntypedef struct ParseTimestampResult {\n        usec_t usec;\n        int return_value;\n} ParseTimestampResult;\n\nint parse_timestamp(const char *t, usec_t *usec) {\n        char *last_space, *tz = NULL;\n        ParseTimestampResult *shared, tmp;\n        int r;\n\n        last_space = strrchr(t, ' ');\n        if (last_space != NULL && timezone_is_valid(last_space + 1, LOG_DEBUG))\n                tz = last_space + 1;\n\n        if (!tz || endswith_no_case(t, \" UTC\"))\n                return parse_timestamp_impl(t, usec, false);\n\n        shared = mmap(NULL, sizeof *shared, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);\n        if (shared == MAP_FAILED)\n                return negative_errno();\n\n        r = safe_fork(\"(sd-timestamp)\", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_DEATHSIG|FORK_WAIT, NULL);\n        if (r < 0) {\n                (void) munmap(shared, sizeof *shared);\n                return r;\n        }\n        if (r == 0) {\n                bool with_tz = true;\n                char *colon_tz;\n\n                /* tzset(3) says $TZ should be prefixed with \":\" if we reference timezone files */\n                colon_tz = strjoina(\":\", tz);\n\n                if (setenv(\"TZ\", colon_tz, 1) != 0) {\n                        shared->return_value = negative_errno();\n                        _exit(EXIT_FAILURE);\n                }\n\n                tzset();\n\n                /* If there is a timezone that matches the tzname fields, leave the parsing to the implementation.\n                 * Otherwise just cut it off. */\n                with_tz = !STR_IN_SET(tz, tzname[0], tzname[1]);\n\n                /* Cut off the timezone if we don't need it. */\n                if (with_tz)\n                        t = strndupa_safe(t, last_space - t);\n\n                shared->return_value = parse_timestamp_impl(t, &shared->usec, with_tz);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        tmp = *shared;\n        if (munmap(shared, sizeof *shared) != 0)\n                return negative_errno();\n\n        if (tmp.return_value == 0 && usec)\n                *usec = tmp.usec;\n\n        return tmp.return_value;\n}\n\nstatic const char* extract_multiplier(const char *p, usec_t *multiplier) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \"seconds\", USEC_PER_SEC    },\n                { \"second\",  USEC_PER_SEC    },\n                { \"sec\",     USEC_PER_SEC    },\n                { \"s\",       USEC_PER_SEC    },\n                { \"minutes\", USEC_PER_MINUTE },\n                { \"minute\",  USEC_PER_MINUTE },\n                { \"min\",     USEC_PER_MINUTE },\n                { \"months\",  USEC_PER_MONTH  },\n                { \"month\",   USEC_PER_MONTH  },\n                { \"M\",       USEC_PER_MONTH  },\n                { \"msec\",    USEC_PER_MSEC   },\n                { \"ms\",      USEC_PER_MSEC   },\n                { \"m\",       USEC_PER_MINUTE },\n                { \"hours\",   USEC_PER_HOUR   },\n                { \"hour\",    USEC_PER_HOUR   },\n                { \"hr\",      USEC_PER_HOUR   },\n                { \"h\",       USEC_PER_HOUR   },\n                { \"days\",    USEC_PER_DAY    },\n                { \"day\",     USEC_PER_DAY    },\n                { \"d\",       USEC_PER_DAY    },\n                { \"weeks\",   USEC_PER_WEEK   },\n                { \"week\",    USEC_PER_WEEK   },\n                { \"w\",       USEC_PER_WEEK   },\n                { \"years\",   USEC_PER_YEAR   },\n                { \"year\",    USEC_PER_YEAR   },\n                { \"y\",       USEC_PER_YEAR   },\n                { \"usec\",    1ULL            },\n                { \"us\",      1ULL            },\n                { \"\u00b5s\",      1ULL            },\n        };\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                char *e;\n\n                e = startswith(p, table[i].suffix);\n                if (e) {\n                        *multiplier = table[i].usec;\n                        return e;\n                }\n        }\n\n        return p;\n}\n\nint parse_time(const char *t, usec_t *usec, usec_t default_unit) {\n        const char *p, *s;\n        usec_t r = 0;\n        bool something = false;\n\n        assert(t);\n        assert(default_unit > 0);\n\n        p = t;\n\n        p += strspn(p, WHITESPACE);\n        s = startswith(p, \"infinity\");\n        if (s) {\n                s += strspn(s, WHITESPACE);\n                if (*s != 0)\n                        return -EINVAL;\n\n                if (usec)\n                        *usec = USEC_INFINITY;\n                return 0;\n        }\n\n        for (;;) {\n                usec_t multiplier = default_unit, k;\n                long long l;\n                char *e;\n\n                p += strspn(p, WHITESPACE);\n\n                if (*p == 0) {\n                        if (!something)\n                                return -EINVAL;\n\n                        break;\n                }\n\n                if (*p == '-') /* Don't allow \"-0\" */\n                        return -ERANGE;\n\n                errno = 0;\n                l = strtoll(p, &e, 10);\n                if (errno > 0)\n                        return -errno;\n                if (l < 0)\n                        return -ERANGE;\n\n                if (*e == '.') {\n                        p = e + 1;\n                        p += strspn(p, DIGITS);\n                } else if (e == p)\n                        return -EINVAL;\n                else\n                        p = e;\n\n                s = extract_multiplier(p + strspn(p, WHITESPACE), &multiplier);\n                if (s == p && *s != '\\0')\n                        /* Don't allow '12.34.56', but accept '12.34 .56' or '12.34s.56' */\n                        return -EINVAL;\n\n                p = s;\n\n                if ((usec_t) l >= USEC_INFINITY / multiplier)\n                        return -ERANGE;\n\n                k = (usec_t) l * multiplier;\n                if (k >= USEC_INFINITY - r)\n                        return -ERANGE;\n\n                r += k;\n\n                something = true;\n\n                if (*e == '.') {\n                        usec_t m = multiplier / 10;\n                        const char *b;\n\n                        for (b = e + 1; *b >= '0' && *b <= '9'; b++, m /= 10) {\n                                k = (usec_t) (*b - '0') * m;\n                                if (k >= USEC_INFINITY - r)\n                                        return -ERANGE;\n\n                                r += k;\n                        }\n\n                        /* Don't allow \"0.-0\", \"3.+1\", \"3. 1\", \"3.sec\" or \"3.hoge\" */\n                        if (b == e + 1)\n                                return -EINVAL;\n                }\n        }\n\n        if (usec)\n                *usec = r;\n        return 0;\n}\n\nint parse_sec(const char *t, usec_t *usec) {\n        return parse_time(t, usec, USEC_PER_SEC);\n}\n\nint parse_sec_fix_0(const char *t, usec_t *ret) {\n        usec_t k;\n        int r;\n\n        assert(t);\n        assert(ret);\n\n        r = parse_sec(t, &k);\n        if (r < 0)\n                return r;\n\n        *ret = k == 0 ? USEC_INFINITY : k;\n        return r;\n}\n\nint parse_sec_def_infinity(const char *t, usec_t *ret) {\n        t += strspn(t, WHITESPACE);\n        if (isempty(t)) {\n                *ret = USEC_INFINITY;\n                return 0;\n        }\n        return parse_sec(t, ret);\n}\n\nstatic const char* extract_nsec_multiplier(const char *p, nsec_t *multiplier) {\n        static const struct {\n                const char *suffix;\n                nsec_t nsec;\n        } table[] = {\n                { \"seconds\", NSEC_PER_SEC    },\n                { \"second\",  NSEC_PER_SEC    },\n                { \"sec\",     NSEC_PER_SEC    },\n                { \"s\",       NSEC_PER_SEC    },\n                { \"minutes\", NSEC_PER_MINUTE },\n                { \"minute\",  NSEC_PER_MINUTE },\n                { \"min\",     NSEC_PER_MINUTE },\n                { \"months\",  NSEC_PER_MONTH  },\n                { \"month\",   NSEC_PER_MONTH  },\n                { \"M\",       NSEC_PER_MONTH  },\n                { \"msec\",    NSEC_PER_MSEC   },\n                { \"ms\",      NSEC_PER_MSEC   },\n                { \"m\",       NSEC_PER_MINUTE },\n                { \"hours\",   NSEC_PER_HOUR   },\n                { \"hour\",    NSEC_PER_HOUR   },\n                { \"hr\",      NSEC_PER_HOUR   },\n                { \"h\",       NSEC_PER_HOUR   },\n                { \"days\",    NSEC_PER_DAY    },\n                { \"day\",     NSEC_PER_DAY    },\n                { \"d\",       NSEC_PER_DAY    },\n                { \"weeks\",   NSEC_PER_WEEK   },\n                { \"week\",    NSEC_PER_WEEK   },\n                { \"w\",       NSEC_PER_WEEK   },\n                { \"years\",   NSEC_PER_YEAR   },\n                { \"year\",    NSEC_PER_YEAR   },\n                { \"y\",       NSEC_PER_YEAR   },\n                { \"usec\",    NSEC_PER_USEC   },\n                { \"us\",      NSEC_PER_USEC   },\n                { \"\u00b5s\",      NSEC_PER_USEC   },\n                { \"nsec\",    1ULL            },\n                { \"ns\",      1ULL            },\n                { \"\",        1ULL            }, /* default is nsec */\n        };\n        size_t i;\n\n        for (i = 0; i < ELEMENTSOF(table); i++) {\n                char *e;\n\n                e = startswith(p, table[i].suffix);\n                if (e) {\n                        *multiplier = table[i].nsec;\n                        return e;\n                }\n        }\n\n        return p;\n}\n\nint parse_nsec(const char *t, nsec_t *nsec) {\n        const char *p, *s;\n        nsec_t r = 0;\n        bool something = false;\n\n        assert(t);\n        assert(nsec);\n\n        p = t;\n\n        p += strspn(p, WHITESPACE);\n        s = startswith(p, \"infinity\");\n        if (s) {\n                s += strspn(s, WHITESPACE);\n                if (*s != 0)\n                        return -EINVAL;\n\n                *nsec = NSEC_INFINITY;\n                return 0;\n        }\n\n        for (;;) {\n                nsec_t multiplier = 1, k;\n                long long l;\n                char *e;\n\n                p += strspn(p, WHITESPACE);\n\n                if (*p == 0) {\n                        if (!something)\n                                return -EINVAL;\n\n                        break;\n                }\n\n                if (*p == '-') /* Don't allow \"-0\" */\n                        return -ERANGE;\n\n                errno = 0;\n                l = strtoll(p, &e, 10);\n                if (errno > 0)\n                        return -errno;\n                if (l < 0)\n                        return -ERANGE;\n\n                if (*e == '.') {\n                        p = e + 1;\n                        p += strspn(p, DIGITS);\n                } else if (e == p)\n                        return -EINVAL;\n                else\n                        p = e;\n\n                s = extract_nsec_multiplier(p + strspn(p, WHITESPACE), &multiplier);\n                if (s == p && *s != '\\0')\n                        /* Don't allow '12.34.56', but accept '12.34 .56' or '12.34s.56' */\n                        return -EINVAL;\n\n                p = s;\n\n                if ((nsec_t) l >= NSEC_INFINITY / multiplier)\n                        return -ERANGE;\n\n                k = (nsec_t) l * multiplier;\n                if (k >= NSEC_INFINITY - r)\n                        return -ERANGE;\n\n                r += k;\n\n                something = true;\n\n                if (*e == '.') {\n                        nsec_t m = multiplier / 10;\n                        const char *b;\n\n                        for (b = e + 1; *b >= '0' && *b <= '9'; b++, m /= 10) {\n                                k = (nsec_t) (*b - '0') * m;\n                                if (k >= NSEC_INFINITY - r)\n                                        return -ERANGE;\n\n                                r += k;\n                        }\n\n                        /* Don't allow \"0.-0\", \"3.+1\", \"3. 1\", \"3.sec\" or \"3.hoge\" */\n                        if (b == e + 1)\n                                return -EINVAL;\n                }\n        }\n\n        *nsec = r;\n\n        return 0;\n}\n\nstatic int get_timezones_from_zone1970_tab(char ***ret) {\n        _cleanup_fclose_ FILE *f = NULL;\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        assert(ret);\n\n        f = fopen(\"/usr/share/zoneinfo/zone1970.tab\", \"re\");\n        if (!f)\n                return -errno;\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL, *cc = NULL, *co = NULL, *tz = NULL;\n\n                r = read_line(f, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        break;\n\n                const char *p = line;\n\n                /* Line format is:\n                 * 'country codes' 'coordinates' 'timezone' 'comments' */\n                r = extract_many_words(&p, NULL, 0, &cc, &co, &tz, NULL);\n                if (r < 0)\n                        continue;\n\n                /* Lines that start with # are comments. */\n                if (*cc == '#')\n                        continue;\n\n                r = strv_extend(&zones, tz);\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(zones);\n        return 0;\n}\n\nstatic int get_timezones_from_tzdata_zi(char ***ret) {\n        _cleanup_fclose_ FILE *f = NULL;\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        f = fopen(\"/usr/share/zoneinfo/tzdata.zi\", \"re\");\n        if (!f)\n                return -errno;\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL, *type = NULL, *f1 = NULL, *f2 = NULL;\n\n                r = read_line(f, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        break;\n\n                const char *p = line;\n\n                /* The only lines we care about are Zone and Link lines.\n                 * Zone line format is:\n                 * 'Zone' 'timezone' ...\n                 * Link line format is:\n                 * 'Link' 'target' 'alias'\n                 * See 'man zic' for more detail. */\n                r = extract_many_words(&p, NULL, 0, &type, &f1, &f2, NULL);\n                if (r < 0)\n                        continue;\n\n                char *tz;\n                if (IN_SET(*type, 'Z', 'z'))\n                        /* Zone lines have timezone in field 1. */\n                        tz = f1;\n                else if (IN_SET(*type, 'L', 'l'))\n                        /* Link lines have timezone in field 2. */\n                        tz = f2;\n                else\n                        /* Not a line we care about. */\n                        continue;\n\n                r = strv_extend(&zones, tz);\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(zones);\n        return 0;\n}\n\nint get_timezones(char ***ret) {\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        assert(ret);\n\n        r = get_timezones_from_tzdata_zi(&zones);\n        if (r == -ENOENT) {\n                log_debug_errno(r, \"Could not get timezone data from tzdata.zi, using zone1970.tab: %m\");\n                r = get_timezones_from_zone1970_tab(&zones);\n                if (r == -ENOENT)\n                        log_debug_errno(r, \"Could not get timezone data from zone1970.tab, using UTC: %m\");\n        }\n        if (r < 0 && r != -ENOENT)\n                return r;\n\n        /* Always include UTC */\n        r = strv_extend(&zones, \"UTC\");\n        if (r < 0)\n                return -ENOMEM;\n\n        strv_sort(zones);\n        strv_uniq(zones);\n\n        *ret = TAKE_PTR(zones);\n        return 0;\n}\n\nint verify_timezone(const char *name, int log_level) {\n        bool slash = false;\n        const char *p, *t;\n        _cleanup_close_ int fd = -1;\n        char buf[4];\n        int r;\n\n        if (isempty(name))\n                return -EINVAL;\n\n        /* Always accept \"UTC\" as valid timezone, since it's the fallback, even if user has no timezones installed. */\n        if (streq(name, \"UTC\"))\n                return 0;\n\n        if (name[0] == '/')\n                return -EINVAL;\n\n        for (p = name; *p; p++) {\n                if (!ascii_isdigit(*p) &&\n                    !ascii_isalpha(*p) &&\n                    !IN_SET(*p, '-', '_', '+', '/'))\n                        return -EINVAL;\n\n                if (*p == '/') {\n\n                        if (slash)\n                                return -EINVAL;\n\n                        slash = true;\n                } else\n                        slash = false;\n        }\n\n        if (slash)\n                return -EINVAL;\n\n        if (p - name >= PATH_MAX)\n                return -ENAMETOOLONG;\n\n        t = strjoina(\"/usr/share/zoneinfo/\", name);\n\n        fd = open(t, O_RDONLY|O_CLOEXEC);\n        if (fd < 0)\n                return log_full_errno(log_level, errno, \"Failed to open timezone file '%s': %m\", t);\n\n        r = fd_verify_regular(fd);\n        if (r < 0)\n                return log_full_errno(log_level, r, \"Timezone file '%s' is not  a regular file: %m\", t);\n\n        r = loop_read_exact(fd, buf, 4, false);\n        if (r < 0)\n                return log_full_errno(log_level, r, \"Failed to read from timezone file '%s': %m\", t);\n\n        /* Magic from tzfile(5) */\n        if (memcmp(buf, \"TZif\", 4) != 0)\n                return log_full_errno(log_level, SYNTHETIC_ERRNO(EBADMSG),\n                                      \"Timezone file '%s' has wrong magic bytes\", t);\n\n        return 0;\n}\n\nbool clock_supported(clockid_t clock) {\n        struct timespec ts;\n\n        switch (clock) {\n\n        case CLOCK_MONOTONIC:\n        case CLOCK_REALTIME:\n        case CLOCK_BOOTTIME:\n                /* These three are always available in our baseline, and work in timerfd, as of kernel 3.15 */\n                return true;\n\n        default:\n                /* For everything else, check properly */\n                return clock_gettime(clock, &ts) >= 0;\n        }\n}\n\nint get_timezone(char **ret) {\n        _cleanup_free_ char *t = NULL;\n        const char *e;\n        char *z;\n        int r;\n\n        r = readlink_malloc(\"/etc/localtime\", &t);\n        if (r == -ENOENT) {\n                /* If the symlink does not exist, assume \"UTC\", like glibc does */\n                z = strdup(\"UTC\");\n                if (!z)\n                        return -ENOMEM;\n\n                *ret = z;\n                return 0;\n        }\n        if (r < 0)\n                return r; /* returns EINVAL if not a symlink */\n\n        e = PATH_STARTSWITH_SET(t, \"/usr/share/zoneinfo/\", \"../usr/share/zoneinfo/\");\n        if (!e)\n                return -EINVAL;\n\n        if (!timezone_is_valid(e, LOG_DEBUG))\n                return -EINVAL;\n\n        z = strdup(e);\n        if (!z)\n                return -ENOMEM;\n\n        *ret = z;\n        return 0;\n}\n\ntime_t mktime_or_timegm(struct tm *tm, bool utc) {\n        return utc ? timegm(tm) : mktime(tm);\n}\n\nstruct tm *localtime_or_gmtime_r(const time_t *t, struct tm *tm, bool utc) {\n        return utc ? gmtime_r(t, tm) : localtime_r(t, tm);\n}\n\nstatic uint32_t sysconf_clock_ticks_cached(void) {\n        static thread_local uint32_t hz = 0;\n        long r;\n\n        if (hz == 0) {\n                r = sysconf(_SC_CLK_TCK);\n\n                assert(r > 0);\n                hz = r;\n        }\n\n        return hz;\n}\n\nuint32_t usec_to_jiffies(usec_t u) {\n        uint32_t hz = sysconf_clock_ticks_cached();\n        return DIV_ROUND_UP(u, USEC_PER_SEC / hz);\n}\n\nusec_t jiffies_to_usec(uint32_t j) {\n        uint32_t hz = sysconf_clock_ticks_cached();\n        return DIV_ROUND_UP(j * USEC_PER_SEC, hz);\n}\n\nusec_t usec_shift_clock(usec_t x, clockid_t from, clockid_t to) {\n        usec_t a, b;\n\n        if (x == USEC_INFINITY)\n                return USEC_INFINITY;\n        if (map_clock_id(from) == map_clock_id(to))\n                return x;\n\n        a = now(from);\n        b = now(to);\n\n        if (x > a)\n                /* x lies in the future */\n                return usec_add(b, usec_sub_unsigned(x, a));\n        else\n                /* x lies in the past */\n                return usec_sub_unsigned(b, usec_sub_unsigned(a, x));\n}\n\nbool in_utc_timezone(void) {\n        tzset();\n\n        return timezone == 0 && daylight == 0;\n}\n\nint time_change_fd(void) {\n\n        /* We only care for the cancellation event, hence we set the timeout to the latest possible value. */\n        static const struct itimerspec its = {\n                .it_value.tv_sec = TIME_T_MAX,\n        };\n\n        _cleanup_close_ int fd = -1;\n\n        assert_cc(sizeof(time_t) == sizeof(TIME_T_MAX));\n\n        /* Uses TFD_TIMER_CANCEL_ON_SET to get notifications whenever CLOCK_REALTIME makes a jump relative to\n         * CLOCK_MONOTONIC. */\n\n        fd = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK|TFD_CLOEXEC);\n        if (fd < 0)\n                return -errno;\n\n        if (timerfd_settime(fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its, NULL) >= 0)\n                return TAKE_FD(fd);\n\n        /* So apparently there are systems where time_t is 64bit, but the kernel actually doesn't support\n         * 64bit time_t. In that case configuring a timer to TIME_T_MAX will fail with EOPNOTSUPP or a\n         * similar error. If that's the case let's try with INT32_MAX instead, maybe that works. It's a bit\n         * of a black magic thing though, but what can we do?\n         *\n         * We don't want this code on x86-64, hence let's conditionalize this for systems with 64bit time_t\n         * but where \"long\" is shorter than 64bit, i.e. 32bit archs.\n         *\n         * See: https://github.com/systemd/systemd/issues/14362 */\n\n#if SIZEOF_TIME_T == 8 && ULONG_MAX < UINT64_MAX\n        if (ERRNO_IS_NOT_SUPPORTED(errno) || errno == EOVERFLOW) {\n                static const struct itimerspec its32 = {\n                        .it_value.tv_sec = INT32_MAX,\n                };\n\n                if (timerfd_settime(fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its32, NULL) >= 0)\n                        return TAKE_FD(fd);\n        }\n#endif\n\n        return -errno;\n}\n\nstatic const char* const timestamp_style_table[_TIMESTAMP_STYLE_MAX] = {\n        [TIMESTAMP_PRETTY] = \"pretty\",\n        [TIMESTAMP_US] = \"us\",\n        [TIMESTAMP_UTC] = \"utc\",\n        [TIMESTAMP_US_UTC] = \"us+utc\",\n        [TIMESTAMP_UNIX] = \"unix\",\n};\n\n/* Use the macro for enum \u2192 string to allow for aliases */\n_DEFINE_STRING_TABLE_LOOKUP_TO_STRING(timestamp_style, TimestampStyle,);\n\n/* For the string \u2192 enum mapping we use the generic implementation, but also support two aliases */\nTimestampStyle timestamp_style_from_string(const char *s) {\n        TimestampStyle t;\n\n        t = (TimestampStyle) string_table_lookup(timestamp_style_table, ELEMENTSOF(timestamp_style_table), s);\n        if (t >= 0)\n                return t;\n        if (streq_ptr(s, \"\u00b5s\"))\n                return TIMESTAMP_US;\n        if (streq_ptr(s, \"\u00b5s+utc\"))\n                return TIMESTAMP_US_UTC;\n        return t;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"env-util.h\"\n#include \"random-util.h\"\n#include \"serialize.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nTEST(parse_sec) {\n        usec_t u;\n\n        assert_se(parse_sec(\"5s\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n        assert_se(parse_sec(\"5s500ms\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" 5s 500ms  \", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" 5.5s  \", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" 5.5s 0.5ms \", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC + 500);\n        assert_se(parse_sec(\" .22s \", &u) >= 0);\n        assert_se(u == 220 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" .50y \", &u) >= 0);\n        assert_se(u == USEC_PER_YEAR / 2);\n        assert_se(parse_sec(\"2.5\", &u) >= 0);\n        assert_se(u == 2500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\".7\", &u) >= 0);\n        assert_se(u == 700 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"23us\", &u) >= 0);\n        assert_se(u == 23);\n        assert_se(parse_sec(\"23\u00b5s\", &u) >= 0);\n        assert_se(u == 23);\n        assert_se(parse_sec(\"infinity\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec(\" infinity \", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec(\"+3.1s\", &u) >= 0);\n        assert_se(u == 3100 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1s.2\", &u) >= 0);\n        assert_se(u == 3300 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1 .2\", &u) >= 0);\n        assert_se(u == 3300 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1 sec .2 sec\", &u) >= 0);\n        assert_se(u == 3300 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1 sec 1.2 sec\", &u) >= 0);\n        assert_se(u == 4300 * USEC_PER_MSEC);\n\n        assert_se(parse_sec(\" xyz \", &u) < 0);\n        assert_se(parse_sec(\"\", &u) < 0);\n        assert_se(parse_sec(\" . \", &u) < 0);\n        assert_se(parse_sec(\" 5. \", &u) < 0);\n        assert_se(parse_sec(\".s \", &u) < 0);\n        assert_se(parse_sec(\"-5s \", &u) < 0);\n        assert_se(parse_sec(\"-0.3s \", &u) < 0);\n        assert_se(parse_sec(\"-0.0s \", &u) < 0);\n        assert_se(parse_sec(\"-0.-0s \", &u) < 0);\n        assert_se(parse_sec(\"0.-0s \", &u) < 0);\n        assert_se(parse_sec(\"3.-0s \", &u) < 0);\n        assert_se(parse_sec(\" infinity .7\", &u) < 0);\n        assert_se(parse_sec(\".3 infinity\", &u) < 0);\n        assert_se(parse_sec(\"3.+1s\", &u) < 0);\n        assert_se(parse_sec(\"3. 1s\", &u) < 0);\n        assert_se(parse_sec(\"3.s\", &u) < 0);\n        assert_se(parse_sec(\"12.34.56\", &u) < 0);\n        assert_se(parse_sec(\"12..34\", &u) < 0);\n        assert_se(parse_sec(\"..1234\", &u) < 0);\n        assert_se(parse_sec(\"1234..\", &u) < 0);\n}\n\nTEST(parse_sec_fix_0) {\n        usec_t u;\n\n        assert_se(parse_sec_fix_0(\"5s\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n        assert_se(parse_sec_fix_0(\"0s\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_fix_0(\"0\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_fix_0(\" 0\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n}\n\nTEST(parse_sec_def_infinity) {\n        usec_t u;\n\n        assert_se(parse_sec_def_infinity(\"5s\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n        assert_se(parse_sec_def_infinity(\"\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_def_infinity(\"     \", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_def_infinity(\"0s\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_sec_def_infinity(\"0\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_sec_def_infinity(\" 0\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_sec_def_infinity(\"-5s\", &u) < 0);\n}\n\nTEST(parse_time) {\n        usec_t u;\n\n        assert_se(parse_time(\"5\", &u, 1) >= 0);\n        assert_se(u == 5);\n\n        assert_se(parse_time(\"5\", &u, USEC_PER_MSEC) >= 0);\n        assert_se(u == 5 * USEC_PER_MSEC);\n\n        assert_se(parse_time(\"5\", &u, USEC_PER_SEC) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"5s\", &u, 1) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"5s\", &u, USEC_PER_SEC) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"5s\", &u, USEC_PER_MSEC) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"11111111111111y\", &u, 1) == -ERANGE);\n        assert_se(parse_time(\"1.1111111111111y\", &u, 1) >= 0);\n}\n\nTEST(parse_nsec) {\n        nsec_t u;\n\n        assert_se(parse_nsec(\"5s\", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC);\n        assert_se(parse_nsec(\"5s500ms\", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" 5s 500ms  \", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" 5.5s  \", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" 5.5s 0.5ms \", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC + 500 * NSEC_PER_USEC);\n        assert_se(parse_nsec(\" .22s \", &u) >= 0);\n        assert_se(u == 220 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" .50y \", &u) >= 0);\n        assert_se(u == NSEC_PER_YEAR / 2);\n        assert_se(parse_nsec(\"2.5\", &u) >= 0);\n        assert_se(u == 2);\n        assert_se(parse_nsec(\".7\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_nsec(\"infinity\", &u) >= 0);\n        assert_se(u == NSEC_INFINITY);\n        assert_se(parse_nsec(\" infinity \", &u) >= 0);\n        assert_se(u == NSEC_INFINITY);\n        assert_se(parse_nsec(\"+3.1s\", &u) >= 0);\n        assert_se(u == 3100 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\"3.1s.2\", &u) >= 0);\n        assert_se(u == 3100 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\"3.1 .2s\", &u) >= 0);\n        assert_se(u == 200 * NSEC_PER_MSEC + 3);\n        assert_se(parse_nsec(\"3.1 sec .2 sec\", &u) >= 0);\n        assert_se(u == 3300 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\"3.1 sec 1.2 sec\", &u) >= 0);\n        assert_se(u == 4300 * NSEC_PER_MSEC);\n\n        assert_se(parse_nsec(\" xyz \", &u) < 0);\n        assert_se(parse_nsec(\"\", &u) < 0);\n        assert_se(parse_nsec(\" . \", &u) < 0);\n        assert_se(parse_nsec(\" 5. \", &u) < 0);\n        assert_se(parse_nsec(\".s \", &u) < 0);\n        assert_se(parse_nsec(\" infinity .7\", &u) < 0);\n        assert_se(parse_nsec(\".3 infinity\", &u) < 0);\n        assert_se(parse_nsec(\"-5s \", &u) < 0);\n        assert_se(parse_nsec(\"-0.3s \", &u) < 0);\n        assert_se(parse_nsec(\"-0.0s \", &u) < 0);\n        assert_se(parse_nsec(\"-0.-0s \", &u) < 0);\n        assert_se(parse_nsec(\"0.-0s \", &u) < 0);\n        assert_se(parse_nsec(\"3.-0s \", &u) < 0);\n        assert_se(parse_nsec(\" infinity .7\", &u) < 0);\n        assert_se(parse_nsec(\".3 infinity\", &u) < 0);\n        assert_se(parse_nsec(\"3.+1s\", &u) < 0);\n        assert_se(parse_nsec(\"3. 1s\", &u) < 0);\n        assert_se(parse_nsec(\"3.s\", &u) < 0);\n        assert_se(parse_nsec(\"12.34.56\", &u) < 0);\n        assert_se(parse_nsec(\"12..34\", &u) < 0);\n        assert_se(parse_nsec(\"..1234\", &u) < 0);\n        assert_se(parse_nsec(\"1234..\", &u) < 0);\n        assert_se(parse_nsec(\"1111111111111y\", &u) == -ERANGE);\n        assert_se(parse_nsec(\"1.111111111111y\", &u) >= 0);\n}\n\nstatic void test_format_timespan_one(usec_t x, usec_t accuracy) {\n        char l[FORMAT_TIMESPAN_MAX];\n        const char *t;\n        usec_t y;\n\n        log_debug(USEC_FMT\"     (at accuracy \"USEC_FMT\")\", x, accuracy);\n\n        assert_se(t = format_timespan(l, sizeof l, x, accuracy));\n        log_debug(\" = <%s>\", t);\n\n        assert_se(parse_sec(t, &y) >= 0);\n        log_debug(\" = \"USEC_FMT, y);\n\n        if (accuracy <= 0)\n                accuracy = 1;\n\n        assert_se(x / accuracy == y / accuracy);\n}\n\nstatic void test_format_timespan_accuracy(usec_t accuracy) {\n        log_info(\"/* %s accuracy=\"USEC_FMT\" */\", __func__, accuracy);\n\n        test_format_timespan_one(0, accuracy);\n        test_format_timespan_one(1, accuracy);\n        test_format_timespan_one(1*USEC_PER_SEC, accuracy);\n        test_format_timespan_one(999*USEC_PER_MSEC, accuracy);\n        test_format_timespan_one(1234567, accuracy);\n        test_format_timespan_one(12, accuracy);\n        test_format_timespan_one(123, accuracy);\n        test_format_timespan_one(1234, accuracy);\n        test_format_timespan_one(12345, accuracy);\n        test_format_timespan_one(123456, accuracy);\n        test_format_timespan_one(1234567, accuracy);\n        test_format_timespan_one(12345678, accuracy);\n        test_format_timespan_one(1200000, accuracy);\n        test_format_timespan_one(1230000, accuracy);\n        test_format_timespan_one(1234000, accuracy);\n        test_format_timespan_one(1234500, accuracy);\n        test_format_timespan_one(1234560, accuracy);\n        test_format_timespan_one(1234567, accuracy);\n        test_format_timespan_one(986087, accuracy);\n        test_format_timespan_one(500 * USEC_PER_MSEC, accuracy);\n        test_format_timespan_one(9*USEC_PER_YEAR/5 - 23, accuracy);\n        test_format_timespan_one(USEC_INFINITY, accuracy);\n}\n\nTEST(format_timespan) {\n        test_format_timespan_accuracy(1);\n        test_format_timespan_accuracy(USEC_PER_MSEC);\n        test_format_timespan_accuracy(USEC_PER_SEC);\n}\n\nTEST(verify_timezone) {\n        assert_se(verify_timezone(\"Europe/Berlin\", LOG_DEBUG) == 0);\n        assert_se(verify_timezone(\"Australia/Sydney\", LOG_DEBUG) == 0);\n        assert_se(verify_timezone(\"Europe/Do not exist\", LOG_DEBUG) == -EINVAL);\n        assert_se(verify_timezone(\"Europe/DoNotExist\", LOG_DEBUG) == -ENOENT);\n        assert_se(verify_timezone(\"/DoNotExist\", LOG_DEBUG) == -EINVAL);\n        assert_se(verify_timezone(\"DoNotExist/\", LOG_DEBUG) == -EINVAL);\n}\n\nTEST(timezone_is_valid) {\n        assert_se(timezone_is_valid(\"Europe/Berlin\", LOG_ERR));\n        assert_se(timezone_is_valid(\"Australia/Sydney\", LOG_ERR));\n        assert_se(!timezone_is_valid(\"Europe/Do not exist\", LOG_ERR));\n}\n\nTEST(get_timezones) {\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        r = get_timezones(&zones);\n        assert_se(r == 0);\n\n        STRV_FOREACH(zone, zones) {\n                r = verify_timezone(*zone, LOG_ERR);\n                log_debug_errno(r, \"verify_timezone(\\\"%s\\\"): %m\", *zone);\n                assert_se(r >= 0 || r == -ENOENT);\n        }\n}\n\nTEST(usec_add) {\n        assert_se(usec_add(0, 0) == 0);\n        assert_se(usec_add(1, 4) == 5);\n        assert_se(usec_add(USEC_INFINITY, 5) == USEC_INFINITY);\n        assert_se(usec_add(5, USEC_INFINITY) == USEC_INFINITY);\n        assert_se(usec_add(USEC_INFINITY-5, 2) == USEC_INFINITY-3);\n        assert_se(usec_add(USEC_INFINITY-2, 2) == USEC_INFINITY);\n        assert_se(usec_add(USEC_INFINITY-1, 2) == USEC_INFINITY);\n        assert_se(usec_add(USEC_INFINITY, 2) == USEC_INFINITY);\n}\n\nTEST(usec_sub_unsigned) {\n        assert_se(usec_sub_unsigned(0, 0) == 0);\n        assert_se(usec_sub_unsigned(0, 2) == 0);\n        assert_se(usec_sub_unsigned(0, USEC_INFINITY) == 0);\n        assert_se(usec_sub_unsigned(1, 0) == 1);\n        assert_se(usec_sub_unsigned(1, 1) == 0);\n        assert_se(usec_sub_unsigned(1, 2) == 0);\n        assert_se(usec_sub_unsigned(1, 3) == 0);\n        assert_se(usec_sub_unsigned(1, USEC_INFINITY) == 0);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, 0) == USEC_INFINITY-1);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, 1) == USEC_INFINITY-2);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, 2) == USEC_INFINITY-3);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, USEC_INFINITY-2) == 1);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, USEC_INFINITY-1) == 0);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, USEC_INFINITY) == 0);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, 0) == USEC_INFINITY);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, 1) == USEC_INFINITY);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, 2) == USEC_INFINITY);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, USEC_INFINITY) == USEC_INFINITY);\n}\n\nTEST(usec_sub_signed) {\n        assert_se(usec_sub_signed(0, 0) == 0);\n        assert_se(usec_sub_signed(4, 1) == 3);\n        assert_se(usec_sub_signed(4, 4) == 0);\n        assert_se(usec_sub_signed(4, 5) == 0);\n        assert_se(usec_sub_signed(USEC_INFINITY-3, -3) == USEC_INFINITY);\n        assert_se(usec_sub_signed(USEC_INFINITY-3, -4) == USEC_INFINITY);\n        assert_se(usec_sub_signed(USEC_INFINITY-3, -5) == USEC_INFINITY);\n        assert_se(usec_sub_signed(USEC_INFINITY, 5) == USEC_INFINITY);\n}\n\nTEST(format_timestamp) {\n        for (unsigned i = 0; i < 100; i++) {\n                char buf[CONST_MAX(FORMAT_TIMESTAMP_MAX, FORMAT_TIMESPAN_MAX)];\n                usec_t x, y;\n\n                x = random_u64_range(2147483600 * USEC_PER_SEC) + 1;\n\n                assert_se(format_timestamp(buf, sizeof(buf), x));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_UNIX));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_UTC));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_US));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x == y);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_US_UTC));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x == y);\n\n                assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n\n                /* The two calls above will run with a slightly different local time. Make sure we are in the same\n                 * range however, but give enough leeway that this is unlikely to explode. And of course,\n                 * format_timestamp_relative() scales the accuracy with the distance from the current time up to one\n                 * month, cover for that too. */\n                assert_se(y > x ? y - x : x - y <= USEC_PER_MONTH + USEC_PER_DAY);\n        }\n}\n\nTEST(FORMAT_TIMESTAMP) {\n        for (unsigned i = 0; i < 100; i++) {\n                _cleanup_free_ char *buf;\n                usec_t x, y;\n\n                x = random_u64_range(2147483600 * USEC_PER_SEC) + 1;\n\n                /* strbuf() is to test the macro in an argument to a function call. */\n                assert_se(buf = strdup(FORMAT_TIMESTAMP(x)));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(streq(FORMAT_TIMESTAMP(x), buf));\n        }\n}\n\nTEST(format_timestamp_relative) {\n        char buf[CONST_MAX(FORMAT_TIMESTAMP_MAX, FORMAT_TIMESPAN_MAX)];\n        usec_t x;\n\n        /* Only testing timestamps in the past so we don't need to add some delta to account for time passing\n         * by while we are running the tests (unless we're running on potatoes and 24 hours somehow passes\n         * between our call to now() and format_timestamp_relative's call to now()). */\n\n        /* Years and months */\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_YEAR + 1*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 year 1 month ago\"));\n\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_YEAR + 2*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 year 2 months ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_YEAR + 1*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 years 1 month ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_YEAR + 2*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 years 2 months ago\"));\n\n        /* Months and days */\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_MONTH + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 month 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_MONTH + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 month 2 days ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_MONTH + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 months 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_MONTH + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 months 2 days ago\"));\n\n        /* Weeks and days */\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_WEEK + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 week 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_WEEK + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 week 2 days ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_WEEK + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 weeks 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_WEEK + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 weeks 2 days ago\"));\n}\n\nstatic void test_format_timestamp_utc_one(usec_t val, const char *result) {\n        char buf[FORMAT_TIMESTAMP_MAX];\n        const char *t;\n\n        t = format_timestamp_style(buf, sizeof(buf), val, TIMESTAMP_UTC);\n        assert_se(streq_ptr(t, result));\n}\n\nTEST(format_timestamp_utc) {\n        test_format_timestamp_utc_one(0, NULL);\n        test_format_timestamp_utc_one(1, \"Thu 1970-01-01 00:00:00 UTC\");\n        test_format_timestamp_utc_one(USEC_PER_SEC, \"Thu 1970-01-01 00:00:01 UTC\");\n\n#if SIZEOF_TIME_T == 8\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX, \"Thu 9999-12-30 23:59:59 UTC\");\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX + 1, \"--- XXXX-XX-XX XX:XX:XX\");\n#elif SIZEOF_TIME_T == 4\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX, \"Tue 2038-01-19 03:14:07 UTC\");\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX + 1, \"--- XXXX-XX-XX XX:XX:XX\");\n#endif\n\n        test_format_timestamp_utc_one(USEC_INFINITY, NULL);\n}\n\nTEST(deserialize_dual_timestamp) {\n        int r;\n        dual_timestamp t;\n\n        r = deserialize_dual_timestamp(\"1234 5678\", &t);\n        assert_se(r == 0);\n        assert_se(t.realtime == 1234);\n        assert_se(t.monotonic == 5678);\n\n        r = deserialize_dual_timestamp(\"1234x 5678\", &t);\n        assert_se(r == -EINVAL);\n\n        r = deserialize_dual_timestamp(\"1234 5678y\", &t);\n        assert_se(r == -EINVAL);\n\n        r = deserialize_dual_timestamp(\"-1234 5678\", &t);\n        assert_se(r == -EINVAL);\n\n        r = deserialize_dual_timestamp(\"1234 -5678\", &t);\n        assert_se(r == -EINVAL);\n\n        /* Check that output wasn't modified. */\n        assert_se(t.realtime == 1234);\n        assert_se(t.monotonic == 5678);\n\n        r = deserialize_dual_timestamp(\"+123 567\", &t);\n        assert_se(r == 0);\n        assert_se(t.realtime == 123);\n        assert_se(t.monotonic == 567);\n\n        /* Check that we get \"infinity\" on overflow. */\n        r = deserialize_dual_timestamp(\"18446744073709551617 0\", &t);\n        assert_se(r == 0);\n        assert_se(t.realtime == USEC_INFINITY);\n        assert_se(t.monotonic == 0);\n}\n\nstatic void assert_similar(usec_t a, usec_t b) {\n        usec_t d;\n\n        if (a > b)\n                d = a - b;\n        else\n                d = b - a;\n\n        assert_se(d < 10*USEC_PER_SEC);\n}\n\nTEST(usec_shift_clock) {\n        usec_t rt, mn, bt;\n\n        rt = now(CLOCK_REALTIME);\n        mn = now(CLOCK_MONOTONIC);\n        bt = now(CLOCK_BOOTTIME);\n\n        assert_se(usec_shift_clock(USEC_INFINITY, CLOCK_REALTIME, CLOCK_MONOTONIC) == USEC_INFINITY);\n\n        assert_similar(usec_shift_clock(rt + USEC_PER_HOUR, CLOCK_REALTIME, CLOCK_MONOTONIC), mn + USEC_PER_HOUR);\n        assert_similar(usec_shift_clock(rt + 2*USEC_PER_HOUR, CLOCK_REALTIME, CLOCK_BOOTTIME), bt + 2*USEC_PER_HOUR);\n        assert_se(usec_shift_clock(rt + 3*USEC_PER_HOUR, CLOCK_REALTIME, CLOCK_REALTIME_ALARM) == rt + 3*USEC_PER_HOUR);\n\n        assert_similar(usec_shift_clock(mn + 4*USEC_PER_HOUR, CLOCK_MONOTONIC, CLOCK_REALTIME_ALARM), rt + 4*USEC_PER_HOUR);\n        assert_similar(usec_shift_clock(mn + 5*USEC_PER_HOUR, CLOCK_MONOTONIC, CLOCK_BOOTTIME), bt + 5*USEC_PER_HOUR);\n        assert_se(usec_shift_clock(mn + 6*USEC_PER_HOUR, CLOCK_MONOTONIC, CLOCK_MONOTONIC) == mn + 6*USEC_PER_HOUR);\n\n        assert_similar(usec_shift_clock(bt + 7*USEC_PER_HOUR, CLOCK_BOOTTIME, CLOCK_MONOTONIC), mn + 7*USEC_PER_HOUR);\n        assert_similar(usec_shift_clock(bt + 8*USEC_PER_HOUR, CLOCK_BOOTTIME, CLOCK_REALTIME_ALARM), rt + 8*USEC_PER_HOUR);\n        assert_se(usec_shift_clock(bt + 9*USEC_PER_HOUR, CLOCK_BOOTTIME, CLOCK_BOOTTIME) == bt + 9*USEC_PER_HOUR);\n\n        if (mn > USEC_PER_MINUTE) {\n                assert_similar(usec_shift_clock(rt - 30 * USEC_PER_SEC, CLOCK_REALTIME_ALARM, CLOCK_MONOTONIC), mn - 30 * USEC_PER_SEC);\n                assert_similar(usec_shift_clock(rt - 50 * USEC_PER_SEC, CLOCK_REALTIME, CLOCK_BOOTTIME), bt - 50 * USEC_PER_SEC);\n        }\n}\n\nTEST(in_utc_timezone) {\n        const char *tz = getenv(\"TZ\");\n\n        assert_se(setenv(\"TZ\", \":UTC\", 1) >= 0);\n        assert_se(in_utc_timezone());\n        assert_se(streq(tzname[0], \"UTC\"));\n        assert_se(streq(tzname[1], \"UTC\"));\n        assert_se(timezone == 0);\n        assert_se(daylight == 0);\n\n        assert_se(setenv(\"TZ\", \":Europe/Berlin\", 1) >= 0);\n        assert_se(!in_utc_timezone());\n        assert_se(streq(tzname[0], \"CET\"));\n        assert_se(streq(tzname[1], \"CEST\"));\n\n        assert_se(set_unset_env(\"TZ\", tz, true) == 0);\n        tzset();\n}\n\nTEST(map_clock_usec) {\n        usec_t nowr, x, y, z;\n\n        x = nowr = now(CLOCK_REALTIME); /* right now */\n        y = map_clock_usec(x, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        z = map_clock_usec(y, CLOCK_MONOTONIC, CLOCK_REALTIME);\n        /* Converting forth and back will introduce inaccuracies, since we cannot query both clocks atomically, but it should be small. Even on the slowest CI smaller than 1h */\n\n        assert_se((z > x ? z - x : x - z) < USEC_PER_HOUR);\n\n        assert_se(nowr < USEC_INFINITY - USEC_PER_DAY*7); /* overflow check */\n        x = nowr + USEC_PER_DAY*7; /* 1 week from now */\n        y = map_clock_usec(x, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        assert_se(y > 0 && y < USEC_INFINITY);\n        z = map_clock_usec(y, CLOCK_MONOTONIC, CLOCK_REALTIME);\n        assert_se(z > 0 && z < USEC_INFINITY);\n        assert_se((z > x ? z - x : x - z) < USEC_PER_HOUR);\n\n        assert_se(nowr > USEC_PER_DAY * 7); /* underflow check */\n        x = nowr - USEC_PER_DAY*7; /* 1 week ago */\n        y = map_clock_usec(x, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        if (y != 0) { /* might underflow if machine is not up long enough for the monotonic clock to be beyond 1w */\n                assert_se(y < USEC_INFINITY);\n                z = map_clock_usec(y, CLOCK_MONOTONIC, CLOCK_REALTIME);\n                assert_se(z > 0 && z < USEC_INFINITY);\n                assert_se((z > x ? z - x : x - z) < USEC_PER_HOUR);\n        }\n}\n\nstatic int intro(void) {\n        log_info(\"realtime=\" USEC_FMT \"\\n\"\n                 \"monotonic=\" USEC_FMT \"\\n\"\n                 \"boottime=\" USEC_FMT \"\\n\",\n                 now(CLOCK_REALTIME),\n                 now(CLOCK_MONOTONIC),\n                 now(CLOCK_BOOTTIME));\n\n        /* Ensure time_t is signed */\n        assert_cc((time_t) -1 < (time_t) 1);\n\n        /* Ensure TIME_T_MAX works correctly */\n        uintmax_t x = TIME_T_MAX;\n        x++;\n        assert_se((time_t) x < 0);\n\n        return EXIT_SUCCESS;\n}\n\nDEFINE_TEST_MAIN_WITH_INTRO(LOG_INFO, intro);\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/timerfd.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"io-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"missing_timerfd.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"process-util.h\"\n#include \"stat-util.h\"\n#include \"string-table.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"time-util.h\"\n\nstatic clockid_t map_clock_id(clockid_t c) {\n\n        /* Some more exotic archs (s390, ppc, \u2026) lack the \"ALARM\" flavour of the clocks. Thus,\n         * clock_gettime() will fail for them. Since they are essentially the same as their non-ALARM\n         * pendants (their only difference is when timers are set on them), let's just map them\n         * accordingly. This way, we can get the correct time even on those archs. */\n\n        switch (c) {\n\n        case CLOCK_BOOTTIME_ALARM:\n                return CLOCK_BOOTTIME;\n\n        case CLOCK_REALTIME_ALARM:\n                return CLOCK_REALTIME;\n\n        default:\n                return c;\n        }\n}\n\nusec_t now(clockid_t clock_id) {\n        struct timespec ts;\n\n        assert_se(clock_gettime(map_clock_id(clock_id), &ts) == 0);\n\n        return timespec_load(&ts);\n}\n\nnsec_t now_nsec(clockid_t clock_id) {\n        struct timespec ts;\n\n        assert_se(clock_gettime(map_clock_id(clock_id), &ts) == 0);\n\n        return timespec_load_nsec(&ts);\n}\n\ndual_timestamp* dual_timestamp_get(dual_timestamp *ts) {\n        assert(ts);\n\n        ts->realtime = now(CLOCK_REALTIME);\n        ts->monotonic = now(CLOCK_MONOTONIC);\n\n        return ts;\n}\n\ntriple_timestamp* triple_timestamp_get(triple_timestamp *ts) {\n        assert(ts);\n\n        ts->realtime = now(CLOCK_REALTIME);\n        ts->monotonic = now(CLOCK_MONOTONIC);\n        ts->boottime = now(CLOCK_BOOTTIME);\n\n        return ts;\n}\n\nstatic usec_t map_clock_usec_internal(usec_t from, usec_t from_base, usec_t to_base) {\n\n        /* Maps the time 'from' between two clocks, based on a common reference point where the first clock\n         * is at 'from_base' and the second clock at 'to_base'. Basically calculates:\n         *\n         *         from - from_base + to_base\n         *\n         * But takes care of overflows/underflows and avoids signed operations. */\n\n        if (from >= from_base) { /* In the future */\n                usec_t delta = from - from_base;\n\n                if (to_base >= USEC_INFINITY - delta) /* overflow? */\n                        return USEC_INFINITY;\n\n                return to_base + delta;\n\n        } else { /* In the past */\n                usec_t delta = from_base - from;\n\n                if (to_base <= delta) /* underflow? */\n                        return 0;\n\n                return to_base - delta;\n        }\n}\n\nusec_t map_clock_usec(usec_t from, clockid_t from_clock, clockid_t to_clock) {\n\n        /* Try to avoid any inaccuracy needlessly added in case we convert from effectively the same clock\n         * onto itself */\n        if (map_clock_id(from_clock) == map_clock_id(to_clock))\n                return from;\n\n        /* Keep infinity as is */\n        if (from == USEC_INFINITY)\n                return from;\n\n        return map_clock_usec_internal(from, now(from_clock), now(to_clock));\n}\n\ndual_timestamp* dual_timestamp_from_realtime(dual_timestamp *ts, usec_t u) {\n        assert(ts);\n\n        if (!timestamp_is_set(u)) {\n                ts->realtime = ts->monotonic = u;\n                return ts;\n        }\n\n        ts->realtime = u;\n        ts->monotonic = map_clock_usec(u, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        return ts;\n}\n\ntriple_timestamp* triple_timestamp_from_realtime(triple_timestamp *ts, usec_t u) {\n        usec_t nowr;\n\n        assert(ts);\n\n        if (!timestamp_is_set(u)) {\n                ts->realtime = ts->monotonic = ts->boottime = u;\n                return ts;\n        }\n\n        nowr = now(CLOCK_REALTIME);\n\n        ts->realtime = u;\n        ts->monotonic = map_clock_usec_internal(u, nowr, now(CLOCK_MONOTONIC));\n        ts->boottime = map_clock_usec_internal(u, nowr, now(CLOCK_BOOTTIME));\n\n        return ts;\n}\n\ndual_timestamp* dual_timestamp_from_monotonic(dual_timestamp *ts, usec_t u) {\n        assert(ts);\n\n        if (u == USEC_INFINITY) {\n                ts->realtime = ts->monotonic = USEC_INFINITY;\n                return ts;\n        }\n\n        ts->monotonic = u;\n        ts->realtime = map_clock_usec(u, CLOCK_MONOTONIC, CLOCK_REALTIME);\n        return ts;\n}\n\ndual_timestamp* dual_timestamp_from_boottime(dual_timestamp *ts, usec_t u) {\n        usec_t nowm;\n\n        if (u == USEC_INFINITY) {\n                ts->realtime = ts->monotonic = USEC_INFINITY;\n                return ts;\n        }\n\n        nowm = now(CLOCK_BOOTTIME);\n        ts->monotonic = map_clock_usec_internal(u, nowm, now(CLOCK_MONOTONIC));\n        ts->realtime = map_clock_usec_internal(u, nowm, now(CLOCK_REALTIME));\n        return ts;\n}\n\nusec_t triple_timestamp_by_clock(triple_timestamp *ts, clockid_t clock) {\n\n        switch (clock) {\n\n        case CLOCK_REALTIME:\n        case CLOCK_REALTIME_ALARM:\n                return ts->realtime;\n\n        case CLOCK_MONOTONIC:\n                return ts->monotonic;\n\n        case CLOCK_BOOTTIME:\n        case CLOCK_BOOTTIME_ALARM:\n                return ts->boottime;\n\n        default:\n                return USEC_INFINITY;\n        }\n}\n\nusec_t timespec_load(const struct timespec *ts) {\n        assert(ts);\n\n        if (ts->tv_sec < 0 || ts->tv_nsec < 0)\n                return USEC_INFINITY;\n\n        if ((usec_t) ts->tv_sec > (UINT64_MAX - (ts->tv_nsec / NSEC_PER_USEC)) / USEC_PER_SEC)\n                return USEC_INFINITY;\n\n        return\n                (usec_t) ts->tv_sec * USEC_PER_SEC +\n                (usec_t) ts->tv_nsec / NSEC_PER_USEC;\n}\n\nnsec_t timespec_load_nsec(const struct timespec *ts) {\n        assert(ts);\n\n        if (ts->tv_sec < 0 || ts->tv_nsec < 0)\n                return NSEC_INFINITY;\n\n        if ((nsec_t) ts->tv_sec >= (UINT64_MAX - ts->tv_nsec) / NSEC_PER_SEC)\n                return NSEC_INFINITY;\n\n        return (nsec_t) ts->tv_sec * NSEC_PER_SEC + (nsec_t) ts->tv_nsec;\n}\n\nstruct timespec *timespec_store(struct timespec *ts, usec_t u)  {\n        assert(ts);\n\n        if (u == USEC_INFINITY ||\n            u / USEC_PER_SEC >= TIME_T_MAX) {\n                ts->tv_sec = (time_t) -1;\n                ts->tv_nsec = -1L;\n                return ts;\n        }\n\n        ts->tv_sec = (time_t) (u / USEC_PER_SEC);\n        ts->tv_nsec = (long) ((u % USEC_PER_SEC) * NSEC_PER_USEC);\n\n        return ts;\n}\n\nstruct timespec *timespec_store_nsec(struct timespec *ts, nsec_t n)  {\n        assert(ts);\n\n        if (n == NSEC_INFINITY ||\n            n / NSEC_PER_SEC >= TIME_T_MAX) {\n                ts->tv_sec = (time_t) -1;\n                ts->tv_nsec = -1L;\n                return ts;\n        }\n\n        ts->tv_sec = (time_t) (n / NSEC_PER_SEC);\n        ts->tv_nsec = (long) (n % NSEC_PER_SEC);\n\n        return ts;\n}\n\nusec_t timeval_load(const struct timeval *tv) {\n        assert(tv);\n\n        if (tv->tv_sec < 0 || tv->tv_usec < 0)\n                return USEC_INFINITY;\n\n        if ((usec_t) tv->tv_sec > (UINT64_MAX - tv->tv_usec) / USEC_PER_SEC)\n                return USEC_INFINITY;\n\n        return\n                (usec_t) tv->tv_sec * USEC_PER_SEC +\n                (usec_t) tv->tv_usec;\n}\n\nstruct timeval *timeval_store(struct timeval *tv, usec_t u) {\n        assert(tv);\n\n        if (u == USEC_INFINITY ||\n            u / USEC_PER_SEC > TIME_T_MAX) {\n                tv->tv_sec = (time_t) -1;\n                tv->tv_usec = (suseconds_t) -1;\n        } else {\n                tv->tv_sec = (time_t) (u / USEC_PER_SEC);\n                tv->tv_usec = (suseconds_t) (u % USEC_PER_SEC);\n        }\n\n        return tv;\n}\n\nchar *format_timestamp_style(\n                char *buf,\n                size_t l,\n                usec_t t,\n                TimestampStyle style) {\n\n        /* The weekdays in non-localized (English) form. We use this instead of the localized form, so that\n         * our generated timestamps may be parsed with parse_timestamp(), and always read the same. */\n        static const char * const weekdays[] = {\n                [0] = \"Sun\",\n                [1] = \"Mon\",\n                [2] = \"Tue\",\n                [3] = \"Wed\",\n                [4] = \"Thu\",\n                [5] = \"Fri\",\n                [6] = \"Sat\",\n        };\n\n        struct tm tm;\n        time_t sec;\n        size_t n;\n        bool utc = false, us = false;\n        int r;\n\n        assert(buf);\n\n        switch (style) {\n                case TIMESTAMP_PRETTY:\n                case TIMESTAMP_UNIX:\n                        break;\n                case TIMESTAMP_US:\n                        us = true;\n                        break;\n                case TIMESTAMP_UTC:\n                        utc = true;\n                        break;\n                case TIMESTAMP_US_UTC:\n                        us = true;\n                        utc = true;\n                        break;\n                default:\n                        return NULL;\n        }\n\n        if (l < (size_t) (3 +                  /* week day */\n                          1 + 10 +             /* space and date */\n                          1 + 8 +              /* space and time */\n                          (us ? 1 + 6 : 0) +   /* \".\" and microsecond part */\n                          1 + 1 +              /* space and shortest possible zone */\n                          1))\n                return NULL; /* Not enough space even for the shortest form. */\n        if (!timestamp_is_set(t))\n                return NULL; /* Timestamp is unset */\n\n        if (style == TIMESTAMP_UNIX) {\n                r = snprintf(buf, l, \"@\" USEC_FMT, t / USEC_PER_SEC);  /* round down \u00b5s \u2192 s */\n                if (r < 0 || (size_t) r >= l)\n                        return NULL; /* Doesn't fit */\n\n                return buf;\n        }\n\n        /* Let's not format times with years > 9999 */\n        if (t > USEC_TIMESTAMP_FORMATTABLE_MAX) {\n                assert(l >= STRLEN(\"--- XXXX-XX-XX XX:XX:XX\") + 1);\n                strcpy(buf, \"--- XXXX-XX-XX XX:XX:XX\");\n                return buf;\n        }\n\n        sec = (time_t) (t / USEC_PER_SEC); /* Round down */\n\n        if (!localtime_or_gmtime_r(&sec, &tm, utc))\n                return NULL;\n\n        /* Start with the week day */\n        assert((size_t) tm.tm_wday < ELEMENTSOF(weekdays));\n        memcpy(buf, weekdays[tm.tm_wday], 4);\n\n        /* Add the main components */\n        if (strftime(buf + 3, l - 3, \" %Y-%m-%d %H:%M:%S\", &tm) <= 0)\n                return NULL; /* Doesn't fit */\n\n        /* Append the microseconds part, if that's requested */\n        if (us) {\n                n = strlen(buf);\n                if (n + 8 > l)\n                        return NULL; /* Microseconds part doesn't fit. */\n\n                sprintf(buf + n, \".%06\"PRI_USEC, t % USEC_PER_SEC);\n        }\n\n        /* Append the timezone */\n        n = strlen(buf);\n        if (utc) {\n                /* If this is UTC then let's explicitly use the \"UTC\" string here, because gmtime_r()\n                 * normally uses the obsolete \"GMT\" instead. */\n                if (n + 5 > l)\n                        return NULL; /* \"UTC\" doesn't fit. */\n\n                strcpy(buf + n, \" UTC\");\n\n        } else if (!isempty(tm.tm_zone)) {\n                size_t tn;\n\n                /* An explicit timezone is specified, let's use it, if it fits */\n                tn = strlen(tm.tm_zone);\n                if (n + 1 + tn + 1 > l) {\n                        /* The full time zone does not fit in. Yuck. */\n\n                        if (n + 1 + _POSIX_TZNAME_MAX + 1 > l)\n                                return NULL; /* Not even enough space for the POSIX minimum (of 6)? In that\n                                              * case, complain that it doesn't fit. */\n\n                        /* So the time zone doesn't fit in fully, but the caller passed enough space for the\n                         * POSIX minimum time zone length. In this case suppress the timezone entirely, in\n                         * order not to dump an overly long, hard to read string on the user. This should be\n                         * safe, because the user will assume the local timezone anyway if none is shown. And\n                         * so does parse_timestamp(). */\n                } else {\n                        buf[n++] = ' ';\n                        strcpy(buf + n, tm.tm_zone);\n                }\n        }\n\n        return buf;\n}\n\nchar *format_timestamp_relative(char *buf, size_t l, usec_t t) {\n        const char *s;\n        usec_t n, d;\n\n        if (!timestamp_is_set(t))\n                return NULL;\n\n        n = now(CLOCK_REALTIME);\n        if (n > t) {\n                d = n - t;\n                s = \"ago\";\n        } else {\n                d = t - n;\n                s = \"left\";\n        }\n\n        if (d >= USEC_PER_YEAR) {\n                usec_t years = d / USEC_PER_YEAR;\n                usec_t months = (d % USEC_PER_YEAR) / USEC_PER_MONTH;\n\n                (void) snprintf(buf, l, USEC_FMT \" %s \" USEC_FMT \" %s %s\",\n                                years,\n                                years == 1 ? \"year\" : \"years\",\n                                months,\n                                months == 1 ? \"month\" : \"months\",\n                                s);\n        } else if (d >= USEC_PER_MONTH) {\n                usec_t months = d / USEC_PER_MONTH;\n                usec_t days = (d % USEC_PER_MONTH) / USEC_PER_DAY;\n\n                (void) snprintf(buf, l, USEC_FMT \" %s \" USEC_FMT \" %s %s\",\n                                months,\n                                months == 1 ? \"month\" : \"months\",\n                                days,\n                                days == 1 ? \"day\" : \"days\",\n                                s);\n        } else if (d >= USEC_PER_WEEK) {\n                usec_t weeks = d / USEC_PER_WEEK;\n                usec_t days = (d % USEC_PER_WEEK) / USEC_PER_DAY;\n\n                (void) snprintf(buf, l, USEC_FMT \" %s \" USEC_FMT \" %s %s\",\n                                weeks,\n                                weeks == 1 ? \"week\" : \"weeks\",\n                                days,\n                                days == 1 ? \"day\" : \"days\",\n                                s);\n        } else if (d >= 2*USEC_PER_DAY)\n                (void) snprintf(buf, l, USEC_FMT \" days %s\", d / USEC_PER_DAY, s);\n        else if (d >= 25*USEC_PER_HOUR)\n                (void) snprintf(buf, l, \"1 day \" USEC_FMT \"h %s\",\n                                (d - USEC_PER_DAY) / USEC_PER_HOUR, s);\n        else if (d >= 6*USEC_PER_HOUR)\n                (void) snprintf(buf, l, USEC_FMT \"h %s\",\n                                d / USEC_PER_HOUR, s);\n        else if (d >= USEC_PER_HOUR)\n                (void) snprintf(buf, l, USEC_FMT \"h \" USEC_FMT \"min %s\",\n                                d / USEC_PER_HOUR,\n                                (d % USEC_PER_HOUR) / USEC_PER_MINUTE, s);\n        else if (d >= 5*USEC_PER_MINUTE)\n                (void) snprintf(buf, l, USEC_FMT \"min %s\",\n                                d / USEC_PER_MINUTE, s);\n        else if (d >= USEC_PER_MINUTE)\n                (void) snprintf(buf, l, USEC_FMT \"min \" USEC_FMT \"s %s\",\n                                d / USEC_PER_MINUTE,\n                                (d % USEC_PER_MINUTE) / USEC_PER_SEC, s);\n        else if (d >= USEC_PER_SEC)\n                (void) snprintf(buf, l, USEC_FMT \"s %s\",\n                                d / USEC_PER_SEC, s);\n        else if (d >= USEC_PER_MSEC)\n                (void) snprintf(buf, l, USEC_FMT \"ms %s\",\n                                d / USEC_PER_MSEC, s);\n        else if (d > 0)\n                (void) snprintf(buf, l, USEC_FMT\"us %s\",\n                                d, s);\n        else\n                (void) snprintf(buf, l, \"now\");\n\n        buf[l-1] = 0;\n        return buf;\n}\n\nchar *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \"y\",     USEC_PER_YEAR   },\n                { \"month\", USEC_PER_MONTH  },\n                { \"w\",     USEC_PER_WEEK   },\n                { \"d\",     USEC_PER_DAY    },\n                { \"h\",     USEC_PER_HOUR   },\n                { \"min\",   USEC_PER_MINUTE },\n                { \"s\",     USEC_PER_SEC    },\n                { \"ms\",    USEC_PER_MSEC   },\n                { \"us\",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \"infinity\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \"0\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \"%s\"USEC_FMT\".%0*\"PRI_USEC\"%s\",\n                                             p > buf ? \" \" : \"\",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \"%s\"USEC_FMT\"%s\",\n                                     p > buf ? \" \" : \"\",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l-1);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n        *p = 0;\n\n        return buf;\n}\n\nstatic int parse_timestamp_impl(const char *t, usec_t *usec, bool with_tz) {\n        static const struct {\n                const char *name;\n                const int nr;\n        } day_nr[] = {\n                { \"Sunday\",    0 },\n                { \"Sun\",       0 },\n                { \"Monday\",    1 },\n                { \"Mon\",       1 },\n                { \"Tuesday\",   2 },\n                { \"Tue\",       2 },\n                { \"Wednesday\", 3 },\n                { \"Wed\",       3 },\n                { \"Thursday\",  4 },\n                { \"Thu\",       4 },\n                { \"Friday\",    5 },\n                { \"Fri\",       5 },\n                { \"Saturday\",  6 },\n                { \"Sat\",       6 },\n        };\n\n        const char *k, *utc = NULL, *tzn = NULL;\n        struct tm tm, copy;\n        time_t x;\n        usec_t x_usec, plus = 0, minus = 0, ret;\n        int r, weekday = -1, dst = -1;\n        size_t i;\n\n        /* Allowed syntaxes:\n         *\n         *   2012-09-22 16:34:22\n         *   2012-09-22 16:34     (seconds will be set to 0)\n         *   2012-09-22           (time will be set to 00:00:00)\n         *   16:34:22             (date will be set to today)\n         *   16:34                (date will be set to today, seconds to 0)\n         *   now\n         *   yesterday            (time is set to 00:00:00)\n         *   today                (time is set to 00:00:00)\n         *   tomorrow             (time is set to 00:00:00)\n         *   +5min\n         *   -5days\n         *   @2147483647          (seconds since epoch)\n         */\n\n        assert(t);\n\n        if (t[0] == '@' && !with_tz)\n                return parse_sec(t + 1, usec);\n\n        ret = now(CLOCK_REALTIME);\n\n        if (!with_tz) {\n                if (streq(t, \"now\"))\n                        goto finish;\n\n                else if (t[0] == '+') {\n                        r = parse_sec(t+1, &plus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n\n                } else if (t[0] == '-') {\n                        r = parse_sec(t+1, &minus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n\n                } else if ((k = endswith(t, \" ago\"))) {\n                        t = strndupa_safe(t, k - t);\n\n                        r = parse_sec(t, &minus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n\n                } else if ((k = endswith(t, \" left\"))) {\n                        t = strndupa_safe(t, k - t);\n\n                        r = parse_sec(t, &plus);\n                        if (r < 0)\n                                return r;\n\n                        goto finish;\n                }\n\n                /* See if the timestamp is suffixed with UTC */\n                utc = endswith_no_case(t, \" UTC\");\n                if (utc)\n                        t = strndupa_safe(t, utc - t);\n                else {\n                        const char *e = NULL;\n                        int j;\n\n                        tzset();\n\n                        /* See if the timestamp is suffixed by either the DST or non-DST local timezone. Note\n                         * that we only support the local timezones here, nothing else. Not because we\n                         * wouldn't want to, but simply because there are no nice APIs available to cover\n                         * this. By accepting the local time zone strings, we make sure that all timestamps\n                         * written by format_timestamp() can be parsed correctly, even though we don't\n                         * support arbitrary timezone specifications. */\n\n                        for (j = 0; j <= 1; j++) {\n\n                                if (isempty(tzname[j]))\n                                        continue;\n\n                                e = endswith_no_case(t, tzname[j]);\n                                if (!e)\n                                        continue;\n                                if (e == t)\n                                        continue;\n                                if (e[-1] != ' ')\n                                        continue;\n\n                                break;\n                        }\n\n                        if (IN_SET(j, 0, 1)) {\n                                /* Found one of the two timezones specified. */\n                                t = strndupa_safe(t, e - t - 1);\n                                dst = j;\n                                tzn = tzname[j];\n                        }\n                }\n        }\n\n        x = (time_t) (ret / USEC_PER_SEC);\n        x_usec = 0;\n\n        if (!localtime_or_gmtime_r(&x, &tm, utc))\n                return -EINVAL;\n\n        tm.tm_isdst = dst;\n        if (!with_tz && tzn)\n                tm.tm_zone = tzn;\n\n        if (streq(t, \"today\")) {\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n\n        } else if (streq(t, \"yesterday\")) {\n                tm.tm_mday--;\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n\n        } else if (streq(t, \"tomorrow\")) {\n                tm.tm_mday++;\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n        }\n\n        for (i = 0; i < ELEMENTSOF(day_nr); i++) {\n                size_t skip;\n\n                if (!startswith_no_case(t, day_nr[i].name))\n                        continue;\n\n                skip = strlen(day_nr[i].name);\n                if (t[skip] != ' ')\n                        continue;\n\n                weekday = day_nr[i].nr;\n                t += skip + 1;\n                break;\n        }\n\n        copy = tm;\n        k = strptime(t, \"%y-%m-%d %H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%Y-%m-%d %H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        /* Support OUTPUT_SHORT and OUTPUT_SHORT_PRECISE formats */\n        tm = copy;\n        k = strptime(t, \"%b %d %H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%y-%m-%d %H:%M\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%Y-%m-%d %H:%M\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%y-%m-%d\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%Y-%m-%d\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;\n                goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%H:%M:%S\", &tm);\n        if (k) {\n                if (*k == '.')\n                        goto parse_usec;\n                else if (*k == 0)\n                        goto from_tm;\n        }\n\n        tm = copy;\n        k = strptime(t, \"%H:%M\", &tm);\n        if (k && *k == 0) {\n                tm.tm_sec = 0;\n                goto from_tm;\n        }\n\n        return -EINVAL;\n\nparse_usec:\n        {\n                unsigned add;\n\n                k++;\n                r = parse_fractional_part_u(&k, 6, &add);\n                if (r < 0)\n                        return -EINVAL;\n\n                if (*k)\n                        return -EINVAL;\n\n                x_usec = add;\n        }\n\nfrom_tm:\n        if (weekday >= 0 && tm.tm_wday != weekday)\n                return -EINVAL;\n\n        x = mktime_or_timegm(&tm, utc);\n        if (x < 0)\n                return -EINVAL;\n\n        ret = (usec_t) x * USEC_PER_SEC + x_usec;\n        if (ret > USEC_TIMESTAMP_FORMATTABLE_MAX)\n                return -EINVAL;\n\nfinish:\n        if (ret + plus < ret) /* overflow? */\n                return -EINVAL;\n        ret += plus;\n        if (ret > USEC_TIMESTAMP_FORMATTABLE_MAX)\n                return -EINVAL;\n\n        if (ret >= minus)\n                ret -= minus;\n        else\n                return -EINVAL;\n\n        if (usec)\n                *usec = ret;\n        return 0;\n}\n\ntypedef struct ParseTimestampResult {\n        usec_t usec;\n        int return_value;\n} ParseTimestampResult;\n\nint parse_timestamp(const char *t, usec_t *usec) {\n        char *last_space, *tz = NULL;\n        ParseTimestampResult *shared, tmp;\n        int r;\n\n        last_space = strrchr(t, ' ');\n        if (last_space != NULL && timezone_is_valid(last_space + 1, LOG_DEBUG))\n                tz = last_space + 1;\n\n        if (!tz || endswith_no_case(t, \" UTC\"))\n                return parse_timestamp_impl(t, usec, false);\n\n        shared = mmap(NULL, sizeof *shared, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);\n        if (shared == MAP_FAILED)\n                return negative_errno();\n\n        r = safe_fork(\"(sd-timestamp)\", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_DEATHSIG|FORK_WAIT, NULL);\n        if (r < 0) {\n                (void) munmap(shared, sizeof *shared);\n                return r;\n        }\n        if (r == 0) {\n                bool with_tz = true;\n                char *colon_tz;\n\n                /* tzset(3) says $TZ should be prefixed with \":\" if we reference timezone files */\n                colon_tz = strjoina(\":\", tz);\n\n                if (setenv(\"TZ\", colon_tz, 1) != 0) {\n                        shared->return_value = negative_errno();\n                        _exit(EXIT_FAILURE);\n                }\n\n                tzset();\n\n                /* If there is a timezone that matches the tzname fields, leave the parsing to the implementation.\n                 * Otherwise just cut it off. */\n                with_tz = !STR_IN_SET(tz, tzname[0], tzname[1]);\n\n                /* Cut off the timezone if we don't need it. */\n                if (with_tz)\n                        t = strndupa_safe(t, last_space - t);\n\n                shared->return_value = parse_timestamp_impl(t, &shared->usec, with_tz);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        tmp = *shared;\n        if (munmap(shared, sizeof *shared) != 0)\n                return negative_errno();\n\n        if (tmp.return_value == 0 && usec)\n                *usec = tmp.usec;\n\n        return tmp.return_value;\n}\n\nstatic const char* extract_multiplier(const char *p, usec_t *multiplier) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \"seconds\", USEC_PER_SEC    },\n                { \"second\",  USEC_PER_SEC    },\n                { \"sec\",     USEC_PER_SEC    },\n                { \"s\",       USEC_PER_SEC    },\n                { \"minutes\", USEC_PER_MINUTE },\n                { \"minute\",  USEC_PER_MINUTE },\n                { \"min\",     USEC_PER_MINUTE },\n                { \"months\",  USEC_PER_MONTH  },\n                { \"month\",   USEC_PER_MONTH  },\n                { \"M\",       USEC_PER_MONTH  },\n                { \"msec\",    USEC_PER_MSEC   },\n                { \"ms\",      USEC_PER_MSEC   },\n                { \"m\",       USEC_PER_MINUTE },\n                { \"hours\",   USEC_PER_HOUR   },\n                { \"hour\",    USEC_PER_HOUR   },\n                { \"hr\",      USEC_PER_HOUR   },\n                { \"h\",       USEC_PER_HOUR   },\n                { \"days\",    USEC_PER_DAY    },\n                { \"day\",     USEC_PER_DAY    },\n                { \"d\",       USEC_PER_DAY    },\n                { \"weeks\",   USEC_PER_WEEK   },\n                { \"week\",    USEC_PER_WEEK   },\n                { \"w\",       USEC_PER_WEEK   },\n                { \"years\",   USEC_PER_YEAR   },\n                { \"year\",    USEC_PER_YEAR   },\n                { \"y\",       USEC_PER_YEAR   },\n                { \"usec\",    1ULL            },\n                { \"us\",      1ULL            },\n                { \"\u00b5s\",      1ULL            },\n        };\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                char *e;\n\n                e = startswith(p, table[i].suffix);\n                if (e) {\n                        *multiplier = table[i].usec;\n                        return e;\n                }\n        }\n\n        return p;\n}\n\nint parse_time(const char *t, usec_t *usec, usec_t default_unit) {\n        const char *p, *s;\n        usec_t r = 0;\n        bool something = false;\n\n        assert(t);\n        assert(default_unit > 0);\n\n        p = t;\n\n        p += strspn(p, WHITESPACE);\n        s = startswith(p, \"infinity\");\n        if (s) {\n                s += strspn(s, WHITESPACE);\n                if (*s != 0)\n                        return -EINVAL;\n\n                if (usec)\n                        *usec = USEC_INFINITY;\n                return 0;\n        }\n\n        for (;;) {\n                usec_t multiplier = default_unit, k;\n                long long l;\n                char *e;\n\n                p += strspn(p, WHITESPACE);\n\n                if (*p == 0) {\n                        if (!something)\n                                return -EINVAL;\n\n                        break;\n                }\n\n                if (*p == '-') /* Don't allow \"-0\" */\n                        return -ERANGE;\n\n                errno = 0;\n                l = strtoll(p, &e, 10);\n                if (errno > 0)\n                        return -errno;\n                if (l < 0)\n                        return -ERANGE;\n\n                if (*e == '.') {\n                        p = e + 1;\n                        p += strspn(p, DIGITS);\n                } else if (e == p)\n                        return -EINVAL;\n                else\n                        p = e;\n\n                s = extract_multiplier(p + strspn(p, WHITESPACE), &multiplier);\n                if (s == p && *s != '\\0')\n                        /* Don't allow '12.34.56', but accept '12.34 .56' or '12.34s.56' */\n                        return -EINVAL;\n\n                p = s;\n\n                if ((usec_t) l >= USEC_INFINITY / multiplier)\n                        return -ERANGE;\n\n                k = (usec_t) l * multiplier;\n                if (k >= USEC_INFINITY - r)\n                        return -ERANGE;\n\n                r += k;\n\n                something = true;\n\n                if (*e == '.') {\n                        usec_t m = multiplier / 10;\n                        const char *b;\n\n                        for (b = e + 1; *b >= '0' && *b <= '9'; b++, m /= 10) {\n                                k = (usec_t) (*b - '0') * m;\n                                if (k >= USEC_INFINITY - r)\n                                        return -ERANGE;\n\n                                r += k;\n                        }\n\n                        /* Don't allow \"0.-0\", \"3.+1\", \"3. 1\", \"3.sec\" or \"3.hoge\" */\n                        if (b == e + 1)\n                                return -EINVAL;\n                }\n        }\n\n        if (usec)\n                *usec = r;\n        return 0;\n}\n\nint parse_sec(const char *t, usec_t *usec) {\n        return parse_time(t, usec, USEC_PER_SEC);\n}\n\nint parse_sec_fix_0(const char *t, usec_t *ret) {\n        usec_t k;\n        int r;\n\n        assert(t);\n        assert(ret);\n\n        r = parse_sec(t, &k);\n        if (r < 0)\n                return r;\n\n        *ret = k == 0 ? USEC_INFINITY : k;\n        return r;\n}\n\nint parse_sec_def_infinity(const char *t, usec_t *ret) {\n        t += strspn(t, WHITESPACE);\n        if (isempty(t)) {\n                *ret = USEC_INFINITY;\n                return 0;\n        }\n        return parse_sec(t, ret);\n}\n\nstatic const char* extract_nsec_multiplier(const char *p, nsec_t *multiplier) {\n        static const struct {\n                const char *suffix;\n                nsec_t nsec;\n        } table[] = {\n                { \"seconds\", NSEC_PER_SEC    },\n                { \"second\",  NSEC_PER_SEC    },\n                { \"sec\",     NSEC_PER_SEC    },\n                { \"s\",       NSEC_PER_SEC    },\n                { \"minutes\", NSEC_PER_MINUTE },\n                { \"minute\",  NSEC_PER_MINUTE },\n                { \"min\",     NSEC_PER_MINUTE },\n                { \"months\",  NSEC_PER_MONTH  },\n                { \"month\",   NSEC_PER_MONTH  },\n                { \"M\",       NSEC_PER_MONTH  },\n                { \"msec\",    NSEC_PER_MSEC   },\n                { \"ms\",      NSEC_PER_MSEC   },\n                { \"m\",       NSEC_PER_MINUTE },\n                { \"hours\",   NSEC_PER_HOUR   },\n                { \"hour\",    NSEC_PER_HOUR   },\n                { \"hr\",      NSEC_PER_HOUR   },\n                { \"h\",       NSEC_PER_HOUR   },\n                { \"days\",    NSEC_PER_DAY    },\n                { \"day\",     NSEC_PER_DAY    },\n                { \"d\",       NSEC_PER_DAY    },\n                { \"weeks\",   NSEC_PER_WEEK   },\n                { \"week\",    NSEC_PER_WEEK   },\n                { \"w\",       NSEC_PER_WEEK   },\n                { \"years\",   NSEC_PER_YEAR   },\n                { \"year\",    NSEC_PER_YEAR   },\n                { \"y\",       NSEC_PER_YEAR   },\n                { \"usec\",    NSEC_PER_USEC   },\n                { \"us\",      NSEC_PER_USEC   },\n                { \"\u00b5s\",      NSEC_PER_USEC   },\n                { \"nsec\",    1ULL            },\n                { \"ns\",      1ULL            },\n                { \"\",        1ULL            }, /* default is nsec */\n        };\n        size_t i;\n\n        for (i = 0; i < ELEMENTSOF(table); i++) {\n                char *e;\n\n                e = startswith(p, table[i].suffix);\n                if (e) {\n                        *multiplier = table[i].nsec;\n                        return e;\n                }\n        }\n\n        return p;\n}\n\nint parse_nsec(const char *t, nsec_t *nsec) {\n        const char *p, *s;\n        nsec_t r = 0;\n        bool something = false;\n\n        assert(t);\n        assert(nsec);\n\n        p = t;\n\n        p += strspn(p, WHITESPACE);\n        s = startswith(p, \"infinity\");\n        if (s) {\n                s += strspn(s, WHITESPACE);\n                if (*s != 0)\n                        return -EINVAL;\n\n                *nsec = NSEC_INFINITY;\n                return 0;\n        }\n\n        for (;;) {\n                nsec_t multiplier = 1, k;\n                long long l;\n                char *e;\n\n                p += strspn(p, WHITESPACE);\n\n                if (*p == 0) {\n                        if (!something)\n                                return -EINVAL;\n\n                        break;\n                }\n\n                if (*p == '-') /* Don't allow \"-0\" */\n                        return -ERANGE;\n\n                errno = 0;\n                l = strtoll(p, &e, 10);\n                if (errno > 0)\n                        return -errno;\n                if (l < 0)\n                        return -ERANGE;\n\n                if (*e == '.') {\n                        p = e + 1;\n                        p += strspn(p, DIGITS);\n                } else if (e == p)\n                        return -EINVAL;\n                else\n                        p = e;\n\n                s = extract_nsec_multiplier(p + strspn(p, WHITESPACE), &multiplier);\n                if (s == p && *s != '\\0')\n                        /* Don't allow '12.34.56', but accept '12.34 .56' or '12.34s.56' */\n                        return -EINVAL;\n\n                p = s;\n\n                if ((nsec_t) l >= NSEC_INFINITY / multiplier)\n                        return -ERANGE;\n\n                k = (nsec_t) l * multiplier;\n                if (k >= NSEC_INFINITY - r)\n                        return -ERANGE;\n\n                r += k;\n\n                something = true;\n\n                if (*e == '.') {\n                        nsec_t m = multiplier / 10;\n                        const char *b;\n\n                        for (b = e + 1; *b >= '0' && *b <= '9'; b++, m /= 10) {\n                                k = (nsec_t) (*b - '0') * m;\n                                if (k >= NSEC_INFINITY - r)\n                                        return -ERANGE;\n\n                                r += k;\n                        }\n\n                        /* Don't allow \"0.-0\", \"3.+1\", \"3. 1\", \"3.sec\" or \"3.hoge\" */\n                        if (b == e + 1)\n                                return -EINVAL;\n                }\n        }\n\n        *nsec = r;\n\n        return 0;\n}\n\nstatic int get_timezones_from_zone1970_tab(char ***ret) {\n        _cleanup_fclose_ FILE *f = NULL;\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        assert(ret);\n\n        f = fopen(\"/usr/share/zoneinfo/zone1970.tab\", \"re\");\n        if (!f)\n                return -errno;\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL, *cc = NULL, *co = NULL, *tz = NULL;\n\n                r = read_line(f, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        break;\n\n                const char *p = line;\n\n                /* Line format is:\n                 * 'country codes' 'coordinates' 'timezone' 'comments' */\n                r = extract_many_words(&p, NULL, 0, &cc, &co, &tz, NULL);\n                if (r < 0)\n                        continue;\n\n                /* Lines that start with # are comments. */\n                if (*cc == '#')\n                        continue;\n\n                r = strv_extend(&zones, tz);\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(zones);\n        return 0;\n}\n\nstatic int get_timezones_from_tzdata_zi(char ***ret) {\n        _cleanup_fclose_ FILE *f = NULL;\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        f = fopen(\"/usr/share/zoneinfo/tzdata.zi\", \"re\");\n        if (!f)\n                return -errno;\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL, *type = NULL, *f1 = NULL, *f2 = NULL;\n\n                r = read_line(f, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        break;\n\n                const char *p = line;\n\n                /* The only lines we care about are Zone and Link lines.\n                 * Zone line format is:\n                 * 'Zone' 'timezone' ...\n                 * Link line format is:\n                 * 'Link' 'target' 'alias'\n                 * See 'man zic' for more detail. */\n                r = extract_many_words(&p, NULL, 0, &type, &f1, &f2, NULL);\n                if (r < 0)\n                        continue;\n\n                char *tz;\n                if (IN_SET(*type, 'Z', 'z'))\n                        /* Zone lines have timezone in field 1. */\n                        tz = f1;\n                else if (IN_SET(*type, 'L', 'l'))\n                        /* Link lines have timezone in field 2. */\n                        tz = f2;\n                else\n                        /* Not a line we care about. */\n                        continue;\n\n                r = strv_extend(&zones, tz);\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(zones);\n        return 0;\n}\n\nint get_timezones(char ***ret) {\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        assert(ret);\n\n        r = get_timezones_from_tzdata_zi(&zones);\n        if (r == -ENOENT) {\n                log_debug_errno(r, \"Could not get timezone data from tzdata.zi, using zone1970.tab: %m\");\n                r = get_timezones_from_zone1970_tab(&zones);\n                if (r == -ENOENT)\n                        log_debug_errno(r, \"Could not get timezone data from zone1970.tab, using UTC: %m\");\n        }\n        if (r < 0 && r != -ENOENT)\n                return r;\n\n        /* Always include UTC */\n        r = strv_extend(&zones, \"UTC\");\n        if (r < 0)\n                return -ENOMEM;\n\n        strv_sort(zones);\n        strv_uniq(zones);\n\n        *ret = TAKE_PTR(zones);\n        return 0;\n}\n\nint verify_timezone(const char *name, int log_level) {\n        bool slash = false;\n        const char *p, *t;\n        _cleanup_close_ int fd = -1;\n        char buf[4];\n        int r;\n\n        if (isempty(name))\n                return -EINVAL;\n\n        /* Always accept \"UTC\" as valid timezone, since it's the fallback, even if user has no timezones installed. */\n        if (streq(name, \"UTC\"))\n                return 0;\n\n        if (name[0] == '/')\n                return -EINVAL;\n\n        for (p = name; *p; p++) {\n                if (!ascii_isdigit(*p) &&\n                    !ascii_isalpha(*p) &&\n                    !IN_SET(*p, '-', '_', '+', '/'))\n                        return -EINVAL;\n\n                if (*p == '/') {\n\n                        if (slash)\n                                return -EINVAL;\n\n                        slash = true;\n                } else\n                        slash = false;\n        }\n\n        if (slash)\n                return -EINVAL;\n\n        if (p - name >= PATH_MAX)\n                return -ENAMETOOLONG;\n\n        t = strjoina(\"/usr/share/zoneinfo/\", name);\n\n        fd = open(t, O_RDONLY|O_CLOEXEC);\n        if (fd < 0)\n                return log_full_errno(log_level, errno, \"Failed to open timezone file '%s': %m\", t);\n\n        r = fd_verify_regular(fd);\n        if (r < 0)\n                return log_full_errno(log_level, r, \"Timezone file '%s' is not  a regular file: %m\", t);\n\n        r = loop_read_exact(fd, buf, 4, false);\n        if (r < 0)\n                return log_full_errno(log_level, r, \"Failed to read from timezone file '%s': %m\", t);\n\n        /* Magic from tzfile(5) */\n        if (memcmp(buf, \"TZif\", 4) != 0)\n                return log_full_errno(log_level, SYNTHETIC_ERRNO(EBADMSG),\n                                      \"Timezone file '%s' has wrong magic bytes\", t);\n\n        return 0;\n}\n\nbool clock_supported(clockid_t clock) {\n        struct timespec ts;\n\n        switch (clock) {\n\n        case CLOCK_MONOTONIC:\n        case CLOCK_REALTIME:\n        case CLOCK_BOOTTIME:\n                /* These three are always available in our baseline, and work in timerfd, as of kernel 3.15 */\n                return true;\n\n        default:\n                /* For everything else, check properly */\n                return clock_gettime(clock, &ts) >= 0;\n        }\n}\n\nint get_timezone(char **ret) {\n        _cleanup_free_ char *t = NULL;\n        const char *e;\n        char *z;\n        int r;\n\n        r = readlink_malloc(\"/etc/localtime\", &t);\n        if (r == -ENOENT) {\n                /* If the symlink does not exist, assume \"UTC\", like glibc does */\n                z = strdup(\"UTC\");\n                if (!z)\n                        return -ENOMEM;\n\n                *ret = z;\n                return 0;\n        }\n        if (r < 0)\n                return r; /* returns EINVAL if not a symlink */\n\n        e = PATH_STARTSWITH_SET(t, \"/usr/share/zoneinfo/\", \"../usr/share/zoneinfo/\");\n        if (!e)\n                return -EINVAL;\n\n        if (!timezone_is_valid(e, LOG_DEBUG))\n                return -EINVAL;\n\n        z = strdup(e);\n        if (!z)\n                return -ENOMEM;\n\n        *ret = z;\n        return 0;\n}\n\ntime_t mktime_or_timegm(struct tm *tm, bool utc) {\n        return utc ? timegm(tm) : mktime(tm);\n}\n\nstruct tm *localtime_or_gmtime_r(const time_t *t, struct tm *tm, bool utc) {\n        return utc ? gmtime_r(t, tm) : localtime_r(t, tm);\n}\n\nstatic uint32_t sysconf_clock_ticks_cached(void) {\n        static thread_local uint32_t hz = 0;\n        long r;\n\n        if (hz == 0) {\n                r = sysconf(_SC_CLK_TCK);\n\n                assert(r > 0);\n                hz = r;\n        }\n\n        return hz;\n}\n\nuint32_t usec_to_jiffies(usec_t u) {\n        uint32_t hz = sysconf_clock_ticks_cached();\n        return DIV_ROUND_UP(u, USEC_PER_SEC / hz);\n}\n\nusec_t jiffies_to_usec(uint32_t j) {\n        uint32_t hz = sysconf_clock_ticks_cached();\n        return DIV_ROUND_UP(j * USEC_PER_SEC, hz);\n}\n\nusec_t usec_shift_clock(usec_t x, clockid_t from, clockid_t to) {\n        usec_t a, b;\n\n        if (x == USEC_INFINITY)\n                return USEC_INFINITY;\n        if (map_clock_id(from) == map_clock_id(to))\n                return x;\n\n        a = now(from);\n        b = now(to);\n\n        if (x > a)\n                /* x lies in the future */\n                return usec_add(b, usec_sub_unsigned(x, a));\n        else\n                /* x lies in the past */\n                return usec_sub_unsigned(b, usec_sub_unsigned(a, x));\n}\n\nbool in_utc_timezone(void) {\n        tzset();\n\n        return timezone == 0 && daylight == 0;\n}\n\nint time_change_fd(void) {\n\n        /* We only care for the cancellation event, hence we set the timeout to the latest possible value. */\n        static const struct itimerspec its = {\n                .it_value.tv_sec = TIME_T_MAX,\n        };\n\n        _cleanup_close_ int fd = -1;\n\n        assert_cc(sizeof(time_t) == sizeof(TIME_T_MAX));\n\n        /* Uses TFD_TIMER_CANCEL_ON_SET to get notifications whenever CLOCK_REALTIME makes a jump relative to\n         * CLOCK_MONOTONIC. */\n\n        fd = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK|TFD_CLOEXEC);\n        if (fd < 0)\n                return -errno;\n\n        if (timerfd_settime(fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its, NULL) >= 0)\n                return TAKE_FD(fd);\n\n        /* So apparently there are systems where time_t is 64bit, but the kernel actually doesn't support\n         * 64bit time_t. In that case configuring a timer to TIME_T_MAX will fail with EOPNOTSUPP or a\n         * similar error. If that's the case let's try with INT32_MAX instead, maybe that works. It's a bit\n         * of a black magic thing though, but what can we do?\n         *\n         * We don't want this code on x86-64, hence let's conditionalize this for systems with 64bit time_t\n         * but where \"long\" is shorter than 64bit, i.e. 32bit archs.\n         *\n         * See: https://github.com/systemd/systemd/issues/14362 */\n\n#if SIZEOF_TIME_T == 8 && ULONG_MAX < UINT64_MAX\n        if (ERRNO_IS_NOT_SUPPORTED(errno) || errno == EOVERFLOW) {\n                static const struct itimerspec its32 = {\n                        .it_value.tv_sec = INT32_MAX,\n                };\n\n                if (timerfd_settime(fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its32, NULL) >= 0)\n                        return TAKE_FD(fd);\n        }\n#endif\n\n        return -errno;\n}\n\nstatic const char* const timestamp_style_table[_TIMESTAMP_STYLE_MAX] = {\n        [TIMESTAMP_PRETTY] = \"pretty\",\n        [TIMESTAMP_US] = \"us\",\n        [TIMESTAMP_UTC] = \"utc\",\n        [TIMESTAMP_US_UTC] = \"us+utc\",\n        [TIMESTAMP_UNIX] = \"unix\",\n};\n\n/* Use the macro for enum \u2192 string to allow for aliases */\n_DEFINE_STRING_TABLE_LOOKUP_TO_STRING(timestamp_style, TimestampStyle,);\n\n/* For the string \u2192 enum mapping we use the generic implementation, but also support two aliases */\nTimestampStyle timestamp_style_from_string(const char *s) {\n        TimestampStyle t;\n\n        t = (TimestampStyle) string_table_lookup(timestamp_style_table, ELEMENTSOF(timestamp_style_table), s);\n        if (t >= 0)\n                return t;\n        if (streq_ptr(s, \"\u00b5s\"))\n                return TIMESTAMP_US;\n        if (streq_ptr(s, \"\u00b5s+utc\"))\n                return TIMESTAMP_US_UTC;\n        return t;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"env-util.h\"\n#include \"random-util.h\"\n#include \"serialize.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nTEST(parse_sec) {\n        usec_t u;\n\n        assert_se(parse_sec(\"5s\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n        assert_se(parse_sec(\"5s500ms\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" 5s 500ms  \", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" 5.5s  \", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" 5.5s 0.5ms \", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC + 500 * USEC_PER_MSEC + 500);\n        assert_se(parse_sec(\" .22s \", &u) >= 0);\n        assert_se(u == 220 * USEC_PER_MSEC);\n        assert_se(parse_sec(\" .50y \", &u) >= 0);\n        assert_se(u == USEC_PER_YEAR / 2);\n        assert_se(parse_sec(\"2.5\", &u) >= 0);\n        assert_se(u == 2500 * USEC_PER_MSEC);\n        assert_se(parse_sec(\".7\", &u) >= 0);\n        assert_se(u == 700 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"23us\", &u) >= 0);\n        assert_se(u == 23);\n        assert_se(parse_sec(\"23\u00b5s\", &u) >= 0);\n        assert_se(u == 23);\n        assert_se(parse_sec(\"infinity\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec(\" infinity \", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec(\"+3.1s\", &u) >= 0);\n        assert_se(u == 3100 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1s.2\", &u) >= 0);\n        assert_se(u == 3300 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1 .2\", &u) >= 0);\n        assert_se(u == 3300 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1 sec .2 sec\", &u) >= 0);\n        assert_se(u == 3300 * USEC_PER_MSEC);\n        assert_se(parse_sec(\"3.1 sec 1.2 sec\", &u) >= 0);\n        assert_se(u == 4300 * USEC_PER_MSEC);\n\n        assert_se(parse_sec(\" xyz \", &u) < 0);\n        assert_se(parse_sec(\"\", &u) < 0);\n        assert_se(parse_sec(\" . \", &u) < 0);\n        assert_se(parse_sec(\" 5. \", &u) < 0);\n        assert_se(parse_sec(\".s \", &u) < 0);\n        assert_se(parse_sec(\"-5s \", &u) < 0);\n        assert_se(parse_sec(\"-0.3s \", &u) < 0);\n        assert_se(parse_sec(\"-0.0s \", &u) < 0);\n        assert_se(parse_sec(\"-0.-0s \", &u) < 0);\n        assert_se(parse_sec(\"0.-0s \", &u) < 0);\n        assert_se(parse_sec(\"3.-0s \", &u) < 0);\n        assert_se(parse_sec(\" infinity .7\", &u) < 0);\n        assert_se(parse_sec(\".3 infinity\", &u) < 0);\n        assert_se(parse_sec(\"3.+1s\", &u) < 0);\n        assert_se(parse_sec(\"3. 1s\", &u) < 0);\n        assert_se(parse_sec(\"3.s\", &u) < 0);\n        assert_se(parse_sec(\"12.34.56\", &u) < 0);\n        assert_se(parse_sec(\"12..34\", &u) < 0);\n        assert_se(parse_sec(\"..1234\", &u) < 0);\n        assert_se(parse_sec(\"1234..\", &u) < 0);\n}\n\nTEST(parse_sec_fix_0) {\n        usec_t u;\n\n        assert_se(parse_sec_fix_0(\"5s\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n        assert_se(parse_sec_fix_0(\"0s\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_fix_0(\"0\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_fix_0(\" 0\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n}\n\nTEST(parse_sec_def_infinity) {\n        usec_t u;\n\n        assert_se(parse_sec_def_infinity(\"5s\", &u) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n        assert_se(parse_sec_def_infinity(\"\", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_def_infinity(\"     \", &u) >= 0);\n        assert_se(u == USEC_INFINITY);\n        assert_se(parse_sec_def_infinity(\"0s\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_sec_def_infinity(\"0\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_sec_def_infinity(\" 0\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_sec_def_infinity(\"-5s\", &u) < 0);\n}\n\nTEST(parse_time) {\n        usec_t u;\n\n        assert_se(parse_time(\"5\", &u, 1) >= 0);\n        assert_se(u == 5);\n\n        assert_se(parse_time(\"5\", &u, USEC_PER_MSEC) >= 0);\n        assert_se(u == 5 * USEC_PER_MSEC);\n\n        assert_se(parse_time(\"5\", &u, USEC_PER_SEC) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"5s\", &u, 1) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"5s\", &u, USEC_PER_SEC) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"5s\", &u, USEC_PER_MSEC) >= 0);\n        assert_se(u == 5 * USEC_PER_SEC);\n\n        assert_se(parse_time(\"11111111111111y\", &u, 1) == -ERANGE);\n        assert_se(parse_time(\"1.1111111111111y\", &u, 1) >= 0);\n}\n\nTEST(parse_nsec) {\n        nsec_t u;\n\n        assert_se(parse_nsec(\"5s\", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC);\n        assert_se(parse_nsec(\"5s500ms\", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" 5s 500ms  \", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" 5.5s  \", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" 5.5s 0.5ms \", &u) >= 0);\n        assert_se(u == 5 * NSEC_PER_SEC + 500 * NSEC_PER_MSEC + 500 * NSEC_PER_USEC);\n        assert_se(parse_nsec(\" .22s \", &u) >= 0);\n        assert_se(u == 220 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\" .50y \", &u) >= 0);\n        assert_se(u == NSEC_PER_YEAR / 2);\n        assert_se(parse_nsec(\"2.5\", &u) >= 0);\n        assert_se(u == 2);\n        assert_se(parse_nsec(\".7\", &u) >= 0);\n        assert_se(u == 0);\n        assert_se(parse_nsec(\"infinity\", &u) >= 0);\n        assert_se(u == NSEC_INFINITY);\n        assert_se(parse_nsec(\" infinity \", &u) >= 0);\n        assert_se(u == NSEC_INFINITY);\n        assert_se(parse_nsec(\"+3.1s\", &u) >= 0);\n        assert_se(u == 3100 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\"3.1s.2\", &u) >= 0);\n        assert_se(u == 3100 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\"3.1 .2s\", &u) >= 0);\n        assert_se(u == 200 * NSEC_PER_MSEC + 3);\n        assert_se(parse_nsec(\"3.1 sec .2 sec\", &u) >= 0);\n        assert_se(u == 3300 * NSEC_PER_MSEC);\n        assert_se(parse_nsec(\"3.1 sec 1.2 sec\", &u) >= 0);\n        assert_se(u == 4300 * NSEC_PER_MSEC);\n\n        assert_se(parse_nsec(\" xyz \", &u) < 0);\n        assert_se(parse_nsec(\"\", &u) < 0);\n        assert_se(parse_nsec(\" . \", &u) < 0);\n        assert_se(parse_nsec(\" 5. \", &u) < 0);\n        assert_se(parse_nsec(\".s \", &u) < 0);\n        assert_se(parse_nsec(\" infinity .7\", &u) < 0);\n        assert_se(parse_nsec(\".3 infinity\", &u) < 0);\n        assert_se(parse_nsec(\"-5s \", &u) < 0);\n        assert_se(parse_nsec(\"-0.3s \", &u) < 0);\n        assert_se(parse_nsec(\"-0.0s \", &u) < 0);\n        assert_se(parse_nsec(\"-0.-0s \", &u) < 0);\n        assert_se(parse_nsec(\"0.-0s \", &u) < 0);\n        assert_se(parse_nsec(\"3.-0s \", &u) < 0);\n        assert_se(parse_nsec(\" infinity .7\", &u) < 0);\n        assert_se(parse_nsec(\".3 infinity\", &u) < 0);\n        assert_se(parse_nsec(\"3.+1s\", &u) < 0);\n        assert_se(parse_nsec(\"3. 1s\", &u) < 0);\n        assert_se(parse_nsec(\"3.s\", &u) < 0);\n        assert_se(parse_nsec(\"12.34.56\", &u) < 0);\n        assert_se(parse_nsec(\"12..34\", &u) < 0);\n        assert_se(parse_nsec(\"..1234\", &u) < 0);\n        assert_se(parse_nsec(\"1234..\", &u) < 0);\n        assert_se(parse_nsec(\"1111111111111y\", &u) == -ERANGE);\n        assert_se(parse_nsec(\"1.111111111111y\", &u) >= 0);\n}\n\nstatic void test_format_timespan_one(usec_t x, usec_t accuracy) {\n        char l[FORMAT_TIMESPAN_MAX];\n        const char *t;\n        usec_t y;\n\n        log_debug(USEC_FMT\"     (at accuracy \"USEC_FMT\")\", x, accuracy);\n\n        assert_se(t = format_timespan(l, sizeof l, x, accuracy));\n        log_debug(\" = <%s>\", t);\n\n        assert_se(parse_sec(t, &y) >= 0);\n        log_debug(\" = \"USEC_FMT, y);\n\n        if (accuracy <= 0)\n                accuracy = 1;\n\n        assert_se(x / accuracy == y / accuracy);\n}\n\nstatic void test_format_timespan_accuracy(usec_t accuracy) {\n        log_info(\"/* %s accuracy=\"USEC_FMT\" */\", __func__, accuracy);\n\n        test_format_timespan_one(0, accuracy);\n        test_format_timespan_one(1, accuracy);\n        test_format_timespan_one(1*USEC_PER_SEC, accuracy);\n        test_format_timespan_one(999*USEC_PER_MSEC, accuracy);\n        test_format_timespan_one(1234567, accuracy);\n        test_format_timespan_one(12, accuracy);\n        test_format_timespan_one(123, accuracy);\n        test_format_timespan_one(1234, accuracy);\n        test_format_timespan_one(12345, accuracy);\n        test_format_timespan_one(123456, accuracy);\n        test_format_timespan_one(1234567, accuracy);\n        test_format_timespan_one(12345678, accuracy);\n        test_format_timespan_one(1200000, accuracy);\n        test_format_timespan_one(1230000, accuracy);\n        test_format_timespan_one(1234000, accuracy);\n        test_format_timespan_one(1234500, accuracy);\n        test_format_timespan_one(1234560, accuracy);\n        test_format_timespan_one(1234567, accuracy);\n        test_format_timespan_one(986087, accuracy);\n        test_format_timespan_one(500 * USEC_PER_MSEC, accuracy);\n        test_format_timespan_one(9*USEC_PER_YEAR/5 - 23, accuracy);\n        test_format_timespan_one(USEC_INFINITY, accuracy);\n}\n\nTEST(format_timespan) {\n        test_format_timespan_accuracy(1);\n        test_format_timespan_accuracy(USEC_PER_MSEC);\n        test_format_timespan_accuracy(USEC_PER_SEC);\n\n        /* See issue #23928. */\n        _cleanup_free_ char *buf;\n        assert_se(buf = new(char, 5));\n        assert_se(buf == format_timespan(buf, 5, 100005, 1000));\n}\n\nTEST(verify_timezone) {\n        assert_se(verify_timezone(\"Europe/Berlin\", LOG_DEBUG) == 0);\n        assert_se(verify_timezone(\"Australia/Sydney\", LOG_DEBUG) == 0);\n        assert_se(verify_timezone(\"Europe/Do not exist\", LOG_DEBUG) == -EINVAL);\n        assert_se(verify_timezone(\"Europe/DoNotExist\", LOG_DEBUG) == -ENOENT);\n        assert_se(verify_timezone(\"/DoNotExist\", LOG_DEBUG) == -EINVAL);\n        assert_se(verify_timezone(\"DoNotExist/\", LOG_DEBUG) == -EINVAL);\n}\n\nTEST(timezone_is_valid) {\n        assert_se(timezone_is_valid(\"Europe/Berlin\", LOG_ERR));\n        assert_se(timezone_is_valid(\"Australia/Sydney\", LOG_ERR));\n        assert_se(!timezone_is_valid(\"Europe/Do not exist\", LOG_ERR));\n}\n\nTEST(get_timezones) {\n        _cleanup_strv_free_ char **zones = NULL;\n        int r;\n\n        r = get_timezones(&zones);\n        assert_se(r == 0);\n\n        STRV_FOREACH(zone, zones) {\n                r = verify_timezone(*zone, LOG_ERR);\n                log_debug_errno(r, \"verify_timezone(\\\"%s\\\"): %m\", *zone);\n                assert_se(r >= 0 || r == -ENOENT);\n        }\n}\n\nTEST(usec_add) {\n        assert_se(usec_add(0, 0) == 0);\n        assert_se(usec_add(1, 4) == 5);\n        assert_se(usec_add(USEC_INFINITY, 5) == USEC_INFINITY);\n        assert_se(usec_add(5, USEC_INFINITY) == USEC_INFINITY);\n        assert_se(usec_add(USEC_INFINITY-5, 2) == USEC_INFINITY-3);\n        assert_se(usec_add(USEC_INFINITY-2, 2) == USEC_INFINITY);\n        assert_se(usec_add(USEC_INFINITY-1, 2) == USEC_INFINITY);\n        assert_se(usec_add(USEC_INFINITY, 2) == USEC_INFINITY);\n}\n\nTEST(usec_sub_unsigned) {\n        assert_se(usec_sub_unsigned(0, 0) == 0);\n        assert_se(usec_sub_unsigned(0, 2) == 0);\n        assert_se(usec_sub_unsigned(0, USEC_INFINITY) == 0);\n        assert_se(usec_sub_unsigned(1, 0) == 1);\n        assert_se(usec_sub_unsigned(1, 1) == 0);\n        assert_se(usec_sub_unsigned(1, 2) == 0);\n        assert_se(usec_sub_unsigned(1, 3) == 0);\n        assert_se(usec_sub_unsigned(1, USEC_INFINITY) == 0);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, 0) == USEC_INFINITY-1);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, 1) == USEC_INFINITY-2);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, 2) == USEC_INFINITY-3);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, USEC_INFINITY-2) == 1);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, USEC_INFINITY-1) == 0);\n        assert_se(usec_sub_unsigned(USEC_INFINITY-1, USEC_INFINITY) == 0);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, 0) == USEC_INFINITY);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, 1) == USEC_INFINITY);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, 2) == USEC_INFINITY);\n        assert_se(usec_sub_unsigned(USEC_INFINITY, USEC_INFINITY) == USEC_INFINITY);\n}\n\nTEST(usec_sub_signed) {\n        assert_se(usec_sub_signed(0, 0) == 0);\n        assert_se(usec_sub_signed(4, 1) == 3);\n        assert_se(usec_sub_signed(4, 4) == 0);\n        assert_se(usec_sub_signed(4, 5) == 0);\n        assert_se(usec_sub_signed(USEC_INFINITY-3, -3) == USEC_INFINITY);\n        assert_se(usec_sub_signed(USEC_INFINITY-3, -4) == USEC_INFINITY);\n        assert_se(usec_sub_signed(USEC_INFINITY-3, -5) == USEC_INFINITY);\n        assert_se(usec_sub_signed(USEC_INFINITY, 5) == USEC_INFINITY);\n}\n\nTEST(format_timestamp) {\n        for (unsigned i = 0; i < 100; i++) {\n                char buf[CONST_MAX(FORMAT_TIMESTAMP_MAX, FORMAT_TIMESPAN_MAX)];\n                usec_t x, y;\n\n                x = random_u64_range(2147483600 * USEC_PER_SEC) + 1;\n\n                assert_se(format_timestamp(buf, sizeof(buf), x));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_UNIX));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_UTC));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_US));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x == y);\n\n                assert_se(format_timestamp_style(buf, sizeof(buf), x, TIMESTAMP_US_UTC));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x == y);\n\n                assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n\n                /* The two calls above will run with a slightly different local time. Make sure we are in the same\n                 * range however, but give enough leeway that this is unlikely to explode. And of course,\n                 * format_timestamp_relative() scales the accuracy with the distance from the current time up to one\n                 * month, cover for that too. */\n                assert_se(y > x ? y - x : x - y <= USEC_PER_MONTH + USEC_PER_DAY);\n        }\n}\n\nTEST(FORMAT_TIMESTAMP) {\n        for (unsigned i = 0; i < 100; i++) {\n                _cleanup_free_ char *buf;\n                usec_t x, y;\n\n                x = random_u64_range(2147483600 * USEC_PER_SEC) + 1;\n\n                /* strbuf() is to test the macro in an argument to a function call. */\n                assert_se(buf = strdup(FORMAT_TIMESTAMP(x)));\n                log_debug(\"%s\", buf);\n                assert_se(parse_timestamp(buf, &y) >= 0);\n                assert_se(x / USEC_PER_SEC == y / USEC_PER_SEC);\n\n                assert_se(streq(FORMAT_TIMESTAMP(x), buf));\n        }\n}\n\nTEST(format_timestamp_relative) {\n        char buf[CONST_MAX(FORMAT_TIMESTAMP_MAX, FORMAT_TIMESPAN_MAX)];\n        usec_t x;\n\n        /* Only testing timestamps in the past so we don't need to add some delta to account for time passing\n         * by while we are running the tests (unless we're running on potatoes and 24 hours somehow passes\n         * between our call to now() and format_timestamp_relative's call to now()). */\n\n        /* Years and months */\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_YEAR + 1*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 year 1 month ago\"));\n\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_YEAR + 2*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 year 2 months ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_YEAR + 1*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 years 1 month ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_YEAR + 2*USEC_PER_MONTH);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 years 2 months ago\"));\n\n        /* Months and days */\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_MONTH + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 month 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_MONTH + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 month 2 days ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_MONTH + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 months 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_MONTH + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 months 2 days ago\"));\n\n        /* Weeks and days */\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_WEEK + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 week 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (1*USEC_PER_WEEK + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"1 week 2 days ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_WEEK + 1*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 weeks 1 day ago\"));\n\n        x = now(CLOCK_REALTIME) - (2*USEC_PER_WEEK + 2*USEC_PER_DAY);\n        assert_se(format_timestamp_relative(buf, sizeof(buf), x));\n        log_debug(\"%s\", buf);\n        assert_se(streq(buf, \"2 weeks 2 days ago\"));\n}\n\nstatic void test_format_timestamp_utc_one(usec_t val, const char *result) {\n        char buf[FORMAT_TIMESTAMP_MAX];\n        const char *t;\n\n        t = format_timestamp_style(buf, sizeof(buf), val, TIMESTAMP_UTC);\n        assert_se(streq_ptr(t, result));\n}\n\nTEST(format_timestamp_utc) {\n        test_format_timestamp_utc_one(0, NULL);\n        test_format_timestamp_utc_one(1, \"Thu 1970-01-01 00:00:00 UTC\");\n        test_format_timestamp_utc_one(USEC_PER_SEC, \"Thu 1970-01-01 00:00:01 UTC\");\n\n#if SIZEOF_TIME_T == 8\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX, \"Thu 9999-12-30 23:59:59 UTC\");\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX + 1, \"--- XXXX-XX-XX XX:XX:XX\");\n#elif SIZEOF_TIME_T == 4\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX, \"Tue 2038-01-19 03:14:07 UTC\");\n        test_format_timestamp_utc_one(USEC_TIMESTAMP_FORMATTABLE_MAX + 1, \"--- XXXX-XX-XX XX:XX:XX\");\n#endif\n\n        test_format_timestamp_utc_one(USEC_INFINITY, NULL);\n}\n\nTEST(deserialize_dual_timestamp) {\n        int r;\n        dual_timestamp t;\n\n        r = deserialize_dual_timestamp(\"1234 5678\", &t);\n        assert_se(r == 0);\n        assert_se(t.realtime == 1234);\n        assert_se(t.monotonic == 5678);\n\n        r = deserialize_dual_timestamp(\"1234x 5678\", &t);\n        assert_se(r == -EINVAL);\n\n        r = deserialize_dual_timestamp(\"1234 5678y\", &t);\n        assert_se(r == -EINVAL);\n\n        r = deserialize_dual_timestamp(\"-1234 5678\", &t);\n        assert_se(r == -EINVAL);\n\n        r = deserialize_dual_timestamp(\"1234 -5678\", &t);\n        assert_se(r == -EINVAL);\n\n        /* Check that output wasn't modified. */\n        assert_se(t.realtime == 1234);\n        assert_se(t.monotonic == 5678);\n\n        r = deserialize_dual_timestamp(\"+123 567\", &t);\n        assert_se(r == 0);\n        assert_se(t.realtime == 123);\n        assert_se(t.monotonic == 567);\n\n        /* Check that we get \"infinity\" on overflow. */\n        r = deserialize_dual_timestamp(\"18446744073709551617 0\", &t);\n        assert_se(r == 0);\n        assert_se(t.realtime == USEC_INFINITY);\n        assert_se(t.monotonic == 0);\n}\n\nstatic void assert_similar(usec_t a, usec_t b) {\n        usec_t d;\n\n        if (a > b)\n                d = a - b;\n        else\n                d = b - a;\n\n        assert_se(d < 10*USEC_PER_SEC);\n}\n\nTEST(usec_shift_clock) {\n        usec_t rt, mn, bt;\n\n        rt = now(CLOCK_REALTIME);\n        mn = now(CLOCK_MONOTONIC);\n        bt = now(CLOCK_BOOTTIME);\n\n        assert_se(usec_shift_clock(USEC_INFINITY, CLOCK_REALTIME, CLOCK_MONOTONIC) == USEC_INFINITY);\n\n        assert_similar(usec_shift_clock(rt + USEC_PER_HOUR, CLOCK_REALTIME, CLOCK_MONOTONIC), mn + USEC_PER_HOUR);\n        assert_similar(usec_shift_clock(rt + 2*USEC_PER_HOUR, CLOCK_REALTIME, CLOCK_BOOTTIME), bt + 2*USEC_PER_HOUR);\n        assert_se(usec_shift_clock(rt + 3*USEC_PER_HOUR, CLOCK_REALTIME, CLOCK_REALTIME_ALARM) == rt + 3*USEC_PER_HOUR);\n\n        assert_similar(usec_shift_clock(mn + 4*USEC_PER_HOUR, CLOCK_MONOTONIC, CLOCK_REALTIME_ALARM), rt + 4*USEC_PER_HOUR);\n        assert_similar(usec_shift_clock(mn + 5*USEC_PER_HOUR, CLOCK_MONOTONIC, CLOCK_BOOTTIME), bt + 5*USEC_PER_HOUR);\n        assert_se(usec_shift_clock(mn + 6*USEC_PER_HOUR, CLOCK_MONOTONIC, CLOCK_MONOTONIC) == mn + 6*USEC_PER_HOUR);\n\n        assert_similar(usec_shift_clock(bt + 7*USEC_PER_HOUR, CLOCK_BOOTTIME, CLOCK_MONOTONIC), mn + 7*USEC_PER_HOUR);\n        assert_similar(usec_shift_clock(bt + 8*USEC_PER_HOUR, CLOCK_BOOTTIME, CLOCK_REALTIME_ALARM), rt + 8*USEC_PER_HOUR);\n        assert_se(usec_shift_clock(bt + 9*USEC_PER_HOUR, CLOCK_BOOTTIME, CLOCK_BOOTTIME) == bt + 9*USEC_PER_HOUR);\n\n        if (mn > USEC_PER_MINUTE) {\n                assert_similar(usec_shift_clock(rt - 30 * USEC_PER_SEC, CLOCK_REALTIME_ALARM, CLOCK_MONOTONIC), mn - 30 * USEC_PER_SEC);\n                assert_similar(usec_shift_clock(rt - 50 * USEC_PER_SEC, CLOCK_REALTIME, CLOCK_BOOTTIME), bt - 50 * USEC_PER_SEC);\n        }\n}\n\nTEST(in_utc_timezone) {\n        const char *tz = getenv(\"TZ\");\n\n        assert_se(setenv(\"TZ\", \":UTC\", 1) >= 0);\n        assert_se(in_utc_timezone());\n        assert_se(streq(tzname[0], \"UTC\"));\n        assert_se(streq(tzname[1], \"UTC\"));\n        assert_se(timezone == 0);\n        assert_se(daylight == 0);\n\n        assert_se(setenv(\"TZ\", \":Europe/Berlin\", 1) >= 0);\n        assert_se(!in_utc_timezone());\n        assert_se(streq(tzname[0], \"CET\"));\n        assert_se(streq(tzname[1], \"CEST\"));\n\n        assert_se(set_unset_env(\"TZ\", tz, true) == 0);\n        tzset();\n}\n\nTEST(map_clock_usec) {\n        usec_t nowr, x, y, z;\n\n        x = nowr = now(CLOCK_REALTIME); /* right now */\n        y = map_clock_usec(x, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        z = map_clock_usec(y, CLOCK_MONOTONIC, CLOCK_REALTIME);\n        /* Converting forth and back will introduce inaccuracies, since we cannot query both clocks atomically, but it should be small. Even on the slowest CI smaller than 1h */\n\n        assert_se((z > x ? z - x : x - z) < USEC_PER_HOUR);\n\n        assert_se(nowr < USEC_INFINITY - USEC_PER_DAY*7); /* overflow check */\n        x = nowr + USEC_PER_DAY*7; /* 1 week from now */\n        y = map_clock_usec(x, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        assert_se(y > 0 && y < USEC_INFINITY);\n        z = map_clock_usec(y, CLOCK_MONOTONIC, CLOCK_REALTIME);\n        assert_se(z > 0 && z < USEC_INFINITY);\n        assert_se((z > x ? z - x : x - z) < USEC_PER_HOUR);\n\n        assert_se(nowr > USEC_PER_DAY * 7); /* underflow check */\n        x = nowr - USEC_PER_DAY*7; /* 1 week ago */\n        y = map_clock_usec(x, CLOCK_REALTIME, CLOCK_MONOTONIC);\n        if (y != 0) { /* might underflow if machine is not up long enough for the monotonic clock to be beyond 1w */\n                assert_se(y < USEC_INFINITY);\n                z = map_clock_usec(y, CLOCK_MONOTONIC, CLOCK_REALTIME);\n                assert_se(z > 0 && z < USEC_INFINITY);\n                assert_se((z > x ? z - x : x - z) < USEC_PER_HOUR);\n        }\n}\n\nstatic int intro(void) {\n        log_info(\"realtime=\" USEC_FMT \"\\n\"\n                 \"monotonic=\" USEC_FMT \"\\n\"\n                 \"boottime=\" USEC_FMT \"\\n\",\n                 now(CLOCK_REALTIME),\n                 now(CLOCK_MONOTONIC),\n                 now(CLOCK_BOOTTIME));\n\n        /* Ensure time_t is signed */\n        assert_cc((time_t) -1 < (time_t) 1);\n\n        /* Ensure TIME_T_MAX works correctly */\n        uintmax_t x = TIME_T_MAX;\n        x++;\n        assert_se((time_t) x < 0);\n\n        return EXIT_SUCCESS;\n}\n\nDEFINE_TEST_MAIN_WITH_INTRO(LOG_INFO, intro);\n"], "filenames": ["src/basic/time-util.c", "src/test/test-time-util.c"], "buggy_code_start_loc": [594, 240], "buggy_code_end_loc": [595, 240], "fixing_code_start_loc": [594, 241], "fixing_code_end_loc": [595, 246], "type": "CWE-193", "message": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.", "other": {"cve": {"id": "CVE-2022-3821", "sourceIdentifier": "secalert@redhat.com", "published": "2022-11-08T22:15:16.700", "lastModified": "2023-05-03T12:16:26.973", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionEndIncluding": "251", "matchCriteriaId": "52303FA5-37AB-4D24-8121-64BBF929D93B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2139327", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/9102c625a673a3246d7e73d8737f3494446bad4e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/issues/23928", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/pull/23933", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RVBQC2VLSDVQAPJTEMTREXDL4HYLXG2P/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-15", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/9102c625a673a3246d7e73d8737f3494446bad4e"}}