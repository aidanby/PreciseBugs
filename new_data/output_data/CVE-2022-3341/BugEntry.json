{"buggy_code": ["/*\n * \"NUT\" Container Format demuxer\n * Copyright (c) 2004-2006 Michael Niedermayer\n * Copyright (c) 2003 Alex Beregszaszi\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/bswap.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/tree.h\"\n#include \"libavcodec/bytestream.h\"\n#include \"avio_internal.h\"\n#include \"isom.h\"\n#include \"nut.h\"\n#include \"riff.h\"\n\n#define NUT_MAX_STREAMS 256    /* arbitrary sanity check value */\n\nstatic int64_t nut_read_timestamp(AVFormatContext *s, int stream_index,\n                                  int64_t *pos_arg, int64_t pos_limit);\n\nstatic int get_str(AVIOContext *bc, char *string, unsigned int maxlen)\n{\n    unsigned int len = ffio_read_varlen(bc);\n\n    if (len && maxlen)\n        avio_read(bc, string, FFMIN(len, maxlen));\n    while (len > maxlen) {\n        avio_r8(bc);\n        len--;\n        if (bc->eof_reached)\n            len = maxlen;\n    }\n\n    if (maxlen)\n        string[FFMIN(len, maxlen - 1)] = 0;\n\n    if (bc->eof_reached)\n        return AVERROR_EOF;\n    if (maxlen == len)\n        return -1;\n    else\n        return 0;\n}\n\nstatic int64_t get_s(AVIOContext *bc)\n{\n    int64_t v = ffio_read_varlen(bc) + 1;\n\n    if (v & 1)\n        return -(v >> 1);\n    else\n        return  (v >> 1);\n}\n\nstatic uint64_t get_fourcc(AVIOContext *bc)\n{\n    unsigned int len = ffio_read_varlen(bc);\n\n    if (len == 2)\n        return avio_rl16(bc);\n    else if (len == 4)\n        return avio_rl32(bc);\n    else {\n        av_log(NULL, AV_LOG_ERROR, \"Unsupported fourcc length %d\\n\", len);\n        return -1;\n    }\n}\n\nstatic int get_packetheader(NUTContext *nut, AVIOContext *bc,\n                            int calculate_checksum, uint64_t startcode)\n{\n    int64_t size;\n\n    startcode = av_be2ne64(startcode);\n    startcode = ff_crc04C11DB7_update(0, (uint8_t*) &startcode, 8);\n\n    ffio_init_checksum(bc, ff_crc04C11DB7_update, startcode);\n    size = ffio_read_varlen(bc);\n    if (size > 4096)\n        avio_rb32(bc);\n    if (ffio_get_checksum(bc) && size > 4096)\n        return -1;\n\n    ffio_init_checksum(bc, calculate_checksum ? ff_crc04C11DB7_update : NULL, 0);\n\n    return size;\n}\n\nstatic uint64_t find_any_startcode(AVIOContext *bc, int64_t pos)\n{\n    uint64_t state = 0;\n\n    if (pos >= 0)\n        /* Note, this may fail if the stream is not seekable, but that should\n         * not matter, as in this case we simply start where we currently are */\n        avio_seek(bc, pos, SEEK_SET);\n    while (!avio_feof(bc)) {\n        state = (state << 8) | avio_r8(bc);\n        if ((state >> 56) != 'N')\n            continue;\n        switch (state) {\n        case MAIN_STARTCODE:\n        case STREAM_STARTCODE:\n        case SYNCPOINT_STARTCODE:\n        case INFO_STARTCODE:\n        case INDEX_STARTCODE:\n            return state;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Find the given startcode.\n * @param code the startcode\n * @param pos the start position of the search, or -1 if the current position\n * @return the position of the startcode or -1 if not found\n */\nstatic int64_t find_startcode(AVIOContext *bc, uint64_t code, int64_t pos)\n{\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        if (startcode == code)\n            return avio_tell(bc) - 8;\n        else if (startcode == 0)\n            return -1;\n        pos = -1;\n    }\n}\n\nstatic int nut_probe(const AVProbeData *p)\n{\n    int i;\n\n    for (i = 0; i < p->buf_size-8; i++) {\n        if (AV_RB32(p->buf+i) != MAIN_STARTCODE>>32)\n            continue;\n        if (AV_RB32(p->buf+i+4) == (MAIN_STARTCODE & 0xFFFFFFFF))\n            return AVPROBE_SCORE_MAX;\n    }\n    return 0;\n}\n\n#define GET_V(dst, check)                                                     \\\n    do {                                                                      \\\n        tmp = ffio_read_varlen(bc);                                           \\\n        if (!(check)) {                                                       \\\n            av_log(s, AV_LOG_ERROR, \"Error \" #dst \" is (%\"PRId64\")\\n\", tmp);  \\\n            ret = AVERROR_INVALIDDATA;                                        \\\n            goto fail;                                                        \\\n        }                                                                     \\\n        dst = tmp;                                                            \\\n    } while (0)\n\nstatic int skip_reserved(AVIOContext *bc, int64_t pos)\n{\n    pos -= avio_tell(bc);\n    if (pos < 0) {\n        avio_seek(bc, pos, SEEK_CUR);\n        return AVERROR_INVALIDDATA;\n    } else {\n        while (pos--) {\n            if (bc->eof_reached)\n                return AVERROR_INVALIDDATA;\n            avio_r8(bc);\n        }\n        return 0;\n    }\n}\n\nstatic int decode_main_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end, length;\n    unsigned int stream_count;\n    int i, j, count, ret;\n    int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;\n\n    length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);\n    end = length + avio_tell(bc);\n\n    nut->version = ffio_read_varlen(bc);\n    if (nut->version < NUT_MIN_VERSION ||\n        nut->version > NUT_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\",\n               nut->version);\n        return AVERROR(ENOSYS);\n    }\n    if (nut->version > 3)\n        nut->minor_version = ffio_read_varlen(bc);\n\n    GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);\n\n    nut->max_distance = ffio_read_varlen(bc);\n    if (nut->max_distance > 65536) {\n        av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);\n        nut->max_distance = 65536;\n    }\n\n    GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);\n    nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));\n    if (!nut->time_base)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < nut->time_base_count; i++) {\n        GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));\n        GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));\n        if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {\n            av_log(s, AV_LOG_ERROR, \"invalid time base %d/%d\\n\",\n                   nut->time_base[i].num,\n                   nut->time_base[i].den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    tmp_pts      = 0;\n    tmp_mul      = 1;\n    tmp_stream   = 0;\n    tmp_head_idx = 0;\n    for (i = 0; i < 256;) {\n        int tmp_flags  = ffio_read_varlen(bc);\n        int tmp_fields = ffio_read_varlen(bc);\n\n        if (tmp_fields > 0)\n            tmp_pts = get_s(bc);\n        if (tmp_fields > 1)\n            tmp_mul = ffio_read_varlen(bc);\n        if (tmp_fields > 2)\n            tmp_stream = ffio_read_varlen(bc);\n        if (tmp_fields > 3)\n            tmp_size = ffio_read_varlen(bc);\n        else\n            tmp_size = 0;\n        if (tmp_fields > 4)\n            tmp_res = ffio_read_varlen(bc);\n        else\n            tmp_res = 0;\n        if (tmp_fields > 5)\n            count = ffio_read_varlen(bc);\n        else\n            count = tmp_mul - (unsigned)tmp_size;\n        if (tmp_fields > 6)\n            get_s(bc);\n        if (tmp_fields > 7)\n            tmp_head_idx = ffio_read_varlen(bc);\n\n        while (tmp_fields-- > 8) {\n            if (bc->eof_reached) {\n                av_log(s, AV_LOG_ERROR, \"reached EOF while decoding main header\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            ffio_read_varlen(bc);\n        }\n\n        if (count <= 0 || count > 256 - (i <= 'N') - i) {\n            av_log(s, AV_LOG_ERROR, \"illegal count %d at %d\\n\", count, i);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_stream >= stream_count) {\n            av_log(s, AV_LOG_ERROR, \"illegal stream number %d >= %d\\n\",\n                   tmp_stream, stream_count);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_size < 0 || tmp_size > INT_MAX - count) {\n            av_log(s, AV_LOG_ERROR, \"illegal size\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (j = 0; j < count; j++, i++) {\n            if (i == 'N') {\n                nut->frame_code[i].flags = FLAG_INVALID;\n                j--;\n                continue;\n            }\n            nut->frame_code[i].flags          = tmp_flags;\n            nut->frame_code[i].pts_delta      = tmp_pts;\n            nut->frame_code[i].stream_id      = tmp_stream;\n            nut->frame_code[i].size_mul       = tmp_mul;\n            nut->frame_code[i].size_lsb       = tmp_size + j;\n            nut->frame_code[i].reserved_count = tmp_res;\n            nut->frame_code[i].header_idx     = tmp_head_idx;\n        }\n    }\n    av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);\n\n    if (end > avio_tell(bc) + 4) {\n        int rem = 1024;\n        GET_V(nut->header_count, tmp < 128U);\n        nut->header_count++;\n        for (i = 1; i < nut->header_count; i++) {\n            uint8_t *hdr;\n            GET_V(nut->header_len[i], tmp > 0 && tmp < 256);\n            if (rem < nut->header_len[i]) {\n                av_log(s, AV_LOG_ERROR,\n                       \"invalid elision header %d : %d > %d\\n\",\n                       i, nut->header_len[i], rem);\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            rem -= nut->header_len[i];\n            hdr = av_malloc(nut->header_len[i]);\n            if (!hdr) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avio_read(bc, hdr, nut->header_len[i]);\n            nut->header[i] = hdr;\n        }\n        av_assert0(nut->header_len[0] == 0);\n    }\n\n    // flags had been effectively introduced in version 4\n    if (nut->version > 3 && end > avio_tell(bc) + 4) {\n        nut->flags = ffio_read_varlen(bc);\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"main header checksum mismatch\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    nut->stream = av_calloc(stream_count, sizeof(StreamContext));\n    if (!nut->stream) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < stream_count; i++)\n        avformat_new_stream(s, NULL);\n\n    return 0;\nfail:\n    av_freep(&nut->time_base);\n    for (i = 1; i < nut->header_count; i++) {\n        av_freep(&nut->header[i]);\n    }\n    nut->header_count = 0;\n    return ret;\n}\n\nstatic int decode_stream_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    StreamContext *stc;\n    int class, stream_id, ret;\n    uint64_t tmp, end;\n    AVStream *st = NULL;\n\n    end  = get_packetheader(nut, bc, 1, STREAM_STARTCODE);\n    end += avio_tell(bc);\n\n    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);\n    stc = &nut->stream[stream_id];\n    st  = s->streams[stream_id];\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    class                = ffio_read_varlen(bc);\n    tmp                  = get_fourcc(bc);\n    st->codecpar->codec_tag = tmp;\n    switch (class) {\n    case 0:\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id   = av_codec_get_id((const AVCodecTag * const []) {\n                                                    ff_nut_video_tags,\n                                                    ff_codec_bmp_tags,\n                                                    ff_codec_movvideo_tags,\n                                                    0\n                                                },\n                                                tmp);\n        break;\n    case 1:\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id   = av_codec_get_id((const AVCodecTag * const []) {\n                                                    ff_nut_audio_tags,\n                                                    ff_codec_wav_tags,\n                                                    ff_nut_audio_extra_tags,\n                                                    0\n                                                },\n                                                tmp);\n        break;\n    case 2:\n        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n        st->codecpar->codec_id   = ff_codec_get_id(ff_nut_subtitle_tags, tmp);\n        break;\n    case 3:\n        st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n        st->codecpar->codec_id   = ff_codec_get_id(ff_nut_data_tags, tmp);\n        break;\n    default:\n        av_log(s, AV_LOG_ERROR, \"unknown stream class (%d)\\n\", class);\n        return AVERROR(ENOSYS);\n    }\n    if (class < 3 && st->codecpar->codec_id == AV_CODEC_ID_NONE)\n        av_log(s, AV_LOG_ERROR,\n               \"Unknown codec tag '0x%04x' for stream number %d\\n\",\n               (unsigned int) tmp, stream_id);\n\n    GET_V(stc->time_base_id, tmp < nut->time_base_count);\n    GET_V(stc->msb_pts_shift, tmp < 16);\n    stc->max_pts_distance = ffio_read_varlen(bc);\n    GET_V(stc->decode_delay, tmp < 1000); // sanity limit, raise this if Moore's law is true\n    st->codecpar->video_delay = stc->decode_delay;\n    ffio_read_varlen(bc); // stream flags\n\n    GET_V(st->codecpar->extradata_size, tmp < (1 << 30));\n    if (st->codecpar->extradata_size) {\n        ret = ff_get_extradata(s, st->codecpar, bc,\n                               st->codecpar->extradata_size);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        GET_V(st->codecpar->width,  tmp > 0);\n        GET_V(st->codecpar->height, tmp > 0);\n        st->sample_aspect_ratio.num = ffio_read_varlen(bc);\n        st->sample_aspect_ratio.den = ffio_read_varlen(bc);\n        if ((!st->sample_aspect_ratio.num) != (!st->sample_aspect_ratio.den)) {\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio %d/%d\\n\",\n                   st->sample_aspect_ratio.num, st->sample_aspect_ratio.den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        ffio_read_varlen(bc); /* csp type */\n    } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        GET_V(st->codecpar->sample_rate, tmp > 0);\n        ffio_read_varlen(bc); // samplerate_den\n        GET_V(st->codecpar->channels, tmp > 0);\n    }\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR,\n               \"stream header %d checksum mismatch\\n\", stream_id);\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    stc->time_base = &nut->time_base[stc->time_base_id];\n    avpriv_set_pts_info(s->streams[stream_id], 63, stc->time_base->num,\n                        stc->time_base->den);\n    return 0;\nfail:\n    if (st && st->codecpar) {\n        av_freep(&st->codecpar->extradata);\n        st->codecpar->extradata_size = 0;\n    }\n    return ret;\n}\n\nstatic void set_disposition_bits(AVFormatContext *avf, char *value,\n                                 int stream_id)\n{\n    int flag = 0, i;\n\n    for (i = 0; ff_nut_dispositions[i].flag; ++i)\n        if (!strcmp(ff_nut_dispositions[i].str, value))\n            flag = ff_nut_dispositions[i].flag;\n    if (!flag)\n        av_log(avf, AV_LOG_INFO, \"unknown disposition type '%s'\\n\", value);\n    for (i = 0; i < avf->nb_streams; ++i)\n        if (stream_id == i || stream_id == -1)\n            avf->streams[i]->disposition |= flag;\n}\n\nstatic int decode_info_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, chapter_start, chapter_len;\n    unsigned int stream_id_plus1, count;\n    int i, ret = 0;\n    int64_t chapter_id, value, end;\n    char name[256], str_value[1024], type_str[256];\n    const char *type;\n    int *event_flags        = NULL;\n    AVChapter *chapter      = NULL;\n    AVStream *st            = NULL;\n    AVDictionary **metadata = NULL;\n    int metadata_flag       = 0;\n\n    end  = get_packetheader(nut, bc, 1, INFO_STARTCODE);\n    end += avio_tell(bc);\n\n    GET_V(stream_id_plus1, tmp <= s->nb_streams);\n    chapter_id    = get_s(bc);\n    chapter_start = ffio_read_varlen(bc);\n    chapter_len   = ffio_read_varlen(bc);\n    count         = ffio_read_varlen(bc);\n\n    if (chapter_id && !stream_id_plus1) {\n        int64_t start = chapter_start / nut->time_base_count;\n        chapter = avpriv_new_chapter(s, chapter_id,\n                                     nut->time_base[chapter_start %\n                                                    nut->time_base_count],\n                                     start, start + chapter_len, NULL);\n        if (!chapter) {\n            av_log(s, AV_LOG_ERROR, \"Could not create chapter.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        metadata = &chapter->metadata;\n    } else if (stream_id_plus1) {\n        st       = s->streams[stream_id_plus1 - 1];\n        metadata = &st->metadata;\n        event_flags = &st->event_flags;\n        metadata_flag = AVSTREAM_EVENT_FLAG_METADATA_UPDATED;\n    } else {\n        metadata = &s->metadata;\n        event_flags = &s->event_flags;\n        metadata_flag = AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    }\n\n    for (i = 0; i < count; i++) {\n        ret = get_str(bc, name, sizeof(name));\n        if (ret < 0) {\n            av_log(s, AV_LOG_ERROR, \"get_str failed while decoding info header\\n\");\n            return ret;\n        }\n        value = get_s(bc);\n        str_value[0] = 0;\n\n        if (value == -1) {\n            type = \"UTF-8\";\n            ret = get_str(bc, str_value, sizeof(str_value));\n        } else if (value == -2) {\n            ret = get_str(bc, type_str, sizeof(type_str));\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"get_str failed while decoding info header\\n\");\n                return ret;\n            }\n            type = type_str;\n            ret = get_str(bc, str_value, sizeof(str_value));\n        } else if (value == -3) {\n            type  = \"s\";\n            value = get_s(bc);\n        } else if (value == -4) {\n            type  = \"t\";\n            value = ffio_read_varlen(bc);\n        } else if (value < -4) {\n            type = \"r\";\n            get_s(bc);\n        } else {\n            type = \"v\";\n        }\n\n        if (ret < 0) {\n            av_log(s, AV_LOG_ERROR, \"get_str failed while decoding info header\\n\");\n            return ret;\n        }\n\n        if (stream_id_plus1 > s->nb_streams) {\n            av_log(s, AV_LOG_WARNING,\n                   \"invalid stream id %d for info packet\\n\",\n                   stream_id_plus1);\n            continue;\n        }\n\n        if (!strcmp(type, \"UTF-8\")) {\n            if (chapter_id == 0 && !strcmp(name, \"Disposition\")) {\n                set_disposition_bits(s, str_value, stream_id_plus1 - 1);\n                continue;\n            }\n\n            if (stream_id_plus1 && !strcmp(name, \"r_frame_rate\")) {\n                sscanf(str_value, \"%d/%d\", &st->r_frame_rate.num, &st->r_frame_rate.den);\n                if (st->r_frame_rate.num >= 1000LL*st->r_frame_rate.den ||\n                    st->r_frame_rate.num < 0 || st->r_frame_rate.den < 0)\n                    st->r_frame_rate.num = st->r_frame_rate.den = 0;\n                continue;\n            }\n\n            if (metadata && av_strcasecmp(name, \"Uses\") &&\n                av_strcasecmp(name, \"Depends\") && av_strcasecmp(name, \"Replaces\")) {\n                if (event_flags)\n                    *event_flags |= metadata_flag;\n                av_dict_set(metadata, name, str_value, 0);\n            }\n        }\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"info header checksum mismatch\\n\");\n        return AVERROR_INVALIDDATA;\n    }\nfail:\n    return FFMIN(ret, 0);\n}\n\nstatic int decode_syncpoint(NUTContext *nut, int64_t *ts, int64_t *back_ptr)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    int64_t end;\n    uint64_t tmp;\n    int ret;\n\n    nut->last_syncpoint_pos = avio_tell(bc) - 8;\n\n    end  = get_packetheader(nut, bc, 1, SYNCPOINT_STARTCODE);\n    end += avio_tell(bc);\n\n    tmp       = ffio_read_varlen(bc);\n    *back_ptr = nut->last_syncpoint_pos - 16 * ffio_read_varlen(bc);\n    if (*back_ptr < 0)\n        return AVERROR_INVALIDDATA;\n\n    ff_nut_reset_ts(nut, nut->time_base[tmp % nut->time_base_count],\n                    tmp / nut->time_base_count);\n\n    if (nut->flags & NUT_BROADCAST) {\n        tmp = ffio_read_varlen(bc);\n        av_log(s, AV_LOG_VERBOSE, \"Syncpoint wallclock %\"PRId64\"\\n\",\n               av_rescale_q(tmp / nut->time_base_count,\n                            nut->time_base[tmp % nut->time_base_count],\n                            AV_TIME_BASE_Q));\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"sync point checksum mismatch\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    *ts = tmp / nut->time_base_count *\n          av_q2d(nut->time_base[tmp % nut->time_base_count]) * AV_TIME_BASE;\n\n    if ((ret = ff_nut_add_sp(nut, nut->last_syncpoint_pos, *back_ptr, *ts)) < 0)\n        return ret;\n\n    return 0;\n}\n\n//FIXME calculate exactly, this is just a good approximation.\nstatic int64_t find_duration(NUTContext *nut, int64_t filesize)\n{\n    AVFormatContext *s = nut->avf;\n    int64_t duration = 0;\n\n    ff_find_last_ts(s, -1, &duration, NULL, nut_read_timestamp);\n\n    if(duration > 0)\n        s->duration_estimation_method = AVFMT_DURATION_FROM_PTS;\n    return duration;\n}\n\nstatic int find_and_decode_index(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end;\n    int i, j, syncpoint_count;\n    int64_t filesize = avio_size(bc);\n    int64_t *syncpoints = NULL;\n    uint64_t max_pts;\n    int8_t *has_keyframe = NULL;\n    int ret = AVERROR_INVALIDDATA;\n\n    if(filesize <= 0)\n        return -1;\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n        av_log(s, AV_LOG_WARNING, \"no index at the end\\n\");\n\n        if(s->duration<=0)\n            s->duration = find_duration(nut, filesize);\n        return ret;\n    }\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n    end += avio_tell(bc);\n\n    max_pts = ffio_read_varlen(bc);\n    s->duration = av_rescale_q(max_pts / nut->time_base_count,\n                               nut->time_base[max_pts % nut->time_base_count],\n                               AV_TIME_BASE_Q);\n    s->duration_estimation_method = AVFMT_DURATION_FROM_PTS;\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n    syncpoints   = av_malloc_array(syncpoint_count, sizeof(int64_t));\n    has_keyframe = av_malloc_array(syncpoint_count + 1, sizeof(int8_t));\n    if (!syncpoints || !has_keyframe) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < syncpoint_count; i++) {\n        syncpoints[i] = ffio_read_varlen(bc);\n        if (syncpoints[i] <= 0)\n            goto fail;\n        if (i)\n            syncpoints[i] += syncpoints[i - 1];\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        int64_t last_pts = -1;\n        for (j = 0; j < syncpoint_count;) {\n            uint64_t x = ffio_read_varlen(bc);\n            int type   = x & 1;\n            int n      = j;\n            x >>= 1;\n            if (type) {\n                int flag = x & 1;\n                x >>= 1;\n                if (n + x >= syncpoint_count + 1) {\n                    av_log(s, AV_LOG_ERROR, \"index overflow A %d + %\"PRIu64\" >= %d\\n\", n, x, syncpoint_count + 1);\n                    goto fail;\n                }\n                while (x--)\n                    has_keyframe[n++] = flag;\n                has_keyframe[n++] = !flag;\n            } else {\n                if (x <= 1) {\n                    av_log(s, AV_LOG_ERROR, \"index: x %\"PRIu64\" is invalid\\n\", x);\n                    goto fail;\n                }\n                while (x != 1) {\n                    if (n >= syncpoint_count + 1) {\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n                        goto fail;\n                    }\n                    has_keyframe[n++] = x & 1;\n                    x >>= 1;\n                }\n            }\n            if (has_keyframe[0]) {\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n                goto fail;\n            }\n            av_assert0(n <= syncpoint_count + 1);\n            for (; j < n && j < syncpoint_count; j++) {\n                if (has_keyframe[j]) {\n                    uint64_t B, A = ffio_read_varlen(bc);\n                    if (!A) {\n                        A = ffio_read_varlen(bc);\n                        B = ffio_read_varlen(bc);\n                        // eor_pts[j][i] = last_pts + A + B\n                    } else\n                        B = 0;\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n                    last_pts += A + B;\n                }\n            }\n        }\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n        goto fail;\n    }\n    ret = 0;\n\nfail:\n    av_free(syncpoints);\n    av_free(has_keyframe);\n    return ret;\n}\n\nstatic int nut_read_close(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    int i;\n\n    av_freep(&nut->time_base);\n    av_freep(&nut->stream);\n    ff_nut_free_sp(nut);\n    for (i = 1; i < nut->header_count; i++)\n        av_freep(&nut->header[i]);\n\n    return 0;\n}\n\nstatic int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}\n\nstatic int read_sm_data(AVFormatContext *s, AVIOContext *bc, AVPacket *pkt, int is_meta, int64_t maxpos)\n{\n    int count = ffio_read_varlen(bc);\n    int skip_start = 0;\n    int skip_end = 0;\n    int channels = 0;\n    int64_t channel_layout = 0;\n    int sample_rate = 0;\n    int width = 0;\n    int height = 0;\n    int i, ret;\n\n    for (i=0; i<count; i++) {\n        uint8_t name[256], str_value[256], type_str[256];\n        int value;\n        if (avio_tell(bc) >= maxpos)\n            return AVERROR_INVALIDDATA;\n        ret = get_str(bc, name, sizeof(name));\n        if (ret < 0) {\n            av_log(s, AV_LOG_ERROR, \"get_str failed while reading sm data\\n\");\n            return ret;\n        }\n        value = get_s(bc);\n\n        if (value == -1) {\n            ret = get_str(bc, str_value, sizeof(str_value));\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"get_str failed while reading sm data\\n\");\n                return ret;\n            }\n            av_log(s, AV_LOG_WARNING, \"Unknown string %s / %s\\n\", name, str_value);\n        } else if (value == -2) {\n            uint8_t *dst = NULL;\n            int64_t v64, value_len;\n\n            ret = get_str(bc, type_str, sizeof(type_str));\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"get_str failed while reading sm data\\n\");\n                return ret;\n            }\n            value_len = ffio_read_varlen(bc);\n            if (value_len < 0 || value_len >= maxpos - avio_tell(bc))\n                return AVERROR_INVALIDDATA;\n            if (!strcmp(name, \"Palette\")) {\n                dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, value_len);\n            } else if (!strcmp(name, \"Extradata\")) {\n                dst = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, value_len);\n            } else if (sscanf(name, \"CodecSpecificSide%\"SCNd64\"\", &v64) == 1) {\n                dst = av_packet_new_side_data(pkt, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL, value_len + 8);\n                if(!dst)\n                    return AVERROR(ENOMEM);\n                AV_WB64(dst, v64);\n                dst += 8;\n            } else if (!strcmp(name, \"ChannelLayout\") && value_len == 8) {\n                channel_layout = avio_rl64(bc);\n                continue;\n            } else {\n                av_log(s, AV_LOG_WARNING, \"Unknown data %s / %s\\n\", name, type_str);\n                avio_skip(bc, value_len);\n                continue;\n            }\n            if(!dst)\n                return AVERROR(ENOMEM);\n            avio_read(bc, dst, value_len);\n        } else if (value == -3) {\n            value = get_s(bc);\n        } else if (value == -4) {\n            value = ffio_read_varlen(bc);\n        } else if (value < -4) {\n            get_s(bc);\n        } else {\n            if (!strcmp(name, \"SkipStart\")) {\n                skip_start = value;\n            } else if (!strcmp(name, \"SkipEnd\")) {\n                skip_end = value;\n            } else if (!strcmp(name, \"Channels\")) {\n                channels = value;\n            } else if (!strcmp(name, \"SampleRate\")) {\n                sample_rate = value;\n            } else if (!strcmp(name, \"Width\")) {\n                width = value;\n            } else if (!strcmp(name, \"Height\")) {\n                height = value;\n            } else {\n                av_log(s, AV_LOG_WARNING, \"Unknown integer %s\\n\", name);\n            }\n        }\n    }\n\n    if (channels || channel_layout || sample_rate || width || height) {\n        uint8_t *dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PARAM_CHANGE, 28);\n        if (!dst)\n            return AVERROR(ENOMEM);\n        bytestream_put_le32(&dst,\n                            AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT*(!!channels) +\n                            AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT*(!!channel_layout) +\n                            AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE*(!!sample_rate) +\n                            AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS*(!!(width|height))\n                           );\n        if (channels)\n            bytestream_put_le32(&dst, channels);\n        if (channel_layout)\n            bytestream_put_le64(&dst, channel_layout);\n        if (sample_rate)\n            bytestream_put_le32(&dst, sample_rate);\n        if (width || height){\n            bytestream_put_le32(&dst, width);\n            bytestream_put_le32(&dst, height);\n        }\n    }\n\n    if (skip_start || skip_end) {\n        uint8_t *dst = av_packet_new_side_data(pkt, AV_PKT_DATA_SKIP_SAMPLES, 10);\n        if (!dst)\n            return AVERROR(ENOMEM);\n        AV_WL32(dst, skip_start);\n        AV_WL32(dst+4, skip_end);\n    }\n\n    if (avio_tell(bc) >= maxpos)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int decode_frame_header(NUTContext *nut, int64_t *pts, int *stream_id,\n                               uint8_t *header_idx, int frame_code)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    StreamContext *stc;\n    int size, flags, size_mul, pts_delta, i, reserved_count, ret;\n    uint64_t tmp;\n\n    if (!(nut->flags & NUT_PIPE) &&\n        avio_tell(bc) > nut->last_syncpoint_pos + nut->max_distance) {\n        av_log(s, AV_LOG_ERROR,\n               \"Last frame must have been damaged %\"PRId64\" > %\"PRId64\" + %d\\n\",\n               avio_tell(bc), nut->last_syncpoint_pos, nut->max_distance);\n        return AVERROR_INVALIDDATA;\n    }\n\n    flags          = nut->frame_code[frame_code].flags;\n    size_mul       = nut->frame_code[frame_code].size_mul;\n    size           = nut->frame_code[frame_code].size_lsb;\n    *stream_id     = nut->frame_code[frame_code].stream_id;\n    pts_delta      = nut->frame_code[frame_code].pts_delta;\n    reserved_count = nut->frame_code[frame_code].reserved_count;\n    *header_idx    = nut->frame_code[frame_code].header_idx;\n\n    if (flags & FLAG_INVALID)\n        return AVERROR_INVALIDDATA;\n    if (flags & FLAG_CODED)\n        flags ^= ffio_read_varlen(bc);\n    if (flags & FLAG_STREAM_ID) {\n        GET_V(*stream_id, tmp < s->nb_streams);\n    }\n    stc = &nut->stream[*stream_id];\n    if (flags & FLAG_CODED_PTS) {\n        int64_t coded_pts = ffio_read_varlen(bc);\n        // FIXME check last_pts validity?\n        if (coded_pts < (1LL << stc->msb_pts_shift)) {\n            *pts = ff_lsb2full(stc, coded_pts);\n        } else\n            *pts = coded_pts - (1LL << stc->msb_pts_shift);\n    } else\n        *pts = stc->last_pts + pts_delta;\n    if (flags & FLAG_SIZE_MSB)\n        size += size_mul * ffio_read_varlen(bc);\n    if (flags & FLAG_MATCH_TIME)\n        get_s(bc);\n    if (flags & FLAG_HEADER_IDX)\n        *header_idx = ffio_read_varlen(bc);\n    if (flags & FLAG_RESERVED)\n        reserved_count = ffio_read_varlen(bc);\n    for (i = 0; i < reserved_count; i++) {\n        if (bc->eof_reached) {\n            av_log(s, AV_LOG_ERROR, \"reached EOF while decoding frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ffio_read_varlen(bc);\n    }\n\n    if (*header_idx >= (unsigned)nut->header_count) {\n        av_log(s, AV_LOG_ERROR, \"header_idx invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (size > 4096)\n        *header_idx = 0;\n    size -= nut->header_len[*header_idx];\n\n    if (flags & FLAG_CHECKSUM) {\n        avio_rb32(bc); // FIXME check this\n    } else if (!(nut->flags & NUT_PIPE) &&\n               size > 2 * nut->max_distance ||\n               FFABS(stc->last_pts - *pts) > stc->max_pts_distance) {\n        av_log(s, AV_LOG_ERROR, \"frame size > 2max_distance and no checksum\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    stc->last_pts   = *pts;\n    stc->last_flags = flags;\n\n    return size;\nfail:\n    return ret;\n}\n\nstatic int decode_frame(NUTContext *nut, AVPacket *pkt, int frame_code)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    int size, stream_id, discard, ret;\n    int64_t pts, last_IP_pts;\n    StreamContext *stc;\n    uint8_t header_idx;\n\n    size = decode_frame_header(nut, &pts, &stream_id, &header_idx, frame_code);\n    if (size < 0)\n        return size;\n\n    stc = &nut->stream[stream_id];\n\n    if (stc->last_flags & FLAG_KEY)\n        stc->skip_until_key_frame = 0;\n\n    discard     = s->streams[stream_id]->discard;\n    last_IP_pts = ffstream(s->streams[stream_id])->last_IP_pts;\n    if ((discard >= AVDISCARD_NONKEY && !(stc->last_flags & FLAG_KEY)) ||\n        (discard >= AVDISCARD_BIDIR  && last_IP_pts != AV_NOPTS_VALUE &&\n         last_IP_pts > pts) ||\n        discard >= AVDISCARD_ALL ||\n        stc->skip_until_key_frame) {\n        avio_skip(bc, size);\n        return 1;\n    }\n\n    ret = av_new_packet(pkt, size + nut->header_len[header_idx]);\n    if (ret < 0)\n        return ret;\n    if (nut->header[header_idx])\n        memcpy(pkt->data, nut->header[header_idx], nut->header_len[header_idx]);\n    pkt->pos = avio_tell(bc); // FIXME\n    if (stc->last_flags & FLAG_SM_DATA) {\n        int sm_size;\n        if (read_sm_data(s, bc, pkt, 0, pkt->pos + size) < 0) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (read_sm_data(s, bc, pkt, 1, pkt->pos + size) < 0) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        sm_size = avio_tell(bc) - pkt->pos;\n        size      -= sm_size;\n        pkt->size -= sm_size;\n    }\n\n    ret = avio_read(bc, pkt->data + nut->header_len[header_idx], size);\n    if (ret != size) {\n        if (ret < 0)\n            goto fail;\n    }\n    av_shrink_packet(pkt, nut->header_len[header_idx] + ret);\n\n    pkt->stream_index = stream_id;\n    if (stc->last_flags & FLAG_KEY)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n    pkt->pts = pts;\n\n    return 0;\nfail:\n    av_packet_unref(pkt);\n    return ret;\n}\n\nstatic int nut_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int i, frame_code = 0, ret, skip;\n    int64_t ts, back_ptr;\n\n    for (;;) {\n        int64_t pos  = avio_tell(bc);\n        uint64_t tmp = nut->next_startcode;\n        nut->next_startcode = 0;\n\n        if (tmp) {\n            pos -= 8;\n        } else {\n            frame_code = avio_r8(bc);\n            if (avio_feof(bc))\n                return AVERROR_EOF;\n            if (frame_code == 'N') {\n                tmp = frame_code;\n                for (i = 1; i < 8; i++)\n                    tmp = (tmp << 8) + avio_r8(bc);\n            }\n        }\n        switch (tmp) {\n        case MAIN_STARTCODE:\n        case STREAM_STARTCODE:\n        case INDEX_STARTCODE:\n            skip = get_packetheader(nut, bc, 0, tmp);\n            avio_skip(bc, skip);\n            break;\n        case INFO_STARTCODE:\n            if (decode_info_header(nut) < 0)\n                goto resync;\n            break;\n        case SYNCPOINT_STARTCODE:\n            if (decode_syncpoint(nut, &ts, &back_ptr) < 0)\n                goto resync;\n            frame_code = avio_r8(bc);\n        case 0:\n            ret = decode_frame(nut, pkt, frame_code);\n            if (ret == 0)\n                return 0;\n            else if (ret == 1) // OK but discard packet\n                break;\n        default:\nresync:\n            av_log(s, AV_LOG_DEBUG, \"syncing from %\"PRId64\"\\n\", pos);\n            tmp = find_any_startcode(bc, FFMAX(nut->last_syncpoint_pos, nut->last_resync_pos) + 1);\n            nut->last_resync_pos = avio_tell(bc);\n            if (tmp == 0)\n                return AVERROR_INVALIDDATA;\n            av_log(s, AV_LOG_DEBUG, \"sync\\n\");\n            nut->next_startcode = tmp;\n        }\n    }\n}\n\nstatic int64_t nut_read_timestamp(AVFormatContext *s, int stream_index,\n                                  int64_t *pos_arg, int64_t pos_limit)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos, pts, back_ptr;\n    av_log(s, AV_LOG_DEBUG, \"read_timestamp(X,%d,%\"PRId64\",%\"PRId64\")\\n\",\n           stream_index, *pos_arg, pos_limit);\n\n    pos = *pos_arg;\n    do {\n        pos = find_startcode(bc, SYNCPOINT_STARTCODE, pos) + 1;\n        if (pos < 1) {\n            av_log(s, AV_LOG_ERROR, \"read_timestamp failed.\\n\");\n            return AV_NOPTS_VALUE;\n        }\n    } while (decode_syncpoint(nut, &pts, &back_ptr) < 0);\n    *pos_arg = pos - 1;\n    av_assert0(nut->last_syncpoint_pos == *pos_arg);\n\n    av_log(s, AV_LOG_DEBUG, \"return %\"PRId64\" %\"PRId64\"\\n\", pts, back_ptr);\n    if (stream_index == -2)\n        return back_ptr;\n    av_assert0(stream_index == -1);\n    return pts;\n}\n\nstatic int read_seek(AVFormatContext *s, int stream_index,\n                     int64_t pts, int flags)\n{\n    NUTContext *nut    = s->priv_data;\n    AVStream *st       = s->streams[stream_index];\n    FFStream *const sti = ffstream(st);\n    Syncpoint dummy    = { .ts = pts * av_q2d(st->time_base) * AV_TIME_BASE };\n    Syncpoint nopts_sp = { .ts = AV_NOPTS_VALUE, .back_ptr = AV_NOPTS_VALUE };\n    Syncpoint *sp, *next_node[2] = { &nopts_sp, &nopts_sp };\n    int64_t pos, pos2, ts;\n    int i;\n\n    if (nut->flags & NUT_PIPE) {\n        return AVERROR(ENOSYS);\n    }\n\n    if (sti->index_entries) {\n        int index = av_index_search_timestamp(st, pts, flags);\n        if (index < 0)\n            index = av_index_search_timestamp(st, pts, flags ^ AVSEEK_FLAG_BACKWARD);\n        if (index < 0)\n            return -1;\n\n        pos2 = sti->index_entries[index].pos;\n        ts   = sti->index_entries[index].timestamp;\n    } else {\n        av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pts_cmp,\n                     (void **) next_node);\n        av_log(s, AV_LOG_DEBUG, \"%\"PRIu64\"-%\"PRIu64\" %\"PRId64\"-%\"PRId64\"\\n\",\n               next_node[0]->pos, next_node[1]->pos, next_node[0]->ts,\n               next_node[1]->ts);\n        pos = ff_gen_search(s, -1, dummy.ts, next_node[0]->pos,\n                            next_node[1]->pos, next_node[1]->pos,\n                            next_node[0]->ts, next_node[1]->ts,\n                            AVSEEK_FLAG_BACKWARD, &ts, nut_read_timestamp);\n        if (pos < 0)\n            return pos;\n\n        if (!(flags & AVSEEK_FLAG_BACKWARD)) {\n            dummy.pos    = pos + 16;\n            next_node[1] = &nopts_sp;\n            av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pos_cmp,\n                         (void **) next_node);\n            pos2 = ff_gen_search(s, -2, dummy.pos, next_node[0]->pos,\n                                 next_node[1]->pos, next_node[1]->pos,\n                                 next_node[0]->back_ptr, next_node[1]->back_ptr,\n                                 flags, &ts, nut_read_timestamp);\n            if (pos2 >= 0)\n                pos = pos2;\n            // FIXME dir but I think it does not matter\n        }\n        dummy.pos = pos;\n        sp = av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pos_cmp,\n                          NULL);\n\n        av_assert0(sp);\n        pos2 = sp->back_ptr - 15;\n    }\n    av_log(s, AV_LOG_DEBUG, \"SEEKTO: %\"PRId64\"\\n\", pos2);\n    pos = find_startcode(s->pb, SYNCPOINT_STARTCODE, pos2);\n    avio_seek(s->pb, pos, SEEK_SET);\n    nut->last_syncpoint_pos = pos;\n    av_log(s, AV_LOG_DEBUG, \"SP: %\"PRId64\"\\n\", pos);\n    if (pos2 > pos || pos2 + 15 < pos)\n        av_log(s, AV_LOG_ERROR, \"no syncpoint at backptr pos\\n\");\n    for (i = 0; i < s->nb_streams; i++)\n        nut->stream[i].skip_until_key_frame = 1;\n\n    nut->last_resync_pos = 0;\n\n    return 0;\n}\n\nconst AVInputFormat ff_nut_demuxer = {\n    .name           = \"nut\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"NUT\"),\n    .flags          = AVFMT_SEEK_TO_PTS,\n    .priv_data_size = sizeof(NUTContext),\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .read_probe     = nut_probe,\n    .read_header    = nut_read_header,\n    .read_packet    = nut_read_packet,\n    .read_close     = nut_read_close,\n    .read_seek      = read_seek,\n    .extensions     = \"nut\",\n    .codec_tag      = ff_nut_codec_tags,\n};\n"], "fixing_code": ["/*\n * \"NUT\" Container Format demuxer\n * Copyright (c) 2004-2006 Michael Niedermayer\n * Copyright (c) 2003 Alex Beregszaszi\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/bswap.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/tree.h\"\n#include \"libavcodec/bytestream.h\"\n#include \"avio_internal.h\"\n#include \"isom.h\"\n#include \"nut.h\"\n#include \"riff.h\"\n\n#define NUT_MAX_STREAMS 256    /* arbitrary sanity check value */\n\nstatic int64_t nut_read_timestamp(AVFormatContext *s, int stream_index,\n                                  int64_t *pos_arg, int64_t pos_limit);\n\nstatic int get_str(AVIOContext *bc, char *string, unsigned int maxlen)\n{\n    unsigned int len = ffio_read_varlen(bc);\n\n    if (len && maxlen)\n        avio_read(bc, string, FFMIN(len, maxlen));\n    while (len > maxlen) {\n        avio_r8(bc);\n        len--;\n        if (bc->eof_reached)\n            len = maxlen;\n    }\n\n    if (maxlen)\n        string[FFMIN(len, maxlen - 1)] = 0;\n\n    if (bc->eof_reached)\n        return AVERROR_EOF;\n    if (maxlen == len)\n        return -1;\n    else\n        return 0;\n}\n\nstatic int64_t get_s(AVIOContext *bc)\n{\n    int64_t v = ffio_read_varlen(bc) + 1;\n\n    if (v & 1)\n        return -(v >> 1);\n    else\n        return  (v >> 1);\n}\n\nstatic uint64_t get_fourcc(AVIOContext *bc)\n{\n    unsigned int len = ffio_read_varlen(bc);\n\n    if (len == 2)\n        return avio_rl16(bc);\n    else if (len == 4)\n        return avio_rl32(bc);\n    else {\n        av_log(NULL, AV_LOG_ERROR, \"Unsupported fourcc length %d\\n\", len);\n        return -1;\n    }\n}\n\nstatic int get_packetheader(NUTContext *nut, AVIOContext *bc,\n                            int calculate_checksum, uint64_t startcode)\n{\n    int64_t size;\n\n    startcode = av_be2ne64(startcode);\n    startcode = ff_crc04C11DB7_update(0, (uint8_t*) &startcode, 8);\n\n    ffio_init_checksum(bc, ff_crc04C11DB7_update, startcode);\n    size = ffio_read_varlen(bc);\n    if (size > 4096)\n        avio_rb32(bc);\n    if (ffio_get_checksum(bc) && size > 4096)\n        return -1;\n\n    ffio_init_checksum(bc, calculate_checksum ? ff_crc04C11DB7_update : NULL, 0);\n\n    return size;\n}\n\nstatic uint64_t find_any_startcode(AVIOContext *bc, int64_t pos)\n{\n    uint64_t state = 0;\n\n    if (pos >= 0)\n        /* Note, this may fail if the stream is not seekable, but that should\n         * not matter, as in this case we simply start where we currently are */\n        avio_seek(bc, pos, SEEK_SET);\n    while (!avio_feof(bc)) {\n        state = (state << 8) | avio_r8(bc);\n        if ((state >> 56) != 'N')\n            continue;\n        switch (state) {\n        case MAIN_STARTCODE:\n        case STREAM_STARTCODE:\n        case SYNCPOINT_STARTCODE:\n        case INFO_STARTCODE:\n        case INDEX_STARTCODE:\n            return state;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Find the given startcode.\n * @param code the startcode\n * @param pos the start position of the search, or -1 if the current position\n * @return the position of the startcode or -1 if not found\n */\nstatic int64_t find_startcode(AVIOContext *bc, uint64_t code, int64_t pos)\n{\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        if (startcode == code)\n            return avio_tell(bc) - 8;\n        else if (startcode == 0)\n            return -1;\n        pos = -1;\n    }\n}\n\nstatic int nut_probe(const AVProbeData *p)\n{\n    int i;\n\n    for (i = 0; i < p->buf_size-8; i++) {\n        if (AV_RB32(p->buf+i) != MAIN_STARTCODE>>32)\n            continue;\n        if (AV_RB32(p->buf+i+4) == (MAIN_STARTCODE & 0xFFFFFFFF))\n            return AVPROBE_SCORE_MAX;\n    }\n    return 0;\n}\n\n#define GET_V(dst, check)                                                     \\\n    do {                                                                      \\\n        tmp = ffio_read_varlen(bc);                                           \\\n        if (!(check)) {                                                       \\\n            av_log(s, AV_LOG_ERROR, \"Error \" #dst \" is (%\"PRId64\")\\n\", tmp);  \\\n            ret = AVERROR_INVALIDDATA;                                        \\\n            goto fail;                                                        \\\n        }                                                                     \\\n        dst = tmp;                                                            \\\n    } while (0)\n\nstatic int skip_reserved(AVIOContext *bc, int64_t pos)\n{\n    pos -= avio_tell(bc);\n    if (pos < 0) {\n        avio_seek(bc, pos, SEEK_CUR);\n        return AVERROR_INVALIDDATA;\n    } else {\n        while (pos--) {\n            if (bc->eof_reached)\n                return AVERROR_INVALIDDATA;\n            avio_r8(bc);\n        }\n        return 0;\n    }\n}\n\nstatic int decode_main_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end, length;\n    unsigned int stream_count;\n    int i, j, count, ret;\n    int tmp_stream, tmp_mul, tmp_pts, tmp_size, tmp_res, tmp_head_idx;\n\n    length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);\n    end = length + avio_tell(bc);\n\n    nut->version = ffio_read_varlen(bc);\n    if (nut->version < NUT_MIN_VERSION ||\n        nut->version > NUT_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\",\n               nut->version);\n        return AVERROR(ENOSYS);\n    }\n    if (nut->version > 3)\n        nut->minor_version = ffio_read_varlen(bc);\n\n    GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);\n\n    nut->max_distance = ffio_read_varlen(bc);\n    if (nut->max_distance > 65536) {\n        av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);\n        nut->max_distance = 65536;\n    }\n\n    GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);\n    nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));\n    if (!nut->time_base)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < nut->time_base_count; i++) {\n        GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));\n        GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));\n        if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {\n            av_log(s, AV_LOG_ERROR, \"invalid time base %d/%d\\n\",\n                   nut->time_base[i].num,\n                   nut->time_base[i].den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    tmp_pts      = 0;\n    tmp_mul      = 1;\n    tmp_stream   = 0;\n    tmp_head_idx = 0;\n    for (i = 0; i < 256;) {\n        int tmp_flags  = ffio_read_varlen(bc);\n        int tmp_fields = ffio_read_varlen(bc);\n\n        if (tmp_fields > 0)\n            tmp_pts = get_s(bc);\n        if (tmp_fields > 1)\n            tmp_mul = ffio_read_varlen(bc);\n        if (tmp_fields > 2)\n            tmp_stream = ffio_read_varlen(bc);\n        if (tmp_fields > 3)\n            tmp_size = ffio_read_varlen(bc);\n        else\n            tmp_size = 0;\n        if (tmp_fields > 4)\n            tmp_res = ffio_read_varlen(bc);\n        else\n            tmp_res = 0;\n        if (tmp_fields > 5)\n            count = ffio_read_varlen(bc);\n        else\n            count = tmp_mul - (unsigned)tmp_size;\n        if (tmp_fields > 6)\n            get_s(bc);\n        if (tmp_fields > 7)\n            tmp_head_idx = ffio_read_varlen(bc);\n\n        while (tmp_fields-- > 8) {\n            if (bc->eof_reached) {\n                av_log(s, AV_LOG_ERROR, \"reached EOF while decoding main header\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            ffio_read_varlen(bc);\n        }\n\n        if (count <= 0 || count > 256 - (i <= 'N') - i) {\n            av_log(s, AV_LOG_ERROR, \"illegal count %d at %d\\n\", count, i);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_stream >= stream_count) {\n            av_log(s, AV_LOG_ERROR, \"illegal stream number %d >= %d\\n\",\n                   tmp_stream, stream_count);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (tmp_size < 0 || tmp_size > INT_MAX - count) {\n            av_log(s, AV_LOG_ERROR, \"illegal size\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        for (j = 0; j < count; j++, i++) {\n            if (i == 'N') {\n                nut->frame_code[i].flags = FLAG_INVALID;\n                j--;\n                continue;\n            }\n            nut->frame_code[i].flags          = tmp_flags;\n            nut->frame_code[i].pts_delta      = tmp_pts;\n            nut->frame_code[i].stream_id      = tmp_stream;\n            nut->frame_code[i].size_mul       = tmp_mul;\n            nut->frame_code[i].size_lsb       = tmp_size + j;\n            nut->frame_code[i].reserved_count = tmp_res;\n            nut->frame_code[i].header_idx     = tmp_head_idx;\n        }\n    }\n    av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);\n\n    if (end > avio_tell(bc) + 4) {\n        int rem = 1024;\n        GET_V(nut->header_count, tmp < 128U);\n        nut->header_count++;\n        for (i = 1; i < nut->header_count; i++) {\n            uint8_t *hdr;\n            GET_V(nut->header_len[i], tmp > 0 && tmp < 256);\n            if (rem < nut->header_len[i]) {\n                av_log(s, AV_LOG_ERROR,\n                       \"invalid elision header %d : %d > %d\\n\",\n                       i, nut->header_len[i], rem);\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            rem -= nut->header_len[i];\n            hdr = av_malloc(nut->header_len[i]);\n            if (!hdr) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avio_read(bc, hdr, nut->header_len[i]);\n            nut->header[i] = hdr;\n        }\n        av_assert0(nut->header_len[0] == 0);\n    }\n\n    // flags had been effectively introduced in version 4\n    if (nut->version > 3 && end > avio_tell(bc) + 4) {\n        nut->flags = ffio_read_varlen(bc);\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"main header checksum mismatch\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    nut->stream = av_calloc(stream_count, sizeof(StreamContext));\n    if (!nut->stream) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < stream_count; i++) {\n        if (!avformat_new_stream(s, NULL)) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n    }\n\n    return 0;\nfail:\n    av_freep(&nut->time_base);\n    for (i = 1; i < nut->header_count; i++) {\n        av_freep(&nut->header[i]);\n    }\n    nut->header_count = 0;\n    return ret;\n}\n\nstatic int decode_stream_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    StreamContext *stc;\n    int class, stream_id, ret;\n    uint64_t tmp, end;\n    AVStream *st = NULL;\n\n    end  = get_packetheader(nut, bc, 1, STREAM_STARTCODE);\n    end += avio_tell(bc);\n\n    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);\n    stc = &nut->stream[stream_id];\n    st  = s->streams[stream_id];\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    class                = ffio_read_varlen(bc);\n    tmp                  = get_fourcc(bc);\n    st->codecpar->codec_tag = tmp;\n    switch (class) {\n    case 0:\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id   = av_codec_get_id((const AVCodecTag * const []) {\n                                                    ff_nut_video_tags,\n                                                    ff_codec_bmp_tags,\n                                                    ff_codec_movvideo_tags,\n                                                    0\n                                                },\n                                                tmp);\n        break;\n    case 1:\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id   = av_codec_get_id((const AVCodecTag * const []) {\n                                                    ff_nut_audio_tags,\n                                                    ff_codec_wav_tags,\n                                                    ff_nut_audio_extra_tags,\n                                                    0\n                                                },\n                                                tmp);\n        break;\n    case 2:\n        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n        st->codecpar->codec_id   = ff_codec_get_id(ff_nut_subtitle_tags, tmp);\n        break;\n    case 3:\n        st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n        st->codecpar->codec_id   = ff_codec_get_id(ff_nut_data_tags, tmp);\n        break;\n    default:\n        av_log(s, AV_LOG_ERROR, \"unknown stream class (%d)\\n\", class);\n        return AVERROR(ENOSYS);\n    }\n    if (class < 3 && st->codecpar->codec_id == AV_CODEC_ID_NONE)\n        av_log(s, AV_LOG_ERROR,\n               \"Unknown codec tag '0x%04x' for stream number %d\\n\",\n               (unsigned int) tmp, stream_id);\n\n    GET_V(stc->time_base_id, tmp < nut->time_base_count);\n    GET_V(stc->msb_pts_shift, tmp < 16);\n    stc->max_pts_distance = ffio_read_varlen(bc);\n    GET_V(stc->decode_delay, tmp < 1000); // sanity limit, raise this if Moore's law is true\n    st->codecpar->video_delay = stc->decode_delay;\n    ffio_read_varlen(bc); // stream flags\n\n    GET_V(st->codecpar->extradata_size, tmp < (1 << 30));\n    if (st->codecpar->extradata_size) {\n        ret = ff_get_extradata(s, st->codecpar, bc,\n                               st->codecpar->extradata_size);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        GET_V(st->codecpar->width,  tmp > 0);\n        GET_V(st->codecpar->height, tmp > 0);\n        st->sample_aspect_ratio.num = ffio_read_varlen(bc);\n        st->sample_aspect_ratio.den = ffio_read_varlen(bc);\n        if ((!st->sample_aspect_ratio.num) != (!st->sample_aspect_ratio.den)) {\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio %d/%d\\n\",\n                   st->sample_aspect_ratio.num, st->sample_aspect_ratio.den);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        ffio_read_varlen(bc); /* csp type */\n    } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        GET_V(st->codecpar->sample_rate, tmp > 0);\n        ffio_read_varlen(bc); // samplerate_den\n        GET_V(st->codecpar->channels, tmp > 0);\n    }\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR,\n               \"stream header %d checksum mismatch\\n\", stream_id);\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    stc->time_base = &nut->time_base[stc->time_base_id];\n    avpriv_set_pts_info(s->streams[stream_id], 63, stc->time_base->num,\n                        stc->time_base->den);\n    return 0;\nfail:\n    if (st && st->codecpar) {\n        av_freep(&st->codecpar->extradata);\n        st->codecpar->extradata_size = 0;\n    }\n    return ret;\n}\n\nstatic void set_disposition_bits(AVFormatContext *avf, char *value,\n                                 int stream_id)\n{\n    int flag = 0, i;\n\n    for (i = 0; ff_nut_dispositions[i].flag; ++i)\n        if (!strcmp(ff_nut_dispositions[i].str, value))\n            flag = ff_nut_dispositions[i].flag;\n    if (!flag)\n        av_log(avf, AV_LOG_INFO, \"unknown disposition type '%s'\\n\", value);\n    for (i = 0; i < avf->nb_streams; ++i)\n        if (stream_id == i || stream_id == -1)\n            avf->streams[i]->disposition |= flag;\n}\n\nstatic int decode_info_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, chapter_start, chapter_len;\n    unsigned int stream_id_plus1, count;\n    int i, ret = 0;\n    int64_t chapter_id, value, end;\n    char name[256], str_value[1024], type_str[256];\n    const char *type;\n    int *event_flags        = NULL;\n    AVChapter *chapter      = NULL;\n    AVStream *st            = NULL;\n    AVDictionary **metadata = NULL;\n    int metadata_flag       = 0;\n\n    end  = get_packetheader(nut, bc, 1, INFO_STARTCODE);\n    end += avio_tell(bc);\n\n    GET_V(stream_id_plus1, tmp <= s->nb_streams);\n    chapter_id    = get_s(bc);\n    chapter_start = ffio_read_varlen(bc);\n    chapter_len   = ffio_read_varlen(bc);\n    count         = ffio_read_varlen(bc);\n\n    if (chapter_id && !stream_id_plus1) {\n        int64_t start = chapter_start / nut->time_base_count;\n        chapter = avpriv_new_chapter(s, chapter_id,\n                                     nut->time_base[chapter_start %\n                                                    nut->time_base_count],\n                                     start, start + chapter_len, NULL);\n        if (!chapter) {\n            av_log(s, AV_LOG_ERROR, \"Could not create chapter.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        metadata = &chapter->metadata;\n    } else if (stream_id_plus1) {\n        st       = s->streams[stream_id_plus1 - 1];\n        metadata = &st->metadata;\n        event_flags = &st->event_flags;\n        metadata_flag = AVSTREAM_EVENT_FLAG_METADATA_UPDATED;\n    } else {\n        metadata = &s->metadata;\n        event_flags = &s->event_flags;\n        metadata_flag = AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    }\n\n    for (i = 0; i < count; i++) {\n        ret = get_str(bc, name, sizeof(name));\n        if (ret < 0) {\n            av_log(s, AV_LOG_ERROR, \"get_str failed while decoding info header\\n\");\n            return ret;\n        }\n        value = get_s(bc);\n        str_value[0] = 0;\n\n        if (value == -1) {\n            type = \"UTF-8\";\n            ret = get_str(bc, str_value, sizeof(str_value));\n        } else if (value == -2) {\n            ret = get_str(bc, type_str, sizeof(type_str));\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"get_str failed while decoding info header\\n\");\n                return ret;\n            }\n            type = type_str;\n            ret = get_str(bc, str_value, sizeof(str_value));\n        } else if (value == -3) {\n            type  = \"s\";\n            value = get_s(bc);\n        } else if (value == -4) {\n            type  = \"t\";\n            value = ffio_read_varlen(bc);\n        } else if (value < -4) {\n            type = \"r\";\n            get_s(bc);\n        } else {\n            type = \"v\";\n        }\n\n        if (ret < 0) {\n            av_log(s, AV_LOG_ERROR, \"get_str failed while decoding info header\\n\");\n            return ret;\n        }\n\n        if (stream_id_plus1 > s->nb_streams) {\n            av_log(s, AV_LOG_WARNING,\n                   \"invalid stream id %d for info packet\\n\",\n                   stream_id_plus1);\n            continue;\n        }\n\n        if (!strcmp(type, \"UTF-8\")) {\n            if (chapter_id == 0 && !strcmp(name, \"Disposition\")) {\n                set_disposition_bits(s, str_value, stream_id_plus1 - 1);\n                continue;\n            }\n\n            if (stream_id_plus1 && !strcmp(name, \"r_frame_rate\")) {\n                sscanf(str_value, \"%d/%d\", &st->r_frame_rate.num, &st->r_frame_rate.den);\n                if (st->r_frame_rate.num >= 1000LL*st->r_frame_rate.den ||\n                    st->r_frame_rate.num < 0 || st->r_frame_rate.den < 0)\n                    st->r_frame_rate.num = st->r_frame_rate.den = 0;\n                continue;\n            }\n\n            if (metadata && av_strcasecmp(name, \"Uses\") &&\n                av_strcasecmp(name, \"Depends\") && av_strcasecmp(name, \"Replaces\")) {\n                if (event_flags)\n                    *event_flags |= metadata_flag;\n                av_dict_set(metadata, name, str_value, 0);\n            }\n        }\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"info header checksum mismatch\\n\");\n        return AVERROR_INVALIDDATA;\n    }\nfail:\n    return FFMIN(ret, 0);\n}\n\nstatic int decode_syncpoint(NUTContext *nut, int64_t *ts, int64_t *back_ptr)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    int64_t end;\n    uint64_t tmp;\n    int ret;\n\n    nut->last_syncpoint_pos = avio_tell(bc) - 8;\n\n    end  = get_packetheader(nut, bc, 1, SYNCPOINT_STARTCODE);\n    end += avio_tell(bc);\n\n    tmp       = ffio_read_varlen(bc);\n    *back_ptr = nut->last_syncpoint_pos - 16 * ffio_read_varlen(bc);\n    if (*back_ptr < 0)\n        return AVERROR_INVALIDDATA;\n\n    ff_nut_reset_ts(nut, nut->time_base[tmp % nut->time_base_count],\n                    tmp / nut->time_base_count);\n\n    if (nut->flags & NUT_BROADCAST) {\n        tmp = ffio_read_varlen(bc);\n        av_log(s, AV_LOG_VERBOSE, \"Syncpoint wallclock %\"PRId64\"\\n\",\n               av_rescale_q(tmp / nut->time_base_count,\n                            nut->time_base[tmp % nut->time_base_count],\n                            AV_TIME_BASE_Q));\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"sync point checksum mismatch\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    *ts = tmp / nut->time_base_count *\n          av_q2d(nut->time_base[tmp % nut->time_base_count]) * AV_TIME_BASE;\n\n    if ((ret = ff_nut_add_sp(nut, nut->last_syncpoint_pos, *back_ptr, *ts)) < 0)\n        return ret;\n\n    return 0;\n}\n\n//FIXME calculate exactly, this is just a good approximation.\nstatic int64_t find_duration(NUTContext *nut, int64_t filesize)\n{\n    AVFormatContext *s = nut->avf;\n    int64_t duration = 0;\n\n    ff_find_last_ts(s, -1, &duration, NULL, nut_read_timestamp);\n\n    if(duration > 0)\n        s->duration_estimation_method = AVFMT_DURATION_FROM_PTS;\n    return duration;\n}\n\nstatic int find_and_decode_index(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, end;\n    int i, j, syncpoint_count;\n    int64_t filesize = avio_size(bc);\n    int64_t *syncpoints = NULL;\n    uint64_t max_pts;\n    int8_t *has_keyframe = NULL;\n    int ret = AVERROR_INVALIDDATA;\n\n    if(filesize <= 0)\n        return -1;\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n        av_log(s, AV_LOG_WARNING, \"no index at the end\\n\");\n\n        if(s->duration<=0)\n            s->duration = find_duration(nut, filesize);\n        return ret;\n    }\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n    end += avio_tell(bc);\n\n    max_pts = ffio_read_varlen(bc);\n    s->duration = av_rescale_q(max_pts / nut->time_base_count,\n                               nut->time_base[max_pts % nut->time_base_count],\n                               AV_TIME_BASE_Q);\n    s->duration_estimation_method = AVFMT_DURATION_FROM_PTS;\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n    syncpoints   = av_malloc_array(syncpoint_count, sizeof(int64_t));\n    has_keyframe = av_malloc_array(syncpoint_count + 1, sizeof(int8_t));\n    if (!syncpoints || !has_keyframe) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    for (i = 0; i < syncpoint_count; i++) {\n        syncpoints[i] = ffio_read_varlen(bc);\n        if (syncpoints[i] <= 0)\n            goto fail;\n        if (i)\n            syncpoints[i] += syncpoints[i - 1];\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        int64_t last_pts = -1;\n        for (j = 0; j < syncpoint_count;) {\n            uint64_t x = ffio_read_varlen(bc);\n            int type   = x & 1;\n            int n      = j;\n            x >>= 1;\n            if (type) {\n                int flag = x & 1;\n                x >>= 1;\n                if (n + x >= syncpoint_count + 1) {\n                    av_log(s, AV_LOG_ERROR, \"index overflow A %d + %\"PRIu64\" >= %d\\n\", n, x, syncpoint_count + 1);\n                    goto fail;\n                }\n                while (x--)\n                    has_keyframe[n++] = flag;\n                has_keyframe[n++] = !flag;\n            } else {\n                if (x <= 1) {\n                    av_log(s, AV_LOG_ERROR, \"index: x %\"PRIu64\" is invalid\\n\", x);\n                    goto fail;\n                }\n                while (x != 1) {\n                    if (n >= syncpoint_count + 1) {\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n                        goto fail;\n                    }\n                    has_keyframe[n++] = x & 1;\n                    x >>= 1;\n                }\n            }\n            if (has_keyframe[0]) {\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n                goto fail;\n            }\n            av_assert0(n <= syncpoint_count + 1);\n            for (; j < n && j < syncpoint_count; j++) {\n                if (has_keyframe[j]) {\n                    uint64_t B, A = ffio_read_varlen(bc);\n                    if (!A) {\n                        A = ffio_read_varlen(bc);\n                        B = ffio_read_varlen(bc);\n                        // eor_pts[j][i] = last_pts + A + B\n                    } else\n                        B = 0;\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n                    last_pts += A + B;\n                }\n            }\n        }\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n        goto fail;\n    }\n    ret = 0;\n\nfail:\n    av_free(syncpoints);\n    av_free(has_keyframe);\n    return ret;\n}\n\nstatic int nut_read_close(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    int i;\n\n    av_freep(&nut->time_base);\n    av_freep(&nut->stream);\n    ff_nut_free_sp(nut);\n    for (i = 1; i < nut->header_count; i++)\n        av_freep(&nut->header[i]);\n\n    return 0;\n}\n\nstatic int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count, ret;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    ret = 0;\n    do {\n        if (ret == AVERROR(ENOMEM))\n            return ret;\n\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while ((ret = decode_main_header(nut)) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}\n\nstatic int read_sm_data(AVFormatContext *s, AVIOContext *bc, AVPacket *pkt, int is_meta, int64_t maxpos)\n{\n    int count = ffio_read_varlen(bc);\n    int skip_start = 0;\n    int skip_end = 0;\n    int channels = 0;\n    int64_t channel_layout = 0;\n    int sample_rate = 0;\n    int width = 0;\n    int height = 0;\n    int i, ret;\n\n    for (i=0; i<count; i++) {\n        uint8_t name[256], str_value[256], type_str[256];\n        int value;\n        if (avio_tell(bc) >= maxpos)\n            return AVERROR_INVALIDDATA;\n        ret = get_str(bc, name, sizeof(name));\n        if (ret < 0) {\n            av_log(s, AV_LOG_ERROR, \"get_str failed while reading sm data\\n\");\n            return ret;\n        }\n        value = get_s(bc);\n\n        if (value == -1) {\n            ret = get_str(bc, str_value, sizeof(str_value));\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"get_str failed while reading sm data\\n\");\n                return ret;\n            }\n            av_log(s, AV_LOG_WARNING, \"Unknown string %s / %s\\n\", name, str_value);\n        } else if (value == -2) {\n            uint8_t *dst = NULL;\n            int64_t v64, value_len;\n\n            ret = get_str(bc, type_str, sizeof(type_str));\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"get_str failed while reading sm data\\n\");\n                return ret;\n            }\n            value_len = ffio_read_varlen(bc);\n            if (value_len < 0 || value_len >= maxpos - avio_tell(bc))\n                return AVERROR_INVALIDDATA;\n            if (!strcmp(name, \"Palette\")) {\n                dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, value_len);\n            } else if (!strcmp(name, \"Extradata\")) {\n                dst = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, value_len);\n            } else if (sscanf(name, \"CodecSpecificSide%\"SCNd64\"\", &v64) == 1) {\n                dst = av_packet_new_side_data(pkt, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL, value_len + 8);\n                if(!dst)\n                    return AVERROR(ENOMEM);\n                AV_WB64(dst, v64);\n                dst += 8;\n            } else if (!strcmp(name, \"ChannelLayout\") && value_len == 8) {\n                channel_layout = avio_rl64(bc);\n                continue;\n            } else {\n                av_log(s, AV_LOG_WARNING, \"Unknown data %s / %s\\n\", name, type_str);\n                avio_skip(bc, value_len);\n                continue;\n            }\n            if(!dst)\n                return AVERROR(ENOMEM);\n            avio_read(bc, dst, value_len);\n        } else if (value == -3) {\n            value = get_s(bc);\n        } else if (value == -4) {\n            value = ffio_read_varlen(bc);\n        } else if (value < -4) {\n            get_s(bc);\n        } else {\n            if (!strcmp(name, \"SkipStart\")) {\n                skip_start = value;\n            } else if (!strcmp(name, \"SkipEnd\")) {\n                skip_end = value;\n            } else if (!strcmp(name, \"Channels\")) {\n                channels = value;\n            } else if (!strcmp(name, \"SampleRate\")) {\n                sample_rate = value;\n            } else if (!strcmp(name, \"Width\")) {\n                width = value;\n            } else if (!strcmp(name, \"Height\")) {\n                height = value;\n            } else {\n                av_log(s, AV_LOG_WARNING, \"Unknown integer %s\\n\", name);\n            }\n        }\n    }\n\n    if (channels || channel_layout || sample_rate || width || height) {\n        uint8_t *dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PARAM_CHANGE, 28);\n        if (!dst)\n            return AVERROR(ENOMEM);\n        bytestream_put_le32(&dst,\n                            AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT*(!!channels) +\n                            AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT*(!!channel_layout) +\n                            AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE*(!!sample_rate) +\n                            AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS*(!!(width|height))\n                           );\n        if (channels)\n            bytestream_put_le32(&dst, channels);\n        if (channel_layout)\n            bytestream_put_le64(&dst, channel_layout);\n        if (sample_rate)\n            bytestream_put_le32(&dst, sample_rate);\n        if (width || height){\n            bytestream_put_le32(&dst, width);\n            bytestream_put_le32(&dst, height);\n        }\n    }\n\n    if (skip_start || skip_end) {\n        uint8_t *dst = av_packet_new_side_data(pkt, AV_PKT_DATA_SKIP_SAMPLES, 10);\n        if (!dst)\n            return AVERROR(ENOMEM);\n        AV_WL32(dst, skip_start);\n        AV_WL32(dst+4, skip_end);\n    }\n\n    if (avio_tell(bc) >= maxpos)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int decode_frame_header(NUTContext *nut, int64_t *pts, int *stream_id,\n                               uint8_t *header_idx, int frame_code)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    StreamContext *stc;\n    int size, flags, size_mul, pts_delta, i, reserved_count, ret;\n    uint64_t tmp;\n\n    if (!(nut->flags & NUT_PIPE) &&\n        avio_tell(bc) > nut->last_syncpoint_pos + nut->max_distance) {\n        av_log(s, AV_LOG_ERROR,\n               \"Last frame must have been damaged %\"PRId64\" > %\"PRId64\" + %d\\n\",\n               avio_tell(bc), nut->last_syncpoint_pos, nut->max_distance);\n        return AVERROR_INVALIDDATA;\n    }\n\n    flags          = nut->frame_code[frame_code].flags;\n    size_mul       = nut->frame_code[frame_code].size_mul;\n    size           = nut->frame_code[frame_code].size_lsb;\n    *stream_id     = nut->frame_code[frame_code].stream_id;\n    pts_delta      = nut->frame_code[frame_code].pts_delta;\n    reserved_count = nut->frame_code[frame_code].reserved_count;\n    *header_idx    = nut->frame_code[frame_code].header_idx;\n\n    if (flags & FLAG_INVALID)\n        return AVERROR_INVALIDDATA;\n    if (flags & FLAG_CODED)\n        flags ^= ffio_read_varlen(bc);\n    if (flags & FLAG_STREAM_ID) {\n        GET_V(*stream_id, tmp < s->nb_streams);\n    }\n    stc = &nut->stream[*stream_id];\n    if (flags & FLAG_CODED_PTS) {\n        int64_t coded_pts = ffio_read_varlen(bc);\n        // FIXME check last_pts validity?\n        if (coded_pts < (1LL << stc->msb_pts_shift)) {\n            *pts = ff_lsb2full(stc, coded_pts);\n        } else\n            *pts = coded_pts - (1LL << stc->msb_pts_shift);\n    } else\n        *pts = stc->last_pts + pts_delta;\n    if (flags & FLAG_SIZE_MSB)\n        size += size_mul * ffio_read_varlen(bc);\n    if (flags & FLAG_MATCH_TIME)\n        get_s(bc);\n    if (flags & FLAG_HEADER_IDX)\n        *header_idx = ffio_read_varlen(bc);\n    if (flags & FLAG_RESERVED)\n        reserved_count = ffio_read_varlen(bc);\n    for (i = 0; i < reserved_count; i++) {\n        if (bc->eof_reached) {\n            av_log(s, AV_LOG_ERROR, \"reached EOF while decoding frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ffio_read_varlen(bc);\n    }\n\n    if (*header_idx >= (unsigned)nut->header_count) {\n        av_log(s, AV_LOG_ERROR, \"header_idx invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (size > 4096)\n        *header_idx = 0;\n    size -= nut->header_len[*header_idx];\n\n    if (flags & FLAG_CHECKSUM) {\n        avio_rb32(bc); // FIXME check this\n    } else if (!(nut->flags & NUT_PIPE) &&\n               size > 2 * nut->max_distance ||\n               FFABS(stc->last_pts - *pts) > stc->max_pts_distance) {\n        av_log(s, AV_LOG_ERROR, \"frame size > 2max_distance and no checksum\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    stc->last_pts   = *pts;\n    stc->last_flags = flags;\n\n    return size;\nfail:\n    return ret;\n}\n\nstatic int decode_frame(NUTContext *nut, AVPacket *pkt, int frame_code)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    int size, stream_id, discard, ret;\n    int64_t pts, last_IP_pts;\n    StreamContext *stc;\n    uint8_t header_idx;\n\n    size = decode_frame_header(nut, &pts, &stream_id, &header_idx, frame_code);\n    if (size < 0)\n        return size;\n\n    stc = &nut->stream[stream_id];\n\n    if (stc->last_flags & FLAG_KEY)\n        stc->skip_until_key_frame = 0;\n\n    discard     = s->streams[stream_id]->discard;\n    last_IP_pts = ffstream(s->streams[stream_id])->last_IP_pts;\n    if ((discard >= AVDISCARD_NONKEY && !(stc->last_flags & FLAG_KEY)) ||\n        (discard >= AVDISCARD_BIDIR  && last_IP_pts != AV_NOPTS_VALUE &&\n         last_IP_pts > pts) ||\n        discard >= AVDISCARD_ALL ||\n        stc->skip_until_key_frame) {\n        avio_skip(bc, size);\n        return 1;\n    }\n\n    ret = av_new_packet(pkt, size + nut->header_len[header_idx]);\n    if (ret < 0)\n        return ret;\n    if (nut->header[header_idx])\n        memcpy(pkt->data, nut->header[header_idx], nut->header_len[header_idx]);\n    pkt->pos = avio_tell(bc); // FIXME\n    if (stc->last_flags & FLAG_SM_DATA) {\n        int sm_size;\n        if (read_sm_data(s, bc, pkt, 0, pkt->pos + size) < 0) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        if (read_sm_data(s, bc, pkt, 1, pkt->pos + size) < 0) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        sm_size = avio_tell(bc) - pkt->pos;\n        size      -= sm_size;\n        pkt->size -= sm_size;\n    }\n\n    ret = avio_read(bc, pkt->data + nut->header_len[header_idx], size);\n    if (ret != size) {\n        if (ret < 0)\n            goto fail;\n    }\n    av_shrink_packet(pkt, nut->header_len[header_idx] + ret);\n\n    pkt->stream_index = stream_id;\n    if (stc->last_flags & FLAG_KEY)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n    pkt->pts = pts;\n\n    return 0;\nfail:\n    av_packet_unref(pkt);\n    return ret;\n}\n\nstatic int nut_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int i, frame_code = 0, ret, skip;\n    int64_t ts, back_ptr;\n\n    for (;;) {\n        int64_t pos  = avio_tell(bc);\n        uint64_t tmp = nut->next_startcode;\n        nut->next_startcode = 0;\n\n        if (tmp) {\n            pos -= 8;\n        } else {\n            frame_code = avio_r8(bc);\n            if (avio_feof(bc))\n                return AVERROR_EOF;\n            if (frame_code == 'N') {\n                tmp = frame_code;\n                for (i = 1; i < 8; i++)\n                    tmp = (tmp << 8) + avio_r8(bc);\n            }\n        }\n        switch (tmp) {\n        case MAIN_STARTCODE:\n        case STREAM_STARTCODE:\n        case INDEX_STARTCODE:\n            skip = get_packetheader(nut, bc, 0, tmp);\n            avio_skip(bc, skip);\n            break;\n        case INFO_STARTCODE:\n            if (decode_info_header(nut) < 0)\n                goto resync;\n            break;\n        case SYNCPOINT_STARTCODE:\n            if (decode_syncpoint(nut, &ts, &back_ptr) < 0)\n                goto resync;\n            frame_code = avio_r8(bc);\n        case 0:\n            ret = decode_frame(nut, pkt, frame_code);\n            if (ret == 0)\n                return 0;\n            else if (ret == 1) // OK but discard packet\n                break;\n        default:\nresync:\n            av_log(s, AV_LOG_DEBUG, \"syncing from %\"PRId64\"\\n\", pos);\n            tmp = find_any_startcode(bc, FFMAX(nut->last_syncpoint_pos, nut->last_resync_pos) + 1);\n            nut->last_resync_pos = avio_tell(bc);\n            if (tmp == 0)\n                return AVERROR_INVALIDDATA;\n            av_log(s, AV_LOG_DEBUG, \"sync\\n\");\n            nut->next_startcode = tmp;\n        }\n    }\n}\n\nstatic int64_t nut_read_timestamp(AVFormatContext *s, int stream_index,\n                                  int64_t *pos_arg, int64_t pos_limit)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos, pts, back_ptr;\n    av_log(s, AV_LOG_DEBUG, \"read_timestamp(X,%d,%\"PRId64\",%\"PRId64\")\\n\",\n           stream_index, *pos_arg, pos_limit);\n\n    pos = *pos_arg;\n    do {\n        pos = find_startcode(bc, SYNCPOINT_STARTCODE, pos) + 1;\n        if (pos < 1) {\n            av_log(s, AV_LOG_ERROR, \"read_timestamp failed.\\n\");\n            return AV_NOPTS_VALUE;\n        }\n    } while (decode_syncpoint(nut, &pts, &back_ptr) < 0);\n    *pos_arg = pos - 1;\n    av_assert0(nut->last_syncpoint_pos == *pos_arg);\n\n    av_log(s, AV_LOG_DEBUG, \"return %\"PRId64\" %\"PRId64\"\\n\", pts, back_ptr);\n    if (stream_index == -2)\n        return back_ptr;\n    av_assert0(stream_index == -1);\n    return pts;\n}\n\nstatic int read_seek(AVFormatContext *s, int stream_index,\n                     int64_t pts, int flags)\n{\n    NUTContext *nut    = s->priv_data;\n    AVStream *st       = s->streams[stream_index];\n    FFStream *const sti = ffstream(st);\n    Syncpoint dummy    = { .ts = pts * av_q2d(st->time_base) * AV_TIME_BASE };\n    Syncpoint nopts_sp = { .ts = AV_NOPTS_VALUE, .back_ptr = AV_NOPTS_VALUE };\n    Syncpoint *sp, *next_node[2] = { &nopts_sp, &nopts_sp };\n    int64_t pos, pos2, ts;\n    int i;\n\n    if (nut->flags & NUT_PIPE) {\n        return AVERROR(ENOSYS);\n    }\n\n    if (sti->index_entries) {\n        int index = av_index_search_timestamp(st, pts, flags);\n        if (index < 0)\n            index = av_index_search_timestamp(st, pts, flags ^ AVSEEK_FLAG_BACKWARD);\n        if (index < 0)\n            return -1;\n\n        pos2 = sti->index_entries[index].pos;\n        ts   = sti->index_entries[index].timestamp;\n    } else {\n        av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pts_cmp,\n                     (void **) next_node);\n        av_log(s, AV_LOG_DEBUG, \"%\"PRIu64\"-%\"PRIu64\" %\"PRId64\"-%\"PRId64\"\\n\",\n               next_node[0]->pos, next_node[1]->pos, next_node[0]->ts,\n               next_node[1]->ts);\n        pos = ff_gen_search(s, -1, dummy.ts, next_node[0]->pos,\n                            next_node[1]->pos, next_node[1]->pos,\n                            next_node[0]->ts, next_node[1]->ts,\n                            AVSEEK_FLAG_BACKWARD, &ts, nut_read_timestamp);\n        if (pos < 0)\n            return pos;\n\n        if (!(flags & AVSEEK_FLAG_BACKWARD)) {\n            dummy.pos    = pos + 16;\n            next_node[1] = &nopts_sp;\n            av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pos_cmp,\n                         (void **) next_node);\n            pos2 = ff_gen_search(s, -2, dummy.pos, next_node[0]->pos,\n                                 next_node[1]->pos, next_node[1]->pos,\n                                 next_node[0]->back_ptr, next_node[1]->back_ptr,\n                                 flags, &ts, nut_read_timestamp);\n            if (pos2 >= 0)\n                pos = pos2;\n            // FIXME dir but I think it does not matter\n        }\n        dummy.pos = pos;\n        sp = av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pos_cmp,\n                          NULL);\n\n        av_assert0(sp);\n        pos2 = sp->back_ptr - 15;\n    }\n    av_log(s, AV_LOG_DEBUG, \"SEEKTO: %\"PRId64\"\\n\", pos2);\n    pos = find_startcode(s->pb, SYNCPOINT_STARTCODE, pos2);\n    avio_seek(s->pb, pos, SEEK_SET);\n    nut->last_syncpoint_pos = pos;\n    av_log(s, AV_LOG_DEBUG, \"SP: %\"PRId64\"\\n\", pos);\n    if (pos2 > pos || pos2 + 15 < pos)\n        av_log(s, AV_LOG_ERROR, \"no syncpoint at backptr pos\\n\");\n    for (i = 0; i < s->nb_streams; i++)\n        nut->stream[i].skip_until_key_frame = 1;\n\n    nut->last_resync_pos = 0;\n\n    return 0;\n}\n\nconst AVInputFormat ff_nut_demuxer = {\n    .name           = \"nut\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"NUT\"),\n    .flags          = AVFMT_SEEK_TO_PTS,\n    .priv_data_size = sizeof(NUTContext),\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .read_probe     = nut_probe,\n    .read_header    = nut_read_header,\n    .read_packet    = nut_read_packet,\n    .read_close     = nut_read_close,\n    .read_seek      = read_seek,\n    .extensions     = \"nut\",\n    .codec_tag      = ff_nut_codec_tags,\n};\n"], "filenames": ["libavformat/nutdec.c"], "buggy_code_start_loc": [354], "buggy_code_end_loc": [816], "fixing_code_start_loc": [354], "fixing_code_end_loc": [824], "type": "CWE-476", "message": "A null pointer dereference issue was discovered in 'FFmpeg' in decode_main_header() function of libavformat/nutdec.c file. The flaw occurs because the function lacks check of the return value of avformat_new_stream() and triggers the null pointer dereference error, causing an application to crash.", "other": {"cve": {"id": "CVE-2022-3341", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2023-01-12T15:15:10.007", "lastModified": "2023-01-20T20:08:55.323", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A null pointer dereference issue was discovered in 'FFmpeg' in decode_main_header() function of libavformat/nutdec.c file. The flaw occurs because the function lacks check of the return value of avformat_new_stream() and triggers the null pointer dereference error, causing an application to crash."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.1", "matchCriteriaId": "1729FAD7-CEEE-4DCC-9F09-E813995593C5"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2157054", "source": "patrick@puiterwijk.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/9cf652cef49d74afe3d454f27d49eb1a1394951e", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9cf652cef49d74afe3d454f27d49eb1a1394951e"}}