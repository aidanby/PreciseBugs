{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"rdp.h\"\n\n#include \"info.h\"\n#include \"redirection.h\"\n\n#include <freerdp/crypto/per.h>\n\n#ifdef WITH_DEBUG_RDP\nstatic const char* const DATA_PDU_TYPE_STRINGS[] =\n{\n\t\t\"?\", \"?\", /* 0x00 - 0x01 */\n\t\t\"Update\", /* 0x02 */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", /* 0x03 - 0x0A */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", /* 0x0B - 0x13 */\n\t\t\"Control\", /* 0x14 */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\", /* 0x15 - 0x1A */\n\t\t\"Pointer\", /* 0x1B */\n\t\t\"Input\", /* 0x1C */\n\t\t\"?\", \"?\", /* 0x1D - 0x1E */\n\t\t\"Synchronize\", /* 0x1F */\n\t\t\"?\", /* 0x20 */\n\t\t\"Refresh Rect\", /* 0x21 */\n\t\t\"Play Sound\", /* 0x22 */\n\t\t\"Suppress Output\", /* 0x23 */\n\t\t\"Shutdown Request\", /* 0x24 */\n\t\t\"Shutdown Denied\", /* 0x25 */\n\t\t\"Save Session Info\", /* 0x26 */\n\t\t\"Font List\", /* 0x27 */\n\t\t\"Font Map\", /* 0x28 */\n\t\t\"Set Keyboard Indicators\", /* 0x29 */\n\t\t\"?\", /* 0x2A */\n\t\t\"Bitmap Cache Persistent List\", /* 0x2B */\n\t\t\"Bitmap Cache Error\", /* 0x2C */\n\t\t\"Set Keyboard IME Status\", /* 0x2D */\n\t\t\"Offscreen Cache Error\", /* 0x2E */\n\t\t\"Set Error Info\", /* 0x2F */\n\t\t\"Draw Nine Grid Error\", /* 0x30 */\n\t\t\"Draw GDI+ Error\", /* 0x31 */\n\t\t\"ARC Status\", /* 0x32 */\n\t\t\"?\", \"?\", \"?\", /* 0x33 - 0x35 */\n\t\t\"Status Info\", /* 0x36 */\n\t\t\"Monitor Layout\" /* 0x37 */\n\t\t\"?\", \"?\", \"?\", /* 0x38 - 0x40 */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\" /* 0x41 - 0x46 */\n};\n#endif\n\n/**\n * Read RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nBOOL rdp_read_security_header(STREAM* s, UINT16* flags)\n{\n\t/* Basic Security Header */\n\tif(stream_get_left(s) < 4)\n\t\treturn FALSE;\n\tstream_read_UINT16(s, *flags); /* flags */\n\tstream_seek(s, 2); /* flagsHi (unused) */\n\treturn TRUE;\n}\n\n/**\n * Write RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nvoid rdp_write_security_header(STREAM* s, UINT16 flags)\n{\n\t/* Basic Security Header */\n\tstream_write_UINT16(s, flags); /* flags */\n\tstream_write_UINT16(s, 0); /* flagsHi (unused) */\n}\n\nBOOL rdp_read_share_control_header(STREAM* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (stream_get_left(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tstream_read_UINT16(s, *length); /* totalLength */\n\n\tif (*length - 2 > stream_get_left(s))\n\t\treturn FALSE;\n\n\tstream_read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F; /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tstream_read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}\n\nvoid rdp_write_share_control_header(STREAM* s, UINT16 length, UINT16 type, UINT16 channel_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\n\t/* Share Control Header */\n\tstream_write_UINT16(s, length); /* totalLength */\n\tstream_write_UINT16(s, type | 0x10); /* pduType */\n\tstream_write_UINT16(s, channel_id); /* pduSource */\n}\n\nBOOL rdp_read_share_data_header(STREAM* s, UINT16* length, BYTE* type, UINT32* share_id,\n\t\t\t\t\tBYTE *compressed_type, UINT16 *compressed_len)\n{\n\tif (stream_get_left(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tstream_read_UINT32(s, *share_id); /* shareId (4 bytes) */\n\tstream_seek_BYTE(s); /* pad1 (1 byte) */\n\tstream_seek_BYTE(s); /* streamId (1 byte) */\n\tstream_read_UINT16(s, *length); /* uncompressedLength (2 bytes) */\n\tstream_read_BYTE(s, *type); /* pduType2, Data PDU Type (1 byte) */\n\tstream_read_BYTE(s, *compressed_type); /* compressedType (1 byte) */\n\tstream_read_UINT16(s, *compressed_len); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n\nvoid rdp_write_share_data_header(STREAM* s, UINT16 length, BYTE type, UINT32 share_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\tlength -= RDP_SHARE_CONTROL_HEADER_LENGTH;\n\tlength -= RDP_SHARE_DATA_HEADER_LENGTH;\n\n\t/* Share Data Header */\n\tstream_write_UINT32(s, share_id); /* shareId (4 bytes) */\n\tstream_write_BYTE(s, 0); /* pad1 (1 byte) */\n\tstream_write_BYTE(s, STREAM_LOW); /* streamId (1 byte) */\n\tstream_write_UINT16(s, length); /* uncompressedLength (2 bytes) */\n\tstream_write_BYTE(s, type); /* pduType2, Data PDU Type (1 byte) */\n\tstream_write_BYTE(s, 0); /* compressedType (1 byte) */\n\tstream_write_UINT16(s, 0); /* compressedLength (2 bytes) */\n}\n\nstatic int rdp_security_stream_init(rdpRdp* rdp, STREAM* s)\n{\n\tif (rdp->do_crypt)\n\t{\n\t\tstream_seek(s, 12);\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tstream_seek(s, 4);\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0)\n\t{\n\t\tstream_seek(s, 4);\n\t}\n\n\treturn 0;\n}\n\n/**\n * Initialize an RDP packet stream.\\n\n * @param rdp rdp module\n * @return\n */\n\nSTREAM* rdp_send_stream_init(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\n\ts = transport_send_stream_init(rdp->transport, 2048);\n\tstream_seek(s, RDP_PACKET_HEADER_MAX_LENGTH);\n\trdp_security_stream_init(rdp, s);\n\n\treturn s;\n}\n\nSTREAM* rdp_pdu_init(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\ts = transport_send_stream_init(rdp->transport, 2048);\n\tstream_seek(s, RDP_PACKET_HEADER_MAX_LENGTH);\n\trdp_security_stream_init(rdp, s);\n\tstream_seek(s, RDP_SHARE_CONTROL_HEADER_LENGTH);\n\treturn s;\n}\n\nSTREAM* rdp_data_pdu_init(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\ts = transport_send_stream_init(rdp->transport, 2048);\n\tstream_seek(s, RDP_PACKET_HEADER_MAX_LENGTH);\n\trdp_security_stream_init(rdp, s);\n\tstream_seek(s, RDP_SHARE_CONTROL_HEADER_LENGTH);\n\tstream_seek(s, RDP_SHARE_DATA_HEADER_LENGTH);\n\treturn s;\n}\n\n/**\n * Read an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nBOOL rdp_read_header(rdpRdp* rdp, STREAM* s, UINT16* length, UINT16* channel_id)\n{\n\tUINT16 initiator;\n\tenum DomainMCSPDU MCSPDU;\n\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataRequest : DomainMCSPDU_SendDataIndication;\n\n\tif (!mcs_read_domain_mcspdu_header(s, &MCSPDU, length))\n\t{\n\t\tif (MCSPDU != DomainMCSPDU_DisconnectProviderUltimatum)\n\t\t\treturn FALSE;\n\t}\n\n\tif (*length - 8 > stream_get_left(s))\n\t\treturn FALSE;\n\n\tif (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)\n\t{\n\t\tBYTE reason;\n\n\t\t(void) per_read_enumerated(s, &reason, 0);\n\t\tDEBUG_RDP(\"DisconnectProviderUltimatum from server, reason code 0x%02x\\n\", reason);\n\n\t\trdp->disconnect = TRUE;\n\n\t\treturn TRUE;\n\t}\n\n\tif(stream_get_left(s) < 5)\n\t\treturn FALSE;\n\tper_read_integer16(s, &initiator, MCS_BASE_CHANNEL_ID); /* initiator (UserId) */\n\tper_read_integer16(s, channel_id, 0); /* channelId */\n\tstream_seek(s, 1); /* dataPriority + Segmentation (0x70) */\n\n\tif(!per_read_length(s, length)) /* userData (OCTET_STRING) */\n\t\treturn FALSE;\n\tif (*length > stream_get_left(s))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nvoid rdp_write_header(rdpRdp* rdp, STREAM* s, UINT16 length, UINT16 channel_id)\n{\n\tint body_length;\n\tenum DomainMCSPDU MCSPDU;\n\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataIndication : DomainMCSPDU_SendDataRequest;\n\n\tif ((rdp->sec_flags & SEC_ENCRYPT) && (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS))\n\t{\n\t\tint pad;\n\n\t\tbody_length = length - RDP_PACKET_HEADER_MAX_LENGTH - 16;\n\t\tpad = 8 - (body_length % 8);\n\n\t\tif (pad != 8)\n\t\t\tlength += pad;\n\t}\n\n\tmcs_write_domain_mcspdu_header(s, MCSPDU, length, 0);\n\tper_write_integer16(s, rdp->mcs->user_id, MCS_BASE_CHANNEL_ID); /* initiator */\n\tper_write_integer16(s, channel_id, 0); /* channelId */\n\tstream_write_BYTE(s, 0x70); /* dataPriority + segmentation */\n\t/*\n\t * We always encode length in two bytes, eventhough we could use\n\t * only one byte if length <= 0x7F. It is just easier that way,\n\t * because we can leave room for fixed-length header, store all\n\t * the data first and then store the header.\n\t */\n\tlength = (length - RDP_PACKET_HEADER_MAX_LENGTH) | 0x8000;\n\tstream_write_UINT16_be(s, length); /* userData (OCTET_STRING) */\n}\n\nstatic UINT32 rdp_security_stream_out(rdpRdp* rdp, STREAM* s, int length)\n{\n\tBYTE* data;\n\tUINT32 sec_flags;\n\tUINT32 pad = 0;\n\n\tsec_flags = rdp->sec_flags;\n\n\tif (sec_flags != 0)\n\t{\n\t\trdp_write_security_header(s, sec_flags);\n\n\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tdata = s->p + 12;\n\n\t\t\t\tlength = length - (data - s->data);\n\t\t\t\tstream_write_UINT16(s, 0x10); /* length */\n\t\t\t\tstream_write_BYTE(s, 0x1); /* TSFIPS_VERSION 1*/\n\n\t\t\t\t/* handle padding */\n\t\t\t\tpad = 8 - (length % 8);\n\n\t\t\t\tif (pad == 8)\n\t\t\t\t\tpad = 0;\n\t\t\t\tif (pad)\n\t\t\t\t\tmemset(data+length, 0, pad);\n\n\t\t\t\tstream_write_BYTE(s, pad);\n\n\t\t\t\tsecurity_hmac_signature(data, length, s->p, rdp);\n\t\t\t\tstream_seek(s, 8);\n\t\t\t\tsecurity_fips_encrypt(data, length + pad, rdp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata = s->p + 8;\n\t\t\t\tlength = length - (data - s->data);\n\t\t\t\tif (sec_flags & SEC_SECURE_CHECKSUM)\n\t\t\t\t\tsecurity_salted_mac_signature(rdp, data, length, TRUE, s->p);\n\t\t\t\telse\n\t\t\t\t\tsecurity_mac_signature(rdp, data, length, s->p);\n\t\t\t\tstream_seek(s, 8);\n\t\t\t\tsecurity_encrypt(s->p, length, rdp);\n\t\t\t}\n\t\t}\n\n\t\trdp->sec_flags = 0;\n\t}\n\n\treturn pad;\n}\n\nstatic UINT32 rdp_get_sec_bytes(rdpRdp* rdp)\n{\n\tUINT32 sec_bytes;\n\n\tif (rdp->sec_flags & SEC_ENCRYPT)\n\t{\n\t\tsec_bytes = 12;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tsec_bytes += 4;\n\t}\n\telse if (rdp->sec_flags != 0)\n\t{\n\t\tsec_bytes = 4;\n\t}\n\telse\n\t{\n\t\tsec_bytes = 0;\n\t}\n\n\treturn sec_bytes;\n}\n\n/**\n * Send an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param channel_id channel id\n */\n\nBOOL rdp_send(rdpRdp* rdp, STREAM* s, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tBYTE* sec_hold;\n\n\tlength = stream_get_length(s);\n\tstream_set_pos(s, 0);\n\n\trdp_write_header(rdp, s, length, channel_id);\n\n\tsec_bytes = rdp_get_sec_bytes(rdp);\n\tsec_hold = s->p;\n\tstream_seek(s, sec_bytes);\n\n\ts->p = sec_hold;\n\tlength += rdp_security_stream_out(rdp, s, length);\n\n\tstream_set_pos(s, length);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_pdu(rdpRdp* rdp, STREAM* s, UINT16 type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tBYTE* sec_hold;\n\n\tlength = stream_get_length(s);\n\tstream_set_pos(s, 0);\n\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\n\tsec_bytes = rdp_get_sec_bytes(rdp);\n\tsec_hold = s->p;\n\tstream_seek(s, sec_bytes);\n\n\trdp_write_share_control_header(s, length - sec_bytes, type, channel_id);\n\n\ts->p = sec_hold;\n\tlength += rdp_security_stream_out(rdp, s, length);\n\n\tstream_set_pos(s, length);\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_data_pdu(rdpRdp* rdp, STREAM* s, BYTE type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tBYTE* sec_hold;\n\n\tlength = stream_get_length(s);\n\tstream_set_pos(s, 0);\n\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\n\tsec_bytes = rdp_get_sec_bytes(rdp);\n\tsec_hold = s->p;\n\tstream_seek(s, sec_bytes);\n\n\trdp_write_share_control_header(s, length - sec_bytes, PDU_TYPE_DATA, channel_id);\n\trdp_write_share_data_header(s, length - sec_bytes, type, rdp->settings->ShareId);\n\n\ts->p = sec_hold;\n\tlength += rdp_security_stream_out(rdp, s, length);\n\n\tstream_set_pos(s, length);\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_recv_set_error_info_data_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tif (stream_get_left(s) < 4)\n\t\treturn FALSE;\n\n\tstream_read_UINT32(s, rdp->errorInfo); /* errorInfo (4 bytes) */\n\n\tif (rdp->errorInfo != ERRINFO_SUCCESS)\n\t\trdp_print_errinfo(rdp->errorInfo);\n\n\treturn TRUE;\n}\n\nint rdp_recv_data_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tBYTE type;\n\tUINT16 length;\n\tUINT32 share_id;\n\tBYTE compressed_type;\n\tUINT16 compressed_len;\n\tUINT32 roff;\n\tUINT32 rlen;\n\tSTREAM* comp_stream;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &share_id, &compressed_type, &compressed_len))\n\t\treturn -1;\n\n\tcomp_stream = s;\n\n\tif (compressed_type & PACKET_COMPRESSED)\n\t{\n\t\tif (stream_get_left(s) < compressed_len - 18)\n\t\t{\n\t\t\tprintf(\"decompress_rdp: not enough bytes for compressed_len=%d\\n\", compressed_len);\n\t\t\treturn -1;\t\n\t\t}\n\t\tif (decompress_rdp(rdp->mppc_dec, s->p, compressed_len - 18, compressed_type, &roff, &rlen))\n\t\t{\n\t\t\tcomp_stream = stream_new(0);\n\t\t\tcomp_stream->data = rdp->mppc_dec->history_buf + roff;\n\t\t\tcomp_stream->p = comp_stream->data;\n\t\t\tcomp_stream->size = rlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"decompress_rdp() failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tstream_seek(s, compressed_len - 18);\n\t}\n\n#ifdef WITH_DEBUG_RDP\n\t/* if (type != DATA_PDU_TYPE_UPDATE) */\n\t\tDEBUG_RDP(\"recv %s Data PDU (0x%02X), length:%d\",\n\t\t\t\ttype < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type, length);\n#endif\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_UPDATE:\n\t\t\tif (!update_recv(rdp->update, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_recv_server_control_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_POINTER:\n\t\t\tif (!update_recv_pointer(rdp->update, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_INPUT:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_synchronize_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_REFRESH_RECT:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_PLAY_SOUND:\n\t\t\tif (!update_recv_play_sound(rdp->update, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SUPPRESS_OUTPUT:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_REQUEST:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_DENIED:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SAVE_SESSION_INFO:\n\t\t\tif(!rdp_recv_save_session_info(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_LIST:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_MAP:\n\t\t\tif(!rdp_recv_font_map_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_OFFSCREEN_CACHE_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_ERROR_INFO:\n\t\t\tif (!rdp_recv_set_error_info_data_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_DRAW_NINEGRID_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_DRAW_GDIPLUS_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_ARC_STATUS:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_STATUS_INFO:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_MONITOR_LAYOUT:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (comp_stream != s)\n\t{\n\t\tstream_detach(comp_stream);\n\t\tstream_free(comp_stream);\n\t}\n\n\treturn 0;\n}\n\nBOOL rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tUINT16 channelId;\n\n\tif (!rdp_read_share_control_header(s, &length, &type, &channelId))\n\t\treturn FALSE;\n\n\tif (type == PDU_TYPE_DATA)\n\t{\n\t\treturn (rdp_recv_data_pdu(rdp, s) < 0) ? FALSE : TRUE;\n\t}\n\telse if (type == PDU_TYPE_SERVER_REDIRECTION)\n\t{\n\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\n/**\n * Decrypt an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param length int\n */\n\nBOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Process an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n */\n\nstatic int rdp_recv_tpkt_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags;\n\tBYTE* nextp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tprintf(\"Incorrect RDP header.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rdp->settings->DisableEncryption)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & (SEC_ENCRYPT | SEC_REDIRECTION_PKT))\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length - 4, securityFlags))\n\t\t\t{\n\t\t\t\tprintf(\"rdp_decrypt failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (securityFlags & SEC_REDIRECTION_PKT)\n\t\t{\n\t\t\t/*\n\t\t\t * [MS-RDPBCGR] 2.2.13.2.1\n\t\t\t *  - no share control header, nor the 2 byte pad\n\t\t\t */\n\t\t\ts->p -= 2;\n\t\t\trdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (channelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tif (!freerdp_channel_process(rdp->instance, s, channelId))\n\t\t\treturn -1;\n\t}\n\telse\n\t{\n\t\twhile (stream_get_left(s) > 3)\n\t\t{\n\t\t\tstream_get_mark(s, nextp);\n\n\t\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\t\treturn -1;\n\n\t\t\tnextp += pduLength;\n\n\t\t\trdp->settings->PduSource = pduSource;\n\n\t\t\tswitch (pduType)\n\t\t\t{\n\t\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\t\tif (rdp_recv_data_pdu(rdp, s) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"rdp_recv_data_pdu failed\\n\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\t\t\tif (!rdp_recv_deactivate_all(rdp, s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\t\t\tif (!rdp_recv_enhanced_security_redirection_packet(rdp, s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"incorrect PDU type: 0x%04X\\n\", pduType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream_set_mark(s, nextp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rdp_recv_fastpath_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\n\tfastpath = rdp->fastpath;\n\n\tif (!fastpath_read_header_rdp(fastpath, s, &length))\n\t\treturn -1;\n\n\tif ((length == 0) || (length > stream_get_left(s)))\n\t{\n\t\tprintf(\"incorrect FastPath PDU header length %d\\n\", length);\n\t\treturn -1;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tUINT16 flags = (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0;\n\n\t\tif (!rdp_decrypt(rdp, s, length, flags))\n\t\t\treturn -1;\n\t}\n\n\treturn fastpath_recv_updates(rdp->fastpath, s);\n}\n\nstatic int rdp_recv_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn rdp_recv_tpkt_pdu(rdp, s);\n\telse\n\t\treturn rdp_recv_fastpath_pdu(rdp, s);\n}\n\n/**\n * Receive an RDP packet.\\n\n * @param rdp RDP module\n */\n\nvoid rdp_recv(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\n\ts = transport_recv_stream_init(rdp->transport, 4096);\n\ttransport_read(rdp->transport, s);\n\n\trdp_recv_pdu(rdp, s);\n}\n\nstatic int rdp_recv_callback(rdpTransport* transport, STREAM* s, void* extra)\n{\n\tint status = 0;\n\trdpRdp* rdp = (rdpRdp*) extra;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_client_connect_mcs_connect_response(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_client_connect_mcs_attach_user_confirm(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (!rdp_client_connect_mcs_channel_join_confirm(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_client_connect_license(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_CAPABILITY:\n\t\t\tif (!rdp_client_connect_demand_active(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\t\t\tif ((status >= 0) && (rdp->finalize_sc_pdus == FINALIZE_SC_COMPLETE))\n\t\t\t\trdp->state = CONNECTION_STATE_ACTIVE;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"Invalid state %d\\n\", rdp->state);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nint rdp_send_channel_data(rdpRdp* rdp, int channel_id, BYTE* data, int size)\n{\n\treturn freerdp_channel_send(rdp, channel_id, data, size);\n}\n\n/**\n * Set non-blocking mode information.\n * @param rdp RDP module\n * @param blocking blocking mode\n */\nvoid rdp_set_blocking_mode(rdpRdp* rdp, BOOL blocking)\n{\n\trdp->transport->ReceiveCallback = rdp_recv_callback;\n\trdp->transport->ReceiveExtra = rdp;\n\ttransport_set_blocking_mode(rdp->transport, blocking);\n}\n\nint rdp_check_fds(rdpRdp* rdp)\n{\n\treturn transport_check_fds(&(rdp->transport));\n}\n\n/**\n * Instantiate new RDP module.\n * @return new RDP module\n */\n\nrdpRdp* rdp_new(freerdp* instance)\n{\n\trdpRdp* rdp;\n\n\trdp = (rdpRdp*) malloc(sizeof(rdpRdp));\n\n\tif (rdp != NULL)\n\t{\n\t\tZeroMemory(rdp, sizeof(rdpRdp));\n\n\t\trdp->instance = instance;\n\t\trdp->settings = freerdp_settings_new((void*) instance);\n\n\t\tif (instance != NULL)\n\t\t\tinstance->settings = rdp->settings;\n\n\t\trdp->extension = extension_new(instance);\n\t\trdp->transport = transport_new(rdp->settings);\n\t\trdp->license = license_new(rdp);\n\t\trdp->input = input_new(rdp);\n\t\trdp->update = update_new(rdp);\n\t\trdp->fastpath = fastpath_new(rdp);\n\t\trdp->nego = nego_new(rdp->transport);\n\t\trdp->mcs = mcs_new(rdp->transport);\n\t\trdp->redirection = redirection_new();\n\t\trdp->mppc_dec = mppc_dec_new();\n\t\trdp->mppc_enc = mppc_enc_new(PROTO_RDP_50);\n\t}\n\n\treturn rdp;\n}\n\n/**\n * Free RDP module.\n * @param rdp RDP module to be freed\n */\n\nvoid rdp_free(rdpRdp* rdp)\n{\n\tif (rdp != NULL)\n\t{\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\tcrypto_rc4_free(rdp->rc4_encrypt_key);\n\t\tcrypto_des3_free(rdp->fips_encrypt);\n\t\tcrypto_des3_free(rdp->fips_decrypt);\n\t\tcrypto_hmac_free(rdp->fips_hmac);\n\t\tfreerdp_settings_free(rdp->settings);\n\t\textension_free(rdp->extension);\n\t\ttransport_free(rdp->transport);\n\t\tlicense_free(rdp->license);\n\t\tinput_free(rdp->input);\n\t\tupdate_free(rdp->update);\n\t\tfastpath_free(rdp->fastpath);\n\t\tnego_free(rdp->nego);\n\t\tmcs_free(rdp->mcs);\n\t\tredirection_free(rdp->redirection);\n\t\tmppc_dec_free(rdp->mppc_dec);\n\t\tmppc_enc_free(rdp->mppc_enc);\n\t\tfree(rdp);\n\t}\n}\n\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Security\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"security.h\"\n\n/* 0x36 repeated 40 times */\nstatic const BYTE pad1[40] =\n{\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n};\n\n/* 0x5C repeated 48 times */\nstatic const BYTE pad2[48] =\n{\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n};\n\nstatic const BYTE\nfips_reverse_table[256] =\n{\n\t0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,\n\t0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\n\t0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,\n\t0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\n\t0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,\n\t0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\n\t0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n\t0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\n\t0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,\n\t0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\n\t0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,\n\t0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\n\t0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,\n\t0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n\t0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,\n\t0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\n\t0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,\n\t0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\n\t0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,\n\t0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\n\t0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n\t0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\n\t0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,\n\t0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\n\t0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,\n\t0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\n\t0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,\n\t0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n\t0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,\n\t0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\n\t0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,\n\t0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff\n};\n\nstatic const BYTE\nfips_oddparity_table[256] =\n{\n\t0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x07, 0x07,\n\t0x08, 0x08, 0x0b, 0x0b, 0x0d, 0x0d, 0x0e, 0x0e,\n\t0x10, 0x10, 0x13, 0x13, 0x15, 0x15, 0x16, 0x16,\n\t0x19, 0x19, 0x1a, 0x1a, 0x1c, 0x1c, 0x1f, 0x1f,\n\t0x20, 0x20, 0x23, 0x23, 0x25, 0x25, 0x26, 0x26,\n\t0x29, 0x29, 0x2a, 0x2a, 0x2c, 0x2c, 0x2f, 0x2f,\n\t0x31, 0x31, 0x32, 0x32, 0x34, 0x34, 0x37, 0x37,\n\t0x38, 0x38, 0x3b, 0x3b, 0x3d, 0x3d, 0x3e, 0x3e,\n\t0x40, 0x40, 0x43, 0x43, 0x45, 0x45, 0x46, 0x46,\n\t0x49, 0x49, 0x4a, 0x4a, 0x4c, 0x4c, 0x4f, 0x4f,\n\t0x51, 0x51, 0x52, 0x52, 0x54, 0x54, 0x57, 0x57,\n\t0x58, 0x58, 0x5b, 0x5b, 0x5d, 0x5d, 0x5e, 0x5e,\n\t0x61, 0x61, 0x62, 0x62, 0x64, 0x64, 0x67, 0x67,\n\t0x68, 0x68, 0x6b, 0x6b, 0x6d, 0x6d, 0x6e, 0x6e,\n\t0x70, 0x70, 0x73, 0x73, 0x75, 0x75, 0x76, 0x76,\n\t0x79, 0x79, 0x7a, 0x7a, 0x7c, 0x7c, 0x7f, 0x7f,\n\t0x80, 0x80, 0x83, 0x83, 0x85, 0x85, 0x86, 0x86,\n\t0x89, 0x89, 0x8a, 0x8a, 0x8c, 0x8c, 0x8f, 0x8f,\n\t0x91, 0x91, 0x92, 0x92, 0x94, 0x94, 0x97, 0x97,\n\t0x98, 0x98, 0x9b, 0x9b, 0x9d, 0x9d, 0x9e, 0x9e,\n\t0xa1, 0xa1, 0xa2, 0xa2, 0xa4, 0xa4, 0xa7, 0xa7,\n\t0xa8, 0xa8, 0xab, 0xab, 0xad, 0xad, 0xae, 0xae,\n\t0xb0, 0xb0, 0xb3, 0xb3, 0xb5, 0xb5, 0xb6, 0xb6,\n\t0xb9, 0xb9, 0xba, 0xba, 0xbc, 0xbc, 0xbf, 0xbf,\n\t0xc1, 0xc1, 0xc2, 0xc2, 0xc4, 0xc4, 0xc7, 0xc7,\n\t0xc8, 0xc8, 0xcb, 0xcb, 0xcd, 0xcd, 0xce, 0xce,\n\t0xd0, 0xd0, 0xd3, 0xd3, 0xd5, 0xd5, 0xd6, 0xd6,\n\t0xd9, 0xd9, 0xda, 0xda, 0xdc, 0xdc, 0xdf, 0xdf,\n\t0xe0, 0xe0, 0xe3, 0xe3, 0xe5, 0xe5, 0xe6, 0xe6,\n\t0xe9, 0xe9, 0xea, 0xea, 0xec, 0xec, 0xef, 0xef,\n\t0xf1, 0xf1, 0xf2, 0xf2, 0xf4, 0xf4, 0xf7, 0xf7,\n\t0xf8, 0xf8, 0xfb, 0xfb, 0xfd, 0xfd, 0xfe, 0xfe\n};\n\nstatic void security_salted_hash(const BYTE* salt, const BYTE* input, int length,\n\t\tconst BYTE* salt1, const BYTE* salt2, BYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\t/* SaltedHash(Salt, Input, Salt1, Salt2) = MD5(S + SHA1(Input + Salt + Salt1 + Salt2)) */\n\n\t/* SHA1_Digest = SHA1(Input + Salt + Salt1 + Salt2) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, input, length); /* Input */\n\tcrypto_sha1_update(sha1, salt, 48); /* Salt (48 bytes) */\n\tcrypto_sha1_update(sha1, salt1, 32); /* Salt1 (32 bytes) */\n\tcrypto_sha1_update(sha1, salt2, 32); /* Salt2 (32 bytes) */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* SaltedHash(Salt, Input, Salt1, Salt2) = MD5(S + SHA1_Digest) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, salt, 48); /* Salt (48 bytes) */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, output);\n}\n\nstatic void security_premaster_hash(const char* input, int length, const BYTE* premaster_secret, const BYTE* client_random, const BYTE* server_random, BYTE* output)\n{\n\t/* PremasterHash(Input) = SaltedHash(PremasterSecret, Input, ClientRandom, ServerRandom) */\n\tsecurity_salted_hash(premaster_secret, (BYTE*)input, length, client_random, server_random, output);\n}\n\nvoid security_master_secret(const BYTE* premaster_secret, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MasterSecret = PremasterHash('A') + PremasterHash('BB') + PremasterHash('CCC') */\n\tsecurity_premaster_hash(\"A\", 1, premaster_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"BB\", 2, premaster_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"CCC\", 3, premaster_secret, client_random, server_random, &output[32]);\n}\n\nstatic void security_master_hash(const char* input, int length, const BYTE* master_secret,\n\t\tconst BYTE* client_random, const BYTE* server_random, BYTE* output)\n{\n\t/* MasterHash(Input) = SaltedHash(MasterSecret, Input, ServerRandom, ClientRandom) */\n\tsecurity_salted_hash(master_secret, (const BYTE*)input, length, server_random, client_random, output);\n}\n\nvoid security_session_key_blob(const BYTE* master_secret, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MasterHash = MasterHash('A') + MasterHash('BB') + MasterHash('CCC') */\n\tsecurity_master_hash(\"A\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_master_hash(\"BB\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_master_hash(\"CCC\", 3, master_secret, client_random, server_random, &output[32]);\n}\n\nvoid security_mac_salt_key(const BYTE* session_key_blob, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MacSaltKey = First128Bits(SessionKeyBlob) */\n\tmemcpy(output, session_key_blob, 16);\n}\n\nvoid security_md5_16_32_32(const BYTE* in0, const BYTE* in1, const BYTE* in2, BYTE* output)\n{\n\tCryptoMd5 md5;\n\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, in0, 16);\n\tcrypto_md5_update(md5, in1, 32);\n\tcrypto_md5_update(md5, in2, 32);\n\tcrypto_md5_final(md5, output);\n}\n\nvoid security_licensing_encryption_key(const BYTE* session_key_blob, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* LicensingEncryptionKey = MD5(Second128Bits(SessionKeyBlob) + ClientRandom + ServerRandom)) */\n\tsecurity_md5_16_32_32(&session_key_blob[16], client_random, server_random, output);\n}\n\nvoid security_UINT32_le(BYTE* output, UINT32 value)\n{\n\toutput[0] = (value) & 0xFF;\n\toutput[1] = (value >> 8) & 0xFF;\n\toutput[2] = (value >> 16) & 0xFF;\n\toutput[3] = (value >> 24) & 0xFF;\n}\n\nvoid security_mac_data(const BYTE* mac_salt_key, const BYTE* data, UINT32 length,\n\t\tBYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE length_le[4];\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\t/* MacData = MD5(MacSaltKey + pad2 + SHA1(MacSaltKey + pad1 + length + data)) */\n\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\t/* SHA1_Digest = SHA1(MacSaltKey + pad1 + length + data) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, mac_salt_key, 16); /* MacSaltKey */\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1)); /* pad1 */\n\tcrypto_sha1_update(sha1, length_le, sizeof(length_le)); /* length */\n\tcrypto_sha1_update(sha1, data, length); /* data */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* MacData = MD5(MacSaltKey + pad2 + SHA1_Digest) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, mac_salt_key, 16); /* MacSaltKey */\n\tcrypto_md5_update(md5, pad2, sizeof(pad2)); /* pad2 */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, output);\n}\n\nvoid security_mac_signature(rdpRdp *rdp, const BYTE* data, UINT32 length, BYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE length_le[4];\n\tBYTE md5_digest[CRYPTO_MD5_DIGEST_LENGTH];\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\t/* SHA1_Digest = SHA1(MACKeyN + pad1 + length + data) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1)); /* pad1 */\n\tcrypto_sha1_update(sha1, length_le, sizeof(length_le)); /* length */\n\tcrypto_sha1_update(sha1, data, length); /* data */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* MACSignature = First64Bits(MD5(MACKeyN + pad2 + SHA1_Digest)) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_md5_update(md5, pad2, sizeof(pad2)); /* pad2 */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, md5_digest);\n\n\tmemcpy(output, md5_digest, 8);\n}\n\nvoid security_salted_mac_signature(rdpRdp *rdp, const BYTE* data, UINT32 length,\n\t\tBOOL encryption, BYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE length_le[4];\n\tBYTE use_count_le[4];\n\tBYTE md5_digest[CRYPTO_MD5_DIGEST_LENGTH];\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\tif (encryption)\n\t{\n\t\tsecurity_UINT32_le(use_count_le, rdp->encrypt_checksum_use_count);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We calculate checksum on plain text, so we must have already\n\t\t * decrypt it, which means decrypt_checksum_use_count is off by one.\n\t\t */\n\t\tsecurity_UINT32_le(use_count_le, rdp->decrypt_checksum_use_count - 1);\n\t}\n\n\t/* SHA1_Digest = SHA1(MACKeyN + pad1 + length + data) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1)); /* pad1 */\n\tcrypto_sha1_update(sha1, length_le, sizeof(length_le)); /* length */\n\tcrypto_sha1_update(sha1, data, length); /* data */\n\tcrypto_sha1_update(sha1, use_count_le, sizeof(use_count_le)); /* encryptionCount */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* MACSignature = First64Bits(MD5(MACKeyN + pad2 + SHA1_Digest)) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_md5_update(md5, pad2, sizeof(pad2)); /* pad2 */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, md5_digest);\n\n\tmemcpy(output, md5_digest, 8);\n}\n\nstatic void security_A(BYTE* master_secret, const BYTE* client_random, BYTE* server_random,\n\t\tBYTE* output)\n{\n\tsecurity_premaster_hash(\"A\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"BB\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"CCC\", 3, master_secret, client_random, server_random, &output[32]);\n}\n\nstatic void security_X(BYTE* master_secret, const BYTE* client_random, BYTE* server_random,\n\t\tBYTE* output)\n{\n\tsecurity_premaster_hash(\"X\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"YY\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"ZZZ\", 3, master_secret, client_random, server_random, &output[32]);\n}\n\nstatic void fips_expand_key_bits(BYTE* in, BYTE* out)\n{\n\tBYTE buf[21], c;\n\tint i, b, p, r;\n\n\t/* reverse every byte in the key */\n\tfor (i = 0; i < 21; i++)\n\t\tbuf[i] = fips_reverse_table[in[i]];\n\n\t/* insert a zero-bit after every 7th bit */\n\tfor (i = 0, b = 0; i < 24; i++, b += 7)\n\t{\n\t\tp = b / 8;\n\t\tr = b % 8;\n\t\tif (r == 0)\n\t\t{\n\t\t\tout[i] = buf[p] & 0xfe;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* c is accumulator */\n\t\t\tc = buf[p] << r;\n\t\t\tc |= buf[p + 1] >> (8 - r);\n\t\t\tout[i] = c & 0xfe;\n\t\t}\n\t}\n\n\t/* reverse every byte */\n\t/* alter lsb so the byte has odd parity */\n\tfor (i = 0; i < 24; i++)\n\t\tout[i] = fips_oddparity_table[fips_reverse_table[out[i]]];\n}\n\nBOOL security_establish_keys(const BYTE* client_random, rdpRdp* rdp)\n{\n\tBYTE pre_master_secret[48];\n\tBYTE master_secret[48];\n\tBYTE session_key_blob[48];\n\tBYTE* server_random;\n\tBYTE salt40[] = { 0xD1, 0x26, 0x9E };\n\trdpSettings* settings;\n\n\tsettings = rdp->settings;\n\tserver_random = settings->ServerRandom;\n\n\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tCryptoSha1 sha1;\n\t\tBYTE client_encrypt_key_t[CRYPTO_SHA1_DIGEST_LENGTH + 1];\n\t\tBYTE client_decrypt_key_t[CRYPTO_SHA1_DIGEST_LENGTH + 1];\n\n\t\tprintf(\"FIPS Compliant encryption level.\\n\");\n\n\t\t/* disable fastpath input; it doesnt handle FIPS encryption yet */\n\t\trdp->settings->FastPathInput = FALSE;\n\n\t\tsha1 = crypto_sha1_init();\n\t\tcrypto_sha1_update(sha1, client_random + 16, 16);\n\t\tcrypto_sha1_update(sha1, server_random + 16, 16);\n\t\tcrypto_sha1_final(sha1, client_encrypt_key_t);\n\n\t\tclient_encrypt_key_t[20] = client_encrypt_key_t[0];\n\t\tfips_expand_key_bits(client_encrypt_key_t, rdp->fips_encrypt_key);\n\n\t\tsha1 = crypto_sha1_init();\n\t\tcrypto_sha1_update(sha1, client_random, 16);\n\t\tcrypto_sha1_update(sha1, server_random, 16);\n\t\tcrypto_sha1_final(sha1, client_decrypt_key_t);\n\n\t\tclient_decrypt_key_t[20] = client_decrypt_key_t[0];\n\t\tfips_expand_key_bits(client_decrypt_key_t, rdp->fips_decrypt_key);\n\n\t\tsha1 = crypto_sha1_init();\n\t\tcrypto_sha1_update(sha1, client_decrypt_key_t, 20);\n\t\tcrypto_sha1_update(sha1, client_encrypt_key_t, 20);\n\t\tcrypto_sha1_final(sha1, rdp->fips_sign_key);\n\t}\n\n\tmemcpy(pre_master_secret, client_random, 24);\n\tmemcpy(pre_master_secret + 24, server_random, 24);\n\n\tsecurity_A(pre_master_secret, client_random, server_random, master_secret);\n\tsecurity_X(master_secret, client_random, server_random, session_key_blob);\n\n\tmemcpy(rdp->sign_key, session_key_blob, 16);\n\n\tif (rdp->settings->ServerMode)\n\t{\n\t\tsecurity_md5_16_32_32(&session_key_blob[16], client_random,\n\t\t    server_random, rdp->encrypt_key);\n\t\tsecurity_md5_16_32_32(&session_key_blob[32], client_random,\n\t\t    server_random, rdp->decrypt_key);\n\t}\n\telse\n\t{\n\t\tsecurity_md5_16_32_32(&session_key_blob[16], client_random,\n\t\t    server_random, rdp->decrypt_key);\n\t\tsecurity_md5_16_32_32(&session_key_blob[32], client_random,\n\t\t    server_random, rdp->encrypt_key);\n\t}\n\n\tif (settings->EncryptionMethods == 1) /* 40 and 56 bit */\n\t{\n\t\tmemcpy(rdp->sign_key, salt40, 3); /* TODO 56 bit */\n\t\tmemcpy(rdp->decrypt_key, salt40, 3); /* TODO 56 bit */\n\t\tmemcpy(rdp->encrypt_key, salt40, 3); /* TODO 56 bit */\n\t\trdp->rc4_key_len = 8;\n\t}\n\telse if (settings->EncryptionMethods == 2) /* 128 bit */\n\t{\n\t\trdp->rc4_key_len = 16;\n\t}\n\n\tmemcpy(rdp->decrypt_update_key, rdp->decrypt_key, 16);\n\tmemcpy(rdp->encrypt_update_key, rdp->encrypt_key, 16);\n\trdp->decrypt_use_count = 0;\n\trdp->decrypt_checksum_use_count = 0;\n\trdp->encrypt_use_count =0;\n\trdp->encrypt_checksum_use_count =0;\n\n\treturn TRUE;\n}\n\nBOOL security_key_update(BYTE* key, BYTE* update_key, int key_len)\n{\n\tBYTE sha1h[CRYPTO_SHA1_DIGEST_LENGTH];\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tCryptoRc4 rc4;\n\tBYTE salt40[] = { 0xD1, 0x26, 0x9E };\n\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, update_key, key_len);\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1));\n\tcrypto_sha1_update(sha1, key, key_len);\n\tcrypto_sha1_final(sha1, sha1h);\n\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, update_key, key_len);\n\tcrypto_md5_update(md5, pad2, sizeof(pad2));\n\tcrypto_md5_update(md5, sha1h, sizeof(sha1h));\n\tcrypto_md5_final(md5, key);\n\n\trc4 = crypto_rc4_init(key, key_len);\n\tcrypto_rc4(rc4, key_len, key, key);\n\tcrypto_rc4_free(rc4);\n\n\tif (key_len == 8)\n\t\tmemcpy(key, salt40, 3); /* TODO 56 bit */\n\n\treturn TRUE;\n}\n\nBOOL security_encrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->encrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->encrypt_key, rdp->encrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_encrypt_key);\n\t\trdp->rc4_encrypt_key = crypto_rc4_init(rdp->encrypt_key, rdp->rc4_key_len);\n\t\trdp->encrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_encrypt_key, length, data, data);\n\trdp->encrypt_use_count++;\n\trdp->encrypt_checksum_use_count++;\n\treturn TRUE;\n}\n\nBOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}\n\nvoid security_hmac_signature(const BYTE* data, int length, BYTE* output, rdpRdp* rdp)\n{\n\tBYTE buf[20];\n\tBYTE use_count_le[4];\n\n\tsecurity_UINT32_le(use_count_le, rdp->encrypt_use_count);\n\n\tcrypto_hmac_sha1_init(rdp->fips_hmac, rdp->fips_sign_key, 20);\n\tcrypto_hmac_update(rdp->fips_hmac, data, length);\n\tcrypto_hmac_update(rdp->fips_hmac, use_count_le, 4);\n\tcrypto_hmac_final(rdp->fips_hmac, buf, 20);\n\n\tmemmove(output, buf, 8);\n}\n\nBOOL security_fips_encrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tcrypto_des3_encrypt(rdp->fips_encrypt, length, data, data);\n\trdp->encrypt_use_count++;\n\treturn TRUE;\n}\n\nBOOL security_fips_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tcrypto_des3_decrypt(rdp->fips_decrypt, length, data, data);\n\treturn TRUE;\n}\n\nBOOL security_fips_check_signature(const BYTE* data, int length, const BYTE* sig, rdpRdp* rdp)\n{\n\tBYTE buf[20];\n\tBYTE use_count_le[4];\n\n\tsecurity_UINT32_le(use_count_le, rdp->decrypt_use_count);\n\n\tcrypto_hmac_sha1_init(rdp->fips_hmac, rdp->fips_sign_key, 20);\n\tcrypto_hmac_update(rdp->fips_hmac, data, length);\n\tcrypto_hmac_update(rdp->fips_hmac, use_count_le, 4);\n\tcrypto_hmac_final(rdp->fips_hmac, buf, 20);\n\n\trdp->decrypt_use_count++;\n\n\tif (memcmp(sig, buf, 8))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"rdp.h\"\n\n#include \"info.h\"\n#include \"redirection.h\"\n\n#include <freerdp/crypto/per.h>\n\n#ifdef WITH_DEBUG_RDP\nstatic const char* const DATA_PDU_TYPE_STRINGS[] =\n{\n\t\t\"?\", \"?\", /* 0x00 - 0x01 */\n\t\t\"Update\", /* 0x02 */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", /* 0x03 - 0x0A */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", /* 0x0B - 0x13 */\n\t\t\"Control\", /* 0x14 */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\", /* 0x15 - 0x1A */\n\t\t\"Pointer\", /* 0x1B */\n\t\t\"Input\", /* 0x1C */\n\t\t\"?\", \"?\", /* 0x1D - 0x1E */\n\t\t\"Synchronize\", /* 0x1F */\n\t\t\"?\", /* 0x20 */\n\t\t\"Refresh Rect\", /* 0x21 */\n\t\t\"Play Sound\", /* 0x22 */\n\t\t\"Suppress Output\", /* 0x23 */\n\t\t\"Shutdown Request\", /* 0x24 */\n\t\t\"Shutdown Denied\", /* 0x25 */\n\t\t\"Save Session Info\", /* 0x26 */\n\t\t\"Font List\", /* 0x27 */\n\t\t\"Font Map\", /* 0x28 */\n\t\t\"Set Keyboard Indicators\", /* 0x29 */\n\t\t\"?\", /* 0x2A */\n\t\t\"Bitmap Cache Persistent List\", /* 0x2B */\n\t\t\"Bitmap Cache Error\", /* 0x2C */\n\t\t\"Set Keyboard IME Status\", /* 0x2D */\n\t\t\"Offscreen Cache Error\", /* 0x2E */\n\t\t\"Set Error Info\", /* 0x2F */\n\t\t\"Draw Nine Grid Error\", /* 0x30 */\n\t\t\"Draw GDI+ Error\", /* 0x31 */\n\t\t\"ARC Status\", /* 0x32 */\n\t\t\"?\", \"?\", \"?\", /* 0x33 - 0x35 */\n\t\t\"Status Info\", /* 0x36 */\n\t\t\"Monitor Layout\" /* 0x37 */\n\t\t\"?\", \"?\", \"?\", /* 0x38 - 0x40 */\n\t\t\"?\", \"?\", \"?\", \"?\", \"?\", \"?\" /* 0x41 - 0x46 */\n};\n#endif\n\n/**\n * Read RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nBOOL rdp_read_security_header(STREAM* s, UINT16* flags)\n{\n\t/* Basic Security Header */\n\tif(stream_get_left(s) < 4)\n\t\treturn FALSE;\n\tstream_read_UINT16(s, *flags); /* flags */\n\tstream_seek(s, 2); /* flagsHi (unused) */\n\treturn TRUE;\n}\n\n/**\n * Write RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nvoid rdp_write_security_header(STREAM* s, UINT16 flags)\n{\n\t/* Basic Security Header */\n\tstream_write_UINT16(s, flags); /* flags */\n\tstream_write_UINT16(s, 0); /* flagsHi (unused) */\n}\n\nBOOL rdp_read_share_control_header(STREAM* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (stream_get_left(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tstream_read_UINT16(s, *length); /* totalLength */\n\n\tif (*length - 2 > stream_get_left(s))\n\t\treturn FALSE;\n\n\tstream_read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F; /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tstream_read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}\n\nvoid rdp_write_share_control_header(STREAM* s, UINT16 length, UINT16 type, UINT16 channel_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\n\t/* Share Control Header */\n\tstream_write_UINT16(s, length); /* totalLength */\n\tstream_write_UINT16(s, type | 0x10); /* pduType */\n\tstream_write_UINT16(s, channel_id); /* pduSource */\n}\n\nBOOL rdp_read_share_data_header(STREAM* s, UINT16* length, BYTE* type, UINT32* share_id,\n\t\t\t\t\tBYTE *compressed_type, UINT16 *compressed_len)\n{\n\tif (stream_get_left(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tstream_read_UINT32(s, *share_id); /* shareId (4 bytes) */\n\tstream_seek_BYTE(s); /* pad1 (1 byte) */\n\tstream_seek_BYTE(s); /* streamId (1 byte) */\n\tstream_read_UINT16(s, *length); /* uncompressedLength (2 bytes) */\n\tstream_read_BYTE(s, *type); /* pduType2, Data PDU Type (1 byte) */\n\tstream_read_BYTE(s, *compressed_type); /* compressedType (1 byte) */\n\tstream_read_UINT16(s, *compressed_len); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n\nvoid rdp_write_share_data_header(STREAM* s, UINT16 length, BYTE type, UINT32 share_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\tlength -= RDP_SHARE_CONTROL_HEADER_LENGTH;\n\tlength -= RDP_SHARE_DATA_HEADER_LENGTH;\n\n\t/* Share Data Header */\n\tstream_write_UINT32(s, share_id); /* shareId (4 bytes) */\n\tstream_write_BYTE(s, 0); /* pad1 (1 byte) */\n\tstream_write_BYTE(s, STREAM_LOW); /* streamId (1 byte) */\n\tstream_write_UINT16(s, length); /* uncompressedLength (2 bytes) */\n\tstream_write_BYTE(s, type); /* pduType2, Data PDU Type (1 byte) */\n\tstream_write_BYTE(s, 0); /* compressedType (1 byte) */\n\tstream_write_UINT16(s, 0); /* compressedLength (2 bytes) */\n}\n\nstatic int rdp_security_stream_init(rdpRdp* rdp, STREAM* s)\n{\n\tif (rdp->do_crypt)\n\t{\n\t\tstream_seek(s, 12);\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tstream_seek(s, 4);\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0)\n\t{\n\t\tstream_seek(s, 4);\n\t}\n\n\treturn 0;\n}\n\n/**\n * Initialize an RDP packet stream.\\n\n * @param rdp rdp module\n * @return\n */\n\nSTREAM* rdp_send_stream_init(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\n\ts = transport_send_stream_init(rdp->transport, 2048);\n\tstream_seek(s, RDP_PACKET_HEADER_MAX_LENGTH);\n\trdp_security_stream_init(rdp, s);\n\n\treturn s;\n}\n\nSTREAM* rdp_pdu_init(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\ts = transport_send_stream_init(rdp->transport, 2048);\n\tstream_seek(s, RDP_PACKET_HEADER_MAX_LENGTH);\n\trdp_security_stream_init(rdp, s);\n\tstream_seek(s, RDP_SHARE_CONTROL_HEADER_LENGTH);\n\treturn s;\n}\n\nSTREAM* rdp_data_pdu_init(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\ts = transport_send_stream_init(rdp->transport, 2048);\n\tstream_seek(s, RDP_PACKET_HEADER_MAX_LENGTH);\n\trdp_security_stream_init(rdp, s);\n\tstream_seek(s, RDP_SHARE_CONTROL_HEADER_LENGTH);\n\tstream_seek(s, RDP_SHARE_DATA_HEADER_LENGTH);\n\treturn s;\n}\n\n/**\n * Read an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nBOOL rdp_read_header(rdpRdp* rdp, STREAM* s, UINT16* length, UINT16* channel_id)\n{\n\tUINT16 initiator;\n\tenum DomainMCSPDU MCSPDU;\n\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataRequest : DomainMCSPDU_SendDataIndication;\n\n\tif (!mcs_read_domain_mcspdu_header(s, &MCSPDU, length))\n\t{\n\t\tif (MCSPDU != DomainMCSPDU_DisconnectProviderUltimatum)\n\t\t\treturn FALSE;\n\t}\n\n\tif (*length - 8 > stream_get_left(s))\n\t\treturn FALSE;\n\n\tif (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)\n\t{\n\t\tBYTE reason;\n\n\t\t(void) per_read_enumerated(s, &reason, 0);\n\t\tDEBUG_RDP(\"DisconnectProviderUltimatum from server, reason code 0x%02x\\n\", reason);\n\n\t\trdp->disconnect = TRUE;\n\n\t\treturn TRUE;\n\t}\n\n\tif(stream_get_left(s) < 5)\n\t\treturn FALSE;\n\tper_read_integer16(s, &initiator, MCS_BASE_CHANNEL_ID); /* initiator (UserId) */\n\tper_read_integer16(s, channel_id, 0); /* channelId */\n\tstream_seek(s, 1); /* dataPriority + Segmentation (0x70) */\n\n\tif(!per_read_length(s, length)) /* userData (OCTET_STRING) */\n\t\treturn FALSE;\n\tif (*length > stream_get_left(s))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nvoid rdp_write_header(rdpRdp* rdp, STREAM* s, UINT16 length, UINT16 channel_id)\n{\n\tint body_length;\n\tenum DomainMCSPDU MCSPDU;\n\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataIndication : DomainMCSPDU_SendDataRequest;\n\n\tif ((rdp->sec_flags & SEC_ENCRYPT) && (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS))\n\t{\n\t\tint pad;\n\n\t\tbody_length = length - RDP_PACKET_HEADER_MAX_LENGTH - 16;\n\t\tpad = 8 - (body_length % 8);\n\n\t\tif (pad != 8)\n\t\t\tlength += pad;\n\t}\n\n\tmcs_write_domain_mcspdu_header(s, MCSPDU, length, 0);\n\tper_write_integer16(s, rdp->mcs->user_id, MCS_BASE_CHANNEL_ID); /* initiator */\n\tper_write_integer16(s, channel_id, 0); /* channelId */\n\tstream_write_BYTE(s, 0x70); /* dataPriority + segmentation */\n\t/*\n\t * We always encode length in two bytes, eventhough we could use\n\t * only one byte if length <= 0x7F. It is just easier that way,\n\t * because we can leave room for fixed-length header, store all\n\t * the data first and then store the header.\n\t */\n\tlength = (length - RDP_PACKET_HEADER_MAX_LENGTH) | 0x8000;\n\tstream_write_UINT16_be(s, length); /* userData (OCTET_STRING) */\n}\n\nstatic UINT32 rdp_security_stream_out(rdpRdp* rdp, STREAM* s, int length)\n{\n\tBYTE* data;\n\tUINT32 sec_flags;\n\tUINT32 pad = 0;\n\n\tsec_flags = rdp->sec_flags;\n\n\tif (sec_flags != 0)\n\t{\n\t\trdp_write_security_header(s, sec_flags);\n\n\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tdata = s->p + 12;\n\n\t\t\t\tlength = length - (data - s->data);\n\t\t\t\tstream_write_UINT16(s, 0x10); /* length */\n\t\t\t\tstream_write_BYTE(s, 0x1); /* TSFIPS_VERSION 1*/\n\n\t\t\t\t/* handle padding */\n\t\t\t\tpad = 8 - (length % 8);\n\n\t\t\t\tif (pad == 8)\n\t\t\t\t\tpad = 0;\n\t\t\t\tif (pad)\n\t\t\t\t\tmemset(data+length, 0, pad);\n\n\t\t\t\tstream_write_BYTE(s, pad);\n\n\t\t\t\tsecurity_hmac_signature(data, length, s->p, rdp);\n\t\t\t\tstream_seek(s, 8);\n\t\t\t\tsecurity_fips_encrypt(data, length + pad, rdp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata = s->p + 8;\n\t\t\t\tlength = length - (data - s->data);\n\t\t\t\tif (sec_flags & SEC_SECURE_CHECKSUM)\n\t\t\t\t\tsecurity_salted_mac_signature(rdp, data, length, TRUE, s->p);\n\t\t\t\telse\n\t\t\t\t\tsecurity_mac_signature(rdp, data, length, s->p);\n\t\t\t\tstream_seek(s, 8);\n\t\t\t\tsecurity_encrypt(s->p, length, rdp);\n\t\t\t}\n\t\t}\n\n\t\trdp->sec_flags = 0;\n\t}\n\n\treturn pad;\n}\n\nstatic UINT32 rdp_get_sec_bytes(rdpRdp* rdp)\n{\n\tUINT32 sec_bytes;\n\n\tif (rdp->sec_flags & SEC_ENCRYPT)\n\t{\n\t\tsec_bytes = 12;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tsec_bytes += 4;\n\t}\n\telse if (rdp->sec_flags != 0)\n\t{\n\t\tsec_bytes = 4;\n\t}\n\telse\n\t{\n\t\tsec_bytes = 0;\n\t}\n\n\treturn sec_bytes;\n}\n\n/**\n * Send an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param channel_id channel id\n */\n\nBOOL rdp_send(rdpRdp* rdp, STREAM* s, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tBYTE* sec_hold;\n\n\tlength = stream_get_length(s);\n\tstream_set_pos(s, 0);\n\n\trdp_write_header(rdp, s, length, channel_id);\n\n\tsec_bytes = rdp_get_sec_bytes(rdp);\n\tsec_hold = s->p;\n\tstream_seek(s, sec_bytes);\n\n\ts->p = sec_hold;\n\tlength += rdp_security_stream_out(rdp, s, length);\n\n\tstream_set_pos(s, length);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_pdu(rdpRdp* rdp, STREAM* s, UINT16 type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tBYTE* sec_hold;\n\n\tlength = stream_get_length(s);\n\tstream_set_pos(s, 0);\n\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\n\tsec_bytes = rdp_get_sec_bytes(rdp);\n\tsec_hold = s->p;\n\tstream_seek(s, sec_bytes);\n\n\trdp_write_share_control_header(s, length - sec_bytes, type, channel_id);\n\n\ts->p = sec_hold;\n\tlength += rdp_security_stream_out(rdp, s, length);\n\n\tstream_set_pos(s, length);\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_data_pdu(rdpRdp* rdp, STREAM* s, BYTE type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tBYTE* sec_hold;\n\n\tlength = stream_get_length(s);\n\tstream_set_pos(s, 0);\n\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\n\tsec_bytes = rdp_get_sec_bytes(rdp);\n\tsec_hold = s->p;\n\tstream_seek(s, sec_bytes);\n\n\trdp_write_share_control_header(s, length - sec_bytes, PDU_TYPE_DATA, channel_id);\n\trdp_write_share_data_header(s, length - sec_bytes, type, rdp->settings->ShareId);\n\n\ts->p = sec_hold;\n\tlength += rdp_security_stream_out(rdp, s, length);\n\n\tstream_set_pos(s, length);\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_recv_set_error_info_data_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tif (stream_get_left(s) < 4)\n\t\treturn FALSE;\n\n\tstream_read_UINT32(s, rdp->errorInfo); /* errorInfo (4 bytes) */\n\n\tif (rdp->errorInfo != ERRINFO_SUCCESS)\n\t\trdp_print_errinfo(rdp->errorInfo);\n\n\treturn TRUE;\n}\n\nint rdp_recv_data_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tBYTE type;\n\tUINT16 length;\n\tUINT32 share_id;\n\tBYTE compressed_type;\n\tUINT16 compressed_len;\n\tUINT32 roff;\n\tUINT32 rlen;\n\tSTREAM* comp_stream;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &share_id, &compressed_type, &compressed_len))\n\t\treturn -1;\n\n\tcomp_stream = s;\n\n\tif (compressed_type & PACKET_COMPRESSED)\n\t{\n\t\tif (stream_get_left(s) < compressed_len - 18)\n\t\t{\n\t\t\tprintf(\"decompress_rdp: not enough bytes for compressed_len=%d\\n\", compressed_len);\n\t\t\treturn -1;\t\n\t\t}\n\t\tif (decompress_rdp(rdp->mppc_dec, s->p, compressed_len - 18, compressed_type, &roff, &rlen))\n\t\t{\n\t\t\tcomp_stream = stream_new(0);\n\t\t\tcomp_stream->data = rdp->mppc_dec->history_buf + roff;\n\t\t\tcomp_stream->p = comp_stream->data;\n\t\t\tcomp_stream->size = rlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"decompress_rdp() failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tstream_seek(s, compressed_len - 18);\n\t}\n\n#ifdef WITH_DEBUG_RDP\n\t/* if (type != DATA_PDU_TYPE_UPDATE) */\n\t\tDEBUG_RDP(\"recv %s Data PDU (0x%02X), length:%d\",\n\t\t\t\ttype < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type, length);\n#endif\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_UPDATE:\n\t\t\tif (!update_recv(rdp->update, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_recv_server_control_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_POINTER:\n\t\t\tif (!update_recv_pointer(rdp->update, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_INPUT:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_synchronize_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_REFRESH_RECT:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_PLAY_SOUND:\n\t\t\tif (!update_recv_play_sound(rdp->update, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SUPPRESS_OUTPUT:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_REQUEST:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_DENIED:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SAVE_SESSION_INFO:\n\t\t\tif(!rdp_recv_save_session_info(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_LIST:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_MAP:\n\t\t\tif(!rdp_recv_font_map_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_OFFSCREEN_CACHE_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_ERROR_INFO:\n\t\t\tif (!rdp_recv_set_error_info_data_pdu(rdp, comp_stream))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_DRAW_NINEGRID_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_DRAW_GDIPLUS_ERROR:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_ARC_STATUS:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_STATUS_INFO:\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_MONITOR_LAYOUT:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (comp_stream != s)\n\t{\n\t\tstream_detach(comp_stream);\n\t\tstream_free(comp_stream);\n\t}\n\n\treturn 0;\n}\n\nBOOL rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tUINT16 channelId;\n\n\tif (!rdp_read_share_control_header(s, &length, &type, &channelId))\n\t\treturn FALSE;\n\n\tif (type == PDU_TYPE_DATA)\n\t{\n\t\treturn (rdp_recv_data_pdu(rdp, s) < 0) ? FALSE : TRUE;\n\t}\n\telse if (type == PDU_TYPE_SERVER_REDIRECTION)\n\t{\n\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\n/**\n * Decrypt an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param length int\n */\n\nBOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tif (!security_decrypt(s->p, length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Process an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n */\n\nstatic int rdp_recv_tpkt_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags;\n\tBYTE* nextp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tprintf(\"Incorrect RDP header.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rdp->settings->DisableEncryption)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & (SEC_ENCRYPT | SEC_REDIRECTION_PKT))\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length - 4, securityFlags))\n\t\t\t{\n\t\t\t\tprintf(\"rdp_decrypt failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (securityFlags & SEC_REDIRECTION_PKT)\n\t\t{\n\t\t\t/*\n\t\t\t * [MS-RDPBCGR] 2.2.13.2.1\n\t\t\t *  - no share control header, nor the 2 byte pad\n\t\t\t */\n\t\t\ts->p -= 2;\n\t\t\trdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (channelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tif (!freerdp_channel_process(rdp->instance, s, channelId))\n\t\t\treturn -1;\n\t}\n\telse\n\t{\n\t\twhile (stream_get_left(s) > 3)\n\t\t{\n\t\t\tstream_get_mark(s, nextp);\n\n\t\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\t\treturn -1;\n\n\t\t\tnextp += pduLength;\n\n\t\t\trdp->settings->PduSource = pduSource;\n\n\t\t\tswitch (pduType)\n\t\t\t{\n\t\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\t\tif (rdp_recv_data_pdu(rdp, s) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"rdp_recv_data_pdu failed\\n\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\t\t\tif (!rdp_recv_deactivate_all(rdp, s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\t\t\tif (!rdp_recv_enhanced_security_redirection_packet(rdp, s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"incorrect PDU type: 0x%04X\\n\", pduType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstream_set_mark(s, nextp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rdp_recv_fastpath_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\n\tfastpath = rdp->fastpath;\n\n\tif (!fastpath_read_header_rdp(fastpath, s, &length))\n\t\treturn -1;\n\n\tif ((length == 0) || (length > stream_get_left(s)))\n\t{\n\t\tprintf(\"incorrect FastPath PDU header length %d\\n\", length);\n\t\treturn -1;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tUINT16 flags = (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0;\n\n\t\tif (!rdp_decrypt(rdp, s, length, flags))\n\t\t\treturn -1;\n\t}\n\n\treturn fastpath_recv_updates(rdp->fastpath, s);\n}\n\nstatic int rdp_recv_pdu(rdpRdp* rdp, STREAM* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn rdp_recv_tpkt_pdu(rdp, s);\n\telse\n\t\treturn rdp_recv_fastpath_pdu(rdp, s);\n}\n\n/**\n * Receive an RDP packet.\\n\n * @param rdp RDP module\n */\n\nvoid rdp_recv(rdpRdp* rdp)\n{\n\tSTREAM* s;\n\n\ts = transport_recv_stream_init(rdp->transport, 4096);\n\ttransport_read(rdp->transport, s);\n\n\trdp_recv_pdu(rdp, s);\n}\n\nstatic int rdp_recv_callback(rdpTransport* transport, STREAM* s, void* extra)\n{\n\tint status = 0;\n\trdpRdp* rdp = (rdpRdp*) extra;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_client_connect_mcs_connect_response(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_client_connect_mcs_attach_user_confirm(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (!rdp_client_connect_mcs_channel_join_confirm(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_client_connect_license(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_CAPABILITY:\n\t\t\tif (!rdp_client_connect_demand_active(rdp, s))\n\t\t\t\tstatus = -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\t\t\tif ((status >= 0) && (rdp->finalize_sc_pdus == FINALIZE_SC_COMPLETE))\n\t\t\t\trdp->state = CONNECTION_STATE_ACTIVE;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"Invalid state %d\\n\", rdp->state);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nint rdp_send_channel_data(rdpRdp* rdp, int channel_id, BYTE* data, int size)\n{\n\treturn freerdp_channel_send(rdp, channel_id, data, size);\n}\n\n/**\n * Set non-blocking mode information.\n * @param rdp RDP module\n * @param blocking blocking mode\n */\nvoid rdp_set_blocking_mode(rdpRdp* rdp, BOOL blocking)\n{\n\trdp->transport->ReceiveCallback = rdp_recv_callback;\n\trdp->transport->ReceiveExtra = rdp;\n\ttransport_set_blocking_mode(rdp->transport, blocking);\n}\n\nint rdp_check_fds(rdpRdp* rdp)\n{\n\treturn transport_check_fds(&(rdp->transport));\n}\n\n/**\n * Instantiate new RDP module.\n * @return new RDP module\n */\n\nrdpRdp* rdp_new(freerdp* instance)\n{\n\trdpRdp* rdp;\n\n\trdp = (rdpRdp*) malloc(sizeof(rdpRdp));\n\n\tif (rdp != NULL)\n\t{\n\t\tZeroMemory(rdp, sizeof(rdpRdp));\n\n\t\trdp->instance = instance;\n\t\trdp->settings = freerdp_settings_new((void*) instance);\n\n\t\tif (instance != NULL)\n\t\t\tinstance->settings = rdp->settings;\n\n\t\trdp->extension = extension_new(instance);\n\t\trdp->transport = transport_new(rdp->settings);\n\t\trdp->license = license_new(rdp);\n\t\trdp->input = input_new(rdp);\n\t\trdp->update = update_new(rdp);\n\t\trdp->fastpath = fastpath_new(rdp);\n\t\trdp->nego = nego_new(rdp->transport);\n\t\trdp->mcs = mcs_new(rdp->transport);\n\t\trdp->redirection = redirection_new();\n\t\trdp->mppc_dec = mppc_dec_new();\n\t\trdp->mppc_enc = mppc_enc_new(PROTO_RDP_50);\n\t}\n\n\treturn rdp;\n}\n\n/**\n * Free RDP module.\n * @param rdp RDP module to be freed\n */\n\nvoid rdp_free(rdpRdp* rdp)\n{\n\tif (rdp != NULL)\n\t{\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\tcrypto_rc4_free(rdp->rc4_encrypt_key);\n\t\tcrypto_des3_free(rdp->fips_encrypt);\n\t\tcrypto_des3_free(rdp->fips_decrypt);\n\t\tcrypto_hmac_free(rdp->fips_hmac);\n\t\tfreerdp_settings_free(rdp->settings);\n\t\textension_free(rdp->extension);\n\t\ttransport_free(rdp->transport);\n\t\tlicense_free(rdp->license);\n\t\tinput_free(rdp->input);\n\t\tupdate_free(rdp->update);\n\t\tfastpath_free(rdp->fastpath);\n\t\tnego_free(rdp->nego);\n\t\tmcs_free(rdp->mcs);\n\t\tredirection_free(rdp->redirection);\n\t\tmppc_dec_free(rdp->mppc_dec);\n\t\tmppc_enc_free(rdp->mppc_enc);\n\t\tfree(rdp);\n\t}\n}\n\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Security\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"security.h\"\n\n/* 0x36 repeated 40 times */\nstatic const BYTE pad1[40] =\n{\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n\t\"\\x36\\x36\\x36\\x36\\x36\\x36\\x36\\x36\"\n};\n\n/* 0x5C repeated 48 times */\nstatic const BYTE pad2[48] =\n{\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n\t\"\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\\x5C\"\n};\n\nstatic const BYTE\nfips_reverse_table[256] =\n{\n\t0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,\n\t0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\n\t0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,\n\t0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\n\t0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,\n\t0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\n\t0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n\t0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\n\t0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,\n\t0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\n\t0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,\n\t0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\n\t0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,\n\t0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n\t0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,\n\t0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\n\t0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,\n\t0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\n\t0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,\n\t0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\n\t0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n\t0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\n\t0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,\n\t0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\n\t0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,\n\t0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\n\t0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,\n\t0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n\t0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,\n\t0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\n\t0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,\n\t0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff\n};\n\nstatic const BYTE\nfips_oddparity_table[256] =\n{\n\t0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x07, 0x07,\n\t0x08, 0x08, 0x0b, 0x0b, 0x0d, 0x0d, 0x0e, 0x0e,\n\t0x10, 0x10, 0x13, 0x13, 0x15, 0x15, 0x16, 0x16,\n\t0x19, 0x19, 0x1a, 0x1a, 0x1c, 0x1c, 0x1f, 0x1f,\n\t0x20, 0x20, 0x23, 0x23, 0x25, 0x25, 0x26, 0x26,\n\t0x29, 0x29, 0x2a, 0x2a, 0x2c, 0x2c, 0x2f, 0x2f,\n\t0x31, 0x31, 0x32, 0x32, 0x34, 0x34, 0x37, 0x37,\n\t0x38, 0x38, 0x3b, 0x3b, 0x3d, 0x3d, 0x3e, 0x3e,\n\t0x40, 0x40, 0x43, 0x43, 0x45, 0x45, 0x46, 0x46,\n\t0x49, 0x49, 0x4a, 0x4a, 0x4c, 0x4c, 0x4f, 0x4f,\n\t0x51, 0x51, 0x52, 0x52, 0x54, 0x54, 0x57, 0x57,\n\t0x58, 0x58, 0x5b, 0x5b, 0x5d, 0x5d, 0x5e, 0x5e,\n\t0x61, 0x61, 0x62, 0x62, 0x64, 0x64, 0x67, 0x67,\n\t0x68, 0x68, 0x6b, 0x6b, 0x6d, 0x6d, 0x6e, 0x6e,\n\t0x70, 0x70, 0x73, 0x73, 0x75, 0x75, 0x76, 0x76,\n\t0x79, 0x79, 0x7a, 0x7a, 0x7c, 0x7c, 0x7f, 0x7f,\n\t0x80, 0x80, 0x83, 0x83, 0x85, 0x85, 0x86, 0x86,\n\t0x89, 0x89, 0x8a, 0x8a, 0x8c, 0x8c, 0x8f, 0x8f,\n\t0x91, 0x91, 0x92, 0x92, 0x94, 0x94, 0x97, 0x97,\n\t0x98, 0x98, 0x9b, 0x9b, 0x9d, 0x9d, 0x9e, 0x9e,\n\t0xa1, 0xa1, 0xa2, 0xa2, 0xa4, 0xa4, 0xa7, 0xa7,\n\t0xa8, 0xa8, 0xab, 0xab, 0xad, 0xad, 0xae, 0xae,\n\t0xb0, 0xb0, 0xb3, 0xb3, 0xb5, 0xb5, 0xb6, 0xb6,\n\t0xb9, 0xb9, 0xba, 0xba, 0xbc, 0xbc, 0xbf, 0xbf,\n\t0xc1, 0xc1, 0xc2, 0xc2, 0xc4, 0xc4, 0xc7, 0xc7,\n\t0xc8, 0xc8, 0xcb, 0xcb, 0xcd, 0xcd, 0xce, 0xce,\n\t0xd0, 0xd0, 0xd3, 0xd3, 0xd5, 0xd5, 0xd6, 0xd6,\n\t0xd9, 0xd9, 0xda, 0xda, 0xdc, 0xdc, 0xdf, 0xdf,\n\t0xe0, 0xe0, 0xe3, 0xe3, 0xe5, 0xe5, 0xe6, 0xe6,\n\t0xe9, 0xe9, 0xea, 0xea, 0xec, 0xec, 0xef, 0xef,\n\t0xf1, 0xf1, 0xf2, 0xf2, 0xf4, 0xf4, 0xf7, 0xf7,\n\t0xf8, 0xf8, 0xfb, 0xfb, 0xfd, 0xfd, 0xfe, 0xfe\n};\n\nstatic void security_salted_hash(const BYTE* salt, const BYTE* input, int length,\n\t\tconst BYTE* salt1, const BYTE* salt2, BYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\t/* SaltedHash(Salt, Input, Salt1, Salt2) = MD5(S + SHA1(Input + Salt + Salt1 + Salt2)) */\n\n\t/* SHA1_Digest = SHA1(Input + Salt + Salt1 + Salt2) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, input, length); /* Input */\n\tcrypto_sha1_update(sha1, salt, 48); /* Salt (48 bytes) */\n\tcrypto_sha1_update(sha1, salt1, 32); /* Salt1 (32 bytes) */\n\tcrypto_sha1_update(sha1, salt2, 32); /* Salt2 (32 bytes) */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* SaltedHash(Salt, Input, Salt1, Salt2) = MD5(S + SHA1_Digest) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, salt, 48); /* Salt (48 bytes) */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, output);\n}\n\nstatic void security_premaster_hash(const char* input, int length, const BYTE* premaster_secret, const BYTE* client_random, const BYTE* server_random, BYTE* output)\n{\n\t/* PremasterHash(Input) = SaltedHash(PremasterSecret, Input, ClientRandom, ServerRandom) */\n\tsecurity_salted_hash(premaster_secret, (BYTE*)input, length, client_random, server_random, output);\n}\n\nvoid security_master_secret(const BYTE* premaster_secret, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MasterSecret = PremasterHash('A') + PremasterHash('BB') + PremasterHash('CCC') */\n\tsecurity_premaster_hash(\"A\", 1, premaster_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"BB\", 2, premaster_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"CCC\", 3, premaster_secret, client_random, server_random, &output[32]);\n}\n\nstatic void security_master_hash(const char* input, int length, const BYTE* master_secret,\n\t\tconst BYTE* client_random, const BYTE* server_random, BYTE* output)\n{\n\t/* MasterHash(Input) = SaltedHash(MasterSecret, Input, ServerRandom, ClientRandom) */\n\tsecurity_salted_hash(master_secret, (const BYTE*)input, length, server_random, client_random, output);\n}\n\nvoid security_session_key_blob(const BYTE* master_secret, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MasterHash = MasterHash('A') + MasterHash('BB') + MasterHash('CCC') */\n\tsecurity_master_hash(\"A\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_master_hash(\"BB\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_master_hash(\"CCC\", 3, master_secret, client_random, server_random, &output[32]);\n}\n\nvoid security_mac_salt_key(const BYTE* session_key_blob, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MacSaltKey = First128Bits(SessionKeyBlob) */\n\tmemcpy(output, session_key_blob, 16);\n}\n\nvoid security_md5_16_32_32(const BYTE* in0, const BYTE* in1, const BYTE* in2, BYTE* output)\n{\n\tCryptoMd5 md5;\n\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, in0, 16);\n\tcrypto_md5_update(md5, in1, 32);\n\tcrypto_md5_update(md5, in2, 32);\n\tcrypto_md5_final(md5, output);\n}\n\nvoid security_licensing_encryption_key(const BYTE* session_key_blob, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* LicensingEncryptionKey = MD5(Second128Bits(SessionKeyBlob) + ClientRandom + ServerRandom)) */\n\tsecurity_md5_16_32_32(&session_key_blob[16], client_random, server_random, output);\n}\n\nvoid security_UINT32_le(BYTE* output, UINT32 value)\n{\n\toutput[0] = (value) & 0xFF;\n\toutput[1] = (value >> 8) & 0xFF;\n\toutput[2] = (value >> 16) & 0xFF;\n\toutput[3] = (value >> 24) & 0xFF;\n}\n\nvoid security_mac_data(const BYTE* mac_salt_key, const BYTE* data, UINT32 length,\n\t\tBYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE length_le[4];\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\t/* MacData = MD5(MacSaltKey + pad2 + SHA1(MacSaltKey + pad1 + length + data)) */\n\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\t/* SHA1_Digest = SHA1(MacSaltKey + pad1 + length + data) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, mac_salt_key, 16); /* MacSaltKey */\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1)); /* pad1 */\n\tcrypto_sha1_update(sha1, length_le, sizeof(length_le)); /* length */\n\tcrypto_sha1_update(sha1, data, length); /* data */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* MacData = MD5(MacSaltKey + pad2 + SHA1_Digest) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, mac_salt_key, 16); /* MacSaltKey */\n\tcrypto_md5_update(md5, pad2, sizeof(pad2)); /* pad2 */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, output);\n}\n\nvoid security_mac_signature(rdpRdp *rdp, const BYTE* data, UINT32 length, BYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE length_le[4];\n\tBYTE md5_digest[CRYPTO_MD5_DIGEST_LENGTH];\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\t/* SHA1_Digest = SHA1(MACKeyN + pad1 + length + data) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1)); /* pad1 */\n\tcrypto_sha1_update(sha1, length_le, sizeof(length_le)); /* length */\n\tcrypto_sha1_update(sha1, data, length); /* data */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* MACSignature = First64Bits(MD5(MACKeyN + pad2 + SHA1_Digest)) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_md5_update(md5, pad2, sizeof(pad2)); /* pad2 */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, md5_digest);\n\n\tmemcpy(output, md5_digest, 8);\n}\n\nvoid security_salted_mac_signature(rdpRdp *rdp, const BYTE* data, UINT32 length,\n\t\tBOOL encryption, BYTE* output)\n{\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tBYTE length_le[4];\n\tBYTE use_count_le[4];\n\tBYTE md5_digest[CRYPTO_MD5_DIGEST_LENGTH];\n\tBYTE sha1_digest[CRYPTO_SHA1_DIGEST_LENGTH];\n\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\tif (encryption)\n\t{\n\t\tsecurity_UINT32_le(use_count_le, rdp->encrypt_checksum_use_count);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We calculate checksum on plain text, so we must have already\n\t\t * decrypt it, which means decrypt_checksum_use_count is off by one.\n\t\t */\n\t\tsecurity_UINT32_le(use_count_le, rdp->decrypt_checksum_use_count - 1);\n\t}\n\n\t/* SHA1_Digest = SHA1(MACKeyN + pad1 + length + data) */\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1)); /* pad1 */\n\tcrypto_sha1_update(sha1, length_le, sizeof(length_le)); /* length */\n\tcrypto_sha1_update(sha1, data, length); /* data */\n\tcrypto_sha1_update(sha1, use_count_le, sizeof(use_count_le)); /* encryptionCount */\n\tcrypto_sha1_final(sha1, sha1_digest);\n\n\t/* MACSignature = First64Bits(MD5(MACKeyN + pad2 + SHA1_Digest)) */\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, rdp->sign_key, rdp->rc4_key_len); /* MacKeyN */\n\tcrypto_md5_update(md5, pad2, sizeof(pad2)); /* pad2 */\n\tcrypto_md5_update(md5, sha1_digest, sizeof(sha1_digest)); /* SHA1_Digest */\n\tcrypto_md5_final(md5, md5_digest);\n\n\tmemcpy(output, md5_digest, 8);\n}\n\nstatic void security_A(BYTE* master_secret, const BYTE* client_random, BYTE* server_random,\n\t\tBYTE* output)\n{\n\tsecurity_premaster_hash(\"A\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"BB\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"CCC\", 3, master_secret, client_random, server_random, &output[32]);\n}\n\nstatic void security_X(BYTE* master_secret, const BYTE* client_random, BYTE* server_random,\n\t\tBYTE* output)\n{\n\tsecurity_premaster_hash(\"X\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"YY\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"ZZZ\", 3, master_secret, client_random, server_random, &output[32]);\n}\n\nstatic void fips_expand_key_bits(BYTE* in, BYTE* out)\n{\n\tBYTE buf[21], c;\n\tint i, b, p, r;\n\n\t/* reverse every byte in the key */\n\tfor (i = 0; i < 21; i++)\n\t\tbuf[i] = fips_reverse_table[in[i]];\n\n\t/* insert a zero-bit after every 7th bit */\n\tfor (i = 0, b = 0; i < 24; i++, b += 7)\n\t{\n\t\tp = b / 8;\n\t\tr = b % 8;\n\t\tif (r == 0)\n\t\t{\n\t\t\tout[i] = buf[p] & 0xfe;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* c is accumulator */\n\t\t\tc = buf[p] << r;\n\t\t\tc |= buf[p + 1] >> (8 - r);\n\t\t\tout[i] = c & 0xfe;\n\t\t}\n\t}\n\n\t/* reverse every byte */\n\t/* alter lsb so the byte has odd parity */\n\tfor (i = 0; i < 24; i++)\n\t\tout[i] = fips_oddparity_table[fips_reverse_table[out[i]]];\n}\n\nBOOL security_establish_keys(const BYTE* client_random, rdpRdp* rdp)\n{\n\tBYTE pre_master_secret[48];\n\tBYTE master_secret[48];\n\tBYTE session_key_blob[48];\n\tBYTE* server_random;\n\tBYTE salt40[] = { 0xD1, 0x26, 0x9E };\n\trdpSettings* settings;\n\n\tsettings = rdp->settings;\n\tserver_random = settings->ServerRandom;\n\n\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tCryptoSha1 sha1;\n\t\tBYTE client_encrypt_key_t[CRYPTO_SHA1_DIGEST_LENGTH + 1];\n\t\tBYTE client_decrypt_key_t[CRYPTO_SHA1_DIGEST_LENGTH + 1];\n\n\t\tprintf(\"FIPS Compliant encryption level.\\n\");\n\n\t\t/* disable fastpath input; it doesnt handle FIPS encryption yet */\n\t\trdp->settings->FastPathInput = FALSE;\n\n\t\tsha1 = crypto_sha1_init();\n\t\tcrypto_sha1_update(sha1, client_random + 16, 16);\n\t\tcrypto_sha1_update(sha1, server_random + 16, 16);\n\t\tcrypto_sha1_final(sha1, client_encrypt_key_t);\n\n\t\tclient_encrypt_key_t[20] = client_encrypt_key_t[0];\n\t\tfips_expand_key_bits(client_encrypt_key_t, rdp->fips_encrypt_key);\n\n\t\tsha1 = crypto_sha1_init();\n\t\tcrypto_sha1_update(sha1, client_random, 16);\n\t\tcrypto_sha1_update(sha1, server_random, 16);\n\t\tcrypto_sha1_final(sha1, client_decrypt_key_t);\n\n\t\tclient_decrypt_key_t[20] = client_decrypt_key_t[0];\n\t\tfips_expand_key_bits(client_decrypt_key_t, rdp->fips_decrypt_key);\n\n\t\tsha1 = crypto_sha1_init();\n\t\tcrypto_sha1_update(sha1, client_decrypt_key_t, 20);\n\t\tcrypto_sha1_update(sha1, client_encrypt_key_t, 20);\n\t\tcrypto_sha1_final(sha1, rdp->fips_sign_key);\n\t}\n\n\tmemcpy(pre_master_secret, client_random, 24);\n\tmemcpy(pre_master_secret + 24, server_random, 24);\n\n\tsecurity_A(pre_master_secret, client_random, server_random, master_secret);\n\tsecurity_X(master_secret, client_random, server_random, session_key_blob);\n\n\tmemcpy(rdp->sign_key, session_key_blob, 16);\n\n\tif (rdp->settings->ServerMode)\n\t{\n\t\tsecurity_md5_16_32_32(&session_key_blob[16], client_random,\n\t\t    server_random, rdp->encrypt_key);\n\t\tsecurity_md5_16_32_32(&session_key_blob[32], client_random,\n\t\t    server_random, rdp->decrypt_key);\n\t}\n\telse\n\t{\n\t\tsecurity_md5_16_32_32(&session_key_blob[16], client_random,\n\t\t    server_random, rdp->decrypt_key);\n\t\tsecurity_md5_16_32_32(&session_key_blob[32], client_random,\n\t\t    server_random, rdp->encrypt_key);\n\t}\n\n\tif (settings->EncryptionMethods == 1) /* 40 and 56 bit */\n\t{\n\t\tmemcpy(rdp->sign_key, salt40, 3); /* TODO 56 bit */\n\t\tmemcpy(rdp->decrypt_key, salt40, 3); /* TODO 56 bit */\n\t\tmemcpy(rdp->encrypt_key, salt40, 3); /* TODO 56 bit */\n\t\trdp->rc4_key_len = 8;\n\t}\n\telse if (settings->EncryptionMethods == 2) /* 128 bit */\n\t{\n\t\trdp->rc4_key_len = 16;\n\t}\n\n\tmemcpy(rdp->decrypt_update_key, rdp->decrypt_key, 16);\n\tmemcpy(rdp->encrypt_update_key, rdp->encrypt_key, 16);\n\trdp->decrypt_use_count = 0;\n\trdp->decrypt_checksum_use_count = 0;\n\trdp->encrypt_use_count =0;\n\trdp->encrypt_checksum_use_count =0;\n\n\treturn TRUE;\n}\n\nBOOL security_key_update(BYTE* key, BYTE* update_key, int key_len)\n{\n\tBYTE sha1h[CRYPTO_SHA1_DIGEST_LENGTH];\n\tCryptoMd5 md5;\n\tCryptoSha1 sha1;\n\tCryptoRc4 rc4;\n\tBYTE salt40[] = { 0xD1, 0x26, 0x9E };\n\n\tsha1 = crypto_sha1_init();\n\tcrypto_sha1_update(sha1, update_key, key_len);\n\tcrypto_sha1_update(sha1, pad1, sizeof(pad1));\n\tcrypto_sha1_update(sha1, key, key_len);\n\tcrypto_sha1_final(sha1, sha1h);\n\n\tmd5 = crypto_md5_init();\n\tcrypto_md5_update(md5, update_key, key_len);\n\tcrypto_md5_update(md5, pad2, sizeof(pad2));\n\tcrypto_md5_update(md5, sha1h, sizeof(sha1h));\n\tcrypto_md5_final(md5, key);\n\n\trc4 = crypto_rc4_init(key, key_len);\n\tcrypto_rc4(rc4, key_len, key, key);\n\tcrypto_rc4_free(rc4);\n\n\tif (key_len == 8)\n\t\tmemcpy(key, salt40, 3); /* TODO 56 bit */\n\n\treturn TRUE;\n}\n\nBOOL security_encrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->encrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->encrypt_key, rdp->encrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_encrypt_key);\n\t\trdp->rc4_encrypt_key = crypto_rc4_init(rdp->encrypt_key, rdp->rc4_key_len);\n\t\trdp->encrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_encrypt_key, length, data, data);\n\trdp->encrypt_use_count++;\n\trdp->encrypt_checksum_use_count++;\n\treturn TRUE;\n}\n\nBOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}\n\nvoid security_hmac_signature(const BYTE* data, int length, BYTE* output, rdpRdp* rdp)\n{\n\tBYTE buf[20];\n\tBYTE use_count_le[4];\n\n\tsecurity_UINT32_le(use_count_le, rdp->encrypt_use_count);\n\n\tcrypto_hmac_sha1_init(rdp->fips_hmac, rdp->fips_sign_key, 20);\n\tcrypto_hmac_update(rdp->fips_hmac, data, length);\n\tcrypto_hmac_update(rdp->fips_hmac, use_count_le, 4);\n\tcrypto_hmac_final(rdp->fips_hmac, buf, 20);\n\n\tmemmove(output, buf, 8);\n}\n\nBOOL security_fips_encrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tcrypto_des3_encrypt(rdp->fips_encrypt, length, data, data);\n\trdp->encrypt_use_count++;\n\treturn TRUE;\n}\n\nBOOL security_fips_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tcrypto_des3_decrypt(rdp->fips_decrypt, length, data, data);\n\treturn TRUE;\n}\n\nBOOL security_fips_check_signature(const BYTE* data, int length, const BYTE* sig, rdpRdp* rdp)\n{\n\tBYTE buf[20];\n\tBYTE use_count_le[4];\n\n\tsecurity_UINT32_le(use_count_le, rdp->decrypt_use_count);\n\n\tcrypto_hmac_sha1_init(rdp->fips_hmac, rdp->fips_sign_key, 20);\n\tcrypto_hmac_update(rdp->fips_hmac, data, length);\n\tcrypto_hmac_update(rdp->fips_hmac, use_count_le, 4);\n\tcrypto_hmac_final(rdp->fips_hmac, buf, 20);\n\n\trdp->decrypt_use_count++;\n\n\tif (memcmp(sig, buf, 8))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n"], "filenames": ["libfreerdp/core/rdp.c", "libfreerdp/core/security.c"], "buggy_code_start_loc": [720, 494], "buggy_code_end_loc": [721, 494], "fixing_code_start_loc": [720, 495], "fixing_code_end_loc": [722, 497], "type": "CWE-476", "message": "FreeRDP before 1.1.0-beta1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors.", "other": {"cve": {"id": "CVE-2013-4118", "sourceIdentifier": "secalert@redhat.com", "published": "2016-10-03T21:59:00.317", "lastModified": "2020-03-06T17:18:46.660", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP before 1.1.0-beta1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a 1.1.0-beta1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de vectores no especificados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.2", "matchCriteriaId": "F437CAE0-7C2D-441D-8122-6E621F5D1DA4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-09/msg00101.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-09/msg00102.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/11/12", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/12/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/61072", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7"}}