{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar _ = require('lodash')\nvar moment = require('moment-timezone')\nvar winston = require('winston')\nvar permissions = require('../../../permissions')\nvar emitter = require('../../../emitter')\nvar xss = require('xss')\nvar sanitizeHtml = require('sanitize-html')\n\nvar apiTickets = {}\n\nfunction buildGraphData (arr, days, callback) {\n  var graphData = []\n  var today = moment()\n    .hour(23)\n    .minute(59)\n    .second(59)\n  var timespanArray = []\n  for (var i = days; i--; ) {\n    timespanArray.push(i)\n  }\n\n  _.each(timespanArray, function (day) {\n    var obj = {}\n    var d = today.clone().subtract(day, 'd')\n    obj.date = d.format('YYYY-MM-DD')\n\n    var $dateCount = _.filter(arr, function (v) {\n      return (\n        v.date <= d.toDate() &&\n        v.date >=\n          d\n            .clone()\n            .subtract(1, 'd')\n            .toDate()\n      )\n    })\n\n    $dateCount = _.size($dateCount)\n    obj.value = $dateCount\n    graphData.push(obj)\n  })\n\n  if (_.isFunction(callback)) {\n    return callback(graphData)\n  }\n\n  return graphData\n}\n\nfunction buildAvgResponse (ticketArray, callback) {\n  var cbObj = {}\n  var $ticketAvg = []\n  _.each(ticketArray, function (ticket) {\n    if (_.isUndefined(ticket.comments) || _.size(ticket.comments) < 1) return\n\n    var ticketDate = moment(ticket.date)\n    var firstCommentDate = moment(ticket.comments[0].date)\n\n    var diff = firstCommentDate.diff(ticketDate, 'seconds')\n    $ticketAvg.push(diff)\n  })\n\n  var ticketAvgTotal = _($ticketAvg).reduce(function (m, x) {\n    return m + x\n  }, 0)\n\n  var tvt = moment.duration(Math.round(ticketAvgTotal / _.size($ticketAvg)), 'seconds').asHours()\n  cbObj.avgResponse = Math.floor(tvt)\n\n  if (_.isFunction(callback)) {\n    return callback(cbObj)\n  }\n\n  return cbObj\n}\n\n/**\n * @api {get} /api/v1/tickets/ Get Tickets\n * @apiName getTickets\n * @apiDescription Gets tickets for the given User\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets\n *\n * @apiSuccess {object}     _id                 The MongoDB ID\n * @apiSuccess {number}     uid                 Unique ID (seq num)\n * @apiSuccess {object}     owner               User\n * @apiSuccess {object}     owner._id           The MongoDB ID of Owner\n * @apiSuccess {string}     owner.username      Username\n * @apiSuccess {string}     owner.fullname      User Full Name\n * @apiSuccess {string}     owner.email         User Email Address\n * @apiSuccess {string}     owner.role          User Permission Role\n * @apiSuccess {string}     owner.title         User Title\n * @apiSuccess {string}     owner.image         User Image Rel Path\n * @apiSuccess {object}     group               Group\n * @apiSuccess {object}     group._id           Group MongoDB ID\n * @apiSuccess {string}     group.name          Group Name\n * @apiSuccess {object}     assignee            User Assigned\n * @apiSuccess {object}     assignee._id        The MongoDB ID of Owner\n * @apiSuccess {string}     assignee.username   Username\n * @apiSuccess {string}     assignee.fullname   User Full Name\n * @apiSuccess {string}     assignee.email      User Email Address\n * @apiSuccess {string}     assignee.role       User Permission Role\n * @apiSuccess {string}     assignee.title      User Title\n * @apiSuccess {string}     assignee.image      User Image Rel Path\n * @apiSuccess {date}       date                Created Date\n * @apiSuccess {date}       updated             Last Updated DateTime\n * @apiSuccess {boolean}    deleted             Deleted Flag\n * @apiSuccess {object}     type                Ticket Type\n * @apiSuccess {object}     type._id            Type MongoDB ID\n * @apiSuccess {string}     type.name           Type Name\n * @apiSuccess {number}     status              Status of Ticket\n * @apiSuccess {number}     prioirty            Prioirty of Ticket\n * @apiSuccess {array}      tags                Array of Tags\n * @apiSuccess {string}     subject             Subject Text\n * @apiSuccess {string}     issue               Issue Text\n * @apiSuccess {date}       closedDate          Date Ticket was closed\n * @apiSuccess {array}      comments            Array of Comments\n * @apiSuccess {array}      attachments         Array of Attachments\n * @apiSuccess {array}      history             Array of History items\n *\n */\napiTickets.get = function (req, res) {\n  var l = req.query.limit ? req.query.limit : 10\n  var limit = parseInt(l)\n  var page = parseInt(req.query.page)\n  var assignedSelf = req.query.assignedself\n  var status = req.query.status\n  var user = req.user\n\n  var object = {\n    user: user,\n    limit: limit,\n    page: page,\n    assignedSelf: assignedSelf,\n    status: status\n  }\n\n  var ticketModel = require('../../../models/ticket')\n  var groupModel = require('../../../models/group')\n  var departmentModel = require('../../../models/department')\n\n  async.waterfall(\n    [\n      function (callback) {\n        if (user.role.isAdmin || user.role.isAgent) {\n          departmentModel.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n            callback(err, groups)\n          })\n        } else {\n          groupModel.getAllGroupsOfUserNoPopulate(user._id, function (err, grps) {\n            callback(err, grps)\n          })\n        }\n      },\n      function (grps, callback) {\n        if (permissions.canThis(user.role, 'tickets:public')) {\n          groupModel.getAllPublicGroups(function (err, publicGroups) {\n            if (err) return callback(err)\n\n            grps = grps.concat(publicGroups)\n\n            return callback(null, grps)\n          })\n        } else {\n          return callback(null, grps)\n        }\n      },\n      function (grps, callback) {\n        ticketModel.getTicketsWithObject(grps, object, function (err, results) {\n          if (!permissions.canThis(user.role, 'comments:view')) {\n            _.each(results, function (ticket) {\n              ticket.comments = []\n            })\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            _.each(results, function (ticket) {\n              ticket.notes = []\n            })\n          }\n\n          // sanitize\n          _.each(results, function (ticket) {\n            ticket.subscribers = _.map(ticket.subscribers, function (s) {\n              return s._id\n            })\n\n            ticket.history = _.map(ticket.history, function (h) {\n              var obj = {\n                date: h.date,\n                _id: h._id,\n                action: h.action,\n                description: h.description,\n                owner: _.clone(h.owner)\n              }\n              obj.owner.role = h.owner.role._id\n              return obj\n            })\n\n            ticket.owner.role = ticket.owner.role._id\n          })\n\n          return callback(err, results)\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.send('Error: ' + err.message)\n\n      return res.json(results)\n    }\n  )\n}\n\napiTickets.getByGroup = function (req, res) {\n  var groupId = req.params.id\n  if (!groupId) return res.status(400).json({ success: false, error: 'Invalid Group Id' })\n\n  var limit = req.query.limit ? Number(req.query.limit) : 50\n  var page = req.query.page ? Number(req.query.page) : 0\n\n  var obj = {\n    limit: limit,\n    page: page\n  }\n\n  var ticketSchema = require('../../../models/ticket')\n  ticketSchema.getTicketsWithObject([groupId], obj, function (err, tickets) {\n    if (err) return res.status(500).json({ success: false, error: err.message })\n\n    return res.json({ success: true, tickets: tickets, count: tickets.length })\n  })\n}\n\napiTickets.getCountByGroup = function (req, res) {\n  var groupId = req.params.id\n  if (!groupId) return res.status(400).json({ success: false, error: 'Invalid Group Id' })\n  if (_.isUndefined(req.query.type) || _.isUndefined(req.query.value))\n    return res.status(400).json({ success: false, error: 'Invalid QueryString' })\n\n  var type = req.query.type\n  var value = req.query.value\n  // var limit = req.query.limit ? Number(req.query.limit) : -1\n  // var page = req.query.page ? Number(req.query.page) : 0\n\n  var ticketSchema = require('../../../models/ticket')\n\n  var obj = {\n    // limit: limit,\n    // page: page\n  }\n\n  switch (type.toLowerCase()) {\n    case 'status':\n      obj.status = [Number(value)]\n      ticketSchema.getCountWithObject([groupId], obj, function (err, count) {\n        if (err) return res.status(500).json({ success: false, error: err.message })\n\n        return res.json({ success: true, count: count })\n      })\n      break\n    case 'tickettype':\n      obj.filter = {\n        types: [value]\n      }\n      ticketSchema.getCountWithObject([groupId], obj, function (err, count) {\n        if (err) return res.status(500).json({ success: false, error: err.message })\n\n        return res.json({ success: true, count: count })\n      })\n      break\n    default:\n      return res.status(400).json({ success: false, error: 'Unsupported type query' })\n  }\n}\n\n/**\n * @api {get} /api/v1/tickets/search/?search={searchString} Get Tickets by Search String\n * @apiName search\n * @apiDescription Gets tickets via search string\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/search/?search=searchString\n *\n * @apiSuccess {number} count Count of Tickets Array\n * @apiSuccess {array} tickets Tickets Array\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Ticket\"\n }\n */\napiTickets.search = function (req, res) {\n  var searchString = req.query.search\n\n  var ticketModel = require('../../../models/ticket')\n  var groupModel = require('../../../models/group')\n  var departmentModel = require('../../../models/department')\n\n  async.waterfall(\n    [\n      function (callback) {\n        if (req.user.role.isAdmin || req.user.role.isAgent) {\n          return departmentModel.getDepartmentGroupsOfUser(req.user._id, callback)\n        } else {\n          return groupModel.getAllGroupsOfUserNoPopulate(req.user._id, callback)\n        }\n      },\n      function (grps, callback) {\n        if (permissions.canThis(req.user.role, 'tickets:public')) {\n          groupModel.getAllPublicGroups(function (err, publicGroups) {\n            if (err) return callback(err)\n\n            grps = grps.concat(publicGroups)\n\n            return callback(null, grps)\n          })\n        } else {\n          return callback(null, grps)\n        }\n      },\n      function (grps, callback) {\n        ticketModel.getTicketsWithSearchString(grps, searchString, function (err, results) {\n          if (!permissions.canThis(req.user.role.role, 'tickets:notes')) {\n            _.each(results, function (ticket) {\n              ticket.notes = []\n            })\n          }\n\n          return callback(err, results)\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.status(400).json({ success: false, error: 'Error - ' + err.message })\n\n      return res.json({\n        success: true,\n        error: null,\n        count: _.size(results),\n        totalCount: _.size(results),\n        tickets: _.sortBy(results, 'uid').reverse()\n      })\n    }\n  )\n}\n\n/**\n * @api {post} /api/v1/tickets/create Create Ticket\n * @apiName createTicket\n * @apiDescription Creates a ticket with the given post data.\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"subject\": \"Subject\",\n *      \"issue\": \"Issue Exmaple\",\n *      \"owner\": {OwnerId},\n *      \"group\": {GroupId},\n *      \"type\": {TypeId},\n *      \"prioirty\": {PriorityId},\n *      \"tags\": [{tagId}]\n * }\n *\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"subject\\\":\\\"{subject}\\\",\\\"owner\\\":{ownerId}, group: \\\"{groupId}\\\", type: \\\"{typeId}\\\", issue: \\\"{issue}\\\", prioirty: \\\"{prioirty}\\\"}\"\n *      -l http://localhost/api/v1/tickets/create\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Saved Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n        {\n            \"error\": \"Invalid Post Data\"\n        }\n */\n\napiTickets.create = function (req, res) {\n  var response = {}\n  response.success = true\n\n  var postData = req.body\n  if (!_.isObject(postData) || !postData.subject || !postData.issue)\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  var socketId = _.isUndefined(postData.socketId) ? '' : postData.socketId\n\n  if (_.isUndefined(postData.tags) || _.isNull(postData.tags)) {\n    postData.tags = []\n  } else if (!_.isArray(postData.tags)) {\n    postData.tags = [postData.tags]\n  }\n\n  async.waterfall(\n    [\n      function (done) {\n        var UserSchema = require('../../../models/user')\n        UserSchema.findOne({ _id: req.user._id }, done)\n      },\n      function (user, done) {\n        if (user.deleted) return done({ status: 400, error: 'Invalid User' })\n\n        var HistoryItem = {\n          action: 'ticket:created',\n          description: 'Ticket was created.',\n          owner: req.user._id\n        }\n\n        var TicketSchema = require('../../../models/ticket')\n        var ticket = new TicketSchema(postData)\n        if (!_.isUndefined(postData.owner)) {\n          ticket.owner = postData.owner\n        } else {\n          ticket.owner = req.user._id\n        }\n\n        ticket.subject = sanitizeHtml(ticket.subject).trim()\n\n        var marked = require('marked')\n        var tIssue = ticket.issue\n        tIssue = tIssue.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, '<br>')\n        tIssue = sanitizeHtml(tIssue).trim()\n        ticket.issue = xss(marked.parse(tIssue))\n        ticket.history = [HistoryItem]\n        ticket.subscribers = [user._id]\n\n        ticket.save(function (err, t) {\n          if (err) return done({ status: 400, error: err })\n\n          t.populate('group owner priority', function (err, tt) {\n            if (err) return done({ status: 400, error: err })\n\n            emitter.emit('ticket:created', {\n              hostname: req.headers.host,\n              socketId: socketId,\n              ticket: tt\n            })\n\n            response.ticket = tt\n            res.json(response)\n          })\n        })\n      }\n    ],\n    function (err) {\n      if (err) {\n        response.success = false\n        response.error = err.error\n        return res.status(err.status).json(response)\n      }\n\n      response.success = true\n\n      return res.json(response)\n    }\n  )\n}\n\n/**\n * @api {post} /api/v1/public/tickets/create Create Public Ticket\n * @apiName createPublicTicket\n * @apiDescription Creates a ticket with the given post data via public ticket submission. [Limited to Server Origin]\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"fullname\": \"Full Name\",\n *      \"email\": \"email@email.com\",\n *      \"subject\": \"Subject\",\n *      \"issue\": \"Issue Exmaple\"\n * }\n *\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -d \"{\\\"fullname\\\":\\\"{fullname}\\\",\\\"email\\\":{email}, \\\"subject\\\": \\\"{subject}\\\", \\\"issue\\\": \\\"{issue}\\\"}\"\n *      -l http://localhost/api/v1/public/tickets/create\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Saved Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.createPublicTicket = function (req, res) {\n  var Chance = require('chance')\n\n  var chance = new Chance()\n  var response = {}\n  response.success = true\n  var postData = req.body\n  if (!_.isObject(postData)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  var user, group, ticket, plainTextPass\n\n  var settingSchema = require('../../../models/setting')\n\n  async.waterfall(\n    [\n      function (next) {\n        settingSchema.getSetting('allowPublicTickets:enable', function (err, allowPublicTickets) {\n          if (err) return next(err)\n          if (!allowPublicTickets) {\n            winston.warn('Public ticket creation attempted while disabled!')\n            return next('Public ticket creation is disabled!')\n          }\n\n          return next()\n        })\n      },\n      function (next) {\n        settingSchema.getSetting('role:user:default', function (err, roleDefault) {\n          if (err) return next(err)\n          if (!roleDefault) {\n            winston.error('No Default User Role Set. (Settings > Permissions > Default User Role)')\n            return next('No Default Role Set')\n          }\n\n          return next(null, roleDefault)\n        })\n      },\n      function (roleDefault, next) {\n        var UserSchema = require('../../../models/user')\n        plainTextPass = chance.string({\n          length: 6,\n          pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n        })\n\n        var sanitizedFullname = xss(postData.user.fullname)\n\n        user = new UserSchema({\n          username: postData.user.email,\n          password: plainTextPass,\n          fullname: sanitizedFullname,\n          email: postData.user.email,\n          accessToken: chance.hash(),\n          role: roleDefault.value\n        })\n\n        user.save(function (err, savedUser) {\n          if (err) return next(err)\n\n          return next(null, savedUser)\n        })\n      },\n\n      function (savedUser, next) {\n        // Group Creation\n        var GroupSchema = require('../../../models/group')\n        group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, group) {\n          if (err) return next(err)\n\n          return next(null, group, savedUser)\n        })\n      },\n\n      function (group, savedUser, next) {\n        var settingsSchema = require('../../../models/setting')\n        settingsSchema.getSettingByName('ticket:type:default', function (err, defaultType) {\n          if (err) return next(err)\n\n          if (defaultType.value) {\n            return next(null, defaultType.value, group, savedUser)\n          }\n\n          return next('Failed: Invalid Default Ticket Type.')\n        })\n      },\n\n      function (defaultTicketType, group, savedUser, next) {\n        // Create Ticket\n        var ticketTypeSchema = require('../../../models/tickettype')\n        ticketTypeSchema.getType(defaultTicketType, function (err, ticketType) {\n          if (err) return next(err)\n\n          var TicketSchema = require('../../../models/ticket')\n          var HistoryItem = {\n            action: 'ticket:created',\n            description: 'Ticket was created.',\n            owner: savedUser._id\n          }\n          ticket = new TicketSchema({\n            owner: savedUser._id,\n            group: group._id,\n            type: ticketType._id,\n            priority: _.first(ticketType.priorities)._id, // TODO: change when priority order is complete!\n            subject: xss(sanitizeHtml(postData.ticket.subject).trim()),\n            issue: xss(sanitizeHtml(postData.ticket.issue).trim()),\n            history: [HistoryItem],\n            subscribers: [savedUser._id]\n          })\n\n          var marked = require('marked')\n          var tIssue = ticket.issue\n          tIssue = tIssue.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, '<br>')\n          tIssue = sanitizeHtml(tIssue).trim()\n          ticket.issue = marked.parse(tIssue)\n          ticket.issue = xss(ticket.issue)\n\n          ticket.save(function (err, t) {\n            if (err) return next(err)\n\n            emitter.emit('ticket:created', {\n              hostname: req.headers.host,\n              socketId: '',\n              ticket: t\n            })\n\n            return next(null, { user: savedUser, group: group, ticket: t })\n          })\n        })\n      }\n    ],\n    function (err, result) {\n      if (err) winston.debug(err)\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      delete result.user.password\n      result.user.password = undefined\n\n      return res.json({\n        success: true,\n        userData: { savedUser: result.user, chancepass: plainTextPass },\n        ticket: result.ticket\n      })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/:uid Get Single Ticket\n * @apiName singleTicket\n * @apiDescription Gets a ticket with the given UID.\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/1000\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Ticket\"\n }\n */\napiTickets.single = function (req, res) {\n  var uid = req.params.uid\n  if (_.isUndefined(uid)) return res.status(200).json({ success: false, error: 'Invalid Ticket' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketByUid(uid, function (err, ticket) {\n    if (err) return res.send(err)\n\n    if (_.isUndefined(ticket) || _.isNull(ticket)) {\n      return res.status(200).json({ success: false, error: 'Invalid Ticket' })\n    }\n\n    ticket = _.clone(ticket._doc)\n    if (!permissions.canThis(req.user.role, 'tickets:notes')) {\n      delete ticket.notes\n    }\n\n    return res.json({ success: true, ticket: ticket })\n  })\n}\n\n/**\n * @api {put} /api/v1/tickets/:id Update Ticket\n * @apiName updateTicket\n * @apiDescription Updates ticket via given OID\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -X PUT -d \"{\\\"status\\\": {status},\\\"group\\\": \\\"{group}\\\"}\"\n *      -l http://localhost/api/v1/tickets/{id}\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Updated Ticket Object\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.update = function (req, res) {\n  var user = req.user\n  if (!_.isUndefined(user) && !_.isNull(user)) {\n    var permissions = require('../../../permissions')\n    if (!permissions.canThis(user.role, 'tickets:update')) {\n      return res.status(401).json({ success: false, error: 'Invalid Permissions' })\n    }\n    var oId = req.params.id\n    var reqTicket = req.body\n    if (_.isUndefined(oId)) return res.status(400).json({ success: false, error: 'Invalid Ticket ObjectID.' })\n    var ticketModel = require('../../../models/ticket')\n    ticketModel.getTicketById(oId, function (err, ticket) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n      if (!ticket) return res.status(400).json({ success: false, error: 'Unable to locate ticket. Aborting...' })\n      async.parallel(\n        [\n          function (cb) {\n            if (!_.isUndefined(reqTicket.status)) {\n              ticket.status = reqTicket.status\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.subject)) {\n              ticket.subject = sanitizeHtml(reqTicket.subject).trim()\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.group)) {\n              ticket.group = reqTicket.group._id || reqTicket.group\n\n              ticket.populate('group', function () {\n                return cb()\n              })\n            } else {\n              return cb()\n            }\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.closedDate)) {\n              ticket.closedDate = reqTicket.closedDate\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.tags) && !_.isNull(reqTicket.tags)) {\n              ticket.tags = reqTicket.tags\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.issue) && !_.isNull(reqTicket.issue)) {\n              ticket.issue = sanitizeHtml(reqTicket.issue).trim()\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.assignee) && !_.isNull(reqTicket.assignee)) {\n              ticket.assignee = reqTicket.assignee\n              ticket.populate('assignee', function (err, t) {\n                if (err) return cb(err)\n\n                var HistoryItem = {\n                  action: 'ticket:set:assignee',\n                  description: t.assignee.fullname + ' was set as assignee',\n                  owner: req.user._id\n                }\n\n                ticket.history.push(HistoryItem)\n\n                return cb()\n              })\n            } else {\n              return cb()\n            }\n          }\n        ],\n        function () {\n          ticket.save(function (err, t) {\n            if (err) {\n              return res.status(400).json({ success: false, error: err.message })\n            }\n\n            if (!permissions.canThis(user.role, 'tickets:notes')) {\n              t.notes = []\n            }\n\n            return res.json({\n              success: true,\n              error: null,\n              ticket: t\n            })\n          })\n        }\n      )\n    })\n  } else {\n    return res.status(403).json({ success: false, error: 'Invalid Access Token' })\n  }\n}\n\n/**\n * @api {delete} /api/v1/tickets/:id Delete Ticket\n * @apiName deleteTicket\n * @apiDescription Deletes ticket via given OID\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/{id}\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.delete = function (req, res) {\n  var oId = req.params.id\n  var user = req.user\n\n  if (_.isUndefined(oId) || _.isUndefined(user))\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.softDelete(oId, function (err) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    emitter.emit('ticket:deleted', oId)\n    res.json({ success: true, error: null })\n  })\n}\n\n/**\n * @api {post} /api/v1/tickets/addcomment Add Comment\n * @apiName addComment\n * @apiDescription Adds comment to the given Ticket Id\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"comment\\\":\\\"{comment}\\\",\\\"owner\\\":{ownerId}, ticketId: \\\"{ticketId}\\\"}\"\n *      -l http://localhost/api/v1/tickets/addcomment\n *\n * @apiParamExample {json} Request:\n * {\n *      \"comment\": \"Comment Text\",\n *      \"owner\": {OwnerId},\n *      \"ticketid\": {TicketId}\n * }\n *\n * @apiSuccess {boolean} success Successful\n * @apiSuccess {string} error Error if occurrred\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.postComment = function (req, res) {\n  var commentJson = req.body\n  var comment = commentJson.comment\n  var owner = commentJson.ownerId || req.user._id\n  var ticketId = commentJson._id\n\n  if (_.isUndefined(ticketId)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(ticketId, function (err, t) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    if (_.isUndefined(comment)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    var marked = require('marked')\n    marked.setOptions({\n      breaks: true\n    })\n\n    comment = sanitizeHtml(comment).trim()\n\n    var Comment = {\n      owner: owner,\n      date: new Date(),\n      comment: xss(marked.parse(comment))\n    }\n\n    t.updated = Date.now()\n    t.comments.push(Comment)\n    var HistoryItem = {\n      action: 'ticket:comment:added',\n      description: 'Comment was added',\n      owner: owner\n    }\n    t.history.push(HistoryItem)\n\n    t.save(function (err, tt) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      if (!permissions.canThis(req.user.role, 'tickets:notes')) {\n        tt.notes = []\n      }\n\n      emitter.emit('ticket:comment:added', tt, Comment, req.headers.host)\n\n      return res.json({ success: true, error: null, ticket: tt })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/tickets/addnote Add Note\n * @apiName addInternalNote\n * @apiDescription Adds a note to the given Ticket Id\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"note\\\":\\\"{note}\\\",\\\"owner\\\":{ownerId}, ticketId: \\\"{ticketId}\\\"}\"\n *      -l http://localhost/api/v1/tickets/addnote\n *\n * @apiParamExample {json} Request:\n * {\n *      \"note\": \"Note Text\",\n *      \"owner\": {OwnerId},\n *      \"ticketid\": {TicketId}\n * }\n *\n * @apiSuccess {boolean} success Successful\n * @apiSuccess {string} error Error if occurrred\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.postInternalNote = function (req, res) {\n  var payload = req.body\n  if (_.isUndefined(payload.ticketid)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(payload.ticketid, function (err, ticket) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (_.isUndefined(payload.note)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    var marked = require('marked')\n    // var note = payload.note.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, \"<br>\");\n    var Note = {\n      owner: payload.owner || req.user._id,\n      date: new Date(),\n      note: xss(marked.parse(payload.note))\n    }\n\n    ticket.updated = Date.now()\n    ticket.notes.push(Note)\n    var HistoryItem = {\n      action: 'ticket:note:added',\n      description: 'Internal note was added',\n      owner: payload.owner || req.user._id\n    }\n    ticket.history.push(HistoryItem)\n\n    ticket.save(function (err, savedTicket) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      ticketModel.populate(savedTicket, 'subscribers notes.owner history.owner', function (err, savedTicket) {\n        if (err) return res.json({ success: true, ticket: savedTicket })\n\n        emitter.emit('ticket:note:added', savedTicket, Note)\n\n        return res.json({ success: true, ticket: savedTicket })\n      })\n    })\n  })\n}\n\n/**\n * @api {get} /api/v1/tickets/types Get Ticket Types\n * @apiName getTicketTypes\n * @apiDescription Gets all available ticket types.\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/types\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTypes = function (req, res) {\n  var ticketType = require('../../../models/tickettype')\n  ticketType.getTypes(function (err, types) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    return res.json(types)\n  })\n}\n\napiTickets.getType = function (req, res) {\n  var id = req.params.id\n  if (!id) return res.status(400).json({ success: false, error: 'Invalid Type ID' })\n\n  var ticketType = require('../../../models/tickettype')\n  ticketType.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Type ID' })\n\n    return res.json({ success: true, type: type })\n  })\n}\n\n/**\n * @api {post} /api/v1/tickets/types/create Create Ticket Type\n * @apiName createType\n * @apiDescription Creates a new ticket type\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"name\\\": \\\"TypeName\\\"}\"\n *      -l http://localhost/api/v1/tickets/types/create\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {Object} tickettype Returns the newly create ticket type\n *\n */\napiTickets.createType = function (req, res) {\n  var typeName = req.body.name\n  var ticketTypeSchema = require('../../../models/tickettype')\n  var ticketPrioritiesSchema = require('../../../models/ticketpriority')\n\n  if (_.isUndefined(typeName) || typeName.length < 3)\n    return res.status(400).json({ success: false, error: 'Invalid Type Name!' })\n\n  ticketPrioritiesSchema.find({ default: true }, function (err, priorities) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n    priorities = _.sortBy(priorities, 'migrationNum')\n\n    ticketTypeSchema.create({ name: typeName, priorities: priorities }, function (err, ticketType) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, tickettype: ticketType })\n    })\n  })\n}\n\n/**\n * @api {put} /api/v1/tickets/types/:id Update Ticket Type\n * @apiName updateType\n * @apiDescription Updates given ticket type\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X PUT -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/types/:id\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {object} tag Updated Ticket Type\n *\n */\napiTickets.updateType = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n\n  if (_.isUndefined(id) || _.isNull(id) || _.isNull(data) || _.isUndefined(data)) {\n    return res.status(400).json({ success: false, error: 'Invalid Put Data' })\n  }\n\n  ticketTypeSchema.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    type.name = data.name\n\n    type.save(function (err, t) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, type: t })\n    })\n  })\n}\n\napiTickets.typeAddPriority = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n\n  if (!id || !data || !data.priority) {\n    return res.status(400).json({ success: false, error: 'Invalid request data' })\n  }\n\n  ticketTypeSchema.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    type.addPriority(data.priority, function (err, type) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      type.save(function (err, t) {\n        if (err) return res.status(400).json({ success: false, error: err.message })\n\n        t.populate('priorities', function (err, tt) {\n          if (err) return res.status(400).json({ success: false, error: err.message })\n\n          return res.json({ success: true, type: tt })\n        })\n      })\n    })\n  })\n}\n\napiTickets.typeRemovePriority = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n\n  if (!id || !data || !data.priority) {\n    return res.status(400).json({ success: false, error: 'Invalid request data' })\n  }\n\n  ticketTypeSchema.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    type.removePriority(data.priority, function (err, type) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      type.save(function (err, t) {\n        if (err) return res.status(400).json({ success: false, error: err.message })\n\n        t.populate('priorities', function (err, tt) {\n          if (err) return res.status(400).json({ success: false, error: err.message })\n\n          return res.json({ success: true, type: tt })\n        })\n      })\n    })\n  })\n}\n\n/**\n * @api {delete} /api/v1/tickets/types/:id Delete Ticket Type\n * @apiName deleteType\n * @apiDescription Deletes given ticket type\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X DELETE\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"newTypeId\\\": \\\"{ObjectId}\\\"}\"\n *      -l http://localhost/api/v1/tickets/types/:id\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {number} updated Count of Tickets updated to new type\n *\n */\napiTickets.deleteType = function (req, res) {\n  var newTypeId = req.body.newTypeId\n  var delTypeId = req.params.id\n\n  if (_.isUndefined(newTypeId) || _.isUndefined(delTypeId)) {\n    return res.status(400).json({ success: false, error: 'Invalid POST data.' })\n  }\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n  var ticketSchema = require('../../../models/ticket')\n  var settingsSchema = require('../../../models/setting')\n\n  async.waterfall(\n    [\n      function (next) {\n        settingsSchema.getSettingByName('mailer:check:ticketype', function (err, setting) {\n          if (err) return next(err)\n          if (setting && setting.value.toString().toLowerCase() === delTypeId.toString().toLowerCase()) {\n            return next({\n              custom: true,\n              message: 'Type currently \"Default Ticket Type\" for mailer check.'\n            })\n          }\n\n          return next(null)\n        })\n      },\n      function (next) {\n        ticketSchema.updateType(delTypeId, newTypeId, next)\n      },\n      function (result, next) {\n        ticketTypeSchema.getType(delTypeId, function (err, type) {\n          if (err) return next(err)\n\n          type.remove(function (err) {\n            if (err) return next(err)\n            return next(null, result)\n          })\n        })\n      }\n    ],\n    function (err, result) {\n      if (err) return res.status(400).json({ success: false, error: err })\n      return res.json({ success: true, updated: result.nModified })\n    }\n  )\n}\n\napiTickets.createPriority = function (req, res) {\n  var data = req.body\n\n  var pName = data.name\n\n  var pOverdueIn = data.overdueIn\n\n  var pHtmlColor = data.htmlColor\n\n  if (!pName) {\n    return res.status(400).json({ success: false, error: 'Invalid Request Data.' })\n  }\n\n  var TicketPrioritySchema = require('../../../models/ticketpriority')\n\n  var P = new TicketPrioritySchema({\n    name: pName,\n    overdueIn: pOverdueIn,\n    htmlColor: pHtmlColor\n  })\n\n  P.save(function (err, savedPriority) {\n    if (err) {\n      return res.status(400).json({ success: false, error: err.message })\n    }\n\n    return res.json({ success: true, priority: savedPriority })\n  })\n}\n\napiTickets.getPriorities = function (req, res) {\n  var ticketPrioritySchema = require('../../../models/ticketpriority')\n  ticketPrioritySchema.find({}, function (err, priorities) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    priorities = _.sortBy(priorities, ['migrationNum', 'name'])\n\n    return res.json({ success: true, priorities: priorities })\n  })\n}\n\napiTickets.updatePriority = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  if (_.isUndefined(id) || _.isNull(id) || _.isNull(data) || _.isUndefined(data)) {\n    return res.status(400).json({ success: false, error: 'Invalid Request Data' })\n  }\n\n  var ticketPrioritySchema = require('../../../models/ticketpriority')\n  ticketPrioritySchema.findOne({ _id: id }, function (err, priority) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (data.name) {\n      priority.name = data.name\n    }\n    if (data.htmlColor) {\n      priority.htmlColor = data.htmlColor\n    }\n    if (data.overdueIn) {\n      priority.overdueIn = data.overdueIn\n    }\n\n    priority.save(function (err, p) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, priority: p })\n    })\n  })\n}\n\napiTickets.deletePriority = function (req, res) {\n  var id = req.params.id\n\n  var newPriority = req.body.newPriority\n\n  if (!id || !newPriority) {\n    return res.status(400).json({ success: false, error: 'Invalid Request Data' })\n  }\n\n  async.series(\n    [\n      function (next) {\n        var ticketSchema = require('../../../models/ticket')\n        ticketSchema.updateMany({ priority: id }, { priority: newPriority }, next)\n      },\n      function (next) {\n        var ticketPrioritySchema = require('../../../models/ticketpriority')\n        ticketPrioritySchema.findOne({ _id: id }, function (err, priority) {\n          if (err) return next(err)\n\n          if (priority.default) {\n            return next('Unable to delete default priority: ' + priority.name)\n          }\n\n          priority.remove(next)\n        })\n      }\n    ],\n    function (err) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/stats Get Ticket Stats\n * @apiName getTicketStats\n * @apiDescription Gets cached ticket stats\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/stats\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTicketStats = function (req, res) {\n  var timespan = 30\n  if (req.params.timespan) {\n    timespan = parseInt(req.params.timespan)\n  }\n\n  var cache = global.cache\n\n  if (_.isUndefined(cache)) {\n    return res.status(400).send('Ticket stats are still loading...')\n  }\n\n  var obj = {}\n\n  switch (timespan) {\n    case 30:\n      obj.data = cache.get('tickets:overview:e30:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e30:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e30:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e30:responseTime')\n      break\n    case 60:\n      obj.data = cache.get('tickets:overview:e60:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e60:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e60:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e60:responseTime')\n      break\n    case 90:\n      obj.data = cache.get('tickets:overview:e90:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e90:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e90:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e90:responseTime')\n      break\n    case 180:\n      obj.data = cache.get('tickets:overview:e180:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e180:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e180:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e180:responseTime')\n      break\n    case 365:\n      obj.data = cache.get('tickets:overview:e365:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e365:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e365:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e365:responseTime')\n      break\n    // case 0:\n    //     obj.data = cache.get('tickets:overview:lifetime:graphData');\n    //     obj.ticketCount = cache.get('tickets:overview:lifetime:ticketCount');\n    //     obj.closedCount = cache.get('tickets:overview:lifetime:closedTickets');\n    //     obj.ticketAvg = cache.get('tickets:overview:lifetime:responseTime');\n    //     break;\n  }\n\n  obj.mostRequester = cache.get('quickstats:mostRequester')\n  obj.mostCommenter = cache.get('quickstats:mostCommenter')\n  obj.mostAssignee = cache.get('quickstats:mostAssignee')\n  obj.mostActiveTicket = cache.get('quickstats:mostActiveTicket')\n\n  obj.lastUpdated = cache.get('tickets:overview:lastUpdated')\n  var settingsUtil = require('../../../settings/settingsUtil')\n  settingsUtil.getSettings(function (err, context) {\n    if (err) {\n      return res.send(obj)\n    }\n\n    var tz = context.data.settings.timezone.value\n    obj.lastUpdated = moment\n      .utc(obj.lastUpdated)\n      .tz(tz)\n      .format('MM-DD-YYYY hh:mm:ssa')\n\n    return res.send(obj)\n  })\n  // return res.send(obj);\n}\n\nfunction parseTicketStats (role, tickets, callback) {\n  if (_.isEmpty(tickets)) return callback({ tickets: tickets, tags: {} })\n  var t = []\n  var tags = {}\n  if (!permissions.canThis(role, 'tickets:notes')) {\n    _.each(tickets, function (ticket) {\n      ticket.notes = []\n    })\n  }\n\n  async.each(\n    tickets,\n    function (ticket, cb) {\n      _.each(ticket.tags, function (tag) {\n        t.push(tag.name)\n      })\n\n      t = _.take(t, 10)\n\n      return cb()\n    },\n    function () {\n      _.mixin({\n        sortKeysBy: function (obj, comparator) {\n          var keys = _.sortBy(_.keys(obj), function (key) {\n            return comparator ? comparator(obj[key], key) : key\n          })\n\n          return _.zipObject(\n            keys,\n            _.map(keys, function (key) {\n              return obj[key]\n            })\n          )\n        }\n      })\n\n      tags = _.countBy(t, function (k) {\n        return k\n      })\n      tags = _(tags)\n        .toPairs()\n        .sortBy(0)\n        .fromPairs()\n        .value()\n\n      return callback({ tickets: tickets, tags: tags })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/stats/group/:group Get Ticket Stats For Group\n * @apiName getTicketStatsForGroup\n * @apiDescription Gets live ticket stats for given groupId\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/stats/group/{groupid}\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTicketStatsForGroup = function (req, res) {\n  var groupId = req.params.group\n  if (groupId === 0) return res.status(200).json({ success: false, error: 'Please Select Group.' })\n  if (_.isUndefined(groupId)) return res.status(400).json({ success: false, error: 'Invalid Group Id.' })\n\n  var ticketModel = require('../../../models/ticket')\n  var data = {}\n  var tags = {}\n  async.waterfall(\n    [\n      function (callback) {\n        var obj = { limit: 10000, page: 0 }\n        ticketModel.getTicketsWithObject([groupId], obj, function (err, tickets) {\n          if (err) return callback(err)\n          parseTicketStats(req.user.role, tickets, function (data) {\n            tags = data.tags\n\n            return callback(null, tickets)\n          })\n        })\n      },\n      function (tickets, callback) {\n        if (_.isEmpty(tickets)) return callback('Group has no tickets to report.')\n        var today = moment()\n          .hour(23)\n          .minute(59)\n          .second(59)\n        var r = {}\n        r.ticketCount = _.size(tickets)\n        tickets = _.sortBy(tickets, 'date')\n        r.recentTickets = _.takeRight(tickets, 5)\n        r.closedTickets = _.filter(tickets, function (v) {\n          return v.status === 3\n        })\n\n        var firstDate = moment(_.first(tickets).date).subtract(30, 'd')\n        var diffDays = today.diff(firstDate, 'days')\n\n        buildGraphData(tickets, diffDays, function (graphData) {\n          r.graphData = graphData\n\n          // Get average Response\n          buildAvgResponse(tickets, function (obj) {\n            if (_.isUndefined(obj)) {\n              return callback(null, r)\n            }\n\n            r.avgResponse = obj.avgResponse\n\n            return callback(null, r)\n          })\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.status(400).json({ success: false, error: err })\n\n      data.ticketCount = results.ticketCount\n      data.recentTickets = results.recentTickets\n      data.closedCount = _.size(results.closedTickets)\n      data.graphData = results.graphData\n      data.avgResponse = results.avgResponse\n      data.tags = tags\n\n      return res.json({ success: true, data: data })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/stats/user/:user Get Ticket Stats For User\n * @apiName getTicketStatsForUser\n * @apiDescription Gets live ticket stats for given userId\n * @apiVersion 0.1.9\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/stats/user/{userid}\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTicketStatsForUser = function (req, res) {\n  var userId = req.params.user\n  if (userId === 0) return res.status(200).json({ success: false, error: 'Please Select User.' })\n  if (_.isUndefined(userId)) return res.status(400).json({ success: false, error: 'Invalid User Id.' })\n\n  var ticketModel = require('../../../models/ticket')\n  var data = {}\n  var tags = {}\n  async.waterfall(\n    [\n      function (callback) {\n        ticketModel.getTicketsByRequester(userId, function (err, tickets) {\n          if (err) return callback(err)\n          parseTicketStats(req.user.role, tickets, function (data) {\n            tags = data.tags\n\n            return callback(null, tickets)\n          })\n        })\n      },\n      function (tickets, callback) {\n        if (_.isEmpty(tickets)) return callback('User has no tickets to report.')\n        var today = moment()\n          .hour(23)\n          .minute(59)\n          .second(59)\n        var r = {}\n        r.ticketCount = _.size(tickets)\n        tickets = _.sortBy(tickets, 'date')\n        r.recentTickets = _.takeRight(tickets, 5)\n        r.closedTickets = _.filter(tickets, function (v) {\n          return v.status === 3\n        })\n\n        var firstDate = moment(_.first(tickets).date).subtract(30, 'd')\n        var diffDays = today.diff(firstDate, 'days')\n\n        buildGraphData(tickets, diffDays, function (graphData) {\n          r.graphData = graphData\n\n          // Get average Response\n          buildAvgResponse(tickets, function (obj) {\n            if (_.isUndefined(obj)) {\n              return callback(null, r)\n            }\n\n            r.avgResponse = obj.avgResponse\n\n            return callback(null, r)\n          })\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.status(400).json({ success: false, error: err })\n\n      data.ticketCount = results.ticketCount\n      data.recentTickets = results.recentTickets\n      data.closedCount = _.size(results.closedTickets)\n      data.graphData = results.graphData\n      data.avgResponse = results.avgResponse\n      data.tags = tags\n\n      return res.json({ success: true, data: data })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/count/tags Get Tags Count\n * @apiName getTagCount\n * @apiDescription Gets cached count of all tags\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/count/tags\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTagCount = function (req, res) {\n  var cache = global.cache\n  var timespan = req.params.timespan\n  if (_.isUndefined(timespan) || _.isNaN(timespan)) timespan = 0\n\n  if (_.isUndefined(cache)) {\n    return res.status(400).send('Tag stats are still loading...')\n  }\n\n  var tags = cache.get('tags:' + timespan + ':usage')\n\n  res.json({ success: true, tags: tags })\n}\n\n/**\n * @api {get} /api/v1/tickets/count/topgroups/:timespan/:topNum Top Groups Count\n * @apiName getTopTicketGroups\n * @apiDescription Gets the group with the top ticket count and timespan\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/count/topgroups/30/10\n *\n * @apiSuccess {array} items Array with Group name and Count\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiTickets.getTopTicketGroups = function (req, res) {\n  var ticketModel = require('../../../models/ticket')\n  var top = req.params.top\n  var timespan = req.params.timespan\n\n  ticketModel.getTopTicketGroups(timespan, top, function (err, items) {\n    if (err) return res.status(400).json({ error: 'Invalid Request' })\n\n    return res.json({ items: items })\n  })\n}\n\n/**\n * @api {delete} /api/v1/tickets/:tid/attachments/remove/:aid Remove Attachment\n * @apiName removeAttachment\n * @apiDescription Remove Attachemtn with given Attachment ID from given Ticket ID\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/:tid/attachments/remove/:aid\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidRequest Invalid Request\n * @apiError InvalidPermissions Invalid Permissions\n */\napiTickets.removeAttachment = function (req, res) {\n  var ticketId = req.params.tid\n  var attachmentId = req.params.aid\n  if (_.isUndefined(ticketId) || _.isUndefined(attachmentId))\n    return res.status(400).json({ error: 'Invalid Attachment' })\n\n  // Check user perm\n  var user = req.user\n  if (_.isUndefined(user)) return res.status(400).json({ error: 'Invalid User Auth.' })\n\n  var permissions = require('../../../permissions')\n  if (!permissions.canThis(user.role, 'tickets:removeAttachment'))\n    return res.status(401).json({ error: 'Invalid Permissions' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(ticketId, function (err, ticket) {\n    if (err) return res.status(400).send('Invalid Ticket Id')\n    ticket.getAttachment(attachmentId, function (a) {\n      ticket.removeAttachment(user._id, attachmentId, function (err, ticket) {\n        if (err) return res.status(400).json({ error: 'Invalid Request.' })\n\n        var fs = require('fs')\n        var path = require('path')\n        var dir = path.join(__dirname, '../../../../public', a.path)\n        if (fs.existsSync(dir)) fs.unlinkSync(dir)\n\n        ticket.save(function (err, t) {\n          if (err) return res.status(400).json({ error: 'Invalid Request.' })\n\n          res.json({ success: true, ticket: t })\n        })\n      })\n    })\n  })\n}\n\n/**\n * @api {put} /api/v1/tickets/:id/subscribe Subscribe/Unsubscribe\n * @apiName subscribeTicket\n * @apiDescription Subscribe/Unsubscribe user to the given ticket OID\n * @apiVersion 0.1.4\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"Content-Type: application/json\" -H \"accesstoken: {accesstoken}\" -X PUT -d \"{\\\"user\\\": {user},\\\"subscribe\\\": {boolean}}\" -l http://localhost/api/v1/tickets/{id}\n *\n * @apiParamExample {json} Request-Example:\n   {\n       \"user\": {user},\n       \"subscribe\": {boolean}\n   }\n *\n * @apiSuccess {boolean} success Successfully?\n *\n * @apiError InvalidPostData Invalid Post Data\n */\napiTickets.subscribe = function (req, res) {\n  var ticketId = req.params.id\n  var data = req.body\n  if (_.isUndefined(data.user) || _.isUndefined(data.subscribe))\n    return res.status(400).json({ error: 'Invalid Post Data.' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(ticketId, function (err, ticket) {\n    if (err) return res.status(400).json({ error: 'Invalid Ticket Id' })\n\n    async.series(\n      [\n        function (callback) {\n          if (data.subscribe) {\n            ticket.addSubscriber(data.user, function () {\n              callback()\n            })\n          } else {\n            ticket.removeSubscriber(data.user, function () {\n              callback()\n            })\n          }\n        }\n      ],\n      function () {\n        ticket.save(function (err, ticket) {\n          if (err) return res.status(400).json({ error: err })\n\n          emitter.emit('ticket:subscriber:update', ticket)\n\n          res.json({ success: true, ticket: ticket })\n        })\n      }\n    )\n  })\n}\n\n/**\n * @api {get} /api/v1/tickets/tags Get Ticket Tags\n * @apiName getTags\n * @apiDescription Gets all ticket tags\n * @apiVersion 0.1.6\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/tags\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {boolean} tags Array of Tags\n *\n */\napiTickets.getTags = function (req, res) {\n  var tagSchema = require('../../../models/tag')\n  tagSchema.getTags(function (err, tags) {\n    if (err) return res.status(400).json({ success: false, error: err })\n\n    _.each(tags, function (item) {\n      item.__v = undefined\n    })\n\n    res.json({ success: true, tags: tags })\n  })\n}\n\n/**\n * @api {get} /api/v1/tickets/overdue Get Overdue Tickets\n * @apiName getOverdue\n * @apiDescription Gets current overdue tickets\n * @apiVersion 0.1.9\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/overdue\n *\n * @apiSuccess {boolean} success Successfully?\n *\n */\napiTickets.getOverdue = function (req, res) {\n  var settingSchema = require('../../../models/setting')\n  settingSchema.getSettingByName('showOverdueTickets:enable', function (err, setting) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (setting !== null && setting.value === false) {\n      return res.json({\n        success: true,\n        error: 'Show Overdue currently disabled.'\n      })\n    }\n\n    var ticketSchema = require('../../../models/ticket')\n    var departmentSchema = require('../../../models/department')\n    var groupSchema = require('../../../models/group')\n\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          } else {\n            return departmentSchema.getDepartmentGroupsOfUser(req.user._id, next)\n          }\n        },\n        function (groups, next) {\n          var groupIds = groups.map(function (g) {\n            return g._id\n          })\n\n          ticketSchema.getOverdue(groupIds, function (err, tickets) {\n            if (err) return next(err)\n\n            var sorted = _.sortBy(tickets, 'uid').reverse()\n\n            return next(null, sorted)\n          })\n        }\n      ],\n      function (err, overdueTickets) {\n        if (err) return res.status(400).json({ success: false, error: err.message })\n\n        return res.json({ success: true, tickets: overdueTickets })\n      }\n    )\n  })\n}\n\napiTickets.getDeletedTickets = function (req, res) {\n  var ticketSchema = require('../../../models/ticket')\n  ticketSchema.getDeleted(function (err, tickets) {\n    if (err) return res.status(500).json({ success: false, error: err })\n\n    return res.json({ success: true, count: tickets.length, deletedTickets: tickets })\n  })\n}\n\napiTickets.restoreDeleted = function (req, res) {\n  var postData = req.body\n  if (!postData || !postData._id) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  var ticketSchema = require('../../../models/ticket')\n  ticketSchema.restoreDeleted(postData._id, function (err) {\n    if (err) return res.status(500).json({ success: false, error: err })\n\n    return res.json({ success: true })\n  })\n}\n\nmodule.exports = apiTickets\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar _ = require('lodash')\nvar moment = require('moment-timezone')\nvar winston = require('../../../logger')\nvar permissions = require('../../../permissions')\nvar emitter = require('../../../emitter')\nvar xss = require('xss')\nvar sanitizeHtml = require('sanitize-html')\n\nvar apiTickets = {}\n\nfunction buildGraphData (arr, days, callback) {\n  var graphData = []\n  var today = moment()\n    .hour(23)\n    .minute(59)\n    .second(59)\n  var timespanArray = []\n  for (var i = days; i--; ) {\n    timespanArray.push(i)\n  }\n\n  _.each(timespanArray, function (day) {\n    var obj = {}\n    var d = today.clone().subtract(day, 'd')\n    obj.date = d.format('YYYY-MM-DD')\n\n    var $dateCount = _.filter(arr, function (v) {\n      return (\n        v.date <= d.toDate() &&\n        v.date >=\n          d\n            .clone()\n            .subtract(1, 'd')\n            .toDate()\n      )\n    })\n\n    $dateCount = _.size($dateCount)\n    obj.value = $dateCount\n    graphData.push(obj)\n  })\n\n  if (_.isFunction(callback)) {\n    return callback(graphData)\n  }\n\n  return graphData\n}\n\nfunction buildAvgResponse (ticketArray, callback) {\n  var cbObj = {}\n  var $ticketAvg = []\n  _.each(ticketArray, function (ticket) {\n    if (_.isUndefined(ticket.comments) || _.size(ticket.comments) < 1) return\n\n    var ticketDate = moment(ticket.date)\n    var firstCommentDate = moment(ticket.comments[0].date)\n\n    var diff = firstCommentDate.diff(ticketDate, 'seconds')\n    $ticketAvg.push(diff)\n  })\n\n  var ticketAvgTotal = _($ticketAvg).reduce(function (m, x) {\n    return m + x\n  }, 0)\n\n  var tvt = moment.duration(Math.round(ticketAvgTotal / _.size($ticketAvg)), 'seconds').asHours()\n  cbObj.avgResponse = Math.floor(tvt)\n\n  if (_.isFunction(callback)) {\n    return callback(cbObj)\n  }\n\n  return cbObj\n}\n\n/**\n * @api {get} /api/v1/tickets/ Get Tickets\n * @apiName getTickets\n * @apiDescription Gets tickets for the given User\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets\n *\n * @apiSuccess {object}     _id                 The MongoDB ID\n * @apiSuccess {number}     uid                 Unique ID (seq num)\n * @apiSuccess {object}     owner               User\n * @apiSuccess {object}     owner._id           The MongoDB ID of Owner\n * @apiSuccess {string}     owner.username      Username\n * @apiSuccess {string}     owner.fullname      User Full Name\n * @apiSuccess {string}     owner.email         User Email Address\n * @apiSuccess {string}     owner.role          User Permission Role\n * @apiSuccess {string}     owner.title         User Title\n * @apiSuccess {string}     owner.image         User Image Rel Path\n * @apiSuccess {object}     group               Group\n * @apiSuccess {object}     group._id           Group MongoDB ID\n * @apiSuccess {string}     group.name          Group Name\n * @apiSuccess {object}     assignee            User Assigned\n * @apiSuccess {object}     assignee._id        The MongoDB ID of Owner\n * @apiSuccess {string}     assignee.username   Username\n * @apiSuccess {string}     assignee.fullname   User Full Name\n * @apiSuccess {string}     assignee.email      User Email Address\n * @apiSuccess {string}     assignee.role       User Permission Role\n * @apiSuccess {string}     assignee.title      User Title\n * @apiSuccess {string}     assignee.image      User Image Rel Path\n * @apiSuccess {date}       date                Created Date\n * @apiSuccess {date}       updated             Last Updated DateTime\n * @apiSuccess {boolean}    deleted             Deleted Flag\n * @apiSuccess {object}     type                Ticket Type\n * @apiSuccess {object}     type._id            Type MongoDB ID\n * @apiSuccess {string}     type.name           Type Name\n * @apiSuccess {number}     status              Status of Ticket\n * @apiSuccess {number}     prioirty            Prioirty of Ticket\n * @apiSuccess {array}      tags                Array of Tags\n * @apiSuccess {string}     subject             Subject Text\n * @apiSuccess {string}     issue               Issue Text\n * @apiSuccess {date}       closedDate          Date Ticket was closed\n * @apiSuccess {array}      comments            Array of Comments\n * @apiSuccess {array}      attachments         Array of Attachments\n * @apiSuccess {array}      history             Array of History items\n *\n */\napiTickets.get = function (req, res) {\n  var l = req.query.limit ? req.query.limit : 10\n  var limit = parseInt(l)\n  var page = parseInt(req.query.page)\n  var assignedSelf = req.query.assignedself\n  var status = req.query.status\n  var user = req.user\n\n  var object = {\n    user: user,\n    limit: limit,\n    page: page,\n    assignedSelf: assignedSelf,\n    status: status\n  }\n\n  var ticketModel = require('../../../models/ticket')\n  var groupModel = require('../../../models/group')\n  var departmentModel = require('../../../models/department')\n\n  async.waterfall(\n    [\n      function (callback) {\n        if (user.role.isAdmin || user.role.isAgent) {\n          departmentModel.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n            callback(err, groups)\n          })\n        } else {\n          groupModel.getAllGroupsOfUserNoPopulate(user._id, function (err, grps) {\n            callback(err, grps)\n          })\n        }\n      },\n      function (grps, callback) {\n        if (permissions.canThis(user.role, 'tickets:public')) {\n          groupModel.getAllPublicGroups(function (err, publicGroups) {\n            if (err) return callback(err)\n\n            grps = grps.concat(publicGroups)\n\n            return callback(null, grps)\n          })\n        } else {\n          return callback(null, grps)\n        }\n      },\n      function (grps, callback) {\n        ticketModel.getTicketsWithObject(grps, object, function (err, results) {\n          if (!permissions.canThis(user.role, 'comments:view')) {\n            _.each(results, function (ticket) {\n              ticket.comments = []\n            })\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            _.each(results, function (ticket) {\n              ticket.notes = []\n            })\n          }\n\n          // sanitize\n          _.each(results, function (ticket) {\n            ticket.subscribers = _.map(ticket.subscribers, function (s) {\n              return s._id\n            })\n\n            ticket.history = _.map(ticket.history, function (h) {\n              var obj = {\n                date: h.date,\n                _id: h._id,\n                action: h.action,\n                description: h.description,\n                owner: _.clone(h.owner)\n              }\n              obj.owner.role = h.owner.role._id\n              return obj\n            })\n\n            ticket.owner.role = ticket.owner.role._id\n          })\n\n          return callback(err, results)\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.send('Error: ' + err.message)\n\n      return res.json(results)\n    }\n  )\n}\n\napiTickets.getByGroup = function (req, res) {\n  var groupId = req.params.id\n  if (!groupId) return res.status(400).json({ success: false, error: 'Invalid Group Id' })\n\n  var limit = req.query.limit ? Number(req.query.limit) : 50\n  var page = req.query.page ? Number(req.query.page) : 0\n\n  var obj = {\n    limit: limit,\n    page: page\n  }\n\n  var ticketSchema = require('../../../models/ticket')\n  ticketSchema.getTicketsWithObject([groupId], obj, function (err, tickets) {\n    if (err) return res.status(500).json({ success: false, error: err.message })\n\n    return res.json({ success: true, tickets: tickets, count: tickets.length })\n  })\n}\n\napiTickets.getCountByGroup = function (req, res) {\n  var groupId = req.params.id\n  if (!groupId) return res.status(400).json({ success: false, error: 'Invalid Group Id' })\n  if (_.isUndefined(req.query.type) || _.isUndefined(req.query.value))\n    return res.status(400).json({ success: false, error: 'Invalid QueryString' })\n\n  var type = req.query.type\n  var value = req.query.value\n  // var limit = req.query.limit ? Number(req.query.limit) : -1\n  // var page = req.query.page ? Number(req.query.page) : 0\n\n  var ticketSchema = require('../../../models/ticket')\n\n  var obj = {\n    // limit: limit,\n    // page: page\n  }\n\n  switch (type.toLowerCase()) {\n    case 'status':\n      obj.status = [Number(value)]\n      ticketSchema.getCountWithObject([groupId], obj, function (err, count) {\n        if (err) return res.status(500).json({ success: false, error: err.message })\n\n        return res.json({ success: true, count: count })\n      })\n      break\n    case 'tickettype':\n      obj.filter = {\n        types: [value]\n      }\n      ticketSchema.getCountWithObject([groupId], obj, function (err, count) {\n        if (err) return res.status(500).json({ success: false, error: err.message })\n\n        return res.json({ success: true, count: count })\n      })\n      break\n    default:\n      return res.status(400).json({ success: false, error: 'Unsupported type query' })\n  }\n}\n\n/**\n * @api {get} /api/v1/tickets/search/?search={searchString} Get Tickets by Search String\n * @apiName search\n * @apiDescription Gets tickets via search string\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/search/?search=searchString\n *\n * @apiSuccess {number} count Count of Tickets Array\n * @apiSuccess {array} tickets Tickets Array\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Ticket\"\n }\n */\napiTickets.search = function (req, res) {\n  var searchString = req.query.search\n\n  var ticketModel = require('../../../models/ticket')\n  var groupModel = require('../../../models/group')\n  var departmentModel = require('../../../models/department')\n\n  async.waterfall(\n    [\n      function (callback) {\n        if (req.user.role.isAdmin || req.user.role.isAgent) {\n          return departmentModel.getDepartmentGroupsOfUser(req.user._id, callback)\n        } else {\n          return groupModel.getAllGroupsOfUserNoPopulate(req.user._id, callback)\n        }\n      },\n      function (grps, callback) {\n        if (permissions.canThis(req.user.role, 'tickets:public')) {\n          groupModel.getAllPublicGroups(function (err, publicGroups) {\n            if (err) return callback(err)\n\n            grps = grps.concat(publicGroups)\n\n            return callback(null, grps)\n          })\n        } else {\n          return callback(null, grps)\n        }\n      },\n      function (grps, callback) {\n        ticketModel.getTicketsWithSearchString(grps, searchString, function (err, results) {\n          if (!permissions.canThis(req.user.role.role, 'tickets:notes')) {\n            _.each(results, function (ticket) {\n              ticket.notes = []\n            })\n          }\n\n          return callback(err, results)\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.status(400).json({ success: false, error: 'Error - ' + err.message })\n\n      return res.json({\n        success: true,\n        error: null,\n        count: _.size(results),\n        totalCount: _.size(results),\n        tickets: _.sortBy(results, 'uid').reverse()\n      })\n    }\n  )\n}\n\n/**\n * @api {post} /api/v1/tickets/create Create Ticket\n * @apiName createTicket\n * @apiDescription Creates a ticket with the given post data.\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"subject\": \"Subject\",\n *      \"issue\": \"Issue Exmaple\",\n *      \"owner\": {OwnerId},\n *      \"group\": {GroupId},\n *      \"type\": {TypeId},\n *      \"prioirty\": {PriorityId},\n *      \"tags\": [{tagId}]\n * }\n *\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"subject\\\":\\\"{subject}\\\",\\\"owner\\\":{ownerId}, group: \\\"{groupId}\\\", type: \\\"{typeId}\\\", issue: \\\"{issue}\\\", prioirty: \\\"{prioirty}\\\"}\"\n *      -l http://localhost/api/v1/tickets/create\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Saved Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n        {\n            \"error\": \"Invalid Post Data\"\n        }\n */\n\napiTickets.create = function (req, res) {\n  var response = {}\n  response.success = true\n\n  var postData = req.body\n  if (!_.isObject(postData) || !postData.subject || !postData.issue)\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  var socketId = _.isUndefined(postData.socketId) ? '' : postData.socketId\n\n  if (_.isUndefined(postData.tags) || _.isNull(postData.tags)) {\n    postData.tags = []\n  } else if (!_.isArray(postData.tags)) {\n    postData.tags = [postData.tags]\n  }\n\n  async.waterfall(\n    [\n      function (done) {\n        var UserSchema = require('../../../models/user')\n        UserSchema.findOne({ _id: req.user._id }, done)\n      },\n      function (user, done) {\n        if (user.deleted) return done({ status: 400, error: 'Invalid User' })\n\n        var HistoryItem = {\n          action: 'ticket:created',\n          description: 'Ticket was created.',\n          owner: req.user._id\n        }\n\n        var TicketSchema = require('../../../models/ticket')\n        var ticket = new TicketSchema(postData)\n        if (!_.isUndefined(postData.owner)) {\n          ticket.owner = postData.owner\n        } else {\n          ticket.owner = req.user._id\n        }\n\n        ticket.subject = sanitizeHtml(ticket.subject).trim()\n\n        var marked = require('marked')\n        var tIssue = ticket.issue\n        tIssue = tIssue.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, '<br>')\n        tIssue = sanitizeHtml(tIssue).trim()\n        ticket.issue = xss(marked.parse(tIssue))\n        ticket.history = [HistoryItem]\n        ticket.subscribers = [user._id]\n\n        ticket.save(function (err, t) {\n          if (err) return done({ status: 400, error: err })\n\n          t.populate('group owner priority', function (err, tt) {\n            if (err) return done({ status: 400, error: err })\n\n            emitter.emit('ticket:created', {\n              hostname: req.headers.host,\n              socketId: socketId,\n              ticket: tt\n            })\n\n            response.ticket = tt\n            res.json(response)\n          })\n        })\n      }\n    ],\n    function (err) {\n      if (err) {\n        response.success = false\n        response.error = err.error\n        return res.status(err.status).json(response)\n      }\n\n      response.success = true\n\n      return res.json(response)\n    }\n  )\n}\n\n/**\n * @api {post} /api/v1/public/tickets/create Create Public Ticket\n * @apiName createPublicTicket\n * @apiDescription Creates a ticket with the given post data via public ticket submission. [Limited to Server Origin]\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"fullname\": \"Full Name\",\n *      \"email\": \"email@email.com\",\n *      \"subject\": \"Subject\",\n *      \"issue\": \"Issue Exmaple\"\n * }\n *\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -d \"{\\\"fullname\\\":\\\"{fullname}\\\",\\\"email\\\":{email}, \\\"subject\\\": \\\"{subject}\\\", \\\"issue\\\": \\\"{issue}\\\"}\"\n *      -l http://localhost/api/v1/public/tickets/create\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Saved Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.createPublicTicket = function (req, res) {\n  var Chance = require('chance')\n\n  var chance = new Chance()\n  var response = {}\n  response.success = true\n  var postData = req.body\n  if (!_.isObject(postData)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  var user, group, ticket, plainTextPass\n\n  var settingSchema = require('../../../models/setting')\n\n  async.waterfall(\n    [\n      function (next) {\n        settingSchema.getSetting('allowPublicTickets:enable', function (err, allowPublicTickets) {\n          if (err) return next(err)\n          if (!allowPublicTickets) {\n            winston.warn('Public ticket creation attempted while disabled!')\n            return next('Public ticket creation is disabled!')\n          }\n\n          return next()\n        })\n      },\n      function (next) {\n        settingSchema.getSetting('role:user:default', function (err, roleDefault) {\n          if (err) return next(err)\n          if (!roleDefault) {\n            winston.error('No Default User Role Set. (Settings > Permissions > Default User Role)')\n            return next('No Default Role Set')\n          }\n\n          return next(null, roleDefault)\n        })\n      },\n      function (roleDefault, next) {\n        var UserSchema = require('../../../models/user')\n        plainTextPass = chance.string({\n          length: 6,\n          pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n        })\n\n        var sanitizedFullname = xss(postData.user.fullname)\n\n        user = new UserSchema({\n          username: postData.user.email,\n          password: plainTextPass,\n          fullname: sanitizedFullname,\n          email: postData.user.email,\n          accessToken: chance.hash(),\n          role: roleDefault.value\n        })\n\n        user.save(function (err, savedUser) {\n          if (err) return next(err)\n\n          return next(null, savedUser)\n        })\n      },\n\n      function (savedUser, next) {\n        // Group Creation\n        var GroupSchema = require('../../../models/group')\n        group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, group) {\n          if (err) return next(err)\n\n          return next(null, group, savedUser)\n        })\n      },\n\n      function (group, savedUser, next) {\n        var settingsSchema = require('../../../models/setting')\n        settingsSchema.getSettingByName('ticket:type:default', function (err, defaultType) {\n          if (err) return next(err)\n\n          if (defaultType.value) {\n            return next(null, defaultType.value, group, savedUser)\n          }\n\n          return next('Failed: Invalid Default Ticket Type.')\n        })\n      },\n\n      function (defaultTicketType, group, savedUser, next) {\n        // Create Ticket\n        var ticketTypeSchema = require('../../../models/tickettype')\n        ticketTypeSchema.getType(defaultTicketType, function (err, ticketType) {\n          if (err) return next(err)\n\n          var TicketSchema = require('../../../models/ticket')\n          var HistoryItem = {\n            action: 'ticket:created',\n            description: 'Ticket was created.',\n            owner: savedUser._id\n          }\n          ticket = new TicketSchema({\n            owner: savedUser._id,\n            group: group._id,\n            type: ticketType._id,\n            priority: _.first(ticketType.priorities)._id, // TODO: change when priority order is complete!\n            subject: xss(sanitizeHtml(postData.ticket.subject).trim()),\n            issue: xss(sanitizeHtml(postData.ticket.issue).trim()),\n            history: [HistoryItem],\n            subscribers: [savedUser._id]\n          })\n\n          var marked = require('marked')\n          var tIssue = ticket.issue\n          tIssue = tIssue.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, '<br>')\n          tIssue = sanitizeHtml(tIssue).trim()\n          ticket.issue = marked.parse(tIssue)\n          ticket.issue = xss(ticket.issue)\n\n          ticket.save(function (err, t) {\n            if (err) return next(err)\n\n            emitter.emit('ticket:created', {\n              hostname: req.headers.host,\n              socketId: '',\n              ticket: t\n            })\n\n            return next(null, { user: savedUser, group: group, ticket: t })\n          })\n        })\n      }\n    ],\n    function (err, result) {\n      if (err) winston.debug(err)\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      delete result.user.password\n      result.user.password = undefined\n\n      return res.json({\n        success: true,\n        userData: { savedUser: result.user, chancepass: plainTextPass },\n        ticket: result.ticket\n      })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/:uid Get Single Ticket\n * @apiName singleTicket\n * @apiDescription Gets a ticket with the given UID.\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/1000\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Ticket\"\n }\n */\napiTickets.single = function (req, res) {\n  var uid = req.params.uid\n  if (_.isUndefined(uid)) return res.status(200).json({ success: false, error: 'Invalid Ticket' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketByUid(uid, function (err, ticket) {\n    if (err) return res.send(err)\n\n    if (_.isUndefined(ticket) || _.isNull(ticket)) {\n      return res.status(200).json({ success: false, error: 'Invalid Ticket' })\n    }\n\n    ticket = _.clone(ticket._doc)\n    if (!permissions.canThis(req.user.role, 'tickets:notes')) {\n      delete ticket.notes\n    }\n\n    return res.json({ success: true, ticket: ticket })\n  })\n}\n\n/**\n * @api {put} /api/v1/tickets/:id Update Ticket\n * @apiName updateTicket\n * @apiDescription Updates ticket via given OID\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -X PUT -d \"{\\\"status\\\": {status},\\\"group\\\": \\\"{group}\\\"}\"\n *      -l http://localhost/api/v1/tickets/{id}\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} ticket Updated Ticket Object\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.update = function (req, res) {\n  var user = req.user\n  if (!_.isUndefined(user) && !_.isNull(user)) {\n    var permissions = require('../../../permissions')\n    if (!permissions.canThis(user.role, 'tickets:update')) {\n      return res.status(401).json({ success: false, error: 'Invalid Permissions' })\n    }\n    var oId = req.params.id\n    var reqTicket = req.body\n    if (_.isUndefined(oId)) return res.status(400).json({ success: false, error: 'Invalid Ticket ObjectID.' })\n    var ticketModel = require('../../../models/ticket')\n    ticketModel.getTicketById(oId, function (err, ticket) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n      if (!ticket) return res.status(400).json({ success: false, error: 'Unable to locate ticket. Aborting...' })\n      async.parallel(\n        [\n          function (cb) {\n            if (!_.isUndefined(reqTicket.status)) {\n              ticket.status = reqTicket.status\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.subject)) {\n              ticket.subject = sanitizeHtml(reqTicket.subject).trim()\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.group)) {\n              ticket.group = reqTicket.group._id || reqTicket.group\n\n              ticket.populate('group', function () {\n                return cb()\n              })\n            } else {\n              return cb()\n            }\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.closedDate)) {\n              ticket.closedDate = reqTicket.closedDate\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.tags) && !_.isNull(reqTicket.tags)) {\n              ticket.tags = reqTicket.tags\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.issue) && !_.isNull(reqTicket.issue)) {\n              ticket.issue = sanitizeHtml(reqTicket.issue).trim()\n            }\n\n            return cb()\n          },\n          function (cb) {\n            if (!_.isUndefined(reqTicket.assignee) && !_.isNull(reqTicket.assignee)) {\n              ticket.assignee = reqTicket.assignee\n              ticket.populate('assignee', function (err, t) {\n                if (err) return cb(err)\n\n                var HistoryItem = {\n                  action: 'ticket:set:assignee',\n                  description: t.assignee.fullname + ' was set as assignee',\n                  owner: req.user._id\n                }\n\n                ticket.history.push(HistoryItem)\n\n                return cb()\n              })\n            } else {\n              return cb()\n            }\n          }\n        ],\n        function () {\n          ticket.save(function (err, t) {\n            if (err) {\n              return res.status(400).json({ success: false, error: err.message })\n            }\n\n            if (!permissions.canThis(user.role, 'tickets:notes')) {\n              t.notes = []\n            }\n\n            return res.json({\n              success: true,\n              error: null,\n              ticket: t\n            })\n          })\n        }\n      )\n    })\n  } else {\n    return res.status(403).json({ success: false, error: 'Invalid Access Token' })\n  }\n}\n\n/**\n * @api {delete} /api/v1/tickets/:id Delete Ticket\n * @apiName deleteTicket\n * @apiDescription Deletes ticket via given OID\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/{id}\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n *\n * @apiError InvalidRequest The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.delete = function (req, res) {\n  var oId = req.params.id\n  var user = req.user\n\n  if (_.isUndefined(oId) || _.isUndefined(user))\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.softDelete(oId, function (err) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    emitter.emit('ticket:deleted', oId)\n    res.json({ success: true, error: null })\n  })\n}\n\n/**\n * @api {post} /api/v1/tickets/addcomment Add Comment\n * @apiName addComment\n * @apiDescription Adds comment to the given Ticket Id\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"comment\\\":\\\"{comment}\\\",\\\"owner\\\":{ownerId}, ticketId: \\\"{ticketId}\\\"}\"\n *      -l http://localhost/api/v1/tickets/addcomment\n *\n * @apiParamExample {json} Request:\n * {\n *      \"comment\": \"Comment Text\",\n *      \"owner\": {OwnerId},\n *      \"ticketid\": {TicketId}\n * }\n *\n * @apiSuccess {boolean} success Successful\n * @apiSuccess {string} error Error if occurrred\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.postComment = function (req, res) {\n  var commentJson = req.body\n  var comment = commentJson.comment\n  var owner = commentJson.ownerId || req.user._id\n  var ticketId = commentJson._id\n\n  if (_.isUndefined(ticketId)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(ticketId, function (err, t) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    if (_.isUndefined(comment)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    var marked = require('marked')\n    marked.setOptions({\n      breaks: true\n    })\n\n    comment = sanitizeHtml(comment).trim()\n\n    var Comment = {\n      owner: owner,\n      date: new Date(),\n      comment: xss(marked.parse(comment))\n    }\n\n    t.updated = Date.now()\n    t.comments.push(Comment)\n    var HistoryItem = {\n      action: 'ticket:comment:added',\n      description: 'Comment was added',\n      owner: owner\n    }\n    t.history.push(HistoryItem)\n\n    t.save(function (err, tt) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      if (!permissions.canThis(req.user.role, 'tickets:notes')) {\n        tt.notes = []\n      }\n\n      emitter.emit('ticket:comment:added', tt, Comment, req.headers.host)\n\n      return res.json({ success: true, error: null, ticket: tt })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/tickets/addnote Add Note\n * @apiName addInternalNote\n * @apiDescription Adds a note to the given Ticket Id\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"Content-Type: application/json\"\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"note\\\":\\\"{note}\\\",\\\"owner\\\":{ownerId}, ticketId: \\\"{ticketId}\\\"}\"\n *      -l http://localhost/api/v1/tickets/addnote\n *\n * @apiParamExample {json} Request:\n * {\n *      \"note\": \"Note Text\",\n *      \"owner\": {OwnerId},\n *      \"ticketid\": {TicketId}\n * }\n *\n * @apiSuccess {boolean} success Successful\n * @apiSuccess {string} error Error if occurrred\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiTickets.postInternalNote = function (req, res) {\n  var payload = req.body\n  if (_.isUndefined(payload.ticketid)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(payload.ticketid, function (err, ticket) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (_.isUndefined(payload.note)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    var marked = require('marked')\n    // var note = payload.note.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, \"<br>\");\n    var Note = {\n      owner: payload.owner || req.user._id,\n      date: new Date(),\n      note: xss(marked.parse(payload.note))\n    }\n\n    ticket.updated = Date.now()\n    ticket.notes.push(Note)\n    var HistoryItem = {\n      action: 'ticket:note:added',\n      description: 'Internal note was added',\n      owner: payload.owner || req.user._id\n    }\n    ticket.history.push(HistoryItem)\n\n    ticket.save(function (err, savedTicket) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      ticketModel.populate(savedTicket, 'subscribers notes.owner history.owner', function (err, savedTicket) {\n        if (err) return res.json({ success: true, ticket: savedTicket })\n\n        emitter.emit('ticket:note:added', savedTicket, Note)\n\n        return res.json({ success: true, ticket: savedTicket })\n      })\n    })\n  })\n}\n\n/**\n * @api {get} /api/v1/tickets/types Get Ticket Types\n * @apiName getTicketTypes\n * @apiDescription Gets all available ticket types.\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/types\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTypes = function (req, res) {\n  var ticketType = require('../../../models/tickettype')\n  ticketType.getTypes(function (err, types) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n    return res.json(types)\n  })\n}\n\napiTickets.getType = function (req, res) {\n  var id = req.params.id\n  if (!id) return res.status(400).json({ success: false, error: 'Invalid Type ID' })\n\n  var ticketType = require('../../../models/tickettype')\n  ticketType.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Type ID' })\n\n    return res.json({ success: true, type: type })\n  })\n}\n\n/**\n * @api {post} /api/v1/tickets/types/create Create Ticket Type\n * @apiName createType\n * @apiDescription Creates a new ticket type\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X POST\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"name\\\": \\\"TypeName\\\"}\"\n *      -l http://localhost/api/v1/tickets/types/create\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {Object} tickettype Returns the newly create ticket type\n *\n */\napiTickets.createType = function (req, res) {\n  var typeName = req.body.name\n  var ticketTypeSchema = require('../../../models/tickettype')\n  var ticketPrioritiesSchema = require('../../../models/ticketpriority')\n\n  if (_.isUndefined(typeName) || typeName.length < 3)\n    return res.status(400).json({ success: false, error: 'Invalid Type Name!' })\n\n  ticketPrioritiesSchema.find({ default: true }, function (err, priorities) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n    priorities = _.sortBy(priorities, 'migrationNum')\n\n    ticketTypeSchema.create({ name: typeName, priorities: priorities }, function (err, ticketType) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, tickettype: ticketType })\n    })\n  })\n}\n\n/**\n * @api {put} /api/v1/tickets/types/:id Update Ticket Type\n * @apiName updateType\n * @apiDescription Updates given ticket type\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X PUT -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/types/:id\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {object} tag Updated Ticket Type\n *\n */\napiTickets.updateType = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n\n  if (_.isUndefined(id) || _.isNull(id) || _.isNull(data) || _.isUndefined(data)) {\n    return res.status(400).json({ success: false, error: 'Invalid Put Data' })\n  }\n\n  ticketTypeSchema.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    type.name = data.name\n\n    type.save(function (err, t) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, type: t })\n    })\n  })\n}\n\napiTickets.typeAddPriority = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n\n  if (!id || !data || !data.priority) {\n    return res.status(400).json({ success: false, error: 'Invalid request data' })\n  }\n\n  ticketTypeSchema.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    type.addPriority(data.priority, function (err, type) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      type.save(function (err, t) {\n        if (err) return res.status(400).json({ success: false, error: err.message })\n\n        t.populate('priorities', function (err, tt) {\n          if (err) return res.status(400).json({ success: false, error: err.message })\n\n          return res.json({ success: true, type: tt })\n        })\n      })\n    })\n  })\n}\n\napiTickets.typeRemovePriority = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n\n  if (!id || !data || !data.priority) {\n    return res.status(400).json({ success: false, error: 'Invalid request data' })\n  }\n\n  ticketTypeSchema.getType(id, function (err, type) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    type.removePriority(data.priority, function (err, type) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      type.save(function (err, t) {\n        if (err) return res.status(400).json({ success: false, error: err.message })\n\n        t.populate('priorities', function (err, tt) {\n          if (err) return res.status(400).json({ success: false, error: err.message })\n\n          return res.json({ success: true, type: tt })\n        })\n      })\n    })\n  })\n}\n\n/**\n * @api {delete} /api/v1/tickets/types/:id Delete Ticket Type\n * @apiName deleteType\n * @apiDescription Deletes given ticket type\n * @apiVersion 0.1.10\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X DELETE\n *      -H \"accesstoken: {accesstoken}\"\n *      -d \"{\\\"newTypeId\\\": \\\"{ObjectId}\\\"}\"\n *      -l http://localhost/api/v1/tickets/types/:id\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {number} updated Count of Tickets updated to new type\n *\n */\napiTickets.deleteType = function (req, res) {\n  var newTypeId = req.body.newTypeId\n  var delTypeId = req.params.id\n\n  if (_.isUndefined(newTypeId) || _.isUndefined(delTypeId)) {\n    return res.status(400).json({ success: false, error: 'Invalid POST data.' })\n  }\n\n  var ticketTypeSchema = require('../../../models/tickettype')\n  var ticketSchema = require('../../../models/ticket')\n  var settingsSchema = require('../../../models/setting')\n\n  async.waterfall(\n    [\n      function (next) {\n        settingsSchema.getSettingByName('mailer:check:ticketype', function (err, setting) {\n          if (err) return next(err)\n          if (setting && setting.value.toString().toLowerCase() === delTypeId.toString().toLowerCase()) {\n            return next({\n              custom: true,\n              message: 'Type currently \"Default Ticket Type\" for mailer check.'\n            })\n          }\n\n          return next(null)\n        })\n      },\n      function (next) {\n        ticketSchema.updateType(delTypeId, newTypeId, next)\n      },\n      function (result, next) {\n        ticketTypeSchema.getType(delTypeId, function (err, type) {\n          if (err) return next(err)\n\n          type.remove(function (err) {\n            if (err) return next(err)\n            return next(null, result)\n          })\n        })\n      }\n    ],\n    function (err, result) {\n      if (err) return res.status(400).json({ success: false, error: err })\n      return res.json({ success: true, updated: result.nModified })\n    }\n  )\n}\n\napiTickets.createPriority = function (req, res) {\n  var data = req.body\n\n  var pName = data.name\n\n  var pOverdueIn = data.overdueIn\n\n  var pHtmlColor = data.htmlColor\n\n  if (!pName) {\n    return res.status(400).json({ success: false, error: 'Invalid Request Data.' })\n  }\n\n  var TicketPrioritySchema = require('../../../models/ticketpriority')\n\n  var P = new TicketPrioritySchema({\n    name: pName,\n    overdueIn: pOverdueIn,\n    htmlColor: pHtmlColor\n  })\n\n  P.save(function (err, savedPriority) {\n    if (err) {\n      return res.status(400).json({ success: false, error: err.message })\n    }\n\n    return res.json({ success: true, priority: savedPriority })\n  })\n}\n\napiTickets.getPriorities = function (req, res) {\n  var ticketPrioritySchema = require('../../../models/ticketpriority')\n  ticketPrioritySchema.find({}, function (err, priorities) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    priorities = _.sortBy(priorities, ['migrationNum', 'name'])\n\n    return res.json({ success: true, priorities: priorities })\n  })\n}\n\napiTickets.updatePriority = function (req, res) {\n  var id = req.params.id\n\n  var data = req.body\n\n  if (_.isUndefined(id) || _.isNull(id) || _.isNull(data) || _.isUndefined(data)) {\n    return res.status(400).json({ success: false, error: 'Invalid Request Data' })\n  }\n\n  var ticketPrioritySchema = require('../../../models/ticketpriority')\n  ticketPrioritySchema.findOne({ _id: id }, function (err, priority) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (data.name) {\n      priority.name = data.name\n    }\n    if (data.htmlColor) {\n      priority.htmlColor = data.htmlColor\n    }\n    if (data.overdueIn) {\n      priority.overdueIn = data.overdueIn\n    }\n\n    priority.save(function (err, p) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, priority: p })\n    })\n  })\n}\n\napiTickets.deletePriority = function (req, res) {\n  var id = req.params.id\n\n  var newPriority = req.body.newPriority\n\n  if (!id || !newPriority) {\n    return res.status(400).json({ success: false, error: 'Invalid Request Data' })\n  }\n\n  async.series(\n    [\n      function (next) {\n        var ticketSchema = require('../../../models/ticket')\n        ticketSchema.updateMany({ priority: id }, { priority: newPriority }, next)\n      },\n      function (next) {\n        var ticketPrioritySchema = require('../../../models/ticketpriority')\n        ticketPrioritySchema.findOne({ _id: id }, function (err, priority) {\n          if (err) return next(err)\n\n          if (priority.default) {\n            return next('Unable to delete default priority: ' + priority.name)\n          }\n\n          priority.remove(next)\n        })\n      }\n    ],\n    function (err) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/stats Get Ticket Stats\n * @apiName getTicketStats\n * @apiDescription Gets cached ticket stats\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/stats\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTicketStats = function (req, res) {\n  var timespan = 30\n  if (req.params.timespan) {\n    timespan = parseInt(req.params.timespan)\n  }\n\n  var cache = global.cache\n\n  if (_.isUndefined(cache)) {\n    return res.status(400).send('Ticket stats are still loading...')\n  }\n\n  var obj = {}\n\n  switch (timespan) {\n    case 30:\n      obj.data = cache.get('tickets:overview:e30:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e30:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e30:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e30:responseTime')\n      break\n    case 60:\n      obj.data = cache.get('tickets:overview:e60:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e60:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e60:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e60:responseTime')\n      break\n    case 90:\n      obj.data = cache.get('tickets:overview:e90:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e90:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e90:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e90:responseTime')\n      break\n    case 180:\n      obj.data = cache.get('tickets:overview:e180:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e180:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e180:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e180:responseTime')\n      break\n    case 365:\n      obj.data = cache.get('tickets:overview:e365:graphData')\n      obj.ticketCount = cache.get('tickets:overview:e365:ticketCount')\n      obj.closedCount = cache.get('tickets:overview:e365:closedTickets')\n      obj.ticketAvg = cache.get('tickets:overview:e365:responseTime')\n      break\n    // case 0:\n    //     obj.data = cache.get('tickets:overview:lifetime:graphData');\n    //     obj.ticketCount = cache.get('tickets:overview:lifetime:ticketCount');\n    //     obj.closedCount = cache.get('tickets:overview:lifetime:closedTickets');\n    //     obj.ticketAvg = cache.get('tickets:overview:lifetime:responseTime');\n    //     break;\n  }\n\n  obj.mostRequester = cache.get('quickstats:mostRequester')\n  obj.mostCommenter = cache.get('quickstats:mostCommenter')\n  obj.mostAssignee = cache.get('quickstats:mostAssignee')\n  obj.mostActiveTicket = cache.get('quickstats:mostActiveTicket')\n\n  obj.lastUpdated = cache.get('tickets:overview:lastUpdated')\n  var settingsUtil = require('../../../settings/settingsUtil')\n  settingsUtil.getSettings(function (err, context) {\n    if (err) {\n      return res.send(obj)\n    }\n\n    var tz = context.data.settings.timezone.value\n    obj.lastUpdated = moment\n      .utc(obj.lastUpdated)\n      .tz(tz)\n      .format('MM-DD-YYYY hh:mm:ssa')\n\n    return res.send(obj)\n  })\n  // return res.send(obj);\n}\n\nfunction parseTicketStats (role, tickets, callback) {\n  if (_.isEmpty(tickets)) return callback({ tickets: tickets, tags: {} })\n  var t = []\n  var tags = {}\n  if (!permissions.canThis(role, 'tickets:notes')) {\n    _.each(tickets, function (ticket) {\n      ticket.notes = []\n    })\n  }\n\n  async.each(\n    tickets,\n    function (ticket, cb) {\n      _.each(ticket.tags, function (tag) {\n        t.push(tag.name)\n      })\n\n      t = _.take(t, 10)\n\n      return cb()\n    },\n    function () {\n      _.mixin({\n        sortKeysBy: function (obj, comparator) {\n          var keys = _.sortBy(_.keys(obj), function (key) {\n            return comparator ? comparator(obj[key], key) : key\n          })\n\n          return _.zipObject(\n            keys,\n            _.map(keys, function (key) {\n              return obj[key]\n            })\n          )\n        }\n      })\n\n      tags = _.countBy(t, function (k) {\n        return k\n      })\n      tags = _(tags)\n        .toPairs()\n        .sortBy(0)\n        .fromPairs()\n        .value()\n\n      return callback({ tickets: tickets, tags: tags })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/stats/group/:group Get Ticket Stats For Group\n * @apiName getTicketStatsForGroup\n * @apiDescription Gets live ticket stats for given groupId\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/stats/group/{groupid}\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTicketStatsForGroup = function (req, res) {\n  var groupId = req.params.group\n  if (groupId === 0) return res.status(200).json({ success: false, error: 'Please Select Group.' })\n  if (_.isUndefined(groupId)) return res.status(400).json({ success: false, error: 'Invalid Group Id.' })\n\n  var ticketModel = require('../../../models/ticket')\n  var data = {}\n  var tags = {}\n  async.waterfall(\n    [\n      function (callback) {\n        var obj = { limit: 10000, page: 0 }\n        ticketModel.getTicketsWithObject([groupId], obj, function (err, tickets) {\n          if (err) return callback(err)\n          parseTicketStats(req.user.role, tickets, function (data) {\n            tags = data.tags\n\n            return callback(null, tickets)\n          })\n        })\n      },\n      function (tickets, callback) {\n        if (_.isEmpty(tickets)) return callback('Group has no tickets to report.')\n        var today = moment()\n          .hour(23)\n          .minute(59)\n          .second(59)\n        var r = {}\n        r.ticketCount = _.size(tickets)\n        tickets = _.sortBy(tickets, 'date')\n        r.recentTickets = _.takeRight(tickets, 5)\n        r.closedTickets = _.filter(tickets, function (v) {\n          return v.status === 3\n        })\n\n        var firstDate = moment(_.first(tickets).date).subtract(30, 'd')\n        var diffDays = today.diff(firstDate, 'days')\n\n        buildGraphData(tickets, diffDays, function (graphData) {\n          r.graphData = graphData\n\n          // Get average Response\n          buildAvgResponse(tickets, function (obj) {\n            if (_.isUndefined(obj)) {\n              return callback(null, r)\n            }\n\n            r.avgResponse = obj.avgResponse\n\n            return callback(null, r)\n          })\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.status(400).json({ success: false, error: err })\n\n      data.ticketCount = results.ticketCount\n      data.recentTickets = results.recentTickets\n      data.closedCount = _.size(results.closedTickets)\n      data.graphData = results.graphData\n      data.avgResponse = results.avgResponse\n      data.tags = tags\n\n      return res.json({ success: true, data: data })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/stats/user/:user Get Ticket Stats For User\n * @apiName getTicketStatsForUser\n * @apiDescription Gets live ticket stats for given userId\n * @apiVersion 0.1.9\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/stats/user/{userid}\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTicketStatsForUser = function (req, res) {\n  var userId = req.params.user\n  if (userId === 0) return res.status(200).json({ success: false, error: 'Please Select User.' })\n  if (_.isUndefined(userId)) return res.status(400).json({ success: false, error: 'Invalid User Id.' })\n\n  var ticketModel = require('../../../models/ticket')\n  var data = {}\n  var tags = {}\n  async.waterfall(\n    [\n      function (callback) {\n        ticketModel.getTicketsByRequester(userId, function (err, tickets) {\n          if (err) return callback(err)\n          parseTicketStats(req.user.role, tickets, function (data) {\n            tags = data.tags\n\n            return callback(null, tickets)\n          })\n        })\n      },\n      function (tickets, callback) {\n        if (_.isEmpty(tickets)) return callback('User has no tickets to report.')\n        var today = moment()\n          .hour(23)\n          .minute(59)\n          .second(59)\n        var r = {}\n        r.ticketCount = _.size(tickets)\n        tickets = _.sortBy(tickets, 'date')\n        r.recentTickets = _.takeRight(tickets, 5)\n        r.closedTickets = _.filter(tickets, function (v) {\n          return v.status === 3\n        })\n\n        var firstDate = moment(_.first(tickets).date).subtract(30, 'd')\n        var diffDays = today.diff(firstDate, 'days')\n\n        buildGraphData(tickets, diffDays, function (graphData) {\n          r.graphData = graphData\n\n          // Get average Response\n          buildAvgResponse(tickets, function (obj) {\n            if (_.isUndefined(obj)) {\n              return callback(null, r)\n            }\n\n            r.avgResponse = obj.avgResponse\n\n            return callback(null, r)\n          })\n        })\n      }\n    ],\n    function (err, results) {\n      if (err) return res.status(400).json({ success: false, error: err })\n\n      data.ticketCount = results.ticketCount\n      data.recentTickets = results.recentTickets\n      data.closedCount = _.size(results.closedTickets)\n      data.graphData = results.graphData\n      data.avgResponse = results.avgResponse\n      data.tags = tags\n\n      return res.json({ success: true, data: data })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/tickets/count/tags Get Tags Count\n * @apiName getTagCount\n * @apiDescription Gets cached count of all tags\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/count/tags\n *\n * @apiError InvalidRequest Invalid Post Data\n *\n */\napiTickets.getTagCount = function (req, res) {\n  var cache = global.cache\n  var timespan = req.params.timespan\n  if (_.isUndefined(timespan) || _.isNaN(timespan)) timespan = 0\n\n  if (_.isUndefined(cache)) {\n    return res.status(400).send('Tag stats are still loading...')\n  }\n\n  var tags = cache.get('tags:' + timespan + ':usage')\n\n  res.json({ success: true, tags: tags })\n}\n\n/**\n * @api {get} /api/v1/tickets/count/topgroups/:timespan/:topNum Top Groups Count\n * @apiName getTopTicketGroups\n * @apiDescription Gets the group with the top ticket count and timespan\n * @apiVersion 0.1.7\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/count/topgroups/30/10\n *\n * @apiSuccess {array} items Array with Group name and Count\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiTickets.getTopTicketGroups = function (req, res) {\n  var ticketModel = require('../../../models/ticket')\n  var top = req.params.top\n  var timespan = req.params.timespan\n\n  ticketModel.getTopTicketGroups(timespan, top, function (err, items) {\n    if (err) return res.status(400).json({ error: 'Invalid Request' })\n\n    return res.json({ items: items })\n  })\n}\n\n/**\n * @api {delete} /api/v1/tickets/:tid/attachments/remove/:aid Remove Attachment\n * @apiName removeAttachment\n * @apiDescription Remove Attachemtn with given Attachment ID from given Ticket ID\n * @apiVersion 0.1.0\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/:tid/attachments/remove/:aid\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {object} ticket Ticket Object\n *\n * @apiError InvalidRequest Invalid Request\n * @apiError InvalidPermissions Invalid Permissions\n */\napiTickets.removeAttachment = function (req, res) {\n  var ticketId = req.params.tid\n  var attachmentId = req.params.aid\n  if (_.isUndefined(ticketId) || _.isUndefined(attachmentId))\n    return res.status(400).json({ error: 'Invalid Attachment' })\n\n  // Check user perm\n  var user = req.user\n  if (_.isUndefined(user)) return res.status(400).json({ error: 'Invalid User Auth.' })\n\n  var permissions = require('../../../permissions')\n  if (!permissions.canThis(user.role, 'tickets:removeAttachment'))\n    return res.status(401).json({ error: 'Invalid Permissions' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(ticketId, function (err, ticket) {\n    if (err) return res.status(400).send('Invalid Ticket Id')\n    ticket.getAttachment(attachmentId, function (a) {\n      ticket.removeAttachment(user._id, attachmentId, function (err, ticket) {\n        if (err) return res.status(400).json({ error: 'Invalid Request.' })\n\n        var fs = require('fs')\n        var path = require('path')\n        var dir = path.join(__dirname, '../../../../public', a.path)\n        if (fs.existsSync(dir)) fs.unlinkSync(dir)\n\n        ticket.save(function (err, t) {\n          if (err) return res.status(400).json({ error: 'Invalid Request.' })\n\n          res.json({ success: true, ticket: t })\n        })\n      })\n    })\n  })\n}\n\n/**\n * @api {put} /api/v1/tickets/:id/subscribe Subscribe/Unsubscribe\n * @apiName subscribeTicket\n * @apiDescription Subscribe/Unsubscribe user to the given ticket OID\n * @apiVersion 0.1.4\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"Content-Type: application/json\" -H \"accesstoken: {accesstoken}\" -X PUT -d \"{\\\"user\\\": {user},\\\"subscribe\\\": {boolean}}\" -l http://localhost/api/v1/tickets/{id}\n *\n * @apiParamExample {json} Request-Example:\n   {\n       \"user\": {user},\n       \"subscribe\": {boolean}\n   }\n *\n * @apiSuccess {boolean} success Successfully?\n *\n * @apiError InvalidPostData Invalid Post Data\n */\napiTickets.subscribe = function (req, res) {\n  var ticketId = req.params.id\n  var data = req.body\n  if (_.isUndefined(data.user) || _.isUndefined(data.subscribe))\n    return res.status(400).json({ error: 'Invalid Post Data.' })\n\n  if (data.user.toString() !== req.user._id.toString()) return res.status(401).json({ error: 'Unauthorized!' })\n\n  var ticketModel = require('../../../models/ticket')\n  ticketModel.getTicketById(ticketId, function (err, ticket) {\n    if (err) return res.status(400).json({ error: 'Invalid Ticket Id' })\n\n    async.series(\n      [\n        function (callback) {\n          require('../../../models/user').find({ _id: data.user }, function (err, user) {\n            if (err) return callback(err)\n\n            if (!user) return callback(new Error('Unauthorized!'))\n\n            return callback()\n          })\n        },\n        function (callback) {\n          if (data.subscribe) {\n            ticket.addSubscriber(data.user, function () {\n              callback()\n            })\n          } else {\n            ticket.removeSubscriber(data.user, function () {\n              callback()\n            })\n          }\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.status(401).json({ error: 'Unauthorized!' })\n        }\n\n        ticket.save(function (err, ticket) {\n          if (err) return res.status(400).json({ error: err })\n\n          emitter.emit('ticket:subscriber:update', ticket)\n\n          res.json({ success: true, ticket: ticket })\n        })\n      }\n    )\n  })\n}\n\n/**\n * @api {get} /api/v1/tickets/tags Get Ticket Tags\n * @apiName getTags\n * @apiDescription Gets all ticket tags\n * @apiVersion 0.1.6\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/tags\n *\n * @apiSuccess {boolean} success Successfully?\n * @apiSuccess {boolean} tags Array of Tags\n *\n */\napiTickets.getTags = function (req, res) {\n  var tagSchema = require('../../../models/tag')\n  tagSchema.getTags(function (err, tags) {\n    if (err) return res.status(400).json({ success: false, error: err })\n\n    _.each(tags, function (item) {\n      item.__v = undefined\n    })\n\n    res.json({ success: true, tags: tags })\n  })\n}\n\n/**\n * @api {get} /api/v1/tickets/overdue Get Overdue Tickets\n * @apiName getOverdue\n * @apiDescription Gets current overdue tickets\n * @apiVersion 0.1.9\n * @apiGroup Ticket\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/tickets/overdue\n *\n * @apiSuccess {boolean} success Successfully?\n *\n */\napiTickets.getOverdue = function (req, res) {\n  var settingSchema = require('../../../models/setting')\n  settingSchema.getSettingByName('showOverdueTickets:enable', function (err, setting) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (setting !== null && setting.value === false) {\n      return res.json({\n        success: true,\n        error: 'Show Overdue currently disabled.'\n      })\n    }\n\n    var ticketSchema = require('../../../models/ticket')\n    var departmentSchema = require('../../../models/department')\n    var groupSchema = require('../../../models/group')\n\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          } else {\n            return departmentSchema.getDepartmentGroupsOfUser(req.user._id, next)\n          }\n        },\n        function (groups, next) {\n          var groupIds = groups.map(function (g) {\n            return g._id\n          })\n\n          ticketSchema.getOverdue(groupIds, function (err, tickets) {\n            if (err) return next(err)\n\n            var sorted = _.sortBy(tickets, 'uid').reverse()\n\n            return next(null, sorted)\n          })\n        }\n      ],\n      function (err, overdueTickets) {\n        if (err) return res.status(400).json({ success: false, error: err.message })\n\n        return res.json({ success: true, tickets: overdueTickets })\n      }\n    )\n  })\n}\n\napiTickets.getDeletedTickets = function (req, res) {\n  var ticketSchema = require('../../../models/ticket')\n  ticketSchema.getDeleted(function (err, tickets) {\n    if (err) return res.status(500).json({ success: false, error: err })\n\n    return res.json({ success: true, count: tickets.length, deletedTickets: tickets })\n  })\n}\n\napiTickets.restoreDeleted = function (req, res) {\n  var postData = req.body\n  if (!postData || !postData._id) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  var ticketSchema = require('../../../models/ticket')\n  ticketSchema.restoreDeleted(postData._id, function (err) {\n    if (err) return res.status(500).json({ success: false, error: err })\n\n    return res.json({ success: true })\n  })\n}\n\nmodule.exports = apiTickets\n"], "filenames": ["src/controllers/api/v1/tickets.js"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [1850], "fixing_code_start_loc": [18], "fixing_code_end_loc": [1866], "type": "NVD-CWE-Other", "message": "Execution with Unnecessary Privileges in GitHub repository polonel/trudesk prior to 1.2.3.", "other": {"cve": {"id": "CVE-2022-1808", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-31T22:15:08.640", "lastModified": "2022-06-10T00:35:49.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Execution with Unnecessary Privileges in GitHub repository polonel/trudesk prior to 1.2.3."}, {"lang": "es", "value": "Una Ejecuci\u00f3n con Privilegios no Necesarios en el repositorio de GitHub polonel/trudesk versiones anteriores a 1.2.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-250"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.3", "matchCriteriaId": "D498F5B4-C37B-4226-A1FF-580B69B2AB0E"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/f739eac6fc52adc0cba83a49034100e5b99ac7c8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/9-polonel/trudesk", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/f739eac6fc52adc0cba83a49034100e5b99ac7c8"}}