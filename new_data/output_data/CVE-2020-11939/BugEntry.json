{"buggy_code": ["/*\n * ssh.c\n *\n * Copyright (C) 2009-2011 by ipoque GmbH\n * Copyright (C) 2011-20 - ntop.org\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_SSH\n\n#include \"ndpi_api.h\"\n#include \"ndpi_md5.h\"\n\n/*\n  HASSH - https://github.com/salesforce/hassh\n\n  https://github.com/salesforce/hassh/blob/master/python/hassh.py\n\n  [server]\n  skex = packet.ssh.kex_algorithms\n  seastc = packet.ssh.encryption_algorithms_server_to_client\n  smastc = packet.ssh.mac_algorithms_server_to_client\n  scastc = packet.ssh.compression_algorithms_server_to_client\n  hasshs_str = ';'.join([skex, seastc, smastc, scastc]) \n\n  [client]\n  ckex = packet.ssh.kex_algorithms\n  ceacts = packet.ssh.encryption_algorithms_client_to_server\n  cmacts = packet.ssh.mac_algorithms_client_to_server\n  ccacts = packet.ssh.compression_algorithms_client_to_server\n  hassh_str = ';'.join([ckex, ceacts, cmacts, ccacts]) \n\n  NOTE\n  THe ECDSA key fingerprint is SHA256 -> ssh.kex.h_sig (wireshark)\n  is in the Message Code: Diffie-Hellman Key Exchange Reply (31) \n  that usually is packet 14\n*/\n\n/* #define SSH_DEBUG 1 */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow);\n  \n/* ************************************************************************ */\n\nstatic int search_ssh_again(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  ndpi_search_ssh_tcp(ndpi_struct, flow);\n\n  if((flow->protos.ssh.hassh_client[0] != '\\0')\n     && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n    /* stop extra processing */\n    flow->extra_packets_func = NULL; /* We're good now */\n    return(0);\n  }\n\n  /* Possibly more processing */\n  return(1);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_int_ssh_add_connection(struct ndpi_detection_module_struct\n\t\t\t\t\t*ndpi_struct, struct ndpi_flow_struct *flow) {\n  if(flow->extra_packets_func != NULL)\n    return;\n\n  flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n  \n  /* This is necessary to inform the core to call this dissector again */\n  flow->check_extra_packets = 1;\n  flow->max_extra_packets_to_check = 12;\n  flow->extra_packets_func = search_ssh_again;\n  \n  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SSH, NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ************************************************************************ */\n\nstatic u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_ssh_zap_cr(char *str, int len) {\n  len--;\n\n  while(len > 0) {\n    if((str[len] == '\\n') || (str[len] == '\\r')) {\n      str[len] = '\\0';\n      len--;\n    } else\n      break;\n  }\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s()\\n\", __FUNCTION__);\n#endif\n\n  if(flow->l4.tcp.ssh_stage == 0) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 100\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.client_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.client_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.client_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.client_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [client_signature: %s]\\n\", flow->protos.ssh.client_signature);\n#endif      \n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 0 passed\\n\");\n      flow->l4.tcp.ssh_stage = 1 + packet->packet_direction;\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n      return;\n    }\n  } else if(flow->l4.tcp.ssh_stage == (2 - packet->packet_direction)) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 500\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.server_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.server_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.server_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.server_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [server_signature: %s]\\n\", flow->protos.ssh.server_signature);\n#endif\n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 1 passed\\n\");\n      flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [completed stage: %u]\\n\", flow->l4.tcp.ssh_stage);\n#endif\n\n      flow->l4.tcp.ssh_stage = 3;\n      return;\n    }\n  } else if(packet->payload_packet_len > 5) {\n    u_int8_t msgcode = *(packet->payload + 5);\n    ndpi_MD5_CTX ctx;\n    \n    if(msgcode == 20 /* key exchange init */) {\n      char *hassh_buf = ndpi_calloc(packet->payload_packet_len, sizeof(char));\n      u_int i, len;\n\n#ifdef SSH_DEBUG\n      printf(\"[SSH] [stage: %u][msg: %u][direction: %u][key exchange init]\\n\", flow->l4.tcp.ssh_stage, msgcode, packet->packet_direction);\n#endif\n\n      if(hassh_buf) {\n\tif(packet->packet_direction == 0 /* client */) {\n\t  u_char fingerprint_client[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 1 /* client */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_client, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [client][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_client[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_client[i*2], \"%02X\", fingerprint_client[i] & 0xFF);\n\t  flow->protos.ssh.hassh_client[32] = '\\0';\n\t} else {\n\t  u_char fingerprint_server[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 0 /* server */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_server, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [server][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_server[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_server[i*2], \"%02X\", fingerprint_server[i] & 0xFF);\n\t  flow->protos.ssh.hassh_server[32] = '\\0';\n\t}\n\n\tndpi_free(hassh_buf);\n      }\n\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n    }\n\n    if((flow->protos.ssh.hassh_client[0] != '\\0') && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n#ifdef SSH_DEBUG\n      printf(\"[SSH] Dissection completed\\n\");\n#endif\n      flow->extra_packets_func = NULL; /* We're good now */\n    }\n\n    return;\n  }\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Excluding SSH\");\n#endif\n\n  NDPI_LOG_DBG(ndpi_struct, \"excluding ssh at stage %d\\n\", flow->l4.tcp.ssh_stage);\n  NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_SSH);\n}\n\n/* ************************************************************************ */\n\nvoid init_ssh_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)\n{\n  ndpi_set_bitmask_protocol_detection(\"SSH\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_SSH,\n\t\t\t\t      ndpi_search_ssh_tcp,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "fixing_code": ["/*\n * ssh.c\n *\n * Copyright (C) 2009-2011 by ipoque GmbH\n * Copyright (C) 2011-20 - ntop.org\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_SSH\n\n#include \"ndpi_api.h\"\n#include \"ndpi_md5.h\"\n\n/*\n  HASSH - https://github.com/salesforce/hassh\n\n  https://github.com/salesforce/hassh/blob/master/python/hassh.py\n\n  [server]\n  skex = packet.ssh.kex_algorithms\n  seastc = packet.ssh.encryption_algorithms_server_to_client\n  smastc = packet.ssh.mac_algorithms_server_to_client\n  scastc = packet.ssh.compression_algorithms_server_to_client\n  hasshs_str = ';'.join([skex, seastc, smastc, scastc]) \n\n  [client]\n  ckex = packet.ssh.kex_algorithms\n  ceacts = packet.ssh.encryption_algorithms_client_to_server\n  cmacts = packet.ssh.mac_algorithms_client_to_server\n  ccacts = packet.ssh.compression_algorithms_client_to_server\n  hassh_str = ';'.join([ckex, ceacts, cmacts, ccacts]) \n\n  NOTE\n  THe ECDSA key fingerprint is SHA256 -> ssh.kex.h_sig (wireshark)\n  is in the Message Code: Diffie-Hellman Key Exchange Reply (31) \n  that usually is packet 14\n*/\n\n/* #define SSH_DEBUG 1 */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow);\n  \n/* ************************************************************************ */\n\nstatic int search_ssh_again(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  ndpi_search_ssh_tcp(ndpi_struct, flow);\n\n  if((flow->protos.ssh.hassh_client[0] != '\\0')\n     && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n    /* stop extra processing */\n    flow->extra_packets_func = NULL; /* We're good now */\n    return(0);\n  }\n\n  /* Possibly more processing */\n  return(1);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_int_ssh_add_connection(struct ndpi_detection_module_struct\n\t\t\t\t\t*ndpi_struct, struct ndpi_flow_struct *flow) {\n  if(flow->extra_packets_func != NULL)\n    return;\n\n  flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n  \n  /* This is necessary to inform the core to call this dissector again */\n  flow->check_extra_packets = 1;\n  flow->max_extra_packets_to_check = 12;\n  flow->extra_packets_func = search_ssh_again;\n  \n  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_SSH, NDPI_PROTOCOL_UNKNOWN);\n}\n\n/* ************************************************************************ */\n\nstatic u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int32_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  if (len > UINT32_MAX - 4 - offset)\n    goto invalid_payload;\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(!client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(!client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  offset += 4;\n  if(!client_hash) {\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n  }\n  if (len > UINT32_MAX - offset)\n    goto invalid_payload;\n  offset += len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_ssh_zap_cr(char *str, int len) {\n  len--;\n\n  while(len > 0) {\n    if((str[len] == '\\n') || (str[len] == '\\r')) {\n      str[len] = '\\0';\n      len--;\n    } else\n      break;\n  }\n}\n\n/* ************************************************************************ */\n\nstatic void ndpi_search_ssh_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s()\\n\", __FUNCTION__);\n#endif\n\n  if(flow->l4.tcp.ssh_stage == 0) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 100\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.client_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.client_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.client_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.client_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [client_signature: %s]\\n\", flow->protos.ssh.client_signature);\n#endif      \n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 0 passed\\n\");\n      flow->l4.tcp.ssh_stage = 1 + packet->packet_direction;\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n      return;\n    }\n  } else if(flow->l4.tcp.ssh_stage == (2 - packet->packet_direction)) {\n    if(packet->payload_packet_len > 7 && packet->payload_packet_len < 500\n\t&& memcmp(packet->payload, \"SSH-\", 4) == 0) {\n      int len = ndpi_min(sizeof(flow->protos.ssh.server_signature)-1, packet->payload_packet_len);\n      \n      strncpy(flow->protos.ssh.server_signature, (const char *)packet->payload, len);\n      flow->protos.ssh.server_signature[len] = '\\0';\n      ndpi_ssh_zap_cr(flow->protos.ssh.server_signature, len);\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [server_signature: %s]\\n\", flow->protos.ssh.server_signature);\n#endif\n      \n      NDPI_LOG_DBG2(ndpi_struct, \"ssh stage 1 passed\\n\");\n      flow->guessed_host_protocol_id = flow->guessed_protocol_id = NDPI_PROTOCOL_SSH;\n      \n#ifdef SSH_DEBUG\n      printf(\"[SSH] [completed stage: %u]\\n\", flow->l4.tcp.ssh_stage);\n#endif\n\n      flow->l4.tcp.ssh_stage = 3;\n      return;\n    }\n  } else if(packet->payload_packet_len > 5) {\n    u_int8_t msgcode = *(packet->payload + 5);\n    ndpi_MD5_CTX ctx;\n    \n    if(msgcode == 20 /* key exchange init */) {\n      char *hassh_buf = ndpi_calloc(packet->payload_packet_len, sizeof(char));\n      u_int i, len;\n\n#ifdef SSH_DEBUG\n      printf(\"[SSH] [stage: %u][msg: %u][direction: %u][key exchange init]\\n\", flow->l4.tcp.ssh_stage, msgcode, packet->packet_direction);\n#endif\n\n      if(hassh_buf) {\n\tif(packet->packet_direction == 0 /* client */) {\n\t  u_char fingerprint_client[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 1 /* client */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_client, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [client][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_client[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_client[i*2], \"%02X\", fingerprint_client[i] & 0xFF);\n\t  flow->protos.ssh.hassh_client[32] = '\\0';\n\t} else {\n\t  u_char fingerprint_server[16];\n\n\t  len = concat_hash_string(packet, hassh_buf, 0 /* server */);\n\n\t  ndpi_MD5Init(&ctx);\n\t  ndpi_MD5Update(&ctx, (const unsigned char *)hassh_buf, len);\n\t  ndpi_MD5Final(fingerprint_server, &ctx);\n\n#ifdef SSH_DEBUG\n\t  {\n\t    printf(\"[SSH] [server][%s][\", hassh_buf);\n\t    for(i=0; i<16; i++) printf(\"%02X\", fingerprint_server[i]);\n\t    printf(\"]\\n\");\n\t  }\n#endif\n\n\t  for(i=0; i<16; i++) sprintf(&flow->protos.ssh.hassh_server[i*2], \"%02X\", fingerprint_server[i] & 0xFF);\n\t  flow->protos.ssh.hassh_server[32] = '\\0';\n\t}\n\n\tndpi_free(hassh_buf);\n      }\n\n      ndpi_int_ssh_add_connection(ndpi_struct, flow);\n    }\n\n    if((flow->protos.ssh.hassh_client[0] != '\\0') && (flow->protos.ssh.hassh_server[0] != '\\0')) {\n#ifdef SSH_DEBUG\n      printf(\"[SSH] Dissection completed\\n\");\n#endif\n      flow->extra_packets_func = NULL; /* We're good now */\n    }\n\n    return;\n  }\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Excluding SSH\");\n#endif\n\n  NDPI_LOG_DBG(ndpi_struct, \"excluding ssh at stage %d\\n\", flow->l4.tcp.ssh_stage);\n  NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_SSH);\n}\n\n/* ************************************************************************ */\n\nvoid init_ssh_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)\n{\n  ndpi_set_bitmask_protocol_detection(\"SSH\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_SSH,\n\t\t\t\t      ndpi_search_ssh_tcp,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "filenames": ["src/lib/protocols/ssh.c"], "buggy_code_start_loc": [98], "buggy_code_end_loc": [224], "fixing_code_start_loc": [98], "fixing_code_end_loc": [226], "type": "CWE-190", "message": "In nDPI through 3.2 Stable, the SSH protocol dissector has multiple KEXINIT integer overflows that result in a controlled remote heap overflow in concat_hash_string in ssh.c. Due to the granular nature of the overflow primitive and the ability to control both the contents and layout of the nDPI library's heap memory through remote input, this vulnerability may be abused to achieve full Remote Code Execution against any network inspection stack that is linked against nDPI and uses it to perform network traffic analysis.", "other": {"cve": {"id": "CVE-2020-11939", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-23T15:15:14.093", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In nDPI through 3.2 Stable, the SSH protocol dissector has multiple KEXINIT integer overflows that result in a controlled remote heap overflow in concat_hash_string in ssh.c. Due to the granular nature of the overflow primitive and the ability to control both the contents and layout of the nDPI library's heap memory through remote input, this vulnerability may be abused to achieve full Remote Code Execution against any network inspection stack that is linked against nDPI and uses it to perform network traffic analysis."}, {"lang": "es", "value": "En nDPI versiones hasta 3.2 Stable, el disector del protocolo SSH  tiene m\u00faltiples desbordamientos de enteros KEXINIT que resultan en un desbordamiento de la pila (heap) remoto controlado en la funci\u00f3n concat_hash_string en el archivo ssh.c. Debido a la naturaleza granular de la primitiva de desbordamiento y la capacidad de controlar tanto el contenido como el dise\u00f1o de la memoria de la pila (heap) de la biblioteca de nDPI por medio de una entrada remota, se puede abusar de esta vulnerabilidad para lograr una Ejecuci\u00f3n de C\u00f3digo Remota completa contra cualquier pila de inspecci\u00f3n de red que est\u00e9 vinculada contra nDPI y lo usa para realizar an\u00e1lisis de tr\u00e1fico de red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ndpi:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2", "matchCriteriaId": "97EDB1C6-9886-4C0B-8F09-5A4C52DC5A45"}]}]}], "references": [{"url": "https://github.com/ntop/nDPI/commit/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2020-051_052-ntop-ndpi", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/nDPI/commit/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202"}}