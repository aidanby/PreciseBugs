{"buggy_code": ["/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport * as chai from \"chai\";\nimport { isAllowedWebsocketDomain } from \"./express-util\";\nconst expect = chai.expect;\n\ndescribe(\"express-util\", function () {\n    describe(\"isAllowedWebsocketDomain for dev-staging\", function () {\n        const HOSTURL_HOSTNAME = \"gpl-2732-ws-csrf.staging.gitpod.io\";\n        it(\"should return false for workspace-port locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://3000-moccasin-ferret-155799b3.ws-eu.gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return true for workspace locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://moccasin-ferret-155799b3.ws-eu.gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n            );\n            expect(result).to.be.true;\n        });\n\n        it(\"should return true for dashboard\", function () {\n            const result = isAllowedWebsocketDomain(\"http://gpl-2732-ws-csrf.staging.gitpod.io\", HOSTURL_HOSTNAME);\n            expect(result).to.be.true;\n        });\n    });\n    describe(\"isAllowedWebsocketDomain for gitpod.io\", function () {\n        const HOSTURL_HOSTNAME = \"gitpod.io\";\n        it(\"should return false for workspace-port locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"https://8000-black-capybara-dy6e3fgz.ws-eu08.gitpod.io\",\n                HOSTURL_HOSTNAME,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return true for workspace locations\", function () {\n            const result = isAllowedWebsocketDomain(\"https://bronze-bird-p2q226d8.ws-eu08.gitpod.io\", HOSTURL_HOSTNAME);\n            expect(result).to.be.true;\n        });\n    });\n});\n", "/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport { URL } from \"url\";\nimport * as express from \"express\";\nimport * as crypto from \"crypto\";\nimport { GitpodHostUrl } from \"@gitpod/gitpod-protocol/lib/util/gitpod-host-url\";\nimport * as session from \"express-session\";\n\nexport const query = (...tuples: [string, string][]) => {\n    if (tuples.length === 0) {\n        return \"\";\n    }\n    return \"?\" + tuples.map((t) => `${t[0]}=${encodeURIComponent(t[1])}`).join(\"&\");\n};\n\n// We do not precise UUID parsing here, we just want to distinguish three cases:\n//  - the base domain\n//  - a frontend domain (workspace domain)\n//  - a workspace port domain\n// We control all of those values and the base domain, so we don't need to much effort\nexport const isAllowedWebsocketDomain = (originHeader: any, gitpodHostName: string): boolean => {\n    if (!originHeader || typeof originHeader !== \"string\") {\n        return false;\n    }\n\n    var originHostname = \"\";\n    try {\n        const originUrl = new URL(originHeader);\n        originHostname = originUrl.hostname;\n        if (originHostname === gitpodHostName) {\n            return true;\n        }\n        if (looksLikeWorkspaceHostname(originUrl, gitpodHostName)) {\n            return true;\n        } else {\n            return false;\n        }\n    } catch (err) {\n        return false;\n    }\n};\n\nconst looksLikeWorkspaceHostname = (originHostname: URL, gitpodHostName: string): boolean => {\n    // Is prefix a valid (looking) workspace ID?\n    const found = originHostname.toString().lastIndexOf(gitpodHostName);\n    if (found === -1) {\n        return false;\n    }\n    const url = new GitpodHostUrl(originHostname);\n    const workspaceId = url.workspaceId;\n    if (workspaceId) {\n        const hostname = url.url.hostname as string;\n        if (hostname.startsWith(workspaceId)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport function saveSession(session: session.Session): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        session.save((err: any) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\nexport function destroySession(session: session.Session): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        session.destroy((error: any) => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For\n *\n * X-Forwarded-For: <client>, <proxy1>, <proxy2>\n *\n * @returns fingerprint which is a hash over (potential) client ip (or just proxy ip) and User Agent\n */\nexport function getRequestingClientInfo(req: express.Request) {\n    const ip = req.ips[0] || req.ip; // on PROD this should be a client IP address\n    const ua = req.get(\"user-agent\");\n    const fingerprint = crypto.createHash(\"sha256\").update(`${ip}\u2013${ua}`).digest(\"hex\");\n    return { ua, fingerprint };\n}\n\n/**\n * Catches exceptions from an async handler and puts them back into the express handler chain.\n * Assumes handlers take care of regular forwarding themselves.\n *\n * @param handler\n * @returns\n */\nexport function asyncHandler(\n    handler: (req: express.Request, res: express.Response, next: express.NextFunction) => Promise<void>,\n): express.Handler {\n    return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n        handler(req, res, next).catch((err) => next(err));\n    };\n}\n\n/**\n * Turns all unhandled requests into an error\n * @param req\n * @param res\n * @param next\n * @returns\n */\nexport function unhandledToError(req: express.Request, res: express.Response, next: express.NextFunction) {\n    if (isAnsweredRequest(req, res)) {\n        return next();\n    }\n    return next(new Error(\"unhandled request: \" + req.method + \" \" + req.originalUrl));\n}\n\n/**\n * Logs all errors, and responds unanswered requests.\n * @param log\n */\nexport function bottomErrorHandler(log: (...args: any[]) => void): express.ErrorRequestHandler {\n    return (err: any, req: express.Request, response: express.Response, next: express.NextFunction) => {\n        if (!err) {\n            return next();\n        }\n\n        let msg = \"undefined\";\n        let status = 500;\n        if (err instanceof Error) {\n            msg = err.toString() + \"\\nStack: \" + err.stack;\n            status = typeof (err as any).status === \"number\" ? (err as any).status : 500;\n        } else {\n            msg = err.toString();\n        }\n        log({ sessionId: req.sessionID }, err, {\n            originalUrl: req.originalUrl,\n            headers: req.headers,\n            cookies: req.cookies,\n            session: req.session,\n        });\n        if (!isAnsweredRequest(req, response)) {\n            response.status(status).send({ error: msg });\n        }\n    };\n}\n\nexport function isAnsweredRequest(req: express.Request, res: express.Response) {\n    return res.headersSent || req.originalUrl.endsWith(\".websocket\");\n}\n\nexport const takeFirst = (h: string | string[] | undefined): string | undefined => {\n    if (Array.isArray(h)) {\n        if (h.length < 1) {\n            return undefined;\n        }\n        return h[0];\n    }\n    return h;\n};\n", "/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport * as http from \"http\";\nimport * as express from \"express\";\nimport * as ws from \"ws\";\nimport * as bodyParser from \"body-parser\";\nimport * as cookieParser from \"cookie-parser\";\nimport { injectable, inject } from \"inversify\";\nimport * as prom from \"prom-client\";\nimport { SessionHandlerProvider } from \"./session-handler\";\nimport { Authenticator } from \"./auth/authenticator\";\nimport { UserController } from \"./user/user-controller\";\nimport { EventEmitter } from \"events\";\nimport { toIWebSocket } from \"@gitpod/gitpod-protocol/lib/messaging/node/connection\";\nimport { WsExpressHandler, WsRequestHandler } from \"./express/ws-handler\";\nimport { isAllowedWebsocketDomain, bottomErrorHandler, unhandledToError } from \"./express-util\";\nimport { createWebSocketConnection } from \"vscode-ws-jsonrpc/lib\";\nimport { MessageBusIntegration } from \"./workspace/messagebus-integration\";\nimport { log } from \"@gitpod/gitpod-protocol/lib/util/logging\";\nimport { EnforcementController } from \"./user/enforcement-endpoint\";\nimport { AddressInfo } from \"net\";\nimport { ConsensusLeaderQorum } from \"./consensus/consensus-leader-quorum\";\nimport { RabbitMQConsensusLeaderMessenger } from \"./consensus/rabbitmq-consensus-leader-messenger\";\nimport { WorkspaceGarbageCollector } from \"./workspace/garbage-collector\";\nimport { WorkspaceDownloadService } from \"./workspace/workspace-download-service\";\nimport { MonitoringEndpointsApp } from \"./monitoring-endpoints\";\nimport { WebsocketConnectionManager } from \"./websocket/websocket-connection-manager\";\nimport { PeriodicDbDeleter, TypeORM } from \"@gitpod/gitpod-db/lib\";\nimport { OneTimeSecretServer } from \"./one-time-secret-server\";\nimport { Disposable, DisposableCollection, GitpodClient, GitpodServer } from \"@gitpod/gitpod-protocol\";\nimport { BearerAuth, isBearerAuthError } from \"./auth/bearer-authenticator\";\nimport { HostContextProvider } from \"./auth/host-context-provider\";\nimport { CodeSyncService } from \"./code-sync/code-sync-service\";\nimport { increaseHttpRequestCounter, observeHttpRequestDuration, setGitpodVersion } from \"./prometheus-metrics\";\nimport { OAuthController } from \"./oauth-server/oauth-controller\";\nimport {\n    HeadlessLogController,\n    HEADLESS_LOGS_PATH_PREFIX,\n    HEADLESS_LOG_DOWNLOAD_PATH_PREFIX,\n} from \"./workspace/headless-log-controller\";\nimport { NewsletterSubscriptionController } from \"./user/newsletter-subscription-controller\";\nimport { Config } from \"./config\";\nimport { DebugApp } from \"@gitpod/gitpod-protocol/lib/util/debug-app\";\nimport { LocalMessageBroker } from \"./messaging/local-message-broker\";\nimport { WsConnectionHandler } from \"./express/ws-connection-handler\";\nimport { InstallationAdminController } from \"./installation-admin/installation-admin-controller\";\nimport { WebhookEventGarbageCollector } from \"./projects/webhook-event-garbage-collector\";\nimport { LivenessController } from \"./liveness/liveness-controller\";\n\n@injectable()\nexport class Server<C extends GitpodClient, S extends GitpodServer> {\n    static readonly EVENT_ON_START = \"start\";\n\n    @inject(Config) protected readonly config: Config;\n    @inject(TypeORM) protected readonly typeOrm: TypeORM;\n    @inject(SessionHandlerProvider) protected sessionHandlerProvider: SessionHandlerProvider;\n    @inject(Authenticator) protected authenticator: Authenticator;\n    @inject(UserController) protected readonly userController: UserController;\n    @inject(InstallationAdminController) protected readonly installationAdminController: InstallationAdminController;\n    @inject(EnforcementController) protected readonly enforcementController: EnforcementController;\n    @inject(WebsocketConnectionManager) protected websocketConnectionHandler: WebsocketConnectionManager;\n    @inject(MessageBusIntegration) protected readonly messagebus: MessageBusIntegration;\n    @inject(LocalMessageBroker) protected readonly localMessageBroker: LocalMessageBroker;\n    @inject(WorkspaceDownloadService) protected readonly workspaceDownloadService: WorkspaceDownloadService;\n    @inject(LivenessController) protected readonly livenessController: LivenessController;\n    @inject(MonitoringEndpointsApp) protected readonly monitoringEndpointsApp: MonitoringEndpointsApp;\n    @inject(CodeSyncService) private readonly codeSyncService: CodeSyncService;\n    @inject(HeadlessLogController) protected readonly headlessLogController: HeadlessLogController;\n    @inject(DebugApp) protected readonly debugApp: DebugApp;\n\n    @inject(RabbitMQConsensusLeaderMessenger) protected readonly consensusMessenger: RabbitMQConsensusLeaderMessenger;\n    @inject(ConsensusLeaderQorum) protected readonly qorum: ConsensusLeaderQorum;\n    @inject(WorkspaceGarbageCollector) protected readonly workspaceGC: WorkspaceGarbageCollector;\n    @inject(OneTimeSecretServer) protected readonly oneTimeSecretServer: OneTimeSecretServer;\n\n    @inject(PeriodicDbDeleter) protected readonly periodicDbDeleter: PeriodicDbDeleter;\n    @inject(WebhookEventGarbageCollector) protected readonly webhookEventGarbageCollector: WebhookEventGarbageCollector;\n\n    @inject(BearerAuth) protected readonly bearerAuth: BearerAuth;\n\n    @inject(HostContextProvider) protected readonly hostCtxProvider: HostContextProvider;\n    @inject(OAuthController) protected readonly oauthController: OAuthController;\n    @inject(NewsletterSubscriptionController)\n    protected readonly newsletterSubscriptionController: NewsletterSubscriptionController;\n\n    protected readonly eventEmitter = new EventEmitter();\n    protected app?: express.Application;\n    protected httpServer?: http.Server;\n    protected monitoringApp?: express.Application;\n    protected installationAdminApp?: express.Application;\n    protected monitoringHttpServer?: http.Server;\n    protected installationAdminHttpServer?: http.Server;\n    protected disposables = new DisposableCollection();\n\n    public async init(app: express.Application) {\n        log.setVersion(this.config.version);\n        log.info(\"server initializing...\");\n\n        // Set version info metric\n        setGitpodVersion(this.config.version);\n\n        // ensure DB connection is established to avoid noisy error messages\n        await this.typeOrm.connect();\n        log.info(\"connected to DB\");\n\n        // metrics\n        app.use((req: express.Request, res: express.Response, next: express.NextFunction) => {\n            const startTime = Date.now();\n            req.on(\"end\", () => {\n                const method = req.method;\n                const route = req.route?.path || req.baseUrl || \"unknown\";\n                observeHttpRequestDuration(method, route, res.statusCode, (Date.now() - startTime) / 1000);\n                increaseHttpRequestCounter(method, route, res.statusCode);\n            });\n\n            return next();\n        });\n\n        // Express configuration\n        // Read bodies as JSON (but keep the raw body just in case)\n        app.use(\n            bodyParser.json({\n                verify: (req, res, buffer) => {\n                    (req as any).rawBody = buffer;\n                },\n            }),\n        );\n        app.use(bodyParser.urlencoded({ extended: true }));\n        // Add cookie Parser\n        app.use(cookieParser());\n        app.set(\"trust proxy\", 1); // trust first proxy\n\n        // Install Sessionhandler\n        app.use(this.sessionHandlerProvider.sessionHandler);\n\n        // Install passport\n        await this.authenticator.init(app);\n\n        // Ensure that host contexts of dynamic auth providers are initialized.\n        await this.hostCtxProvider.init();\n\n        // Websocket for client connection\n        const websocketConnectionHandler = this.websocketConnectionHandler;\n        this.eventEmitter.on(Server.EVENT_ON_START, (httpServer) => {\n            // CSRF protection: check \"Origin\" header, it must be either:\n            //  - gitpod.io (hostUrl.hostname) or\n            //  - a workspace location (ending of hostUrl.hostname)\n            // We rely on the origin header being set correctly (needed by regular clients to use Gitpod:\n            // CORS allows subdomains to access gitpod.io)\n            const verifyCSRF = (origin: string) => {\n                let allowedRequest = isAllowedWebsocketDomain(origin, this.config.hostUrl.url.hostname);\n                if (!allowedRequest && this.config.insecureNoDomain) {\n                    log.warn(\"Websocket connection CSRF guard disabled\");\n                    allowedRequest = true;\n                }\n                return allowedRequest;\n            };\n\n            /**\n             * Verify the web socket handshake request.\n             */\n            const verifyClient: ws.VerifyClientCallbackAsync = async (info, callback) => {\n                if (!verifyCSRF(info.origin)) {\n                    log.warn(\"Websocket connection attempt with non-matching Origin header: \" + info.origin);\n                    return callback(false, 403);\n                }\n                if (info.req.url === \"/v1\") {\n                    try {\n                        await this.bearerAuth.auth(info.req as express.Request);\n                    } catch (e) {\n                        if (isBearerAuthError(e)) {\n                            return callback(false, 401, e.message);\n                        }\n                        log.warn(\"authentication failed: \", e);\n                        return callback(false, 500);\n                    }\n                }\n                return callback(true);\n            };\n\n            // Materialize session into req.session\n            const handleSession: WsRequestHandler = (ws, req, next) => {\n                // The fake response needs to be create in a per-request context to avoid memory leaks\n                this.sessionHandlerProvider.sessionHandler(req, {} as express.Response, next);\n            };\n\n            // Materialize user into req.user\n            const initSessionHandlers = this.authenticator.initHandlers.map<WsRequestHandler>(\n                (handler) => (ws, req, next) => {\n                    // The fake response needs to be create in a per-request context to avoid memory leaks\n                    handler(req, {} as express.Response, next);\n                },\n            );\n\n            const wsPingPongHandler = new WsConnectionHandler();\n            const wsHandler = new WsExpressHandler(httpServer, verifyClient);\n            wsHandler.ws(\n                websocketConnectionHandler.path,\n                (ws, request) => {\n                    const websocket = toIWebSocket(ws);\n                    (request as any).wsConnection = createWebSocketConnection(websocket, console);\n                },\n                handleSession,\n                ...initSessionHandlers,\n                wsPingPongHandler.handler(),\n                (ws: ws, req: express.Request) => {\n                    websocketConnectionHandler.onConnection((req as any).wsConnection, req);\n                },\n            );\n            wsHandler.ws(\n                \"/v1\",\n                (ws, request) => {\n                    const websocket = toIWebSocket(ws);\n                    (request as any).wsConnection = createWebSocketConnection(websocket, console);\n                },\n                wsPingPongHandler.handler(),\n                (ws: ws, req: express.Request) => {\n                    websocketConnectionHandler.onConnection((req as any).wsConnection, req);\n                },\n            );\n            wsHandler.ws(/.*/, (ws, request) => {\n                // fallthrough case\n                // note: this is suboptimal as we upgrade and than terminate the request. But we're not sure this is a problem at all, so we start out with this\n                log.warn(\"websocket path not matching\", { path: request.path });\n                ws.terminate();\n            });\n\n            // start ws heartbeat/ping-pong\n            wsPingPongHandler.start();\n            this.disposables.push(wsPingPongHandler);\n        });\n\n        // register routers\n        await this.registerRoutes(app);\n\n        // Turn unhandled requests into errors\n        app.use(unhandledToError);\n\n        // Generic error handler\n        app.use(bottomErrorHandler(log.debug));\n\n        // Health check + metrics endpoints\n        this.monitoringApp = this.monitoringEndpointsApp.create();\n\n        // Installation Admin - host separately to avoid exposing publicly\n        this.installationAdminApp = this.installationAdminController.create();\n\n        // Report current websocket connections\n        this.installWebsocketConnectionGauge();\n        this.installWebsocketClientContextGauge();\n\n        // Connect to message bus\n        await this.messagebus.connect();\n\n        // Start local message broker\n        await this.localMessageBroker.start();\n        this.disposables.push(Disposable.create(() => this.localMessageBroker.stop().catch(log.error)));\n\n        // Start concensus quorum\n        await this.consensusMessenger.connect();\n        await this.qorum.start();\n\n        // Start workspace garbage collector\n        this.workspaceGC.start().catch((err) => log.error(\"wsgc: error during startup\", err));\n\n        // Start one-time secret GC\n        this.oneTimeSecretServer.startPruningExpiredSecrets();\n\n        // Start DB updater\n        this.startDbDeleter().catch((err) => log.error(\"starting DB deleter\", err));\n\n        // Start WebhookEvent GC\n        this.webhookEventGarbageCollector\n            .start()\n            .catch((err) => log.error(\"webhook-event-gc: error during startup\", err));\n\n        this.app = app;\n        log.info(\"server initialized.\");\n    }\n\n    protected async startDbDeleter() {\n        if (!this.config.runDbDeleter) {\n            return;\n        }\n        const areWeLeader = await this.qorum.areWeLeader();\n        if (areWeLeader) {\n            this.periodicDbDeleter.start();\n        }\n    }\n\n    protected async registerRoutes(app: express.Application) {\n        app.use(this.userController.apiRouter);\n        app.use(this.oneTimeSecretServer.apiRouter);\n        app.use(\"/enforcement\", this.enforcementController.apiRouter);\n        app.use(\"/workspace-download\", this.workspaceDownloadService.apiRouter);\n        app.use(\"/code-sync\", this.codeSyncService.apiRouter);\n        app.use(HEADLESS_LOGS_PATH_PREFIX, this.headlessLogController.headlessLogs);\n        app.use(HEADLESS_LOG_DOWNLOAD_PATH_PREFIX, this.headlessLogController.headlessLogDownload);\n        app.use(\"/live\", this.livenessController.apiRouter);\n        app.use(this.newsletterSubscriptionController.apiRouter);\n        app.use(\"/version\", (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            res.send(this.config.version);\n        });\n        app.use(this.oauthController.oauthRouter);\n    }\n\n    public async start(port: number) {\n        if (!this.app) {\n            throw new Error(\"server cannot start, not initialized\");\n        }\n\n        const httpServer = this.app.listen(port, () => {\n            this.eventEmitter.emit(Server.EVENT_ON_START, httpServer);\n            log.info(`server listening on port: ${(<AddressInfo>httpServer.address()).port}`);\n        });\n        this.httpServer = httpServer;\n\n        if (this.monitoringApp) {\n            this.monitoringHttpServer = this.monitoringApp.listen(9500, \"localhost\", () => {\n                log.info(\n                    `monitoring app listening on port: ${(<AddressInfo>this.monitoringHttpServer!.address()).port}`,\n                );\n            });\n        }\n\n        if (this.installationAdminApp) {\n            this.installationAdminHttpServer = this.installationAdminApp.listen(9000, () => {\n                log.info(\n                    `installation admin app listening on port: ${\n                        (<AddressInfo>this.installationAdminHttpServer!.address()).port\n                    }`,\n                );\n            });\n        }\n\n        this.debugApp.start();\n    }\n\n    public async stop() {\n        await this.debugApp.stop();\n        await this.stopServer(this.monitoringHttpServer);\n        await this.stopServer(this.installationAdminHttpServer);\n        await this.stopServer(this.httpServer);\n        this.disposables.dispose();\n        log.info(\"server stopped.\");\n    }\n\n    protected async stopServer(server?: http.Server): Promise<void> {\n        if (!server) {\n            return;\n        }\n        return new Promise((resolve) =>\n            server.close((err: any) => {\n                if (err) {\n                    log.warn(`error on server close.`, { err });\n                }\n                resolve();\n            }),\n        );\n    }\n\n    protected installWebsocketConnectionGauge() {\n        const gauge = new prom.Gauge({\n            name: `server_websocket_connection_count`,\n            help: \"Currently served websocket connections\",\n            labelNames: [\"clientType\"],\n        });\n        this.websocketConnectionHandler.onConnectionCreated((s, _) =>\n            gauge.inc({ clientType: s.clientMetadata.type || \"undefined\" }),\n        );\n        this.websocketConnectionHandler.onConnectionClosed((s, _) =>\n            gauge.dec({ clientType: s.clientMetadata.type || \"undefined\" }),\n        );\n    }\n\n    protected installWebsocketClientContextGauge() {\n        const gauge = new prom.Gauge({\n            name: `server_websocket_client_context_count`,\n            help: \"Currently served client contexts\",\n            labelNames: [\"authLevel\"],\n        });\n        this.websocketConnectionHandler.onClientContextCreated((ctx) =>\n            gauge.inc({ authLevel: ctx.clientMetadata.authLevel }),\n        );\n        this.websocketConnectionHandler.onClientContextClosed((ctx) =>\n            gauge.dec({ authLevel: ctx.clientMetadata.authLevel }),\n        );\n    }\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport * as chai from \"chai\";\nimport { isAllowedWebsocketDomain } from \"./express-util\";\nconst expect = chai.expect;\n\ndescribe(\"express-util\", function () {\n    describe(\"isAllowedWebsocketDomain for dev-staging\", function () {\n        const HOSTURL_HOSTNAME = \"gpl-2732-ws-csrf.staging.gitpod.io\";\n        it(\"should return false for workspace-port locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://3000-moccasin-ferret-155799b3.ws-eu.gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                false,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return true for workspace locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://moccasin-ferret-155799b3.ws-eu.gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                false,\n            );\n            expect(result).to.be.true;\n        });\n\n        it(\"should return true for dashboard\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                false,\n            );\n            expect(result).to.be.true;\n        });\n        it(\"should return false for workspace-port locations (strict)\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://3000-moccasin-ferret-155799b3.ws-eu.gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                true,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return true for workspace locations (strict)\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://moccasin-ferret-155799b3.ws-eu.gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                true,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return true for dashboard (strict)\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"http://gpl-2732-ws-csrf.staging.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                true,\n            );\n            expect(result).to.be.true;\n        });\n    });\n    describe(\"isAllowedWebsocketDomain for gitpod.io\", function () {\n        const HOSTURL_HOSTNAME = \"gitpod.io\";\n        it(\"should return false for workspace-port locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"https://8000-black-capybara-dy6e3fgz.ws-eu08.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                false,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return true for workspace locations\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"https://bronze-bird-p2q226d8.ws-eu08.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                false,\n            );\n            expect(result).to.be.true;\n        });\n        it(\"should return false for workspace-port locations (strict)\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"https://8000-black-capybara-dy6e3fgz.ws-eu08.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                true,\n            );\n            expect(result).to.be.false;\n        });\n\n        it(\"should return false for workspace locations (strict)\", function () {\n            const result = isAllowedWebsocketDomain(\n                \"https://bronze-bird-p2q226d8.ws-eu08.gitpod.io\",\n                HOSTURL_HOSTNAME,\n                true,\n            );\n            expect(result).to.be.true;\n        });\n    });\n});\n", "/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport { URL } from \"url\";\nimport * as express from \"express\";\nimport * as crypto from \"crypto\";\nimport * as session from \"express-session\";\nimport { log } from \"@gitpod/gitpod-protocol/lib/util/logging\";\nimport { GitpodHostUrl } from \"@gitpod/gitpod-protocol/lib/util/gitpod-host-url\";\n\nexport const query = (...tuples: [string, string][]) => {\n    if (tuples.length === 0) {\n        return \"\";\n    }\n    return \"?\" + tuples.map((t) => `${t[0]}=${encodeURIComponent(t[1])}`).join(\"&\");\n};\n\n// Strict: We only allow connections from the base domain, so disallow connections from all other Origins\n//      Only (current) exception: If no Origin header is set, skip the check!\n// Non-Strict: \"rely\" on subdomain parsing (do we still need this?)\nexport const isAllowedWebsocketDomain = (originHeader: string, gitpodHostName: string, strict: boolean): boolean => {\n    if (!originHeader || typeof originHeader !== \"string\") {\n        // TODO(gpl) Can we get rid of this dependency alltogether?\n        log.warn(\"Origin header check not applied because of empty Origin header!\");\n        return false;\n    }\n\n    try {\n        const originUrl = new URL(originHeader);\n        const originHostname = originUrl.hostname;\n        if (originHostname === gitpodHostName) {\n            return true;\n        }\n\n        if (strict) {\n            return false;\n        }\n        // TODO(gpl) This is only used for Bearer-Token authentication.\n        // Does this restriction help at all, or can we remove it entirely?\n        log.warn(\"Origin header check based on looksLikeWorkspaceHostname\");\n        if (looksLikeWorkspaceHostname(originUrl, gitpodHostName)) {\n            return true;\n        } else {\n            return false;\n        }\n    } catch (err) {\n        return false;\n    }\n};\n\nconst looksLikeWorkspaceHostname = (originHostname: URL, gitpodHostName: string): boolean => {\n    // Is prefix a valid (looking) workspace ID?\n    const found = originHostname.toString().lastIndexOf(gitpodHostName);\n    if (found === -1) {\n        return false;\n    }\n    const url = new GitpodHostUrl(originHostname);\n    const workspaceId = url.workspaceId;\n    if (workspaceId) {\n        const hostname = url.url.hostname as string;\n        if (hostname.startsWith(workspaceId)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport function saveSession(session: session.Session): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        session.save((err: any) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\nexport function destroySession(session: session.Session): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        session.destroy((error: any) => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For\n *\n * X-Forwarded-For: <client>, <proxy1>, <proxy2>\n *\n * @returns fingerprint which is a hash over (potential) client ip (or just proxy ip) and User Agent\n */\nexport function getRequestingClientInfo(req: express.Request) {\n    const ip = req.ips[0] || req.ip; // on PROD this should be a client IP address\n    const ua = req.get(\"user-agent\");\n    const fingerprint = crypto.createHash(\"sha256\").update(`${ip}\u2013${ua}`).digest(\"hex\");\n    return { ua, fingerprint };\n}\n\n/**\n * Catches exceptions from an async handler and puts them back into the express handler chain.\n * Assumes handlers take care of regular forwarding themselves.\n *\n * @param handler\n * @returns\n */\nexport function asyncHandler(\n    handler: (req: express.Request, res: express.Response, next: express.NextFunction) => Promise<void>,\n): express.Handler {\n    return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n        handler(req, res, next).catch((err) => next(err));\n    };\n}\n\n/**\n * Turns all unhandled requests into an error\n * @param req\n * @param res\n * @param next\n * @returns\n */\nexport function unhandledToError(req: express.Request, res: express.Response, next: express.NextFunction) {\n    if (isAnsweredRequest(req, res)) {\n        return next();\n    }\n    return next(new Error(\"unhandled request: \" + req.method + \" \" + req.originalUrl));\n}\n\n/**\n * Logs all errors, and responds unanswered requests.\n * @param log\n */\nexport function bottomErrorHandler(log: (...args: any[]) => void): express.ErrorRequestHandler {\n    return (err: any, req: express.Request, response: express.Response, next: express.NextFunction) => {\n        if (!err) {\n            return next();\n        }\n\n        let msg = \"undefined\";\n        let status = 500;\n        if (err instanceof Error) {\n            msg = err.toString() + \"\\nStack: \" + err.stack;\n            status = typeof (err as any).status === \"number\" ? (err as any).status : 500;\n        } else {\n            msg = err.toString();\n        }\n        log({ sessionId: req.sessionID }, err, {\n            originalUrl: req.originalUrl,\n            headers: req.headers,\n            cookies: req.cookies,\n            session: req.session,\n        });\n        if (!isAnsweredRequest(req, response)) {\n            response.status(status).send({ error: msg });\n        }\n    };\n}\n\nexport function isAnsweredRequest(req: express.Request, res: express.Response) {\n    return res.headersSent || req.originalUrl.endsWith(\".websocket\");\n}\n\nexport const takeFirst = (h: string | string[] | undefined): string | undefined => {\n    if (Array.isArray(h)) {\n        if (h.length < 1) {\n            return undefined;\n        }\n        return h[0];\n    }\n    return h;\n};\n", "/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport * as http from \"http\";\nimport * as express from \"express\";\nimport * as ws from \"ws\";\nimport * as bodyParser from \"body-parser\";\nimport * as cookieParser from \"cookie-parser\";\nimport { injectable, inject } from \"inversify\";\nimport * as prom from \"prom-client\";\nimport { SessionHandlerProvider } from \"./session-handler\";\nimport { Authenticator } from \"./auth/authenticator\";\nimport { UserController } from \"./user/user-controller\";\nimport { EventEmitter } from \"events\";\nimport { toIWebSocket } from \"@gitpod/gitpod-protocol/lib/messaging/node/connection\";\nimport { WsExpressHandler, WsRequestHandler } from \"./express/ws-handler\";\nimport { isAllowedWebsocketDomain, bottomErrorHandler, unhandledToError } from \"./express-util\";\nimport { createWebSocketConnection } from \"vscode-ws-jsonrpc/lib\";\nimport { MessageBusIntegration } from \"./workspace/messagebus-integration\";\nimport { log } from \"@gitpod/gitpod-protocol/lib/util/logging\";\nimport { EnforcementController } from \"./user/enforcement-endpoint\";\nimport { AddressInfo } from \"net\";\nimport { ConsensusLeaderQorum } from \"./consensus/consensus-leader-quorum\";\nimport { RabbitMQConsensusLeaderMessenger } from \"./consensus/rabbitmq-consensus-leader-messenger\";\nimport { WorkspaceGarbageCollector } from \"./workspace/garbage-collector\";\nimport { WorkspaceDownloadService } from \"./workspace/workspace-download-service\";\nimport { MonitoringEndpointsApp } from \"./monitoring-endpoints\";\nimport { WebsocketConnectionManager } from \"./websocket/websocket-connection-manager\";\nimport { PeriodicDbDeleter, TypeORM } from \"@gitpod/gitpod-db/lib\";\nimport { OneTimeSecretServer } from \"./one-time-secret-server\";\nimport { Disposable, DisposableCollection, GitpodClient, GitpodServer } from \"@gitpod/gitpod-protocol\";\nimport { BearerAuth, isBearerAuthError } from \"./auth/bearer-authenticator\";\nimport { HostContextProvider } from \"./auth/host-context-provider\";\nimport { CodeSyncService } from \"./code-sync/code-sync-service\";\nimport { increaseHttpRequestCounter, observeHttpRequestDuration, setGitpodVersion } from \"./prometheus-metrics\";\nimport { OAuthController } from \"./oauth-server/oauth-controller\";\nimport {\n    HeadlessLogController,\n    HEADLESS_LOGS_PATH_PREFIX,\n    HEADLESS_LOG_DOWNLOAD_PATH_PREFIX,\n} from \"./workspace/headless-log-controller\";\nimport { NewsletterSubscriptionController } from \"./user/newsletter-subscription-controller\";\nimport { Config } from \"./config\";\nimport { DebugApp } from \"@gitpod/gitpod-protocol/lib/util/debug-app\";\nimport { LocalMessageBroker } from \"./messaging/local-message-broker\";\nimport { WsConnectionHandler } from \"./express/ws-connection-handler\";\nimport { InstallationAdminController } from \"./installation-admin/installation-admin-controller\";\nimport { WebhookEventGarbageCollector } from \"./projects/webhook-event-garbage-collector\";\nimport { LivenessController } from \"./liveness/liveness-controller\";\n\n@injectable()\nexport class Server<C extends GitpodClient, S extends GitpodServer> {\n    static readonly EVENT_ON_START = \"start\";\n\n    @inject(Config) protected readonly config: Config;\n    @inject(TypeORM) protected readonly typeOrm: TypeORM;\n    @inject(SessionHandlerProvider) protected sessionHandlerProvider: SessionHandlerProvider;\n    @inject(Authenticator) protected authenticator: Authenticator;\n    @inject(UserController) protected readonly userController: UserController;\n    @inject(InstallationAdminController) protected readonly installationAdminController: InstallationAdminController;\n    @inject(EnforcementController) protected readonly enforcementController: EnforcementController;\n    @inject(WebsocketConnectionManager) protected websocketConnectionHandler: WebsocketConnectionManager;\n    @inject(MessageBusIntegration) protected readonly messagebus: MessageBusIntegration;\n    @inject(LocalMessageBroker) protected readonly localMessageBroker: LocalMessageBroker;\n    @inject(WorkspaceDownloadService) protected readonly workspaceDownloadService: WorkspaceDownloadService;\n    @inject(LivenessController) protected readonly livenessController: LivenessController;\n    @inject(MonitoringEndpointsApp) protected readonly monitoringEndpointsApp: MonitoringEndpointsApp;\n    @inject(CodeSyncService) private readonly codeSyncService: CodeSyncService;\n    @inject(HeadlessLogController) protected readonly headlessLogController: HeadlessLogController;\n    @inject(DebugApp) protected readonly debugApp: DebugApp;\n\n    @inject(RabbitMQConsensusLeaderMessenger) protected readonly consensusMessenger: RabbitMQConsensusLeaderMessenger;\n    @inject(ConsensusLeaderQorum) protected readonly qorum: ConsensusLeaderQorum;\n    @inject(WorkspaceGarbageCollector) protected readonly workspaceGC: WorkspaceGarbageCollector;\n    @inject(OneTimeSecretServer) protected readonly oneTimeSecretServer: OneTimeSecretServer;\n\n    @inject(PeriodicDbDeleter) protected readonly periodicDbDeleter: PeriodicDbDeleter;\n    @inject(WebhookEventGarbageCollector) protected readonly webhookEventGarbageCollector: WebhookEventGarbageCollector;\n\n    @inject(BearerAuth) protected readonly bearerAuth: BearerAuth;\n\n    @inject(HostContextProvider) protected readonly hostCtxProvider: HostContextProvider;\n    @inject(OAuthController) protected readonly oauthController: OAuthController;\n    @inject(NewsletterSubscriptionController)\n    protected readonly newsletterSubscriptionController: NewsletterSubscriptionController;\n\n    protected readonly eventEmitter = new EventEmitter();\n    protected app?: express.Application;\n    protected httpServer?: http.Server;\n    protected monitoringApp?: express.Application;\n    protected installationAdminApp?: express.Application;\n    protected monitoringHttpServer?: http.Server;\n    protected installationAdminHttpServer?: http.Server;\n    protected disposables = new DisposableCollection();\n\n    public async init(app: express.Application) {\n        log.setVersion(this.config.version);\n        log.info(\"server initializing...\");\n\n        // Set version info metric\n        setGitpodVersion(this.config.version);\n\n        // ensure DB connection is established to avoid noisy error messages\n        await this.typeOrm.connect();\n        log.info(\"connected to DB\");\n\n        // metrics\n        app.use((req: express.Request, res: express.Response, next: express.NextFunction) => {\n            const startTime = Date.now();\n            req.on(\"end\", () => {\n                const method = req.method;\n                const route = req.route?.path || req.baseUrl || \"unknown\";\n                observeHttpRequestDuration(method, route, res.statusCode, (Date.now() - startTime) / 1000);\n                increaseHttpRequestCounter(method, route, res.statusCode);\n            });\n\n            return next();\n        });\n\n        // Express configuration\n        // Read bodies as JSON (but keep the raw body just in case)\n        app.use(\n            bodyParser.json({\n                verify: (req, res, buffer) => {\n                    (req as any).rawBody = buffer;\n                },\n            }),\n        );\n        app.use(bodyParser.urlencoded({ extended: true }));\n        // Add cookie Parser\n        app.use(cookieParser());\n        app.set(\"trust proxy\", 1); // trust first proxy\n\n        // Install Sessionhandler\n        app.use(this.sessionHandlerProvider.sessionHandler);\n\n        // Install passport\n        await this.authenticator.init(app);\n\n        // Ensure that host contexts of dynamic auth providers are initialized.\n        await this.hostCtxProvider.init();\n\n        // Websocket for client connection\n        const websocketConnectionHandler = this.websocketConnectionHandler;\n        this.eventEmitter.on(Server.EVENT_ON_START, (httpServer) => {\n            // CSRF protection: check \"Origin\" header:\n            //  - for cookie/session auth: MUST be gitpod.io (hostUrl.hostname)\n            //  - for Bearer auth: MUST be sth with the same base domain (*.gitpod.io) (is this required?)\n            //  - edge case: empty \"Origin\" is always permitted (can this be removed?)\n            // We rely on the origin header being set correctly (needed by regular clients to use Gitpod:\n            // CORS allows subdomains to access gitpod.io)\n            const verifyOrigin = (origin: string, strict: boolean) => {\n                let allowedRequest = isAllowedWebsocketDomain(origin, this.config.hostUrl.url.hostname, strict);\n                if (!allowedRequest && this.config.insecureNoDomain) {\n                    log.warn(\"Websocket connection CSRF guard disabled\");\n                    allowedRequest = true;\n                }\n                return allowedRequest;\n            };\n\n            /**\n             * Verify the web socket handshake request.\n             */\n            const verifyClient: ws.VerifyClientCallbackAsync = async (info, callback) => {\n                let authenticatedUsingBearerToken = false;\n                if (info.req.url === \"/v1\") {\n                    // Connection attempt with Bearer-Token: be less strict for now\n                    if (!verifyOrigin(info.origin, false)) {\n                        log.warn(\"Websocket connection attempt with non-matching Origin header: \" + info.origin);\n                        return callback(false, 403);\n                    }\n\n                    try {\n                        await this.bearerAuth.auth(info.req as express.Request);\n                        authenticatedUsingBearerToken = true;\n                    } catch (e) {\n                        if (isBearerAuthError(e)) {\n                            return callback(false, 401, e.message);\n                        }\n                        log.warn(\"authentication failed: \", e);\n                        return callback(false, 500);\n                    }\n                    // intentional fall-through to cookie/session based authentication\n                }\n\n                if (!authenticatedUsingBearerToken) {\n                    // Connection attempt with cookie/session based authentication: be strict about where we accept connections from!\n                    if (!verifyOrigin(info.origin, true)) {\n                        log.warn(\"Websocket connection attempt with non-matching Origin header: \" + info.origin);\n                        return callback(false, 403);\n                    }\n                }\n\n                return callback(true);\n            };\n\n            // Materialize session into req.session\n            const handleSession: WsRequestHandler = (ws, req, next) => {\n                // The fake response needs to be create in a per-request context to avoid memory leaks\n                this.sessionHandlerProvider.sessionHandler(req, {} as express.Response, next);\n            };\n\n            // Materialize user into req.user\n            const initSessionHandlers = this.authenticator.initHandlers.map<WsRequestHandler>(\n                (handler) => (ws, req, next) => {\n                    // The fake response needs to be create in a per-request context to avoid memory leaks\n                    handler(req, {} as express.Response, next);\n                },\n            );\n\n            const wsPingPongHandler = new WsConnectionHandler();\n            const wsHandler = new WsExpressHandler(httpServer, verifyClient);\n            wsHandler.ws(\n                websocketConnectionHandler.path,\n                (ws, request) => {\n                    const websocket = toIWebSocket(ws);\n                    (request as any).wsConnection = createWebSocketConnection(websocket, console);\n                },\n                handleSession,\n                ...initSessionHandlers,\n                wsPingPongHandler.handler(),\n                (ws: ws, req: express.Request) => {\n                    websocketConnectionHandler.onConnection((req as any).wsConnection, req);\n                },\n            );\n            wsHandler.ws(\n                \"/v1\",\n                (ws, request) => {\n                    const websocket = toIWebSocket(ws);\n                    (request as any).wsConnection = createWebSocketConnection(websocket, console);\n                },\n                wsPingPongHandler.handler(),\n                (ws: ws, req: express.Request) => {\n                    websocketConnectionHandler.onConnection((req as any).wsConnection, req);\n                },\n            );\n            wsHandler.ws(/.*/, (ws, request) => {\n                // fallthrough case\n                // note: this is suboptimal as we upgrade and than terminate the request. But we're not sure this is a problem at all, so we start out with this\n                log.warn(\"websocket path not matching\", { path: request.path });\n                ws.terminate();\n            });\n\n            // start ws heartbeat/ping-pong\n            wsPingPongHandler.start();\n            this.disposables.push(wsPingPongHandler);\n        });\n\n        // register routers\n        await this.registerRoutes(app);\n\n        // Turn unhandled requests into errors\n        app.use(unhandledToError);\n\n        // Generic error handler\n        app.use(bottomErrorHandler(log.debug));\n\n        // Health check + metrics endpoints\n        this.monitoringApp = this.monitoringEndpointsApp.create();\n\n        // Installation Admin - host separately to avoid exposing publicly\n        this.installationAdminApp = this.installationAdminController.create();\n\n        // Report current websocket connections\n        this.installWebsocketConnectionGauge();\n        this.installWebsocketClientContextGauge();\n\n        // Connect to message bus\n        await this.messagebus.connect();\n\n        // Start local message broker\n        await this.localMessageBroker.start();\n        this.disposables.push(Disposable.create(() => this.localMessageBroker.stop().catch(log.error)));\n\n        // Start concensus quorum\n        await this.consensusMessenger.connect();\n        await this.qorum.start();\n\n        // Start workspace garbage collector\n        this.workspaceGC.start().catch((err) => log.error(\"wsgc: error during startup\", err));\n\n        // Start one-time secret GC\n        this.oneTimeSecretServer.startPruningExpiredSecrets();\n\n        // Start DB updater\n        this.startDbDeleter().catch((err) => log.error(\"starting DB deleter\", err));\n\n        // Start WebhookEvent GC\n        this.webhookEventGarbageCollector\n            .start()\n            .catch((err) => log.error(\"webhook-event-gc: error during startup\", err));\n\n        this.app = app;\n        log.info(\"server initialized.\");\n    }\n\n    protected async startDbDeleter() {\n        if (!this.config.runDbDeleter) {\n            return;\n        }\n        const areWeLeader = await this.qorum.areWeLeader();\n        if (areWeLeader) {\n            this.periodicDbDeleter.start();\n        }\n    }\n\n    protected async registerRoutes(app: express.Application) {\n        app.use(this.userController.apiRouter);\n        app.use(this.oneTimeSecretServer.apiRouter);\n        app.use(\"/enforcement\", this.enforcementController.apiRouter);\n        app.use(\"/workspace-download\", this.workspaceDownloadService.apiRouter);\n        app.use(\"/code-sync\", this.codeSyncService.apiRouter);\n        app.use(HEADLESS_LOGS_PATH_PREFIX, this.headlessLogController.headlessLogs);\n        app.use(HEADLESS_LOG_DOWNLOAD_PATH_PREFIX, this.headlessLogController.headlessLogDownload);\n        app.use(\"/live\", this.livenessController.apiRouter);\n        app.use(this.newsletterSubscriptionController.apiRouter);\n        app.use(\"/version\", (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            res.send(this.config.version);\n        });\n        app.use(this.oauthController.oauthRouter);\n    }\n\n    public async start(port: number) {\n        if (!this.app) {\n            throw new Error(\"server cannot start, not initialized\");\n        }\n\n        const httpServer = this.app.listen(port, () => {\n            this.eventEmitter.emit(Server.EVENT_ON_START, httpServer);\n            log.info(`server listening on port: ${(<AddressInfo>httpServer.address()).port}`);\n        });\n        this.httpServer = httpServer;\n\n        if (this.monitoringApp) {\n            this.monitoringHttpServer = this.monitoringApp.listen(9500, \"localhost\", () => {\n                log.info(\n                    `monitoring app listening on port: ${(<AddressInfo>this.monitoringHttpServer!.address()).port}`,\n                );\n            });\n        }\n\n        if (this.installationAdminApp) {\n            this.installationAdminHttpServer = this.installationAdminApp.listen(9000, () => {\n                log.info(\n                    `installation admin app listening on port: ${\n                        (<AddressInfo>this.installationAdminHttpServer!.address()).port\n                    }`,\n                );\n            });\n        }\n\n        this.debugApp.start();\n    }\n\n    public async stop() {\n        await this.debugApp.stop();\n        await this.stopServer(this.monitoringHttpServer);\n        await this.stopServer(this.installationAdminHttpServer);\n        await this.stopServer(this.httpServer);\n        this.disposables.dispose();\n        log.info(\"server stopped.\");\n    }\n\n    protected async stopServer(server?: http.Server): Promise<void> {\n        if (!server) {\n            return;\n        }\n        return new Promise((resolve) =>\n            server.close((err: any) => {\n                if (err) {\n                    log.warn(`error on server close.`, { err });\n                }\n                resolve();\n            }),\n        );\n    }\n\n    protected installWebsocketConnectionGauge() {\n        const gauge = new prom.Gauge({\n            name: `server_websocket_connection_count`,\n            help: \"Currently served websocket connections\",\n            labelNames: [\"clientType\"],\n        });\n        this.websocketConnectionHandler.onConnectionCreated((s, _) =>\n            gauge.inc({ clientType: s.clientMetadata.type || \"undefined\" }),\n        );\n        this.websocketConnectionHandler.onConnectionClosed((s, _) =>\n            gauge.dec({ clientType: s.clientMetadata.type || \"undefined\" }),\n        );\n    }\n\n    protected installWebsocketClientContextGauge() {\n        const gauge = new prom.Gauge({\n            name: `server_websocket_client_context_count`,\n            help: \"Currently served client contexts\",\n            labelNames: [\"authLevel\"],\n        });\n        this.websocketConnectionHandler.onClientContextCreated((ctx) =>\n            gauge.inc({ authLevel: ctx.clientMetadata.authLevel }),\n        );\n        this.websocketConnectionHandler.onClientContextClosed((ctx) =>\n            gauge.dec({ authLevel: ctx.clientMetadata.authLevel }),\n        );\n    }\n}\n"], "filenames": ["components/server/src/express-util.spec.ts", "components/server/src/express-util.ts", "components/server/src/server.ts"], "buggy_code_start_loc": [17, 9, 149], "buggy_code_end_loc": [47, 36, 181], "fixing_code_start_loc": [18, 10, 149], "fixing_code_end_loc": [101, 44, 197], "type": "CWE-346", "message": "An issue was discovered in Gitpod versions prior to release-2022.11.2.16. There is a Cross-Site WebSocket Hijacking (CSWSH) vulnerability that allows attackers to make WebSocket connections to the Gitpod JSONRPC server using a victim\u2019s credentials, because the Origin header is not restricted. This can lead to the extraction of data from workspaces, to a full takeover of the workspace.", "other": {"cve": {"id": "CVE-2023-0957", "sourceIdentifier": "report@snyk.io", "published": "2023-03-03T08:15:08.613", "lastModified": "2023-03-10T19:04:18.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Gitpod versions prior to release-2022.11.2.16. There is a Cross-Site WebSocket Hijacking (CSWSH) vulnerability that allows attackers to make WebSocket connections to the Gitpod JSONRPC server using a victim\u2019s credentials, because the Origin header is not restricted. This can lead to the extraction of data from workspaces, to a full takeover of the workspace."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1385"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitpod:gitpod:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022.11.2", "matchCriteriaId": "DA92F145-3FE3-4749-AA7B-648BC0588E31"}]}]}], "references": [{"url": "https://app.safebase.io/portal/71ccd717-aa2d-4a1e-942e-c768d37e9e0c/preview?product=default&orgId=71ccd717-aa2d-4a1e-942e-c768d37e9e0c&tcuUid=1d505bda-9a38-4ca5-8724-052e6337f34d", "source": "report@snyk.io", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/commit/12956988eec0031f42ffdfa3bdc3359f65628f9f", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/commit/673ab6856fa04c13b7b1f2a968e4d090f1d94e4f", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/16378", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/16405", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/gitpod-io/gitpod/releases/tag/release-2022.11.2", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gitpod-io/gitpod/commit/12956988eec0031f42ffdfa3bdc3359f65628f9f"}}