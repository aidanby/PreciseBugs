{"buggy_code": ["## 0.6 / YYYY-MM-DD\n\n*   Breaking Changes:\n\n    *   Extracted `bin/minitar` into a new gem, `minitar-cli`. No, I am *not*\n        going to bump the major version for this. As far as I can tell, few\n        people use the command-line utility anyway. (Installing\n        `archive-tar-minitar` will install both `minitar` and `minitar-cli`, at\n        least until version 1.0.)\n\n*   Enhancements:\n\n    *   Licence change. After speaking with Mauricio Fern\u00e1ndez, we have changed\n        the licensing of this library to Ruby and Simplified BSD and have\n        dropped the GNU GPL license. This takes effect from the 0.6 release.\n    *   Printing a deprecation warning for including Archive::Tar to put\n        Minitar in the top-level namespace.\n    *   Printing a deprecation warning for including Archive::Tar::Minitar into\n        a class (Minitar will be a class for version 1.0).\n    *   Moved Archive::Tar::PosixHeader to Archive::Tar::Minitar::PosixHeader\n        with a deprecation warning. Do not depend on\n        Archive::Tar::Minitar::PosixHeader, as it will be moving to\n        ::Minitar::PosixHeader in a future release.\n    *   Added an alias, ::Minitar, for Archive::Tar::Minitar, opted in with\n        `require 'minitar'`. In future releases, this alias will be enabled by\n        default, and the Archive::Tar namespace will be removed entirely for\n        version 1.0.\n    *   Modified the handling of `mtime` in PosixHeader to do an integer\n        conversion (#to_i) so that a Time object can be used instead of the\n        integer value of the time object.\n    *   Writer::RestrictedStream was renamed to Writer::WriteOnlyStream for\n        clarity. No alias or deprecation warning was provided for this as it is\n        an internal implementation detail.\n    *   Writer::BoundedStream was renamed to Writer::BoundedWriteStream for\n        clarity. A deprecation warning is provided on first use because a\n        BoundedWriteStream may raise a BoundedWriteStream::FileOverflow\n        exception.\n    *   Writer::BoundedWriteStream::FileOverflow has been renamed to\n        Writer::WriteBoundaryOverflow and inherits from StandardError instead\n        of RuntimeError. Note that for Ruby 2.0 or higher, an error will be\n        raised when specifying Writer::BoundedWriteStream::FileOverflow because\n        Writer::BoundedWriteStream has been declared a private constant.\n    *   Modified Writer#add_file_simple to accept the data for a\n        file in `opts[:data]`. When `opts[:data]` is provided, a stream block\n        must not be provided. Improved the documentation for this method.\n    *   Modified Writer#add_file to accept `opts[:data]` and transparently call\n        Writer#add_file_simple in this case.\n    *   Methods that require blocks are no longer required, so the\n        Archive::Tar::Minitar::BlockRequired exception has been removed with a\n        warning.\n\n*   Bugs:\n\n    *   Fix [#2](https://github.com/halostatue/minitar/issues/2) to handle IO\n        streams that are not seekable, such as pipes, STDIN, or STDOUT.\n    *   Fix [#3](https://github.com/halostatue/minitar/issues/3) to make the\n        test timezone resilient.\n    *   Fix [#4](https://github.com/halostatue/minitar/issues/4) for supporting\n        the reading of tar files with filenames in the GNU long filename\n        extension format. Ported from @atoulme\u2019s fork, originally provided by\n        Curtis Sampson.\n    *   Fix [#6](https://github.com/halostatue/minitar/issues/6) by making it\n        raise the correct error for a long filename with no path components.\n    *   Fix [#14](https://github.com/halostatue/minitar/pull/6) provided by\n        @kzys should fix Windows detection issues.\n\n*   Development:\n\n    *   Modernized minitar tooling around Hoe.\n    *   Added travis and coveralls.\n\n## 0.5.2 / 2008-02-26\n\n* Bugs:\n  * Fixed a Ruby 1.9 compatibility error.\n\n## 0.5.1 / 2004-09-27\n\n* Bugs:\n  * Fixed a variable name error.\n\n## 0.5.0\n\n* Initial release. Does files and directories. Command does create, extract,\n  and list.\n", "# coding: utf-8\n\nmodule Archive; end\nmodule Archive::Tar; end\n\nrequire 'fileutils'\nrequire 'rbconfig'\n\nclass << Archive::Tar #:nodoc:\n  def const_missing(const) #:nodoc:\n    case const\n    when :PosixHeader\n      warn \"Archive::Tar::PosixHeader has been renamed to Archive::Tar::Minitar::PosixHeader\"\n      const_set(:PosixHeader, Archive::Tar::Minitar::PosixHeader)\n    else\n      super\n    end\n  end\n\n  private\n\n  def included(mod)\n    unless modules.include?(mod)\n      warn \"Including Minitar via the #{self} namespace is deprecated.\"\n      modules.add mod\n    end\n  end\n\n  def modules\n    require 'set'\n    @modules ||= Set.new\n  end\nend\n\n# == Synopsis\n#\n# Using minitar is easy. The simplest case is:\n#\n#     require 'zlib'\n#     require 'minitar'\n#\n#     # Packs everything that matches Find.find('tests').\n#     # test.tar will automatically be closed by Minitar.pack.\n#     Minitar.pack('tests', File.open('test.tar', 'wb'))\n#\n#     # Unpacks 'test.tar' to 'x', creating 'x' if necessary.\n#     Minitar.unpack('test.tar', 'x')\n#\n# A gzipped tar can be written with:\n#\n#     # test.tgz will be closed automatically.\n#     Minitar.pack('tests', Zlib::GzipWriter.new(File.open('test.tgz', 'wb'))\n#\n#     # test.tgz will be closed automatically.\n#     Minitar.unpack(Zlib::GzipReader.new(File.open('test.tgz', 'rb')), 'x')\n#\n# As the case above shows, one need not write to a file. However, it will\n# sometimes require that one dive a little deeper into the API, as in the case\n# of StringIO objects. Note that I'm not providing a block with\n# Minitar::Output, as Minitar::Output#close automatically closes both the\n# Output object and the wrapped data stream object.\n#\n#     begin\n#       sgz = Zlib::GzipWriter.new(StringIO.new(\"\"))\n#       tar = Output.new(sgz)\n#       Find.find('tests') do |entry|\n#         Minitar.pack_file(entry, tar)\n#       end\n#     ensure\n#         # Closes both tar and sgz.\n#       tar.close\n#     end\nmodule Archive::Tar::Minitar\n  VERSION = '0.6' # :nodoc:\n\n  # Raised when a wrapped data stream class is not seekable.\n  NonSeekableStream = Class.new(StandardError)\n  # The exception raised when operations are performed on a stream that has\n  # previously been closed.\n  ClosedStream = Class.new(StandardError)\n  # The exception raised when a filename exceeds 256 bytes in length, the\n  # maximum supported by the standard Tar format.\n  FileNameTooLong = Class.new(StandardError)\n  # The exception raised when a data stream ends before the amount of data\n  # expected in the archive's PosixHeader.\n  UnexpectedEOF = Class.new(StandardError)\n\n  class << self\n    # Tests if +path+ refers to a directory. Fixes an apparently\n    # corrupted <tt>stat()</tt> call on Windows.\n    def dir?(path)\n      File.directory?((path[-1] == ?/) ? path : \"#{path}/\")\n    end\n\n    # A convenience method for wrapping Archive::Tar::Minitar::Input.open\n    # (mode +r+) and Archive::Tar::Minitar::Output.open (mode +w+). No other\n    # modes are currently supported.\n    def open(dest, mode = \"r\", &block)\n      case mode\n      when 'r'\n        Input.open(dest, &block)\n      when 'w'\n        Output.open(dest, &block)\n      else\n        raise \"Unknown open mode for Archive::Tar::Minitar.open.\"\n      end\n    end\n\n    def const_missing(c) #:nodoc:\n      case c\n      when :BlockRequired\n        warn \"This constant has been removed.\"\n        const_set(:BlockRequired, Class.new(StandardError))\n      else\n        super\n      end\n    end\n\n    def windows? #:nodoc:\n      RbConfig::CONFIG[\"host_os\"] =~ /^(mswin|mingw|cygwin)/\n    end\n\n    # A convenience method to pack the file provided. +entry+ may either be a\n    # filename (in which case various values for the file (see below) will be\n    # obtained from <tt>File#stat(entry)</tt> or a Hash with the fields:\n    #\n    # <tt>:name</tt>::  The filename to be packed into the archive. Required.\n    # <tt>:mode</tt>::  The mode to be applied.\n    # <tt>:uid</tt>::   The user owner of the file. (Ignored on Windows.)\n    # <tt>:gid</tt>::   The group owner of the file. (Ignored on Windows.)\n    # <tt>:mtime</tt>:: The modification Time of the file.\n    #\n    # During packing, if a block is provided, #pack_file yields an +action+\n    # Symol, the full name of the file being packed, and a Hash of\n    # statistical information, just as with\n    # Archive::Tar::Minitar::Input#extract_entry.\n    #\n    # The +action+ will be one of:\n    # <tt>:dir</tt>::           The +entry+ is a directory.\n    # <tt>:file_start</tt>::    The +entry+ is a file; the extract of the\n    #                           file is just beginning.\n    # <tt>:file_progress</tt>:: Yielded every 4096 bytes during the extract\n    #                           of the +entry+.\n    # <tt>:file_done</tt>::     Yielded when the +entry+ is completed.\n    #\n    # The +stats+ hash contains the following keys:\n    # <tt>:current</tt>:: The current total number of bytes read in the\n    #                     +entry+.\n    # <tt>:currinc</tt>:: The current number of bytes read in this read\n    #                     cycle.\n    # <tt>:name</tt>::    The filename to be packed into the tarchive.\n    #                     *REQUIRED*.\n    # <tt>:mode</tt>::    The mode to be applied.\n    # <tt>:uid</tt>::     The user owner of the file. (+nil+ on Windows.)\n    # <tt>:gid</tt>::     The group owner of the file. (+nil+ on Windows.)\n    # <tt>:mtime</tt>::   The modification Time of the file.\n    def pack_file(entry, outputter) #:yields action, name, stats:\n      outputter = outputter.tar if outputter.kind_of?(Archive::Tar::Minitar::Output)\n\n      stats = {}\n\n      if entry.kind_of?(Hash)\n        name = entry[:name]\n        entry.each { |kk, vv| stats[kk] = vv unless vv.nil? }\n      else\n        name = entry\n      end\n\n      name = name.sub(%r{\\./}, '')\n      stat = File.stat(name)\n      stats[:mode]   ||= stat.mode\n      stats[:mtime]  ||= stat.mtime\n      stats[:size]   = stat.size\n\n      if windows?\n        stats[:uid]  = nil\n        stats[:gid]  = nil\n      else\n        stats[:uid]  ||= stat.uid\n        stats[:gid]  ||= stat.gid\n      end\n\n      case\n      when File.file?(name)\n        outputter.add_file_simple(name, stats) do |os|\n          stats[:current] = 0\n          yield :file_start, name, stats if block_given?\n          File.open(name, \"rb\") do |ff|\n            until ff.eof?\n              stats[:currinc] = os.write(ff.read(4096))\n              stats[:current] += stats[:currinc]\n              yield :file_progress, name, stats if block_given?\n            end\n          end\n          yield :file_done, name, stats if block_given?\n        end\n      when dir?(name)\n        yield :dir, name, stats if block_given?\n        outputter.mkdir(name, stats)\n      else\n        raise \"Don't yet know how to pack this type of file.\"\n      end\n    end\n\n    # A convenience method to pack files specified by +src+ into +dest+. If\n    # +src+ is an Array, then each file detailed therein will be packed into\n    # the resulting Archive::Tar::Minitar::Output stream; if +recurse_dirs+ is\n    # true, then directories will be recursed.\n    #\n    # If +src+ is an Array, it will be treated as the result of Find.find; all\n    # files matching will be packed.\n    def pack(src, dest, recurse_dirs = true, &block)\n      Output.open(dest) do |outp|\n        if src.kind_of?(Array)\n          src.each do |entry|\n            pack_file(entry, outp, &block)\n            if dir?(entry) and recurse_dirs\n              Dir[\"#{entry}/**/**\"].each do |ee|\n                pack_file(ee, outp, &block)\n              end\n            end\n          end\n        else\n          require 'find'\n          Find.find(src) do |entry|\n            pack_file(entry, outp, &block)\n          end\n        end\n      end\n    end\n\n    # A convenience method to unpack files from +src+ into the directory\n    # specified by +dest+. Only those files named explicitly in +files+\n    # will be extracted.\n    def unpack(src, dest, files = [], &block)\n      Input.open(src) do |inp|\n        if File.exist?(dest) and (not dir?(dest))\n          raise \"Can't unpack to a non-directory.\"\n        elsif not File.exist?(dest)\n          FileUtils.mkdir_p(dest)\n        end\n\n        inp.each do |entry|\n          if files.empty? or files.include?(entry.full_name)\n            inp.extract_entry(dest, entry, &block)\n          end\n        end\n      end\n    end\n\n    # Check whether +io+ can seek without errors.\n    def seekable?(io, methods = nil)\n      # The IO class throws an exception at runtime if we try to change\n      # position on a non-regular file.\n      if io.respond_to?(:stat)\n        io.stat.file?\n      else\n        # Duck-type the rest of this.\n        methods ||= [ :pos, :pos=, :seek, :rewind ]\n        methods = [ methods ] unless methods.kind_of?(Array)\n        methods.all? { |m| io.respond_to?(m) }\n      end\n    end\n\n    private\n    def included(mod)\n      unless modules.include?(mod)\n        warn \"Including #{self} has been deprecated.\"\n        modules << mod\n      end\n    end\n\n    def modules\n      require 'set'\n      @modules ||= Set.new\n    end\n  end\nend\n\nrequire 'archive/tar/minitar/posix_header'\nrequire 'archive/tar/minitar/input'\nrequire 'archive/tar/minitar/output'\n", "# coding: utf-8\n\nrequire 'archive/tar/minitar/reader'\n\nmodule Archive::Tar::Minitar\n  # Wraps a Archive::Tar::Minitar::Reader with convenience methods and wrapped\n  # stream management; Input only works with data streams that can be rewound.\n  class Input\n    include Enumerable\n\n    # With no associated block, +Input.open+ is a synonym for +Input.new+. If\n    # the optional code block is given, it will be given the new Input as an\n    # argument and the Input object will automatically be closed when the block\n    # terminates (this also closes the wrapped stream object). In this\n    # instance, +Input.open+ returns the value of the block.\n    #\n    # call-seq:\n    #    Archive::Tar::Minitar::Input.open(io) -> input\n    #    Archive::Tar::Minitar::Input.open(io) { |input| block } -> obj\n    def self.open(input)\n      stream = new(input)\n      return stream unless block_given?\n\n      begin\n        res = yield stream\n      ensure\n        stream.close\n      end\n\n      res\n    end\n\n    # Creates a new Input object. If +input+ is a stream object that responds\n    # to #read, then it will simply be wrapped. Otherwise, one will be created\n    # and opened using Kernel#open. When Input#close is called, the stream\n    # object wrapped will be closed.\n    #\n    # An exception will be raised if the stream that is wrapped does not\n    # support rewinding.\n    #\n    # call-seq:\n    #    Archive::Tar::Minitar::Input.new(io) -> input\n    #    Archive::Tar::Minitar::Input.new(path) -> input\n    def initialize(input)\n      if input.respond_to?(:read)\n        @io = input\n      else\n        @io = ::Kernel.open(input, \"rb\")\n      end\n\n      unless Archive::Tar::Minitar.seekable?(@io, :rewind)\n        raise Archive::Tar::Minitar::NonSeekableStream\n      end\n\n      @tar = Reader.new(@io)\n    end\n\n    # When provided a block, iterates through each entry in the archive. When\n    # finished, rewinds to the beginning of the stream.\n    #\n    # If not provided a block, creates an enumerator with the same semantics.\n    def each\n      if block_given?\n        begin\n          @tar.each { |entry| yield entry }\n        ensure\n          @tar.rewind\n        end\n      else\n        enum_for(:each)\n      end\n    end\n\n    # Extracts the current +entry+ to +destdir+. If a block is provided, it\n    # yields an +action+ Symbol, the full name of the file being extracted\n    # (+name+), and a Hash of statistical information (+stats+).\n    #\n    # The +action+ will be one of:\n    # <tt>:dir</tt>::           The +entry+ is a directory.\n    # <tt>:file_start</tt>::    The +entry+ is a file; the extract of the\n    #                           file is just beginning.\n    # <tt>:file_progress</tt>:: Yielded every 4096 bytes during the extract\n    #                           of the +entry+.\n    # <tt>:file_done</tt>::     Yielded when the +entry+ is completed.\n    #\n    # The +stats+ hash contains the following keys:\n    # <tt>:current</tt>:: The current total number of bytes read in the\n    #                     +entry+.\n    # <tt>:currinc</tt>:: The current number of bytes read in this read\n    #                     cycle.\n    # <tt>:entry</tt>::   The entry being extracted; this is a\n    #                     Reader::EntryStream, with all methods thereof.\n    def extract_entry(destdir, entry) # :yields action, name, stats:\n      stats = {\n        :current  => 0,\n        :currinc  => 0,\n        :entry    => entry\n      }\n\n      if entry.directory?\n        dest = File.join(destdir, entry.full_name)\n\n        yield :dir, entry.full_name, stats if block_given?\n\n        if Archive::Tar::Minitar.dir?(dest)\n          begin\n            FileUtils.chmod(entry.mode, dest)\n          rescue Exception\n            nil\n          end\n        else\n          FileUtils.mkdir_p(dest, :mode => entry.mode)\n          FileUtils.chmod(entry.mode, dest)\n        end\n\n        fsync_dir(dest)\n        fsync_dir(File.join(dest, \"..\"))\n        return\n      else # it's a file\n        destdir = File.join(destdir, File.dirname(entry.full_name))\n        FileUtils.mkdir_p(destdir, :mode => 0755)\n\n        destfile = File.join(destdir, File.basename(entry.full_name))\n        FileUtils.chmod(0600, destfile) rescue nil  # Errno::ENOENT\n\n        yield :file_start, entry.full_name, stats if block_given?\n\n        File.open(destfile, \"wb\", entry.mode) do |os|\n          loop do\n            data = entry.read(4096)\n            break unless data\n\n            stats[:currinc] = os.write(data)\n            stats[:current] += stats[:currinc]\n\n            yield :file_progress, entry.full_name, stats if block_given?\n          end\n          os.fsync\n        end\n\n        FileUtils.chmod(entry.mode, destfile)\n        fsync_dir(File.dirname(destfile))\n        fsync_dir(File.join(File.dirname(destfile), \"..\"))\n\n        yield :file_done, entry.full_name, stats if block_given?\n      end\n    end\n\n    # Returns the Reader object for direct access.\n    attr_reader :tar\n\n    # Closes both the Reader object and the wrapped data stream.\n    def close\n      @io.close\n      @tar.close\n    end\n\n    private\n\n    def fsync_dir(dirname)\n      # make sure this hits the disc\n      dir = open(dirname, 'rb')\n      dir.fsync\n    rescue # ignore IOError if it's an unpatched (old) Ruby\n      nil\n    ensure\n      dir.close if dir rescue nil\n    end\n  end\nend\n", "# -*- encoding: utf-8 -*-\n# stub: minitar 0.6 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"minitar\"\n  s.version = \"0.6\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\"]\n  s.authors = [\"Austin Ziegler\"]\n  s.date = \"2016-11-08\"\n  s.description = \"The minitar library is a pure-Ruby library that provides the ability to deal\\nwith POSIX tar(1) archive files.\\n\\nThis is release 0.6, \\u{2026}\\n\\nminitar (previously called Archive::Tar::Minitar) is based heavily on code\\noriginally written by Mauricio Julio Fern\\u{e1}ndez Pradier for the rpa-base\\nproject.\"\n  s.email = [\"halostatue@gmail.com\"]\n  s.extra_rdoc_files = [\"Code-of-Conduct.md\", \"Contributing.md\", \"History.md\", \"Licence.md\", \"Manifest.txt\", \"README.rdoc\", \"docs/bsdl.txt\", \"docs/ruby.txt\"]\n  s.files = [\"Code-of-Conduct.md\", \"Contributing.md\", \"History.md\", \"Licence.md\", \"Manifest.txt\", \"README.rdoc\", \"Rakefile\", \"docs/bsdl.txt\", \"docs/ruby.txt\", \"lib/archive-tar-minitar.rb\", \"lib/archive/tar/minitar.rb\", \"lib/archive/tar/minitar/input.rb\", \"lib/archive/tar/minitar/output.rb\", \"lib/archive/tar/minitar/posix_header.rb\", \"lib/archive/tar/minitar/reader.rb\", \"lib/archive/tar/minitar/writer.rb\", \"lib/minitar.rb\", \"test/minitest_helper.rb\", \"test/support/tar_test_helpers.rb\", \"test/test_tar_header.rb\", \"test/test_tar_input.rb\", \"test/test_tar_output.rb\", \"test/test_tar_reader.rb\", \"test/test_tar_writer.rb\"]\n  s.homepage = \"https://github.com/halostatue/minitar/\"\n  s.licenses = [\"Ruby\", \"BSD-2-Clause\"]\n  s.rdoc_options = [\"--main\", \"README.rdoc\"]\n  s.required_ruby_version = Gem::Requirement.new(\">= 1.8\")\n  s.rubygems_version = \"2.5.1\"\n  s.summary = \"The minitar library is a pure-Ruby library that provides the ability to deal with POSIX tar(1) archive files\"\n\n  if s.respond_to? :specification_version then\n    s.specification_version = 4\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_development_dependency(%q<minitest>, [\"~> 5.9\"])\n      s.add_development_dependency(%q<hoe-doofus>, [\"~> 1.0\"])\n      s.add_development_dependency(%q<hoe-gemspec2>, [\"~> 1.1\"])\n      s.add_development_dependency(%q<hoe-git>, [\"~> 1.6\"])\n      s.add_development_dependency(%q<hoe-rubygems>, [\"~> 1.0\"])\n      s.add_development_dependency(%q<hoe-travis>, [\"~> 1.2\"])\n      s.add_development_dependency(%q<minitest-autotest>, [\"< 2\", \">= 1.0.b\"])\n      s.add_development_dependency(%q<rake>, [\"~> 10.0\"])\n      s.add_development_dependency(%q<rdoc>, [\">= 0.0\"])\n      s.add_development_dependency(%q<hoe>, [\"~> 3.15\"])\n    else\n      s.add_dependency(%q<minitest>, [\"~> 5.9\"])\n      s.add_dependency(%q<hoe-doofus>, [\"~> 1.0\"])\n      s.add_dependency(%q<hoe-gemspec2>, [\"~> 1.1\"])\n      s.add_dependency(%q<hoe-git>, [\"~> 1.6\"])\n      s.add_dependency(%q<hoe-rubygems>, [\"~> 1.0\"])\n      s.add_dependency(%q<hoe-travis>, [\"~> 1.2\"])\n      s.add_dependency(%q<minitest-autotest>, [\"< 2\", \">= 1.0.b\"])\n      s.add_dependency(%q<rake>, [\"~> 10.0\"])\n      s.add_dependency(%q<rdoc>, [\">= 0.0\"])\n      s.add_dependency(%q<hoe>, [\"~> 3.15\"])\n    end\n  else\n    s.add_dependency(%q<minitest>, [\"~> 5.9\"])\n    s.add_dependency(%q<hoe-doofus>, [\"~> 1.0\"])\n    s.add_dependency(%q<hoe-gemspec2>, [\"~> 1.1\"])\n    s.add_dependency(%q<hoe-git>, [\"~> 1.6\"])\n    s.add_dependency(%q<hoe-rubygems>, [\"~> 1.0\"])\n    s.add_dependency(%q<hoe-travis>, [\"~> 1.2\"])\n    s.add_dependency(%q<minitest-autotest>, [\"< 2\", \">= 1.0.b\"])\n    s.add_dependency(%q<rake>, [\"~> 10.0\"])\n    s.add_dependency(%q<rdoc>, [\">= 0.0\"])\n    s.add_dependency(%q<hoe>, [\"~> 3.15\"])\n  end\nend\n", "#!/usr/bin/env ruby\n\nrequire 'minitar'\nrequire 'minitest_helper'\nrequire 'base64'\nrequire 'zlib'\n\nclass TestTarInput < Minitest::Test\n  include TarTester\n\n  TEST_TGZ = Base64.decode64 <<-EOS\nH4sIAKJpllQAA0tJLEnUK0ks0kuvYqAVMDAwMDMxUQDR5mbmYNrACMIHA2MjIwUDc3NzEzMz\nQxMDAwUDQ2NTczMGBQOauQgJlBYDfQ90SiKQkZmHWx1QWVoaHnMgXlGA00MEyHdzMMzOnBbC\nwPz28n2uJgOR44Xrq7tsHc/utNe/9FdihkmH3pZ7+zOTRFREzkzYJ99iHHDn4n0/Wb3E8Ceq\nS0uOdSyMMg9Z+WVvX0vJucxs77vrvZf2arWcvHP9wa1Yp9lRnJmC59/P9+43PXum+tj7Ga+8\nrtT+u3d941e765Y/bOrnvpv8X6jtz+wKqyk/v3n8P5xlO3l/1dn9q9Zotpy5funw/Of77Y/5\nLVltz7ToTl7dXf5ppmf3n9p+PPxz/sz/qjZn9yf9Y4R7I2Ft3tqfPTUMGgMYlEMSpGXmpBrT\n2A5Qvjc1xZ3/DTDyv5GJmfFo/qcHCMnILFYAIlA6UDDWU+DlGmgXjYJRMApGwSgYBaNgFIyC\nUTAKRsEoGAWjYBSMglEwCkbBKBgFo2AUjIJRMApGwSgYBaNgFIwCUgAAGnyo6wAoAAA=\n  EOS\n  FILETIMES = Time.utc(2004).to_i\n\n  TEST_CONTENTS = {\n    \"data.tar.gz\" => { :size => 210, :mode => 0644 },\n    \"file3\" => { :size => 18, :mode => 0755 },\n  }\n\n  TEST_DATA_CONTENTS = {\n    \"data/\" => { :size => 0, :mode => 0755 },\n    \"data/__dir__/\" => { :size => 0, :mode => 0755 },\n    \"data/file1\" => { :size => 16, :mode => 0644 },\n    \"data/file2\" => { :size => 16, :mode => 0644 },\n  }\n\n  def setup\n    FileUtils.mkdir_p(\"data__\")\n  end\n\n  def teardown\n    FileUtils.rm_rf(\"data__\")\n  end\n\n  def test_each_works\n    reader = Zlib::GzipReader.new(StringIO.new(TEST_TGZ))\n    Minitar::Input.open(reader) do |stream|\n      outer = 0\n      stream.each.with_index do |entry, i|\n        assert_kind_of(Minitar::Reader::EntryStream, entry)\n        assert TEST_CONTENTS.has_key?(entry.name)\n\n        assert_equal(TEST_CONTENTS[entry.name][:size], entry.size, entry.name)\n        assert_modes_equal(TEST_CONTENTS[entry.name][:mode],\n                           entry.mode, entry.name)\n        assert_equal(FILETIMES, entry.mtime, \"entry.mtime\")\n\n        if i.zero?\n          data_reader = Zlib::GzipReader.new(StringIO.new(entry.read))\n          Minitar::Input.open(data_reader) do |is2|\n            inner = 0\n            is2.each_with_index do |entry2, j|\n              assert_kind_of(Minitar::Reader::EntryStream, entry2)\n              assert TEST_DATA_CONTENTS.has_key?(entry2.name)\n              assert_equal(TEST_DATA_CONTENTS[entry2.name][:size], entry2.size,\n                           entry2.name)\n              assert_modes_equal(TEST_DATA_CONTENTS[entry2.name][:mode],\n                                 entry2.mode, entry2.name)\n              assert_equal(FILETIMES, entry2.mtime, entry2.name)\n              inner += 1\n            end\n            assert_equal(4, inner)\n          end\n        end\n\n        outer += 1\n      end\n      assert_equal(2, outer)\n    end\n  end\n\n  def test_extract_entry_works\n    reader = Zlib::GzipReader.new(StringIO.new(TEST_TGZ))\n    Minitar::Input.open(reader) do |stream|\n      outer_count = 0\n      stream.each_with_index do |entry, i|\n        stream.extract_entry(\"data__\", entry)\n        name = File.join(\"data__\", entry.name)\n\n        assert TEST_CONTENTS.has_key?(entry.name)\n\n        if entry.directory?\n          assert(File.directory?(name))\n        else\n          assert(File.file?(name))\n\n          assert_equal(TEST_CONTENTS[entry.name][:size], File.stat(name).size)\n        end\n\n        assert_modes_equal(TEST_CONTENTS[entry.name][:mode],\n                           File.stat(name).mode, entry.name)\n\n        if i.zero?\n          begin\n            ff    = File.open(name, \"rb\")\n            data_reader  = Zlib::GzipReader.new(ff)\n            Minitar::Input.open(data_reader) do |is2|\n              is2.each_with_index do |entry2, j|\n                is2.extract_entry(\"data__\", entry2)\n                name2 = File.join(\"data__\", entry2.name)\n\n                assert TEST_DATA_CONTENTS.has_key?(entry2.name)\n\n                if entry2.directory?\n                  assert(File.directory?(name2))\n                else\n                  assert(File.file?(name2))\n                  assert_equal(TEST_DATA_CONTENTS[entry2.name][:size],\n                               File.stat(name2).size)\n                end\n                assert_modes_equal(TEST_DATA_CONTENTS[entry2.name][:mode],\n                                   File.stat(name2).mode, name2)\n              end\n            end\n          ensure\n            ff.close unless ff.closed?\n          end\n        end\n\n        outer_count += 1\n      end\n\n      assert_equal(2, outer_count)\n    end\n  end\nend\n"], "fixing_code": ["## 0.6 / YYYY-MM-DD\n\n*   Breaking Changes:\n\n    *   Extracted `bin/minitar` into a new gem, `minitar-cli`. No, I am *not*\n        going to bump the major version for this. As far as I can tell, few\n        people use the command-line utility anyway. (Installing\n        `archive-tar-minitar` will install both `minitar` and `minitar-cli`, at\n        least until version 1.0.)\n\n    *   Minitar extraction before 0.6 traverses directories if the tarball\n        includes a relative directory reference, as reported in [#16][] by\n        @ecneladis. This has been disallowed entirely and will throw a\n        SecureRelativePathError when found. Additionally, if the final\n        destination of an entry is an already-existing symbolic link, the\n        existing symbolic link will be removed and the file will be written\n        correctly (on platforms that support symblic links).\n\n*   Enhancements:\n\n    *   Licence change. After speaking with Mauricio Fern\u00e1ndez, we have changed\n        the licensing of this library to Ruby and Simplified BSD and have\n        dropped the GNU GPL license. This takes effect from the 0.6 release.\n    *   Printing a deprecation warning for including Archive::Tar to put\n        Minitar in the top-level namespace.\n    *   Printing a deprecation warning for including Archive::Tar::Minitar into\n        a class (Minitar will be a class for version 1.0).\n    *   Moved Archive::Tar::PosixHeader to Archive::Tar::Minitar::PosixHeader\n        with a deprecation warning. Do not depend on\n        Archive::Tar::Minitar::PosixHeader, as it will be moving to\n        ::Minitar::PosixHeader in a future release.\n    *   Added an alias, ::Minitar, for Archive::Tar::Minitar, opted in with\n        `require 'minitar'`. In future releases, this alias will be enabled by\n        default, and the Archive::Tar namespace will be removed entirely for\n        version 1.0.\n    *   Modified the handling of `mtime` in PosixHeader to do an integer\n        conversion (#to_i) so that a Time object can be used instead of the\n        integer value of the time object.\n    *   Writer::RestrictedStream was renamed to Writer::WriteOnlyStream for\n        clarity. No alias or deprecation warning was provided for this as it is\n        an internal implementation detail.\n    *   Writer::BoundedStream was renamed to Writer::BoundedWriteStream for\n        clarity. A deprecation warning is provided on first use because a\n        BoundedWriteStream may raise a BoundedWriteStream::FileOverflow\n        exception.\n    *   Writer::BoundedWriteStream::FileOverflow has been renamed to\n        Writer::WriteBoundaryOverflow and inherits from StandardError instead\n        of RuntimeError. Note that for Ruby 2.0 or higher, an error will be\n        raised when specifying Writer::BoundedWriteStream::FileOverflow because\n        Writer::BoundedWriteStream has been declared a private constant.\n    *   Modified Writer#add_file_simple to accept the data for a\n        file in `opts[:data]`. When `opts[:data]` is provided, a stream block\n        must not be provided. Improved the documentation for this method.\n    *   Modified Writer#add_file to accept `opts[:data]` and transparently call\n        Writer#add_file_simple in this case.\n    *   Methods that require blocks are no longer required, so the\n        Archive::Tar::Minitar::BlockRequired exception has been removed with a\n        warning.\n\n*   Bugs:\n\n    *   Fix [#2][] to handle IO streams that are not seekable, such as pipes,\n        STDIN, or STDOUT.\n    *   Fix [#3][] to make the test timezone resilient.\n    *   Fix [#4][] for supporting the reading of tar files with filenames in\n        the GNU long filename extension format. Ported from @atoulme\u2019s fork,\n        originally provided by Curtis Sampson.\n    *   Fix [#6][] by making it raise the correct error for a long filename\n        with no path components.\n    *   Fix [#14][] provided by @kzys should fix Windows detection issues.\n    *   Fix [#16][] as specified above.\n\n*   Development:\n\n    *   Modernized minitar tooling around Hoe.\n    *   Added travis and coveralls.\n\n## 0.5.2 / 2008-02-26\n\n* Bugs:\n  * Fixed a Ruby 1.9 compatibility error.\n\n## 0.5.1 / 2004-09-27\n\n* Bugs:\n  * Fixed a variable name error.\n\n## 0.5.0\n\n* Initial release. Does files and directories. Command does create, extract,\n  and list.\n\n[#2]: https://github.com/halostatue/minitar/issues/2\n[#3]: https://github.com/halostatue/minitar/issues/3\n[#4]: https://github.com/halostatue/minitar/issues/4\n[#6]: https://github.com/halostatue/minitar/issues/6\n[#14]: https://github.com/halostatue/minitar/issues/14\n[#16]: https://github.com/halostatue/minitar/issues/16\n", "# coding: utf-8\n\nmodule Archive; end\nmodule Archive::Tar; end\n\nrequire 'fileutils'\nrequire 'rbconfig'\n\nclass << Archive::Tar #:nodoc:\n  def const_missing(const) #:nodoc:\n    case const\n    when :PosixHeader\n      warn \"Archive::Tar::PosixHeader has been renamed to Archive::Tar::Minitar::PosixHeader\"\n      const_set(:PosixHeader, Archive::Tar::Minitar::PosixHeader)\n    else\n      super\n    end\n  end\n\n  private\n\n  def included(mod)\n    unless modules.include?(mod)\n      warn \"Including Minitar via the #{self} namespace is deprecated.\"\n      modules.add mod\n    end\n  end\n\n  def modules\n    require 'set'\n    @modules ||= Set.new\n  end\nend\n\n# == Synopsis\n#\n# Using minitar is easy. The simplest case is:\n#\n#     require 'zlib'\n#     require 'minitar'\n#\n#     # Packs everything that matches Find.find('tests').\n#     # test.tar will automatically be closed by Minitar.pack.\n#     Minitar.pack('tests', File.open('test.tar', 'wb'))\n#\n#     # Unpacks 'test.tar' to 'x', creating 'x' if necessary.\n#     Minitar.unpack('test.tar', 'x')\n#\n# A gzipped tar can be written with:\n#\n#     # test.tgz will be closed automatically.\n#     Minitar.pack('tests', Zlib::GzipWriter.new(File.open('test.tgz', 'wb'))\n#\n#     # test.tgz will be closed automatically.\n#     Minitar.unpack(Zlib::GzipReader.new(File.open('test.tgz', 'rb')), 'x')\n#\n# As the case above shows, one need not write to a file. However, it will\n# sometimes require that one dive a little deeper into the API, as in the case\n# of StringIO objects. Note that I'm not providing a block with\n# Minitar::Output, as Minitar::Output#close automatically closes both the\n# Output object and the wrapped data stream object.\n#\n#     begin\n#       sgz = Zlib::GzipWriter.new(StringIO.new(\"\"))\n#       tar = Output.new(sgz)\n#       Find.find('tests') do |entry|\n#         Minitar.pack_file(entry, tar)\n#       end\n#     ensure\n#         # Closes both tar and sgz.\n#       tar.close\n#     end\nmodule Archive::Tar::Minitar\n  VERSION = '0.6' # :nodoc:\n\n  # The base class for any minitar error.\n  Error = Class.new(StandardError)\n  # Raised when a wrapped data stream class is not seekable.\n  NonSeekableStream = Class.new(Error)\n  # The exception raised when operations are performed on a stream that has\n  # previously been closed.\n  ClosedStream = Class.new(Error)\n  # The exception raised when a filename exceeds 256 bytes in length, the\n  # maximum supported by the standard Tar format.\n  FileNameTooLong = Class.new(Error)\n  # The exception raised when a data stream ends before the amount of data\n  # expected in the archive's PosixHeader.\n  UnexpectedEOF = Class.new(StandardError)\n  # The exception raised when a file contains a relative path in secure mode\n  # (the default for this version).\n  SecureRelativePathError = Class.new(Error)\n\n  class << self\n    # Tests if +path+ refers to a directory. Fixes an apparently\n    # corrupted <tt>stat()</tt> call on Windows.\n    def dir?(path)\n      File.directory?((path[-1] == ?/) ? path : \"#{path}/\")\n    end\n\n    # A convenience method for wrapping Archive::Tar::Minitar::Input.open\n    # (mode +r+) and Archive::Tar::Minitar::Output.open (mode +w+). No other\n    # modes are currently supported.\n    def open(dest, mode = \"r\", &block)\n      case mode\n      when 'r'\n        Input.open(dest, &block)\n      when 'w'\n        Output.open(dest, &block)\n      else\n        raise \"Unknown open mode for Archive::Tar::Minitar.open.\"\n      end\n    end\n\n    def const_missing(c) #:nodoc:\n      case c\n      when :BlockRequired\n        warn \"This constant has been removed.\"\n        const_set(:BlockRequired, Class.new(StandardError))\n      else\n        super\n      end\n    end\n\n    def windows? #:nodoc:\n      RbConfig::CONFIG[\"host_os\"] =~ /^(mswin|mingw|cygwin)/\n    end\n\n    # A convenience method to pack the file provided. +entry+ may either be a\n    # filename (in which case various values for the file (see below) will be\n    # obtained from <tt>File#stat(entry)</tt> or a Hash with the fields:\n    #\n    # <tt>:name</tt>::  The filename to be packed into the archive. Required.\n    # <tt>:mode</tt>::  The mode to be applied.\n    # <tt>:uid</tt>::   The user owner of the file. (Ignored on Windows.)\n    # <tt>:gid</tt>::   The group owner of the file. (Ignored on Windows.)\n    # <tt>:mtime</tt>:: The modification Time of the file.\n    #\n    # During packing, if a block is provided, #pack_file yields an +action+\n    # Symol, the full name of the file being packed, and a Hash of\n    # statistical information, just as with\n    # Archive::Tar::Minitar::Input#extract_entry.\n    #\n    # The +action+ will be one of:\n    # <tt>:dir</tt>::           The +entry+ is a directory.\n    # <tt>:file_start</tt>::    The +entry+ is a file; the extract of the\n    #                           file is just beginning.\n    # <tt>:file_progress</tt>:: Yielded every 4096 bytes during the extract\n    #                           of the +entry+.\n    # <tt>:file_done</tt>::     Yielded when the +entry+ is completed.\n    #\n    # The +stats+ hash contains the following keys:\n    # <tt>:current</tt>:: The current total number of bytes read in the\n    #                     +entry+.\n    # <tt>:currinc</tt>:: The current number of bytes read in this read\n    #                     cycle.\n    # <tt>:name</tt>::    The filename to be packed into the tarchive.\n    #                     *REQUIRED*.\n    # <tt>:mode</tt>::    The mode to be applied.\n    # <tt>:uid</tt>::     The user owner of the file. (+nil+ on Windows.)\n    # <tt>:gid</tt>::     The group owner of the file. (+nil+ on Windows.)\n    # <tt>:mtime</tt>::   The modification Time of the file.\n    def pack_file(entry, outputter) #:yields action, name, stats:\n      outputter = outputter.tar if outputter.kind_of?(Archive::Tar::Minitar::Output)\n\n      stats = {}\n\n      if entry.kind_of?(Hash)\n        name = entry[:name]\n        entry.each { |kk, vv| stats[kk] = vv unless vv.nil? }\n      else\n        name = entry\n      end\n\n      name = name.sub(%r{\\./}, '')\n      stat = File.stat(name)\n      stats[:mode]   ||= stat.mode\n      stats[:mtime]  ||= stat.mtime\n      stats[:size]   = stat.size\n\n      if windows?\n        stats[:uid]  = nil\n        stats[:gid]  = nil\n      else\n        stats[:uid]  ||= stat.uid\n        stats[:gid]  ||= stat.gid\n      end\n\n      case\n      when File.file?(name)\n        outputter.add_file_simple(name, stats) do |os|\n          stats[:current] = 0\n          yield :file_start, name, stats if block_given?\n          File.open(name, \"rb\") do |ff|\n            until ff.eof?\n              stats[:currinc] = os.write(ff.read(4096))\n              stats[:current] += stats[:currinc]\n              yield :file_progress, name, stats if block_given?\n            end\n          end\n          yield :file_done, name, stats if block_given?\n        end\n      when dir?(name)\n        yield :dir, name, stats if block_given?\n        outputter.mkdir(name, stats)\n      else\n        raise \"Don't yet know how to pack this type of file.\"\n      end\n    end\n\n    # A convenience method to pack files specified by +src+ into +dest+. If\n    # +src+ is an Array, then each file detailed therein will be packed into\n    # the resulting Archive::Tar::Minitar::Output stream; if +recurse_dirs+ is\n    # true, then directories will be recursed.\n    #\n    # If +src+ is an Array, it will be treated as the result of Find.find; all\n    # files matching will be packed.\n    def pack(src, dest, recurse_dirs = true, &block)\n      Output.open(dest) do |outp|\n        if src.kind_of?(Array)\n          src.each do |entry|\n            pack_file(entry, outp, &block)\n            if dir?(entry) and recurse_dirs\n              Dir[\"#{entry}/**/**\"].each do |ee|\n                pack_file(ee, outp, &block)\n              end\n            end\n          end\n        else\n          require 'find'\n          Find.find(src) do |entry|\n            pack_file(entry, outp, &block)\n          end\n        end\n      end\n    end\n\n    # A convenience method to unpack files from +src+ into the directory\n    # specified by +dest+. Only those files named explicitly in +files+\n    # will be extracted.\n    def unpack(src, dest, files = [], &block)\n      Input.open(src) do |inp|\n        if File.exist?(dest) and (not dir?(dest))\n          raise \"Can't unpack to a non-directory.\"\n        elsif not File.exist?(dest)\n          FileUtils.mkdir_p(dest)\n        end\n\n        inp.each do |entry|\n          if files.empty? or files.include?(entry.full_name)\n            inp.extract_entry(dest, entry, &block)\n          end\n        end\n      end\n    end\n\n    # Check whether +io+ can seek without errors.\n    def seekable?(io, methods = nil)\n      # The IO class throws an exception at runtime if we try to change\n      # position on a non-regular file.\n      if io.respond_to?(:stat)\n        io.stat.file?\n      else\n        # Duck-type the rest of this.\n        methods ||= [ :pos, :pos=, :seek, :rewind ]\n        methods = [ methods ] unless methods.kind_of?(Array)\n        methods.all? { |m| io.respond_to?(m) }\n      end\n    end\n\n    private\n    def included(mod)\n      unless modules.include?(mod)\n        warn \"Including #{self} has been deprecated.\"\n        modules << mod\n      end\n    end\n\n    def modules\n      require 'set'\n      @modules ||= Set.new\n    end\n  end\nend\n\nrequire 'archive/tar/minitar/posix_header'\nrequire 'archive/tar/minitar/input'\nrequire 'archive/tar/minitar/output'\n", "# coding: utf-8\n\nrequire 'archive/tar/minitar/reader'\n\nmodule Archive::Tar::Minitar\n  # Wraps a Archive::Tar::Minitar::Reader with convenience methods and wrapped\n  # stream management; Input only works with data streams that can be rewound.\n  class Input\n    include Enumerable\n\n    # With no associated block, +Input.open+ is a synonym for +Input.new+. If\n    # the optional code block is given, it will be given the new Input as an\n    # argument and the Input object will automatically be closed when the block\n    # terminates (this also closes the wrapped stream object). In this\n    # instance, +Input.open+ returns the value of the block.\n    #\n    # call-seq:\n    #    Archive::Tar::Minitar::Input.open(io) -> input\n    #    Archive::Tar::Minitar::Input.open(io) { |input| block } -> obj\n    def self.open(input)\n      stream = new(input)\n      return stream unless block_given?\n\n      begin\n        res = yield stream\n      ensure\n        stream.close\n      end\n\n      res\n    end\n\n    # Creates a new Input object. If +input+ is a stream object that responds\n    # to #read, then it will simply be wrapped. Otherwise, one will be created\n    # and opened using Kernel#open. When Input#close is called, the stream\n    # object wrapped will be closed.\n    #\n    # An exception will be raised if the stream that is wrapped does not\n    # support rewinding.\n    #\n    # call-seq:\n    #    Archive::Tar::Minitar::Input.new(io) -> input\n    #    Archive::Tar::Minitar::Input.new(path) -> input\n    def initialize(input)\n      if input.respond_to?(:read)\n        @io = input\n      else\n        @io = ::Kernel.open(input, \"rb\")\n      end\n\n      unless Archive::Tar::Minitar.seekable?(@io, :rewind)\n        raise Archive::Tar::Minitar::NonSeekableStream\n      end\n\n      @tar = Reader.new(@io)\n    end\n\n    # When provided a block, iterates through each entry in the archive. When\n    # finished, rewinds to the beginning of the stream.\n    #\n    # If not provided a block, creates an enumerator with the same semantics.\n    def each\n      if block_given?\n        begin\n          @tar.each { |entry| yield entry }\n        ensure\n          @tar.rewind\n        end\n      else\n        enum_for(:each)\n      end\n    end\n\n    # Extracts the current +entry+ to +destdir+. If a block is provided, it\n    # yields an +action+ Symbol, the full name of the file being extracted\n    # (+name+), and a Hash of statistical information (+stats+).\n    #\n    # The +action+ will be one of:\n    # <tt>:dir</tt>::           The +entry+ is a directory.\n    # <tt>:file_start</tt>::    The +entry+ is a file; the extract of the\n    #                           file is just beginning.\n    # <tt>:file_progress</tt>:: Yielded every 4096 bytes during the extract\n    #                           of the +entry+.\n    # <tt>:file_done</tt>::     Yielded when the +entry+ is completed.\n    #\n    # The +stats+ hash contains the following keys:\n    # <tt>:current</tt>:: The current total number of bytes read in the\n    #                     +entry+.\n    # <tt>:currinc</tt>:: The current number of bytes read in this read\n    #                     cycle.\n    # <tt>:entry</tt>::   The entry being extracted; this is a\n    #                     Reader::EntryStream, with all methods thereof.\n    def extract_entry(destdir, entry) # :yields action, name, stats:\n      stats = {\n        :current  => 0,\n        :currinc  => 0,\n        :entry    => entry\n      }\n\n      # extract_entry is not vulnerable to prefix '/' vulnerabilities, but it\n      # is vulnerable to relative path directories. This code will break this\n      # vulnerability. For this version, we are breaking relative paths HARD by\n      # throwing an exception.\n      #\n      # Future versions may permit relative paths as long as the file does not\n      # leave +destdir+.\n      #\n      # However, squeeze consecutive '/' characters together.\n      full_name = entry.full_name.squeeze('/')\n\n      if full_name =~ /\\.{2}(?:\\/|\\z)/\n        raise SecureRelativePathError, %q(Path contains '..')\n      end\n\n      if entry.directory?\n        dest = File.join(destdir, full_name)\n\n        yield :dir, full_name, stats if block_given?\n\n        if Archive::Tar::Minitar.dir?(dest)\n          begin\n            FileUtils.chmod(entry.mode, dest)\n          rescue Exception\n            nil\n          end\n        else\n          File.unlink(dest.chomp('/')) if File.symlink?(dest.chomp('/'))\n\n          FileUtils.mkdir_p(dest, :mode => entry.mode)\n          FileUtils.chmod(entry.mode, dest)\n        end\n\n        fsync_dir(dest)\n        fsync_dir(File.join(dest, \"..\"))\n        return\n      else # it's a file\n        destdir = File.join(destdir, File.dirname(full_name))\n        FileUtils.mkdir_p(destdir, :mode => 0755)\n\n        destfile = File.join(destdir, File.basename(full_name))\n\n        File.unlink(destfile) if File.symlink?(destfile)\n\n        FileUtils.chmod(0600, destfile) rescue nil  # Errno::ENOENT\n\n        yield :file_start, full_name, stats if block_given?\n\n        File.open(destfile, \"wb\", entry.mode) do |os|\n          loop do\n            data = entry.read(4096)\n            break unless data\n\n            stats[:currinc] = os.write(data)\n            stats[:current] += stats[:currinc]\n\n            yield :file_progress, full_name, stats if block_given?\n          end\n          os.fsync\n        end\n\n        FileUtils.chmod(entry.mode, destfile)\n        fsync_dir(File.dirname(destfile))\n        fsync_dir(File.join(File.dirname(destfile), \"..\"))\n\n        yield :file_done, full_name, stats if block_given?\n      end\n    end\n\n    # Returns the Reader object for direct access.\n    attr_reader :tar\n\n    # Closes both the Reader object and the wrapped data stream.\n    def close\n      @io.close\n      @tar.close\n    end\n\n    private\n\n    def fsync_dir(dirname)\n      # make sure this hits the disc\n      dir = open(dirname, 'rb')\n      dir.fsync\n    rescue # ignore IOError if it's an unpatched (old) Ruby\n      nil\n    ensure\n      dir.close if dir rescue nil\n    end\n  end\nend\n", "# -*- encoding: utf-8 -*-\n# stub: minitar 0.6 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"minitar\"\n  s.version = \"0.6\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\"]\n  s.authors = [\"Austin Ziegler\"]\n  s.date = \"2016-11-14\"\n  s.description = \"The minitar library is a pure-Ruby library that provides the ability to deal\\nwith POSIX tar(1) archive files.\\n\\nThis is release 0.6, \\u{2026}\\n\\nminitar (previously called Archive::Tar::Minitar) is based heavily on code\\noriginally written by Mauricio Julio Fern\\u{e1}ndez Pradier for the rpa-base\\nproject.\"\n  s.email = [\"halostatue@gmail.com\"]\n  s.extra_rdoc_files = [\"Code-of-Conduct.md\", \"Contributing.md\", \"History.md\", \"Licence.md\", \"Manifest.txt\", \"README.rdoc\", \"docs/bsdl.txt\", \"docs/ruby.txt\"]\n  s.files = [\"Code-of-Conduct.md\", \"Contributing.md\", \"History.md\", \"Licence.md\", \"Manifest.txt\", \"README.rdoc\", \"Rakefile\", \"docs/bsdl.txt\", \"docs/ruby.txt\", \"lib/archive-tar-minitar.rb\", \"lib/archive/tar/minitar.rb\", \"lib/archive/tar/minitar/input.rb\", \"lib/archive/tar/minitar/output.rb\", \"lib/archive/tar/minitar/posix_header.rb\", \"lib/archive/tar/minitar/reader.rb\", \"lib/archive/tar/minitar/writer.rb\", \"lib/minitar.rb\", \"test/minitest_helper.rb\", \"test/support/tar_test_helpers.rb\", \"test/test_tar_header.rb\", \"test/test_tar_input.rb\", \"test/test_tar_output.rb\", \"test/test_tar_reader.rb\", \"test/test_tar_writer.rb\"]\n  s.homepage = \"https://github.com/halostatue/minitar/\"\n  s.licenses = [\"Ruby\", \"BSD-2-Clause\"]\n  s.rdoc_options = [\"--main\", \"README.rdoc\"]\n  s.required_ruby_version = Gem::Requirement.new(\">= 1.8\")\n  s.rubygems_version = \"2.5.1\"\n  s.summary = \"The minitar library is a pure-Ruby library that provides the ability to deal with POSIX tar(1) archive files\"\n\n  if s.respond_to? :specification_version then\n    s.specification_version = 4\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_development_dependency(%q<minitest>, [\"~> 5.9\"])\n      s.add_development_dependency(%q<hoe-doofus>, [\"~> 1.0\"])\n      s.add_development_dependency(%q<hoe-gemspec2>, [\"~> 1.1\"])\n      s.add_development_dependency(%q<hoe-git>, [\"~> 1.6\"])\n      s.add_development_dependency(%q<hoe-rubygems>, [\"~> 1.0\"])\n      s.add_development_dependency(%q<hoe-travis>, [\"~> 1.2\"])\n      s.add_development_dependency(%q<minitest-autotest>, [\"< 2\", \">= 1.0.b\"])\n      s.add_development_dependency(%q<rake>, [\"~> 10.0\"])\n      s.add_development_dependency(%q<rdoc>, [\">= 0.0\"])\n      s.add_development_dependency(%q<hoe>, [\"~> 3.15\"])\n    else\n      s.add_dependency(%q<minitest>, [\"~> 5.9\"])\n      s.add_dependency(%q<hoe-doofus>, [\"~> 1.0\"])\n      s.add_dependency(%q<hoe-gemspec2>, [\"~> 1.1\"])\n      s.add_dependency(%q<hoe-git>, [\"~> 1.6\"])\n      s.add_dependency(%q<hoe-rubygems>, [\"~> 1.0\"])\n      s.add_dependency(%q<hoe-travis>, [\"~> 1.2\"])\n      s.add_dependency(%q<minitest-autotest>, [\"< 2\", \">= 1.0.b\"])\n      s.add_dependency(%q<rake>, [\"~> 10.0\"])\n      s.add_dependency(%q<rdoc>, [\">= 0.0\"])\n      s.add_dependency(%q<hoe>, [\"~> 3.15\"])\n    end\n  else\n    s.add_dependency(%q<minitest>, [\"~> 5.9\"])\n    s.add_dependency(%q<hoe-doofus>, [\"~> 1.0\"])\n    s.add_dependency(%q<hoe-gemspec2>, [\"~> 1.1\"])\n    s.add_dependency(%q<hoe-git>, [\"~> 1.6\"])\n    s.add_dependency(%q<hoe-rubygems>, [\"~> 1.0\"])\n    s.add_dependency(%q<hoe-travis>, [\"~> 1.2\"])\n    s.add_dependency(%q<minitest-autotest>, [\"< 2\", \">= 1.0.b\"])\n    s.add_dependency(%q<rake>, [\"~> 10.0\"])\n    s.add_dependency(%q<rdoc>, [\">= 0.0\"])\n    s.add_dependency(%q<hoe>, [\"~> 3.15\"])\n  end\nend\n", "#!/usr/bin/env ruby\n\nrequire 'minitar'\nrequire 'minitest_helper'\nrequire 'base64'\nrequire 'zlib'\n\nclass TestTarInput < Minitest::Test\n  include TarTester\n\n  TEST_TGZ = Base64.decode64 <<-EOS\nH4sIAKJpllQAA0tJLEnUK0ks0kuvYqAVMDAwMDMxUQDR5mbmYNrACMIHA2MjIwUDc3NzEzMz\nQxMDAwUDQ2NTczMGBQOauQgJlBYDfQ90SiKQkZmHWx1QWVoaHnMgXlGA00MEyHdzMMzOnBbC\nwPz28n2uJgOR44Xrq7tsHc/utNe/9FdihkmH3pZ7+zOTRFREzkzYJ99iHHDn4n0/Wb3E8Ceq\nS0uOdSyMMg9Z+WVvX0vJucxs77vrvZf2arWcvHP9wa1Yp9lRnJmC59/P9+43PXum+tj7Ga+8\nrtT+u3d941e765Y/bOrnvpv8X6jtz+wKqyk/v3n8P5xlO3l/1dn9q9Zotpy5funw/Of77Y/5\nLVltz7ToTl7dXf5ppmf3n9p+PPxz/sz/qjZn9yf9Y4R7I2Ft3tqfPTUMGgMYlEMSpGXmpBrT\n2A5Qvjc1xZ3/DTDyv5GJmfFo/qcHCMnILFYAIlA6UDDWU+DlGmgXjYJRMApGwSgYBaNgFIyC\nUTAKRsEoGAWjYBSMglEwCkbBKBgFo2AUjIJRMApGwSgYBaNgFIwCUgAAGnyo6wAoAAA=\n  EOS\n  FILETIMES = Time.utc(2004).to_i\n\n  TEST_CONTENTS = {\n    \"data.tar.gz\" => { :size => 210, :mode => 0644 },\n    \"file3\" => { :size => 18, :mode => 0755 },\n  }\n\n  TEST_DATA_CONTENTS = {\n    \"data/\" => { :size => 0, :mode => 0755 },\n    \"data/__dir__/\" => { :size => 0, :mode => 0755 },\n    \"data/file1\" => { :size => 16, :mode => 0644 },\n    \"data/file2\" => { :size => 16, :mode => 0644 },\n  }\n\n  def setup\n    FileUtils.mkdir_p(\"data__\")\n  end\n\n  def teardown\n    FileUtils.rm_rf(\"data__\")\n  end\n\n  def test_each_works\n    reader = Zlib::GzipReader.new(StringIO.new(TEST_TGZ))\n    Minitar::Input.open(reader) do |stream|\n      outer = 0\n      stream.each.with_index do |entry, i|\n        assert_kind_of(Minitar::Reader::EntryStream, entry)\n        assert TEST_CONTENTS.has_key?(entry.name)\n\n        assert_equal(TEST_CONTENTS[entry.name][:size], entry.size, entry.name)\n        assert_modes_equal(TEST_CONTENTS[entry.name][:mode],\n                           entry.mode, entry.name)\n        assert_equal(FILETIMES, entry.mtime, \"entry.mtime\")\n\n        if i.zero?\n          data_reader = Zlib::GzipReader.new(StringIO.new(entry.read))\n          Minitar::Input.open(data_reader) do |is2|\n            inner = 0\n            is2.each_with_index do |entry2, j|\n              assert_kind_of(Minitar::Reader::EntryStream, entry2)\n              assert TEST_DATA_CONTENTS.has_key?(entry2.name)\n              assert_equal(TEST_DATA_CONTENTS[entry2.name][:size], entry2.size,\n                           entry2.name)\n              assert_modes_equal(TEST_DATA_CONTENTS[entry2.name][:mode],\n                                 entry2.mode, entry2.name)\n              assert_equal(FILETIMES, entry2.mtime, entry2.name)\n              inner += 1\n            end\n            assert_equal(4, inner)\n          end\n        end\n\n        outer += 1\n      end\n\n      assert_equal(2, outer)\n    end\n  end\n\n  def test_extract_entry_works\n    reader = Zlib::GzipReader.new(StringIO.new(TEST_TGZ))\n    Minitar::Input.open(reader) do |stream|\n      outer_count = 0\n      stream.each_with_index do |entry, i|\n        stream.extract_entry(\"data__\", entry)\n        name = File.join(\"data__\", entry.name)\n\n        assert TEST_CONTENTS.has_key?(entry.name)\n\n        if entry.directory?\n          assert(File.directory?(name))\n        else\n          assert(File.file?(name))\n\n          assert_equal(TEST_CONTENTS[entry.name][:size], File.stat(name).size)\n        end\n\n        assert_modes_equal(TEST_CONTENTS[entry.name][:mode],\n                           File.stat(name).mode, entry.name)\n\n        if i.zero?\n          begin\n            ff    = File.open(name, \"rb\")\n            data_reader  = Zlib::GzipReader.new(ff)\n            Minitar::Input.open(data_reader) do |is2|\n              is2.each_with_index do |entry2, j|\n                is2.extract_entry(\"data__\", entry2)\n                name2 = File.join(\"data__\", entry2.name)\n\n                assert TEST_DATA_CONTENTS.has_key?(entry2.name)\n\n                if entry2.directory?\n                  assert(File.directory?(name2))\n                else\n                  assert(File.file?(name2))\n                  assert_equal(TEST_DATA_CONTENTS[entry2.name][:size],\n                               File.stat(name2).size)\n                end\n                assert_modes_equal(TEST_DATA_CONTENTS[entry2.name][:mode],\n                                   File.stat(name2).mode, name2)\n              end\n            end\n          ensure\n            ff.close unless ff.closed?\n          end\n        end\n\n        outer_count += 1\n      end\n\n      assert_equal(2, outer_count)\n    end\n  end\n\n  def test_extract_entry_breaks_symlinks\n    return if Minitar.windows?\n\n    IO.write('data__/file4', '')\n    File.symlink('data__/file4', 'data__/file3')\n    File.symlink('data__/file4', 'data__/data')\n\n    Minitar.unpack(Zlib::GzipReader.new(StringIO.new(TEST_TGZ)), 'data__')\n    Minitar.unpack(Zlib::GzipReader.new(File.open('data__/data.tar.gz', 'rb')),\n                   'data__')\n\n    refute File.symlink?('data__/file3')\n    refute File.symlink?('data__/data')\n  end\n\n  RELATIVE_DIRECTORY_TGZ = Base64.decode64 <<-EOS\nH4sICIIoKVgCA2JhZC1kaXIudGFyANPT0y8sTy0qqWSgHTAwMDAzMVEA0eZmpmDawAjChwEFQ2MDQyMg\nMDUzVDAwNDY0N2VQMGCgAygtLkksAjolEcjIzMOtDqgsLQ2/J0H+gNOjYBSMglEwyAEA2LchrwAGAAA=\n  EOS\n\n  def test_extract_entry_fails_with_relative_directory\n    reader = Zlib::GzipReader.new(StringIO.new(RELATIVE_DIRECTORY_TGZ))\n    Minitar::Input.open(reader) do |stream|\n      stream.each do |entry|\n        assert_raises Archive::Tar::Minitar::SecureRelativePathError do\n          stream.extract_entry(\"data__\", entry)\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["History.md", "lib/archive/tar/minitar.rb", "lib/archive/tar/minitar/input.rb", "minitar.gemspec", "test/test_tar_input.rb"], "buggy_code_start_loc": [9, 75, 99, 11, 75], "buggy_code_end_loc": [85, 86, 146, 12, 133], "fixing_code_start_loc": [10, 76, 100, 11, 76], "fixing_code_end_loc": [99, 92, 166, 12, 166], "type": "CWE-22", "message": "Directory traversal vulnerability in the minitar before 0.6 and archive-tar-minitar 0.5.2 gems for Ruby allows remote attackers to write to arbitrary files via a .. (dot dot) in a TAR archive entry.", "other": {"cve": {"id": "CVE-2016-10173", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-01T15:59:00.177", "lastModified": "2017-12-09T02:29:05.123", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in the minitar before 0.6 and archive-tar-minitar 0.5.2 gems for Ruby allows remote attackers to write to arbitrary files via a .. (dot dot) in a TAR archive entry."}, {"lang": "es", "value": "Vulnerabilidad de salto de directorio en versiones en las gemas para Ruby minitar en versiones anteriores a 0.6 y archive-tar-minitar 0.5.2 permite a atacantes remotos escribir archivos arbitrarios a trav\u00e9s de un .. (punto punto) en una entrada de archivo TAR."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minitar:archive-tar-minitar:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.2", "matchCriteriaId": "B9B28DAB-3949-4E98-8A06-278AED86949B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:minitar:minitar:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.4", "matchCriteriaId": "BE8EC005-0081-4584-A651-D6C6A1121D87"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3778", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/24/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/29/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95874", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/halostatue/minitar/commit/e25205ecbb6277ae8a3df1e6a306d7ed4458b6e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/halostatue/minitar/issues/16", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://puppet.com/security/cve/cve-2016-10173", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201702-32", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/halostatue/minitar/commit/e25205ecbb6277ae8a3df1e6a306d7ed4458b6e4"}}