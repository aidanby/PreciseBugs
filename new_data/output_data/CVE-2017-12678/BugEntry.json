{"buggy_code": ["/***************************************************************************\n    copyright            : (C) 2002 - 2008 by Scott Wheeler\n    email                : wheeler@kde.org\n ***************************************************************************/\n\n/***************************************************************************\n *   This library is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU Lesser General Public License version   *\n *   2.1 as published by the Free Software Foundation.                     *\n *                                                                         *\n *   This library is distributed in the hope that it will be useful, but   *\n *   WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *\n *   Lesser General Public License for more details.                       *\n *                                                                         *\n *   You should have received a copy of the GNU Lesser General Public      *\n *   License along with this library; if not, write to the Free Software   *\n *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *\n *   02110-1301  USA                                                       *\n *                                                                         *\n *   Alternatively, this file is available under the Mozilla Public        *\n *   License Version 1.1.  You may obtain a copy of the License at         *\n *   http://www.mozilla.org/MPL/                                           *\n ***************************************************************************/\n\n#include <tdebug.h>\n#include <tzlib.h>\n\n#include \"id3v2framefactory.h\"\n#include \"id3v2synchdata.h\"\n#include \"id3v1genres.h\"\n\n#include \"frames/attachedpictureframe.h\"\n#include \"frames/commentsframe.h\"\n#include \"frames/relativevolumeframe.h\"\n#include \"frames/textidentificationframe.h\"\n#include \"frames/uniquefileidentifierframe.h\"\n#include \"frames/unknownframe.h\"\n#include \"frames/generalencapsulatedobjectframe.h\"\n#include \"frames/urllinkframe.h\"\n#include \"frames/unsynchronizedlyricsframe.h\"\n#include \"frames/popularimeterframe.h\"\n#include \"frames/privateframe.h\"\n#include \"frames/ownershipframe.h\"\n#include \"frames/synchronizedlyricsframe.h\"\n#include \"frames/eventtimingcodesframe.h\"\n#include \"frames/chapterframe.h\"\n#include \"frames/tableofcontentsframe.h\"\n#include \"frames/podcastframe.h\"\n\nusing namespace TagLib;\nusing namespace ID3v2;\n\nnamespace\n{\n  void updateGenre(TextIdentificationFrame *frame)\n  {\n    StringList fields = frame->fieldList();\n    StringList newfields;\n\n    for(StringList::ConstIterator it = fields.begin(); it != fields.end(); ++it) {\n      String s = *it;\n      int end = s.find(\")\");\n\n      if(s.startsWith(\"(\") && end > 0) {\n        // \"(12)Genre\"\n        String text = s.substr(end + 1);\n        bool ok;\n        int number = s.substr(1, end - 1).toInt(&ok);\n        if(ok && number >= 0 && number <= 255 && !(ID3v1::genre(number) == text))\n          newfields.append(s.substr(1, end - 1));\n        if(!text.isEmpty())\n          newfields.append(text);\n      }\n      else {\n        // \"Genre\" or \"12\"\n        newfields.append(s);\n      }\n    }\n\n    if(newfields.isEmpty())\n      fields.append(String());\n\n    frame->setText(newfields);\n  }\n}\n\nclass FrameFactory::FrameFactoryPrivate\n{\npublic:\n  FrameFactoryPrivate() :\n    defaultEncoding(String::Latin1),\n    useDefaultEncoding(false) {}\n\n  String::Type defaultEncoding;\n  bool useDefaultEncoding;\n\n  template <class T> void setTextEncoding(T *frame)\n  {\n    if(useDefaultEncoding)\n      frame->setTextEncoding(defaultEncoding);\n  }\n};\n\nFrameFactory FrameFactory::factory;\n\n////////////////////////////////////////////////////////////////////////////////\n// public members\n////////////////////////////////////////////////////////////////////////////////\n\nFrameFactory *FrameFactory::instance()\n{\n  return &factory;\n}\n\nFrame *FrameFactory::createFrame(const ByteVector &data, bool synchSafeInts) const\n{\n  return createFrame(data, static_cast<unsigned int>(synchSafeInts ? 4 : 3));\n}\n\nFrame *FrameFactory::createFrame(const ByteVector &data, unsigned int version) const\n{\n  Header tagHeader;\n  tagHeader.setMajorVersion(version);\n  return createFrame(data, &tagHeader);\n}\n\nFrame *FrameFactory::createFrame(const ByteVector &origData, Header *tagHeader) const\n{\n  ByteVector data = origData;\n  unsigned int version = tagHeader->majorVersion();\n  Frame::Header *header = new Frame::Header(data, version);\n  ByteVector frameID = header->frameID();\n\n  // A quick sanity check -- make sure that the frameID is 4 uppercase Latin1\n  // characters.  Also make sure that there is data in the frame.\n\n  if(frameID.size() != (version < 3 ? 3 : 4) ||\n     header->frameSize() <= static_cast<unsigned int>(header->dataLengthIndicator() ? 4 : 0) ||\n     header->frameSize() > data.size())\n  {\n    delete header;\n    return 0;\n  }\n\n#ifndef NO_ITUNES_HACKS\n  if(version == 3 && frameID.size() == 4 && frameID[3] == '\\0') {\n    // iTunes v2.3 tags store v2.2 frames - convert now\n    frameID = frameID.mid(0, 3);\n    header->setFrameID(frameID);\n    header->setVersion(2);\n    updateFrame(header);\n    header->setVersion(3);\n  }\n#endif\n\n  for(ByteVector::ConstIterator it = frameID.begin(); it != frameID.end(); it++) {\n    if( (*it < 'A' || *it > 'Z') && (*it < '0' || *it > '9') ) {\n      delete header;\n      return 0;\n    }\n  }\n\n  if(version > 3 && (tagHeader->unsynchronisation() || header->unsynchronisation())) {\n    // Data lengths are not part of the encoded data, but since they are synch-safe\n    // integers they will be never actually encoded.\n    ByteVector frameData = data.mid(Frame::Header::size(version), header->frameSize());\n    frameData = SynchData::decode(frameData);\n    data = data.mid(0, Frame::Header::size(version)) + frameData;\n  }\n\n  // TagLib doesn't mess with encrypted frames, so just treat them\n  // as unknown frames.\n\n  if(!zlib::isAvailable() && header->compression()) {\n    debug(\"Compressed frames are currently not supported.\");\n    return new UnknownFrame(data, header);\n  }\n\n  if(header->encryption()) {\n    debug(\"Encrypted frames are currently not supported.\");\n    return new UnknownFrame(data, header);\n  }\n\n  if(!updateFrame(header)) {\n    header->setTagAlterPreservation(true);\n    return new UnknownFrame(data, header);\n  }\n\n  // updateFrame() might have updated the frame ID.\n\n  frameID = header->frameID();\n\n  // This is where things get necissarily nasty.  Here we determine which\n  // Frame subclass (or if none is found simply an Frame) based\n  // on the frame ID.  Since there are a lot of possibilities, that means\n  // a lot of if blocks.\n\n  // Text Identification (frames 4.2)\n\n  // Apple proprietary WFED (Podcast URL), MVNM (Movement Name), MVIN (Movement Number) are in fact text frames.\n  if(frameID.startsWith(\"T\") || frameID == \"WFED\" || frameID == \"MVNM\" || frameID == \"MVIN\") {\n\n    TextIdentificationFrame *f = frameID != \"TXXX\"\n      ? new TextIdentificationFrame(data, header)\n      : new UserTextIdentificationFrame(data, header);\n\n    d->setTextEncoding(f);\n\n    if(frameID == \"TCON\")\n      updateGenre(f);\n\n    return f;\n  }\n\n  // Comments (frames 4.10)\n\n  if(frameID == \"COMM\") {\n    CommentsFrame *f = new CommentsFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // Attached Picture (frames 4.14)\n\n  if(frameID == \"APIC\") {\n    AttachedPictureFrame *f = new AttachedPictureFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // ID3v2.2 Attached Picture\n\n  if(frameID == \"PIC\") {\n    AttachedPictureFrame *f = new AttachedPictureFrameV22(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // Relative Volume Adjustment (frames 4.11)\n\n  if(frameID == \"RVA2\")\n    return new RelativeVolumeFrame(data, header);\n\n  // Unique File Identifier (frames 4.1)\n\n  if(frameID == \"UFID\")\n    return new UniqueFileIdentifierFrame(data, header);\n\n  // General Encapsulated Object (frames 4.15)\n\n  if(frameID == \"GEOB\") {\n    GeneralEncapsulatedObjectFrame *f = new GeneralEncapsulatedObjectFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // URL link (frames 4.3)\n\n  if(frameID.startsWith(\"W\")) {\n    if(frameID != \"WXXX\") {\n      return new UrlLinkFrame(data, header);\n    }\n    else {\n      UserUrlLinkFrame *f = new UserUrlLinkFrame(data, header);\n      d->setTextEncoding(f);\n      return f;\n    }\n  }\n\n  // Unsynchronized lyric/text transcription (frames 4.8)\n\n  if(frameID == \"USLT\") {\n    UnsynchronizedLyricsFrame *f = new UnsynchronizedLyricsFrame(data, header);\n    if(d->useDefaultEncoding)\n      f->setTextEncoding(d->defaultEncoding);\n    return f;\n  }\n\n  // Synchronised lyrics/text (frames 4.9)\n\n  if(frameID == \"SYLT\") {\n    SynchronizedLyricsFrame *f = new SynchronizedLyricsFrame(data, header);\n    if(d->useDefaultEncoding)\n      f->setTextEncoding(d->defaultEncoding);\n    return f;\n  }\n\n  // Event timing codes (frames 4.5)\n\n  if(frameID == \"ETCO\")\n    return new EventTimingCodesFrame(data, header);\n\n  // Popularimeter (frames 4.17)\n\n  if(frameID == \"POPM\")\n    return new PopularimeterFrame(data, header);\n\n  // Private (frames 4.27)\n\n  if(frameID == \"PRIV\")\n    return new PrivateFrame(data, header);\n\n  // Ownership (frames 4.22)\n\n  if(frameID == \"OWNE\") {\n    OwnershipFrame *f = new OwnershipFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // Chapter (ID3v2 chapters 1.0)\n\n  if(frameID == \"CHAP\")\n    return new ChapterFrame(tagHeader, data, header);\n\n  // Table of contents (ID3v2 chapters 1.0)\n\n  if(frameID == \"CTOC\")\n    return new TableOfContentsFrame(tagHeader, data, header);\n\n  // Apple proprietary PCST (Podcast)\n\n  if(frameID == \"PCST\")\n    return new PodcastFrame(data, header);\n\n  return new UnknownFrame(data, header);\n}\n\nvoid FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nString::Type FrameFactory::defaultTextEncoding() const\n{\n  return d->defaultEncoding;\n}\n\nvoid FrameFactory::setDefaultTextEncoding(String::Type encoding)\n{\n  d->useDefaultEncoding = true;\n  d->defaultEncoding = encoding;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// protected members\n////////////////////////////////////////////////////////////////////////////////\n\nFrameFactory::FrameFactory() :\n  d(new FrameFactoryPrivate())\n{\n}\n\nFrameFactory::~FrameFactory()\n{\n  delete d;\n}\n\nnamespace\n{\n  // Frame conversion table ID3v2.2 -> 2.4\n  const char *frameConversion2[][2] = {\n    { \"BUF\", \"RBUF\" },\n    { \"CNT\", \"PCNT\" },\n    { \"COM\", \"COMM\" },\n    { \"CRA\", \"AENC\" },\n    { \"ETC\", \"ETCO\" },\n    { \"GEO\", \"GEOB\" },\n    { \"IPL\", \"TIPL\" },\n    { \"MCI\", \"MCDI\" },\n    { \"MLL\", \"MLLT\" },\n    { \"POP\", \"POPM\" },\n    { \"REV\", \"RVRB\" },\n    { \"SLT\", \"SYLT\" },\n    { \"STC\", \"SYTC\" },\n    { \"TAL\", \"TALB\" },\n    { \"TBP\", \"TBPM\" },\n    { \"TCM\", \"TCOM\" },\n    { \"TCO\", \"TCON\" },\n    { \"TCP\", \"TCMP\" },\n    { \"TCR\", \"TCOP\" },\n    { \"TDY\", \"TDLY\" },\n    { \"TEN\", \"TENC\" },\n    { \"TFT\", \"TFLT\" },\n    { \"TKE\", \"TKEY\" },\n    { \"TLA\", \"TLAN\" },\n    { \"TLE\", \"TLEN\" },\n    { \"TMT\", \"TMED\" },\n    { \"TOA\", \"TOAL\" },\n    { \"TOF\", \"TOFN\" },\n    { \"TOL\", \"TOLY\" },\n    { \"TOR\", \"TDOR\" },\n    { \"TOT\", \"TOAL\" },\n    { \"TP1\", \"TPE1\" },\n    { \"TP2\", \"TPE2\" },\n    { \"TP3\", \"TPE3\" },\n    { \"TP4\", \"TPE4\" },\n    { \"TPA\", \"TPOS\" },\n    { \"TPB\", \"TPUB\" },\n    { \"TRC\", \"TSRC\" },\n    { \"TRD\", \"TDRC\" },\n    { \"TRK\", \"TRCK\" },\n    { \"TS2\", \"TSO2\" },\n    { \"TSA\", \"TSOA\" },\n    { \"TSC\", \"TSOC\" },\n    { \"TSP\", \"TSOP\" },\n    { \"TSS\", \"TSSE\" },\n    { \"TST\", \"TSOT\" },\n    { \"TT1\", \"TIT1\" },\n    { \"TT2\", \"TIT2\" },\n    { \"TT3\", \"TIT3\" },\n    { \"TXT\", \"TOLY\" },\n    { \"TXX\", \"TXXX\" },\n    { \"TYE\", \"TDRC\" },\n    { \"UFI\", \"UFID\" },\n    { \"ULT\", \"USLT\" },\n    { \"WAF\", \"WOAF\" },\n    { \"WAR\", \"WOAR\" },\n    { \"WAS\", \"WOAS\" },\n    { \"WCM\", \"WCOM\" },\n    { \"WCP\", \"WCOP\" },\n    { \"WPB\", \"WPUB\" },\n    { \"WXX\", \"WXXX\" },\n\n    // Apple iTunes nonstandard frames\n    { \"PCS\", \"PCST\" },\n    { \"TCT\", \"TCAT\" },\n    { \"TDR\", \"TDRL\" },\n    { \"TDS\", \"TDES\" },\n    { \"TID\", \"TGID\" },\n    { \"WFD\", \"WFED\" },\n    { \"MVN\", \"MVNM\" },\n    { \"MVI\", \"MVIN\" },\n  };\n  const size_t frameConversion2Size = sizeof(frameConversion2) / sizeof(frameConversion2[0]);\n\n  // Frame conversion table ID3v2.3 -> 2.4\n  const char *frameConversion3[][2] = {\n    { \"TORY\", \"TDOR\" },\n    { \"TYER\", \"TDRC\" },\n    { \"IPLS\", \"TIPL\" },\n  };\n  const size_t frameConversion3Size = sizeof(frameConversion3) / sizeof(frameConversion3[0]);\n}\n\nbool FrameFactory::updateFrame(Frame::Header *header) const\n{\n  const ByteVector frameID = header->frameID();\n\n  switch(header->version()) {\n\n  case 2: // ID3v2.2\n  {\n    if(frameID == \"CRM\" ||\n       frameID == \"EQU\" ||\n       frameID == \"LNK\" ||\n       frameID == \"RVA\" ||\n       frameID == \"TIM\" ||\n       frameID == \"TSI\" ||\n       frameID == \"TDA\")\n    {\n      debug(\"ID3v2.4 no longer supports the frame type \" + String(frameID) +\n            \".  It will be discarded from the tag.\");\n      return false;\n    }\n\n    // ID3v2.2 only used 3 bytes for the frame ID, so we need to convert all of\n    // the frames to their 4 byte ID3v2.4 equivalent.\n\n    for(size_t i = 0; i < frameConversion2Size; ++i) {\n      if(frameID == frameConversion2[i][0]) {\n        header->setFrameID(frameConversion2[i][1]);\n        break;\n      }\n    }\n\n    break;\n  }\n\n  case 3: // ID3v2.3\n  {\n    if(frameID == \"EQUA\" ||\n       frameID == \"RVAD\" ||\n       frameID == \"TIME\" ||\n       frameID == \"TRDA\" ||\n       frameID == \"TSIZ\" ||\n       frameID == \"TDAT\")\n    {\n      debug(\"ID3v2.4 no longer supports the frame type \" + String(frameID) +\n            \".  It will be discarded from the tag.\");\n      return false;\n    }\n\n    for(size_t i = 0; i < frameConversion3Size; ++i) {\n      if(frameID == frameConversion3[i][0]) {\n        header->setFrameID(frameConversion3[i][1]);\n        break;\n      }\n    }\n\n    break;\n  }\n\n  default:\n\n    // This should catch a typo that existed in TagLib up to and including\n    // version 1.1 where TRDC was used for the year rather than TDRC.\n\n    if(frameID == \"TRDC\")\n      header->setFrameID(\"TDRC\");\n\n    break;\n  }\n\n  return true;\n}\n"], "fixing_code": ["/***************************************************************************\n    copyright            : (C) 2002 - 2008 by Scott Wheeler\n    email                : wheeler@kde.org\n ***************************************************************************/\n\n/***************************************************************************\n *   This library is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU Lesser General Public License version   *\n *   2.1 as published by the Free Software Foundation.                     *\n *                                                                         *\n *   This library is distributed in the hope that it will be useful, but   *\n *   WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *\n *   Lesser General Public License for more details.                       *\n *                                                                         *\n *   You should have received a copy of the GNU Lesser General Public      *\n *   License along with this library; if not, write to the Free Software   *\n *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *\n *   02110-1301  USA                                                       *\n *                                                                         *\n *   Alternatively, this file is available under the Mozilla Public        *\n *   License Version 1.1.  You may obtain a copy of the License at         *\n *   http://www.mozilla.org/MPL/                                           *\n ***************************************************************************/\n\n#include <tdebug.h>\n#include <tzlib.h>\n\n#include \"id3v2framefactory.h\"\n#include \"id3v2synchdata.h\"\n#include \"id3v1genres.h\"\n\n#include \"frames/attachedpictureframe.h\"\n#include \"frames/commentsframe.h\"\n#include \"frames/relativevolumeframe.h\"\n#include \"frames/textidentificationframe.h\"\n#include \"frames/uniquefileidentifierframe.h\"\n#include \"frames/unknownframe.h\"\n#include \"frames/generalencapsulatedobjectframe.h\"\n#include \"frames/urllinkframe.h\"\n#include \"frames/unsynchronizedlyricsframe.h\"\n#include \"frames/popularimeterframe.h\"\n#include \"frames/privateframe.h\"\n#include \"frames/ownershipframe.h\"\n#include \"frames/synchronizedlyricsframe.h\"\n#include \"frames/eventtimingcodesframe.h\"\n#include \"frames/chapterframe.h\"\n#include \"frames/tableofcontentsframe.h\"\n#include \"frames/podcastframe.h\"\n\nusing namespace TagLib;\nusing namespace ID3v2;\n\nnamespace\n{\n  void updateGenre(TextIdentificationFrame *frame)\n  {\n    StringList fields = frame->fieldList();\n    StringList newfields;\n\n    for(StringList::ConstIterator it = fields.begin(); it != fields.end(); ++it) {\n      String s = *it;\n      int end = s.find(\")\");\n\n      if(s.startsWith(\"(\") && end > 0) {\n        // \"(12)Genre\"\n        String text = s.substr(end + 1);\n        bool ok;\n        int number = s.substr(1, end - 1).toInt(&ok);\n        if(ok && number >= 0 && number <= 255 && !(ID3v1::genre(number) == text))\n          newfields.append(s.substr(1, end - 1));\n        if(!text.isEmpty())\n          newfields.append(text);\n      }\n      else {\n        // \"Genre\" or \"12\"\n        newfields.append(s);\n      }\n    }\n\n    if(newfields.isEmpty())\n      fields.append(String());\n\n    frame->setText(newfields);\n  }\n}\n\nclass FrameFactory::FrameFactoryPrivate\n{\npublic:\n  FrameFactoryPrivate() :\n    defaultEncoding(String::Latin1),\n    useDefaultEncoding(false) {}\n\n  String::Type defaultEncoding;\n  bool useDefaultEncoding;\n\n  template <class T> void setTextEncoding(T *frame)\n  {\n    if(useDefaultEncoding)\n      frame->setTextEncoding(defaultEncoding);\n  }\n};\n\nFrameFactory FrameFactory::factory;\n\n////////////////////////////////////////////////////////////////////////////////\n// public members\n////////////////////////////////////////////////////////////////////////////////\n\nFrameFactory *FrameFactory::instance()\n{\n  return &factory;\n}\n\nFrame *FrameFactory::createFrame(const ByteVector &data, bool synchSafeInts) const\n{\n  return createFrame(data, static_cast<unsigned int>(synchSafeInts ? 4 : 3));\n}\n\nFrame *FrameFactory::createFrame(const ByteVector &data, unsigned int version) const\n{\n  Header tagHeader;\n  tagHeader.setMajorVersion(version);\n  return createFrame(data, &tagHeader);\n}\n\nFrame *FrameFactory::createFrame(const ByteVector &origData, Header *tagHeader) const\n{\n  ByteVector data = origData;\n  unsigned int version = tagHeader->majorVersion();\n  Frame::Header *header = new Frame::Header(data, version);\n  ByteVector frameID = header->frameID();\n\n  // A quick sanity check -- make sure that the frameID is 4 uppercase Latin1\n  // characters.  Also make sure that there is data in the frame.\n\n  if(frameID.size() != (version < 3 ? 3 : 4) ||\n     header->frameSize() <= static_cast<unsigned int>(header->dataLengthIndicator() ? 4 : 0) ||\n     header->frameSize() > data.size())\n  {\n    delete header;\n    return 0;\n  }\n\n#ifndef NO_ITUNES_HACKS\n  if(version == 3 && frameID.size() == 4 && frameID[3] == '\\0') {\n    // iTunes v2.3 tags store v2.2 frames - convert now\n    frameID = frameID.mid(0, 3);\n    header->setFrameID(frameID);\n    header->setVersion(2);\n    updateFrame(header);\n    header->setVersion(3);\n  }\n#endif\n\n  for(ByteVector::ConstIterator it = frameID.begin(); it != frameID.end(); it++) {\n    if( (*it < 'A' || *it > 'Z') && (*it < '0' || *it > '9') ) {\n      delete header;\n      return 0;\n    }\n  }\n\n  if(version > 3 && (tagHeader->unsynchronisation() || header->unsynchronisation())) {\n    // Data lengths are not part of the encoded data, but since they are synch-safe\n    // integers they will be never actually encoded.\n    ByteVector frameData = data.mid(Frame::Header::size(version), header->frameSize());\n    frameData = SynchData::decode(frameData);\n    data = data.mid(0, Frame::Header::size(version)) + frameData;\n  }\n\n  // TagLib doesn't mess with encrypted frames, so just treat them\n  // as unknown frames.\n\n  if(!zlib::isAvailable() && header->compression()) {\n    debug(\"Compressed frames are currently not supported.\");\n    return new UnknownFrame(data, header);\n  }\n\n  if(header->encryption()) {\n    debug(\"Encrypted frames are currently not supported.\");\n    return new UnknownFrame(data, header);\n  }\n\n  if(!updateFrame(header)) {\n    header->setTagAlterPreservation(true);\n    return new UnknownFrame(data, header);\n  }\n\n  // updateFrame() might have updated the frame ID.\n\n  frameID = header->frameID();\n\n  // This is where things get necissarily nasty.  Here we determine which\n  // Frame subclass (or if none is found simply an Frame) based\n  // on the frame ID.  Since there are a lot of possibilities, that means\n  // a lot of if blocks.\n\n  // Text Identification (frames 4.2)\n\n  // Apple proprietary WFED (Podcast URL), MVNM (Movement Name), MVIN (Movement Number) are in fact text frames.\n  if(frameID.startsWith(\"T\") || frameID == \"WFED\" || frameID == \"MVNM\" || frameID == \"MVIN\") {\n\n    TextIdentificationFrame *f = frameID != \"TXXX\"\n      ? new TextIdentificationFrame(data, header)\n      : new UserTextIdentificationFrame(data, header);\n\n    d->setTextEncoding(f);\n\n    if(frameID == \"TCON\")\n      updateGenre(f);\n\n    return f;\n  }\n\n  // Comments (frames 4.10)\n\n  if(frameID == \"COMM\") {\n    CommentsFrame *f = new CommentsFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // Attached Picture (frames 4.14)\n\n  if(frameID == \"APIC\") {\n    AttachedPictureFrame *f = new AttachedPictureFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // ID3v2.2 Attached Picture\n\n  if(frameID == \"PIC\") {\n    AttachedPictureFrame *f = new AttachedPictureFrameV22(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // Relative Volume Adjustment (frames 4.11)\n\n  if(frameID == \"RVA2\")\n    return new RelativeVolumeFrame(data, header);\n\n  // Unique File Identifier (frames 4.1)\n\n  if(frameID == \"UFID\")\n    return new UniqueFileIdentifierFrame(data, header);\n\n  // General Encapsulated Object (frames 4.15)\n\n  if(frameID == \"GEOB\") {\n    GeneralEncapsulatedObjectFrame *f = new GeneralEncapsulatedObjectFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // URL link (frames 4.3)\n\n  if(frameID.startsWith(\"W\")) {\n    if(frameID != \"WXXX\") {\n      return new UrlLinkFrame(data, header);\n    }\n    else {\n      UserUrlLinkFrame *f = new UserUrlLinkFrame(data, header);\n      d->setTextEncoding(f);\n      return f;\n    }\n  }\n\n  // Unsynchronized lyric/text transcription (frames 4.8)\n\n  if(frameID == \"USLT\") {\n    UnsynchronizedLyricsFrame *f = new UnsynchronizedLyricsFrame(data, header);\n    if(d->useDefaultEncoding)\n      f->setTextEncoding(d->defaultEncoding);\n    return f;\n  }\n\n  // Synchronised lyrics/text (frames 4.9)\n\n  if(frameID == \"SYLT\") {\n    SynchronizedLyricsFrame *f = new SynchronizedLyricsFrame(data, header);\n    if(d->useDefaultEncoding)\n      f->setTextEncoding(d->defaultEncoding);\n    return f;\n  }\n\n  // Event timing codes (frames 4.5)\n\n  if(frameID == \"ETCO\")\n    return new EventTimingCodesFrame(data, header);\n\n  // Popularimeter (frames 4.17)\n\n  if(frameID == \"POPM\")\n    return new PopularimeterFrame(data, header);\n\n  // Private (frames 4.27)\n\n  if(frameID == \"PRIV\")\n    return new PrivateFrame(data, header);\n\n  // Ownership (frames 4.22)\n\n  if(frameID == \"OWNE\") {\n    OwnershipFrame *f = new OwnershipFrame(data, header);\n    d->setTextEncoding(f);\n    return f;\n  }\n\n  // Chapter (ID3v2 chapters 1.0)\n\n  if(frameID == \"CHAP\")\n    return new ChapterFrame(tagHeader, data, header);\n\n  // Table of contents (ID3v2 chapters 1.0)\n\n  if(frameID == \"CTOC\")\n    return new TableOfContentsFrame(tagHeader, data, header);\n\n  // Apple proprietary PCST (Podcast)\n\n  if(frameID == \"PCST\")\n    return new PodcastFrame(data, header);\n\n  return new UnknownFrame(data, header);\n}\n\nvoid FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      dynamic_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n\n    if(tdrc &&\n       tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nString::Type FrameFactory::defaultTextEncoding() const\n{\n  return d->defaultEncoding;\n}\n\nvoid FrameFactory::setDefaultTextEncoding(String::Type encoding)\n{\n  d->useDefaultEncoding = true;\n  d->defaultEncoding = encoding;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// protected members\n////////////////////////////////////////////////////////////////////////////////\n\nFrameFactory::FrameFactory() :\n  d(new FrameFactoryPrivate())\n{\n}\n\nFrameFactory::~FrameFactory()\n{\n  delete d;\n}\n\nnamespace\n{\n  // Frame conversion table ID3v2.2 -> 2.4\n  const char *frameConversion2[][2] = {\n    { \"BUF\", \"RBUF\" },\n    { \"CNT\", \"PCNT\" },\n    { \"COM\", \"COMM\" },\n    { \"CRA\", \"AENC\" },\n    { \"ETC\", \"ETCO\" },\n    { \"GEO\", \"GEOB\" },\n    { \"IPL\", \"TIPL\" },\n    { \"MCI\", \"MCDI\" },\n    { \"MLL\", \"MLLT\" },\n    { \"POP\", \"POPM\" },\n    { \"REV\", \"RVRB\" },\n    { \"SLT\", \"SYLT\" },\n    { \"STC\", \"SYTC\" },\n    { \"TAL\", \"TALB\" },\n    { \"TBP\", \"TBPM\" },\n    { \"TCM\", \"TCOM\" },\n    { \"TCO\", \"TCON\" },\n    { \"TCP\", \"TCMP\" },\n    { \"TCR\", \"TCOP\" },\n    { \"TDY\", \"TDLY\" },\n    { \"TEN\", \"TENC\" },\n    { \"TFT\", \"TFLT\" },\n    { \"TKE\", \"TKEY\" },\n    { \"TLA\", \"TLAN\" },\n    { \"TLE\", \"TLEN\" },\n    { \"TMT\", \"TMED\" },\n    { \"TOA\", \"TOAL\" },\n    { \"TOF\", \"TOFN\" },\n    { \"TOL\", \"TOLY\" },\n    { \"TOR\", \"TDOR\" },\n    { \"TOT\", \"TOAL\" },\n    { \"TP1\", \"TPE1\" },\n    { \"TP2\", \"TPE2\" },\n    { \"TP3\", \"TPE3\" },\n    { \"TP4\", \"TPE4\" },\n    { \"TPA\", \"TPOS\" },\n    { \"TPB\", \"TPUB\" },\n    { \"TRC\", \"TSRC\" },\n    { \"TRD\", \"TDRC\" },\n    { \"TRK\", \"TRCK\" },\n    { \"TS2\", \"TSO2\" },\n    { \"TSA\", \"TSOA\" },\n    { \"TSC\", \"TSOC\" },\n    { \"TSP\", \"TSOP\" },\n    { \"TSS\", \"TSSE\" },\n    { \"TST\", \"TSOT\" },\n    { \"TT1\", \"TIT1\" },\n    { \"TT2\", \"TIT2\" },\n    { \"TT3\", \"TIT3\" },\n    { \"TXT\", \"TOLY\" },\n    { \"TXX\", \"TXXX\" },\n    { \"TYE\", \"TDRC\" },\n    { \"UFI\", \"UFID\" },\n    { \"ULT\", \"USLT\" },\n    { \"WAF\", \"WOAF\" },\n    { \"WAR\", \"WOAR\" },\n    { \"WAS\", \"WOAS\" },\n    { \"WCM\", \"WCOM\" },\n    { \"WCP\", \"WCOP\" },\n    { \"WPB\", \"WPUB\" },\n    { \"WXX\", \"WXXX\" },\n\n    // Apple iTunes nonstandard frames\n    { \"PCS\", \"PCST\" },\n    { \"TCT\", \"TCAT\" },\n    { \"TDR\", \"TDRL\" },\n    { \"TDS\", \"TDES\" },\n    { \"TID\", \"TGID\" },\n    { \"WFD\", \"WFED\" },\n    { \"MVN\", \"MVNM\" },\n    { \"MVI\", \"MVIN\" },\n  };\n  const size_t frameConversion2Size = sizeof(frameConversion2) / sizeof(frameConversion2[0]);\n\n  // Frame conversion table ID3v2.3 -> 2.4\n  const char *frameConversion3[][2] = {\n    { \"TORY\", \"TDOR\" },\n    { \"TYER\", \"TDRC\" },\n    { \"IPLS\", \"TIPL\" },\n  };\n  const size_t frameConversion3Size = sizeof(frameConversion3) / sizeof(frameConversion3[0]);\n}\n\nbool FrameFactory::updateFrame(Frame::Header *header) const\n{\n  const ByteVector frameID = header->frameID();\n\n  switch(header->version()) {\n\n  case 2: // ID3v2.2\n  {\n    if(frameID == \"CRM\" ||\n       frameID == \"EQU\" ||\n       frameID == \"LNK\" ||\n       frameID == \"RVA\" ||\n       frameID == \"TIM\" ||\n       frameID == \"TSI\" ||\n       frameID == \"TDA\")\n    {\n      debug(\"ID3v2.4 no longer supports the frame type \" + String(frameID) +\n            \".  It will be discarded from the tag.\");\n      return false;\n    }\n\n    // ID3v2.2 only used 3 bytes for the frame ID, so we need to convert all of\n    // the frames to their 4 byte ID3v2.4 equivalent.\n\n    for(size_t i = 0; i < frameConversion2Size; ++i) {\n      if(frameID == frameConversion2[i][0]) {\n        header->setFrameID(frameConversion2[i][1]);\n        break;\n      }\n    }\n\n    break;\n  }\n\n  case 3: // ID3v2.3\n  {\n    if(frameID == \"EQUA\" ||\n       frameID == \"RVAD\" ||\n       frameID == \"TIME\" ||\n       frameID == \"TRDA\" ||\n       frameID == \"TSIZ\" ||\n       frameID == \"TDAT\")\n    {\n      debug(\"ID3v2.4 no longer supports the frame type \" + String(frameID) +\n            \".  It will be discarded from the tag.\");\n      return false;\n    }\n\n    for(size_t i = 0; i < frameConversion3Size; ++i) {\n      if(frameID == frameConversion3[i][0]) {\n        header->setFrameID(frameConversion3[i][1]);\n        break;\n      }\n    }\n\n    break;\n  }\n\n  default:\n\n    // This should catch a typo that existed in TagLib up to and including\n    // version 1.1 where TRDC was used for the year rather than TDRC.\n\n    if(frameID == \"TRDC\")\n      header->setFrameID(\"TDRC\");\n\n    break;\n  }\n\n  return true;\n}\n"], "filenames": ["taglib/mpeg/id3v2/id3v2framefactory.cpp"], "buggy_code_start_loc": [337], "buggy_code_end_loc": [341], "fixing_code_start_loc": [337], "fixing_code_end_loc": [342], "type": "CWE-434", "message": "In TagLib 1.11.1, the rebuildAggregateFrames function in id3v2framefactory.cpp has a pointer to cast vulnerability, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted audio file.", "other": {"cve": {"id": "CVE-2017-12678", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-08T01:34:00.080", "lastModified": "2021-10-18T12:11:54.023", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In TagLib 1.11.1, the rebuildAggregateFrames function in id3v2framefactory.cpp has a pointer to cast vulnerability, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted audio file."}, {"lang": "es", "value": "En TagLib 1.11.1, la funci\u00f3n rebuildAggregateFrames en id3v2framefactory.cpp tiene una vulnerabilidad del tipo pointer to cast, que permite que atacantes remotos provoquen una denegaci\u00f3n de servicio u otro tipo de errores no especificados mediante un archivo de audio manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:taglib:taglib:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "DFA80713-7FB3-4FBC-B1A8-D9B84913CA53"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/taglib/taglib/commit/cb9f07d9dcd791b63e622da43f7b232adaec0a9a", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/taglib/taglib/issues/829", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/taglib/taglib/pull/831", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/09/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/taglib/taglib/commit/cb9f07d9dcd791b63e622da43f7b232adaec0a9a"}}