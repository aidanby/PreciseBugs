{"buggy_code": ["/*\n * MinIO Cloud Storage, (C) 2015-2018 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\txhttp \"github.com/minio/minio/cmd/http\"\n\txjwt \"github.com/minio/minio/cmd/jwt\"\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/auth\"\n\tobjectlock \"github.com/minio/minio/pkg/bucket/object/lock\"\n\t\"github.com/minio/minio/pkg/bucket/policy\"\n\t\"github.com/minio/minio/pkg/hash\"\n\tiampolicy \"github.com/minio/minio/pkg/iam/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(xhttp.Authorization), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.URL.Query()[xhttp.AmzCredential]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.URL.Query()[xhttp.AmzAccessKeyID]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\treturn strings.Contains(r.Header.Get(xhttp.ContentType), \"multipart/form-data\") &&\n\t\tr.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Authorization type.\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n\tauthTypeSTS\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) authType {\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.URL.Query()[xhttp.Action]; ok {\n\t\treturn authTypeSTS\n\t} else if _, ok := r.Header[xhttp.Authorization]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\nfunc validateAdminSignature(ctx context.Context, r *http.Request, region string) (auth.Credentials, map[string]interface{}, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\ts3Err := ErrAccessDenied\n\tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n\t\tgetRequestAuthType(r) == authTypeSigned && !skipContentSha256Cksum(r) {\n\t\t// We only support admin credentials to access admin APIs.\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t\tif s3Err != ErrNone {\n\t\t\treturn cred, nil, owner, s3Err\n\t\t}\n\n\t\t// we only support V4 (no presign) with auth body\n\t\ts3Err = isReqAuthenticated(ctx, r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treqInfo := (&logger.ReqInfo{}).AppendTags(\"requestHeaders\", dumpRequest(r))\n\t\tctx := logger.SetReqInfo(ctx, reqInfo)\n\t\tlogger.LogIf(ctx, errors.New(getAPIError(s3Err).Description), logger.Application)\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, nil, owner, s3Err\n\t}\n\n\treturn cred, claims, owner, ErrNone\n}\n\n// checkAdminRequestAuthType checks whether the request is a valid signature V2 or V4 request.\n// It does not accept presigned or JWT or anonymous requests.\nfunc checkAdminRequestAuthType(ctx context.Context, r *http.Request, action iampolicy.AdminAction, region string) (auth.Credentials, APIErrorCode) {\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, region)\n\tif s3Err != ErrNone {\n\t\treturn cred, s3Err\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.Action(action),\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred, ErrNone\n\t}\n\n\treturn cred, ErrAccessDenied\n}\n\n// Fetch the security token set by the client.\nfunc getSessionToken(r *http.Request) (token string) {\n\ttoken = r.Header.Get(xhttp.AmzSecurityToken)\n\tif token != \"\" {\n\t\treturn token\n\t}\n\treturn r.URL.Query().Get(xhttp.AmzSecurityToken)\n}\n\n// Fetch claims in the security token returned by the client, doesn't return\n// errors - upon errors the returned claims map will be empty.\nfunc mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n\tclaims, _ := getClaimsFromToken(r, getSessionToken(r))\n\treturn claims\n}\n\n// Fetch claims in the security token returned by the client.\nfunc getClaimsFromToken(r *http.Request, token string) (map[string]interface{}, error) {\n\tclaims := xjwt.NewMapClaims()\n\tif token == \"\" {\n\t\treturn claims.Map(), nil\n\t}\n\n\tstsTokenCallback := func(claims *xjwt.MapClaims) ([]byte, error) {\n\t\t// JWT token for x-amz-security-token is signed with admin\n\t\t// secret key, temporary credentials become invalid if\n\t\t// server admin credentials change. This is done to ensure\n\t\t// that clients cannot decode the token using the temp\n\t\t// secret keys and generate an entirely new claim by essentially\n\t\t// hijacking the policies. We need to make sure that this is\n\t\t// based an admin credential such that token cannot be decoded\n\t\t// on the client side and is treated like an opaque value.\n\t\treturn []byte(globalActiveCred.SecretKey), nil\n\t}\n\n\tif err := xjwt.ParseWithClaims(token, claims, stsTokenCallback); err != nil {\n\t\treturn nil, errAuthentication\n\t}\n\n\tif globalPolicyOPA == nil {\n\t\t// If OPA is not set and if ldap claim key is set, allow the claim.\n\t\tif _, ok := claims.Lookup(ldapUser); ok {\n\t\t\treturn claims.Map(), nil\n\t\t}\n\n\t\t// If OPA is not set, session token should\n\t\t// have a policy and its mandatory, reject\n\t\t// requests without policy claim.\n\t\t_, pokOpenID := claims.Lookup(iamPolicyClaimNameOpenID())\n\t\t_, pokSA := claims.Lookup(iamPolicyClaimNameSA())\n\t\tif !pokOpenID && !pokSA {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\n\t\tsp, spok := claims.Lookup(iampolicy.SessionPolicyName)\n\t\tif !spok {\n\t\t\treturn claims.Map(), nil\n\t\t}\n\t\t// Looks like subpolicy is set and is a string, if set then its\n\t\t// base64 encoded, decode it. Decoding fails reject such requests.\n\t\tspBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\t// Base64 decoding fails, we should log to indicate\n\t\t\t// something is malforming the request sent by client.\n\t\t\tlogger.LogIf(r.Context(), err, logger.Application)\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims.MapClaims[iampolicy.SessionPolicyName] = string(spBytes)\n\t}\n\n\treturn claims.Map(), nil\n}\n\n// Fetch claims in the security token returned by the client and validate the token.\nfunc checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]interface{}, APIErrorCode) {\n\ttoken := getSessionToken(r)\n\tif token != \"\" && cred.AccessKey == \"\" {\n\t\treturn nil, ErrNoAccessKey\n\t}\n\tif cred.IsServiceAccount() && token == \"\" {\n\t\ttoken = cred.SessionToken\n\t}\n\tif subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n\t\treturn nil, ErrInvalidToken\n\t}\n\tclaims, err := getClaimsFromToken(r, token)\n\tif err != nil {\n\t\treturn nil, toAPIErrorCode(r.Context(), err)\n\t}\n\treturn claims, ErrNone\n}\n\n// Check request auth type verifies the incoming http request\n// - validates the request signature\n// - validates the policy action if anonymous tests bucket policies if any,\n//   for authenticated requests validates IAM policies.\n// returns APIErrorCode if any to be replied to the client.\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (s3Err APIErrorCode) {\n\t_, _, s3Err = checkRequestAuthTypeToAccessKey(ctx, r, action, bucketName, objectName)\n\treturn s3Err\n}\n\n// Check request auth type verifies the incoming http request\n// - validates the request signature\n// - validates the policy action if anonymous tests bucket policies if any,\n//   for authenticated requests validates IAM policies.\n// returns APIErrorCode if any to be replied to the client.\n// Additionally returns the accessKey used in the request, and if this request is by an admin.\nfunc checkRequestAuthTypeToAccessKey(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (accessKey string, owner bool, s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn accessKey, owner, ErrSignatureVersionNotSupported\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn accessKey, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalServerRegion\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\t\tif s3Err = isReqAuthenticated(ctx, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn accessKey, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn accessKey, owner, s3Err\n\t}\n\n\tvar claims map[string]interface{}\n\tclaims, s3Err = checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn accessKey, owner, s3Err\n\t}\n\n\t// LocationConstraint is valid only for CreateBucketAction.\n\tvar locationConstraint string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := ioutil.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err, logger.Application)\n\t\t\treturn accessKey, owner, ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\n\t\tvar s3Error APIErrorCode\n\t\tlocationConstraint, s3Error = parseLocationConstraint(r)\n\t\tif s3Error != ErrNone {\n\t\t\treturn accessKey, owner, s3Error\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, locationConstraint, \"\", nil),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn cred.AccessKey, owner, ErrNone\n\t\t}\n\t\treturn cred.AccessKey, owner, ErrAccessDenied\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.Action(action),\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred.AccessKey, owner, ErrNone\n\t}\n\treturn cred.AccessKey, owner, ErrAccessDenied\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r, stype)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region, stype)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region, stype)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(ctx context.Context, r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region, stype); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tvar (\n\t\terr                       error\n\t\tcontentMD5, contentSHA256 []byte\n\t)\n\n\t// Extract 'Content-Md5' if present.\n\tcontentMD5, err = checkValidMD5(r.Header)\n\tif err != nil {\n\t\treturn ErrInvalidDigest\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.URL.Query()[xhttp.AmzContentSha256]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[xhttp.AmzContentSha256]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(xhttp.AmzContentSha256))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(r.Body, -1, hex.EncodeToString(contentMD5),\n\t\thex.EncodeToString(contentSHA256), -1, globalCLIContext.StrictS3Compat)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\tr.Body = ioutil.NopCloser(reader)\n\treturn ErrNone\n}\n\n// authHandler - handles all the incoming authorization headers and validates them if possible.\ntype authHandler struct {\n\thandler http.Handler\n}\n\n// setAuthHandler to validate authorization header for the incoming request.\nfunc setAuthHandler(h http.Handler) http.Handler {\n\treturn authHandler{h}\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:       {},\n\tauthTypePresigned:       {},\n\tauthTypePresignedV2:     {},\n\tauthTypeSigned:          {},\n\tauthTypeSignedV2:        {},\n\tauthTypePostPolicy:      {},\n\tauthTypeStreamingSigned: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// handler for validating incoming authorization headers.\nfunc (a authHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\taType := getRequestAuthType(r)\n\tif isSupportedS3AuthType(aType) {\n\t\t// Let top level caller validate for anonymous and known signed requests.\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t} else if aType == authTypeJWT {\n\t\t// Validate Authorization header if its valid for JWT request.\n\t\tif _, _, authErr := webRequestAuthenticate(r); authErr != nil {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t} else if aType == authTypeSTS {\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrSignatureVersionNotSupported), r.URL, guessIsBrowserReq(r))\n}\n\nfunc validateSignature(atype authType, r *http.Request) (auth.Credentials, bool, map[string]interface{}, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tvar s3Err APIErrorCode\n\tswitch atype {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn cred, owner, nil, ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn cred, owner, nil, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypePresigned, authTypeSigned:\n\t\tregion := globalServerRegion\n\t\tif s3Err = isReqAuthenticated(GlobalContext, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn cred, owner, nil, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, nil, s3Err\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, nil, s3Err\n\t}\n\n\treturn cred, owner, claims, ErrNone\n}\n\nfunc isPutRetentionAllowed(bucketName, objectName string, retDays int, retDate time.Time, retMode objectlock.RetMode, byPassSet bool, r *http.Request, cred auth.Credentials, owner bool, claims map[string]interface{}) (s3Err APIErrorCode) {\n\tvar retSet bool\n\tif cred.AccessKey == \"\" {\n\t\tconditions := getConditionValues(r, \"\", \"\", nil)\n\t\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\t\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.Format(time.RFC3339)}\n\t\tif retDays > 0 {\n\t\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t\t}\n\t\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\t\tbyPassSet = globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\tAction:          policy.Action(policy.BypassGovernanceRetentionAction),\n\t\t\t\tBucketName:      bucketName,\n\t\t\t\tConditionValues: conditions,\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      objectName,\n\t\t\t})\n\t\t}\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          policy.Action(policy.PutObjectRetentionAction),\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\tretSet = true\n\t\t}\n\t\tif byPassSet || retSet {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tconditions := getConditionValues(r, \"\", cred.AccessKey, claims)\n\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.Format(time.RFC3339)}\n\tif retDays > 0 {\n\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t}\n\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\tbyPassSet = globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          policy.BypassGovernanceRetentionAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tObjectName:      objectName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t})\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          policy.PutObjectRetentionAction,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: conditions,\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\tretSet = true\n\t}\n\tif byPassSet || retSet {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n\n// isPutActionAllowed - check if PUT operation is allowed on the resource, this\n// call verifies bucket policies and IAM policies, supports multi user\n// checks etc.\nfunc isPutActionAllowed(atype authType, bucketName, objectName string, r *http.Request, action iampolicy.Action) (s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tswitch atype {\n\tcase authTypeUnknown:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeStreamingSigned, authTypePresigned, authTypeSigned:\n\t\tregion := globalServerRegion\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\t// Do not check for PutObjectRetentionAction permission,\n\t// if mode and retain until date are not set.\n\t// Can happen when bucket has default lock config set\n\tif action == iampolicy.PutObjectRetentionAction &&\n\t\tr.Header.Get(xhttp.AmzObjectLockMode) == \"\" &&\n\t\tr.Header.Get(xhttp.AmzObjectLockRetainUntilDate) == \"\" {\n\t\treturn ErrNone\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          policy.Action(action),\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n", "/*\n * MinIO Cloud Storage, (C) 2016, 2017 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/minio/pkg/auth\"\n\tiampolicy \"github.com/minio/minio/pkg/iam/policy\"\n)\n\n// Test get request auth type.\nfunc TestGetRequestAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\treq   *http.Request\n\t\tauthT authType\n\t}\n\ttestCases := []testCase{\n\t\t// Test case - 1\n\t\t// Check for generic signature v4 header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\":        []string{\"AWS4-HMAC-SHA256 <cred_string>\"},\n\t\t\t\t\t\"X-Amz-Content-Sha256\": []string{streamingContentSHA256},\n\t\t\t\t\t\"Content-Encoding\":     []string{streamingContentEncoding},\n\t\t\t\t},\n\t\t\t\tMethod: \"PUT\",\n\t\t\t},\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t},\n\t\t// Test case - 2\n\t\t// Check for JWT header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"Bearer 12313123\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeJWT,\n\t\t},\n\t\t// Test case - 3\n\t\t// Empty authorization header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeUnknown,\n\t\t},\n\t\t// Test case - 4\n\t\t// Check for presigned.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:     \"127.0.0.1:9000\",\n\t\t\t\t\tScheme:   httpScheme,\n\t\t\t\t\tPath:     SlashSeparator,\n\t\t\t\t\tRawQuery: \"X-Amz-Credential=EXAMPLEINVALIDEXAMPL%2Fs3%2F20160314%2Fus-east-1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypePresigned,\n\t\t},\n\t\t// Test case - 5\n\t\t// Check for post policy.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Content-Type\": []string{\"multipart/form-data\"},\n\t\t\t\t},\n\t\t\t\tMethod: \"POST\",\n\t\t\t},\n\t\t\tauthT: authTypePostPolicy,\n\t\t},\n\t}\n\n\t// .. Tests all request auth type.\n\tfor i, testc := range testCases {\n\t\tauthT := getRequestAuthType(testc.req)\n\t\tif authT != testc.authT {\n\t\t\tt.Errorf(\"Test %d: Expected %d, got %d\", i+1, testc.authT, authT)\n\t\t}\n\t}\n}\n\n// Test all s3 supported auth types.\nfunc TestS3SupportedAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\tauthT authType\n\t\tpass  bool\n\t}\n\t// List of all valid and invalid test cases.\n\ttestCases := []testCase{\n\t\t// Test 1 - supported s3 type anonymous.\n\t\t{\n\t\t\tauthT: authTypeAnonymous,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 2 - supported s3 type presigned.\n\t\t{\n\t\t\tauthT: authTypePresigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 3 - supported s3 type signed.\n\t\t{\n\t\t\tauthT: authTypeSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 4 - supported s3 type with post policy.\n\t\t{\n\t\t\tauthT: authTypePostPolicy,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 5 - supported s3 type with streaming signed.\n\t\t{\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 6 - supported s3 type with signature v2.\n\t\t{\n\t\t\tauthT: authTypeSignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 7 - supported s3 type with presign v2.\n\t\t{\n\t\t\tauthT: authTypePresignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 8 - JWT is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeJWT,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 9 - unknown auth header is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeUnknown,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 10 - some new auth type is not supported s3 type.\n\t\t{\n\t\t\tauthT: authType(9),\n\t\t\tpass:  false,\n\t\t},\n\t}\n\t// Validate all the test cases.\n\tfor i, tt := range testCases {\n\t\tok := isSupportedS3AuthType(tt.authT)\n\t\tif ok != tt.pass {\n\t\t\tt.Errorf(\"Test %d:, Expected %t, got %t\", i+1, tt.pass, ok)\n\t\t}\n\t}\n}\n\nfunc TestIsRequestPresignedSignatureV2(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"AWSAccessKeyId\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"AWSAccessKeyId\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV2(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestIsRequestPresignedSignatureV4 - Test validates the logic for presign signature verision v4 detection.\nfunc TestIsRequestPresignedSignatureV4(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"\"X-Amz-Credential\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"X-Amz-Credential\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV4(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// Provides a fully populated http request instance, fails otherwise.\nfunc mustNewRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq, err := newTestRequest(method, urlStr, contentLength, body)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to initialize new http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V4, fails if not able to do so.\nfunc mustNewSignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V2, fails if not able to do so.\nfunc mustNewSignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := signRequestV2(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V2, fails if not able to do so.\nfunc mustNewPresignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := preSignV2(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V4, fails if not able to do so.\nfunc mustNewPresignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := preSignV4(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedShortMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"invalid-digest\")\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedEmptyMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"\")\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedBadMD5Request(method string, urlStr string, contentLength int64,\n\tbody io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"YWFhYWFhYWFhYWFhYWFhCg==\")\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// Tests is requested authenticated function, tests replies for s3 errors.\nfunc TestIsReqAuthenticated(t *testing.T) {\n\tobjLayer, fsDir, err := prepareFS()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(fsDir)\n\tif err = newTestConfig(globalMinioDefaultRegion, objLayer); err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalActiveCred = creds\n\n\t// List of test cases for validating http request authentication.\n\ttestCases := []struct {\n\t\treq     *http.Request\n\t\ts3Error APIErrorCode\n\t}{\n\t\t// When request is unsigned, access denied is returned.\n\t\t{mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrAccessDenied},\n\t\t// Empty Content-Md5 header.\n\t\t{mustNewSignedEmptyMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// Short Content-Md5 header.\n\t\t{mustNewSignedShortMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// When request is properly signed, but has bad Content-MD5 header.\n\t\t{mustNewSignedBadMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrBadDigest},\n\t\t// When request is properly signed, error is none.\n\t\t{mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrNone},\n\t}\n\n\tctx := context.Background()\n\t// Validates all testcases.\n\tfor i, testCase := range testCases {\n\t\ts3Error := isReqAuthenticated(ctx, testCase.req, globalServerRegion, serviceS3)\n\t\tif s3Error != testCase.s3Error {\n\t\t\tif _, err := ioutil.ReadAll(testCase.req.Body); toAPIErrorCode(ctx, err) != testCase.s3Error {\n\t\t\t\tt.Fatalf(\"Test %d: Unexpected S3 error: want %d - got %d (got after reading request %s)\", i, testCase.s3Error, s3Error, toAPIError(ctx, err).Code)\n\t\t\t}\n\t\t}\n\t}\n}\nfunc TestCheckAdminRequestAuthType(t *testing.T) {\n\tobjLayer, fsDir, err := prepareFS()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(fsDir)\n\n\tif err = newTestConfig(globalMinioDefaultRegion, objLayer); err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalActiveCred = creds\n\ttestCases := []struct {\n\t\tRequest *http.Request\n\t\tErrCode APIErrorCode\n\t}{\n\t\t{Request: mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrNone},\n\t\t{Request: mustNewSignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t}\n\tctx := context.Background()\n\tfor i, testCase := range testCases {\n\t\tif _, s3Error := checkAdminRequestAuthType(ctx, testCase.Request, iampolicy.AllAdminActions, globalServerRegion); s3Error != testCase.ErrCode {\n\t\t\tt.Errorf(\"Test %d: Unexpected s3error returned wanted %d, got %d\", i, testCase.ErrCode, s3Error)\n\t\t}\n\t}\n}\n"], "fixing_code": ["/*\n * MinIO Cloud Storage, (C) 2015-2018 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\txhttp \"github.com/minio/minio/cmd/http\"\n\txjwt \"github.com/minio/minio/cmd/jwt\"\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/auth\"\n\tobjectlock \"github.com/minio/minio/pkg/bucket/object/lock\"\n\t\"github.com/minio/minio/pkg/bucket/policy\"\n\t\"github.com/minio/minio/pkg/hash\"\n\tiampolicy \"github.com/minio/minio/pkg/iam/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(xhttp.Authorization), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.URL.Query()[xhttp.AmzCredential]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.URL.Query()[xhttp.AmzAccessKeyID]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\treturn strings.Contains(r.Header.Get(xhttp.ContentType), \"multipart/form-data\") &&\n\t\tr.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Authorization type.\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n\tauthTypeSTS\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) authType {\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.URL.Query()[xhttp.Action]; ok {\n\t\treturn authTypeSTS\n\t} else if _, ok := r.Header[xhttp.Authorization]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\nfunc validateAdminSignature(ctx context.Context, r *http.Request, region string) (auth.Credentials, map[string]interface{}, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\ts3Err := ErrAccessDenied\n\tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n\t\tgetRequestAuthType(r) == authTypeSigned && !skipContentSha256Cksum(r) {\n\t\t// We only support admin credentials to access admin APIs.\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t\tif s3Err != ErrNone {\n\t\t\treturn cred, nil, owner, s3Err\n\t\t}\n\n\t\t// we only support V4 (no presign) with auth body\n\t\ts3Err = isReqAuthenticated(ctx, r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treqInfo := (&logger.ReqInfo{}).AppendTags(\"requestHeaders\", dumpRequest(r))\n\t\tctx := logger.SetReqInfo(ctx, reqInfo)\n\t\tlogger.LogIf(ctx, errors.New(getAPIError(s3Err).Description), logger.Application)\n\t\treturn cred, nil, owner, s3Err\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, nil, owner, s3Err\n\t}\n\n\treturn cred, claims, owner, ErrNone\n}\n\n// checkAdminRequestAuthType checks whether the request is a valid signature V2 or V4 request.\n// It does not accept presigned or JWT or anonymous requests.\nfunc checkAdminRequestAuthType(ctx context.Context, r *http.Request, action iampolicy.AdminAction, region string) (auth.Credentials, APIErrorCode) {\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, region)\n\tif s3Err != ErrNone {\n\t\treturn cred, s3Err\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.Action(action),\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred, ErrNone\n\t}\n\n\treturn cred, ErrAccessDenied\n}\n\n// Fetch the security token set by the client.\nfunc getSessionToken(r *http.Request) (token string) {\n\ttoken = r.Header.Get(xhttp.AmzSecurityToken)\n\tif token != \"\" {\n\t\treturn token\n\t}\n\treturn r.URL.Query().Get(xhttp.AmzSecurityToken)\n}\n\n// Fetch claims in the security token returned by the client, doesn't return\n// errors - upon errors the returned claims map will be empty.\nfunc mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n\tclaims, _ := getClaimsFromToken(r, getSessionToken(r))\n\treturn claims\n}\n\n// Fetch claims in the security token returned by the client.\nfunc getClaimsFromToken(r *http.Request, token string) (map[string]interface{}, error) {\n\tclaims := xjwt.NewMapClaims()\n\tif token == \"\" {\n\t\treturn claims.Map(), nil\n\t}\n\n\tstsTokenCallback := func(claims *xjwt.MapClaims) ([]byte, error) {\n\t\t// JWT token for x-amz-security-token is signed with admin\n\t\t// secret key, temporary credentials become invalid if\n\t\t// server admin credentials change. This is done to ensure\n\t\t// that clients cannot decode the token using the temp\n\t\t// secret keys and generate an entirely new claim by essentially\n\t\t// hijacking the policies. We need to make sure that this is\n\t\t// based an admin credential such that token cannot be decoded\n\t\t// on the client side and is treated like an opaque value.\n\t\treturn []byte(globalActiveCred.SecretKey), nil\n\t}\n\n\tif err := xjwt.ParseWithClaims(token, claims, stsTokenCallback); err != nil {\n\t\treturn nil, errAuthentication\n\t}\n\n\tif globalPolicyOPA == nil {\n\t\t// If OPA is not set and if ldap claim key is set, allow the claim.\n\t\tif _, ok := claims.Lookup(ldapUser); ok {\n\t\t\treturn claims.Map(), nil\n\t\t}\n\n\t\t// If OPA is not set, session token should\n\t\t// have a policy and its mandatory, reject\n\t\t// requests without policy claim.\n\t\t_, pokOpenID := claims.Lookup(iamPolicyClaimNameOpenID())\n\t\t_, pokSA := claims.Lookup(iamPolicyClaimNameSA())\n\t\tif !pokOpenID && !pokSA {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\n\t\tsp, spok := claims.Lookup(iampolicy.SessionPolicyName)\n\t\tif !spok {\n\t\t\treturn claims.Map(), nil\n\t\t}\n\t\t// Looks like subpolicy is set and is a string, if set then its\n\t\t// base64 encoded, decode it. Decoding fails reject such requests.\n\t\tspBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\t// Base64 decoding fails, we should log to indicate\n\t\t\t// something is malforming the request sent by client.\n\t\t\tlogger.LogIf(r.Context(), err, logger.Application)\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims.MapClaims[iampolicy.SessionPolicyName] = string(spBytes)\n\t}\n\n\treturn claims.Map(), nil\n}\n\n// Fetch claims in the security token returned by the client and validate the token.\nfunc checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]interface{}, APIErrorCode) {\n\ttoken := getSessionToken(r)\n\tif token != \"\" && cred.AccessKey == \"\" {\n\t\treturn nil, ErrNoAccessKey\n\t}\n\tif cred.IsServiceAccount() && token == \"\" {\n\t\ttoken = cred.SessionToken\n\t}\n\tif subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n\t\treturn nil, ErrInvalidToken\n\t}\n\tclaims, err := getClaimsFromToken(r, token)\n\tif err != nil {\n\t\treturn nil, toAPIErrorCode(r.Context(), err)\n\t}\n\treturn claims, ErrNone\n}\n\n// Check request auth type verifies the incoming http request\n// - validates the request signature\n// - validates the policy action if anonymous tests bucket policies if any,\n//   for authenticated requests validates IAM policies.\n// returns APIErrorCode if any to be replied to the client.\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (s3Err APIErrorCode) {\n\t_, _, s3Err = checkRequestAuthTypeToAccessKey(ctx, r, action, bucketName, objectName)\n\treturn s3Err\n}\n\n// Check request auth type verifies the incoming http request\n// - validates the request signature\n// - validates the policy action if anonymous tests bucket policies if any,\n//   for authenticated requests validates IAM policies.\n// returns APIErrorCode if any to be replied to the client.\n// Additionally returns the accessKey used in the request, and if this request is by an admin.\nfunc checkRequestAuthTypeToAccessKey(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (accessKey string, owner bool, s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn accessKey, owner, ErrSignatureVersionNotSupported\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn accessKey, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalServerRegion\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\t\tif s3Err = isReqAuthenticated(ctx, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn accessKey, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn accessKey, owner, s3Err\n\t}\n\n\tvar claims map[string]interface{}\n\tclaims, s3Err = checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn accessKey, owner, s3Err\n\t}\n\n\t// LocationConstraint is valid only for CreateBucketAction.\n\tvar locationConstraint string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := ioutil.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err, logger.Application)\n\t\t\treturn accessKey, owner, ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\n\t\tvar s3Error APIErrorCode\n\t\tlocationConstraint, s3Error = parseLocationConstraint(r)\n\t\tif s3Error != ErrNone {\n\t\t\treturn accessKey, owner, s3Error\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, locationConstraint, \"\", nil),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn cred.AccessKey, owner, ErrNone\n\t\t}\n\t\treturn cred.AccessKey, owner, ErrAccessDenied\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.Action(action),\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred.AccessKey, owner, ErrNone\n\t}\n\treturn cred.AccessKey, owner, ErrAccessDenied\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r, stype)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region, stype)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region, stype)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(ctx context.Context, r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region, stype); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tvar (\n\t\terr                       error\n\t\tcontentMD5, contentSHA256 []byte\n\t)\n\n\t// Extract 'Content-Md5' if present.\n\tcontentMD5, err = checkValidMD5(r.Header)\n\tif err != nil {\n\t\treturn ErrInvalidDigest\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.URL.Query()[xhttp.AmzContentSha256]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[xhttp.AmzContentSha256]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(xhttp.AmzContentSha256))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(r.Body, -1, hex.EncodeToString(contentMD5),\n\t\thex.EncodeToString(contentSHA256), -1, globalCLIContext.StrictS3Compat)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\tr.Body = ioutil.NopCloser(reader)\n\treturn ErrNone\n}\n\n// authHandler - handles all the incoming authorization headers and validates them if possible.\ntype authHandler struct {\n\thandler http.Handler\n}\n\n// setAuthHandler to validate authorization header for the incoming request.\nfunc setAuthHandler(h http.Handler) http.Handler {\n\treturn authHandler{h}\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:       {},\n\tauthTypePresigned:       {},\n\tauthTypePresignedV2:     {},\n\tauthTypeSigned:          {},\n\tauthTypeSignedV2:        {},\n\tauthTypePostPolicy:      {},\n\tauthTypeStreamingSigned: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// handler for validating incoming authorization headers.\nfunc (a authHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\taType := getRequestAuthType(r)\n\tif isSupportedS3AuthType(aType) {\n\t\t// Let top level caller validate for anonymous and known signed requests.\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t} else if aType == authTypeJWT {\n\t\t// Validate Authorization header if its valid for JWT request.\n\t\tif _, _, authErr := webRequestAuthenticate(r); authErr != nil {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t} else if aType == authTypeSTS {\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrSignatureVersionNotSupported), r.URL, guessIsBrowserReq(r))\n}\n\nfunc validateSignature(atype authType, r *http.Request) (auth.Credentials, bool, map[string]interface{}, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tvar s3Err APIErrorCode\n\tswitch atype {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn cred, owner, nil, ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn cred, owner, nil, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypePresigned, authTypeSigned:\n\t\tregion := globalServerRegion\n\t\tif s3Err = isReqAuthenticated(GlobalContext, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn cred, owner, nil, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, nil, s3Err\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, nil, s3Err\n\t}\n\n\treturn cred, owner, claims, ErrNone\n}\n\nfunc isPutRetentionAllowed(bucketName, objectName string, retDays int, retDate time.Time, retMode objectlock.RetMode, byPassSet bool, r *http.Request, cred auth.Credentials, owner bool, claims map[string]interface{}) (s3Err APIErrorCode) {\n\tvar retSet bool\n\tif cred.AccessKey == \"\" {\n\t\tconditions := getConditionValues(r, \"\", \"\", nil)\n\t\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\t\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.Format(time.RFC3339)}\n\t\tif retDays > 0 {\n\t\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t\t}\n\t\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\t\tbyPassSet = globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\tAction:          policy.Action(policy.BypassGovernanceRetentionAction),\n\t\t\t\tBucketName:      bucketName,\n\t\t\t\tConditionValues: conditions,\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      objectName,\n\t\t\t})\n\t\t}\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          policy.Action(policy.PutObjectRetentionAction),\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\tretSet = true\n\t\t}\n\t\tif byPassSet || retSet {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tconditions := getConditionValues(r, \"\", cred.AccessKey, claims)\n\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.Format(time.RFC3339)}\n\tif retDays > 0 {\n\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t}\n\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\tbyPassSet = globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          policy.BypassGovernanceRetentionAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tObjectName:      objectName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t})\n\t}\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          policy.PutObjectRetentionAction,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: conditions,\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\tretSet = true\n\t}\n\tif byPassSet || retSet {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n\n// isPutActionAllowed - check if PUT operation is allowed on the resource, this\n// call verifies bucket policies and IAM policies, supports multi user\n// checks etc.\nfunc isPutActionAllowed(atype authType, bucketName, objectName string, r *http.Request, action iampolicy.Action) (s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tswitch atype {\n\tcase authTypeUnknown:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeStreamingSigned, authTypePresigned, authTypeSigned:\n\t\tregion := globalServerRegion\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\t// Do not check for PutObjectRetentionAction permission,\n\t// if mode and retain until date are not set.\n\t// Can happen when bucket has default lock config set\n\tif action == iampolicy.PutObjectRetentionAction &&\n\t\tr.Header.Get(xhttp.AmzObjectLockMode) == \"\" &&\n\t\tr.Header.Get(xhttp.AmzObjectLockRetainUntilDate) == \"\" {\n\t\treturn ErrNone\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          policy.Action(action),\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n", "/*\n * MinIO Cloud Storage, (C) 2016, 2017 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/minio/pkg/auth\"\n\tiampolicy \"github.com/minio/minio/pkg/iam/policy\"\n)\n\n// Test get request auth type.\nfunc TestGetRequestAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\treq   *http.Request\n\t\tauthT authType\n\t}\n\ttestCases := []testCase{\n\t\t// Test case - 1\n\t\t// Check for generic signature v4 header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\":        []string{\"AWS4-HMAC-SHA256 <cred_string>\"},\n\t\t\t\t\t\"X-Amz-Content-Sha256\": []string{streamingContentSHA256},\n\t\t\t\t\t\"Content-Encoding\":     []string{streamingContentEncoding},\n\t\t\t\t},\n\t\t\t\tMethod: \"PUT\",\n\t\t\t},\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t},\n\t\t// Test case - 2\n\t\t// Check for JWT header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"Bearer 12313123\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeJWT,\n\t\t},\n\t\t// Test case - 3\n\t\t// Empty authorization header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeUnknown,\n\t\t},\n\t\t// Test case - 4\n\t\t// Check for presigned.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:     \"127.0.0.1:9000\",\n\t\t\t\t\tScheme:   httpScheme,\n\t\t\t\t\tPath:     SlashSeparator,\n\t\t\t\t\tRawQuery: \"X-Amz-Credential=EXAMPLEINVALIDEXAMPL%2Fs3%2F20160314%2Fus-east-1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypePresigned,\n\t\t},\n\t\t// Test case - 5\n\t\t// Check for post policy.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   SlashSeparator,\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Content-Type\": []string{\"multipart/form-data\"},\n\t\t\t\t},\n\t\t\t\tMethod: \"POST\",\n\t\t\t},\n\t\t\tauthT: authTypePostPolicy,\n\t\t},\n\t}\n\n\t// .. Tests all request auth type.\n\tfor i, testc := range testCases {\n\t\tauthT := getRequestAuthType(testc.req)\n\t\tif authT != testc.authT {\n\t\t\tt.Errorf(\"Test %d: Expected %d, got %d\", i+1, testc.authT, authT)\n\t\t}\n\t}\n}\n\n// Test all s3 supported auth types.\nfunc TestS3SupportedAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\tauthT authType\n\t\tpass  bool\n\t}\n\t// List of all valid and invalid test cases.\n\ttestCases := []testCase{\n\t\t// Test 1 - supported s3 type anonymous.\n\t\t{\n\t\t\tauthT: authTypeAnonymous,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 2 - supported s3 type presigned.\n\t\t{\n\t\t\tauthT: authTypePresigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 3 - supported s3 type signed.\n\t\t{\n\t\t\tauthT: authTypeSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 4 - supported s3 type with post policy.\n\t\t{\n\t\t\tauthT: authTypePostPolicy,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 5 - supported s3 type with streaming signed.\n\t\t{\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 6 - supported s3 type with signature v2.\n\t\t{\n\t\t\tauthT: authTypeSignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 7 - supported s3 type with presign v2.\n\t\t{\n\t\t\tauthT: authTypePresignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 8 - JWT is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeJWT,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 9 - unknown auth header is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeUnknown,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 10 - some new auth type is not supported s3 type.\n\t\t{\n\t\t\tauthT: authType(9),\n\t\t\tpass:  false,\n\t\t},\n\t}\n\t// Validate all the test cases.\n\tfor i, tt := range testCases {\n\t\tok := isSupportedS3AuthType(tt.authT)\n\t\tif ok != tt.pass {\n\t\t\tt.Errorf(\"Test %d:, Expected %t, got %t\", i+1, tt.pass, ok)\n\t\t}\n\t}\n}\n\nfunc TestIsRequestPresignedSignatureV2(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"AWSAccessKeyId\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"AWSAccessKeyId\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV2(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestIsRequestPresignedSignatureV4 - Test validates the logic for presign signature verision v4 detection.\nfunc TestIsRequestPresignedSignatureV4(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"\"X-Amz-Credential\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"X-Amz-Credential\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV4(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// Provides a fully populated http request instance, fails otherwise.\nfunc mustNewRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq, err := newTestRequest(method, urlStr, contentLength, body)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to initialize new http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V4, fails if not able to do so.\nfunc mustNewSignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V2, fails if not able to do so.\nfunc mustNewSignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := signRequestV2(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V2, fails if not able to do so.\nfunc mustNewPresignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := preSignV2(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V4, fails if not able to do so.\nfunc mustNewPresignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalActiveCred\n\tif err := preSignV4(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedShortMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"invalid-digest\")\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedEmptyMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"\")\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedBadMD5Request(method string, urlStr string, contentLength int64,\n\tbody io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"YWFhYWFhYWFhYWFhYWFhCg==\")\n\tcred := globalActiveCred\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// Tests is requested authenticated function, tests replies for s3 errors.\nfunc TestIsReqAuthenticated(t *testing.T) {\n\tobjLayer, fsDir, err := prepareFS()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(fsDir)\n\tif err = newTestConfig(globalMinioDefaultRegion, objLayer); err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalActiveCred = creds\n\n\t// List of test cases for validating http request authentication.\n\ttestCases := []struct {\n\t\treq     *http.Request\n\t\ts3Error APIErrorCode\n\t}{\n\t\t// When request is unsigned, access denied is returned.\n\t\t{mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrAccessDenied},\n\t\t// Empty Content-Md5 header.\n\t\t{mustNewSignedEmptyMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// Short Content-Md5 header.\n\t\t{mustNewSignedShortMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// When request is properly signed, but has bad Content-MD5 header.\n\t\t{mustNewSignedBadMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrBadDigest},\n\t\t// When request is properly signed, error is none.\n\t\t{mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrNone},\n\t}\n\n\tctx := context.Background()\n\t// Validates all testcases.\n\tfor i, testCase := range testCases {\n\t\ts3Error := isReqAuthenticated(ctx, testCase.req, globalServerRegion, serviceS3)\n\t\tif s3Error != testCase.s3Error {\n\t\t\tif _, err := ioutil.ReadAll(testCase.req.Body); toAPIErrorCode(ctx, err) != testCase.s3Error {\n\t\t\t\tt.Fatalf(\"Test %d: Unexpected S3 error: want %d - got %d (got after reading request %s)\", i, testCase.s3Error, s3Error, toAPIError(ctx, err).Code)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCheckAdminRequestAuthType(t *testing.T) {\n\tobjLayer, fsDir, err := prepareFS()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(fsDir)\n\n\tif err = newTestConfig(globalMinioDefaultRegion, objLayer); err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalActiveCred = creds\n\ttestCases := []struct {\n\t\tRequest *http.Request\n\t\tErrCode APIErrorCode\n\t}{\n\t\t{Request: mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrNone},\n\t\t{Request: mustNewSignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t}\n\tctx := context.Background()\n\tfor i, testCase := range testCases {\n\t\tif _, s3Error := checkAdminRequestAuthType(ctx, testCase.Request, iampolicy.AllAdminActions, globalServerRegion); s3Error != testCase.ErrCode {\n\t\t\tt.Errorf(\"Test %d: Unexpected s3error returned wanted %d, got %d\", i, testCase.ErrCode, s3Error)\n\t\t}\n\t}\n}\n\nfunc TestValidateAdminSignature(t *testing.T) {\n\n\tctx := context.Background()\n\n\tobjLayer, fsDir, err := prepareFS()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(fsDir)\n\n\tif err = newTestConfig(globalMinioDefaultRegion, objLayer); err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\n\tcreds, err := auth.CreateCredentials(\"admin\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\tglobalActiveCred = creds\n\n\ttestCases := []struct {\n\t\tAccessKey string\n\t\tSecretKey string\n\t\tErrCode   APIErrorCode\n\t}{\n\t\t{\"\", \"\", ErrInvalidAccessKeyID},\n\t\t{\"admin\", \"\", ErrSignatureDoesNotMatch},\n\t\t{\"admin\", \"wrongpassword\", ErrSignatureDoesNotMatch},\n\t\t{\"wronguser\", \"mypassword\", ErrInvalidAccessKeyID},\n\t\t{\"\", \"mypassword\", ErrInvalidAccessKeyID},\n\t\t{\"admin\", \"mypassword\", ErrNone},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\treq := mustNewRequest(\"GET\", \"http://localhost:9000/\", 0, nil, t)\n\t\tif err := signRequestV4(req, testCase.AccessKey, testCase.SecretKey); err != nil {\n\t\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t\t}\n\t\t_, _, _, s3Error := validateAdminSignature(ctx, req, globalMinioDefaultRegion)\n\t\tif s3Error != testCase.ErrCode {\n\t\t\tt.Errorf(\"Test %d: Unexpected s3error returned wanted %d, got %d\", i+1, testCase.ErrCode, s3Error)\n\t\t}\n\t}\n}\n"], "filenames": ["cmd/auth-handler.go", "cmd/auth-handler_test.go"], "buggy_code_start_loc": [142, 393], "buggy_code_end_loc": [142, 427], "fixing_code_start_loc": [143, 394], "fixing_code_end_loc": [144, 474], "type": "CWE-755", "message": "MinIO versions before RELEASE.2020-04-23T00-58-49Z have an authentication bypass issue in the MinIO admin API. Given an admin access key, it is possible to perform admin API operations i.e. creating new service accounts for existing access keys - without knowing the admin secret key. This has been fixed and released in version RELEASE.2020-04-23T00-58-49Z.", "other": {"cve": {"id": "CVE-2020-11012", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-23T22:15:12.833", "lastModified": "2021-10-26T20:02:15.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MinIO versions before RELEASE.2020-04-23T00-58-49Z have an authentication bypass issue in the MinIO admin API. Given an admin access key, it is possible to perform admin API operations i.e. creating new service accounts for existing access keys - without knowing the admin secret key. This has been fixed and released in version RELEASE.2020-04-23T00-58-49Z."}, {"lang": "es", "value": "MinIO versiones anteriores a la versi\u00f3n  RELEASE.2020-04-23T00-58-49Z, tiene un problema de omisi\u00f3n de autenticaci\u00f3n en la API de administraci\u00f3n de MinIO. Dada una clave de acceso de administrador, es posible llevar a cabo operaciones de la API del administrador, es decir, crear nuevas cuentas de servicio para claves de acceso existentes, sin conocer la clave secreta del administrador. Esto se ha corregido y publicado en la versi\u00f3n RELEASE.2020-04-23T00-58-49Z."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-305"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-04-23t00-58-49z", "matchCriteriaId": "31CB1B2A-7802-446D-8D09-53DF944D7444"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/4cd6ca02c7957aeb2de3eede08b0754332a77923", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/9422", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/minio/minio/releases/tag/RELEASE.2020-04-23T00-58-49Z", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-xv4r-vccv-mg4w", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/4cd6ca02c7957aeb2de3eede08b0754332a77923"}}