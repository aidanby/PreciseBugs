{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <unordered_set>\n\nnamespace tensorflow {\n\nnamespace {\nclass MemmappedTensorAllocator : public Allocator {\n public:\n  MemmappedTensorAllocator() {}\n\n  Status InitializeFromRegion(const string& name, Env* env) {\n    const auto status =\n        env->NewReadOnlyMemoryRegionFromFile(name, &memory_region_);\n    if (!status.ok()) {\n      return status;\n    }\n    return Status::OK();\n  }\n  string Name() override { return \"MemmappedTensorAllocator\"; }\n\n  void* AllocateRaw(size_t alignment, size_t num_bytes) override {\n    if ((reinterpret_cast<intptr_t>(memory_region_->data())) % alignment != 0) {\n      allocation_status_ =\n          errors::Internal(\"Readonly memory region has wrong alignment\");\n      return nullptr;\n    }\n    if (num_bytes > memory_region_->length()) {\n      allocation_status_ = errors::Internal(\n          \"Readonly memory region has wrong length (\", memory_region_->length(),\n          \") when allocating \", num_bytes);\n      return nullptr;\n    }\n    return const_cast<void*>(memory_region_->data());\n  }\n\n  void DeallocateRaw(void* ptr) override {\n    if (ptr != memory_region_->data()) {\n      LOG(ERROR)\n          << \"Deallocating not allocated region for readonly memory region\";\n    }\n    if (delete_on_deallocate_) {\n      delete this;\n    }\n  }\n  const Status& allocation_status() const { return allocation_status_; }\n\n  void set_delete_on_deallocate() { delete_on_deallocate_ = true; }\n\n private:\n  std::unique_ptr<ReadOnlyMemoryRegion> memory_region_;\n  // If there is an error during allocation we keep it in this status.\n  Status allocation_status_;\n\n  // When the allocator is owned by TensorBuffer it will be deleted on\n  // de-allocation.\n  bool delete_on_deallocate_ = false;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(MemmappedTensorAllocator);\n};\n}  // namespace\n\nImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}\n\nvoid ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  // Allocator is owned by the tensor from this point.\n  allocator.release()->set_delete_on_deallocate();\n}\n\nImmutableConstantOp::~ImmutableConstantOp() {}\nconstexpr char const* ImmutableConstantOp::kDTypeAttr;\nconstexpr char const* ImmutableConstantOp::kShapeAttr;\nconstexpr char const* ImmutableConstantOp::kMemoryRegionNameAttr;\n\nREGISTER_KERNEL_BUILDER(Name(\"ImmutableConst\").Device(DEVICE_CPU),\n                        ImmutableConstantOp);\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <unordered_set>\n\nnamespace tensorflow {\n\nnamespace {\nclass MemmappedTensorAllocator : public Allocator {\n public:\n  MemmappedTensorAllocator() {}\n\n  Status InitializeFromRegion(const string& name, Env* env) {\n    const auto status =\n        env->NewReadOnlyMemoryRegionFromFile(name, &memory_region_);\n    if (!status.ok()) {\n      return status;\n    }\n    return Status::OK();\n  }\n  string Name() override { return \"MemmappedTensorAllocator\"; }\n\n  void* AllocateRaw(size_t alignment, size_t num_bytes) override {\n    if ((reinterpret_cast<intptr_t>(memory_region_->data())) % alignment != 0) {\n      allocation_status_ =\n          errors::Internal(\"Readonly memory region has wrong alignment\");\n      return nullptr;\n    }\n    if (num_bytes > memory_region_->length()) {\n      allocation_status_ = errors::Internal(\n          \"Readonly memory region has wrong length (\", memory_region_->length(),\n          \") when allocating \", num_bytes);\n      return nullptr;\n    }\n    return const_cast<void*>(memory_region_->data());\n  }\n\n  void DeallocateRaw(void* ptr) override {\n    if (ptr != memory_region_->data()) {\n      LOG(ERROR)\n          << \"Deallocating not allocated region for readonly memory region\";\n    }\n    if (delete_on_deallocate_) {\n      delete this;\n    }\n  }\n  const Status& allocation_status() const { return allocation_status_; }\n\n  void set_delete_on_deallocate() { delete_on_deallocate_ = true; }\n\n  // Make sure tensors or complex types (strings, variants, resources) don't get\n  // their constructor called via a placement new since that would require\n  // writing to immutable data.\n  // See also: tensorflow/core/framework/typed_allocator.h\n  bool AllocatesOpaqueHandle() const override { return true; }\n\n private:\n  std::unique_ptr<ReadOnlyMemoryRegion> memory_region_;\n  // If there is an error during allocation we keep it in this status.\n  Status allocation_status_;\n\n  // When the allocator is owned by TensorBuffer it will be deleted on\n  // de-allocation.\n  bool delete_on_deallocate_ = false;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(MemmappedTensorAllocator);\n};\n}  // namespace\n\nImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}\n\nvoid ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  // Allocator is owned by the tensor from this point.\n  allocator.release()->set_delete_on_deallocate();\n}\n\nImmutableConstantOp::~ImmutableConstantOp() {}\nconstexpr char const* ImmutableConstantOp::kDTypeAttr;\nconstexpr char const* ImmutableConstantOp::kShapeAttr;\nconstexpr char const* ImmutableConstantOp::kMemoryRegionNameAttr;\n\nREGISTER_KERNEL_BUILDER(Name(\"ImmutableConst\").Device(DEVICE_CPU),\n                        ImmutableConstantOp);\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/immutable_constant_op.cc"], "buggy_code_start_loc": [64], "buggy_code_end_loc": [64], "fixing_code_start_loc": [65], "fixing_code_end_loc": [71], "type": "NVD-CWE-Other", "message": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.", "other": {"cve": {"id": "CVE-2020-26268", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-10T23:15:12.833", "lastModified": "2020-12-14T17:40:39.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0."}, {"lang": "es", "value": "En las versiones afectadas de TensorFlow, la operaci\u00f3n tf.raw_ops.ImmutableConst devuelve un tensor constante creado a partir de un archivo mapeado en memoria que se asume inmutable.&#xa0;Sin embargo, si el tipo de tensor no es un tipo integral, la operaci\u00f3n bloquea el int\u00e9rprete de Python cuando intenta escribir en el \u00e1rea de la memoria.&#xa0;Si el archivo es muy peque\u00f1o, TensorFlow devuelve apropiadamente un error ya que el \u00e1rea de la memoria posee menos bytes de los necesarios para el tensor que crea.&#xa0;Sin embargo, tan pronto como haya suficientes bytes, el fragmento anterior causa un fallo de segmentaci\u00f3n.&#xa0;Esto es debido a que el asignador usado para devolver los datos del b\u00fafer no est\u00e1 marcado como devolviendo un identificador opaco, ya que el m\u00e9todo virtual necesario no se anula.&#xa0;Esto es corregido en las versiones 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2 y 2.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-471"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.15.5", "matchCriteriaId": "CA3A54AC-E0F8-4741-8A80-04EEF746B14B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.4", "matchCriteriaId": "989E4548-7823-436F-A9FE-04158ED41C48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.3", "matchCriteriaId": "46417CA8-E666-4E12-B2A8-BB0E97D49BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.2", "matchCriteriaId": "57B24744-0D81-41E9-9ED0-7296368DEF00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.2", "matchCriteriaId": "DBEA56AF-3495-4883-9721-0FA9F08E7F6D"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/c1e1fc899ad5f8c725dcbb6470069890b5060bc7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-hhvc-g5hv-48c6", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/c1e1fc899ad5f8c725dcbb6470069890b5060bc7"}}