{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,\n *\t  op_change, op_yank, do_join\n */\n\n#include \"vim.h\"\n\nstatic void shift_block(oparg_T *oap, int amount);\nstatic void\tmb_adjust_opend(oparg_T *oap);\nstatic int\tdo_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1);\n\n// Flags for third item in \"opchars\".\n#define OPF_LINES  1\t// operator always works on lines\n#define OPF_CHANGE 2\t// operator changes text\n\n/*\n * The names of operators.\n * IMPORTANT: Index must correspond with defines in vim.h!!!\n * The third field holds OPF_ flags.\n */\nstatic char opchars[][3] =\n{\n    {NUL, NUL, 0},\t\t\t// OP_NOP\n    {'d', NUL, OPF_CHANGE},\t\t// OP_DELETE\n    {'y', NUL, 0},\t\t\t// OP_YANK\n    {'c', NUL, OPF_CHANGE},\t\t// OP_CHANGE\n    {'<', NUL, OPF_LINES | OPF_CHANGE},\t// OP_LSHIFT\n    {'>', NUL, OPF_LINES | OPF_CHANGE},\t// OP_RSHIFT\n    {'!', NUL, OPF_LINES | OPF_CHANGE},\t// OP_FILTER\n    {'g', '~', OPF_CHANGE},\t\t// OP_TILDE\n    {'=', NUL, OPF_LINES | OPF_CHANGE},\t// OP_INDENT\n    {'g', 'q', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT\n    {':', NUL, OPF_LINES},\t\t// OP_COLON\n    {'g', 'U', OPF_CHANGE},\t\t// OP_UPPER\n    {'g', 'u', OPF_CHANGE},\t\t// OP_LOWER\n    {'J', NUL, OPF_LINES | OPF_CHANGE},\t// DO_JOIN\n    {'g', 'J', OPF_LINES | OPF_CHANGE},\t// DO_JOIN_NS\n    {'g', '?', OPF_CHANGE},\t\t// OP_ROT13\n    {'r', NUL, OPF_CHANGE},\t\t// OP_REPLACE\n    {'I', NUL, OPF_CHANGE},\t\t// OP_INSERT\n    {'A', NUL, OPF_CHANGE},\t\t// OP_APPEND\n    {'z', 'f', OPF_LINES},\t\t// OP_FOLD\n    {'z', 'o', OPF_LINES},\t\t// OP_FOLDOPEN\n    {'z', 'O', OPF_LINES},\t\t// OP_FOLDOPENREC\n    {'z', 'c', OPF_LINES},\t\t// OP_FOLDCLOSE\n    {'z', 'C', OPF_LINES},\t\t// OP_FOLDCLOSEREC\n    {'z', 'd', OPF_LINES},\t\t// OP_FOLDDEL\n    {'z', 'D', OPF_LINES},\t\t// OP_FOLDDELREC\n    {'g', 'w', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT2\n    {'g', '@', OPF_CHANGE},\t\t// OP_FUNCTION\n    {Ctrl_A, NUL, OPF_CHANGE},\t\t// OP_NR_ADD\n    {Ctrl_X, NUL, OPF_CHANGE},\t\t// OP_NR_SUB\n};\n\n/*\n * Translate a command name into an operator type.\n * Must only be called with a valid operator name!\n */\n    int\nget_op_type(int char1, int char2)\n{\n    int\t\ti;\n\n    if (char1 == 'r')\t\t// ignore second character\n\treturn OP_REPLACE;\n    if (char1 == '~')\t\t// when tilde is an operator\n\treturn OP_TILDE;\n    if (char1 == 'g' && char2 == Ctrl_A)\t// add\n\treturn OP_NR_ADD;\n    if (char1 == 'g' && char2 == Ctrl_X)\t// subtract\n\treturn OP_NR_SUB;\n    if (char1 == 'z' && char2 == 'y')\t// OP_YANK\n\treturn OP_YANK;\n    for (i = 0; ; ++i)\n    {\n\tif (opchars[i][0] == char1 && opchars[i][1] == char2)\n\t    break;\n\tif (i == (int)ARRAY_LENGTH(opchars) - 1)\n\t{\n\t    internal_error(\"get_op_type()\");\n\t    break;\n\t}\n    }\n    return i;\n}\n\n/*\n * Return TRUE if operator \"op\" always works on whole lines.\n */\n    static int\nop_on_lines(int op)\n{\n    return opchars[op][2] & OPF_LINES;\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Return TRUE if operator \"op\" changes text.\n */\n    int\nop_is_change(int op)\n{\n    return opchars[op][2] & OPF_CHANGE;\n}\n#endif\n\n/*\n * Get first operator command character.\n * Returns 'g' or 'z' if there is another command character.\n */\n    int\nget_op_char(int optype)\n{\n    return opchars[optype][0];\n}\n\n/*\n * Get second operator command character.\n */\n    int\nget_extra_op_char(int optype)\n{\n    return opchars[optype][1];\n}\n\n/*\n * op_shift - handle a shift operation\n */\n    void\nop_shift(oparg_T *oap, int curs_top, int amount)\n{\n    long\t    i;\n    int\t\t    first_char;\n    int\t\t    block_col = 0;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    if (oap->block_mode)\n\tblock_col = curwin->w_cursor.col;\n\n    for (i = oap->line_count; --i >= 0; )\n    {\n\tfirst_char = *ml_get_curline();\n\tif (first_char == NUL)\t\t\t\t// empty line\n\t    curwin->w_cursor.col = 0;\n\telse if (oap->block_mode)\n\t    shift_block(oap, amount);\n\telse\n\t    // Move the line right if it doesn't start with '#', 'smartindent'\n\t    // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    if (first_char != '#' || !preprocs_left())\n#endif\n\t    shift_line(oap->op_type == OP_LSHIFT, p_sr, amount, FALSE);\n\t++curwin->w_cursor.lnum;\n    }\n\n    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    if (oap->block_mode)\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tcurwin->w_cursor.col = block_col;\n    }\n    else if (curs_top)\t    // put cursor on first line, for \">>\"\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tbeginline(BL_SOL | BL_FIX);   // shift_line() may have set cursor.col\n    }\n    else\n\t--curwin->w_cursor.lnum;\t// put cursor on last line, for \":>\"\n\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold\n    foldOpenCursor();\n#endif\n\n\n    if (oap->line_count > p_report)\n    {\n\tchar\t    *op;\n\tchar\t    *msg_line_single;\n\tchar\t    *msg_line_plural;\n\n\tif (oap->op_type == OP_RSHIFT)\n\t    op = \">\";\n\telse\n\t    op = \"<\";\n\tmsg_line_single = NGETTEXT(\"%ld line %sed %d time\",\n\t\t\t\t\t     \"%ld line %sed %d times\", amount);\n\tmsg_line_plural = NGETTEXT(\"%ld lines %sed %d time\",\n\t\t\t\t\t    \"%ld lines %sed %d times\", amount);\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\tNGETTEXT(msg_line_single, msg_line_plural, oap->line_count),\n\t\toap->line_count, op, amount);\n\tmsg_attr_keep((char *)IObuff, 0, TRUE);\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end.lnum = oap->end.lnum;\n\tcurbuf->b_op_end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Shift the current line one shiftwidth left (if left != 0) or right\n * leaves cursor on first blank in the line.\n */\n    void\nshift_line(\n    int\tleft,\n    int\tround,\n    int\tamount,\n    int call_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tcount;\n    int\t\ti, j;\n    int\t\tsw_val = (int)get_sw_value_indent(curbuf);\n\n    count = get_indent();\t// get current indent\n\n    if (round)\t\t\t// round off indent\n    {\n\ti = count / sw_val;\t// number of 'shiftwidth' rounded down\n\tj = count % sw_val;\t// extra spaces\n\tif (j && left)\t\t// first remove extra spaces\n\t    --amount;\n\tif (left)\n\t{\n\t    i -= amount;\n\t    if (i < 0)\n\t\ti = 0;\n\t}\n\telse\n\t    i += amount;\n\tcount = i * sw_val;\n    }\n    else\t\t// original vi indent\n    {\n\tif (left)\n\t{\n\t    count -= sw_val * amount;\n\t    if (count < 0)\n\t\tcount = 0;\n\t}\n\telse\n\t    count += sw_val * amount;\n    }\n\n    // Set new indent\n    if (State & VREPLACE_FLAG)\n\tchange_indent(INDENT_SET, count, FALSE, NUL, call_changed_bytes);\n    else\n\t(void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);\n}\n\n/*\n * Shift one line of the current block one shiftwidth right or left.\n * Leaves cursor on first character in block.\n */\n    static void\nshift_block(oparg_T *oap, int amount)\n{\n    int\t\t\tleft = (oap->op_type == OP_LSHIFT);\n    int\t\t\toldstate = State;\n    int\t\t\ttotal;\n    char_u\t\t*newp, *oldp;\n    int\t\t\toldcol = curwin->w_cursor.col;\n    int\t\t\tsw_val = (int)get_sw_value_indent(curbuf);\n    int\t\t\tts_val = (int)curbuf->b_p_ts;\n    struct block_def\tbd;\n    int\t\t\tincr;\n    colnr_T\t\tws_vcol;\n    int\t\t\ti = 0, j = 0;\n    int\t\t\tlen;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\told_p_ri = p_ri;\n\n    p_ri = 0;\t\t\t// don't want revins in indent\n#endif\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n    if (bd.is_short)\n\treturn;\n\n    // total is number of screen columns to be inserted/removed\n    total = (int)((unsigned)amount * (unsigned)sw_val);\n    if ((total / sw_val) != amount)\n\treturn; // multiplication overflow\n\n    oldp = ml_get_curline();\n\n    if (!left)\n    {\n\t/*\n\t *  1. Get start vcol\n\t *  2. Total ws vcols\n\t *  3. Divvy into TABs & spp\n\t *  4. Construct new string\n\t */\n\ttotal += bd.pre_whitesp; // all virtual WS up to & incl a split TAB\n\tws_vcol = bd.start_vcol - bd.pre_whitesp;\n\tif (bd.startspaces)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tif ((*mb_ptr2len)(bd.textstart) == 1)\n\t\t    ++bd.textstart;\n\t\telse\n\t\t{\n\t\t    ws_vcol = 0;\n\t\t    bd.startspaces = 0;\n\t\t}\n\t    }\n\t    else\n\t\t++bd.textstart;\n\t}\n\tfor ( ; VIM_ISWHITE(*bd.textstart); )\n\t{\n\t    // TODO: is passing bd.textstart for start of the line OK?\n\t    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,\n\t\t\t\t\t\t    (colnr_T)(bd.start_vcol));\n\t    total += incr;\n\t    bd.start_vcol += incr;\n\t}\n\t// OK, now total=all the VWS reqd, and textstart points at the 1st\n\t// non-ws char in the block.\n#ifdef FEAT_VARTABS\n\tif (!curbuf->b_p_et)\n\t    tabstop_fromto(ws_vcol, ws_vcol + total,\n\t\t\t\t\tts_val, curbuf->b_p_vts_array, &i, &j);\n\telse\n\t    j = total;\n#else\n\tif (!curbuf->b_p_et)\n\t    i = ((ws_vcol % ts_val) + total) / ts_val; // number of tabs\n\tif (i)\n\t    j = ((ws_vcol % ts_val) + total) % ts_val; // number of spp\n\telse\n\t    j = total;\n#endif\n\t// if we're splitting a TAB, allow for it\n\tbd.textcol -= bd.pre_whitesp_c - (bd.startspaces != 0);\n\tlen = (int)STRLEN(bd.textstart) + 1;\n\tnewp = alloc(bd.textcol + i + j + len);\n\tif (newp == NULL)\n\t    return;\n\tvim_memset(newp, NUL, (size_t)(bd.textcol + i + j + len));\n\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\tvim_memset(newp + bd.textcol, TAB, (size_t)i);\n\tvim_memset(newp + bd.textcol + i, ' ', (size_t)j);\n\t// the end\n\tmch_memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);\n    }\n    else // left\n    {\n\tcolnr_T\t    destination_col;\t// column to which text in block will\n\t\t\t\t\t// be shifted\n\tchar_u\t    *verbatim_copy_end;\t// end of the part of the line which is\n\t\t\t\t\t// copied verbatim\n\tcolnr_T\t    verbatim_copy_width;// the (displayed) width of this part\n\t\t\t\t\t// of line\n\tunsigned    fill;\t\t// nr of spaces that replace a TAB\n\tunsigned    new_line_len;\t// the length of the line after the\n\t\t\t\t\t// block shift\n\tsize_t\t    block_space_width;\n\tsize_t\t    shift_amount;\n\tchar_u\t    *non_white = bd.textstart;\n\tcolnr_T\t    non_white_col;\n\n\t/*\n\t * Firstly, let's find the first non-whitespace character that is\n\t * displayed after the block's start column and the character's column\n\t * number. Also, let's calculate the width of all the whitespace\n\t * characters that are displayed in the block and precede the searched\n\t * non-whitespace character.\n\t */\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,\n\t// the part of which is displayed at the block's beginning. Let's start\n\t// searching from the next character.\n\tif (bd.startspaces)\n\t    MB_PTR_ADV(non_white);\n\n\t// The character's column is in \"bd.start_vcol\".\n\tnon_white_col = bd.start_vcol;\n\n\twhile (VIM_ISWHITE(*non_white))\n\t{\n\t    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);\n\t    non_white_col += incr;\n\t}\n\n\tblock_space_width = non_white_col - oap->start_vcol;\n\t// We will shift by \"total\" or \"block_space_width\", whichever is less.\n\tshift_amount = (block_space_width < (size_t)total\n\t\t\t\t\t ? block_space_width : (size_t)total);\n\n\t// The column to which we will shift the text.\n\tdestination_col = (colnr_T)(non_white_col - shift_amount);\n\n\t// Now let's find out how much of the beginning of the line we can\n\t// reuse without modification.\n\tverbatim_copy_end = bd.textstart;\n\tverbatim_copy_width = bd.start_vcol;\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character\n\t// preceding the block. We have to subtract its width to obtain its\n\t// column number.\n\tif (bd.startspaces)\n\t    verbatim_copy_width -= bd.start_char_vcols;\n\twhile (verbatim_copy_width < destination_col)\n\t{\n\t    char_u *line = verbatim_copy_end;\n\n\t    // TODO: is passing verbatim_copy_end for start of the line OK?\n\t    incr = lbr_chartabsize(line, verbatim_copy_end,\n\t\t\t\t\t\t\t verbatim_copy_width);\n\t    if (verbatim_copy_width + incr > destination_col)\n\t\tbreak;\n\t    verbatim_copy_width += incr;\n\t    MB_PTR_ADV(verbatim_copy_end);\n\t}\n\n\t// If \"destination_col\" is different from the width of the initial\n\t// part of the line that will be copied, it means we encountered a tab\n\t// character, which we will have to partly replace with spaces.\n\tfill = destination_col - verbatim_copy_width;\n\n\t// The replacement line will consist of:\n\t// - the beginning of the original line up to \"verbatim_copy_end\",\n\t// - \"fill\" number of spaces,\n\t// - the rest of the line, pointed to by non_white.\n\tnew_line_len = (unsigned)(verbatim_copy_end - oldp)\n\t\t       + fill\n\t\t       + (unsigned)STRLEN(non_white) + 1;\n\n\tnewp = alloc(new_line_len);\n\tif (newp == NULL)\n\t    return;\n\tmch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));\n\tvim_memset(newp + (verbatim_copy_end - oldp), ' ', (size_t)fill);\n\tSTRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);\n    }\n    // replace the line\n    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n    changed_bytes(curwin->w_cursor.lnum, (colnr_T)bd.textcol);\n    State = oldstate;\n    curwin->w_cursor.col = oldcol;\n#ifdef FEAT_RIGHTLEFT\n    p_ri = old_p_ri;\n#endif\n}\n\n/*\n * Insert string \"s\" (b_insert ? before : after) block :AKelly\n * Caller must prepare for undo.\n */\n    static void\nblock_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t{\n\t    int off;\n\n\t    // Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t\tspaces -= off;\n\t\tcount -= off;\n\t    }\n\t    else\n\t    {\n\t\t// spaces fill the gap, the character that's at the edge moves\n\t\t// right\n\t\toff = (*mb_head_off)(oldp, oldp + offset);\n\t\toffset -= off;\n\t    }\n\t}\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}\n\n/*\n * Handle a delete operation.\n *\n * Return FAIL if undo failed, OK otherwise.\n */\n    int\nop_delete(oparg_T *oap)\n{\n    int\t\t\tn;\n    linenr_T\t\tlnum;\n    char_u\t\t*ptr;\n    char_u\t\t*newp, *oldp;\n    struct block_def\tbd;\n    linenr_T\t\told_lcount = curbuf->b_ml.ml_line_count;\n    int\t\t\tdid_yank = FALSE;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to do\n\treturn OK;\n\n    // Nothing to delete, return here.\tDo prepare undo, for op_change().\n    if (oap->empty)\n\treturn u_save_cursor();\n\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FAIL;\n    }\n\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&oap->regname);\n#endif\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    /*\n     * Imitate the strange Vi behaviour: If the delete spans more than one\n     * line and motion_type == MCHAR and the result is a blank line, make the\n     * delete linewise.  Don't do this for the change command or Visual mode.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && !oap->is_VIsual\n\t    && !oap->block_mode\n\t    && oap->line_count > 1\n\t    && oap->motion_force == NUL\n\t    && oap->op_type == OP_DELETE)\n    {\n\tptr = ml_get(oap->end.lnum) + oap->end.col;\n\tif (*ptr != NUL)\n\t    ptr += oap->inclusive;\n\tptr = skipwhite(ptr);\n\tif (*ptr == NUL && inindent(0))\n\t    oap->motion_type = MLINE;\n    }\n\n    /*\n     * Check for trying to delete (e.g. \"D\") in an empty line.\n     * Note: For the change operator it is ok.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && oap->line_count == 1\n\t    && oap->op_type == OP_DELETE\n\t    && *ml_get(oap->start.lnum) == NUL)\n    {\n\t/*\n\t * It's an error to operate on an empty region, when 'E' included in\n\t * 'cpoptions' (Vi compatible).\n\t */\n\tif (virtual_op)\n\t    // Virtual editing: Nothing gets deleted, but we set the '[ and ']\n\t    // marks as if it happened.\n\t    goto setmarks;\n\tif (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL)\n\t    beep_flush();\n\treturn OK;\n    }\n\n    /*\n     * Do a yank of whatever we're about to delete.\n     * If a yank register was specified, put the deleted text into that\n     * register.  For the black hole register '_' don't yank anything.\n     */\n    if (oap->regname != '_')\n    {\n\tif (oap->regname != 0)\n\t{\n\t    // check for read-only register\n\t    if (!valid_yank_reg(oap->regname, TRUE))\n\t    {\n\t\tbeep_flush();\n\t\treturn OK;\n\t    }\n\t    get_yank_register(oap->regname, TRUE); // yank into specif'd reg.\n\t    if (op_yank(oap, TRUE, FALSE) == OK)   // yank without message\n\t\tdid_yank = TRUE;\n\t}\n\telse\n\t    reset_y_append(); // not appending to unnamed register\n\n\t/*\n\t * Put deleted text into register 1 and shift number registers if the\n\t * delete contains a line break, or when using a specific operator (Vi\n\t * compatible)\n\t * Use the register name from before adjust_clip_reg() may have\n\t * changed it.\n\t */\n\tif (oap->motion_type == MLINE || oap->line_count > 1\n\t\t\t\t\t\t\t   || oap->use_reg_one)\n\t{\n\t    shift_delete_registers();\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t}\n\n\t// Yank into small delete register when no named register specified\n\t// and the delete is within one line.\n\tif ((\n#ifdef FEAT_CLIPBOARD\n\t    ((clip_unnamed & CLIP_UNNAMED) && oap->regname == '*') ||\n\t    ((clip_unnamed & CLIP_UNNAMED_PLUS) && oap->regname == '+') ||\n#endif\n\t    oap->regname == 0) && oap->motion_type != MLINE\n\t\t\t\t\t\t      && oap->line_count == 1)\n\t{\n\t    oap->regname = '-';\n\t    get_yank_register(oap->regname, TRUE);\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t    oap->regname = 0;\n\t}\n\n\t/*\n\t * If there's too much stuff to fit in the yank register, then get a\n\t * confirmation before doing the delete. This is crude, but simple.\n\t * And it avoids doing a delete of something we can't put back if we\n\t * want.\n\t */\n\tif (!did_yank)\n\t{\n\t    int msg_silent_save = msg_silent;\n\n\t    msg_silent = 0;\t// must display the prompt\n\t    n = ask_yesno((char_u *)_(\"cannot yank; delete anyway\"), TRUE);\n\t    msg_silent = msg_silent_save;\n\t    if (n != 'y')\n\t    {\n\t\temsg(_(e_command_aborted));\n\t\treturn FAIL;\n\t    }\n\t}\n\n#if defined(FEAT_EVAL)\n\tif (did_yank && has_textyankpost())\n\t    yank_do_autocmd(oap, get_y_current());\n#endif\n    }\n\n    /*\n     * block mode delete\n     */\n    if (oap->block_mode)\n    {\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t    return FAIL;\n\n\tfor (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; ++lnum)\n\t{\n\t    block_prep(oap, &bd, lnum, TRUE);\n\t    if (bd.textlen == 0)\t// nothing to delete\n\t\tcontinue;\n\n\t    // Adjust cursor position for tab replaced by spaces and 'lbr'.\n\t    if (lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tcurwin->w_cursor.col = bd.textcol + bd.startspaces;\n\t\tcurwin->w_cursor.coladd = 0;\n\t    }\n\n\t    // \"n\" == number of chars deleted\n\t    // If we delete a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    n = bd.textlen - bd.startspaces - bd.endspaces;\n\t    oldp = ml_get(lnum);\n\t    newp = alloc(STRLEN(oldp) + 1 - n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    // insert spaces\n\t    vim_memset(newp + bd.textcol, ' ',\n\t\t\t\t     (size_t)(bd.startspaces + bd.endspaces));\n\t    // copy the part after the deleted part\n\t    oldp += bd.textcol + bd.textlen;\n\t    STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);\n\t    // replace the line\n\t    ml_replace(lnum, newp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n\t    if (curbuf->b_has_textprop && n != 0)\n\t\tadjust_prop_columns(lnum, bd.textcol, -n, 0);\n#endif\n\t}\n\n\tcheck_cursor_col();\n\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t\t       oap->end.lnum + 1, 0L);\n\toap->line_count = 0;\t    // no lines deleted\n    }\n    else if (oap->motion_type == MLINE)\n    {\n\tif (oap->op_type == OP_CHANGE)\n\t{\n\t    // Delete the lines except the first one.  Temporarily move the\n\t    // cursor to the next line.  Save the current line number, if the\n\t    // last line is deleted it may be changed.\n\t    if (oap->line_count > 1)\n\t    {\n\t\tlnum = curwin->w_cursor.lnum;\n\t\t++curwin->w_cursor.lnum;\n\t\tdel_lines((long)(oap->line_count - 1), TRUE);\n\t\tcurwin->w_cursor.lnum = lnum;\n\t    }\n\t    if (u_save_cursor() == FAIL)\n\t\treturn FAIL;\n\t    if (curbuf->b_p_ai)\t\t    // don't delete indent\n\t    {\n\t\tbeginline(BL_WHITE);\t    // cursor on first non-white\n\t\tdid_ai = TRUE;\t\t    // delete the indent when ESC hit\n\t\tai_col = curwin->w_cursor.col;\n\t    }\n\t    else\n\t\tbeginline(0);\t\t    // cursor in column 0\n\t    truncate_line(FALSE);   // delete the rest of the line\n\t\t\t\t    // leave cursor past last char in line\n\t    if (oap->line_count > 1)\n\t\tu_clearline();\t    // \"U\" command not possible after \"2cc\"\n\t}\n\telse\n\t{\n\t    del_lines(oap->line_count, TRUE);\n\t    beginline(BL_WHITE | BL_FIX);\n\t    u_clearline();\t// \"U\" command not possible after \"dd\"\n\t}\n    }\n    else\n    {\n\tif (virtual_op)\n\t{\n\t    int\t\tendcol = 0;\n\n\t    // For virtualedit: break the tabs that are partly included.\n\t    if (gchar_pos(&oap->start) == '\\t')\n\t    {\n\t\tif (u_save_cursor() == FAIL)\t// save first line for undo\n\t\t    return FAIL;\n\t\tif (oap->line_count == 1)\n\t\t    endcol = getviscol2(oap->end.col, oap->end.coladd);\n\t\tcoladvance_force(getviscol2(oap->start.col, oap->start.coladd));\n\t\toap->start = curwin->w_cursor;\n\t\tif (oap->line_count == 1)\n\t\t{\n\t\t    coladvance(endcol);\n\t\t    oap->end.col = curwin->w_cursor.col;\n\t\t    oap->end.coladd = curwin->w_cursor.coladd;\n\t\t    curwin->w_cursor = oap->start;\n\t\t}\n\t    }\n\n\t    // Break a tab only when it's included in the area.\n\t    if (gchar_pos(&oap->end) == '\\t'\n\t\t\t\t     && (int)oap->end.coladd < oap->inclusive)\n\t    {\n\t\t// save last line for undo\n\t\tif (u_save((linenr_T)(oap->end.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t\t    return FAIL;\n\t\tcurwin->w_cursor = oap->end;\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd));\n\t\toap->end = curwin->w_cursor;\n\t\tcurwin->w_cursor = oap->start;\n\t    }\n\t    if (has_mbyte)\n\t\tmb_adjust_opend(oap);\n\t}\n\n\tif (oap->line_count == 1)\t// delete characters within one line\n\t{\n\t    if (u_save_cursor() == FAIL)\t// save line for undo\n\t\treturn FAIL;\n\n\t    // if 'cpoptions' contains '$', display '$' at end of change\n\t    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL\n\t\t    && oap->op_type == OP_CHANGE\n\t\t    && oap->end.lnum == curwin->w_cursor.lnum\n\t\t    && !oap->is_VIsual)\n\t\tdisplay_dollar(oap->end.col - !oap->inclusive);\n\n\t    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;\n\n\t    if (virtual_op)\n\t    {\n\t\t// fix up things for virtualedit-delete:\n\t\t// break the tabs which are going to get in our way\n\t\tchar_u\t\t*curline = ml_get_curline();\n\t\tint\t\tlen = (int)STRLEN(curline);\n\n\t\tif (oap->end.coladd != 0\n\t\t\t&& (int)oap->end.col >= len - 1\n\t\t\t&& !(oap->start.coladd && (int)oap->end.col >= len - 1))\n\t\t    n++;\n\t\t// Delete at least one char (e.g, when on a control char).\n\t\tif (n == 0 && oap->start.coladd != oap->end.coladd)\n\t\t    n = 1;\n\n\t\t// When deleted a char in the line, reset coladd.\n\t\tif (gchar_cursor() != NUL)\n\t\t    curwin->w_cursor.coladd = 0;\n\t    }\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t}\n\telse\t\t\t\t// delete characters between lines\n\t{\n\t    pos_T   curpos;\n\n\t    // save deleted and changed lines for undo\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)\n\t\treturn FAIL;\n\n\t    truncate_line(TRUE);\t// delete from cursor to end of line\n\n\t    curpos = curwin->w_cursor;\t// remember curwin->w_cursor\n\t    ++curwin->w_cursor.lnum;\n\t    del_lines((long)(oap->line_count - 2), FALSE);\n\n\t    // delete from start of line until op_end\n\t    n = (oap->end.col + 1 - !oap->inclusive);\n\t    curwin->w_cursor.col = 0;\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t    curwin->w_cursor = curpos;\t// restore curwin->w_cursor\n\t    (void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t}\n\tif (oap->op_type == OP_DELETE)\n\t    auto_format(FALSE, TRUE);\n    }\n\n    msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n\nsetmarks:\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tif (oap->block_mode)\n\t{\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = oap->start.col;\n\t}\n\telse\n\t    curbuf->b_op_end = oap->start;\n\tcurbuf->b_op_start = oap->start;\n    }\n\n    return OK;\n}\n\n/*\n * Adjust end of operating area for ending on a multi-byte character.\n * Used for deletion.\n */\n    static void\nmb_adjust_opend(oparg_T *oap)\n{\n    char_u\t*p;\n\n    if (oap->inclusive)\n    {\n\tp = ml_get(oap->end.lnum);\n\toap->end.col += mb_tail_off(p, p + oap->end.col);\n    }\n}\n\n/*\n * Replace the character under the cursor with \"c\".\n * This takes care of multi-byte characters.\n */\n    static void\nreplace_character(int c)\n{\n    int n = State;\n\n    State = REPLACE;\n    ins_char(c);\n    State = n;\n    // Backup to the replaced character.\n    dec_cursor();\n}\n\n/*\n * Replace a whole area with one character.\n */\n    int\nop_replace(oparg_T *oap, int c)\n{\n    int\t\t\tn, numc;\n    int\t\t\tnum_chars;\n    char_u\t\t*newp, *oldp;\n    size_t\t\toldlen;\n    struct block_def\tbd;\n    char_u\t\t*after_p = NULL;\n    int\t\t\thad_ctrl_v_cr = FALSE;\n\n    if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n\treturn OK;\t    // nothing to do\n\n    if (c == REPLACE_CR_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = CAR;\n    }\n    else if (c == REPLACE_NL_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = NL;\n    }\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn FAIL;\n\n    /*\n     * block mode replace\n     */\n    if (oap->block_mode)\n    {\n\tbd.is_MAX = (curwin->w_curswant == MAXCOL);\n\tfor ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = 0;  // make sure cursor position is valid\n\t    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n\t    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))\n\t\tcontinue;\t    // nothing to replace\n\n\t    // n == number of extra chars required\n\t    // If we split a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    // If the range starts in virtual space, count the initial\n\t    // coladd offset as part of \"startspaces\"\n\t    if (virtual_op && bd.is_short && *bd.textstart == NUL)\n\t    {\n\t\tpos_T vpos;\n\n\t\tvpos.lnum = curwin->w_cursor.lnum;\n\t\tgetvpos(&vpos, oap->start_vcol);\n\t\tbd.startspaces += vpos.coladd;\n\t\tn = bd.startspaces;\n\t    }\n\t    else\n\t\t// allow for pre spaces\n\t\tn = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n\t    // allow for post spp\n\t    n += (bd.endspaces\n\t\t    && !bd.is_oneChar\n\t\t    && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n\t    // Figure out how many characters to replace.\n\t    numc = oap->end_vcol - oap->start_vcol + 1;\n\t    if (bd.is_short && (!virtual_op || bd.is_MAX))\n\t\tnumc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n\t    // A double-wide character can be replaced only up to half the\n\t    // times.\n\t    if ((*mb_char2cells)(c) > 1)\n\t    {\n\t\tif ((numc & 1) && !bd.is_short)\n\t\t{\n\t\t    ++bd.endspaces;\n\t\t    ++n;\n\t\t}\n\t\tnumc = numc / 2;\n\t    }\n\n\t    // Compute bytes needed, move character count to num_chars.\n\t    num_chars = numc;\n\t    numc *= (*mb_char2len)(c);\n\t    // oldlen includes textlen, so don't double count\n\t    n += numc - bd.textlen;\n\n\t    oldp = ml_get_curline();\n\t    oldlen = STRLEN(oldp);\n\t    newp = alloc(oldlen + 1 + n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    oldp += bd.textcol + bd.textlen;\n\t    // insert pre-spaces\n\t    vim_memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n\t    // insert replacement chars CHECK FOR ALLOCATED SPACE\n\t    // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR\n\t    // literally.\n\t    if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = (int)STRLEN(newp);\n\t\t    while (--num_chars >= 0)\n\t\t\tn += (*mb_char2bytes)(c, newp + n);\n\t\t}\n\t\telse\n\t\t    vim_memset(newp + STRLEN(newp), c, (size_t)numc);\n\t\tif (!bd.is_short)\n\t\t{\n\t\t    // insert post-spaces\n\t\t    vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);\n\t\t    // copy the part after the changed part\n\t\t    STRMOVE(newp + STRLEN(newp), oldp);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Replacing with \\r or \\n means splitting the line.\n\t\tafter_p = alloc(oldlen + 1 + n - STRLEN(newp));\n\t\tif (after_p != NULL)\n\t\t    STRMOVE(after_p, oldp);\n\t    }\n\t    // replace the line\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    if (after_p != NULL)\n\t    {\n\t\tml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);\n\t\tappended_lines_mark(curwin->w_cursor.lnum, 1L);\n\t\toap->end.lnum++;\n\t\tvim_free(after_p);\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * MCHAR and MLINE motion replace.\n\t */\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    curwin->w_cursor.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n\t{\n\t    n = gchar_cursor();\n\t    if (n != NUL)\n\t    {\n\t\tint new_byte_len = (*mb_char2len)(c);\n\t\tint old_byte_len = mb_ptr2len(ml_get_cursor());\n\n\t\tif (new_byte_len > 1 || old_byte_len > 1)\n\t\t{\n\t\t    // This is slow, but it handles replacing a single-byte\n\t\t    // with a multi-byte and the other way around.\n\t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\toap->end.col += new_byte_len - old_byte_len;\n\t\t    replace_character(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (n == TAB)\n\t\t    {\n\t\t\tint end_vcol = 0;\n\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t{\n\t\t\t    // oap->end has to be recalculated when\n\t\t\t    // the tab breaks\n\t\t\t    end_vcol = getviscol2(oap->end.col,\n\t\t\t\t\t\t\t     oap->end.coladd);\n\t\t\t}\n\t\t\tcoladvance_force(getviscol());\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t    getvpos(&oap->end, end_vcol);\n\t\t    }\n\t\t    PBYTE(curwin->w_cursor, c);\n\t\t}\n\t    }\n\t    else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n\t    {\n\t\tint virtcols = oap->end.coladd;\n\n\t\tif (curwin->w_cursor.lnum == oap->start.lnum\n\t\t\t&& oap->start.col == oap->end.col && oap->start.coladd)\n\t\t    virtcols -= oap->start.coladd;\n\n\t\t// oap->end has been trimmed so it's effectively inclusive;\n\t\t// as a result an extra +1 must be counted so we don't\n\t\t// trample the NUL byte.\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n\t\tcurwin->w_cursor.col -= (virtcols + 1);\n\t\tfor (; virtcols >= 0; virtcols--)\n\t\t{\n                   if ((*mb_char2len)(c) > 1)\n\t\t       replace_character(c);\n                   else\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t   if (inc(&curwin->w_cursor) == -1)\n\t\t       break;\n\t\t}\n\t    }\n\n\t    // Advance to next character, stop at the end of the file.\n\t    if (inc_cursor() == -1)\n\t\tbreak;\n\t}\n    }\n\n    curwin->w_cursor = oap->start;\n    check_cursor();\n    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    return OK;\n}\n\nstatic int swapchars(int op_type, pos_T *pos, int length);\n\n/*\n * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\".\n */\n    static void\nop_tilde(oparg_T *oap)\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tdid_change = FALSE;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    pos = oap->start;\n    if (oap->block_mode)\t\t    // Visual block mode\n    {\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    int one_change;\n\n\t    block_prep(oap, &bd, pos.lnum, FALSE);\n\t    pos.col = bd.textcol;\n\t    one_change = swapchars(oap->op_type, &pos, bd.textlen);\n\t    did_change |= one_change;\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\n\t\tnetbeans_removed(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t\t    (long)bd.textlen);\n\t\tnetbeans_inserted(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t&ptr[bd.textcol], bd.textlen);\n\t    }\n#endif\n\t}\n\tif (did_change)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    }\n    else\t\t\t\t    // not block mode\n    {\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    pos.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\tif (pos.lnum == oap->end.lnum)\n\t    did_change = swapchars(oap->op_type, &pos,\n\t\t\t\t\t\t  oap->end.col - pos.col + 1);\n\telse\n\t    for (;;)\n\t    {\n\t\tdid_change |= swapchars(oap->op_type, &pos,\n\t\t\t\tpos.lnum == oap->end.lnum ? oap->end.col + 1:\n\t\t\t\t\t   (int)STRLEN(ml_get_pos(&pos)));\n\t\tif (LTOREQ_POS(oap->end, pos) || inc(&pos) == -1)\n\t\t    break;\n\t    }\n\tif (did_change)\n\t{\n\t    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && did_change)\n\t    {\n\t\tchar_u *ptr;\n\t\tint count;\n\n\t\tpos = oap->start;\n\t\twhile (pos.lnum < oap->end.lnum)\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\t    count = (int)STRLEN(ptr) - pos.col;\n\t\t    netbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\t    netbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tcount = oap->end.col - pos.col + 1;\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t    }\n#endif\n\t}\n    }\n\n    if (!did_change && oap->is_VIsual)\n\t// No change: need to remove the Visual selection\n\tredraw_curbuf_later(INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set '[ and '] marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    if (oap->line_count > p_report)\n\tsmsg(NGETTEXT(\"%ld line changed\", \"%ld lines changed\",\n\t\t\t\t\t    oap->line_count), oap->line_count);\n}\n\n/*\n * Invoke swapchar() on \"length\" bytes at position \"pos\".\n * \"pos\" is advanced to just after the changed characters.\n * \"length\" is rounded up to include the whole last multi-byte character.\n * Also works correctly when the number of bytes changes.\n * Returns TRUE if some character was changed.\n */\n    static int\nswapchars(int op_type, pos_T *pos, int length)\n{\n    int todo;\n    int\tdid_change = 0;\n\n    for (todo = length; todo > 0; --todo)\n    {\n\tif (has_mbyte)\n\t{\n\t    int len = (*mb_ptr2len)(ml_get_pos(pos));\n\n\t    // we're counting bytes, not characters\n\t    if (len > 0)\n\t\ttodo -= len - 1;\n\t}\n\tdid_change |= swapchar(op_type, pos);\n\tif (inc(pos) == -1)    // at end of file\n\t    break;\n    }\n    return did_change;\n}\n\n/*\n * If op_type == OP_UPPER: make uppercase,\n * if op_type == OP_LOWER: make lowercase,\n * if op_type == OP_ROT13: do rot13 encoding,\n * else swap case of character at 'pos'\n * returns TRUE when something actually changed.\n */\n    int\nswapchar(int op_type, pos_T *pos)\n{\n    int\t    c;\n    int\t    nc;\n\n    c = gchar_pos(pos);\n\n    // Only do rot13 encoding for ASCII characters.\n    if (c >= 0x80 && op_type == OP_ROT13)\n\treturn FALSE;\n\n    if (op_type == OP_UPPER && c == 0xdf\n\t\t      && (enc_latin1like || STRCMP(p_enc, \"iso-8859-2\") == 0))\n    {\n\tpos_T   sp = curwin->w_cursor;\n\n\t// Special handling of German sharp s: change to \"SS\".\n\tcurwin->w_cursor = *pos;\n\tdel_char(FALSE);\n\tins_char('S');\n\tins_char('S');\n\tcurwin->w_cursor = sp;\n\tinc(pos);\n    }\n\n    if (enc_dbcs != 0 && c >= 0x100)\t// No lower/uppercase letter\n\treturn FALSE;\n    nc = c;\n    if (MB_ISLOWER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'a');\n\telse if (op_type != OP_LOWER)\n\t    nc = MB_TOUPPER(c);\n    }\n    else if (MB_ISUPPER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'A');\n\telse if (op_type != OP_UPPER)\n\t    nc = MB_TOLOWER(c);\n    }\n    if (nc != c)\n    {\n\tif (enc_utf8 && (c >= 0x80 || nc >= 0x80))\n\t{\n\t    pos_T   sp = curwin->w_cursor;\n\n\t    curwin->w_cursor = *pos;\n\t    // don't use del_char(), it also removes composing chars\n\t    del_bytes(utf_ptr2len(ml_get_cursor()), FALSE, FALSE);\n\t    ins_char(nc);\n\t    curwin->w_cursor = sp;\n\t}\n\telse\n\t    PBYTE(*pos, nc);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * op_insert - Insert and append operators for Visual mode.\n */\n    void\nop_insert(oparg_T *oap, long count1)\n{\n    long\t\tins_len, pre_textlen = 0;\n    char_u\t\t*firstline, *ins_text;\n    colnr_T\t\tind_pre_col = 0, ind_post_col;\n    int\t\t\tind_pre_vcol = 0, ind_post_vcol = 0;\n    struct block_def\tbd;\n    int\t\t\ti;\n    pos_T\t\tt1;\n    pos_T\t\tstart_insert;\n\t\t\t// offset when cursor was moved in insert mode\n    int\t\t\toffset = 0;\n\n    // edit() changes this - record it for OP_APPEND\n    bd.is_MAX = (curwin->w_curswant == MAXCOL);\n\n    // vis block is still marked. Get rid of it now.\n    curwin->w_cursor.lnum = oap->start.lnum;\n    update_screen(INVERTED);\n\n    if (oap->block_mode)\n    {\n\t// When 'virtualedit' is used, need to insert the extra spaces before\n\t// doing block_prep().  When only \"block\" is used, virtual edit is\n\t// already disabled, but still need it when calling\n\t// coladvance_force().\n\t// coladvance_force() uses get_ve_flags() to get the 'virtualedit'\n\t// state for the current window.  To override that state, we need to\n\t// set the window-local value of ve_flags rather than the global value.\n\tif (curwin->w_cursor.coladd > 0)\n\t{\n\t    int\t\told_ve_flags = curwin->w_ve_flags;\n\n\t    if (u_save_cursor() == FAIL)\n\t\treturn;\n\n\t    curwin->w_ve_flags = VE_ALL;\n\t    coladvance_force(oap->op_type == OP_APPEND\n\t\t\t\t\t   ? oap->end_vcol + 1 : getviscol());\n\t    if (oap->op_type == OP_APPEND)\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_ve_flags = old_ve_flags;\n\t}\n\t// Get the info about the block before entering the text\n\tblock_prep(oap, &bd, oap->start.lnum, TRUE);\n\t// Get indent information\n\tind_pre_col = (colnr_T)getwhitecols_curline();\n\tind_pre_vcol = get_indent();\n\tfirstline = ml_get(oap->start.lnum) + bd.textcol;\n\n\tif (oap->op_type == OP_APPEND)\n\t    firstline += bd.textlen;\n\tpre_textlen = (long)STRLEN(firstline);\n    }\n\n    if (oap->op_type == OP_APPEND)\n    {\n\tif (oap->block_mode && curwin->w_cursor.coladd == 0)\n\t{\n\t    // Move the cursor to the character right of the block.\n\t    curwin->w_set_curswant = TRUE;\n\t    while (*ml_get_cursor() != NUL\n\t\t    && (curwin->w_cursor.col < bd.textcol + bd.textlen))\n\t\t++curwin->w_cursor.col;\n\t    if (bd.is_short && !bd.is_MAX)\n\t    {\n\t\t// First line was too short, make it longer and adjust the\n\t\t// values in \"bd\".\n\t\tif (u_save_cursor() == FAIL)\n\t\t    return;\n\t\tfor (i = 0; i < bd.endspaces; ++i)\n\t\t    ins_char(' ');\n\t\tbd.textlen += bd.endspaces;\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = oap->end;\n\t    check_cursor_col();\n\n\t    // Works just like an 'i'nsert on the next character.\n\t    if (!LINEEMPTY(curwin->w_cursor.lnum)\n\t\t    && oap->start_vcol != oap->end_vcol)\n\t\tinc_cursor();\n\t}\n    }\n\n    t1 = oap->start;\n    start_insert = curwin->w_cursor;\n    (void)edit(NUL, FALSE, (linenr_T)count1);\n\n    // When a tab was inserted, and the characters in front of the tab\n    // have been converted to a tab as well, the column of the cursor\n    // might have actually been reduced, so need to adjust here.\n    if (t1.lnum == curbuf->b_op_start_orig.lnum\n\t    && LT_POS(curbuf->b_op_start_orig, t1))\n\toap->start = curbuf->b_op_start_orig;\n\n    // If user has moved off this line, we don't know what to do, so do\n    // nothing.\n    // Also don't repeat the insert when Insert mode ended with CTRL-C.\n    if (curwin->w_cursor.lnum != oap->start.lnum || got_int)\n\treturn;\n\n    if (oap->block_mode)\n    {\n\tstruct block_def\tbd2;\n\tint\t\t\tdid_indent = FALSE;\n\tsize_t\t\t\tlen;\n\tint\t\t\tadd;\n\n\t// If indent kicked in, the firstline might have changed\n\t// but only do that, if the indent actually increased.\n\tind_post_col = (colnr_T)getwhitecols_curline();\n\tif (curbuf->b_op_start.col > ind_pre_col && ind_post_col > ind_pre_col)\n\t{\n\t    bd.textcol += ind_post_col - ind_pre_col;\n\t    ind_post_vcol = get_indent();\n\t    bd.start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    did_indent = TRUE;\n\t}\n\n\t// The user may have moved the cursor before inserting something, try\n\t// to adjust the block for that.  But only do it, if the difference\n\t// does not come from indent kicking in.\n\tif (oap->start.lnum == curbuf->b_op_start_orig.lnum\n\t\t\t\t\t\t  && !bd.is_MAX && !did_indent)\n\t{\n\t    int t = getviscol2(curbuf->b_op_start_orig.col,\n\t\t\t\t\t       curbuf->b_op_start_orig.coladd);\n\n\t    if (!bd.is_MAX)\n\t    {\n\t\tif (oap->op_type == OP_INSERT\n\t\t\t&& oap->start.col + oap->start.coladd\n\t\t\t\t!= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t\t{\n\t\t    oap->start.col = curbuf->b_op_start_orig.col;\n\t\t    pre_textlen -= t - oap->start_vcol;\n\t\t    oap->start_vcol = t;\n\t\t}\n\t\telse if (oap->op_type == OP_APPEND\n\t\t\t&& oap->start.col + oap->start.coladd\n\t\t\t\t>= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t\t{\n\t\t    oap->start.col = curbuf->b_op_start_orig.col;\n\t\t    // reset pre_textlen to the value of OP_INSERT\n\t\t    pre_textlen += bd.textlen;\n\t\t    pre_textlen -= t - oap->start_vcol;\n\t\t    oap->start_vcol = t;\n\t\t    oap->op_type = OP_INSERT;\n\t\t}\n\t    }\n\t    else if (bd.is_MAX && oap->op_type == OP_APPEND)\n\t    {\n\t\t// reset pre_textlen to the value of OP_INSERT\n\t\tpre_textlen += bd.textlen;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t    }\n\t}\n\n\t// Spaces and tabs in the indent may have changed to other spaces and\n\t// tabs.  Get the starting column again and correct the length.\n\t// Don't do this when \"$\" used, end-of-line will have changed.\n\t//\n\t// if indent was added and the inserted text was after the indent,\n\t// correct the selection for the new indent.\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    oap->start.col += ind_post_col - ind_pre_col;\n\t    oap->start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col += ind_post_col - ind_pre_col;\n\t    oap->end_vcol += ind_post_vcol - ind_pre_vcol;\n\t}\n\tblock_prep(oap, &bd2, oap->start.lnum, TRUE);\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    // undo for where \"oap\" is used below\n\t    oap->start.col -= ind_post_col - ind_pre_col;\n\t    oap->start_vcol -= ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col -= ind_post_col - ind_pre_col;\n\t    oap->end_vcol -= ind_post_vcol - ind_pre_vcol;\n\t}\n\tif (!bd.is_MAX || bd2.textlen < bd.textlen)\n\t{\n\t    if (oap->op_type == OP_APPEND)\n\t    {\n\t\tpre_textlen += bd2.textlen - bd.textlen;\n\t\tif (bd2.endspaces)\n\t\t    --bd2.textlen;\n\t    }\n\t    bd.textcol = bd2.textcol;\n\t    bd.textlen = bd2.textlen;\n\t}\n\n\t/*\n\t * Subsequent calls to ml_get() flush the firstline data - take a\n\t * copy of the required string.\n\t */\n\tfirstline = ml_get(oap->start.lnum);\n\tlen = STRLEN(firstline);\n\tadd = bd.textcol;\n\tif (oap->op_type == OP_APPEND)\n\t{\n\t    add += bd.textlen;\n\t    // account for pressing cursor in insert mode when '$' was used\n\t    if (bd.is_MAX\n\t\t&& (start_insert.lnum == Insstart.lnum\n\t\t\t\t\t   && start_insert.col > Insstart.col))\n\t    {\n\t\toffset = (start_insert.col - Insstart.col);\n\t\tadd -= offset;\n\t\tif (oap->end_vcol > offset)\n\t\t    oap->end_vcol -= (offset + 1);\n\t\telse\n\t\t    // moved outside of the visual block, what to do?\n\t\t    return;\n\t    }\n\t}\n\tif ((size_t)add > len)\n\t    firstline += len;  // short line, point to the NUL\n\telse\n\t    firstline += add;\n\tif (pre_textlen >= 0 && (ins_len =\n\t\t\t   (long)STRLEN(firstline) - pre_textlen - offset) > 0)\n\t{\n\t    ins_text = vim_strnsave(firstline, ins_len);\n\t    if (ins_text != NULL)\n\t    {\n\t\t// block handled here\n\t\tif (u_save(oap->start.lnum,\n\t\t\t\t\t (linenr_T)(oap->end.lnum + 1)) == OK)\n\t\t    block_insert(oap, ins_text, (oap->op_type == OP_INSERT),\n\t\t\t\t\t\t\t\t\t &bd);\n\n\t\tcurwin->w_cursor.col = oap->start.col;\n\t\tcheck_cursor();\n\t\tvim_free(ins_text);\n\t    }\n\t}\n    }\n}\n\n/*\n * op_change - handle a change operation\n *\n * return TRUE if edit() returns because of a CTRL-O command\n */\n    int\nop_change(oparg_T *oap)\n{\n    colnr_T\t\tl;\n    int\t\t\tretval;\n    long\t\toffset;\n    linenr_T\t\tlinenr;\n    long\t\tins_len;\n    long\t\tpre_textlen = 0;\n    long\t\tpre_indent = 0;\n    char_u\t\t*firstline;\n    char_u\t\t*ins_text, *newp, *oldp;\n    struct block_def\tbd;\n\n    l = oap->start.col;\n    if (oap->motion_type == MLINE)\n    {\n\tl = 0;\n#ifdef FEAT_SMARTINDENT\n\tif (!p_paste && curbuf->b_p_si\n# ifdef FEAT_CINDENT\n\t\t&& !curbuf->b_p_cin\n# endif\n\t\t)\n\t    can_si = TRUE;\t// It's like opening a new line, do si\n#endif\n    }\n\n    // First delete the text in the region.  In an empty buffer only need to\n    // save for undo\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return FALSE;\n    }\n    else if (op_delete(oap) == FAIL)\n\treturn FALSE;\n\n    if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t && !virtual_op)\n\tinc_cursor();\n\n    // check for still on same line (<CR> in inserted text meaningless)\n    // skip blank lines too\n    if (oap->block_mode)\n    {\n\t// Add spaces before getting the current line length.\n\tif (virtual_op && (curwin->w_cursor.coladd > 0\n\t\t\t\t\t\t    || gchar_cursor() == NUL))\n\t    coladvance_force(getviscol());\n\tfirstline = ml_get(oap->start.lnum);\n\tpre_textlen = (long)STRLEN(firstline);\n\tpre_indent = (long)getwhitecols(firstline);\n\tbd.textcol = curwin->w_cursor.col;\n    }\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    if (oap->motion_type == MLINE)\n\tfix_indent();\n#endif\n\n    retval = edit(NUL, FALSE, (linenr_T)1);\n\n    /*\n     * In Visual block mode, handle copying the new text to all lines of the\n     * block.\n     * Don't repeat the insert when Insert mode ended with CTRL-C.\n     */\n    if (oap->block_mode && oap->start.lnum != oap->end.lnum && !got_int)\n    {\n\t// Auto-indenting may have changed the indent.  If the cursor was past\n\t// the indent, exclude that indent change from the inserted text.\n\tfirstline = ml_get(oap->start.lnum);\n\tif (bd.textcol > (colnr_T)pre_indent)\n\t{\n\t    long new_indent = (long)getwhitecols(firstline);\n\n\t    pre_textlen += new_indent - pre_indent;\n\t    bd.textcol += new_indent - pre_indent;\n\t}\n\n\tins_len = (long)STRLEN(firstline) - pre_textlen;\n\tif (ins_len > 0)\n\t{\n\t    // Subsequent calls to ml_get() flush the firstline data - take a\n\t    // copy of the inserted text.\n\t    if ((ins_text = alloc(ins_len + 1)) != NULL)\n\t    {\n\t\tvim_strncpy(ins_text, firstline + bd.textcol, (size_t)ins_len);\n\t\tfor (linenr = oap->start.lnum + 1; linenr <= oap->end.lnum;\n\t\t\t\t\t\t\t\t     linenr++)\n\t\t{\n\t\t    block_prep(oap, &bd, linenr, TRUE);\n\t\t    if (!bd.is_short || virtual_op)\n\t\t    {\n\t\t\tpos_T vpos;\n\n\t\t\t// If the block starts in virtual space, count the\n\t\t\t// initial coladd offset as part of \"startspaces\"\n\t\t\tif (bd.is_short)\n\t\t\t{\n\t\t\t    vpos.lnum = linenr;\n\t\t\t    (void)getvpos(&vpos, oap->start_vcol);\n\t\t\t}\n\t\t\telse\n\t\t\t    vpos.coladd = 0;\n\t\t\toldp = ml_get(linenr);\n\t\t\tnewp = alloc(STRLEN(oldp) + vpos.coladd + ins_len + 1);\n\t\t\tif (newp == NULL)\n\t\t\t    continue;\n\t\t\t// copy up to block start\n\t\t\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\t\t\toffset = bd.textcol;\n\t\t\tvim_memset(newp + offset, ' ', (size_t)vpos.coladd);\n\t\t\toffset += vpos.coladd;\n\t\t\tmch_memmove(newp + offset, ins_text, (size_t)ins_len);\n\t\t\toffset += ins_len;\n\t\t\toldp += bd.textcol;\n\t\t\tSTRMOVE(newp + offset, oldp);\n\t\t\tml_replace(linenr, newp, FALSE);\n\t\t    }\n\t\t}\n\t\tcheck_cursor();\n\n\t\tchanged_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\t    }\n\t    vim_free(ins_text);\n\t}\n    }\n    auto_format(FALSE, TRUE);\n\n    return retval;\n}\n\n/*\n * When the cursor is on the NUL past the end of the line and it should not be\n * there move it left.\n */\n    void\nadjust_cursor_eol(void)\n{\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    if (curwin->w_cursor.col > 0\n\t    && gchar_cursor() == NUL\n\t    && (cur_ve_flags & VE_ONEMORE) == 0\n\t    && !(restart_edit || (State & INSERT)))\n    {\n\t// Put the cursor on the last character in the line.\n\tdec_cursor();\n\n\tif (cur_ve_flags == VE_ALL)\n\t{\n\t    colnr_T\t    scol, ecol;\n\n\t    // Coladd is set to the width of the last character.\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol + 1;\n\t}\n    }\n}\n\n/*\n * If \"process\" is TRUE and the line begins with a comment leader (possibly\n * after some white space), return a pointer to the text after it. Put a boolean\n * value indicating whether the line ends with an unclosed comment in\n * \"is_comment\".\n * line - line to be processed,\n * process - if FALSE, will only check whether the line ends with an unclosed\n *\t     comment,\n * include_space - whether to also skip space following the comment leader,\n * is_comment - will indicate whether the current line ends with an unclosed\n *\t\tcomment.\n */\n    char_u *\nskip_comment(\n    char_u   *line,\n    int      process,\n    int\t     include_space,\n    int      *is_comment)\n{\n    char_u *comment_flags = NULL;\n    int    lead_len;\n    int    leader_offset = get_last_leader_offset(line, &comment_flags);\n\n    *is_comment = FALSE;\n    if (leader_offset != -1)\n    {\n\t// Let's check whether the line ends with an unclosed comment.\n\t// If the last comment leader has COM_END in flags, there's no comment.\n\twhile (*comment_flags)\n\t{\n\t    if (*comment_flags == COM_END\n\t\t    || *comment_flags == ':')\n\t\tbreak;\n\t    ++comment_flags;\n\t}\n\tif (*comment_flags != COM_END)\n\t    *is_comment = TRUE;\n    }\n\n    if (process == FALSE)\n\treturn line;\n\n    lead_len = get_leader_len(line, &comment_flags, FALSE, include_space);\n\n    if (lead_len == 0)\n\treturn line;\n\n    // Find:\n    // - COM_END,\n    // - colon,\n    // whichever comes first.\n    while (*comment_flags)\n    {\n\tif (*comment_flags == COM_END\n\t\t|| *comment_flags == ':')\n\t    break;\n\t++comment_flags;\n    }\n\n    // If we found a colon, it means that we are not processing a line\n    // starting with a closing part of a three-part comment. That's good,\n    // because we don't want to remove those as this would be annoying.\n    if (*comment_flags == ':' || *comment_flags == NUL)\n\tline += lead_len;\n\n    return line;\n}\n\n/*\n * Join 'count' lines (minimal 2) at cursor position.\n * When \"save_undo\" is TRUE save lines for undo first.\n * Set \"use_formatoptions\" to FALSE when e.g. processing backspace and comment\n * leaders should not be removed.\n * When setmark is TRUE, sets the '[ and '] mark, else, the caller is expected\n * to set those marks.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_join(\n    long    count,\n    int\t    insert_space,\n    int\t    save_undo,\n    int\t    use_formatoptions UNUSED,\n    int\t    setmark)\n{\n    char_u\t*curr = NULL;\n    char_u      *curr_start = NULL;\n    char_u\t*cend;\n    char_u\t*newp;\n    size_t\tnewp_len;\n    char_u\t*spaces;\t// number of spaces inserted before a line\n    int\t\tendcurr1 = NUL;\n    int\t\tendcurr2 = NUL;\n    int\t\tcurrsize = 0;\t// size of the current line\n    int\t\tsumsize = 0;\t// size of the long new line\n    linenr_T\tt;\n    colnr_T\tcol = 0;\n    int\t\tret = OK;\n    int\t\t*comments = NULL;\n    int\t\tremove_comments = (use_formatoptions == TRUE)\n\t\t\t\t  && has_format_option(FO_REMOVE_COMS);\n    int\t\tprev_was_comment;\n#ifdef FEAT_PROP_POPUP\n    int\t\tpropcount = 0;\t// number of props over all joined lines\n    int\t\tprops_remaining;\n#endif\n\n    if (save_undo && u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t    (linenr_T)(curwin->w_cursor.lnum + count)) == FAIL)\n\treturn FAIL;\n\n    // Allocate an array to store the number of spaces inserted before each\n    // line.  We will use it to pre-compute the length of the new line and the\n    // proper placement of each original line in the new one.\n    spaces = lalloc_clear(count, TRUE);\n    if (spaces == NULL)\n\treturn FAIL;\n    if (remove_comments)\n    {\n\tcomments = lalloc_clear(count * sizeof(int), TRUE);\n\tif (comments == NULL)\n\t{\n\t    vim_free(spaces);\n\t    return FAIL;\n\t}\n    }\n\n    /*\n     * Don't move anything yet, just compute the final line length\n     * and setup the array of space strings lengths\n     * This loops forward over the joined lines.\n     */\n    for (t = 0; t < count; ++t)\n    {\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));\n#ifdef FEAT_PROP_POPUP\n\tpropcount += count_props((linenr_T) (curwin->w_cursor.lnum + t), t > 0);\n#endif\n\tif (t == 0 && setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ mark.\n\t    curwin->w_buffer->b_op_start.lnum = curwin->w_cursor.lnum;\n\t    curwin->w_buffer->b_op_start.col  = (colnr_T)STRLEN(curr);\n\t}\n\tif (remove_comments)\n\t{\n\t    // We don't want to remove the comment leader if the\n\t    // previous line is not a comment.\n\t    if (t > 0 && prev_was_comment)\n\t    {\n\n\t\tchar_u *new_curr = skip_comment(curr, TRUE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t\tcomments[t] = (int)(new_curr - curr);\n\t\tcurr = new_curr;\n\t    }\n\t    else\n\t\tcurr = skip_comment(curr, FALSE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t}\n\n\tif (insert_space && t > 0)\n\t{\n\t    curr = skipwhite(curr);\n\t    if (*curr != NUL && *curr != ')'\n\t\t    && sumsize != 0 && endcurr1 != TAB\n\t\t    && (!has_format_option(FO_MBYTE_JOIN)\n\t\t\t|| (mb_ptr2char(curr) < 0x100 && endcurr1 < 0x100))\n\t\t    && (!has_format_option(FO_MBYTE_JOIN2)\n\t\t\t|| (mb_ptr2char(curr) < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(endcurr1)))\n\t\t\t|| (endcurr1 < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(mb_ptr2char(curr)))))\n\t       )\n\t    {\n\t\t// don't add a space if the line is ending in a space\n\t\tif (endcurr1 == ' ')\n\t\t    endcurr1 = endcurr2;\n\t\telse\n\t\t    ++spaces[t];\n\t\t// extra space when 'joinspaces' set and line ends in '.'\n\t\tif (       p_js\n\t\t\t&& (endcurr1 == '.'\n\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t&& (endcurr1 == '?' || endcurr1 == '!'))))\n\t\t    ++spaces[t];\n\t    }\n\t}\n\tcurrsize = (int)STRLEN(curr);\n\tsumsize += currsize + spaces[t];\n\tendcurr1 = endcurr2 = NUL;\n\tif (insert_space && currsize > 0)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcend = curr + currsize;\n\t\tMB_PTR_BACK(curr, cend);\n\t\tendcurr1 = (*mb_ptr2char)(cend);\n\t\tif (cend > curr)\n\t\t{\n\t\t    MB_PTR_BACK(curr, cend);\n\t\t    endcurr2 = (*mb_ptr2char)(cend);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tendcurr1 = *(curr + currsize - 1);\n\t\tif (currsize > 1)\n\t\t    endcurr2 = *(curr + currsize - 2);\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t{\n\t    ret = FAIL;\n\t    goto theend;\n\t}\n    }\n\n    // store the column position before last line\n    col = sumsize - currsize - spaces[count - 1];\n\n    // allocate the space for the new line\n    newp_len = sumsize + 1;\n#ifdef FEAT_PROP_POPUP\n    newp_len += propcount * sizeof(textprop_T);\n#endif\n    newp = alloc(newp_len);\n    if (newp == NULL)\n    {\n\tret = FAIL;\n\tgoto theend;\n    }\n    cend = newp + sumsize;\n    *cend = 0;\n\n    /*\n     * Move affected lines to the new long one.\n     * This loops backwards over the joined lines, including the original line.\n     *\n     * Move marks from each deleted line to the joined line, adjusting the\n     * column.  This is not Vi compatible, but Vi deletes the marks, thus that\n     * should not really be a problem.\n     */\n#ifdef FEAT_PROP_POPUP\n    props_remaining = propcount;\n#endif\n    for (t = count - 1; ; --t)\n    {\n\tint spaces_removed;\n\n\tcend -= currsize;\n\tmch_memmove(cend, curr, (size_t)currsize);\n\n\tif (spaces[t] > 0)\n\t{\n\t    cend -= spaces[t];\n\t    vim_memset(cend, ' ', (size_t)(spaces[t]));\n\t}\n\n\t// If deleting more spaces than adding, the cursor moves no more than\n\t// what is added if it is inside these spaces.\n\tspaces_removed = (curr - curr_start) - spaces[t];\n\n\tmark_col_adjust(curwin->w_cursor.lnum + t, (colnr_T)0, (linenr_T)-t,\n\t\t\t (long)(cend - newp - spaces_removed), spaces_removed);\n#ifdef FEAT_PROP_POPUP\n\tprepend_joined_props(newp + sumsize + 1, propcount, &props_remaining,\n\t\tcurwin->w_cursor.lnum + t, t == count - 1,\n\t\t(long)(cend - newp), spaces_removed);\n#endif\n\n\tif (t == 0)\n\t    break;\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));\n\tif (remove_comments)\n\t    curr += comments[t - 1];\n\tif (insert_space && t > 1)\n\t    curr = skipwhite(curr);\n\tcurrsize = (int)STRLEN(curr);\n    }\n\n    ml_replace_len(curwin->w_cursor.lnum, newp, (colnr_T)newp_len, TRUE, FALSE);\n\n    if (setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set the '] mark.\n\tcurwin->w_buffer->b_op_end.lnum = curwin->w_cursor.lnum;\n\tcurwin->w_buffer->b_op_end.col  = (colnr_T)sumsize;\n    }\n\n    // Only report the change in the first line here, del_lines() will report\n    // the deleted line.\n    changed_lines(curwin->w_cursor.lnum, currsize,\n\t\t\t\t\t       curwin->w_cursor.lnum + 1, 0L);\n    /*\n     * Delete following lines. To do this we move the cursor there\n     * briefly, and then move it back. After del_lines() the cursor may\n     * have moved up (last line deleted), so the current lnum is kept in t.\n     */\n    t = curwin->w_cursor.lnum;\n    ++curwin->w_cursor.lnum;\n    del_lines(count - 1, FALSE);\n    curwin->w_cursor.lnum = t;\n\n    /*\n     * Set the cursor column:\n     * Vi compatible: use the column of the first join\n     * vim:\t      use the column of the last join\n     */\n    curwin->w_cursor.col =\n\t\t    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);\n    check_cursor_col();\n\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n\ntheend:\n    vim_free(spaces);\n    if (remove_comments)\n\tvim_free(comments);\n    return ret;\n}\n\n/*\n * prepare a few things for block mode yank/delete/tilde\n *\n * for delete:\n * - textlen includes the first/last char to be (partly) deleted\n * - start/endspaces is the number of columns that are taken by the\n *   first/last deleted char minus the number of columns that have to be\n *   deleted.\n * for yank and tilde:\n * - textlen includes the first/last char to be wholly yanked\n * - start/endspaces is the number of columns of the first/last yanked char\n *   that are to be yanked.\n */\n    void\nblock_prep(\n    oparg_T\t\t*oap,\n    struct block_def\t*bdp,\n    linenr_T\t\tlnum,\n    int\t\t\tis_del)\n{\n    int\t\tincr = 0;\n    char_u\t*pend;\n    char_u\t*pstart;\n    char_u\t*line;\n    char_u\t*prev_pstart;\n    char_u\t*prev_pend;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n\n    // Avoid a problem with unwanted linebreaks in block mode.\n    curwin->w_p_lbr = FALSE;\n#endif\n    bdp->startspaces = 0;\n    bdp->endspaces = 0;\n    bdp->textlen = 0;\n    bdp->start_vcol = 0;\n    bdp->end_vcol = 0;\n    bdp->is_short = FALSE;\n    bdp->is_oneChar = FALSE;\n    bdp->pre_whitesp = 0;\n    bdp->pre_whitesp_c = 0;\n    bdp->end_char_vcols = 0;\n    bdp->start_char_vcols = 0;\n\n    line = ml_get(lnum);\n    pstart = line;\n    prev_pstart = line;\n    while (bdp->start_vcol < oap->start_vcol && *pstart)\n    {\n\t// Count a tab for what it's worth (if list mode not on)\n\tincr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);\n\tbdp->start_vcol += incr;\n\tif (VIM_ISWHITE(*pstart))\n\t{\n\t    bdp->pre_whitesp += incr;\n\t    bdp->pre_whitesp_c++;\n\t}\n\telse\n\t{\n\t    bdp->pre_whitesp = 0;\n\t    bdp->pre_whitesp_c = 0;\n\t}\n\tprev_pstart = pstart;\n\tMB_PTR_ADV(pstart);\n    }\n    bdp->start_char_vcols = incr;\n    if (bdp->start_vcol < oap->start_vcol)\t// line too short\n    {\n\tbdp->end_vcol = bdp->start_vcol;\n\tbdp->is_short = TRUE;\n\tif (!is_del || oap->op_type == OP_APPEND)\n\t    bdp->endspaces = oap->end_vcol - oap->start_vcol + 1;\n    }\n    else\n    {\n\t// notice: this converts partly selected Multibyte characters to\n\t// spaces, too.\n\tbdp->startspaces = bdp->start_vcol - oap->start_vcol;\n\tif (is_del && bdp->startspaces)\n\t    bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;\n\tpend = pstart;\n\tbdp->end_vcol = bdp->start_vcol;\n\tif (bdp->end_vcol > oap->end_vcol)\t// it's all in one character\n\t{\n\t    bdp->is_oneChar = TRUE;\n\t    if (oap->op_type == OP_INSERT)\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    else if (oap->op_type == OP_APPEND)\n\t    {\n\t\tbdp->startspaces += oap->end_vcol - oap->start_vcol + 1;\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    }\n\t    else\n\t    {\n\t\tbdp->startspaces = oap->end_vcol - oap->start_vcol + 1;\n\t\tif (is_del && oap->op_type != OP_LSHIFT)\n\t\t{\n\t\t    // just putting the sum of those two into\n\t\t    // bdp->startspaces doesn't work for Visual replace,\n\t\t    // so we have to split the tab in two\n\t\t    bdp->startspaces = bdp->start_char_vcols\n\t\t\t\t\t- (bdp->start_vcol - oap->start_vcol);\n\t\t    bdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    prev_pend = pend;\n\t    while (bdp->end_vcol <= oap->end_vcol && *pend != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tprev_pend = pend;\n\t\tincr = lbr_chartabsize_adv(line, &pend, (colnr_T)bdp->end_vcol);\n\t\tbdp->end_vcol += incr;\n\t    }\n\t    if (bdp->end_vcol <= oap->end_vcol\n\t\t    && (!is_del\n\t\t\t|| oap->op_type == OP_APPEND\n\t\t\t|| oap->op_type == OP_REPLACE)) // line too short\n\t    {\n\t\tbdp->is_short = TRUE;\n\t\t// Alternative: include spaces to fill up the block.\n\t\t// Disadvantage: can lead to trailing spaces when the line is\n\t\t// short where the text is put\n\t\t// if (!is_del || oap->op_type == OP_APPEND)\n\t\tif (oap->op_type == OP_APPEND || virtual_op)\n\t\t    bdp->endspaces = oap->end_vcol - bdp->end_vcol\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\telse\n\t\t    bdp->endspaces = 0; // replace doesn't add characters\n\t    }\n\t    else if (bdp->end_vcol > oap->end_vcol)\n\t    {\n\t\tbdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\tif (!is_del && bdp->endspaces)\n\t\t{\n\t\t    bdp->endspaces = incr - bdp->endspaces;\n\t\t    if (pend != pstart)\n\t\t\tpend = prev_pend;\n\t\t}\n\t    }\n\t}\n\tbdp->end_char_vcols = incr;\n\tif (is_del && bdp->startspaces)\n\t    pstart = prev_pstart;\n\tbdp->textlen = (int)(pend - pstart);\n    }\n    bdp->textcol = (colnr_T) (pstart - line);\n    bdp->textstart = pstart;\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n\n/*\n * Handle the add/subtract operator.\n */\n    void\nop_addsub(\n    oparg_T\t*oap,\n    linenr_T\tPrenum1,\t    // Amount of add/subtract\n    int\t\tg_cmd)\t\t    // was g<c-a>/g<c-x>\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tchange_cnt = 0;\n    linenr_T\t\tamount = Prenum1;\n\n   // do_addsub() might trigger re-evaluation of 'foldexpr' halfway, when the\n   // buffer is not completely updated yet. Postpone updating folds until before\n   // the call to changed_lines().\n#ifdef FEAT_FOLDING\n   disable_fold_update++;\n#endif\n\n    if (!VIsual_active)\n    {\n\tpos = curwin->w_cursor;\n\tif (u_save_cursor() == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\tchange_cnt = do_addsub(oap->op_type, &pos, 0, amount);\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(pos.lnum, 0, pos.lnum + 1, 0L);\n    }\n    else\n    {\n\tint\tone_change;\n\tint\tlength;\n\tpos_T\tstartpos;\n\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t\t(linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\n\tpos = oap->start;\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    if (oap->block_mode)\t\t    // Visual block mode\n\t    {\n\t\tblock_prep(oap, &bd, pos.lnum, FALSE);\n\t\tpos.col = bd.textcol;\n\t\tlength = bd.textlen;\n\t    }\n\t    else if (oap->motion_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tpos.col = 0;\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t    }\n\t    else // oap->motion_type == MCHAR\n\t    {\n\t\tif (pos.lnum == oap->start.lnum && !oap->inclusive)\n\t\t    dec(&(oap->end));\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t\tpos.col = 0;\n\t\tif (pos.lnum == oap->start.lnum)\n\t\t{\n\t\t    pos.col += oap->start.col;\n\t\t    length -= oap->start.col;\n\t\t}\n\t\tif (pos.lnum == oap->end.lnum)\n\t\t{\n\t\t    length = (int)STRLEN(ml_get(oap->end.lnum));\n\t\t    if (oap->end.col >= length)\n\t\t\toap->end.col = length - 1;\n\t\t    length = oap->end.col - pos.col + 1;\n\t\t}\n\t    }\n\t    one_change = do_addsub(oap->op_type, &pos, length, amount);\n\t    if (one_change)\n\t    {\n\t\t// Remember the start position of the first change.\n\t\tif (change_cnt == 0)\n\t\t    startpos = curbuf->b_op_start;\n\t\t++change_cnt;\n\t    }\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr;\n\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)length);\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t&ptr[pos.col], length);\n\t    }\n#endif\n\t    if (g_cmd && one_change)\n\t\tamount += Prenum1;\n\t}\n\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n\n\tif (!change_cnt && oap->is_VIsual)\n\t    // No change: need to remove the Visual selection\n\t    redraw_curbuf_later(INVERTED);\n\n\t// Set '[ mark if something changed. Keep the last end\n\t// position from do_addsub().\n\tif (change_cnt > 0 && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t    curbuf->b_op_start = startpos;\n\n\tif (change_cnt > p_report)\n\t    smsg(NGETTEXT(\"%d line changed\", \"%d lines changed\",\n\t\t\t\t\t\t      change_cnt), change_cnt);\n    }\n}\n\n/*\n * Add or subtract 'Prenum1' from a number in a line\n * op_type is OP_NR_ADD or OP_NR_SUB\n *\n * Returns TRUE if some character was changed.\n */\n    static int\ndo_addsub(\n    int\t\top_type,\n    pos_T\t*pos,\n    int\t\tlength,\n    linenr_T\tPrenum1)\n{\n    int\t\tcol;\n    char_u\t*buf1;\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tpre;\t\t// 'X'/'x': hex; '0': octal; 'B'/'b': bin\n    static int\thexupper = FALSE;\t// 0xABC\n    uvarnumber_T\tn;\n    uvarnumber_T\toldn;\n    char_u\t*ptr;\n    int\t\tc;\n    int\t\ttodel;\n    int\t\tdo_hex;\n    int\t\tdo_oct;\n    int\t\tdo_bin;\n    int\t\tdo_alpha;\n    int\t\tdo_unsigned;\n    int\t\tfirstdigit;\n    int\t\tsubtract;\n    int\t\tnegative = FALSE;\n    int\t\twas_positive = TRUE;\n    int\t\tvisual = VIsual_active;\n    int\t\tdid_change = FALSE;\n    pos_T\tsave_cursor = curwin->w_cursor;\n    int\t\tmaxlen = 0;\n    pos_T\tstartpos;\n    pos_T\tendpos;\n    colnr_T\tsave_coladd = 0;\n\n    do_hex = (vim_strchr(curbuf->b_p_nf, 'x') != NULL);\t// \"heX\"\n    do_oct = (vim_strchr(curbuf->b_p_nf, 'o') != NULL);\t// \"Octal\"\n    do_bin = (vim_strchr(curbuf->b_p_nf, 'b') != NULL);\t// \"Bin\"\n    do_alpha = (vim_strchr(curbuf->b_p_nf, 'p') != NULL);\t// \"alPha\"\n    do_unsigned = (vim_strchr(curbuf->b_p_nf, 'u') != NULL);\t// \"Unsigned\"\n\n    if (virtual_active())\n    {\n\tsave_coladd = pos->coladd;\n\tpos->coladd = 0;\n    }\n\n    curwin->w_cursor = *pos;\n    ptr = ml_get(pos->lnum);\n    col = pos->col;\n\n    if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr))\n\tgoto theend;\n\n    /*\n     * First check if we are on a hexadecimal number, after the \"0x\".\n     */\n    if (!VIsual_active)\n    {\n\tif (do_bin)\n\t    while (col > 0 && vim_isbdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (do_hex)\n\t    while (col > 0 && vim_isxdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (       do_bin\n\t\t&& do_hex\n\t\t&& ! ((col > 0\n\t\t    && (ptr[col] == 'X'\n\t\t\t|| ptr[col] == 'x')\n\t\t    && ptr[col - 1] == '0'\n\t\t    && (!has_mbyte ||\n\t\t\t!(*mb_head_off)(ptr, ptr + col - 1))\n\t\t    && vim_isxdigit(ptr[col + 1]))))\n\t{\n\n\t    // In case of binary/hexadecimal pattern overlap match, rescan\n\n\t    col = pos->col;\n\n\t    while (col > 0 && vim_isdigit(ptr[col]))\n\t    {\n\t\tcol--;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n\n\tif ((       do_hex\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'X'\n\t\t    || ptr[col] == 'x')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isxdigit(ptr[col + 1])) ||\n\t    (       do_bin\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'B'\n\t\t    || ptr[col] == 'b')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isbdigit(ptr[col + 1])))\n\t{\n\t    // Found hexadecimal or binary number, move to its start.\n\t    --col;\n\t    if (has_mbyte)\n\t\tcol -= (*mb_head_off)(ptr, ptr + col);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Search forward and then backward to find the start of number.\n\t     */\n\t    col = pos->col;\n\n\t    while (ptr[col] != NUL\n\t\t    && !vim_isdigit(ptr[col])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t\tcol += mb_ptr2len(ptr + col);\n\n\t    while (col > 0\n\t\t    && vim_isdigit(ptr[col - 1])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n    }\n\n    if (visual)\n    {\n\twhile (ptr[col] != NUL && length > 0\n\t\t&& !vim_isdigit(ptr[col])\n\t\t&& !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t{\n\t    int mb_len = mb_ptr2len(ptr + col);\n\n\t    col += mb_len;\n\t    length -= mb_len;\n\t}\n\n\tif (length == 0)\n\t    goto theend;\n\n\tif (col > pos->col && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !do_unsigned)\n\t{\n\t    negative = TRUE;\n\t    was_positive = FALSE;\n\t}\n    }\n\n    /*\n     * If a number was found, and saving for undo works, replace the number.\n     */\n    firstdigit = ptr[col];\n    if (!VIM_ISDIGIT(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit)))\n    {\n\tbeep_flush();\n\tgoto theend;\n    }\n\n    if (do_alpha && ASCII_ISALPHA(firstdigit))\n    {\n\t// decrement or increment alphabetic character\n\tif (op_type == OP_NR_SUB)\n\t{\n\t    if (CharOrd(firstdigit) < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'A';\n\t\telse\n\t\t    firstdigit = 'a';\n\t    }\n\t    else\n#ifdef EBCDIC\n\t\tfirstdigit = EBCDIC_CHAR_ADD(firstdigit, -Prenum1);\n#else\n\t\tfirstdigit -= Prenum1;\n#endif\n\t}\n\telse\n\t{\n\t    if (26 - CharOrd(firstdigit) - 1 < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'Z';\n\t\telse\n\t\t    firstdigit = 'z';\n\t    }\n\t    else\n#ifdef EBCDIC\n\t\tfirstdigit = EBCDIC_CHAR_ADD(firstdigit, Prenum1);\n#else\n\t\tfirstdigit += Prenum1;\n#endif\n\t}\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\t(void)del_char(FALSE);\n\tins_char(firstdigit);\n\tendpos = curwin->w_cursor;\n\tcurwin->w_cursor.col = col;\n    }\n    else\n    {\n\tpos_T\tsave_pos;\n\tint\ti;\n\n\tif (col > 0 && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !visual\n\t\t&& !do_unsigned)\n\t{\n\t    // negative number\n\t    --col;\n\t    negative = TRUE;\n\t}\n\t// get the number value (unsigned)\n\tif (visual && VIsual_mode != 'V')\n\t    maxlen = (curbuf->b_visual.vi_curswant == MAXCOL\n\t\t    ? (int)STRLEN(ptr) - col\n\t\t    : length);\n\n\tvim_str2nr(ptr + col, &pre, &length,\n\t\t0 + (do_bin ? STR2NR_BIN : 0)\n\t\t    + (do_oct ? STR2NR_OCT : 0)\n\t\t    + (do_hex ? STR2NR_HEX : 0),\n\t\tNULL, &n, maxlen, FALSE);\n\n\t// ignore leading '-' for hex and octal and bin numbers\n\tif (pre && negative)\n\t{\n\t    ++col;\n\t    --length;\n\t    negative = FALSE;\n\t}\n\t// add or subtract\n\tsubtract = FALSE;\n\tif (op_type == OP_NR_SUB)\n\t    subtract ^= TRUE;\n\tif (negative)\n\t    subtract ^= TRUE;\n\n\toldn = n;\n\tif (subtract)\n\t    n -= (uvarnumber_T)Prenum1;\n\telse\n\t    n += (uvarnumber_T)Prenum1;\n\t// handle wraparound for decimal numbers\n\tif (!pre)\n\t{\n\t    if (subtract)\n\t    {\n\t\tif (n > oldn)\n\t\t{\n\t\t    n = 1 + (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// add\n\t\tif (n < oldn)\n\t\t{\n\t\t    n = (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    if (n == 0)\n\t\tnegative = FALSE;\n\t}\n\n\tif (do_unsigned && negative)\n\t{\n\t    if (subtract)\n\t\t// sticking at zero.\n\t\tn = (uvarnumber_T)0;\n\t    else\n\t\t// sticking at 2^64 - 1.\n\t\tn = (uvarnumber_T)(-1);\n\t    negative = FALSE;\n\t}\n\n\tif (visual && !was_positive && !negative && col > 0)\n\t{\n\t    // need to remove the '-'\n\t    col--;\n\t    length++;\n\t}\n\n\t/*\n\t * Delete the old number.\n\t */\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\ttodel = length;\n\tc = gchar_cursor();\n\t/*\n\t * Don't include the '-' in the length, only the length of the\n\t * part after it is kept the same.\n\t */\n\tif (c == '-')\n\t    --length;\n\n\tsave_pos = curwin->w_cursor;\n\tfor (i = 0; i < todel; ++i)\n\t{\n\t    if (c < 0x100 && isalpha(c))\n\t    {\n\t\tif (isupper(c))\n\t\t    hexupper = TRUE;\n\t\telse\n\t\t    hexupper = FALSE;\n\t    }\n\t    inc_cursor();\n\t    c = gchar_cursor();\n\t}\n\tcurwin->w_cursor = save_pos;\n\n\t/*\n\t * Prepare the leading characters in buf1[].\n\t * When there are many leading zeros it could be very long.\n\t * Allocate a bit too much.\n\t */\n\tbuf1 = alloc(length + NUMBUFLEN);\n\tif (buf1 == NULL)\n\t    goto theend;\n\tptr = buf1;\n\tif (negative && (!visual || was_positive))\n\t    *ptr++ = '-';\n\tif (pre)\n\t{\n\t    *ptr++ = '0';\n\t    --length;\n\t}\n\tif (pre == 'b' || pre == 'B' ||\n\t    pre == 'x' || pre == 'X')\n\t{\n\t    *ptr++ = pre;\n\t    --length;\n\t}\n\n\t/*\n\t * Put the number characters in buf2[].\n\t */\n\tif (pre == 'b' || pre == 'B')\n\t{\n\t    int bit = 0;\n\t    int bits = sizeof(uvarnumber_T) * 8;\n\n\t    // leading zeros\n\t    for (bit = bits; bit > 0; bit--)\n\t\tif ((n >> (bit - 1)) & 0x1) break;\n\n\t    for (i = 0; bit > 0; bit--)\n\t\tbuf2[i++] = ((n >> (bit - 1)) & 0x1) ? '1' : '0';\n\n\t    buf2[i] = '\\0';\n\t}\n\telse if (pre == 0)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llu\", (uvarnumber_T)n);\n\telse if (pre == '0')\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llo\", (uvarnumber_T)n);\n\telse if (pre && hexupper)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llX\", (uvarnumber_T)n);\n\telse\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llx\", (uvarnumber_T)n);\n\tlength -= (int)STRLEN(buf2);\n\n\t/*\n\t * Adjust number of zeros to the new number of digits, so the\n\t * total length of the number remains the same.\n\t * Don't do this when\n\t * the result may look like an octal number.\n\t */\n\tif (firstdigit == '0' && !(do_oct && pre == 0))\n\t    while (length-- > 0)\n\t\t*ptr++ = '0';\n\t*ptr = NUL;\n\n\tSTRCAT(buf1, buf2);\n\n\t// Insert just after the first character to be removed, so that any\n\t// text properties will be adjusted.  Then delete the old number\n\t// afterwards.\n\tsave_pos = curwin->w_cursor;\n\tif (todel > 0)\n\t    inc_cursor();\n\tins_str(buf1);\t\t// insert the new number\n\tvim_free(buf1);\n\n\t// del_char() will also mark line needing displaying\n\tif (todel > 0)\n\t{\n\t    int bytes_after = (int)STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t- curwin->w_cursor.col;\n\n\t    // Delete the one character before the insert.\n\t    curwin->w_cursor = save_pos;\n\t    (void)del_char(FALSE);\n\t    curwin->w_cursor.col = (colnr_T)(STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t\t- bytes_after);\n\t    --todel;\n\t}\n\twhile (todel-- > 0)\n\t    (void)del_char(FALSE);\n\n\tendpos = curwin->w_cursor;\n\tif (did_change && curwin->w_cursor.col)\n\t    --curwin->w_cursor.col;\n    }\n\n    if (did_change && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set the '[ and '] marks\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = endpos;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n\ntheend:\n    if (visual)\n\tcurwin->w_cursor = save_cursor;\n    else if (did_change)\n\tcurwin->w_set_curswant = TRUE;\n    else if (virtual_active())\n\tcurwin->w_cursor.coladd = save_coladd;\n\n    return did_change;\n}\n\n    void\nclear_oparg(oparg_T *oap)\n{\n    CLEAR_POINTER(oap);\n}\n\n/*\n *  Count the number of bytes, characters and \"words\" in a line.\n *\n *  \"Words\" are counted by looking for boundaries between non-space and\n *  space characters.  (it seems to produce results that match 'wc'.)\n *\n *  Return value is byte count; word count for the line is added to \"*wc\".\n *  Char count is added to \"*cc\".\n *\n *  The function will only examine the first \"limit\" characters in the\n *  line, stopping if it encounters an end-of-line (NUL byte).  In that\n *  case, eol_size will be added to the character count to account for\n *  the size of the EOL character.\n */\n    static varnumber_T\nline_count_info(\n    char_u\t*line,\n    varnumber_T\t*wc,\n    varnumber_T\t*cc,\n    varnumber_T\tlimit,\n    int\t\teol_size)\n{\n    varnumber_T\ti;\n    varnumber_T\twords = 0;\n    varnumber_T\tchars = 0;\n    int\t\tis_word = 0;\n\n    for (i = 0; i < limit && line[i] != NUL; )\n    {\n\tif (is_word)\n\t{\n\t    if (vim_isspace(line[i]))\n\t    {\n\t\twords++;\n\t\tis_word = 0;\n\t    }\n\t}\n\telse if (!vim_isspace(line[i]))\n\t    is_word = 1;\n\t++chars;\n\ti += (*mb_ptr2len)(line + i);\n    }\n\n    if (is_word)\n\twords++;\n    *wc += words;\n\n    // Add eol_size if the end of line was reached before hitting limit.\n    if (i < limit && line[i] == NUL)\n    {\n\ti += eol_size;\n\tchars += eol_size;\n    }\n    *cc += chars;\n    return i;\n}\n\n/*\n * Give some info about the position of the cursor (for \"g CTRL-G\").\n * In Visual mode, give some info about the selected region.  (In this case,\n * the *_count_cursor variables store running totals for the selection.)\n * When \"dict\" is not NULL store the info there instead of showing it.\n */\n    void\ncursor_pos_info(dict_T *dict)\n{\n    char_u\t*p;\n    char_u\tbuf1[50];\n    char_u\tbuf2[40];\n    linenr_T\tlnum;\n    varnumber_T\tbyte_count = 0;\n    varnumber_T\tbom_count  = 0;\n    varnumber_T\tbyte_count_cursor = 0;\n    varnumber_T\tchar_count = 0;\n    varnumber_T\tchar_count_cursor = 0;\n    varnumber_T\tword_count = 0;\n    varnumber_T\tword_count_cursor = 0;\n    int\t\teol_size;\n    varnumber_T\tlast_check = 100000L;\n    long\tline_count_selected = 0;\n    pos_T\tmin_pos, max_pos;\n    oparg_T\toparg;\n    struct block_def\tbd;\n\n    /*\n     * Compute the length of the file in characters.\n     */\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (dict == NULL)\n\t{\n\t    msg(_(no_lines_msg));\n\t    return;\n\t}\n    }\n    else\n    {\n\tif (get_fileformat(curbuf) == EOL_DOS)\n\t    eol_size = 2;\n\telse\n\t    eol_size = 1;\n\n\tif (VIsual_active)\n\t{\n\t    if (LT_POS(VIsual, curwin->w_cursor))\n\t    {\n\t\tmin_pos = VIsual;\n\t\tmax_pos = curwin->w_cursor;\n\t    }\n\t    else\n\t    {\n\t\tmin_pos = curwin->w_cursor;\n\t\tmax_pos = VIsual;\n\t    }\n\t    if (*p_sel == 'e' && max_pos.col > 0)\n\t\t--max_pos.col;\n\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tchar_u * saved_sbr = p_sbr;\n\t\tchar_u * saved_w_sbr = curwin->w_p_sbr;\n\n\t\t// Make 'sbr' empty for a moment to get the correct size.\n\t\tp_sbr = empty_option;\n\t\tcurwin->w_p_sbr = empty_option;\n#endif\n\t\toparg.is_VIsual = 1;\n\t\toparg.block_mode = TRUE;\n\t\toparg.op_type = OP_NOP;\n\t\tgetvcols(curwin, &min_pos, &max_pos,\n\t\t\t\t\t  &oparg.start_vcol, &oparg.end_vcol);\n#ifdef FEAT_LINEBREAK\n\t\tp_sbr = saved_sbr;\n\t\tcurwin->w_p_sbr = saved_w_sbr;\n#endif\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    oparg.end_vcol = MAXCOL;\n\t\t// Swap the start, end vcol if needed\n\t\tif (oparg.end_vcol < oparg.start_vcol)\n\t\t{\n\t\t    oparg.end_vcol += oparg.start_vcol;\n\t\t    oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;\n\t\t    oparg.end_vcol -= oparg.start_vcol;\n\t\t}\n\t    }\n\t    line_count_selected = max_pos.lnum - min_pos.lnum + 1;\n\t}\n\n\tfor (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t{\n\t    // Check for a CTRL-C every 100000 characters.\n\t    if (byte_count > last_check)\n\t    {\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t    return;\n\t\tlast_check = byte_count + 100000L;\n\t    }\n\n\t    // Do extra processing for VIsual mode.\n\t    if (VIsual_active\n\t\t    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)\n\t    {\n\t\tchar_u\t    *s = NULL;\n\t\tlong\t    len = 0L;\n\n\t\tswitch (VIsual_mode)\n\t\t{\n\t\t    case Ctrl_V:\n\t\t\tvirtual_op = virtual_active();\n\t\t\tblock_prep(&oparg, &bd, lnum, 0);\n\t\t\tvirtual_op = MAYBE;\n\t\t\ts = bd.textstart;\n\t\t\tlen = (long)bd.textlen;\n\t\t\tbreak;\n\t\t    case 'V':\n\t\t\ts = ml_get(lnum);\n\t\t\tlen = MAXCOL;\n\t\t\tbreak;\n\t\t    case 'v':\n\t\t\t{\n\t\t\t    colnr_T start_col = (lnum == min_pos.lnum)\n\t\t\t\t\t\t\t   ? min_pos.col : 0;\n\t\t\t    colnr_T end_col = (lnum == max_pos.lnum)\n\t\t\t\t      ? max_pos.col - start_col + 1 : MAXCOL;\n\n\t\t\t    s = ml_get(lnum) + start_col;\n\t\t\t    len = end_col;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (s != NULL)\n\t\t{\n\t\t    byte_count_cursor += line_count_info(s, &word_count_cursor,\n\t\t\t\t\t   &char_count_cursor, len, eol_size);\n\t\t    if (lnum == curbuf->b_ml.ml_line_count\n\t\t\t    && !curbuf->b_p_eol\n\t\t\t    && (curbuf->b_p_bin || !curbuf->b_p_fixeol)\n\t\t\t    && (long)STRLEN(s) < len)\n\t\t\tbyte_count_cursor -= eol_size;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// In non-visual mode, check for the line the cursor is on\n\t\tif (lnum == curwin->w_cursor.lnum)\n\t\t{\n\t\t    word_count_cursor += word_count;\n\t\t    char_count_cursor += char_count;\n\t\t    byte_count_cursor = byte_count +\n\t\t\tline_count_info(ml_get(lnum),\n\t\t\t\t&word_count_cursor, &char_count_cursor,\n\t\t\t\t(varnumber_T)(curwin->w_cursor.col + 1),\n\t\t\t\teol_size);\n\t\t}\n\t    }\n\t    // Add to the running totals\n\t    byte_count += line_count_info(ml_get(lnum), &word_count,\n\t\t\t\t\t &char_count, (varnumber_T)MAXCOL,\n\t\t\t\t\t eol_size);\n\t}\n\n\t// Correction for when last line doesn't have an EOL.\n\tif (!curbuf->b_p_eol && (curbuf->b_p_bin || !curbuf->b_p_fixeol))\n\t    byte_count -= eol_size;\n\n\tif (dict == NULL)\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)\n\t\t{\n\t\t    getvcols(curwin, &min_pos, &max_pos, &min_pos.col,\n\t\t\t\t\t\t\t\t    &max_pos.col);\n\t\t    vim_snprintf((char *)buf1, sizeof(buf1), _(\"%ld Cols; \"),\n\t\t\t    (long)(oparg.end_vcol - oparg.start_vcol + 1));\n\t\t}\n\t\telse\n\t\t    buf1[0] = NUL;\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t\t\t\t    && char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    (varnumber_T)word_count_cursor,\n\t\t\t    (varnumber_T)word_count,\n\t\t\t    (varnumber_T)byte_count_cursor,\n\t\t\t    (varnumber_T)byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Chars; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    (varnumber_T)word_count_cursor,\n\t\t\t    (varnumber_T)word_count,\n\t\t\t    (varnumber_T)char_count_cursor,\n\t\t\t    (varnumber_T)char_count,\n\t\t\t    (varnumber_T)byte_count_cursor,\n\t\t\t    (varnumber_T)byte_count);\n\t    }\n\t    else\n\t    {\n\t\tp = ml_get_curline();\n\t\tvalidate_virtcol();\n\t\tcol_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,\n\t\t\t(int)curwin->w_virtcol + 1);\n\t\tcol_print(buf2, sizeof(buf2), (int)STRLEN(p),\n\t\t\t\t    linetabsize(p));\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t&& char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\t(varnumber_T)word_count_cursor, (varnumber_T)word_count,\n\t\t\t(varnumber_T)byte_count_cursor, (varnumber_T)byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Char %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\t(varnumber_T)word_count_cursor, (varnumber_T)word_count,\n\t\t\t(varnumber_T)char_count_cursor, (varnumber_T)char_count,\n\t\t\t(varnumber_T)byte_count_cursor, (varnumber_T)byte_count);\n\t    }\n\t}\n\n\tbom_count = bomb_size();\n\tif (dict == NULL && bom_count > 0)\n\t{\n\t    size_t len = STRLEN(IObuff);\n\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t\t _(\"(+%lld for BOM)\"), (varnumber_T)bom_count);\n\t}\n\tif (dict == NULL)\n\t{\n\t    // Don't shorten this message, the user asked for it.\n\t    p = p_shm;\n\t    p_shm = (char_u *)\"\";\n\t    msg((char *)IObuff);\n\t    p_shm = p;\n\t}\n    }\n#if defined(FEAT_EVAL)\n    if (dict != NULL)\n    {\n\tdict_add_number(dict, \"words\", word_count);\n\tdict_add_number(dict, \"chars\", char_count);\n\tdict_add_number(dict, \"bytes\", byte_count + bom_count);\n\tdict_add_number(dict, VIsual_active ? \"visual_bytes\" : \"cursor_bytes\",\n\t\tbyte_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_chars\" : \"cursor_chars\",\n\t\tchar_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_words\" : \"cursor_words\",\n\t\tword_count_cursor);\n    }\n#endif\n}\n\n/*\n * Handle indent and format operators and visual mode \":\".\n */\n    static void\nop_colon(oparg_T *oap)\n{\n    stuffcharReadbuff(':');\n    if (oap->is_VIsual)\n\tstuffReadbuff((char_u *)\"'<,'>\");\n    else\n    {\n\t// Make the range look nice, so it can be repeated.\n\tif (oap->start.lnum == curwin->w_cursor.lnum)\n\t    stuffcharReadbuff('.');\n\telse\n\t    stuffnumReadbuff((long)oap->start.lnum);\n\tif (oap->end.lnum != oap->start.lnum)\n\t{\n\t    stuffcharReadbuff(',');\n\t    if (oap->end.lnum == curwin->w_cursor.lnum)\n\t\tstuffcharReadbuff('.');\n\t    else if (oap->end.lnum == curbuf->b_ml.ml_line_count)\n\t\tstuffcharReadbuff('$');\n\t    else if (oap->start.lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tstuffReadbuff((char_u *)\".+\");\n\t\tstuffnumReadbuff((long)oap->line_count - 1);\n\t    }\n\t    else\n\t\tstuffnumReadbuff((long)oap->end.lnum);\n\t}\n    }\n    if (oap->op_type != OP_COLON)\n\tstuffReadbuff((char_u *)\"!\");\n    if (oap->op_type == OP_INDENT)\n    {\n#ifndef FEAT_CINDENT\n\tif (*get_equalprg() == NUL)\n\t    stuffReadbuff((char_u *)\"indent\");\n\telse\n#endif\n\t    stuffReadbuff(get_equalprg());\n\tstuffReadbuff((char_u *)\"\\n\");\n    }\n    else if (oap->op_type == OP_FORMAT)\n    {\n\tif (*curbuf->b_p_fp != NUL)\n\t    stuffReadbuff(curbuf->b_p_fp);\n\telse if (*p_fp != NUL)\n\t    stuffReadbuff(p_fp);\n\telse\n\t    stuffReadbuff((char_u *)\"fmt\");\n\tstuffReadbuff((char_u *)\"\\n']\");\n    }\n\n    // do_cmdline() does the rest\n}\n\n// callback function for 'operatorfunc'\nstatic callback_T opfunc_cb;\n\n/*\n * Process the 'operatorfunc' option value.\n * Returns OK or FAIL.\n */\n    int\nset_operatorfunc_option(void)\n{\n    return option_set_callback_func(p_opfunc, &opfunc_cb);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_operatorfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&opfunc_cb);\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'operatorfunc' callback with 'copyID' so that it is not\n * garbage collected.\n */\n    int\nset_ref_in_opfunc(int copyID UNUSED)\n{\n    int abort = FALSE;\n\n    abort = set_ref_in_callback(&opfunc_cb, copyID);\n\n    return abort;\n}\n#endif\n\n/*\n * Handle the \"g@\" operator: call 'operatorfunc'.\n */\n    static void\nop_function(oparg_T *oap UNUSED)\n{\n#ifdef FEAT_EVAL\n    typval_T\targv[2];\n    int\t\tsave_virtual_op = virtual_op;\n    int\t\tsave_finish_op = finish_op;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    typval_T\trettv;\n\n    if (*p_opfunc == NUL)\n\temsg(_(e_operatorfunc_is_empty));\n    else\n    {\n\t// Set '[ and '] marks to text to be operated on.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (oap->motion_type != MLINE && !oap->inclusive)\n\t    // Exclude the end position.\n\t    decl(&curbuf->b_op_end);\n\n\targv[0].v_type = VAR_STRING;\n\tif (oap->block_mode)\n\t    argv[0].vval.v_string = (char_u *)\"block\";\n\telse if (oap->motion_type == MLINE)\n\t    argv[0].vval.v_string = (char_u *)\"line\";\n\telse\n\t    argv[0].vval.v_string = (char_u *)\"char\";\n\targv[1].v_type = VAR_UNKNOWN;\n\n\t// Reset virtual_op so that 'virtualedit' can be changed in the\n\t// function.\n\tvirtual_op = MAYBE;\n\n\t// Reset finish_op so that mode() returns the right value.\n\tfinish_op = FALSE;\n\n\tif (call_callback(&opfunc_cb, 0, &rettv, 1, argv) != FAIL)\n\t    clear_tv(&rettv);\n\n\tvirtual_op = save_virtual_op;\n\tfinish_op = save_finish_op;\n\tif (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n\t{\n\t    curbuf->b_op_start = orig_start;\n\t    curbuf->b_op_end = orig_end;\n\t}\n    }\n#else\n    emsg(_(e_eval_feature_not_available));\n#endif\n}\n\n/*\n * Calculate start/end virtual columns for operating in block mode.\n */\n    static void\nget_op_vcol(\n    oparg_T\t*oap,\n    colnr_T\tredo_VIsual_vcol,\n    int\t\tinitial)    // when TRUE adjust position for 'selectmode'\n{\n    colnr_T\t    start, end;\n\n    if (VIsual_mode != Ctrl_V\n\t    || (!initial && oap->end.col < curwin->w_width))\n\treturn;\n\n    oap->block_mode = TRUE;\n\n    // prevent from moving onto a trail byte\n    if (has_mbyte)\n\tmb_adjustpos(curwin->w_buffer, &oap->end);\n\n    getvvcol(curwin, &(oap->start), &oap->start_vcol, NULL, &oap->end_vcol);\n\n    if (!redo_VIsual_busy)\n    {\n\tgetvvcol(curwin, &(oap->end), &start, NULL, &end);\n\n\tif (start < oap->start_vcol)\n\t    oap->start_vcol = start;\n\tif (end > oap->end_vcol)\n\t{\n\t    if (initial && *p_sel == 'e' && start >= 1\n\t\t\t\t    && start - 1 >= oap->end_vcol)\n\t\toap->end_vcol = start - 1;\n\t    else\n\t\toap->end_vcol = end;\n\t}\n    }\n\n    // if '$' was used, get oap->end_vcol from longest line\n    if (curwin->w_curswant == MAXCOL)\n    {\n\tcurwin->w_cursor.col = MAXCOL;\n\toap->end_vcol = 0;\n\tfor (curwin->w_cursor.lnum = oap->start.lnum;\n\t\tcurwin->w_cursor.lnum <= oap->end.lnum;\n\t\t\t\t\t++curwin->w_cursor.lnum)\n\t{\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);\n\t    if (end > oap->end_vcol)\n\t\toap->end_vcol = end;\n\t}\n    }\n    else if (redo_VIsual_busy)\n\toap->end_vcol = oap->start_vcol + redo_VIsual_vcol - 1;\n    // Correct oap->end.col and oap->start.col to be the\n    // upper-left and lower-right corner of the block area.\n    //\n    // (Actually, this does convert column positions into character\n    // positions)\n    curwin->w_cursor.lnum = oap->end.lnum;\n    coladvance(oap->end_vcol);\n    oap->end = curwin->w_cursor;\n\n    curwin->w_cursor = oap->start;\n    coladvance(oap->start_vcol);\n    oap->start = curwin->w_cursor;\n}\n\n// Information for redoing the previous Visual selection.\ntypedef struct {\n    int\t\trv_mode;\t// 'v', 'V', or Ctrl-V\n    linenr_T\trv_line_count;\t// number of lines\n    colnr_T\trv_vcol;\t// number of cols or end column\n    long\trv_count;\t// count for Visual operator\n    int\t\trv_arg;\t\t// extra argument\n} redo_VIsual_T;\n\n    static int\nis_ex_cmdchar(cmdarg_T *cap)\n{\n    return cap->cmdchar == ':'\n\t|| cap->cmdchar == K_COMMAND\n\t|| cap->cmdchar == K_SCRIPT_COMMAND;\n}\n\n/*\n * Handle an operator after Visual mode or when the movement is finished.\n * \"gui_yank\" is true when yanking text for the clipboard.\n */\n    void\ndo_pending_operator(cmdarg_T *cap, int old_col, int gui_yank)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\told_cursor;\n    int\t\tempty_region_error;\n    int\t\trestart_edit_save;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n#endif\n\n    // The visual area is remembered for redo\n    static redo_VIsual_T   redo_VIsual = {NUL, 0, 0, 0,0};\n\n    int\t\t    include_line_break = FALSE;\n\n#if defined(FEAT_CLIPBOARD)\n    // Yank the visual area into the GUI selection register before we operate\n    // on it and lose it forever.\n    // Don't do it if a specific register was specified, so that \"\"x\"*P works.\n    // This could call do_pending_operator() recursively, but that's OK\n    // because gui_yank will be TRUE for the nested call.\n    if ((clip_star.available || clip_plus.available)\n\t    && oap->op_type != OP_NOP\n\t    && !gui_yank\n\t    && VIsual_active\n\t    && !redo_VIsual_busy\n\t    && oap->regname == 0)\n\tclip_auto_select();\n#endif\n    old_cursor = curwin->w_cursor;\n\n    // If an operation is pending, handle it...\n    if ((finish_op || VIsual_active) && oap->op_type != OP_NOP)\n    {\n\t// Yank can be redone when 'y' is in 'cpoptions', but not when yanking\n\t// for the clipboard.\n\tint\tredo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL && !gui_yank;\n\n#ifdef FEAT_LINEBREAK\n\t// Avoid a problem with unwanted linebreaks in block mode.\n\tif (curwin->w_p_lbr)\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\tcurwin->w_p_lbr = FALSE;\n#endif\n\toap->is_VIsual = VIsual_active;\n\tif (oap->motion_force == 'V')\n\t    oap->motion_type = MLINE;\n\telse if (oap->motion_force == 'v')\n\t{\n\t    // If the motion was linewise, \"inclusive\" will not have been set.\n\t    // Use \"exclusive\" to be consistent.  Makes \"dvj\" work nice.\n\t    if (oap->motion_type == MLINE)\n\t\toap->inclusive = FALSE;\n\t    // If the motion already was characterwise, toggle \"inclusive\"\n\t    else if (oap->motion_type == MCHAR)\n\t\toap->inclusive = !oap->inclusive;\n\t    oap->motion_type = MCHAR;\n\t}\n\telse if (oap->motion_force == Ctrl_V)\n\t{\n\t    // Change line- or characterwise motion into Visual block mode.\n\t    if (!VIsual_active)\n\t    {\n\t\tVIsual_active = TRUE;\n\t\tVIsual = oap->start;\n\t    }\n\t    VIsual_mode = Ctrl_V;\n\t    VIsual_select = FALSE;\n\t    VIsual_reselect = FALSE;\n\t}\n\n\t// Only redo yank when 'y' flag is in 'cpoptions'.\n\t// Never redo \"zf\" (define fold).\n\tif ((redo_yank || oap->op_type != OP_YANK)\n\t\t&& ((!VIsual_active || oap->motion_force)\n\t\t    // Also redo Operator-pending Visual mode mappings\n\t\t    || (VIsual_active\n\t\t\t    && is_ex_cmdchar(cap) && oap->op_type != OP_COLON))\n\t\t&& cap->cmdchar != 'D'\n#ifdef FEAT_FOLDING\n\t\t&& oap->op_type != OP_FOLD\n\t\t&& oap->op_type != OP_FOLDOPEN\n\t\t&& oap->op_type != OP_FOLDOPENREC\n\t\t&& oap->op_type != OP_FOLDCLOSE\n\t\t&& oap->op_type != OP_FOLDCLOSEREC\n\t\t&& oap->op_type != OP_FOLDDEL\n\t\t&& oap->op_type != OP_FOLDDELREC\n#endif\n\t\t)\n\t{\n\t    prep_redo(oap->regname, cap->count0,\n\t\t    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),\n\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t    if (cap->cmdchar == '/' || cap->cmdchar == '?') // was a search\n\t    {\n\t\t// If 'cpoptions' does not contain 'r', insert the search\n\t\t// pattern to really repeat the same command.\n\t\tif (vim_strchr(p_cpo, CPO_REDO) == NULL)\n\t\t    AppendToRedobuffLit(cap->searchbuf, -1);\n\t\tAppendToRedobuff(NL_STR);\n\t    }\n\t    else if (is_ex_cmdchar(cap))\n\t    {\n\t\t// do_cmdline() has stored the first typed line in\n\t\t// \"repeat_cmdline\".  When several lines are typed repeating\n\t\t// won't be possible.\n\t\tif (repeat_cmdline == NULL)\n\t\t    ResetRedobuff();\n\t\telse\n\t\t{\n\t\t    AppendToRedobuffLit(repeat_cmdline, -1);\n\t\t    AppendToRedobuff(NL_STR);\n\t\t    VIM_CLEAR(repeat_cmdline);\n\t\t}\n\t    }\n\t}\n\n\tif (redo_VIsual_busy)\n\t{\n\t    // Redo of an operation on a Visual area. Use the same size from\n\t    // redo_VIsual.rv_line_count and redo_VIsual.rv_vcol.\n\t    oap->start = curwin->w_cursor;\n\t    curwin->w_cursor.lnum += redo_VIsual.rv_line_count - 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    VIsual_mode = redo_VIsual.rv_mode;\n\t    if (redo_VIsual.rv_vcol == MAXCOL || VIsual_mode == 'v')\n\t    {\n\t\tif (VIsual_mode == 'v')\n\t\t{\n\t\t    if (redo_VIsual.rv_line_count <= 1)\n\t\t    {\n\t\t\tvalidate_virtcol();\n\t\t\tcurwin->w_curswant =\n\t\t\t\t     curwin->w_virtcol + redo_VIsual.rv_vcol - 1;\n\t\t    }\n\t\t    else\n\t\t\tcurwin->w_curswant = redo_VIsual.rv_vcol;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_curswant = MAXCOL;\n\t\t}\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    cap->count0 = redo_VIsual.rv_count;\n\t    if (redo_VIsual.rv_count != 0)\n\t\tcap->count1 = redo_VIsual.rv_count;\n\t    else\n\t\tcap->count1 = 1;\n\t}\n\telse if (VIsual_active)\n\t{\n\t    if (!gui_yank)\n\t    {\n\t\t// Save the current VIsual area for '< and '> marks, and \"gv\"\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurbuf->b_visual.vi_mode = VIsual_mode;\n\t\trestore_visual_mode();\n\t\tcurbuf->b_visual.vi_curswant = curwin->w_curswant;\n# ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = VIsual_mode;\n# endif\n\t    }\n\n\t    // In Select mode, a linewise selection is operated upon like a\n\t    // characterwise selection.\n\t    // Special case: gH<Del> deletes the last line.\n\t    if (VIsual_select && VIsual_mode == 'V'\n\t\t\t\t\t    && cap->oap->op_type != OP_DELETE)\n\t    {\n\t\tif (LT_POS(VIsual, curwin->w_cursor))\n\t\t{\n\t\t    VIsual.col = 0;\n\t\t    curwin->w_cursor.col =\n\t\t\t       (colnr_T)STRLEN(ml_get(curwin->w_cursor.lnum));\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.col = 0;\n\t\t    VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));\n\t\t}\n\t\tVIsual_mode = 'v';\n\t    }\n\t    // If 'selection' is \"exclusive\", backup one character for\n\t    // charwise selections.\n\t    else if (VIsual_mode == 'v')\n\t\tinclude_line_break = unadjust_for_sel();\n\n\t    oap->start = VIsual;\n\t    if (VIsual_mode == 'V')\n\t    {\n\t\toap->start.col = 0;\n\t\toap->start.coladd = 0;\n\t    }\n\t}\n\n\t// Set oap->start to the first position of the operated text, oap->end\n\t// to the end of the operated text.  w_cursor is equal to oap->start.\n\tif (LT_POS(oap->start, curwin->w_cursor))\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active)\n\t    {\n\t\tif (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))\n\t\t    oap->start.col = 0;\n\t\tif ((curwin->w_cursor.col > 0 || oap->inclusive\n\t\t\t\t\t\t  || oap->motion_type == MLINE)\n\t\t\t&& hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum))\n\t\t    curwin->w_cursor.col = (colnr_T)STRLEN(ml_get_curline());\n\t    }\n#endif\n\t    oap->end = curwin->w_cursor;\n\t    curwin->w_cursor = oap->start;\n\n\t    // w_virtcol may have been updated; if the cursor goes back to its\n\t    // previous position w_virtcol becomes invalid and isn't updated\n\t    // automatically.\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active && oap->motion_type == MLINE)\n\t    {\n\t\tif (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tNULL))\n\t\t    curwin->w_cursor.col = 0;\n\t\tif (hasFolding(oap->start.lnum, NULL, &oap->start.lnum))\n\t\t    oap->start.col = (colnr_T)STRLEN(ml_get(oap->start.lnum));\n\t    }\n#endif\n\t    oap->end = oap->start;\n\t    oap->start = curwin->w_cursor;\n\t}\n\n\t// Just in case lines were deleted that make the position invalid.\n\tcheck_pos(curwin->w_buffer, &oap->end);\n\toap->line_count = oap->end.lnum - oap->start.lnum + 1;\n\n\t// Set \"virtual_op\" before resetting VIsual_active.\n\tvirtual_op = virtual_active();\n\n\tif (VIsual_active || redo_VIsual_busy)\n\t{\n\t    get_op_vcol(oap, redo_VIsual.rv_vcol, TRUE);\n\n\t    if (!redo_VIsual_busy && !gui_yank)\n\t    {\n\t\t// Prepare to reselect and redo Visual: this is based on the\n\t\t// size of the Visual text\n\t\tresel_VIsual_mode = VIsual_mode;\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    resel_VIsual_vcol = MAXCOL;\n\t\telse\n\t\t{\n\t\t    if (VIsual_mode != Ctrl_V)\n\t\t\tgetvvcol(curwin, &(oap->end),\n\t\t\t\t\t\t  NULL, NULL, &oap->end_vcol);\n\t\t    if (VIsual_mode == Ctrl_V || oap->line_count <= 1)\n\t\t    {\n\t\t\tif (VIsual_mode != Ctrl_V)\n\t\t\t    getvvcol(curwin, &(oap->start),\n\t\t\t\t\t\t&oap->start_vcol, NULL, NULL);\n\t\t\tresel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;\n\t\t    }\n\t\t    else\n\t\t\tresel_VIsual_vcol = oap->end_vcol;\n\t\t}\n\t\tresel_VIsual_line_count = oap->line_count;\n\t    }\n\n\t    // can't redo yank (unless 'y' is in 'cpoptions') and \":\"\n\t    if ((redo_yank || oap->op_type != OP_YANK)\n\t\t    && oap->op_type != OP_COLON\n#ifdef FEAT_FOLDING\n\t\t    && oap->op_type != OP_FOLD\n\t\t    && oap->op_type != OP_FOLDOPEN\n\t\t    && oap->op_type != OP_FOLDOPENREC\n\t\t    && oap->op_type != OP_FOLDCLOSE\n\t\t    && oap->op_type != OP_FOLDCLOSEREC\n\t\t    && oap->op_type != OP_FOLDDEL\n\t\t    && oap->op_type != OP_FOLDDELREC\n#endif\n\t\t    && oap->motion_force == NUL\n\t\t    )\n\t    {\n\t\t// Prepare for redoing.  Only use the nchar field for \"r\",\n\t\t// otherwise it might be the second char of the operator.\n\t\tif (cap->cmdchar == 'g' && (cap->nchar == 'n'\n\t\t\t\t\t\t\t|| cap->nchar == 'N'))\n\t\t    prep_redo(oap->regname, cap->count0,\n\t\t\t    get_op_char(oap->op_type),\n\t\t\t    get_extra_op_char(oap->op_type),\n\t\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t\telse if (!is_ex_cmdchar(cap))\n\t\t{\n\t\t    int opchar = get_op_char(oap->op_type);\n\t\t    int extra_opchar = get_extra_op_char(oap->op_type);\n\t\t    int nchar = oap->op_type == OP_REPLACE ? cap->nchar : NUL;\n\n\t\t    // reverse what nv_replace() did\n\t\t    if (nchar == REPLACE_CR_NCHAR)\n\t\t\tnchar = CAR;\n\t\t    else if (nchar == REPLACE_NL_NCHAR)\n\t\t\tnchar = NL;\n\n\t\t    if (opchar == 'g' && extra_opchar == '@')\n\t\t\t// also repeat the count for 'operatorfunc'\n\t\t\tprep_redo_num2(oap->regname, 0L, NUL, 'v',\n\t\t\t\t     cap->count0, opchar, extra_opchar, nchar);\n\t\t    else\n\t\t\tprep_redo(oap->regname, 0L, NUL, 'v',\n\t\t\t\t\t\t  opchar, extra_opchar, nchar);\n\t\t}\n\t\tif (!redo_VIsual_busy)\n\t\t{\n\t\t    redo_VIsual.rv_mode = resel_VIsual_mode;\n\t\t    redo_VIsual.rv_vcol = resel_VIsual_vcol;\n\t\t    redo_VIsual.rv_line_count = resel_VIsual_line_count;\n\t\t    redo_VIsual.rv_count = cap->count0;\n\t\t    redo_VIsual.rv_arg = cap->arg;\n\t\t}\n\t    }\n\n\t    // oap->inclusive defaults to TRUE.\n\t    // If oap->end is on a NUL (empty line) oap->inclusive becomes\n\t    // FALSE.  This makes \"d}P\" and \"v}dP\" work the same.\n\t    if (oap->motion_force == NUL || oap->motion_type == MLINE)\n\t\toap->inclusive = TRUE;\n\t    if (VIsual_mode == 'V')\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->motion_type = MCHAR;\n\t\tif (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL\n\t\t\t&& (include_line_break || !virtual_op))\n\t\t{\n\t\t    oap->inclusive = FALSE;\n\t\t    // Try to include the newline, unless it's an operator\n\t\t    // that works on lines only.\n\t\t    if (*p_sel != 'o'\n\t\t\t    && !op_on_lines(oap->op_type)\n\t\t\t    && oap->end.lnum < curbuf->b_ml.ml_line_count)\n\t\t    {\n\t\t\t++oap->end.lnum;\n\t\t\toap->end.col = 0;\n\t\t\toap->end.coladd = 0;\n\t\t\t++oap->line_count;\n\t\t    }\n\t\t}\n\t    }\n\n\t    redo_VIsual_busy = FALSE;\n\n\t    // Switch Visual off now, so screen updating does\n\t    // not show inverted text when the screen is redrawn.\n\t    // With OP_YANK and sometimes with OP_COLON and OP_FILTER there is\n\t    // no screen redraw, so it is done here to remove the inverted\n\t    // part.\n\t    if (!gui_yank)\n\t    {\n\t\tVIsual_active = FALSE;\n\t\tsetmouse();\n\t\tmouse_dragging = 0;\n\t\tmay_clear_cmdline();\n\t\tif ((oap->op_type == OP_YANK\n\t\t\t    || oap->op_type == OP_COLON\n\t\t\t    || oap->op_type == OP_FUNCTION\n\t\t\t    || oap->op_type == OP_FILTER)\n\t\t\t&& oap->motion_force == NUL)\n\t\t{\n#ifdef FEAT_LINEBREAK\n\t\t    // make sure redrawing is correct\n\t\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t\t    redraw_curbuf_later(INVERTED);\n\t\t}\n\t    }\n\t}\n\n\t// Include the trailing byte of a multi-byte char.\n\tif (has_mbyte && oap->inclusive)\n\t{\n\t    int\t\tl;\n\n\t    l = (*mb_ptr2len)(ml_get_pos(&oap->end));\n\t    if (l > 1)\n\t\toap->end.col += l - 1;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\n\t// oap->empty is set when start and end are the same.  The inclusive\n\t// flag affects this too, unless yanking and the end is on a NUL.\n\toap->empty = (oap->motion_type == MCHAR\n\t\t    && (!oap->inclusive\n\t\t\t|| (oap->op_type == OP_YANK\n\t\t\t    && gchar_pos(&oap->end) == NUL))\n\t\t    && EQUAL_POS(oap->start, oap->end)\n\t\t    && !(virtual_op && oap->start.coladd != oap->end.coladd));\n\t// For delete, change and yank, it's an error to operate on an\n\t// empty region, when 'E' included in 'cpoptions' (Vi compatible).\n\tempty_region_error = (oap->empty\n\t\t\t\t&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);\n\n\t// Force a redraw when operating on an empty Visual region, when\n\t// 'modifiable is off or creating a fold.\n\tif (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma\n#ifdef FEAT_FOLDING\n\t\t    || oap->op_type == OP_FOLD\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_LINEBREAK\n\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// If the end of an operator is in column one while oap->motion_type\n\t// is MCHAR and oap->inclusive is FALSE, we put op_end after the last\n\t// character in the previous line. If op_start is on or before the\n\t// first non-blank in the line, the operator becomes linewise\n\t// (strange, but that's the way vi does it).\n\tif (\t   oap->motion_type == MCHAR\n\t\t&& oap->inclusive == FALSE\n\t\t&& !(cap->retval & CA_NO_ADJ_OP_END)\n\t\t&& oap->end.col == 0\n\t\t&& (!oap->is_VIsual || *p_sel == 'o')\n\t\t&& !oap->block_mode\n\t\t&& oap->line_count > 1)\n\t{\n\t    oap->end_adjusted = TRUE;\t    // remember that we did this\n\t    --oap->line_count;\n\t    --oap->end.lnum;\n\t    if (inindent(0))\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t\tif (oap->end.col)\n\t\t{\n\t\t    --oap->end.col;\n\t\t    oap->inclusive = TRUE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    oap->end_adjusted = FALSE;\n\n\tswitch (oap->op_type)\n\t{\n\tcase OP_LSHIFT:\n\tcase OP_RSHIFT:\n\t    op_shift(oap, TRUE, oap->is_VIsual ? (int)cap->count1 : 1);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase OP_JOIN_NS:\n\tcase OP_JOIN:\n\t    if (oap->line_count < 2)\n\t\toap->line_count = 2;\n\t    if (curwin->w_cursor.lnum + oap->line_count - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t\tbeep_flush();\n\t    else\n\t    {\n\t\t(void)do_join(oap->line_count, oap->op_type == OP_JOIN,\n\t\t\t\t\t\t\t    TRUE, TRUE, TRUE);\n\t\tauto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_DELETE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t(void)op_delete(oap);\n\t\t// save cursor line for undo if it wasn't saved yet\n\t\tif (oap->motion_type == MLINE && has_format_option(FO_AUTO)\n\t\t\t\t\t\t      && u_save_cursor() == OK)\n\t\t    auto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_YANK:\n\t    if (empty_region_error)\n\t    {\n\t\tif (!gui_yank)\n\t\t{\n\t\t    vim_beep(BO_OPER);\n\t\t    CancelRedo();\n\t\t}\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\toap->excl_tr_ws = cap->cmdchar == 'z';\n\t\t(void)op_yank(oap, FALSE, !gui_yank);\n\t    }\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_CHANGE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once and not when typed and\n\t\t// 'insertmode' isn't set.\n\t\tif (p_im || !KeyTyped)\n\t\t    restart_edit_save = restart_edit;\n\t\telse\n\t\t    restart_edit_save = 0;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// Reset finish_op now, don't want it set inside edit().\n\t\tfinish_op = FALSE;\n\t\tif (op_change(oap))\t// will call edit()\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t    }\n\t    break;\n\n\tcase OP_FILTER:\n\t    if (vim_strchr(p_cpo, CPO_FILTER) != NULL)\n\t\tAppendToRedobuff((char_u *)\"!\\r\");  // use any last used !cmd\n\t    else\n\t\tbangredo = TRUE;    // do_bang() will put cmd in redo buffer\n\t    // FALLTHROUGH\n\n\tcase OP_INDENT:\n\tcase OP_COLON:\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\t    // If 'equalprg' is empty, do the indenting internally.\n\t    if (oap->op_type == OP_INDENT && *get_equalprg() == NUL)\n\t    {\n# ifdef FEAT_LISP\n\t\tif (curbuf->b_p_lisp)\n\t\t{\n\t\t    op_reindent(oap, get_lisp_indent);\n\t\t    break;\n\t\t}\n# endif\n# ifdef FEAT_CINDENT\n\t\top_reindent(oap,\n#  ifdef FEAT_EVAL\n\t\t\t*curbuf->b_p_inde != NUL ? get_expr_indent :\n#  endif\n\t\t\t    get_c_indent);\n\t\tbreak;\n# endif\n\t    }\n#endif\n\n\t    op_colon(oap);\n\t    break;\n\n\tcase OP_TILDE:\n\tcase OP_UPPER:\n\tcase OP_LOWER:\n\tcase OP_ROT13:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t\top_tilde(oap);\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_FORMAT:\n#if defined(FEAT_EVAL)\n\t    if (*curbuf->b_p_fex != NUL)\n\t\top_formatexpr(oap);\t// use expression\n\t    else\n#endif\n\t    {\n\t\tif (*p_fp != NUL || *curbuf->b_p_fp != NUL)\n\t\t    op_colon(oap);\t\t// use external command\n\t\telse\n\t\t    op_format(oap, FALSE);\t// use internal function\n\t    }\n\t    break;\n\tcase OP_FORMAT2:\n\t    op_format(oap, TRUE);\t// use internal function\n\t    break;\n\n\tcase OP_FUNCTION:\n\t    {\n\t\tredo_VIsual_T   save_redo_VIsual = redo_VIsual;\n\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// call 'operatorfunc'\n\t\top_function(oap);\n\n\t\t// Restore the info for redoing Visual mode, the function may\n\t\t// invoke another operator and unintentionally change it.\n\t\tredo_VIsual = save_redo_VIsual;\n\t\tbreak;\n\t    }\n\n\tcase OP_INSERT:\n\tcase OP_APPEND:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once.\n\t\trestart_edit_save = restart_edit;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_insert(oap, cap->count1);\n#ifdef FEAT_LINEBREAK\n\t\t// Reset linebreak, so that formatting works correctly.\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\n\t\t// TODO: when inserting in several lines, should format all\n\t\t// the lines.\n\t\tauto_format(FALSE, TRUE);\n\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t\telse\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t    }\n\t    break;\n\n\tcase OP_REPLACE:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_replace(oap, cap->nchar);\n\t    }\n\t    break;\n\n#ifdef FEAT_FOLDING\n\tcase OP_FOLD:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    foldCreate(oap->start.lnum, oap->end.lnum);\n\t    break;\n\n\tcase OP_FOLDOPEN:\n\tcase OP_FOLDOPENREC:\n\tcase OP_FOLDCLOSE:\n\tcase OP_FOLDCLOSEREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    opFoldRange(oap->start.lnum, oap->end.lnum,\n\t\t    oap->op_type == OP_FOLDOPEN\n\t\t\t\t\t    || oap->op_type == OP_FOLDOPENREC,\n\t\t    oap->op_type == OP_FOLDOPENREC\n\t\t\t\t\t  || oap->op_type == OP_FOLDCLOSEREC,\n\t\t\t\t\t  oap->is_VIsual);\n\t    break;\n\n\tcase OP_FOLDDEL:\n\tcase OP_FOLDDELREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    deleteFold(oap->start.lnum, oap->end.lnum,\n\t\t\t       oap->op_type == OP_FOLDDELREC, oap->is_VIsual);\n\t    break;\n#endif\n\tcase OP_NR_ADD:\n\tcase OP_NR_SUB:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\tVIsual_active = TRUE;\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_addsub(oap, cap->count1, redo_VIsual.rv_arg);\n\t\tVIsual_active = FALSE;\n\t    }\n\t    check_cursor_col();\n\t    break;\n\tdefault:\n\t    clearopbeep(oap);\n\t}\n\tvirtual_op = MAYBE;\n\tif (!gui_yank)\n\t{\n\t    // if 'sol' not set, go back to old column for some commands\n\t    if (!p_sol && oap->motion_type == MLINE && !oap->end_adjusted\n\t\t    && (oap->op_type == OP_LSHIFT || oap->op_type == OP_RSHIFT\n\t\t\t\t\t\t|| oap->op_type == OP_DELETE))\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\t\tcoladvance(curwin->w_curswant = old_col);\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = old_cursor;\n\t}\n\toap->block_mode = FALSE;\n\tclearop(oap);\n\tmotion_force = NUL;\n    }\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n", "\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,\n *\t  op_change, op_yank, do_join\n */\n\n#include \"vim.h\"\n\nstatic void shift_block(oparg_T *oap, int amount);\nstatic void\tmb_adjust_opend(oparg_T *oap);\nstatic int\tdo_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1);\n\n// Flags for third item in \"opchars\".\n#define OPF_LINES  1\t// operator always works on lines\n#define OPF_CHANGE 2\t// operator changes text\n\n/*\n * The names of operators.\n * IMPORTANT: Index must correspond with defines in vim.h!!!\n * The third field holds OPF_ flags.\n */\nstatic char opchars[][3] =\n{\n    {NUL, NUL, 0},\t\t\t// OP_NOP\n    {'d', NUL, OPF_CHANGE},\t\t// OP_DELETE\n    {'y', NUL, 0},\t\t\t// OP_YANK\n    {'c', NUL, OPF_CHANGE},\t\t// OP_CHANGE\n    {'<', NUL, OPF_LINES | OPF_CHANGE},\t// OP_LSHIFT\n    {'>', NUL, OPF_LINES | OPF_CHANGE},\t// OP_RSHIFT\n    {'!', NUL, OPF_LINES | OPF_CHANGE},\t// OP_FILTER\n    {'g', '~', OPF_CHANGE},\t\t// OP_TILDE\n    {'=', NUL, OPF_LINES | OPF_CHANGE},\t// OP_INDENT\n    {'g', 'q', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT\n    {':', NUL, OPF_LINES},\t\t// OP_COLON\n    {'g', 'U', OPF_CHANGE},\t\t// OP_UPPER\n    {'g', 'u', OPF_CHANGE},\t\t// OP_LOWER\n    {'J', NUL, OPF_LINES | OPF_CHANGE},\t// DO_JOIN\n    {'g', 'J', OPF_LINES | OPF_CHANGE},\t// DO_JOIN_NS\n    {'g', '?', OPF_CHANGE},\t\t// OP_ROT13\n    {'r', NUL, OPF_CHANGE},\t\t// OP_REPLACE\n    {'I', NUL, OPF_CHANGE},\t\t// OP_INSERT\n    {'A', NUL, OPF_CHANGE},\t\t// OP_APPEND\n    {'z', 'f', OPF_LINES},\t\t// OP_FOLD\n    {'z', 'o', OPF_LINES},\t\t// OP_FOLDOPEN\n    {'z', 'O', OPF_LINES},\t\t// OP_FOLDOPENREC\n    {'z', 'c', OPF_LINES},\t\t// OP_FOLDCLOSE\n    {'z', 'C', OPF_LINES},\t\t// OP_FOLDCLOSEREC\n    {'z', 'd', OPF_LINES},\t\t// OP_FOLDDEL\n    {'z', 'D', OPF_LINES},\t\t// OP_FOLDDELREC\n    {'g', 'w', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT2\n    {'g', '@', OPF_CHANGE},\t\t// OP_FUNCTION\n    {Ctrl_A, NUL, OPF_CHANGE},\t\t// OP_NR_ADD\n    {Ctrl_X, NUL, OPF_CHANGE},\t\t// OP_NR_SUB\n};\n\n/*\n * Translate a command name into an operator type.\n * Must only be called with a valid operator name!\n */\n    int\nget_op_type(int char1, int char2)\n{\n    int\t\ti;\n\n    if (char1 == 'r')\t\t// ignore second character\n\treturn OP_REPLACE;\n    if (char1 == '~')\t\t// when tilde is an operator\n\treturn OP_TILDE;\n    if (char1 == 'g' && char2 == Ctrl_A)\t// add\n\treturn OP_NR_ADD;\n    if (char1 == 'g' && char2 == Ctrl_X)\t// subtract\n\treturn OP_NR_SUB;\n    if (char1 == 'z' && char2 == 'y')\t// OP_YANK\n\treturn OP_YANK;\n    for (i = 0; ; ++i)\n    {\n\tif (opchars[i][0] == char1 && opchars[i][1] == char2)\n\t    break;\n\tif (i == (int)ARRAY_LENGTH(opchars) - 1)\n\t{\n\t    internal_error(\"get_op_type()\");\n\t    break;\n\t}\n    }\n    return i;\n}\n\n/*\n * Return TRUE if operator \"op\" always works on whole lines.\n */\n    static int\nop_on_lines(int op)\n{\n    return opchars[op][2] & OPF_LINES;\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Return TRUE if operator \"op\" changes text.\n */\n    int\nop_is_change(int op)\n{\n    return opchars[op][2] & OPF_CHANGE;\n}\n#endif\n\n/*\n * Get first operator command character.\n * Returns 'g' or 'z' if there is another command character.\n */\n    int\nget_op_char(int optype)\n{\n    return opchars[optype][0];\n}\n\n/*\n * Get second operator command character.\n */\n    int\nget_extra_op_char(int optype)\n{\n    return opchars[optype][1];\n}\n\n/*\n * op_shift - handle a shift operation\n */\n    void\nop_shift(oparg_T *oap, int curs_top, int amount)\n{\n    long\t    i;\n    int\t\t    first_char;\n    int\t\t    block_col = 0;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    if (oap->block_mode)\n\tblock_col = curwin->w_cursor.col;\n\n    for (i = oap->line_count; --i >= 0; )\n    {\n\tfirst_char = *ml_get_curline();\n\tif (first_char == NUL)\t\t\t\t// empty line\n\t    curwin->w_cursor.col = 0;\n\telse if (oap->block_mode)\n\t    shift_block(oap, amount);\n\telse\n\t    // Move the line right if it doesn't start with '#', 'smartindent'\n\t    // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    if (first_char != '#' || !preprocs_left())\n#endif\n\t    shift_line(oap->op_type == OP_LSHIFT, p_sr, amount, FALSE);\n\t++curwin->w_cursor.lnum;\n    }\n\n    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    if (oap->block_mode)\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tcurwin->w_cursor.col = block_col;\n    }\n    else if (curs_top)\t    // put cursor on first line, for \">>\"\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tbeginline(BL_SOL | BL_FIX);   // shift_line() may have set cursor.col\n    }\n    else\n\t--curwin->w_cursor.lnum;\t// put cursor on last line, for \":>\"\n\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold\n    foldOpenCursor();\n#endif\n\n\n    if (oap->line_count > p_report)\n    {\n\tchar\t    *op;\n\tchar\t    *msg_line_single;\n\tchar\t    *msg_line_plural;\n\n\tif (oap->op_type == OP_RSHIFT)\n\t    op = \">\";\n\telse\n\t    op = \"<\";\n\tmsg_line_single = NGETTEXT(\"%ld line %sed %d time\",\n\t\t\t\t\t     \"%ld line %sed %d times\", amount);\n\tmsg_line_plural = NGETTEXT(\"%ld lines %sed %d time\",\n\t\t\t\t\t    \"%ld lines %sed %d times\", amount);\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\tNGETTEXT(msg_line_single, msg_line_plural, oap->line_count),\n\t\toap->line_count, op, amount);\n\tmsg_attr_keep((char *)IObuff, 0, TRUE);\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end.lnum = oap->end.lnum;\n\tcurbuf->b_op_end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Shift the current line one shiftwidth left (if left != 0) or right\n * leaves cursor on first blank in the line.\n */\n    void\nshift_line(\n    int\tleft,\n    int\tround,\n    int\tamount,\n    int call_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tcount;\n    int\t\ti, j;\n    int\t\tsw_val = (int)get_sw_value_indent(curbuf);\n\n    count = get_indent();\t// get current indent\n\n    if (round)\t\t\t// round off indent\n    {\n\ti = count / sw_val;\t// number of 'shiftwidth' rounded down\n\tj = count % sw_val;\t// extra spaces\n\tif (j && left)\t\t// first remove extra spaces\n\t    --amount;\n\tif (left)\n\t{\n\t    i -= amount;\n\t    if (i < 0)\n\t\ti = 0;\n\t}\n\telse\n\t    i += amount;\n\tcount = i * sw_val;\n    }\n    else\t\t// original vi indent\n    {\n\tif (left)\n\t{\n\t    count -= sw_val * amount;\n\t    if (count < 0)\n\t\tcount = 0;\n\t}\n\telse\n\t    count += sw_val * amount;\n    }\n\n    // Set new indent\n    if (State & VREPLACE_FLAG)\n\tchange_indent(INDENT_SET, count, FALSE, NUL, call_changed_bytes);\n    else\n\t(void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);\n}\n\n/*\n * Shift one line of the current block one shiftwidth right or left.\n * Leaves cursor on first character in block.\n */\n    static void\nshift_block(oparg_T *oap, int amount)\n{\n    int\t\t\tleft = (oap->op_type == OP_LSHIFT);\n    int\t\t\toldstate = State;\n    int\t\t\ttotal;\n    char_u\t\t*newp, *oldp;\n    int\t\t\toldcol = curwin->w_cursor.col;\n    int\t\t\tsw_val = (int)get_sw_value_indent(curbuf);\n    int\t\t\tts_val = (int)curbuf->b_p_ts;\n    struct block_def\tbd;\n    int\t\t\tincr;\n    colnr_T\t\tws_vcol;\n    int\t\t\ti = 0, j = 0;\n    int\t\t\tlen;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\told_p_ri = p_ri;\n\n    p_ri = 0;\t\t\t// don't want revins in indent\n#endif\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n    if (bd.is_short)\n\treturn;\n\n    // total is number of screen columns to be inserted/removed\n    total = (int)((unsigned)amount * (unsigned)sw_val);\n    if ((total / sw_val) != amount)\n\treturn; // multiplication overflow\n\n    oldp = ml_get_curline();\n\n    if (!left)\n    {\n\t/*\n\t *  1. Get start vcol\n\t *  2. Total ws vcols\n\t *  3. Divvy into TABs & spp\n\t *  4. Construct new string\n\t */\n\ttotal += bd.pre_whitesp; // all virtual WS up to & incl a split TAB\n\tws_vcol = bd.start_vcol - bd.pre_whitesp;\n\tif (bd.startspaces)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tif ((*mb_ptr2len)(bd.textstart) == 1)\n\t\t    ++bd.textstart;\n\t\telse\n\t\t{\n\t\t    ws_vcol = 0;\n\t\t    bd.startspaces = 0;\n\t\t}\n\t    }\n\t    else\n\t\t++bd.textstart;\n\t}\n\tfor ( ; VIM_ISWHITE(*bd.textstart); )\n\t{\n\t    // TODO: is passing bd.textstart for start of the line OK?\n\t    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,\n\t\t\t\t\t\t    (colnr_T)(bd.start_vcol));\n\t    total += incr;\n\t    bd.start_vcol += incr;\n\t}\n\t// OK, now total=all the VWS reqd, and textstart points at the 1st\n\t// non-ws char in the block.\n#ifdef FEAT_VARTABS\n\tif (!curbuf->b_p_et)\n\t    tabstop_fromto(ws_vcol, ws_vcol + total,\n\t\t\t\t\tts_val, curbuf->b_p_vts_array, &i, &j);\n\telse\n\t    j = total;\n#else\n\tif (!curbuf->b_p_et)\n\t    i = ((ws_vcol % ts_val) + total) / ts_val; // number of tabs\n\tif (i)\n\t    j = ((ws_vcol % ts_val) + total) % ts_val; // number of spp\n\telse\n\t    j = total;\n#endif\n\t// if we're splitting a TAB, allow for it\n\tbd.textcol -= bd.pre_whitesp_c - (bd.startspaces != 0);\n\tlen = (int)STRLEN(bd.textstart) + 1;\n\tnewp = alloc(bd.textcol + i + j + len);\n\tif (newp == NULL)\n\t    return;\n\tvim_memset(newp, NUL, (size_t)(bd.textcol + i + j + len));\n\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\tvim_memset(newp + bd.textcol, TAB, (size_t)i);\n\tvim_memset(newp + bd.textcol + i, ' ', (size_t)j);\n\t// the end\n\tmch_memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);\n    }\n    else // left\n    {\n\tcolnr_T\t    destination_col;\t// column to which text in block will\n\t\t\t\t\t// be shifted\n\tchar_u\t    *verbatim_copy_end;\t// end of the part of the line which is\n\t\t\t\t\t// copied verbatim\n\tcolnr_T\t    verbatim_copy_width;// the (displayed) width of this part\n\t\t\t\t\t// of line\n\tunsigned    fill;\t\t// nr of spaces that replace a TAB\n\tunsigned    new_line_len;\t// the length of the line after the\n\t\t\t\t\t// block shift\n\tsize_t\t    block_space_width;\n\tsize_t\t    shift_amount;\n\tchar_u\t    *non_white = bd.textstart;\n\tcolnr_T\t    non_white_col;\n\n\t/*\n\t * Firstly, let's find the first non-whitespace character that is\n\t * displayed after the block's start column and the character's column\n\t * number. Also, let's calculate the width of all the whitespace\n\t * characters that are displayed in the block and precede the searched\n\t * non-whitespace character.\n\t */\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,\n\t// the part of which is displayed at the block's beginning. Let's start\n\t// searching from the next character.\n\tif (bd.startspaces)\n\t    MB_PTR_ADV(non_white);\n\n\t// The character's column is in \"bd.start_vcol\".\n\tnon_white_col = bd.start_vcol;\n\n\twhile (VIM_ISWHITE(*non_white))\n\t{\n\t    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);\n\t    non_white_col += incr;\n\t}\n\n\tblock_space_width = non_white_col - oap->start_vcol;\n\t// We will shift by \"total\" or \"block_space_width\", whichever is less.\n\tshift_amount = (block_space_width < (size_t)total\n\t\t\t\t\t ? block_space_width : (size_t)total);\n\n\t// The column to which we will shift the text.\n\tdestination_col = (colnr_T)(non_white_col - shift_amount);\n\n\t// Now let's find out how much of the beginning of the line we can\n\t// reuse without modification.\n\tverbatim_copy_end = bd.textstart;\n\tverbatim_copy_width = bd.start_vcol;\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character\n\t// preceding the block. We have to subtract its width to obtain its\n\t// column number.\n\tif (bd.startspaces)\n\t    verbatim_copy_width -= bd.start_char_vcols;\n\twhile (verbatim_copy_width < destination_col)\n\t{\n\t    char_u *line = verbatim_copy_end;\n\n\t    // TODO: is passing verbatim_copy_end for start of the line OK?\n\t    incr = lbr_chartabsize(line, verbatim_copy_end,\n\t\t\t\t\t\t\t verbatim_copy_width);\n\t    if (verbatim_copy_width + incr > destination_col)\n\t\tbreak;\n\t    verbatim_copy_width += incr;\n\t    MB_PTR_ADV(verbatim_copy_end);\n\t}\n\n\t// If \"destination_col\" is different from the width of the initial\n\t// part of the line that will be copied, it means we encountered a tab\n\t// character, which we will have to partly replace with spaces.\n\tfill = destination_col - verbatim_copy_width;\n\n\t// The replacement line will consist of:\n\t// - the beginning of the original line up to \"verbatim_copy_end\",\n\t// - \"fill\" number of spaces,\n\t// - the rest of the line, pointed to by non_white.\n\tnew_line_len = (unsigned)(verbatim_copy_end - oldp)\n\t\t       + fill\n\t\t       + (unsigned)STRLEN(non_white) + 1;\n\n\tnewp = alloc(new_line_len);\n\tif (newp == NULL)\n\t    return;\n\tmch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));\n\tvim_memset(newp + (verbatim_copy_end - oldp), ' ', (size_t)fill);\n\tSTRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);\n    }\n    // replace the line\n    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n    changed_bytes(curwin->w_cursor.lnum, (colnr_T)bd.textcol);\n    State = oldstate;\n    curwin->w_cursor.col = oldcol;\n#ifdef FEAT_RIGHTLEFT\n    p_ri = old_p_ri;\n#endif\n}\n\n/*\n * Insert string \"s\" (b_insert ? before : after) block :AKelly\n * Caller must prepare for undo.\n */\n    static void\nblock_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t    // avoid copying part of a multi-byte character\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}\n\n/*\n * Handle a delete operation.\n *\n * Return FAIL if undo failed, OK otherwise.\n */\n    int\nop_delete(oparg_T *oap)\n{\n    int\t\t\tn;\n    linenr_T\t\tlnum;\n    char_u\t\t*ptr;\n    char_u\t\t*newp, *oldp;\n    struct block_def\tbd;\n    linenr_T\t\told_lcount = curbuf->b_ml.ml_line_count;\n    int\t\t\tdid_yank = FALSE;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to do\n\treturn OK;\n\n    // Nothing to delete, return here.\tDo prepare undo, for op_change().\n    if (oap->empty)\n\treturn u_save_cursor();\n\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FAIL;\n    }\n\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&oap->regname);\n#endif\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    /*\n     * Imitate the strange Vi behaviour: If the delete spans more than one\n     * line and motion_type == MCHAR and the result is a blank line, make the\n     * delete linewise.  Don't do this for the change command or Visual mode.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && !oap->is_VIsual\n\t    && !oap->block_mode\n\t    && oap->line_count > 1\n\t    && oap->motion_force == NUL\n\t    && oap->op_type == OP_DELETE)\n    {\n\tptr = ml_get(oap->end.lnum) + oap->end.col;\n\tif (*ptr != NUL)\n\t    ptr += oap->inclusive;\n\tptr = skipwhite(ptr);\n\tif (*ptr == NUL && inindent(0))\n\t    oap->motion_type = MLINE;\n    }\n\n    /*\n     * Check for trying to delete (e.g. \"D\") in an empty line.\n     * Note: For the change operator it is ok.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && oap->line_count == 1\n\t    && oap->op_type == OP_DELETE\n\t    && *ml_get(oap->start.lnum) == NUL)\n    {\n\t/*\n\t * It's an error to operate on an empty region, when 'E' included in\n\t * 'cpoptions' (Vi compatible).\n\t */\n\tif (virtual_op)\n\t    // Virtual editing: Nothing gets deleted, but we set the '[ and ']\n\t    // marks as if it happened.\n\t    goto setmarks;\n\tif (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL)\n\t    beep_flush();\n\treturn OK;\n    }\n\n    /*\n     * Do a yank of whatever we're about to delete.\n     * If a yank register was specified, put the deleted text into that\n     * register.  For the black hole register '_' don't yank anything.\n     */\n    if (oap->regname != '_')\n    {\n\tif (oap->regname != 0)\n\t{\n\t    // check for read-only register\n\t    if (!valid_yank_reg(oap->regname, TRUE))\n\t    {\n\t\tbeep_flush();\n\t\treturn OK;\n\t    }\n\t    get_yank_register(oap->regname, TRUE); // yank into specif'd reg.\n\t    if (op_yank(oap, TRUE, FALSE) == OK)   // yank without message\n\t\tdid_yank = TRUE;\n\t}\n\telse\n\t    reset_y_append(); // not appending to unnamed register\n\n\t/*\n\t * Put deleted text into register 1 and shift number registers if the\n\t * delete contains a line break, or when using a specific operator (Vi\n\t * compatible)\n\t * Use the register name from before adjust_clip_reg() may have\n\t * changed it.\n\t */\n\tif (oap->motion_type == MLINE || oap->line_count > 1\n\t\t\t\t\t\t\t   || oap->use_reg_one)\n\t{\n\t    shift_delete_registers();\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t}\n\n\t// Yank into small delete register when no named register specified\n\t// and the delete is within one line.\n\tif ((\n#ifdef FEAT_CLIPBOARD\n\t    ((clip_unnamed & CLIP_UNNAMED) && oap->regname == '*') ||\n\t    ((clip_unnamed & CLIP_UNNAMED_PLUS) && oap->regname == '+') ||\n#endif\n\t    oap->regname == 0) && oap->motion_type != MLINE\n\t\t\t\t\t\t      && oap->line_count == 1)\n\t{\n\t    oap->regname = '-';\n\t    get_yank_register(oap->regname, TRUE);\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t    oap->regname = 0;\n\t}\n\n\t/*\n\t * If there's too much stuff to fit in the yank register, then get a\n\t * confirmation before doing the delete. This is crude, but simple.\n\t * And it avoids doing a delete of something we can't put back if we\n\t * want.\n\t */\n\tif (!did_yank)\n\t{\n\t    int msg_silent_save = msg_silent;\n\n\t    msg_silent = 0;\t// must display the prompt\n\t    n = ask_yesno((char_u *)_(\"cannot yank; delete anyway\"), TRUE);\n\t    msg_silent = msg_silent_save;\n\t    if (n != 'y')\n\t    {\n\t\temsg(_(e_command_aborted));\n\t\treturn FAIL;\n\t    }\n\t}\n\n#if defined(FEAT_EVAL)\n\tif (did_yank && has_textyankpost())\n\t    yank_do_autocmd(oap, get_y_current());\n#endif\n    }\n\n    /*\n     * block mode delete\n     */\n    if (oap->block_mode)\n    {\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t    return FAIL;\n\n\tfor (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; ++lnum)\n\t{\n\t    block_prep(oap, &bd, lnum, TRUE);\n\t    if (bd.textlen == 0)\t// nothing to delete\n\t\tcontinue;\n\n\t    // Adjust cursor position for tab replaced by spaces and 'lbr'.\n\t    if (lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tcurwin->w_cursor.col = bd.textcol + bd.startspaces;\n\t\tcurwin->w_cursor.coladd = 0;\n\t    }\n\n\t    // \"n\" == number of chars deleted\n\t    // If we delete a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    n = bd.textlen - bd.startspaces - bd.endspaces;\n\t    oldp = ml_get(lnum);\n\t    newp = alloc(STRLEN(oldp) + 1 - n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    // insert spaces\n\t    vim_memset(newp + bd.textcol, ' ',\n\t\t\t\t     (size_t)(bd.startspaces + bd.endspaces));\n\t    // copy the part after the deleted part\n\t    oldp += bd.textcol + bd.textlen;\n\t    STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);\n\t    // replace the line\n\t    ml_replace(lnum, newp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n\t    if (curbuf->b_has_textprop && n != 0)\n\t\tadjust_prop_columns(lnum, bd.textcol, -n, 0);\n#endif\n\t}\n\n\tcheck_cursor_col();\n\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t\t       oap->end.lnum + 1, 0L);\n\toap->line_count = 0;\t    // no lines deleted\n    }\n    else if (oap->motion_type == MLINE)\n    {\n\tif (oap->op_type == OP_CHANGE)\n\t{\n\t    // Delete the lines except the first one.  Temporarily move the\n\t    // cursor to the next line.  Save the current line number, if the\n\t    // last line is deleted it may be changed.\n\t    if (oap->line_count > 1)\n\t    {\n\t\tlnum = curwin->w_cursor.lnum;\n\t\t++curwin->w_cursor.lnum;\n\t\tdel_lines((long)(oap->line_count - 1), TRUE);\n\t\tcurwin->w_cursor.lnum = lnum;\n\t    }\n\t    if (u_save_cursor() == FAIL)\n\t\treturn FAIL;\n\t    if (curbuf->b_p_ai)\t\t    // don't delete indent\n\t    {\n\t\tbeginline(BL_WHITE);\t    // cursor on first non-white\n\t\tdid_ai = TRUE;\t\t    // delete the indent when ESC hit\n\t\tai_col = curwin->w_cursor.col;\n\t    }\n\t    else\n\t\tbeginline(0);\t\t    // cursor in column 0\n\t    truncate_line(FALSE);   // delete the rest of the line\n\t\t\t\t    // leave cursor past last char in line\n\t    if (oap->line_count > 1)\n\t\tu_clearline();\t    // \"U\" command not possible after \"2cc\"\n\t}\n\telse\n\t{\n\t    del_lines(oap->line_count, TRUE);\n\t    beginline(BL_WHITE | BL_FIX);\n\t    u_clearline();\t// \"U\" command not possible after \"dd\"\n\t}\n    }\n    else\n    {\n\tif (virtual_op)\n\t{\n\t    int\t\tendcol = 0;\n\n\t    // For virtualedit: break the tabs that are partly included.\n\t    if (gchar_pos(&oap->start) == '\\t')\n\t    {\n\t\tif (u_save_cursor() == FAIL)\t// save first line for undo\n\t\t    return FAIL;\n\t\tif (oap->line_count == 1)\n\t\t    endcol = getviscol2(oap->end.col, oap->end.coladd);\n\t\tcoladvance_force(getviscol2(oap->start.col, oap->start.coladd));\n\t\toap->start = curwin->w_cursor;\n\t\tif (oap->line_count == 1)\n\t\t{\n\t\t    coladvance(endcol);\n\t\t    oap->end.col = curwin->w_cursor.col;\n\t\t    oap->end.coladd = curwin->w_cursor.coladd;\n\t\t    curwin->w_cursor = oap->start;\n\t\t}\n\t    }\n\n\t    // Break a tab only when it's included in the area.\n\t    if (gchar_pos(&oap->end) == '\\t'\n\t\t\t\t     && (int)oap->end.coladd < oap->inclusive)\n\t    {\n\t\t// save last line for undo\n\t\tif (u_save((linenr_T)(oap->end.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t\t    return FAIL;\n\t\tcurwin->w_cursor = oap->end;\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd));\n\t\toap->end = curwin->w_cursor;\n\t\tcurwin->w_cursor = oap->start;\n\t    }\n\t    if (has_mbyte)\n\t\tmb_adjust_opend(oap);\n\t}\n\n\tif (oap->line_count == 1)\t// delete characters within one line\n\t{\n\t    if (u_save_cursor() == FAIL)\t// save line for undo\n\t\treturn FAIL;\n\n\t    // if 'cpoptions' contains '$', display '$' at end of change\n\t    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL\n\t\t    && oap->op_type == OP_CHANGE\n\t\t    && oap->end.lnum == curwin->w_cursor.lnum\n\t\t    && !oap->is_VIsual)\n\t\tdisplay_dollar(oap->end.col - !oap->inclusive);\n\n\t    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;\n\n\t    if (virtual_op)\n\t    {\n\t\t// fix up things for virtualedit-delete:\n\t\t// break the tabs which are going to get in our way\n\t\tchar_u\t\t*curline = ml_get_curline();\n\t\tint\t\tlen = (int)STRLEN(curline);\n\n\t\tif (oap->end.coladd != 0\n\t\t\t&& (int)oap->end.col >= len - 1\n\t\t\t&& !(oap->start.coladd && (int)oap->end.col >= len - 1))\n\t\t    n++;\n\t\t// Delete at least one char (e.g, when on a control char).\n\t\tif (n == 0 && oap->start.coladd != oap->end.coladd)\n\t\t    n = 1;\n\n\t\t// When deleted a char in the line, reset coladd.\n\t\tif (gchar_cursor() != NUL)\n\t\t    curwin->w_cursor.coladd = 0;\n\t    }\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t}\n\telse\t\t\t\t// delete characters between lines\n\t{\n\t    pos_T   curpos;\n\n\t    // save deleted and changed lines for undo\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)\n\t\treturn FAIL;\n\n\t    truncate_line(TRUE);\t// delete from cursor to end of line\n\n\t    curpos = curwin->w_cursor;\t// remember curwin->w_cursor\n\t    ++curwin->w_cursor.lnum;\n\t    del_lines((long)(oap->line_count - 2), FALSE);\n\n\t    // delete from start of line until op_end\n\t    n = (oap->end.col + 1 - !oap->inclusive);\n\t    curwin->w_cursor.col = 0;\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t    curwin->w_cursor = curpos;\t// restore curwin->w_cursor\n\t    (void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t}\n\tif (oap->op_type == OP_DELETE)\n\t    auto_format(FALSE, TRUE);\n    }\n\n    msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n\nsetmarks:\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tif (oap->block_mode)\n\t{\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = oap->start.col;\n\t}\n\telse\n\t    curbuf->b_op_end = oap->start;\n\tcurbuf->b_op_start = oap->start;\n    }\n\n    return OK;\n}\n\n/*\n * Adjust end of operating area for ending on a multi-byte character.\n * Used for deletion.\n */\n    static void\nmb_adjust_opend(oparg_T *oap)\n{\n    char_u\t*p;\n\n    if (oap->inclusive)\n    {\n\tp = ml_get(oap->end.lnum);\n\toap->end.col += mb_tail_off(p, p + oap->end.col);\n    }\n}\n\n/*\n * Replace the character under the cursor with \"c\".\n * This takes care of multi-byte characters.\n */\n    static void\nreplace_character(int c)\n{\n    int n = State;\n\n    State = REPLACE;\n    ins_char(c);\n    State = n;\n    // Backup to the replaced character.\n    dec_cursor();\n}\n\n/*\n * Replace a whole area with one character.\n */\n    int\nop_replace(oparg_T *oap, int c)\n{\n    int\t\t\tn, numc;\n    int\t\t\tnum_chars;\n    char_u\t\t*newp, *oldp;\n    size_t\t\toldlen;\n    struct block_def\tbd;\n    char_u\t\t*after_p = NULL;\n    int\t\t\thad_ctrl_v_cr = FALSE;\n\n    if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n\treturn OK;\t    // nothing to do\n\n    if (c == REPLACE_CR_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = CAR;\n    }\n    else if (c == REPLACE_NL_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = NL;\n    }\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn FAIL;\n\n    /*\n     * block mode replace\n     */\n    if (oap->block_mode)\n    {\n\tbd.is_MAX = (curwin->w_curswant == MAXCOL);\n\tfor ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = 0;  // make sure cursor position is valid\n\t    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n\t    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))\n\t\tcontinue;\t    // nothing to replace\n\n\t    // n == number of extra chars required\n\t    // If we split a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    // If the range starts in virtual space, count the initial\n\t    // coladd offset as part of \"startspaces\"\n\t    if (virtual_op && bd.is_short && *bd.textstart == NUL)\n\t    {\n\t\tpos_T vpos;\n\n\t\tvpos.lnum = curwin->w_cursor.lnum;\n\t\tgetvpos(&vpos, oap->start_vcol);\n\t\tbd.startspaces += vpos.coladd;\n\t\tn = bd.startspaces;\n\t    }\n\t    else\n\t\t// allow for pre spaces\n\t\tn = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n\t    // allow for post spp\n\t    n += (bd.endspaces\n\t\t    && !bd.is_oneChar\n\t\t    && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n\t    // Figure out how many characters to replace.\n\t    numc = oap->end_vcol - oap->start_vcol + 1;\n\t    if (bd.is_short && (!virtual_op || bd.is_MAX))\n\t\tnumc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n\t    // A double-wide character can be replaced only up to half the\n\t    // times.\n\t    if ((*mb_char2cells)(c) > 1)\n\t    {\n\t\tif ((numc & 1) && !bd.is_short)\n\t\t{\n\t\t    ++bd.endspaces;\n\t\t    ++n;\n\t\t}\n\t\tnumc = numc / 2;\n\t    }\n\n\t    // Compute bytes needed, move character count to num_chars.\n\t    num_chars = numc;\n\t    numc *= (*mb_char2len)(c);\n\t    // oldlen includes textlen, so don't double count\n\t    n += numc - bd.textlen;\n\n\t    oldp = ml_get_curline();\n\t    oldlen = STRLEN(oldp);\n\t    newp = alloc(oldlen + 1 + n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    oldp += bd.textcol + bd.textlen;\n\t    // insert pre-spaces\n\t    vim_memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n\t    // insert replacement chars CHECK FOR ALLOCATED SPACE\n\t    // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR\n\t    // literally.\n\t    if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = (int)STRLEN(newp);\n\t\t    while (--num_chars >= 0)\n\t\t\tn += (*mb_char2bytes)(c, newp + n);\n\t\t}\n\t\telse\n\t\t    vim_memset(newp + STRLEN(newp), c, (size_t)numc);\n\t\tif (!bd.is_short)\n\t\t{\n\t\t    // insert post-spaces\n\t\t    vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);\n\t\t    // copy the part after the changed part\n\t\t    STRMOVE(newp + STRLEN(newp), oldp);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Replacing with \\r or \\n means splitting the line.\n\t\tafter_p = alloc(oldlen + 1 + n - STRLEN(newp));\n\t\tif (after_p != NULL)\n\t\t    STRMOVE(after_p, oldp);\n\t    }\n\t    // replace the line\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    if (after_p != NULL)\n\t    {\n\t\tml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);\n\t\tappended_lines_mark(curwin->w_cursor.lnum, 1L);\n\t\toap->end.lnum++;\n\t\tvim_free(after_p);\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * MCHAR and MLINE motion replace.\n\t */\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    curwin->w_cursor.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n\t{\n\t    n = gchar_cursor();\n\t    if (n != NUL)\n\t    {\n\t\tint new_byte_len = (*mb_char2len)(c);\n\t\tint old_byte_len = mb_ptr2len(ml_get_cursor());\n\n\t\tif (new_byte_len > 1 || old_byte_len > 1)\n\t\t{\n\t\t    // This is slow, but it handles replacing a single-byte\n\t\t    // with a multi-byte and the other way around.\n\t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\toap->end.col += new_byte_len - old_byte_len;\n\t\t    replace_character(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (n == TAB)\n\t\t    {\n\t\t\tint end_vcol = 0;\n\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t{\n\t\t\t    // oap->end has to be recalculated when\n\t\t\t    // the tab breaks\n\t\t\t    end_vcol = getviscol2(oap->end.col,\n\t\t\t\t\t\t\t     oap->end.coladd);\n\t\t\t}\n\t\t\tcoladvance_force(getviscol());\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t    getvpos(&oap->end, end_vcol);\n\t\t    }\n\t\t    PBYTE(curwin->w_cursor, c);\n\t\t}\n\t    }\n\t    else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n\t    {\n\t\tint virtcols = oap->end.coladd;\n\n\t\tif (curwin->w_cursor.lnum == oap->start.lnum\n\t\t\t&& oap->start.col == oap->end.col && oap->start.coladd)\n\t\t    virtcols -= oap->start.coladd;\n\n\t\t// oap->end has been trimmed so it's effectively inclusive;\n\t\t// as a result an extra +1 must be counted so we don't\n\t\t// trample the NUL byte.\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n\t\tcurwin->w_cursor.col -= (virtcols + 1);\n\t\tfor (; virtcols >= 0; virtcols--)\n\t\t{\n                   if ((*mb_char2len)(c) > 1)\n\t\t       replace_character(c);\n                   else\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t   if (inc(&curwin->w_cursor) == -1)\n\t\t       break;\n\t\t}\n\t    }\n\n\t    // Advance to next character, stop at the end of the file.\n\t    if (inc_cursor() == -1)\n\t\tbreak;\n\t}\n    }\n\n    curwin->w_cursor = oap->start;\n    check_cursor();\n    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    return OK;\n}\n\nstatic int swapchars(int op_type, pos_T *pos, int length);\n\n/*\n * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\".\n */\n    static void\nop_tilde(oparg_T *oap)\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tdid_change = FALSE;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    pos = oap->start;\n    if (oap->block_mode)\t\t    // Visual block mode\n    {\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    int one_change;\n\n\t    block_prep(oap, &bd, pos.lnum, FALSE);\n\t    pos.col = bd.textcol;\n\t    one_change = swapchars(oap->op_type, &pos, bd.textlen);\n\t    did_change |= one_change;\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\n\t\tnetbeans_removed(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t\t    (long)bd.textlen);\n\t\tnetbeans_inserted(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t&ptr[bd.textcol], bd.textlen);\n\t    }\n#endif\n\t}\n\tif (did_change)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    }\n    else\t\t\t\t    // not block mode\n    {\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    pos.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\tif (pos.lnum == oap->end.lnum)\n\t    did_change = swapchars(oap->op_type, &pos,\n\t\t\t\t\t\t  oap->end.col - pos.col + 1);\n\telse\n\t    for (;;)\n\t    {\n\t\tdid_change |= swapchars(oap->op_type, &pos,\n\t\t\t\tpos.lnum == oap->end.lnum ? oap->end.col + 1:\n\t\t\t\t\t   (int)STRLEN(ml_get_pos(&pos)));\n\t\tif (LTOREQ_POS(oap->end, pos) || inc(&pos) == -1)\n\t\t    break;\n\t    }\n\tif (did_change)\n\t{\n\t    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && did_change)\n\t    {\n\t\tchar_u *ptr;\n\t\tint count;\n\n\t\tpos = oap->start;\n\t\twhile (pos.lnum < oap->end.lnum)\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\t    count = (int)STRLEN(ptr) - pos.col;\n\t\t    netbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\t    netbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tcount = oap->end.col - pos.col + 1;\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t    }\n#endif\n\t}\n    }\n\n    if (!did_change && oap->is_VIsual)\n\t// No change: need to remove the Visual selection\n\tredraw_curbuf_later(INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set '[ and '] marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    if (oap->line_count > p_report)\n\tsmsg(NGETTEXT(\"%ld line changed\", \"%ld lines changed\",\n\t\t\t\t\t    oap->line_count), oap->line_count);\n}\n\n/*\n * Invoke swapchar() on \"length\" bytes at position \"pos\".\n * \"pos\" is advanced to just after the changed characters.\n * \"length\" is rounded up to include the whole last multi-byte character.\n * Also works correctly when the number of bytes changes.\n * Returns TRUE if some character was changed.\n */\n    static int\nswapchars(int op_type, pos_T *pos, int length)\n{\n    int todo;\n    int\tdid_change = 0;\n\n    for (todo = length; todo > 0; --todo)\n    {\n\tif (has_mbyte)\n\t{\n\t    int len = (*mb_ptr2len)(ml_get_pos(pos));\n\n\t    // we're counting bytes, not characters\n\t    if (len > 0)\n\t\ttodo -= len - 1;\n\t}\n\tdid_change |= swapchar(op_type, pos);\n\tif (inc(pos) == -1)    // at end of file\n\t    break;\n    }\n    return did_change;\n}\n\n/*\n * If op_type == OP_UPPER: make uppercase,\n * if op_type == OP_LOWER: make lowercase,\n * if op_type == OP_ROT13: do rot13 encoding,\n * else swap case of character at 'pos'\n * returns TRUE when something actually changed.\n */\n    int\nswapchar(int op_type, pos_T *pos)\n{\n    int\t    c;\n    int\t    nc;\n\n    c = gchar_pos(pos);\n\n    // Only do rot13 encoding for ASCII characters.\n    if (c >= 0x80 && op_type == OP_ROT13)\n\treturn FALSE;\n\n    if (op_type == OP_UPPER && c == 0xdf\n\t\t      && (enc_latin1like || STRCMP(p_enc, \"iso-8859-2\") == 0))\n    {\n\tpos_T   sp = curwin->w_cursor;\n\n\t// Special handling of German sharp s: change to \"SS\".\n\tcurwin->w_cursor = *pos;\n\tdel_char(FALSE);\n\tins_char('S');\n\tins_char('S');\n\tcurwin->w_cursor = sp;\n\tinc(pos);\n    }\n\n    if (enc_dbcs != 0 && c >= 0x100)\t// No lower/uppercase letter\n\treturn FALSE;\n    nc = c;\n    if (MB_ISLOWER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'a');\n\telse if (op_type != OP_LOWER)\n\t    nc = MB_TOUPPER(c);\n    }\n    else if (MB_ISUPPER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'A');\n\telse if (op_type != OP_UPPER)\n\t    nc = MB_TOLOWER(c);\n    }\n    if (nc != c)\n    {\n\tif (enc_utf8 && (c >= 0x80 || nc >= 0x80))\n\t{\n\t    pos_T   sp = curwin->w_cursor;\n\n\t    curwin->w_cursor = *pos;\n\t    // don't use del_char(), it also removes composing chars\n\t    del_bytes(utf_ptr2len(ml_get_cursor()), FALSE, FALSE);\n\t    ins_char(nc);\n\t    curwin->w_cursor = sp;\n\t}\n\telse\n\t    PBYTE(*pos, nc);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * op_insert - Insert and append operators for Visual mode.\n */\n    void\nop_insert(oparg_T *oap, long count1)\n{\n    long\t\tins_len, pre_textlen = 0;\n    char_u\t\t*firstline, *ins_text;\n    colnr_T\t\tind_pre_col = 0, ind_post_col;\n    int\t\t\tind_pre_vcol = 0, ind_post_vcol = 0;\n    struct block_def\tbd;\n    int\t\t\ti;\n    pos_T\t\tt1;\n    pos_T\t\tstart_insert;\n\t\t\t// offset when cursor was moved in insert mode\n    int\t\t\toffset = 0;\n\n    // edit() changes this - record it for OP_APPEND\n    bd.is_MAX = (curwin->w_curswant == MAXCOL);\n\n    // vis block is still marked. Get rid of it now.\n    curwin->w_cursor.lnum = oap->start.lnum;\n    update_screen(INVERTED);\n\n    if (oap->block_mode)\n    {\n\t// When 'virtualedit' is used, need to insert the extra spaces before\n\t// doing block_prep().  When only \"block\" is used, virtual edit is\n\t// already disabled, but still need it when calling\n\t// coladvance_force().\n\t// coladvance_force() uses get_ve_flags() to get the 'virtualedit'\n\t// state for the current window.  To override that state, we need to\n\t// set the window-local value of ve_flags rather than the global value.\n\tif (curwin->w_cursor.coladd > 0)\n\t{\n\t    int\t\told_ve_flags = curwin->w_ve_flags;\n\n\t    if (u_save_cursor() == FAIL)\n\t\treturn;\n\n\t    curwin->w_ve_flags = VE_ALL;\n\t    coladvance_force(oap->op_type == OP_APPEND\n\t\t\t\t\t   ? oap->end_vcol + 1 : getviscol());\n\t    if (oap->op_type == OP_APPEND)\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_ve_flags = old_ve_flags;\n\t}\n\t// Get the info about the block before entering the text\n\tblock_prep(oap, &bd, oap->start.lnum, TRUE);\n\t// Get indent information\n\tind_pre_col = (colnr_T)getwhitecols_curline();\n\tind_pre_vcol = get_indent();\n\tfirstline = ml_get(oap->start.lnum) + bd.textcol;\n\n\tif (oap->op_type == OP_APPEND)\n\t    firstline += bd.textlen;\n\tpre_textlen = (long)STRLEN(firstline);\n    }\n\n    if (oap->op_type == OP_APPEND)\n    {\n\tif (oap->block_mode && curwin->w_cursor.coladd == 0)\n\t{\n\t    // Move the cursor to the character right of the block.\n\t    curwin->w_set_curswant = TRUE;\n\t    while (*ml_get_cursor() != NUL\n\t\t    && (curwin->w_cursor.col < bd.textcol + bd.textlen))\n\t\t++curwin->w_cursor.col;\n\t    if (bd.is_short && !bd.is_MAX)\n\t    {\n\t\t// First line was too short, make it longer and adjust the\n\t\t// values in \"bd\".\n\t\tif (u_save_cursor() == FAIL)\n\t\t    return;\n\t\tfor (i = 0; i < bd.endspaces; ++i)\n\t\t    ins_char(' ');\n\t\tbd.textlen += bd.endspaces;\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = oap->end;\n\t    check_cursor_col();\n\n\t    // Works just like an 'i'nsert on the next character.\n\t    if (!LINEEMPTY(curwin->w_cursor.lnum)\n\t\t    && oap->start_vcol != oap->end_vcol)\n\t\tinc_cursor();\n\t}\n    }\n\n    t1 = oap->start;\n    start_insert = curwin->w_cursor;\n    (void)edit(NUL, FALSE, (linenr_T)count1);\n\n    // When a tab was inserted, and the characters in front of the tab\n    // have been converted to a tab as well, the column of the cursor\n    // might have actually been reduced, so need to adjust here.\n    if (t1.lnum == curbuf->b_op_start_orig.lnum\n\t    && LT_POS(curbuf->b_op_start_orig, t1))\n\toap->start = curbuf->b_op_start_orig;\n\n    // If user has moved off this line, we don't know what to do, so do\n    // nothing.\n    // Also don't repeat the insert when Insert mode ended with CTRL-C.\n    if (curwin->w_cursor.lnum != oap->start.lnum || got_int)\n\treturn;\n\n    if (oap->block_mode)\n    {\n\tstruct block_def\tbd2;\n\tint\t\t\tdid_indent = FALSE;\n\tsize_t\t\t\tlen;\n\tint\t\t\tadd;\n\n\t// If indent kicked in, the firstline might have changed\n\t// but only do that, if the indent actually increased.\n\tind_post_col = (colnr_T)getwhitecols_curline();\n\tif (curbuf->b_op_start.col > ind_pre_col && ind_post_col > ind_pre_col)\n\t{\n\t    bd.textcol += ind_post_col - ind_pre_col;\n\t    ind_post_vcol = get_indent();\n\t    bd.start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    did_indent = TRUE;\n\t}\n\n\t// The user may have moved the cursor before inserting something, try\n\t// to adjust the block for that.  But only do it, if the difference\n\t// does not come from indent kicking in.\n\tif (oap->start.lnum == curbuf->b_op_start_orig.lnum\n\t\t\t\t\t\t  && !bd.is_MAX && !did_indent)\n\t{\n\t    int t = getviscol2(curbuf->b_op_start_orig.col,\n\t\t\t\t\t       curbuf->b_op_start_orig.coladd);\n\n\t    if (!bd.is_MAX)\n\t    {\n\t\tif (oap->op_type == OP_INSERT\n\t\t\t&& oap->start.col + oap->start.coladd\n\t\t\t\t!= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t\t{\n\t\t    oap->start.col = curbuf->b_op_start_orig.col;\n\t\t    pre_textlen -= t - oap->start_vcol;\n\t\t    oap->start_vcol = t;\n\t\t}\n\t\telse if (oap->op_type == OP_APPEND\n\t\t\t&& oap->start.col + oap->start.coladd\n\t\t\t\t>= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t\t{\n\t\t    oap->start.col = curbuf->b_op_start_orig.col;\n\t\t    // reset pre_textlen to the value of OP_INSERT\n\t\t    pre_textlen += bd.textlen;\n\t\t    pre_textlen -= t - oap->start_vcol;\n\t\t    oap->start_vcol = t;\n\t\t    oap->op_type = OP_INSERT;\n\t\t}\n\t    }\n\t    else if (bd.is_MAX && oap->op_type == OP_APPEND)\n\t    {\n\t\t// reset pre_textlen to the value of OP_INSERT\n\t\tpre_textlen += bd.textlen;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t    }\n\t}\n\n\t// Spaces and tabs in the indent may have changed to other spaces and\n\t// tabs.  Get the starting column again and correct the length.\n\t// Don't do this when \"$\" used, end-of-line will have changed.\n\t//\n\t// if indent was added and the inserted text was after the indent,\n\t// correct the selection for the new indent.\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    oap->start.col += ind_post_col - ind_pre_col;\n\t    oap->start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col += ind_post_col - ind_pre_col;\n\t    oap->end_vcol += ind_post_vcol - ind_pre_vcol;\n\t}\n\tblock_prep(oap, &bd2, oap->start.lnum, TRUE);\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    // undo for where \"oap\" is used below\n\t    oap->start.col -= ind_post_col - ind_pre_col;\n\t    oap->start_vcol -= ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col -= ind_post_col - ind_pre_col;\n\t    oap->end_vcol -= ind_post_vcol - ind_pre_vcol;\n\t}\n\tif (!bd.is_MAX || bd2.textlen < bd.textlen)\n\t{\n\t    if (oap->op_type == OP_APPEND)\n\t    {\n\t\tpre_textlen += bd2.textlen - bd.textlen;\n\t\tif (bd2.endspaces)\n\t\t    --bd2.textlen;\n\t    }\n\t    bd.textcol = bd2.textcol;\n\t    bd.textlen = bd2.textlen;\n\t}\n\n\t/*\n\t * Subsequent calls to ml_get() flush the firstline data - take a\n\t * copy of the required string.\n\t */\n\tfirstline = ml_get(oap->start.lnum);\n\tlen = STRLEN(firstline);\n\tadd = bd.textcol;\n\tif (oap->op_type == OP_APPEND)\n\t{\n\t    add += bd.textlen;\n\t    // account for pressing cursor in insert mode when '$' was used\n\t    if (bd.is_MAX\n\t\t&& (start_insert.lnum == Insstart.lnum\n\t\t\t\t\t   && start_insert.col > Insstart.col))\n\t    {\n\t\toffset = (start_insert.col - Insstart.col);\n\t\tadd -= offset;\n\t\tif (oap->end_vcol > offset)\n\t\t    oap->end_vcol -= (offset + 1);\n\t\telse\n\t\t    // moved outside of the visual block, what to do?\n\t\t    return;\n\t    }\n\t}\n\tif ((size_t)add > len)\n\t    firstline += len;  // short line, point to the NUL\n\telse\n\t    firstline += add;\n\tif (pre_textlen >= 0 && (ins_len =\n\t\t\t   (long)STRLEN(firstline) - pre_textlen - offset) > 0)\n\t{\n\t    ins_text = vim_strnsave(firstline, ins_len);\n\t    if (ins_text != NULL)\n\t    {\n\t\t// block handled here\n\t\tif (u_save(oap->start.lnum,\n\t\t\t\t\t (linenr_T)(oap->end.lnum + 1)) == OK)\n\t\t    block_insert(oap, ins_text, (oap->op_type == OP_INSERT),\n\t\t\t\t\t\t\t\t\t &bd);\n\n\t\tcurwin->w_cursor.col = oap->start.col;\n\t\tcheck_cursor();\n\t\tvim_free(ins_text);\n\t    }\n\t}\n    }\n}\n\n/*\n * op_change - handle a change operation\n *\n * return TRUE if edit() returns because of a CTRL-O command\n */\n    int\nop_change(oparg_T *oap)\n{\n    colnr_T\t\tl;\n    int\t\t\tretval;\n    long\t\toffset;\n    linenr_T\t\tlinenr;\n    long\t\tins_len;\n    long\t\tpre_textlen = 0;\n    long\t\tpre_indent = 0;\n    char_u\t\t*firstline;\n    char_u\t\t*ins_text, *newp, *oldp;\n    struct block_def\tbd;\n\n    l = oap->start.col;\n    if (oap->motion_type == MLINE)\n    {\n\tl = 0;\n#ifdef FEAT_SMARTINDENT\n\tif (!p_paste && curbuf->b_p_si\n# ifdef FEAT_CINDENT\n\t\t&& !curbuf->b_p_cin\n# endif\n\t\t)\n\t    can_si = TRUE;\t// It's like opening a new line, do si\n#endif\n    }\n\n    // First delete the text in the region.  In an empty buffer only need to\n    // save for undo\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return FALSE;\n    }\n    else if (op_delete(oap) == FAIL)\n\treturn FALSE;\n\n    if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t && !virtual_op)\n\tinc_cursor();\n\n    // check for still on same line (<CR> in inserted text meaningless)\n    // skip blank lines too\n    if (oap->block_mode)\n    {\n\t// Add spaces before getting the current line length.\n\tif (virtual_op && (curwin->w_cursor.coladd > 0\n\t\t\t\t\t\t    || gchar_cursor() == NUL))\n\t    coladvance_force(getviscol());\n\tfirstline = ml_get(oap->start.lnum);\n\tpre_textlen = (long)STRLEN(firstline);\n\tpre_indent = (long)getwhitecols(firstline);\n\tbd.textcol = curwin->w_cursor.col;\n    }\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    if (oap->motion_type == MLINE)\n\tfix_indent();\n#endif\n\n    retval = edit(NUL, FALSE, (linenr_T)1);\n\n    /*\n     * In Visual block mode, handle copying the new text to all lines of the\n     * block.\n     * Don't repeat the insert when Insert mode ended with CTRL-C.\n     */\n    if (oap->block_mode && oap->start.lnum != oap->end.lnum && !got_int)\n    {\n\t// Auto-indenting may have changed the indent.  If the cursor was past\n\t// the indent, exclude that indent change from the inserted text.\n\tfirstline = ml_get(oap->start.lnum);\n\tif (bd.textcol > (colnr_T)pre_indent)\n\t{\n\t    long new_indent = (long)getwhitecols(firstline);\n\n\t    pre_textlen += new_indent - pre_indent;\n\t    bd.textcol += new_indent - pre_indent;\n\t}\n\n\tins_len = (long)STRLEN(firstline) - pre_textlen;\n\tif (ins_len > 0)\n\t{\n\t    // Subsequent calls to ml_get() flush the firstline data - take a\n\t    // copy of the inserted text.\n\t    if ((ins_text = alloc(ins_len + 1)) != NULL)\n\t    {\n\t\tvim_strncpy(ins_text, firstline + bd.textcol, (size_t)ins_len);\n\t\tfor (linenr = oap->start.lnum + 1; linenr <= oap->end.lnum;\n\t\t\t\t\t\t\t\t     linenr++)\n\t\t{\n\t\t    block_prep(oap, &bd, linenr, TRUE);\n\t\t    if (!bd.is_short || virtual_op)\n\t\t    {\n\t\t\tpos_T vpos;\n\n\t\t\t// If the block starts in virtual space, count the\n\t\t\t// initial coladd offset as part of \"startspaces\"\n\t\t\tif (bd.is_short)\n\t\t\t{\n\t\t\t    vpos.lnum = linenr;\n\t\t\t    (void)getvpos(&vpos, oap->start_vcol);\n\t\t\t}\n\t\t\telse\n\t\t\t    vpos.coladd = 0;\n\t\t\toldp = ml_get(linenr);\n\t\t\tnewp = alloc(STRLEN(oldp) + vpos.coladd + ins_len + 1);\n\t\t\tif (newp == NULL)\n\t\t\t    continue;\n\t\t\t// copy up to block start\n\t\t\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\t\t\toffset = bd.textcol;\n\t\t\tvim_memset(newp + offset, ' ', (size_t)vpos.coladd);\n\t\t\toffset += vpos.coladd;\n\t\t\tmch_memmove(newp + offset, ins_text, (size_t)ins_len);\n\t\t\toffset += ins_len;\n\t\t\toldp += bd.textcol;\n\t\t\tSTRMOVE(newp + offset, oldp);\n\t\t\tml_replace(linenr, newp, FALSE);\n\t\t    }\n\t\t}\n\t\tcheck_cursor();\n\n\t\tchanged_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\t    }\n\t    vim_free(ins_text);\n\t}\n    }\n    auto_format(FALSE, TRUE);\n\n    return retval;\n}\n\n/*\n * When the cursor is on the NUL past the end of the line and it should not be\n * there move it left.\n */\n    void\nadjust_cursor_eol(void)\n{\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    if (curwin->w_cursor.col > 0\n\t    && gchar_cursor() == NUL\n\t    && (cur_ve_flags & VE_ONEMORE) == 0\n\t    && !(restart_edit || (State & INSERT)))\n    {\n\t// Put the cursor on the last character in the line.\n\tdec_cursor();\n\n\tif (cur_ve_flags == VE_ALL)\n\t{\n\t    colnr_T\t    scol, ecol;\n\n\t    // Coladd is set to the width of the last character.\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol + 1;\n\t}\n    }\n}\n\n/*\n * If \"process\" is TRUE and the line begins with a comment leader (possibly\n * after some white space), return a pointer to the text after it. Put a boolean\n * value indicating whether the line ends with an unclosed comment in\n * \"is_comment\".\n * line - line to be processed,\n * process - if FALSE, will only check whether the line ends with an unclosed\n *\t     comment,\n * include_space - whether to also skip space following the comment leader,\n * is_comment - will indicate whether the current line ends with an unclosed\n *\t\tcomment.\n */\n    char_u *\nskip_comment(\n    char_u   *line,\n    int      process,\n    int\t     include_space,\n    int      *is_comment)\n{\n    char_u *comment_flags = NULL;\n    int    lead_len;\n    int    leader_offset = get_last_leader_offset(line, &comment_flags);\n\n    *is_comment = FALSE;\n    if (leader_offset != -1)\n    {\n\t// Let's check whether the line ends with an unclosed comment.\n\t// If the last comment leader has COM_END in flags, there's no comment.\n\twhile (*comment_flags)\n\t{\n\t    if (*comment_flags == COM_END\n\t\t    || *comment_flags == ':')\n\t\tbreak;\n\t    ++comment_flags;\n\t}\n\tif (*comment_flags != COM_END)\n\t    *is_comment = TRUE;\n    }\n\n    if (process == FALSE)\n\treturn line;\n\n    lead_len = get_leader_len(line, &comment_flags, FALSE, include_space);\n\n    if (lead_len == 0)\n\treturn line;\n\n    // Find:\n    // - COM_END,\n    // - colon,\n    // whichever comes first.\n    while (*comment_flags)\n    {\n\tif (*comment_flags == COM_END\n\t\t|| *comment_flags == ':')\n\t    break;\n\t++comment_flags;\n    }\n\n    // If we found a colon, it means that we are not processing a line\n    // starting with a closing part of a three-part comment. That's good,\n    // because we don't want to remove those as this would be annoying.\n    if (*comment_flags == ':' || *comment_flags == NUL)\n\tline += lead_len;\n\n    return line;\n}\n\n/*\n * Join 'count' lines (minimal 2) at cursor position.\n * When \"save_undo\" is TRUE save lines for undo first.\n * Set \"use_formatoptions\" to FALSE when e.g. processing backspace and comment\n * leaders should not be removed.\n * When setmark is TRUE, sets the '[ and '] mark, else, the caller is expected\n * to set those marks.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_join(\n    long    count,\n    int\t    insert_space,\n    int\t    save_undo,\n    int\t    use_formatoptions UNUSED,\n    int\t    setmark)\n{\n    char_u\t*curr = NULL;\n    char_u      *curr_start = NULL;\n    char_u\t*cend;\n    char_u\t*newp;\n    size_t\tnewp_len;\n    char_u\t*spaces;\t// number of spaces inserted before a line\n    int\t\tendcurr1 = NUL;\n    int\t\tendcurr2 = NUL;\n    int\t\tcurrsize = 0;\t// size of the current line\n    int\t\tsumsize = 0;\t// size of the long new line\n    linenr_T\tt;\n    colnr_T\tcol = 0;\n    int\t\tret = OK;\n    int\t\t*comments = NULL;\n    int\t\tremove_comments = (use_formatoptions == TRUE)\n\t\t\t\t  && has_format_option(FO_REMOVE_COMS);\n    int\t\tprev_was_comment;\n#ifdef FEAT_PROP_POPUP\n    int\t\tpropcount = 0;\t// number of props over all joined lines\n    int\t\tprops_remaining;\n#endif\n\n    if (save_undo && u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t    (linenr_T)(curwin->w_cursor.lnum + count)) == FAIL)\n\treturn FAIL;\n\n    // Allocate an array to store the number of spaces inserted before each\n    // line.  We will use it to pre-compute the length of the new line and the\n    // proper placement of each original line in the new one.\n    spaces = lalloc_clear(count, TRUE);\n    if (spaces == NULL)\n\treturn FAIL;\n    if (remove_comments)\n    {\n\tcomments = lalloc_clear(count * sizeof(int), TRUE);\n\tif (comments == NULL)\n\t{\n\t    vim_free(spaces);\n\t    return FAIL;\n\t}\n    }\n\n    /*\n     * Don't move anything yet, just compute the final line length\n     * and setup the array of space strings lengths\n     * This loops forward over the joined lines.\n     */\n    for (t = 0; t < count; ++t)\n    {\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));\n#ifdef FEAT_PROP_POPUP\n\tpropcount += count_props((linenr_T) (curwin->w_cursor.lnum + t), t > 0);\n#endif\n\tif (t == 0 && setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ mark.\n\t    curwin->w_buffer->b_op_start.lnum = curwin->w_cursor.lnum;\n\t    curwin->w_buffer->b_op_start.col  = (colnr_T)STRLEN(curr);\n\t}\n\tif (remove_comments)\n\t{\n\t    // We don't want to remove the comment leader if the\n\t    // previous line is not a comment.\n\t    if (t > 0 && prev_was_comment)\n\t    {\n\n\t\tchar_u *new_curr = skip_comment(curr, TRUE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t\tcomments[t] = (int)(new_curr - curr);\n\t\tcurr = new_curr;\n\t    }\n\t    else\n\t\tcurr = skip_comment(curr, FALSE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t}\n\n\tif (insert_space && t > 0)\n\t{\n\t    curr = skipwhite(curr);\n\t    if (*curr != NUL && *curr != ')'\n\t\t    && sumsize != 0 && endcurr1 != TAB\n\t\t    && (!has_format_option(FO_MBYTE_JOIN)\n\t\t\t|| (mb_ptr2char(curr) < 0x100 && endcurr1 < 0x100))\n\t\t    && (!has_format_option(FO_MBYTE_JOIN2)\n\t\t\t|| (mb_ptr2char(curr) < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(endcurr1)))\n\t\t\t|| (endcurr1 < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(mb_ptr2char(curr)))))\n\t       )\n\t    {\n\t\t// don't add a space if the line is ending in a space\n\t\tif (endcurr1 == ' ')\n\t\t    endcurr1 = endcurr2;\n\t\telse\n\t\t    ++spaces[t];\n\t\t// extra space when 'joinspaces' set and line ends in '.'\n\t\tif (       p_js\n\t\t\t&& (endcurr1 == '.'\n\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t&& (endcurr1 == '?' || endcurr1 == '!'))))\n\t\t    ++spaces[t];\n\t    }\n\t}\n\tcurrsize = (int)STRLEN(curr);\n\tsumsize += currsize + spaces[t];\n\tendcurr1 = endcurr2 = NUL;\n\tif (insert_space && currsize > 0)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcend = curr + currsize;\n\t\tMB_PTR_BACK(curr, cend);\n\t\tendcurr1 = (*mb_ptr2char)(cend);\n\t\tif (cend > curr)\n\t\t{\n\t\t    MB_PTR_BACK(curr, cend);\n\t\t    endcurr2 = (*mb_ptr2char)(cend);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tendcurr1 = *(curr + currsize - 1);\n\t\tif (currsize > 1)\n\t\t    endcurr2 = *(curr + currsize - 2);\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t{\n\t    ret = FAIL;\n\t    goto theend;\n\t}\n    }\n\n    // store the column position before last line\n    col = sumsize - currsize - spaces[count - 1];\n\n    // allocate the space for the new line\n    newp_len = sumsize + 1;\n#ifdef FEAT_PROP_POPUP\n    newp_len += propcount * sizeof(textprop_T);\n#endif\n    newp = alloc(newp_len);\n    if (newp == NULL)\n    {\n\tret = FAIL;\n\tgoto theend;\n    }\n    cend = newp + sumsize;\n    *cend = 0;\n\n    /*\n     * Move affected lines to the new long one.\n     * This loops backwards over the joined lines, including the original line.\n     *\n     * Move marks from each deleted line to the joined line, adjusting the\n     * column.  This is not Vi compatible, but Vi deletes the marks, thus that\n     * should not really be a problem.\n     */\n#ifdef FEAT_PROP_POPUP\n    props_remaining = propcount;\n#endif\n    for (t = count - 1; ; --t)\n    {\n\tint spaces_removed;\n\n\tcend -= currsize;\n\tmch_memmove(cend, curr, (size_t)currsize);\n\n\tif (spaces[t] > 0)\n\t{\n\t    cend -= spaces[t];\n\t    vim_memset(cend, ' ', (size_t)(spaces[t]));\n\t}\n\n\t// If deleting more spaces than adding, the cursor moves no more than\n\t// what is added if it is inside these spaces.\n\tspaces_removed = (curr - curr_start) - spaces[t];\n\n\tmark_col_adjust(curwin->w_cursor.lnum + t, (colnr_T)0, (linenr_T)-t,\n\t\t\t (long)(cend - newp - spaces_removed), spaces_removed);\n#ifdef FEAT_PROP_POPUP\n\tprepend_joined_props(newp + sumsize + 1, propcount, &props_remaining,\n\t\tcurwin->w_cursor.lnum + t, t == count - 1,\n\t\t(long)(cend - newp), spaces_removed);\n#endif\n\n\tif (t == 0)\n\t    break;\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));\n\tif (remove_comments)\n\t    curr += comments[t - 1];\n\tif (insert_space && t > 1)\n\t    curr = skipwhite(curr);\n\tcurrsize = (int)STRLEN(curr);\n    }\n\n    ml_replace_len(curwin->w_cursor.lnum, newp, (colnr_T)newp_len, TRUE, FALSE);\n\n    if (setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set the '] mark.\n\tcurwin->w_buffer->b_op_end.lnum = curwin->w_cursor.lnum;\n\tcurwin->w_buffer->b_op_end.col  = (colnr_T)sumsize;\n    }\n\n    // Only report the change in the first line here, del_lines() will report\n    // the deleted line.\n    changed_lines(curwin->w_cursor.lnum, currsize,\n\t\t\t\t\t       curwin->w_cursor.lnum + 1, 0L);\n    /*\n     * Delete following lines. To do this we move the cursor there\n     * briefly, and then move it back. After del_lines() the cursor may\n     * have moved up (last line deleted), so the current lnum is kept in t.\n     */\n    t = curwin->w_cursor.lnum;\n    ++curwin->w_cursor.lnum;\n    del_lines(count - 1, FALSE);\n    curwin->w_cursor.lnum = t;\n\n    /*\n     * Set the cursor column:\n     * Vi compatible: use the column of the first join\n     * vim:\t      use the column of the last join\n     */\n    curwin->w_cursor.col =\n\t\t    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);\n    check_cursor_col();\n\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n\ntheend:\n    vim_free(spaces);\n    if (remove_comments)\n\tvim_free(comments);\n    return ret;\n}\n\n/*\n * prepare a few things for block mode yank/delete/tilde\n *\n * for delete:\n * - textlen includes the first/last char to be (partly) deleted\n * - start/endspaces is the number of columns that are taken by the\n *   first/last deleted char minus the number of columns that have to be\n *   deleted.\n * for yank and tilde:\n * - textlen includes the first/last char to be wholly yanked\n * - start/endspaces is the number of columns of the first/last yanked char\n *   that are to be yanked.\n */\n    void\nblock_prep(\n    oparg_T\t\t*oap,\n    struct block_def\t*bdp,\n    linenr_T\t\tlnum,\n    int\t\t\tis_del)\n{\n    int\t\tincr = 0;\n    char_u\t*pend;\n    char_u\t*pstart;\n    char_u\t*line;\n    char_u\t*prev_pstart;\n    char_u\t*prev_pend;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n\n    // Avoid a problem with unwanted linebreaks in block mode.\n    curwin->w_p_lbr = FALSE;\n#endif\n    bdp->startspaces = 0;\n    bdp->endspaces = 0;\n    bdp->textlen = 0;\n    bdp->start_vcol = 0;\n    bdp->end_vcol = 0;\n    bdp->is_short = FALSE;\n    bdp->is_oneChar = FALSE;\n    bdp->pre_whitesp = 0;\n    bdp->pre_whitesp_c = 0;\n    bdp->end_char_vcols = 0;\n    bdp->start_char_vcols = 0;\n\n    line = ml_get(lnum);\n    pstart = line;\n    prev_pstart = line;\n    while (bdp->start_vcol < oap->start_vcol && *pstart)\n    {\n\t// Count a tab for what it's worth (if list mode not on)\n\tincr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);\n\tbdp->start_vcol += incr;\n\tif (VIM_ISWHITE(*pstart))\n\t{\n\t    bdp->pre_whitesp += incr;\n\t    bdp->pre_whitesp_c++;\n\t}\n\telse\n\t{\n\t    bdp->pre_whitesp = 0;\n\t    bdp->pre_whitesp_c = 0;\n\t}\n\tprev_pstart = pstart;\n\tMB_PTR_ADV(pstart);\n    }\n    bdp->start_char_vcols = incr;\n    if (bdp->start_vcol < oap->start_vcol)\t// line too short\n    {\n\tbdp->end_vcol = bdp->start_vcol;\n\tbdp->is_short = TRUE;\n\tif (!is_del || oap->op_type == OP_APPEND)\n\t    bdp->endspaces = oap->end_vcol - oap->start_vcol + 1;\n    }\n    else\n    {\n\t// notice: this converts partly selected Multibyte characters to\n\t// spaces, too.\n\tbdp->startspaces = bdp->start_vcol - oap->start_vcol;\n\tif (is_del && bdp->startspaces)\n\t    bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;\n\tpend = pstart;\n\tbdp->end_vcol = bdp->start_vcol;\n\tif (bdp->end_vcol > oap->end_vcol)\t// it's all in one character\n\t{\n\t    bdp->is_oneChar = TRUE;\n\t    if (oap->op_type == OP_INSERT)\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    else if (oap->op_type == OP_APPEND)\n\t    {\n\t\tbdp->startspaces += oap->end_vcol - oap->start_vcol + 1;\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    }\n\t    else\n\t    {\n\t\tbdp->startspaces = oap->end_vcol - oap->start_vcol + 1;\n\t\tif (is_del && oap->op_type != OP_LSHIFT)\n\t\t{\n\t\t    // just putting the sum of those two into\n\t\t    // bdp->startspaces doesn't work for Visual replace,\n\t\t    // so we have to split the tab in two\n\t\t    bdp->startspaces = bdp->start_char_vcols\n\t\t\t\t\t- (bdp->start_vcol - oap->start_vcol);\n\t\t    bdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    prev_pend = pend;\n\t    while (bdp->end_vcol <= oap->end_vcol && *pend != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tprev_pend = pend;\n\t\tincr = lbr_chartabsize_adv(line, &pend, (colnr_T)bdp->end_vcol);\n\t\tbdp->end_vcol += incr;\n\t    }\n\t    if (bdp->end_vcol <= oap->end_vcol\n\t\t    && (!is_del\n\t\t\t|| oap->op_type == OP_APPEND\n\t\t\t|| oap->op_type == OP_REPLACE)) // line too short\n\t    {\n\t\tbdp->is_short = TRUE;\n\t\t// Alternative: include spaces to fill up the block.\n\t\t// Disadvantage: can lead to trailing spaces when the line is\n\t\t// short where the text is put\n\t\t// if (!is_del || oap->op_type == OP_APPEND)\n\t\tif (oap->op_type == OP_APPEND || virtual_op)\n\t\t    bdp->endspaces = oap->end_vcol - bdp->end_vcol\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\telse\n\t\t    bdp->endspaces = 0; // replace doesn't add characters\n\t    }\n\t    else if (bdp->end_vcol > oap->end_vcol)\n\t    {\n\t\tbdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\tif (!is_del && bdp->endspaces)\n\t\t{\n\t\t    bdp->endspaces = incr - bdp->endspaces;\n\t\t    if (pend != pstart)\n\t\t\tpend = prev_pend;\n\t\t}\n\t    }\n\t}\n\tbdp->end_char_vcols = incr;\n\tif (is_del && bdp->startspaces)\n\t    pstart = prev_pstart;\n\tbdp->textlen = (int)(pend - pstart);\n    }\n    bdp->textcol = (colnr_T) (pstart - line);\n    bdp->textstart = pstart;\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n\n/*\n * Handle the add/subtract operator.\n */\n    void\nop_addsub(\n    oparg_T\t*oap,\n    linenr_T\tPrenum1,\t    // Amount of add/subtract\n    int\t\tg_cmd)\t\t    // was g<c-a>/g<c-x>\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tchange_cnt = 0;\n    linenr_T\t\tamount = Prenum1;\n\n   // do_addsub() might trigger re-evaluation of 'foldexpr' halfway, when the\n   // buffer is not completely updated yet. Postpone updating folds until before\n   // the call to changed_lines().\n#ifdef FEAT_FOLDING\n   disable_fold_update++;\n#endif\n\n    if (!VIsual_active)\n    {\n\tpos = curwin->w_cursor;\n\tif (u_save_cursor() == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\tchange_cnt = do_addsub(oap->op_type, &pos, 0, amount);\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(pos.lnum, 0, pos.lnum + 1, 0L);\n    }\n    else\n    {\n\tint\tone_change;\n\tint\tlength;\n\tpos_T\tstartpos;\n\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t\t(linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\n\tpos = oap->start;\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    if (oap->block_mode)\t\t    // Visual block mode\n\t    {\n\t\tblock_prep(oap, &bd, pos.lnum, FALSE);\n\t\tpos.col = bd.textcol;\n\t\tlength = bd.textlen;\n\t    }\n\t    else if (oap->motion_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tpos.col = 0;\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t    }\n\t    else // oap->motion_type == MCHAR\n\t    {\n\t\tif (pos.lnum == oap->start.lnum && !oap->inclusive)\n\t\t    dec(&(oap->end));\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t\tpos.col = 0;\n\t\tif (pos.lnum == oap->start.lnum)\n\t\t{\n\t\t    pos.col += oap->start.col;\n\t\t    length -= oap->start.col;\n\t\t}\n\t\tif (pos.lnum == oap->end.lnum)\n\t\t{\n\t\t    length = (int)STRLEN(ml_get(oap->end.lnum));\n\t\t    if (oap->end.col >= length)\n\t\t\toap->end.col = length - 1;\n\t\t    length = oap->end.col - pos.col + 1;\n\t\t}\n\t    }\n\t    one_change = do_addsub(oap->op_type, &pos, length, amount);\n\t    if (one_change)\n\t    {\n\t\t// Remember the start position of the first change.\n\t\tif (change_cnt == 0)\n\t\t    startpos = curbuf->b_op_start;\n\t\t++change_cnt;\n\t    }\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr;\n\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)length);\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t&ptr[pos.col], length);\n\t    }\n#endif\n\t    if (g_cmd && one_change)\n\t\tamount += Prenum1;\n\t}\n\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n\n\tif (!change_cnt && oap->is_VIsual)\n\t    // No change: need to remove the Visual selection\n\t    redraw_curbuf_later(INVERTED);\n\n\t// Set '[ mark if something changed. Keep the last end\n\t// position from do_addsub().\n\tif (change_cnt > 0 && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t    curbuf->b_op_start = startpos;\n\n\tif (change_cnt > p_report)\n\t    smsg(NGETTEXT(\"%d line changed\", \"%d lines changed\",\n\t\t\t\t\t\t      change_cnt), change_cnt);\n    }\n}\n\n/*\n * Add or subtract 'Prenum1' from a number in a line\n * op_type is OP_NR_ADD or OP_NR_SUB\n *\n * Returns TRUE if some character was changed.\n */\n    static int\ndo_addsub(\n    int\t\top_type,\n    pos_T\t*pos,\n    int\t\tlength,\n    linenr_T\tPrenum1)\n{\n    int\t\tcol;\n    char_u\t*buf1;\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tpre;\t\t// 'X'/'x': hex; '0': octal; 'B'/'b': bin\n    static int\thexupper = FALSE;\t// 0xABC\n    uvarnumber_T\tn;\n    uvarnumber_T\toldn;\n    char_u\t*ptr;\n    int\t\tc;\n    int\t\ttodel;\n    int\t\tdo_hex;\n    int\t\tdo_oct;\n    int\t\tdo_bin;\n    int\t\tdo_alpha;\n    int\t\tdo_unsigned;\n    int\t\tfirstdigit;\n    int\t\tsubtract;\n    int\t\tnegative = FALSE;\n    int\t\twas_positive = TRUE;\n    int\t\tvisual = VIsual_active;\n    int\t\tdid_change = FALSE;\n    pos_T\tsave_cursor = curwin->w_cursor;\n    int\t\tmaxlen = 0;\n    pos_T\tstartpos;\n    pos_T\tendpos;\n    colnr_T\tsave_coladd = 0;\n\n    do_hex = (vim_strchr(curbuf->b_p_nf, 'x') != NULL);\t// \"heX\"\n    do_oct = (vim_strchr(curbuf->b_p_nf, 'o') != NULL);\t// \"Octal\"\n    do_bin = (vim_strchr(curbuf->b_p_nf, 'b') != NULL);\t// \"Bin\"\n    do_alpha = (vim_strchr(curbuf->b_p_nf, 'p') != NULL);\t// \"alPha\"\n    do_unsigned = (vim_strchr(curbuf->b_p_nf, 'u') != NULL);\t// \"Unsigned\"\n\n    if (virtual_active())\n    {\n\tsave_coladd = pos->coladd;\n\tpos->coladd = 0;\n    }\n\n    curwin->w_cursor = *pos;\n    ptr = ml_get(pos->lnum);\n    col = pos->col;\n\n    if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr))\n\tgoto theend;\n\n    /*\n     * First check if we are on a hexadecimal number, after the \"0x\".\n     */\n    if (!VIsual_active)\n    {\n\tif (do_bin)\n\t    while (col > 0 && vim_isbdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (do_hex)\n\t    while (col > 0 && vim_isxdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (       do_bin\n\t\t&& do_hex\n\t\t&& ! ((col > 0\n\t\t    && (ptr[col] == 'X'\n\t\t\t|| ptr[col] == 'x')\n\t\t    && ptr[col - 1] == '0'\n\t\t    && (!has_mbyte ||\n\t\t\t!(*mb_head_off)(ptr, ptr + col - 1))\n\t\t    && vim_isxdigit(ptr[col + 1]))))\n\t{\n\n\t    // In case of binary/hexadecimal pattern overlap match, rescan\n\n\t    col = pos->col;\n\n\t    while (col > 0 && vim_isdigit(ptr[col]))\n\t    {\n\t\tcol--;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n\n\tif ((       do_hex\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'X'\n\t\t    || ptr[col] == 'x')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isxdigit(ptr[col + 1])) ||\n\t    (       do_bin\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'B'\n\t\t    || ptr[col] == 'b')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isbdigit(ptr[col + 1])))\n\t{\n\t    // Found hexadecimal or binary number, move to its start.\n\t    --col;\n\t    if (has_mbyte)\n\t\tcol -= (*mb_head_off)(ptr, ptr + col);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Search forward and then backward to find the start of number.\n\t     */\n\t    col = pos->col;\n\n\t    while (ptr[col] != NUL\n\t\t    && !vim_isdigit(ptr[col])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t\tcol += mb_ptr2len(ptr + col);\n\n\t    while (col > 0\n\t\t    && vim_isdigit(ptr[col - 1])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n    }\n\n    if (visual)\n    {\n\twhile (ptr[col] != NUL && length > 0\n\t\t&& !vim_isdigit(ptr[col])\n\t\t&& !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t{\n\t    int mb_len = mb_ptr2len(ptr + col);\n\n\t    col += mb_len;\n\t    length -= mb_len;\n\t}\n\n\tif (length == 0)\n\t    goto theend;\n\n\tif (col > pos->col && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !do_unsigned)\n\t{\n\t    negative = TRUE;\n\t    was_positive = FALSE;\n\t}\n    }\n\n    /*\n     * If a number was found, and saving for undo works, replace the number.\n     */\n    firstdigit = ptr[col];\n    if (!VIM_ISDIGIT(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit)))\n    {\n\tbeep_flush();\n\tgoto theend;\n    }\n\n    if (do_alpha && ASCII_ISALPHA(firstdigit))\n    {\n\t// decrement or increment alphabetic character\n\tif (op_type == OP_NR_SUB)\n\t{\n\t    if (CharOrd(firstdigit) < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'A';\n\t\telse\n\t\t    firstdigit = 'a';\n\t    }\n\t    else\n#ifdef EBCDIC\n\t\tfirstdigit = EBCDIC_CHAR_ADD(firstdigit, -Prenum1);\n#else\n\t\tfirstdigit -= Prenum1;\n#endif\n\t}\n\telse\n\t{\n\t    if (26 - CharOrd(firstdigit) - 1 < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'Z';\n\t\telse\n\t\t    firstdigit = 'z';\n\t    }\n\t    else\n#ifdef EBCDIC\n\t\tfirstdigit = EBCDIC_CHAR_ADD(firstdigit, Prenum1);\n#else\n\t\tfirstdigit += Prenum1;\n#endif\n\t}\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\t(void)del_char(FALSE);\n\tins_char(firstdigit);\n\tendpos = curwin->w_cursor;\n\tcurwin->w_cursor.col = col;\n    }\n    else\n    {\n\tpos_T\tsave_pos;\n\tint\ti;\n\n\tif (col > 0 && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !visual\n\t\t&& !do_unsigned)\n\t{\n\t    // negative number\n\t    --col;\n\t    negative = TRUE;\n\t}\n\t// get the number value (unsigned)\n\tif (visual && VIsual_mode != 'V')\n\t    maxlen = (curbuf->b_visual.vi_curswant == MAXCOL\n\t\t    ? (int)STRLEN(ptr) - col\n\t\t    : length);\n\n\tvim_str2nr(ptr + col, &pre, &length,\n\t\t0 + (do_bin ? STR2NR_BIN : 0)\n\t\t    + (do_oct ? STR2NR_OCT : 0)\n\t\t    + (do_hex ? STR2NR_HEX : 0),\n\t\tNULL, &n, maxlen, FALSE);\n\n\t// ignore leading '-' for hex and octal and bin numbers\n\tif (pre && negative)\n\t{\n\t    ++col;\n\t    --length;\n\t    negative = FALSE;\n\t}\n\t// add or subtract\n\tsubtract = FALSE;\n\tif (op_type == OP_NR_SUB)\n\t    subtract ^= TRUE;\n\tif (negative)\n\t    subtract ^= TRUE;\n\n\toldn = n;\n\tif (subtract)\n\t    n -= (uvarnumber_T)Prenum1;\n\telse\n\t    n += (uvarnumber_T)Prenum1;\n\t// handle wraparound for decimal numbers\n\tif (!pre)\n\t{\n\t    if (subtract)\n\t    {\n\t\tif (n > oldn)\n\t\t{\n\t\t    n = 1 + (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// add\n\t\tif (n < oldn)\n\t\t{\n\t\t    n = (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    if (n == 0)\n\t\tnegative = FALSE;\n\t}\n\n\tif (do_unsigned && negative)\n\t{\n\t    if (subtract)\n\t\t// sticking at zero.\n\t\tn = (uvarnumber_T)0;\n\t    else\n\t\t// sticking at 2^64 - 1.\n\t\tn = (uvarnumber_T)(-1);\n\t    negative = FALSE;\n\t}\n\n\tif (visual && !was_positive && !negative && col > 0)\n\t{\n\t    // need to remove the '-'\n\t    col--;\n\t    length++;\n\t}\n\n\t/*\n\t * Delete the old number.\n\t */\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\ttodel = length;\n\tc = gchar_cursor();\n\t/*\n\t * Don't include the '-' in the length, only the length of the\n\t * part after it is kept the same.\n\t */\n\tif (c == '-')\n\t    --length;\n\n\tsave_pos = curwin->w_cursor;\n\tfor (i = 0; i < todel; ++i)\n\t{\n\t    if (c < 0x100 && isalpha(c))\n\t    {\n\t\tif (isupper(c))\n\t\t    hexupper = TRUE;\n\t\telse\n\t\t    hexupper = FALSE;\n\t    }\n\t    inc_cursor();\n\t    c = gchar_cursor();\n\t}\n\tcurwin->w_cursor = save_pos;\n\n\t/*\n\t * Prepare the leading characters in buf1[].\n\t * When there are many leading zeros it could be very long.\n\t * Allocate a bit too much.\n\t */\n\tbuf1 = alloc(length + NUMBUFLEN);\n\tif (buf1 == NULL)\n\t    goto theend;\n\tptr = buf1;\n\tif (negative && (!visual || was_positive))\n\t    *ptr++ = '-';\n\tif (pre)\n\t{\n\t    *ptr++ = '0';\n\t    --length;\n\t}\n\tif (pre == 'b' || pre == 'B' ||\n\t    pre == 'x' || pre == 'X')\n\t{\n\t    *ptr++ = pre;\n\t    --length;\n\t}\n\n\t/*\n\t * Put the number characters in buf2[].\n\t */\n\tif (pre == 'b' || pre == 'B')\n\t{\n\t    int bit = 0;\n\t    int bits = sizeof(uvarnumber_T) * 8;\n\n\t    // leading zeros\n\t    for (bit = bits; bit > 0; bit--)\n\t\tif ((n >> (bit - 1)) & 0x1) break;\n\n\t    for (i = 0; bit > 0; bit--)\n\t\tbuf2[i++] = ((n >> (bit - 1)) & 0x1) ? '1' : '0';\n\n\t    buf2[i] = '\\0';\n\t}\n\telse if (pre == 0)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llu\", (uvarnumber_T)n);\n\telse if (pre == '0')\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llo\", (uvarnumber_T)n);\n\telse if (pre && hexupper)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llX\", (uvarnumber_T)n);\n\telse\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llx\", (uvarnumber_T)n);\n\tlength -= (int)STRLEN(buf2);\n\n\t/*\n\t * Adjust number of zeros to the new number of digits, so the\n\t * total length of the number remains the same.\n\t * Don't do this when\n\t * the result may look like an octal number.\n\t */\n\tif (firstdigit == '0' && !(do_oct && pre == 0))\n\t    while (length-- > 0)\n\t\t*ptr++ = '0';\n\t*ptr = NUL;\n\n\tSTRCAT(buf1, buf2);\n\n\t// Insert just after the first character to be removed, so that any\n\t// text properties will be adjusted.  Then delete the old number\n\t// afterwards.\n\tsave_pos = curwin->w_cursor;\n\tif (todel > 0)\n\t    inc_cursor();\n\tins_str(buf1);\t\t// insert the new number\n\tvim_free(buf1);\n\n\t// del_char() will also mark line needing displaying\n\tif (todel > 0)\n\t{\n\t    int bytes_after = (int)STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t- curwin->w_cursor.col;\n\n\t    // Delete the one character before the insert.\n\t    curwin->w_cursor = save_pos;\n\t    (void)del_char(FALSE);\n\t    curwin->w_cursor.col = (colnr_T)(STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t\t- bytes_after);\n\t    --todel;\n\t}\n\twhile (todel-- > 0)\n\t    (void)del_char(FALSE);\n\n\tendpos = curwin->w_cursor;\n\tif (did_change && curwin->w_cursor.col)\n\t    --curwin->w_cursor.col;\n    }\n\n    if (did_change && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set the '[ and '] marks\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = endpos;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n\ntheend:\n    if (visual)\n\tcurwin->w_cursor = save_cursor;\n    else if (did_change)\n\tcurwin->w_set_curswant = TRUE;\n    else if (virtual_active())\n\tcurwin->w_cursor.coladd = save_coladd;\n\n    return did_change;\n}\n\n    void\nclear_oparg(oparg_T *oap)\n{\n    CLEAR_POINTER(oap);\n}\n\n/*\n *  Count the number of bytes, characters and \"words\" in a line.\n *\n *  \"Words\" are counted by looking for boundaries between non-space and\n *  space characters.  (it seems to produce results that match 'wc'.)\n *\n *  Return value is byte count; word count for the line is added to \"*wc\".\n *  Char count is added to \"*cc\".\n *\n *  The function will only examine the first \"limit\" characters in the\n *  line, stopping if it encounters an end-of-line (NUL byte).  In that\n *  case, eol_size will be added to the character count to account for\n *  the size of the EOL character.\n */\n    static varnumber_T\nline_count_info(\n    char_u\t*line,\n    varnumber_T\t*wc,\n    varnumber_T\t*cc,\n    varnumber_T\tlimit,\n    int\t\teol_size)\n{\n    varnumber_T\ti;\n    varnumber_T\twords = 0;\n    varnumber_T\tchars = 0;\n    int\t\tis_word = 0;\n\n    for (i = 0; i < limit && line[i] != NUL; )\n    {\n\tif (is_word)\n\t{\n\t    if (vim_isspace(line[i]))\n\t    {\n\t\twords++;\n\t\tis_word = 0;\n\t    }\n\t}\n\telse if (!vim_isspace(line[i]))\n\t    is_word = 1;\n\t++chars;\n\ti += (*mb_ptr2len)(line + i);\n    }\n\n    if (is_word)\n\twords++;\n    *wc += words;\n\n    // Add eol_size if the end of line was reached before hitting limit.\n    if (i < limit && line[i] == NUL)\n    {\n\ti += eol_size;\n\tchars += eol_size;\n    }\n    *cc += chars;\n    return i;\n}\n\n/*\n * Give some info about the position of the cursor (for \"g CTRL-G\").\n * In Visual mode, give some info about the selected region.  (In this case,\n * the *_count_cursor variables store running totals for the selection.)\n * When \"dict\" is not NULL store the info there instead of showing it.\n */\n    void\ncursor_pos_info(dict_T *dict)\n{\n    char_u\t*p;\n    char_u\tbuf1[50];\n    char_u\tbuf2[40];\n    linenr_T\tlnum;\n    varnumber_T\tbyte_count = 0;\n    varnumber_T\tbom_count  = 0;\n    varnumber_T\tbyte_count_cursor = 0;\n    varnumber_T\tchar_count = 0;\n    varnumber_T\tchar_count_cursor = 0;\n    varnumber_T\tword_count = 0;\n    varnumber_T\tword_count_cursor = 0;\n    int\t\teol_size;\n    varnumber_T\tlast_check = 100000L;\n    long\tline_count_selected = 0;\n    pos_T\tmin_pos, max_pos;\n    oparg_T\toparg;\n    struct block_def\tbd;\n\n    /*\n     * Compute the length of the file in characters.\n     */\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (dict == NULL)\n\t{\n\t    msg(_(no_lines_msg));\n\t    return;\n\t}\n    }\n    else\n    {\n\tif (get_fileformat(curbuf) == EOL_DOS)\n\t    eol_size = 2;\n\telse\n\t    eol_size = 1;\n\n\tif (VIsual_active)\n\t{\n\t    if (LT_POS(VIsual, curwin->w_cursor))\n\t    {\n\t\tmin_pos = VIsual;\n\t\tmax_pos = curwin->w_cursor;\n\t    }\n\t    else\n\t    {\n\t\tmin_pos = curwin->w_cursor;\n\t\tmax_pos = VIsual;\n\t    }\n\t    if (*p_sel == 'e' && max_pos.col > 0)\n\t\t--max_pos.col;\n\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tchar_u * saved_sbr = p_sbr;\n\t\tchar_u * saved_w_sbr = curwin->w_p_sbr;\n\n\t\t// Make 'sbr' empty for a moment to get the correct size.\n\t\tp_sbr = empty_option;\n\t\tcurwin->w_p_sbr = empty_option;\n#endif\n\t\toparg.is_VIsual = 1;\n\t\toparg.block_mode = TRUE;\n\t\toparg.op_type = OP_NOP;\n\t\tgetvcols(curwin, &min_pos, &max_pos,\n\t\t\t\t\t  &oparg.start_vcol, &oparg.end_vcol);\n#ifdef FEAT_LINEBREAK\n\t\tp_sbr = saved_sbr;\n\t\tcurwin->w_p_sbr = saved_w_sbr;\n#endif\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    oparg.end_vcol = MAXCOL;\n\t\t// Swap the start, end vcol if needed\n\t\tif (oparg.end_vcol < oparg.start_vcol)\n\t\t{\n\t\t    oparg.end_vcol += oparg.start_vcol;\n\t\t    oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;\n\t\t    oparg.end_vcol -= oparg.start_vcol;\n\t\t}\n\t    }\n\t    line_count_selected = max_pos.lnum - min_pos.lnum + 1;\n\t}\n\n\tfor (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t{\n\t    // Check for a CTRL-C every 100000 characters.\n\t    if (byte_count > last_check)\n\t    {\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t    return;\n\t\tlast_check = byte_count + 100000L;\n\t    }\n\n\t    // Do extra processing for VIsual mode.\n\t    if (VIsual_active\n\t\t    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)\n\t    {\n\t\tchar_u\t    *s = NULL;\n\t\tlong\t    len = 0L;\n\n\t\tswitch (VIsual_mode)\n\t\t{\n\t\t    case Ctrl_V:\n\t\t\tvirtual_op = virtual_active();\n\t\t\tblock_prep(&oparg, &bd, lnum, 0);\n\t\t\tvirtual_op = MAYBE;\n\t\t\ts = bd.textstart;\n\t\t\tlen = (long)bd.textlen;\n\t\t\tbreak;\n\t\t    case 'V':\n\t\t\ts = ml_get(lnum);\n\t\t\tlen = MAXCOL;\n\t\t\tbreak;\n\t\t    case 'v':\n\t\t\t{\n\t\t\t    colnr_T start_col = (lnum == min_pos.lnum)\n\t\t\t\t\t\t\t   ? min_pos.col : 0;\n\t\t\t    colnr_T end_col = (lnum == max_pos.lnum)\n\t\t\t\t      ? max_pos.col - start_col + 1 : MAXCOL;\n\n\t\t\t    s = ml_get(lnum) + start_col;\n\t\t\t    len = end_col;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (s != NULL)\n\t\t{\n\t\t    byte_count_cursor += line_count_info(s, &word_count_cursor,\n\t\t\t\t\t   &char_count_cursor, len, eol_size);\n\t\t    if (lnum == curbuf->b_ml.ml_line_count\n\t\t\t    && !curbuf->b_p_eol\n\t\t\t    && (curbuf->b_p_bin || !curbuf->b_p_fixeol)\n\t\t\t    && (long)STRLEN(s) < len)\n\t\t\tbyte_count_cursor -= eol_size;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// In non-visual mode, check for the line the cursor is on\n\t\tif (lnum == curwin->w_cursor.lnum)\n\t\t{\n\t\t    word_count_cursor += word_count;\n\t\t    char_count_cursor += char_count;\n\t\t    byte_count_cursor = byte_count +\n\t\t\tline_count_info(ml_get(lnum),\n\t\t\t\t&word_count_cursor, &char_count_cursor,\n\t\t\t\t(varnumber_T)(curwin->w_cursor.col + 1),\n\t\t\t\teol_size);\n\t\t}\n\t    }\n\t    // Add to the running totals\n\t    byte_count += line_count_info(ml_get(lnum), &word_count,\n\t\t\t\t\t &char_count, (varnumber_T)MAXCOL,\n\t\t\t\t\t eol_size);\n\t}\n\n\t// Correction for when last line doesn't have an EOL.\n\tif (!curbuf->b_p_eol && (curbuf->b_p_bin || !curbuf->b_p_fixeol))\n\t    byte_count -= eol_size;\n\n\tif (dict == NULL)\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)\n\t\t{\n\t\t    getvcols(curwin, &min_pos, &max_pos, &min_pos.col,\n\t\t\t\t\t\t\t\t    &max_pos.col);\n\t\t    vim_snprintf((char *)buf1, sizeof(buf1), _(\"%ld Cols; \"),\n\t\t\t    (long)(oparg.end_vcol - oparg.start_vcol + 1));\n\t\t}\n\t\telse\n\t\t    buf1[0] = NUL;\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t\t\t\t    && char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    (varnumber_T)word_count_cursor,\n\t\t\t    (varnumber_T)word_count,\n\t\t\t    (varnumber_T)byte_count_cursor,\n\t\t\t    (varnumber_T)byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Chars; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    (varnumber_T)word_count_cursor,\n\t\t\t    (varnumber_T)word_count,\n\t\t\t    (varnumber_T)char_count_cursor,\n\t\t\t    (varnumber_T)char_count,\n\t\t\t    (varnumber_T)byte_count_cursor,\n\t\t\t    (varnumber_T)byte_count);\n\t    }\n\t    else\n\t    {\n\t\tp = ml_get_curline();\n\t\tvalidate_virtcol();\n\t\tcol_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,\n\t\t\t(int)curwin->w_virtcol + 1);\n\t\tcol_print(buf2, sizeof(buf2), (int)STRLEN(p),\n\t\t\t\t    linetabsize(p));\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t&& char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\t(varnumber_T)word_count_cursor, (varnumber_T)word_count,\n\t\t\t(varnumber_T)byte_count_cursor, (varnumber_T)byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Char %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\t(varnumber_T)word_count_cursor, (varnumber_T)word_count,\n\t\t\t(varnumber_T)char_count_cursor, (varnumber_T)char_count,\n\t\t\t(varnumber_T)byte_count_cursor, (varnumber_T)byte_count);\n\t    }\n\t}\n\n\tbom_count = bomb_size();\n\tif (dict == NULL && bom_count > 0)\n\t{\n\t    size_t len = STRLEN(IObuff);\n\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t\t _(\"(+%lld for BOM)\"), (varnumber_T)bom_count);\n\t}\n\tif (dict == NULL)\n\t{\n\t    // Don't shorten this message, the user asked for it.\n\t    p = p_shm;\n\t    p_shm = (char_u *)\"\";\n\t    msg((char *)IObuff);\n\t    p_shm = p;\n\t}\n    }\n#if defined(FEAT_EVAL)\n    if (dict != NULL)\n    {\n\tdict_add_number(dict, \"words\", word_count);\n\tdict_add_number(dict, \"chars\", char_count);\n\tdict_add_number(dict, \"bytes\", byte_count + bom_count);\n\tdict_add_number(dict, VIsual_active ? \"visual_bytes\" : \"cursor_bytes\",\n\t\tbyte_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_chars\" : \"cursor_chars\",\n\t\tchar_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_words\" : \"cursor_words\",\n\t\tword_count_cursor);\n    }\n#endif\n}\n\n/*\n * Handle indent and format operators and visual mode \":\".\n */\n    static void\nop_colon(oparg_T *oap)\n{\n    stuffcharReadbuff(':');\n    if (oap->is_VIsual)\n\tstuffReadbuff((char_u *)\"'<,'>\");\n    else\n    {\n\t// Make the range look nice, so it can be repeated.\n\tif (oap->start.lnum == curwin->w_cursor.lnum)\n\t    stuffcharReadbuff('.');\n\telse\n\t    stuffnumReadbuff((long)oap->start.lnum);\n\tif (oap->end.lnum != oap->start.lnum)\n\t{\n\t    stuffcharReadbuff(',');\n\t    if (oap->end.lnum == curwin->w_cursor.lnum)\n\t\tstuffcharReadbuff('.');\n\t    else if (oap->end.lnum == curbuf->b_ml.ml_line_count)\n\t\tstuffcharReadbuff('$');\n\t    else if (oap->start.lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tstuffReadbuff((char_u *)\".+\");\n\t\tstuffnumReadbuff((long)oap->line_count - 1);\n\t    }\n\t    else\n\t\tstuffnumReadbuff((long)oap->end.lnum);\n\t}\n    }\n    if (oap->op_type != OP_COLON)\n\tstuffReadbuff((char_u *)\"!\");\n    if (oap->op_type == OP_INDENT)\n    {\n#ifndef FEAT_CINDENT\n\tif (*get_equalprg() == NUL)\n\t    stuffReadbuff((char_u *)\"indent\");\n\telse\n#endif\n\t    stuffReadbuff(get_equalprg());\n\tstuffReadbuff((char_u *)\"\\n\");\n    }\n    else if (oap->op_type == OP_FORMAT)\n    {\n\tif (*curbuf->b_p_fp != NUL)\n\t    stuffReadbuff(curbuf->b_p_fp);\n\telse if (*p_fp != NUL)\n\t    stuffReadbuff(p_fp);\n\telse\n\t    stuffReadbuff((char_u *)\"fmt\");\n\tstuffReadbuff((char_u *)\"\\n']\");\n    }\n\n    // do_cmdline() does the rest\n}\n\n// callback function for 'operatorfunc'\nstatic callback_T opfunc_cb;\n\n/*\n * Process the 'operatorfunc' option value.\n * Returns OK or FAIL.\n */\n    int\nset_operatorfunc_option(void)\n{\n    return option_set_callback_func(p_opfunc, &opfunc_cb);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_operatorfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&opfunc_cb);\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'operatorfunc' callback with 'copyID' so that it is not\n * garbage collected.\n */\n    int\nset_ref_in_opfunc(int copyID UNUSED)\n{\n    int abort = FALSE;\n\n    abort = set_ref_in_callback(&opfunc_cb, copyID);\n\n    return abort;\n}\n#endif\n\n/*\n * Handle the \"g@\" operator: call 'operatorfunc'.\n */\n    static void\nop_function(oparg_T *oap UNUSED)\n{\n#ifdef FEAT_EVAL\n    typval_T\targv[2];\n    int\t\tsave_virtual_op = virtual_op;\n    int\t\tsave_finish_op = finish_op;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    typval_T\trettv;\n\n    if (*p_opfunc == NUL)\n\temsg(_(e_operatorfunc_is_empty));\n    else\n    {\n\t// Set '[ and '] marks to text to be operated on.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (oap->motion_type != MLINE && !oap->inclusive)\n\t    // Exclude the end position.\n\t    decl(&curbuf->b_op_end);\n\n\targv[0].v_type = VAR_STRING;\n\tif (oap->block_mode)\n\t    argv[0].vval.v_string = (char_u *)\"block\";\n\telse if (oap->motion_type == MLINE)\n\t    argv[0].vval.v_string = (char_u *)\"line\";\n\telse\n\t    argv[0].vval.v_string = (char_u *)\"char\";\n\targv[1].v_type = VAR_UNKNOWN;\n\n\t// Reset virtual_op so that 'virtualedit' can be changed in the\n\t// function.\n\tvirtual_op = MAYBE;\n\n\t// Reset finish_op so that mode() returns the right value.\n\tfinish_op = FALSE;\n\n\tif (call_callback(&opfunc_cb, 0, &rettv, 1, argv) != FAIL)\n\t    clear_tv(&rettv);\n\n\tvirtual_op = save_virtual_op;\n\tfinish_op = save_finish_op;\n\tif (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n\t{\n\t    curbuf->b_op_start = orig_start;\n\t    curbuf->b_op_end = orig_end;\n\t}\n    }\n#else\n    emsg(_(e_eval_feature_not_available));\n#endif\n}\n\n/*\n * Calculate start/end virtual columns for operating in block mode.\n */\n    static void\nget_op_vcol(\n    oparg_T\t*oap,\n    colnr_T\tredo_VIsual_vcol,\n    int\t\tinitial)    // when TRUE adjust position for 'selectmode'\n{\n    colnr_T\t    start, end;\n\n    if (VIsual_mode != Ctrl_V\n\t    || (!initial && oap->end.col < curwin->w_width))\n\treturn;\n\n    oap->block_mode = TRUE;\n\n    // prevent from moving onto a trail byte\n    if (has_mbyte)\n\tmb_adjustpos(curwin->w_buffer, &oap->end);\n\n    getvvcol(curwin, &(oap->start), &oap->start_vcol, NULL, &oap->end_vcol);\n\n    if (!redo_VIsual_busy)\n    {\n\tgetvvcol(curwin, &(oap->end), &start, NULL, &end);\n\n\tif (start < oap->start_vcol)\n\t    oap->start_vcol = start;\n\tif (end > oap->end_vcol)\n\t{\n\t    if (initial && *p_sel == 'e' && start >= 1\n\t\t\t\t    && start - 1 >= oap->end_vcol)\n\t\toap->end_vcol = start - 1;\n\t    else\n\t\toap->end_vcol = end;\n\t}\n    }\n\n    // if '$' was used, get oap->end_vcol from longest line\n    if (curwin->w_curswant == MAXCOL)\n    {\n\tcurwin->w_cursor.col = MAXCOL;\n\toap->end_vcol = 0;\n\tfor (curwin->w_cursor.lnum = oap->start.lnum;\n\t\tcurwin->w_cursor.lnum <= oap->end.lnum;\n\t\t\t\t\t++curwin->w_cursor.lnum)\n\t{\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);\n\t    if (end > oap->end_vcol)\n\t\toap->end_vcol = end;\n\t}\n    }\n    else if (redo_VIsual_busy)\n\toap->end_vcol = oap->start_vcol + redo_VIsual_vcol - 1;\n    // Correct oap->end.col and oap->start.col to be the\n    // upper-left and lower-right corner of the block area.\n    //\n    // (Actually, this does convert column positions into character\n    // positions)\n    curwin->w_cursor.lnum = oap->end.lnum;\n    coladvance(oap->end_vcol);\n    oap->end = curwin->w_cursor;\n\n    curwin->w_cursor = oap->start;\n    coladvance(oap->start_vcol);\n    oap->start = curwin->w_cursor;\n}\n\n// Information for redoing the previous Visual selection.\ntypedef struct {\n    int\t\trv_mode;\t// 'v', 'V', or Ctrl-V\n    linenr_T\trv_line_count;\t// number of lines\n    colnr_T\trv_vcol;\t// number of cols or end column\n    long\trv_count;\t// count for Visual operator\n    int\t\trv_arg;\t\t// extra argument\n} redo_VIsual_T;\n\n    static int\nis_ex_cmdchar(cmdarg_T *cap)\n{\n    return cap->cmdchar == ':'\n\t|| cap->cmdchar == K_COMMAND\n\t|| cap->cmdchar == K_SCRIPT_COMMAND;\n}\n\n/*\n * Handle an operator after Visual mode or when the movement is finished.\n * \"gui_yank\" is true when yanking text for the clipboard.\n */\n    void\ndo_pending_operator(cmdarg_T *cap, int old_col, int gui_yank)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\told_cursor;\n    int\t\tempty_region_error;\n    int\t\trestart_edit_save;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n#endif\n\n    // The visual area is remembered for redo\n    static redo_VIsual_T   redo_VIsual = {NUL, 0, 0, 0,0};\n\n    int\t\t    include_line_break = FALSE;\n\n#if defined(FEAT_CLIPBOARD)\n    // Yank the visual area into the GUI selection register before we operate\n    // on it and lose it forever.\n    // Don't do it if a specific register was specified, so that \"\"x\"*P works.\n    // This could call do_pending_operator() recursively, but that's OK\n    // because gui_yank will be TRUE for the nested call.\n    if ((clip_star.available || clip_plus.available)\n\t    && oap->op_type != OP_NOP\n\t    && !gui_yank\n\t    && VIsual_active\n\t    && !redo_VIsual_busy\n\t    && oap->regname == 0)\n\tclip_auto_select();\n#endif\n    old_cursor = curwin->w_cursor;\n\n    // If an operation is pending, handle it...\n    if ((finish_op || VIsual_active) && oap->op_type != OP_NOP)\n    {\n\t// Yank can be redone when 'y' is in 'cpoptions', but not when yanking\n\t// for the clipboard.\n\tint\tredo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL && !gui_yank;\n\n#ifdef FEAT_LINEBREAK\n\t// Avoid a problem with unwanted linebreaks in block mode.\n\tif (curwin->w_p_lbr)\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\tcurwin->w_p_lbr = FALSE;\n#endif\n\toap->is_VIsual = VIsual_active;\n\tif (oap->motion_force == 'V')\n\t    oap->motion_type = MLINE;\n\telse if (oap->motion_force == 'v')\n\t{\n\t    // If the motion was linewise, \"inclusive\" will not have been set.\n\t    // Use \"exclusive\" to be consistent.  Makes \"dvj\" work nice.\n\t    if (oap->motion_type == MLINE)\n\t\toap->inclusive = FALSE;\n\t    // If the motion already was characterwise, toggle \"inclusive\"\n\t    else if (oap->motion_type == MCHAR)\n\t\toap->inclusive = !oap->inclusive;\n\t    oap->motion_type = MCHAR;\n\t}\n\telse if (oap->motion_force == Ctrl_V)\n\t{\n\t    // Change line- or characterwise motion into Visual block mode.\n\t    if (!VIsual_active)\n\t    {\n\t\tVIsual_active = TRUE;\n\t\tVIsual = oap->start;\n\t    }\n\t    VIsual_mode = Ctrl_V;\n\t    VIsual_select = FALSE;\n\t    VIsual_reselect = FALSE;\n\t}\n\n\t// Only redo yank when 'y' flag is in 'cpoptions'.\n\t// Never redo \"zf\" (define fold).\n\tif ((redo_yank || oap->op_type != OP_YANK)\n\t\t&& ((!VIsual_active || oap->motion_force)\n\t\t    // Also redo Operator-pending Visual mode mappings\n\t\t    || (VIsual_active\n\t\t\t    && is_ex_cmdchar(cap) && oap->op_type != OP_COLON))\n\t\t&& cap->cmdchar != 'D'\n#ifdef FEAT_FOLDING\n\t\t&& oap->op_type != OP_FOLD\n\t\t&& oap->op_type != OP_FOLDOPEN\n\t\t&& oap->op_type != OP_FOLDOPENREC\n\t\t&& oap->op_type != OP_FOLDCLOSE\n\t\t&& oap->op_type != OP_FOLDCLOSEREC\n\t\t&& oap->op_type != OP_FOLDDEL\n\t\t&& oap->op_type != OP_FOLDDELREC\n#endif\n\t\t)\n\t{\n\t    prep_redo(oap->regname, cap->count0,\n\t\t    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),\n\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t    if (cap->cmdchar == '/' || cap->cmdchar == '?') // was a search\n\t    {\n\t\t// If 'cpoptions' does not contain 'r', insert the search\n\t\t// pattern to really repeat the same command.\n\t\tif (vim_strchr(p_cpo, CPO_REDO) == NULL)\n\t\t    AppendToRedobuffLit(cap->searchbuf, -1);\n\t\tAppendToRedobuff(NL_STR);\n\t    }\n\t    else if (is_ex_cmdchar(cap))\n\t    {\n\t\t// do_cmdline() has stored the first typed line in\n\t\t// \"repeat_cmdline\".  When several lines are typed repeating\n\t\t// won't be possible.\n\t\tif (repeat_cmdline == NULL)\n\t\t    ResetRedobuff();\n\t\telse\n\t\t{\n\t\t    AppendToRedobuffLit(repeat_cmdline, -1);\n\t\t    AppendToRedobuff(NL_STR);\n\t\t    VIM_CLEAR(repeat_cmdline);\n\t\t}\n\t    }\n\t}\n\n\tif (redo_VIsual_busy)\n\t{\n\t    // Redo of an operation on a Visual area. Use the same size from\n\t    // redo_VIsual.rv_line_count and redo_VIsual.rv_vcol.\n\t    oap->start = curwin->w_cursor;\n\t    curwin->w_cursor.lnum += redo_VIsual.rv_line_count - 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    VIsual_mode = redo_VIsual.rv_mode;\n\t    if (redo_VIsual.rv_vcol == MAXCOL || VIsual_mode == 'v')\n\t    {\n\t\tif (VIsual_mode == 'v')\n\t\t{\n\t\t    if (redo_VIsual.rv_line_count <= 1)\n\t\t    {\n\t\t\tvalidate_virtcol();\n\t\t\tcurwin->w_curswant =\n\t\t\t\t     curwin->w_virtcol + redo_VIsual.rv_vcol - 1;\n\t\t    }\n\t\t    else\n\t\t\tcurwin->w_curswant = redo_VIsual.rv_vcol;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_curswant = MAXCOL;\n\t\t}\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    cap->count0 = redo_VIsual.rv_count;\n\t    if (redo_VIsual.rv_count != 0)\n\t\tcap->count1 = redo_VIsual.rv_count;\n\t    else\n\t\tcap->count1 = 1;\n\t}\n\telse if (VIsual_active)\n\t{\n\t    if (!gui_yank)\n\t    {\n\t\t// Save the current VIsual area for '< and '> marks, and \"gv\"\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurbuf->b_visual.vi_mode = VIsual_mode;\n\t\trestore_visual_mode();\n\t\tcurbuf->b_visual.vi_curswant = curwin->w_curswant;\n# ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = VIsual_mode;\n# endif\n\t    }\n\n\t    // In Select mode, a linewise selection is operated upon like a\n\t    // characterwise selection.\n\t    // Special case: gH<Del> deletes the last line.\n\t    if (VIsual_select && VIsual_mode == 'V'\n\t\t\t\t\t    && cap->oap->op_type != OP_DELETE)\n\t    {\n\t\tif (LT_POS(VIsual, curwin->w_cursor))\n\t\t{\n\t\t    VIsual.col = 0;\n\t\t    curwin->w_cursor.col =\n\t\t\t       (colnr_T)STRLEN(ml_get(curwin->w_cursor.lnum));\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.col = 0;\n\t\t    VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));\n\t\t}\n\t\tVIsual_mode = 'v';\n\t    }\n\t    // If 'selection' is \"exclusive\", backup one character for\n\t    // charwise selections.\n\t    else if (VIsual_mode == 'v')\n\t\tinclude_line_break = unadjust_for_sel();\n\n\t    oap->start = VIsual;\n\t    if (VIsual_mode == 'V')\n\t    {\n\t\toap->start.col = 0;\n\t\toap->start.coladd = 0;\n\t    }\n\t}\n\n\t// Set oap->start to the first position of the operated text, oap->end\n\t// to the end of the operated text.  w_cursor is equal to oap->start.\n\tif (LT_POS(oap->start, curwin->w_cursor))\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active)\n\t    {\n\t\tif (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))\n\t\t    oap->start.col = 0;\n\t\tif ((curwin->w_cursor.col > 0 || oap->inclusive\n\t\t\t\t\t\t  || oap->motion_type == MLINE)\n\t\t\t&& hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum))\n\t\t    curwin->w_cursor.col = (colnr_T)STRLEN(ml_get_curline());\n\t    }\n#endif\n\t    oap->end = curwin->w_cursor;\n\t    curwin->w_cursor = oap->start;\n\n\t    // w_virtcol may have been updated; if the cursor goes back to its\n\t    // previous position w_virtcol becomes invalid and isn't updated\n\t    // automatically.\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active && oap->motion_type == MLINE)\n\t    {\n\t\tif (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tNULL))\n\t\t    curwin->w_cursor.col = 0;\n\t\tif (hasFolding(oap->start.lnum, NULL, &oap->start.lnum))\n\t\t    oap->start.col = (colnr_T)STRLEN(ml_get(oap->start.lnum));\n\t    }\n#endif\n\t    oap->end = oap->start;\n\t    oap->start = curwin->w_cursor;\n\t}\n\n\t// Just in case lines were deleted that make the position invalid.\n\tcheck_pos(curwin->w_buffer, &oap->end);\n\toap->line_count = oap->end.lnum - oap->start.lnum + 1;\n\n\t// Set \"virtual_op\" before resetting VIsual_active.\n\tvirtual_op = virtual_active();\n\n\tif (VIsual_active || redo_VIsual_busy)\n\t{\n\t    get_op_vcol(oap, redo_VIsual.rv_vcol, TRUE);\n\n\t    if (!redo_VIsual_busy && !gui_yank)\n\t    {\n\t\t// Prepare to reselect and redo Visual: this is based on the\n\t\t// size of the Visual text\n\t\tresel_VIsual_mode = VIsual_mode;\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    resel_VIsual_vcol = MAXCOL;\n\t\telse\n\t\t{\n\t\t    if (VIsual_mode != Ctrl_V)\n\t\t\tgetvvcol(curwin, &(oap->end),\n\t\t\t\t\t\t  NULL, NULL, &oap->end_vcol);\n\t\t    if (VIsual_mode == Ctrl_V || oap->line_count <= 1)\n\t\t    {\n\t\t\tif (VIsual_mode != Ctrl_V)\n\t\t\t    getvvcol(curwin, &(oap->start),\n\t\t\t\t\t\t&oap->start_vcol, NULL, NULL);\n\t\t\tresel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;\n\t\t    }\n\t\t    else\n\t\t\tresel_VIsual_vcol = oap->end_vcol;\n\t\t}\n\t\tresel_VIsual_line_count = oap->line_count;\n\t    }\n\n\t    // can't redo yank (unless 'y' is in 'cpoptions') and \":\"\n\t    if ((redo_yank || oap->op_type != OP_YANK)\n\t\t    && oap->op_type != OP_COLON\n#ifdef FEAT_FOLDING\n\t\t    && oap->op_type != OP_FOLD\n\t\t    && oap->op_type != OP_FOLDOPEN\n\t\t    && oap->op_type != OP_FOLDOPENREC\n\t\t    && oap->op_type != OP_FOLDCLOSE\n\t\t    && oap->op_type != OP_FOLDCLOSEREC\n\t\t    && oap->op_type != OP_FOLDDEL\n\t\t    && oap->op_type != OP_FOLDDELREC\n#endif\n\t\t    && oap->motion_force == NUL\n\t\t    )\n\t    {\n\t\t// Prepare for redoing.  Only use the nchar field for \"r\",\n\t\t// otherwise it might be the second char of the operator.\n\t\tif (cap->cmdchar == 'g' && (cap->nchar == 'n'\n\t\t\t\t\t\t\t|| cap->nchar == 'N'))\n\t\t    prep_redo(oap->regname, cap->count0,\n\t\t\t    get_op_char(oap->op_type),\n\t\t\t    get_extra_op_char(oap->op_type),\n\t\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t\telse if (!is_ex_cmdchar(cap))\n\t\t{\n\t\t    int opchar = get_op_char(oap->op_type);\n\t\t    int extra_opchar = get_extra_op_char(oap->op_type);\n\t\t    int nchar = oap->op_type == OP_REPLACE ? cap->nchar : NUL;\n\n\t\t    // reverse what nv_replace() did\n\t\t    if (nchar == REPLACE_CR_NCHAR)\n\t\t\tnchar = CAR;\n\t\t    else if (nchar == REPLACE_NL_NCHAR)\n\t\t\tnchar = NL;\n\n\t\t    if (opchar == 'g' && extra_opchar == '@')\n\t\t\t// also repeat the count for 'operatorfunc'\n\t\t\tprep_redo_num2(oap->regname, 0L, NUL, 'v',\n\t\t\t\t     cap->count0, opchar, extra_opchar, nchar);\n\t\t    else\n\t\t\tprep_redo(oap->regname, 0L, NUL, 'v',\n\t\t\t\t\t\t  opchar, extra_opchar, nchar);\n\t\t}\n\t\tif (!redo_VIsual_busy)\n\t\t{\n\t\t    redo_VIsual.rv_mode = resel_VIsual_mode;\n\t\t    redo_VIsual.rv_vcol = resel_VIsual_vcol;\n\t\t    redo_VIsual.rv_line_count = resel_VIsual_line_count;\n\t\t    redo_VIsual.rv_count = cap->count0;\n\t\t    redo_VIsual.rv_arg = cap->arg;\n\t\t}\n\t    }\n\n\t    // oap->inclusive defaults to TRUE.\n\t    // If oap->end is on a NUL (empty line) oap->inclusive becomes\n\t    // FALSE.  This makes \"d}P\" and \"v}dP\" work the same.\n\t    if (oap->motion_force == NUL || oap->motion_type == MLINE)\n\t\toap->inclusive = TRUE;\n\t    if (VIsual_mode == 'V')\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->motion_type = MCHAR;\n\t\tif (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL\n\t\t\t&& (include_line_break || !virtual_op))\n\t\t{\n\t\t    oap->inclusive = FALSE;\n\t\t    // Try to include the newline, unless it's an operator\n\t\t    // that works on lines only.\n\t\t    if (*p_sel != 'o'\n\t\t\t    && !op_on_lines(oap->op_type)\n\t\t\t    && oap->end.lnum < curbuf->b_ml.ml_line_count)\n\t\t    {\n\t\t\t++oap->end.lnum;\n\t\t\toap->end.col = 0;\n\t\t\toap->end.coladd = 0;\n\t\t\t++oap->line_count;\n\t\t    }\n\t\t}\n\t    }\n\n\t    redo_VIsual_busy = FALSE;\n\n\t    // Switch Visual off now, so screen updating does\n\t    // not show inverted text when the screen is redrawn.\n\t    // With OP_YANK and sometimes with OP_COLON and OP_FILTER there is\n\t    // no screen redraw, so it is done here to remove the inverted\n\t    // part.\n\t    if (!gui_yank)\n\t    {\n\t\tVIsual_active = FALSE;\n\t\tsetmouse();\n\t\tmouse_dragging = 0;\n\t\tmay_clear_cmdline();\n\t\tif ((oap->op_type == OP_YANK\n\t\t\t    || oap->op_type == OP_COLON\n\t\t\t    || oap->op_type == OP_FUNCTION\n\t\t\t    || oap->op_type == OP_FILTER)\n\t\t\t&& oap->motion_force == NUL)\n\t\t{\n#ifdef FEAT_LINEBREAK\n\t\t    // make sure redrawing is correct\n\t\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t\t    redraw_curbuf_later(INVERTED);\n\t\t}\n\t    }\n\t}\n\n\t// Include the trailing byte of a multi-byte char.\n\tif (has_mbyte && oap->inclusive)\n\t{\n\t    int\t\tl;\n\n\t    l = (*mb_ptr2len)(ml_get_pos(&oap->end));\n\t    if (l > 1)\n\t\toap->end.col += l - 1;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\n\t// oap->empty is set when start and end are the same.  The inclusive\n\t// flag affects this too, unless yanking and the end is on a NUL.\n\toap->empty = (oap->motion_type == MCHAR\n\t\t    && (!oap->inclusive\n\t\t\t|| (oap->op_type == OP_YANK\n\t\t\t    && gchar_pos(&oap->end) == NUL))\n\t\t    && EQUAL_POS(oap->start, oap->end)\n\t\t    && !(virtual_op && oap->start.coladd != oap->end.coladd));\n\t// For delete, change and yank, it's an error to operate on an\n\t// empty region, when 'E' included in 'cpoptions' (Vi compatible).\n\tempty_region_error = (oap->empty\n\t\t\t\t&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);\n\n\t// Force a redraw when operating on an empty Visual region, when\n\t// 'modifiable is off or creating a fold.\n\tif (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma\n#ifdef FEAT_FOLDING\n\t\t    || oap->op_type == OP_FOLD\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_LINEBREAK\n\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// If the end of an operator is in column one while oap->motion_type\n\t// is MCHAR and oap->inclusive is FALSE, we put op_end after the last\n\t// character in the previous line. If op_start is on or before the\n\t// first non-blank in the line, the operator becomes linewise\n\t// (strange, but that's the way vi does it).\n\tif (\t   oap->motion_type == MCHAR\n\t\t&& oap->inclusive == FALSE\n\t\t&& !(cap->retval & CA_NO_ADJ_OP_END)\n\t\t&& oap->end.col == 0\n\t\t&& (!oap->is_VIsual || *p_sel == 'o')\n\t\t&& !oap->block_mode\n\t\t&& oap->line_count > 1)\n\t{\n\t    oap->end_adjusted = TRUE;\t    // remember that we did this\n\t    --oap->line_count;\n\t    --oap->end.lnum;\n\t    if (inindent(0))\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t\tif (oap->end.col)\n\t\t{\n\t\t    --oap->end.col;\n\t\t    oap->inclusive = TRUE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    oap->end_adjusted = FALSE;\n\n\tswitch (oap->op_type)\n\t{\n\tcase OP_LSHIFT:\n\tcase OP_RSHIFT:\n\t    op_shift(oap, TRUE, oap->is_VIsual ? (int)cap->count1 : 1);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase OP_JOIN_NS:\n\tcase OP_JOIN:\n\t    if (oap->line_count < 2)\n\t\toap->line_count = 2;\n\t    if (curwin->w_cursor.lnum + oap->line_count - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t\tbeep_flush();\n\t    else\n\t    {\n\t\t(void)do_join(oap->line_count, oap->op_type == OP_JOIN,\n\t\t\t\t\t\t\t    TRUE, TRUE, TRUE);\n\t\tauto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_DELETE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t(void)op_delete(oap);\n\t\t// save cursor line for undo if it wasn't saved yet\n\t\tif (oap->motion_type == MLINE && has_format_option(FO_AUTO)\n\t\t\t\t\t\t      && u_save_cursor() == OK)\n\t\t    auto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_YANK:\n\t    if (empty_region_error)\n\t    {\n\t\tif (!gui_yank)\n\t\t{\n\t\t    vim_beep(BO_OPER);\n\t\t    CancelRedo();\n\t\t}\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\toap->excl_tr_ws = cap->cmdchar == 'z';\n\t\t(void)op_yank(oap, FALSE, !gui_yank);\n\t    }\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_CHANGE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once and not when typed and\n\t\t// 'insertmode' isn't set.\n\t\tif (p_im || !KeyTyped)\n\t\t    restart_edit_save = restart_edit;\n\t\telse\n\t\t    restart_edit_save = 0;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// Reset finish_op now, don't want it set inside edit().\n\t\tfinish_op = FALSE;\n\t\tif (op_change(oap))\t// will call edit()\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t    }\n\t    break;\n\n\tcase OP_FILTER:\n\t    if (vim_strchr(p_cpo, CPO_FILTER) != NULL)\n\t\tAppendToRedobuff((char_u *)\"!\\r\");  // use any last used !cmd\n\t    else\n\t\tbangredo = TRUE;    // do_bang() will put cmd in redo buffer\n\t    // FALLTHROUGH\n\n\tcase OP_INDENT:\n\tcase OP_COLON:\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\t    // If 'equalprg' is empty, do the indenting internally.\n\t    if (oap->op_type == OP_INDENT && *get_equalprg() == NUL)\n\t    {\n# ifdef FEAT_LISP\n\t\tif (curbuf->b_p_lisp)\n\t\t{\n\t\t    op_reindent(oap, get_lisp_indent);\n\t\t    break;\n\t\t}\n# endif\n# ifdef FEAT_CINDENT\n\t\top_reindent(oap,\n#  ifdef FEAT_EVAL\n\t\t\t*curbuf->b_p_inde != NUL ? get_expr_indent :\n#  endif\n\t\t\t    get_c_indent);\n\t\tbreak;\n# endif\n\t    }\n#endif\n\n\t    op_colon(oap);\n\t    break;\n\n\tcase OP_TILDE:\n\tcase OP_UPPER:\n\tcase OP_LOWER:\n\tcase OP_ROT13:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t\top_tilde(oap);\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_FORMAT:\n#if defined(FEAT_EVAL)\n\t    if (*curbuf->b_p_fex != NUL)\n\t\top_formatexpr(oap);\t// use expression\n\t    else\n#endif\n\t    {\n\t\tif (*p_fp != NUL || *curbuf->b_p_fp != NUL)\n\t\t    op_colon(oap);\t\t// use external command\n\t\telse\n\t\t    op_format(oap, FALSE);\t// use internal function\n\t    }\n\t    break;\n\tcase OP_FORMAT2:\n\t    op_format(oap, TRUE);\t// use internal function\n\t    break;\n\n\tcase OP_FUNCTION:\n\t    {\n\t\tredo_VIsual_T   save_redo_VIsual = redo_VIsual;\n\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// call 'operatorfunc'\n\t\top_function(oap);\n\n\t\t// Restore the info for redoing Visual mode, the function may\n\t\t// invoke another operator and unintentionally change it.\n\t\tredo_VIsual = save_redo_VIsual;\n\t\tbreak;\n\t    }\n\n\tcase OP_INSERT:\n\tcase OP_APPEND:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once.\n\t\trestart_edit_save = restart_edit;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_insert(oap, cap->count1);\n#ifdef FEAT_LINEBREAK\n\t\t// Reset linebreak, so that formatting works correctly.\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\n\t\t// TODO: when inserting in several lines, should format all\n\t\t// the lines.\n\t\tauto_format(FALSE, TRUE);\n\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t\telse\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t    }\n\t    break;\n\n\tcase OP_REPLACE:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_replace(oap, cap->nchar);\n\t    }\n\t    break;\n\n#ifdef FEAT_FOLDING\n\tcase OP_FOLD:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    foldCreate(oap->start.lnum, oap->end.lnum);\n\t    break;\n\n\tcase OP_FOLDOPEN:\n\tcase OP_FOLDOPENREC:\n\tcase OP_FOLDCLOSE:\n\tcase OP_FOLDCLOSEREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    opFoldRange(oap->start.lnum, oap->end.lnum,\n\t\t    oap->op_type == OP_FOLDOPEN\n\t\t\t\t\t    || oap->op_type == OP_FOLDOPENREC,\n\t\t    oap->op_type == OP_FOLDOPENREC\n\t\t\t\t\t  || oap->op_type == OP_FOLDCLOSEREC,\n\t\t\t\t\t  oap->is_VIsual);\n\t    break;\n\n\tcase OP_FOLDDEL:\n\tcase OP_FOLDDELREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    deleteFold(oap->start.lnum, oap->end.lnum,\n\t\t\t       oap->op_type == OP_FOLDDELREC, oap->is_VIsual);\n\t    break;\n#endif\n\tcase OP_NR_ADD:\n\tcase OP_NR_SUB:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\tVIsual_active = TRUE;\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_addsub(oap, cap->count1, redo_VIsual.rv_arg);\n\t\tVIsual_active = FALSE;\n\t    }\n\t    check_cursor_col();\n\t    break;\n\tdefault:\n\t    clearopbeep(oap);\n\t}\n\tvirtual_op = MAYBE;\n\tif (!gui_yank)\n\t{\n\t    // if 'sol' not set, go back to old column for some commands\n\t    if (!p_sol && oap->motion_type == MLINE && !oap->end_adjusted\n\t\t    && (oap->op_type == OP_LSHIFT || oap->op_type == OP_RSHIFT\n\t\t\t\t\t\t|| oap->op_type == OP_DELETE))\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\t\tcoladvance(curwin->w_curswant = old_col);\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = old_cursor;\n\t}\n\toap->block_mode = FALSE;\n\tclearop(oap);\n\tmotion_force = NUL;\n    }\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n", "\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ops.c", "src/testdir/test_visual.vim", "src/version.c"], "buggy_code_start_loc": [532, 1311, 752], "buggy_code_end_loc": [550, 1311, 752], "fixing_code_start_loc": [532, 1312, 753], "fixing_code_end_loc": [535, 1321, 755], "type": "CWE-787", "message": "Heap-based Buffer Overflow in vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-0318", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-21T12:15:10.053", "lastModified": "2022-11-29T22:12:23.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in vim/vim prior to 8.2."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer en la regi\u00f3n Heap de la Memoria en vim/vim versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4151", "matchCriteriaId": "0F9F96CA-18A7-4C0B-8C3E-4A4DEC087ABA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/43", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/57df9e8a9f9ae1aafdde9b86b10ad907627a87dc", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0d10ba02-b138-4e68-a284-67f781a62d08", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213444", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/57df9e8a9f9ae1aafdde9b86b10ad907627a87dc"}}