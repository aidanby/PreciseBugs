{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Firewall;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\EventDispatcher\\Event;\nuse Symfony\\Component\\EventDispatcher\\LegacyEventDispatcherProxy;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationTrustResolver;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationTrustResolverInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\AnonymousToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\RememberMeToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\SwitchUserToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\UnsupportedUserException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UserNotFoundException;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserProviderInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\DeauthenticatedEvent;\nuse Symfony\\Component\\Security\\Http\\Event\\TokenDeauthenticatedEvent;\nuse Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * ContextListener manages the SecurityContext persistence through a session.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n *\n * @final\n */\nclass ContextListener extends AbstractListener\n{\n    private $tokenStorage;\n    private $sessionKey;\n    private $logger;\n    private $userProviders;\n    private $dispatcher;\n    private $registered;\n    private $trustResolver;\n    private $rememberMeServices;\n    private $sessionTrackerEnabler;\n\n    /**\n     * @param iterable|UserProviderInterface[] $userProviders\n     */\n    public function __construct(TokenStorageInterface $tokenStorage, iterable $userProviders, string $contextKey, LoggerInterface $logger = null, EventDispatcherInterface $dispatcher = null, AuthenticationTrustResolverInterface $trustResolver = null, callable $sessionTrackerEnabler = null)\n    {\n        if (empty($contextKey)) {\n            throw new \\InvalidArgumentException('$contextKey must not be empty.');\n        }\n\n        $this->tokenStorage = $tokenStorage;\n        $this->userProviders = $userProviders;\n        $this->sessionKey = '_security_'.$contextKey;\n        $this->logger = $logger;\n        $this->dispatcher = class_exists(Event::class) ? LegacyEventDispatcherProxy::decorate($dispatcher) : $dispatcher;\n\n        $this->trustResolver = $trustResolver ?? new AuthenticationTrustResolver(AnonymousToken::class, RememberMeToken::class);\n        $this->sessionTrackerEnabler = $sessionTrackerEnabler;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(Request $request): ?bool\n    {\n        return null; // always run authenticate() lazily with lazy firewalls\n    }\n\n    /**\n     * Reads the Security Token from the session.\n     */\n    public function authenticate(RequestEvent $event)\n    {\n        if (!$this->registered && null !== $this->dispatcher && $event->isMainRequest()) {\n            $this->dispatcher->addListener(KernelEvents::RESPONSE, [$this, 'onKernelResponse']);\n            $this->registered = true;\n        }\n\n        $request = $event->getRequest();\n        $session = $request->hasPreviousSession() && $request->hasSession() ? $request->getSession() : null;\n\n        $request->attributes->set('_security_firewall_run', true);\n\n        if (null !== $session) {\n            $usageIndexValue = $session instanceof Session ? $usageIndexReference = &$session->getUsageIndex() : 0;\n            $usageIndexReference = \\PHP_INT_MIN;\n            $sessionId = $request->cookies->all()[$session->getName()] ?? null;\n            $token = $session->get($this->sessionKey);\n\n            // sessionId = true is used in the tests\n            if ($this->sessionTrackerEnabler && \\in_array($sessionId, [true, $session->getId()], true)) {\n                $usageIndexReference = $usageIndexValue;\n            } else {\n                $usageIndexReference = $usageIndexReference - \\PHP_INT_MIN + $usageIndexValue;\n            }\n        }\n\n        if (null === $session || null === $token) {\n            if ($this->sessionTrackerEnabler) {\n                ($this->sessionTrackerEnabler)();\n            }\n\n            $this->tokenStorage->setToken(null);\n\n            return;\n        }\n\n        $token = $this->safelyUnserialize($token);\n\n        if (null !== $this->logger) {\n            $this->logger->debug('Read existing security token from the session.', [\n                'key' => $this->sessionKey,\n                'token_class' => \\is_object($token) ? \\get_class($token) : null,\n            ]);\n        }\n\n        if ($token instanceof TokenInterface) {\n            $originalToken = $token;\n            $token = $this->refreshUser($token);\n\n            if (!$token) {\n                if ($this->dispatcher) {\n                    $this->dispatcher->dispatch(new TokenDeauthenticatedEvent($originalToken, $request));\n                }\n\n                if ($this->rememberMeServices) {\n                    $this->rememberMeServices->loginFail($request);\n                }\n            }\n        } elseif (null !== $token) {\n            if (null !== $this->logger) {\n                $this->logger->warning('Expected a security token from the session, got something else.', ['key' => $this->sessionKey, 'received' => $token]);\n            }\n\n            $token = null;\n        }\n\n        if ($this->sessionTrackerEnabler) {\n            ($this->sessionTrackerEnabler)();\n        }\n\n        $this->tokenStorage->setToken($token);\n    }\n\n    /**\n     * Writes the security token into the session.\n     */\n    public function onKernelResponse(ResponseEvent $event)\n    {\n        if (!$event->isMainRequest()) {\n            return;\n        }\n\n        $request = $event->getRequest();\n\n        if (!$request->hasSession() || !$request->attributes->get('_security_firewall_run', false)) {\n            return;\n        }\n\n        if ($this->dispatcher) {\n            $this->dispatcher->removeListener(KernelEvents::RESPONSE, [$this, 'onKernelResponse']);\n        }\n        $this->registered = false;\n        $session = $request->getSession();\n        $sessionId = $session->getId();\n        $usageIndexValue = $session instanceof Session ? $usageIndexReference = &$session->getUsageIndex() : null;\n        $token = $this->tokenStorage->getToken();\n\n        if (null === $token || $this->trustResolver->isAnonymous($token)) {\n            if ($request->hasPreviousSession()) {\n                $session->remove($this->sessionKey);\n            }\n        } else {\n            $session->set($this->sessionKey, serialize($token));\n\n            if (null !== $this->logger) {\n                $this->logger->debug('Stored the security token in the session.', ['key' => $this->sessionKey]);\n            }\n        }\n\n        if ($this->sessionTrackerEnabler && $session->getId() === $sessionId) {\n            $usageIndexReference = $usageIndexValue;\n        }\n    }\n\n    /**\n     * Refreshes the user by reloading it from the user provider.\n     *\n     * @throws \\RuntimeException\n     */\n    protected function refreshUser(TokenInterface $token): ?TokenInterface\n    {\n        $user = $token->getUser();\n        if (!$user instanceof UserInterface) {\n            return $token;\n        }\n\n        $userNotFoundByProvider = false;\n        $userDeauthenticated = false;\n        $userClass = \\get_class($user);\n\n        foreach ($this->userProviders as $provider) {\n            if (!$provider instanceof UserProviderInterface) {\n                throw new \\InvalidArgumentException(sprintf('User provider \"%s\" must implement \"%s\".', get_debug_type($provider), UserProviderInterface::class));\n            }\n\n            if (!$provider->supportsClass($userClass)) {\n                continue;\n            }\n\n            try {\n                $refreshedUser = $provider->refreshUser($user);\n                $newToken = clone $token;\n                $newToken->setUser($refreshedUser);\n\n                // tokens can be deauthenticated if the user has been changed.\n                if (!$newToken->isAuthenticated()) {\n                    $userDeauthenticated = true;\n\n                    if (null !== $this->logger) {\n                        // @deprecated since 5.3, change to $refreshedUser->getUserIdentifier() in 6.0\n                        $this->logger->debug('Cannot refresh token because user has changed.', ['username' => method_exists($refreshedUser, 'getUserIdentifier') ? $refreshedUser->getUserIdentifier() : $refreshedUser->getUsername(), 'provider' => \\get_class($provider)]);\n                    }\n\n                    continue;\n                }\n\n                $token->setUser($refreshedUser);\n\n                if (null !== $this->logger) {\n                    // @deprecated since 5.3, change to $refreshedUser->getUserIdentifier() in 6.0\n                    $context = ['provider' => \\get_class($provider), 'username' => method_exists($refreshedUser, 'getUserIdentifier') ? $refreshedUser->getUserIdentifier() : $refreshedUser->getUsername()];\n\n                    if ($token instanceof SwitchUserToken) {\n                        // @deprecated since 5.3, change to $token->getUserIdentifier() in 6.0\n                        $context['impersonator_username'] = method_exists($token, 'getUserIdentifier') ? $token->getUserIdentifier() : $token->getOriginalToken()->getUsername();\n                    }\n\n                    $this->logger->debug('User was reloaded from a user provider.', $context);\n                }\n\n                return $token;\n            } catch (UnsupportedUserException $e) {\n                // let's try the next user provider\n            } catch (UserNotFoundException $e) {\n                if (null !== $this->logger) {\n                    $this->logger->warning('Username could not be found in the selected user provider.', ['username' => method_exists($e, 'getUserIdentifier') ? $e->getUserIdentifier() : $e->getUsername(), 'provider' => \\get_class($provider)]);\n                }\n\n                $userNotFoundByProvider = true;\n            }\n        }\n\n        if ($userDeauthenticated) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Token was deauthenticated after trying to refresh it.');\n            }\n\n            if ($this->dispatcher) {\n                $this->dispatcher->dispatch(new DeauthenticatedEvent($token, $newToken), DeauthenticatedEvent::class);\n            }\n\n            return null;\n        }\n\n        if ($userNotFoundByProvider) {\n            return null;\n        }\n\n        throw new \\RuntimeException(sprintf('There is no user provider for user \"%s\". Shouldn\\'t the \"supportsClass()\" method of your user provider return true for this classname?', $userClass));\n    }\n\n    private function safelyUnserialize(string $serializedToken)\n    {\n        $e = $token = null;\n        $prevUnserializeHandler = ini_set('unserialize_callback_func', __CLASS__.'::handleUnserializeCallback');\n        $prevErrorHandler = set_error_handler(function ($type, $msg, $file, $line, $context = []) use (&$prevErrorHandler) {\n            if (__FILE__ === $file) {\n                throw new \\ErrorException($msg, 0x37313bc, $type, $file, $line);\n            }\n\n            return $prevErrorHandler ? $prevErrorHandler($type, $msg, $file, $line, $context) : false;\n        });\n\n        try {\n            $token = unserialize($serializedToken);\n        } catch (\\Throwable $e) {\n        }\n        restore_error_handler();\n        ini_set('unserialize_callback_func', $prevUnserializeHandler);\n        if ($e) {\n            if (!$e instanceof \\ErrorException || 0x37313bc !== $e->getCode()) {\n                throw $e;\n            }\n            if ($this->logger) {\n                $this->logger->warning('Failed to unserialize the security token from the session.', ['key' => $this->sessionKey, 'received' => $serializedToken, 'exception' => $e]);\n            }\n        }\n\n        return $token;\n    }\n\n    /**\n     * @internal\n     */\n    public static function handleUnserializeCallback($class)\n    {\n        throw new \\ErrorException('Class not found: '.$class, 0x37313bc);\n    }\n\n    public function setRememberMeServices(RememberMeServicesInterface $rememberMeServices)\n    {\n        $this->rememberMeServices = $rememberMeServices;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Tests\\Firewall;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Container\\ContainerInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\AnonymousToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorage;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\UsageTrackingTokenStorage;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\Exception\\UnsupportedUserException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UserNotFoundException;\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUser;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserProviderInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\DeauthenticatedEvent;\nuse Symfony\\Component\\Security\\Http\\Firewall\\ContextListener;\nuse Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface;\nuse Symfony\\Contracts\\Service\\ServiceLocatorTrait;\n\nclass ContextListenerTest extends TestCase\n{\n    public function testItRequiresContextKey()\n    {\n        $this->expectException(\\InvalidArgumentException::class);\n        $this->expectExceptionMessage('$contextKey must not be empty');\n        new ContextListener(\n            $this->createMock(TokenStorageInterface::class),\n            [],\n            ''\n        );\n    }\n\n    public function testUserProvidersNeedToImplementAnInterface()\n    {\n        $this->expectException(\\InvalidArgumentException::class);\n        $this->expectExceptionMessage('User provider \"stdClass\" must implement \"Symfony\\Component\\Security\\Core\\User\\UserProviderInterface');\n        $this->handleEventWithPreviousSession([new \\stdClass()]);\n    }\n\n    public function testOnKernelResponseWillAddSession()\n    {\n        $session = $this->runSessionOnKernelResponse(\n            new UsernamePasswordToken('test1', 'pass1', 'phpunit'),\n            null\n        );\n\n        $token = unserialize($session->get('_security_session'));\n        $this->assertInstanceOf(UsernamePasswordToken::class, $token);\n        $this->assertEquals('test1', $token->getUserIdentifier());\n    }\n\n    public function testOnKernelResponseWillReplaceSession()\n    {\n        $session = $this->runSessionOnKernelResponse(\n            new UsernamePasswordToken('test1', 'pass1', 'phpunit'),\n            'C:10:\"serialized\"'\n        );\n\n        $token = unserialize($session->get('_security_session'));\n        $this->assertInstanceOf(UsernamePasswordToken::class, $token);\n        $this->assertEquals('test1', $token->getUserIdentifier());\n    }\n\n    public function testOnKernelResponseWillRemoveSession()\n    {\n        $session = $this->runSessionOnKernelResponse(\n            null,\n            'C:10:\"serialized\"'\n        );\n\n        $this->assertFalse($session->has('_security_session'));\n    }\n\n    public function testOnKernelResponseWillRemoveSessionOnAnonymousToken()\n    {\n        $session = $this->runSessionOnKernelResponse(new AnonymousToken('secret', 'anon.'), 'C:10:\"serialized\"');\n\n        $this->assertFalse($session->has('_security_session'));\n    }\n\n    public function testOnKernelResponseWithoutSession()\n    {\n        $tokenStorage = new TokenStorage();\n        $tokenStorage->setToken(new UsernamePasswordToken('test1', 'pass1', 'phpunit'));\n        $request = new Request();\n        $request->attributes->set('_security_firewall_run', true);\n        $session = new Session(new MockArraySessionStorage());\n        $request->setSession($session);\n\n        $event = new ResponseEvent(\n            $this->createMock(HttpKernelInterface::class),\n            $request,\n            HttpKernelInterface::MAIN_REQUEST,\n            new Response()\n        );\n\n        $listener = new ContextListener($tokenStorage, [], 'session', null, new EventDispatcher());\n        $listener->onKernelResponse($event);\n\n        $this->assertTrue($session->isStarted());\n    }\n\n    public function testOnKernelResponseWithoutSessionNorToken()\n    {\n        $request = new Request();\n        $session = new Session(new MockArraySessionStorage());\n        $request->setSession($session);\n\n        $event = new ResponseEvent(\n            $this->createMock(HttpKernelInterface::class),\n            $request,\n            HttpKernelInterface::MAIN_REQUEST,\n            new Response()\n        );\n\n        $listener = new ContextListener(new TokenStorage(), [], 'session', null, new EventDispatcher());\n        $listener->onKernelResponse($event);\n\n        $this->assertFalse($session->isStarted());\n    }\n\n    /**\n     * @dataProvider provideInvalidToken\n     */\n    public function testInvalidTokenInSession($token)\n    {\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $event = $this->createMock(RequestEvent::class);\n        $session = $this->createMock(SessionInterface::class);\n        $session->expects($this->any())->method('getName')->willReturn('SESSIONNAME');\n        $session->expects($this->any())\n            ->method('get')\n            ->with('_security_key123')\n            ->willReturn($token);\n        $request = new Request([], [], [], ['SESSIONNAME' => true]);\n        $request->setSession($session);\n\n        $event->expects($this->any())\n            ->method('getRequest')\n            ->willReturn($request);\n        $tokenStorage->expects($this->once())\n            ->method('setToken')\n            ->with(null);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123');\n        $listener($event);\n    }\n\n    public function provideInvalidToken()\n    {\n        return [\n            ['foo'],\n            ['O:8:\"NotFound\":0:{}'],\n            [serialize(new \\__PHP_Incomplete_Class())],\n            [serialize(null)],\n            [null],\n        ];\n    }\n\n    public function testHandleAddsKernelResponseListener()\n    {\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $dispatcher = $this->createMock(EventDispatcherInterface::class);\n        $event = $this->createMock(RequestEvent::class);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123', null, $dispatcher);\n\n        $event->expects($this->any())\n            ->method('isMainRequest')\n            ->willReturn(true);\n        $event->expects($this->any())\n            ->method('getRequest')\n            ->willReturn(new Request());\n\n        $dispatcher->expects($this->once())\n            ->method('addListener')\n            ->with(KernelEvents::RESPONSE, [$listener, 'onKernelResponse']);\n\n        $listener($event);\n    }\n\n    public function testOnKernelResponseListenerRemovesItself()\n    {\n        $session = $this->createMock(SessionInterface::class);\n        $session->expects($this->any())->method('getName')->willReturn('SESSIONNAME');\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $dispatcher = $this->createMock(EventDispatcherInterface::class);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123', null, $dispatcher);\n\n        $request = new Request();\n        $request->attributes->set('_security_firewall_run', true);\n        $request->setSession($session);\n\n        $event = new ResponseEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST, new Response());\n\n        $dispatcher->expects($this->once())\n            ->method('removeListener')\n            ->with(KernelEvents::RESPONSE, [$listener, 'onKernelResponse']);\n\n        $listener->onKernelResponse($event);\n    }\n\n    public function testHandleRemovesTokenIfNoPreviousSessionWasFound()\n    {\n        $request = new Request();\n\n        $event = $this->createMock(RequestEvent::class);\n        $event->expects($this->any())->method('getRequest')->willReturn($request);\n\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $tokenStorage->expects($this->once())->method('setToken')->with(null);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123');\n        $listener($event);\n    }\n\n    public function testIfTokenIsDeauthenticated()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)]);\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testIfTokenIsNotDeauthenticated()\n    {\n        $tokenStorage = new TokenStorage();\n        $badRefreshedUser = new InMemoryUser('foobar', 'baz');\n        $goodRefreshedUser = new InMemoryUser('foobar', 'bar');\n        $tokenStorage = $this->handleEventWithPreviousSession([new SupportingUserProvider($badRefreshedUser), new SupportingUserProvider($goodRefreshedUser)], $goodRefreshedUser);\n        $this->assertSame($goodRefreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testRememberMeGetsCanceledIfTokenIsDeauthenticated()\n    {\n        $tokenStorage = new TokenStorage();\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n\n        $rememberMeServices = $this->createMock(RememberMeServicesInterface::class);\n        $rememberMeServices->expects($this->once())->method('loginFail');\n\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], null, $rememberMeServices);\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testTryAllUserProvidersUntilASupportingUserProviderIsFound()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], $refreshedUser);\n\n        $this->assertSame($refreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testNextSupportingUserProviderIsTriedIfPreviousSupportingUserProviderDidNotLoadTheUser()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], $refreshedUser);\n\n        $this->assertSame($refreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testTokenIsSetToNullIfNoUserWasLoadedByTheRegisteredUserProviders()\n    {\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider()]);\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testRuntimeExceptionIsThrownIfNoSupportingUserProviderWasRegistered()\n    {\n        $this->expectException(\\RuntimeException::class);\n        $this->handleEventWithPreviousSession([new NotSupportingUserProvider(false), new NotSupportingUserProvider(true)]);\n    }\n\n    public function testAcceptsProvidersAsTraversable()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession(new \\ArrayObject([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)]), $refreshedUser);\n\n        $this->assertSame($refreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testDeauthenticatedEvent()\n    {\n        $tokenStorage = new TokenStorage();\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n\n        $user = new InMemoryUser('foo', 'bar');\n        $session = new Session(new MockArraySessionStorage());\n        $session->set('_security_context_key', serialize(new UsernamePasswordToken($user, '', 'context_key', ['ROLE_USER'])));\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n\n        $eventDispatcher = new EventDispatcher();\n        $eventDispatcher->addListener(DeauthenticatedEvent::class, function (DeauthenticatedEvent $event) use ($user) {\n            $this->assertTrue($event->getOriginalToken()->isAuthenticated());\n            $this->assertEquals($event->getOriginalToken()->getUser(), $user);\n            $this->assertFalse($event->getRefreshedToken()->isAuthenticated());\n            $this->assertNotEquals($event->getRefreshedToken()->getUser(), $user);\n        });\n\n        $listener = new ContextListener($tokenStorage, [new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], 'context_key', null, $eventDispatcher);\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testWithPreviousNotStartedSession()\n    {\n        $session = new Session(new MockArraySessionStorage());\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n\n        $usageIndex = $session->getUsageIndex();\n\n        $tokenStorage = new TokenStorage();\n        $listener = new ContextListener($tokenStorage, [], 'context_key', null, null, null, [$tokenStorage, 'getToken']);\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n\n        $this->assertSame($usageIndex, $session->getUsageIndex());\n    }\n\n    public function testSessionIsNotReported()\n    {\n        $usageReporter = $this->getMockBuilder(\\stdClass::class)->setMethods(['__invoke'])->getMock();\n        $usageReporter->expects($this->never())->method('__invoke');\n\n        $session = new Session(new MockArraySessionStorage(), null, null, $usageReporter);\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n\n        $tokenStorage = new TokenStorage();\n\n        $listener = new ContextListener($tokenStorage, [], 'context_key', null, null, null, [$tokenStorage, 'getToken']);\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n    }\n\n    protected function runSessionOnKernelResponse($newToken, $original = null)\n    {\n        $session = new Session(new MockArraySessionStorage());\n        $request = new Request();\n        $request->attributes->set('_security_firewall_run', true);\n        $request->setSession($session);\n        $requestStack = new RequestStack();\n        $requestStack->push($request);\n\n        if (null !== $original) {\n            $session->set('_security_session', $original);\n        }\n\n        $tokenStorage = new UsageTrackingTokenStorage(new TokenStorage(), new class(['request_stack' => function () use ($requestStack) {\n            return $requestStack;\n        },\n        ]) implements ContainerInterface {\n            use ServiceLocatorTrait;\n        });\n\n        $tokenStorage->setToken($newToken);\n\n        $request->cookies->set('MOCKSESSID', true);\n\n        $sessionId = $session->getId();\n        $usageIndex = $session->getUsageIndex();\n\n        $event = new ResponseEvent(\n            $this->createMock(HttpKernelInterface::class),\n            $request,\n            HttpKernelInterface::MAIN_REQUEST,\n            new Response()\n        );\n\n        $listener = new ContextListener($tokenStorage, [], 'session', null, new EventDispatcher(), null, [$tokenStorage, 'enableUsageTracking']);\n        $listener->onKernelResponse($event);\n\n        if ($session->getId() === $sessionId) {\n            $this->assertSame($usageIndex, $session->getUsageIndex());\n        } else {\n            $this->assertNotSame($usageIndex, $session->getUsageIndex());\n        }\n\n        return $session;\n    }\n\n    private function handleEventWithPreviousSession($userProviders, UserInterface $user = null, RememberMeServicesInterface $rememberMeServices = null)\n    {\n        $tokenUser = $user ?? new InMemoryUser('foo', 'bar');\n        $session = new Session(new MockArraySessionStorage());\n        $session->set('_security_context_key', serialize(new UsernamePasswordToken($tokenUser, '', 'context_key', ['ROLE_USER'])));\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n        $requestStack = new RequestStack();\n        $requestStack->push($request);\n\n        $tokenStorage = new TokenStorage();\n        $usageIndex = $session->getUsageIndex();\n        $tokenStorage = new UsageTrackingTokenStorage($tokenStorage, new class(\n            (new \\ReflectionClass(UsageTrackingTokenStorage::class))->hasMethod('getSession') ? [\n                'request_stack' => function () use ($requestStack) {\n                return $requestStack;\n            }] : [\n                // BC for symfony/framework-bundle < 5.3\n                'session' => function () use ($session) {\n                    return $session;\n                },\n            ]\n        ) implements ContainerInterface {\n            use ServiceLocatorTrait;\n        });\n        $sessionTrackerEnabler = [$tokenStorage, 'enableUsageTracking'];\n\n        $listener = new ContextListener($tokenStorage, $userProviders, 'context_key', null, null, null, $sessionTrackerEnabler);\n\n        if ($rememberMeServices) {\n            $listener->setRememberMeServices($rememberMeServices);\n        }\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n\n        if (null !== $user) {\n            ++$usageIndex;\n        }\n\n        $this->assertSame($usageIndex, $session->getUsageIndex());\n        $tokenStorage->getToken();\n        $this->assertSame(1 + $usageIndex, $session->getUsageIndex());\n\n        return $tokenStorage;\n    }\n}\n\nclass NotSupportingUserProvider implements UserProviderInterface\n{\n    /** @var bool */\n    private $throwsUnsupportedException;\n\n    public function __construct($throwsUnsupportedException)\n    {\n        $this->throwsUnsupportedException = $throwsUnsupportedException;\n    }\n\n    public function loadUserByUsername($username): UserInterface\n    {\n        throw new UserNotFoundException();\n    }\n\n    public function loadUserByIdentifier(string $identifier): UserInterface\n    {\n        throw new UserNotFoundException();\n    }\n\n    public function refreshUser(UserInterface $user): UserInterface\n    {\n        if ($this->throwsUnsupportedException) {\n            throw new UnsupportedUserException();\n        }\n\n        return $user;\n    }\n\n    public function supportsClass($class): bool\n    {\n        return false;\n    }\n}\n\nclass SupportingUserProvider implements UserProviderInterface\n{\n    private $refreshedUser;\n\n    public function __construct(InMemoryUser $refreshedUser = null)\n    {\n        $this->refreshedUser = $refreshedUser;\n    }\n\n    public function loadUserByUsername($username): UserInterface\n    {\n    }\n\n    public function loadUserByIdentifier(string $identifier): UserInterface\n    {\n    }\n\n    public function refreshUser(UserInterface $user): UserInterface\n    {\n        if (!$user instanceof InMemoryUser) {\n            throw new UnsupportedUserException();\n        }\n\n        if (null === $this->refreshedUser) {\n            throw new UserNotFoundException();\n        }\n\n        return $this->refreshedUser;\n    }\n\n    public function supportsClass($class): bool\n    {\n        return InMemoryUser::class === $class;\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Firewall;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\EventDispatcher\\Event;\nuse Symfony\\Component\\EventDispatcher\\LegacyEventDispatcherProxy;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationTrustResolver;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationTrustResolverInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\AnonymousToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\RememberMeToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\SwitchUserToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\UnsupportedUserException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UserNotFoundException;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserProviderInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\DeauthenticatedEvent;\nuse Symfony\\Component\\Security\\Http\\Event\\TokenDeauthenticatedEvent;\nuse Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * ContextListener manages the SecurityContext persistence through a session.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n *\n * @final\n */\nclass ContextListener extends AbstractListener\n{\n    private $tokenStorage;\n    private $sessionKey;\n    private $logger;\n    private $userProviders;\n    private $dispatcher;\n    private $registered;\n    private $trustResolver;\n    private $rememberMeServices;\n    private $sessionTrackerEnabler;\n\n    /**\n     * @param iterable|UserProviderInterface[] $userProviders\n     */\n    public function __construct(TokenStorageInterface $tokenStorage, iterable $userProviders, string $contextKey, LoggerInterface $logger = null, EventDispatcherInterface $dispatcher = null, AuthenticationTrustResolverInterface $trustResolver = null, callable $sessionTrackerEnabler = null)\n    {\n        if (empty($contextKey)) {\n            throw new \\InvalidArgumentException('$contextKey must not be empty.');\n        }\n\n        $this->tokenStorage = $tokenStorage;\n        $this->userProviders = $userProviders;\n        $this->sessionKey = '_security_'.$contextKey;\n        $this->logger = $logger;\n        $this->dispatcher = class_exists(Event::class) ? LegacyEventDispatcherProxy::decorate($dispatcher) : $dispatcher;\n\n        $this->trustResolver = $trustResolver ?? new AuthenticationTrustResolver(AnonymousToken::class, RememberMeToken::class);\n        $this->sessionTrackerEnabler = $sessionTrackerEnabler;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(Request $request): ?bool\n    {\n        return null; // always run authenticate() lazily with lazy firewalls\n    }\n\n    /**\n     * Reads the Security Token from the session.\n     */\n    public function authenticate(RequestEvent $event)\n    {\n        if (!$this->registered && null !== $this->dispatcher && $event->isMainRequest()) {\n            $this->dispatcher->addListener(KernelEvents::RESPONSE, [$this, 'onKernelResponse']);\n            $this->registered = true;\n        }\n\n        $request = $event->getRequest();\n        $session = $request->hasPreviousSession() && $request->hasSession() ? $request->getSession() : null;\n\n        $request->attributes->set('_security_firewall_run', $this->sessionKey);\n\n        if (null !== $session) {\n            $usageIndexValue = $session instanceof Session ? $usageIndexReference = &$session->getUsageIndex() : 0;\n            $usageIndexReference = \\PHP_INT_MIN;\n            $sessionId = $request->cookies->all()[$session->getName()] ?? null;\n            $token = $session->get($this->sessionKey);\n\n            // sessionId = true is used in the tests\n            if ($this->sessionTrackerEnabler && \\in_array($sessionId, [true, $session->getId()], true)) {\n                $usageIndexReference = $usageIndexValue;\n            } else {\n                $usageIndexReference = $usageIndexReference - \\PHP_INT_MIN + $usageIndexValue;\n            }\n        }\n\n        if (null === $session || null === $token) {\n            if ($this->sessionTrackerEnabler) {\n                ($this->sessionTrackerEnabler)();\n            }\n\n            $this->tokenStorage->setToken(null);\n\n            return;\n        }\n\n        $token = $this->safelyUnserialize($token);\n\n        if (null !== $this->logger) {\n            $this->logger->debug('Read existing security token from the session.', [\n                'key' => $this->sessionKey,\n                'token_class' => \\is_object($token) ? \\get_class($token) : null,\n            ]);\n        }\n\n        if ($token instanceof TokenInterface) {\n            $originalToken = $token;\n            $token = $this->refreshUser($token);\n\n            if (!$token) {\n                if ($this->dispatcher) {\n                    $this->dispatcher->dispatch(new TokenDeauthenticatedEvent($originalToken, $request));\n                }\n\n                if ($this->rememberMeServices) {\n                    $this->rememberMeServices->loginFail($request);\n                }\n            }\n        } elseif (null !== $token) {\n            if (null !== $this->logger) {\n                $this->logger->warning('Expected a security token from the session, got something else.', ['key' => $this->sessionKey, 'received' => $token]);\n            }\n\n            $token = null;\n        }\n\n        if ($this->sessionTrackerEnabler) {\n            ($this->sessionTrackerEnabler)();\n        }\n\n        $this->tokenStorage->setToken($token);\n    }\n\n    /**\n     * Writes the security token into the session.\n     */\n    public function onKernelResponse(ResponseEvent $event)\n    {\n        if (!$event->isMainRequest()) {\n            return;\n        }\n\n        $request = $event->getRequest();\n\n        if (!$request->hasSession() || $request->attributes->get('_security_firewall_run') !== $this->sessionKey) {\n            return;\n        }\n\n        if ($this->dispatcher) {\n            $this->dispatcher->removeListener(KernelEvents::RESPONSE, [$this, 'onKernelResponse']);\n        }\n        $this->registered = false;\n        $session = $request->getSession();\n        $sessionId = $session->getId();\n        $usageIndexValue = $session instanceof Session ? $usageIndexReference = &$session->getUsageIndex() : null;\n        $token = $this->tokenStorage->getToken();\n\n        if (null === $token || $this->trustResolver->isAnonymous($token)) {\n            if ($request->hasPreviousSession()) {\n                $session->remove($this->sessionKey);\n            }\n        } else {\n            $session->set($this->sessionKey, serialize($token));\n\n            if (null !== $this->logger) {\n                $this->logger->debug('Stored the security token in the session.', ['key' => $this->sessionKey]);\n            }\n        }\n\n        if ($this->sessionTrackerEnabler && $session->getId() === $sessionId) {\n            $usageIndexReference = $usageIndexValue;\n        }\n    }\n\n    /**\n     * Refreshes the user by reloading it from the user provider.\n     *\n     * @throws \\RuntimeException\n     */\n    protected function refreshUser(TokenInterface $token): ?TokenInterface\n    {\n        $user = $token->getUser();\n        if (!$user instanceof UserInterface) {\n            return $token;\n        }\n\n        $userNotFoundByProvider = false;\n        $userDeauthenticated = false;\n        $userClass = \\get_class($user);\n\n        foreach ($this->userProviders as $provider) {\n            if (!$provider instanceof UserProviderInterface) {\n                throw new \\InvalidArgumentException(sprintf('User provider \"%s\" must implement \"%s\".', get_debug_type($provider), UserProviderInterface::class));\n            }\n\n            if (!$provider->supportsClass($userClass)) {\n                continue;\n            }\n\n            try {\n                $refreshedUser = $provider->refreshUser($user);\n                $newToken = clone $token;\n                $newToken->setUser($refreshedUser);\n\n                // tokens can be deauthenticated if the user has been changed.\n                if (!$newToken->isAuthenticated()) {\n                    $userDeauthenticated = true;\n\n                    if (null !== $this->logger) {\n                        // @deprecated since 5.3, change to $refreshedUser->getUserIdentifier() in 6.0\n                        $this->logger->debug('Cannot refresh token because user has changed.', ['username' => method_exists($refreshedUser, 'getUserIdentifier') ? $refreshedUser->getUserIdentifier() : $refreshedUser->getUsername(), 'provider' => \\get_class($provider)]);\n                    }\n\n                    continue;\n                }\n\n                $token->setUser($refreshedUser);\n\n                if (null !== $this->logger) {\n                    // @deprecated since 5.3, change to $refreshedUser->getUserIdentifier() in 6.0\n                    $context = ['provider' => \\get_class($provider), 'username' => method_exists($refreshedUser, 'getUserIdentifier') ? $refreshedUser->getUserIdentifier() : $refreshedUser->getUsername()];\n\n                    if ($token instanceof SwitchUserToken) {\n                        // @deprecated since 5.3, change to $token->getUserIdentifier() in 6.0\n                        $context['impersonator_username'] = method_exists($token, 'getUserIdentifier') ? $token->getUserIdentifier() : $token->getOriginalToken()->getUsername();\n                    }\n\n                    $this->logger->debug('User was reloaded from a user provider.', $context);\n                }\n\n                return $token;\n            } catch (UnsupportedUserException $e) {\n                // let's try the next user provider\n            } catch (UserNotFoundException $e) {\n                if (null !== $this->logger) {\n                    $this->logger->warning('Username could not be found in the selected user provider.', ['username' => method_exists($e, 'getUserIdentifier') ? $e->getUserIdentifier() : $e->getUsername(), 'provider' => \\get_class($provider)]);\n                }\n\n                $userNotFoundByProvider = true;\n            }\n        }\n\n        if ($userDeauthenticated) {\n            if (null !== $this->logger) {\n                $this->logger->debug('Token was deauthenticated after trying to refresh it.');\n            }\n\n            if ($this->dispatcher) {\n                $this->dispatcher->dispatch(new DeauthenticatedEvent($token, $newToken), DeauthenticatedEvent::class);\n            }\n\n            return null;\n        }\n\n        if ($userNotFoundByProvider) {\n            return null;\n        }\n\n        throw new \\RuntimeException(sprintf('There is no user provider for user \"%s\". Shouldn\\'t the \"supportsClass()\" method of your user provider return true for this classname?', $userClass));\n    }\n\n    private function safelyUnserialize(string $serializedToken)\n    {\n        $e = $token = null;\n        $prevUnserializeHandler = ini_set('unserialize_callback_func', __CLASS__.'::handleUnserializeCallback');\n        $prevErrorHandler = set_error_handler(function ($type, $msg, $file, $line, $context = []) use (&$prevErrorHandler) {\n            if (__FILE__ === $file) {\n                throw new \\ErrorException($msg, 0x37313bc, $type, $file, $line);\n            }\n\n            return $prevErrorHandler ? $prevErrorHandler($type, $msg, $file, $line, $context) : false;\n        });\n\n        try {\n            $token = unserialize($serializedToken);\n        } catch (\\Throwable $e) {\n        }\n        restore_error_handler();\n        ini_set('unserialize_callback_func', $prevUnserializeHandler);\n        if ($e) {\n            if (!$e instanceof \\ErrorException || 0x37313bc !== $e->getCode()) {\n                throw $e;\n            }\n            if ($this->logger) {\n                $this->logger->warning('Failed to unserialize the security token from the session.', ['key' => $this->sessionKey, 'received' => $serializedToken, 'exception' => $e]);\n            }\n        }\n\n        return $token;\n    }\n\n    /**\n     * @internal\n     */\n    public static function handleUnserializeCallback($class)\n    {\n        throw new \\ErrorException('Class not found: '.$class, 0x37313bc);\n    }\n\n    public function setRememberMeServices(RememberMeServicesInterface $rememberMeServices)\n    {\n        $this->rememberMeServices = $rememberMeServices;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Tests\\Firewall;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Container\\ContainerInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\AnonymousToken;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorage;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\UsageTrackingTokenStorage;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken;\nuse Symfony\\Component\\Security\\Core\\Exception\\UnsupportedUserException;\nuse Symfony\\Component\\Security\\Core\\Exception\\UserNotFoundException;\nuse Symfony\\Component\\Security\\Core\\User\\InMemoryUser;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\nuse Symfony\\Component\\Security\\Core\\User\\UserProviderInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\DeauthenticatedEvent;\nuse Symfony\\Component\\Security\\Http\\Firewall\\ContextListener;\nuse Symfony\\Component\\Security\\Http\\RememberMe\\RememberMeServicesInterface;\nuse Symfony\\Contracts\\Service\\ServiceLocatorTrait;\n\nclass ContextListenerTest extends TestCase\n{\n    public function testItRequiresContextKey()\n    {\n        $this->expectException(\\InvalidArgumentException::class);\n        $this->expectExceptionMessage('$contextKey must not be empty');\n        new ContextListener(\n            $this->createMock(TokenStorageInterface::class),\n            [],\n            ''\n        );\n    }\n\n    public function testUserProvidersNeedToImplementAnInterface()\n    {\n        $this->expectException(\\InvalidArgumentException::class);\n        $this->expectExceptionMessage('User provider \"stdClass\" must implement \"Symfony\\Component\\Security\\Core\\User\\UserProviderInterface');\n        $this->handleEventWithPreviousSession([new \\stdClass()]);\n    }\n\n    public function testOnKernelResponseWillAddSession()\n    {\n        $session = $this->runSessionOnKernelResponse(\n            new UsernamePasswordToken('test1', 'pass1', 'phpunit'),\n            null\n        );\n\n        $token = unserialize($session->get('_security_session'));\n        $this->assertInstanceOf(UsernamePasswordToken::class, $token);\n        $this->assertEquals('test1', $token->getUserIdentifier());\n    }\n\n    public function testOnKernelResponseWillReplaceSession()\n    {\n        $session = $this->runSessionOnKernelResponse(\n            new UsernamePasswordToken('test1', 'pass1', 'phpunit'),\n            'C:10:\"serialized\"'\n        );\n\n        $token = unserialize($session->get('_security_session'));\n        $this->assertInstanceOf(UsernamePasswordToken::class, $token);\n        $this->assertEquals('test1', $token->getUserIdentifier());\n    }\n\n    public function testOnKernelResponseWillRemoveSession()\n    {\n        $session = $this->runSessionOnKernelResponse(\n            null,\n            'C:10:\"serialized\"'\n        );\n\n        $this->assertFalse($session->has('_security_session'));\n    }\n\n    public function testOnKernelResponseWillRemoveSessionOnAnonymousToken()\n    {\n        $session = $this->runSessionOnKernelResponse(new AnonymousToken('secret', 'anon.'), 'C:10:\"serialized\"');\n\n        $this->assertFalse($session->has('_security_session'));\n    }\n\n    public function testOnKernelResponseWithoutSession()\n    {\n        $tokenStorage = new TokenStorage();\n        $tokenStorage->setToken(new UsernamePasswordToken('test1', 'pass1', 'phpunit'));\n        $request = new Request();\n        $request->attributes->set('_security_firewall_run', '_security_session');\n        $session = new Session(new MockArraySessionStorage());\n        $request->setSession($session);\n\n        $event = new ResponseEvent(\n            $this->createMock(HttpKernelInterface::class),\n            $request,\n            HttpKernelInterface::MAIN_REQUEST,\n            new Response()\n        );\n\n        $listener = new ContextListener($tokenStorage, [], 'session', null, new EventDispatcher());\n        $listener->onKernelResponse($event);\n\n        $this->assertTrue($session->isStarted());\n    }\n\n    public function testOnKernelResponseWithoutSessionNorToken()\n    {\n        $request = new Request();\n        $session = new Session(new MockArraySessionStorage());\n        $request->setSession($session);\n\n        $event = new ResponseEvent(\n            $this->createMock(HttpKernelInterface::class),\n            $request,\n            HttpKernelInterface::MAIN_REQUEST,\n            new Response()\n        );\n\n        $listener = new ContextListener(new TokenStorage(), [], 'session', null, new EventDispatcher());\n        $listener->onKernelResponse($event);\n\n        $this->assertFalse($session->isStarted());\n    }\n\n    /**\n     * @dataProvider provideInvalidToken\n     */\n    public function testInvalidTokenInSession($token)\n    {\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $event = $this->createMock(RequestEvent::class);\n        $session = $this->createMock(SessionInterface::class);\n        $session->expects($this->any())->method('getName')->willReturn('SESSIONNAME');\n        $session->expects($this->any())\n            ->method('get')\n            ->with('_security_key123')\n            ->willReturn($token);\n        $request = new Request([], [], [], ['SESSIONNAME' => true]);\n        $request->setSession($session);\n\n        $event->expects($this->any())\n            ->method('getRequest')\n            ->willReturn($request);\n        $tokenStorage->expects($this->once())\n            ->method('setToken')\n            ->with(null);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123');\n        $listener($event);\n    }\n\n    public function provideInvalidToken()\n    {\n        return [\n            ['foo'],\n            ['O:8:\"NotFound\":0:{}'],\n            [serialize(new \\__PHP_Incomplete_Class())],\n            [serialize(null)],\n            [null],\n        ];\n    }\n\n    public function testHandleAddsKernelResponseListener()\n    {\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $dispatcher = $this->createMock(EventDispatcherInterface::class);\n        $event = $this->createMock(RequestEvent::class);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123', null, $dispatcher);\n\n        $event->expects($this->any())\n            ->method('isMainRequest')\n            ->willReturn(true);\n        $event->expects($this->any())\n            ->method('getRequest')\n            ->willReturn(new Request());\n\n        $dispatcher->expects($this->once())\n            ->method('addListener')\n            ->with(KernelEvents::RESPONSE, [$listener, 'onKernelResponse']);\n\n        $listener($event);\n    }\n\n    public function testOnKernelResponseListenerRemovesItself()\n    {\n        $session = $this->createMock(SessionInterface::class);\n        $session->expects($this->any())->method('getName')->willReturn('SESSIONNAME');\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $dispatcher = $this->createMock(EventDispatcherInterface::class);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123', null, $dispatcher);\n\n        $request = new Request();\n        $request->attributes->set('_security_firewall_run', '_security_key123');\n        $request->setSession($session);\n\n        $event = new ResponseEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST, new Response());\n\n        $dispatcher->expects($this->once())\n            ->method('removeListener')\n            ->with(KernelEvents::RESPONSE, [$listener, 'onKernelResponse']);\n\n        $listener->onKernelResponse($event);\n    }\n\n    public function testHandleRemovesTokenIfNoPreviousSessionWasFound()\n    {\n        $request = new Request();\n\n        $event = $this->createMock(RequestEvent::class);\n        $event->expects($this->any())->method('getRequest')->willReturn($request);\n\n        $tokenStorage = $this->createMock(TokenStorageInterface::class);\n        $tokenStorage->expects($this->once())->method('setToken')->with(null);\n\n        $listener = new ContextListener($tokenStorage, [], 'key123');\n        $listener($event);\n    }\n\n    public function testIfTokenIsDeauthenticated()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)]);\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testIfTokenIsNotDeauthenticated()\n    {\n        $tokenStorage = new TokenStorage();\n        $badRefreshedUser = new InMemoryUser('foobar', 'baz');\n        $goodRefreshedUser = new InMemoryUser('foobar', 'bar');\n        $tokenStorage = $this->handleEventWithPreviousSession([new SupportingUserProvider($badRefreshedUser), new SupportingUserProvider($goodRefreshedUser)], $goodRefreshedUser);\n        $this->assertSame($goodRefreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testRememberMeGetsCanceledIfTokenIsDeauthenticated()\n    {\n        $tokenStorage = new TokenStorage();\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n\n        $rememberMeServices = $this->createMock(RememberMeServicesInterface::class);\n        $rememberMeServices->expects($this->once())->method('loginFail');\n\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], null, $rememberMeServices);\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testTryAllUserProvidersUntilASupportingUserProviderIsFound()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], $refreshedUser);\n\n        $this->assertSame($refreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testNextSupportingUserProviderIsTriedIfPreviousSupportingUserProviderDidNotLoadTheUser()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], $refreshedUser);\n\n        $this->assertSame($refreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testTokenIsSetToNullIfNoUserWasLoadedByTheRegisteredUserProviders()\n    {\n        $tokenStorage = $this->handleEventWithPreviousSession([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider()]);\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testRuntimeExceptionIsThrownIfNoSupportingUserProviderWasRegistered()\n    {\n        $this->expectException(\\RuntimeException::class);\n        $this->handleEventWithPreviousSession([new NotSupportingUserProvider(false), new NotSupportingUserProvider(true)]);\n    }\n\n    public function testAcceptsProvidersAsTraversable()\n    {\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n        $tokenStorage = $this->handleEventWithPreviousSession(new \\ArrayObject([new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)]), $refreshedUser);\n\n        $this->assertSame($refreshedUser, $tokenStorage->getToken()->getUser());\n    }\n\n    public function testDeauthenticatedEvent()\n    {\n        $tokenStorage = new TokenStorage();\n        $refreshedUser = new InMemoryUser('foobar', 'baz');\n\n        $user = new InMemoryUser('foo', 'bar');\n        $session = new Session(new MockArraySessionStorage());\n        $session->set('_security_context_key', serialize(new UsernamePasswordToken($user, '', 'context_key', ['ROLE_USER'])));\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n\n        $eventDispatcher = new EventDispatcher();\n        $eventDispatcher->addListener(DeauthenticatedEvent::class, function (DeauthenticatedEvent $event) use ($user) {\n            $this->assertTrue($event->getOriginalToken()->isAuthenticated());\n            $this->assertEquals($event->getOriginalToken()->getUser(), $user);\n            $this->assertFalse($event->getRefreshedToken()->isAuthenticated());\n            $this->assertNotEquals($event->getRefreshedToken()->getUser(), $user);\n        });\n\n        $listener = new ContextListener($tokenStorage, [new NotSupportingUserProvider(true), new NotSupportingUserProvider(false), new SupportingUserProvider($refreshedUser)], 'context_key', null, $eventDispatcher);\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n\n        $this->assertNull($tokenStorage->getToken());\n    }\n\n    public function testWithPreviousNotStartedSession()\n    {\n        $session = new Session(new MockArraySessionStorage());\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n\n        $usageIndex = $session->getUsageIndex();\n\n        $tokenStorage = new TokenStorage();\n        $listener = new ContextListener($tokenStorage, [], 'context_key', null, null, null, [$tokenStorage, 'getToken']);\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n\n        $this->assertSame($usageIndex, $session->getUsageIndex());\n    }\n\n    public function testSessionIsNotReported()\n    {\n        $usageReporter = $this->getMockBuilder(\\stdClass::class)->setMethods(['__invoke'])->getMock();\n        $usageReporter->expects($this->never())->method('__invoke');\n\n        $session = new Session(new MockArraySessionStorage(), null, null, $usageReporter);\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n\n        $tokenStorage = new TokenStorage();\n\n        $listener = new ContextListener($tokenStorage, [], 'context_key', null, null, null, [$tokenStorage, 'getToken']);\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n    }\n\n    protected function runSessionOnKernelResponse($newToken, $original = null)\n    {\n        $session = new Session(new MockArraySessionStorage());\n        $request = new Request();\n        $request->attributes->set('_security_firewall_run', '_security_session');\n        $request->setSession($session);\n        $requestStack = new RequestStack();\n        $requestStack->push($request);\n\n        if (null !== $original) {\n            $session->set('_security_session', $original);\n        }\n\n        $tokenStorage = new UsageTrackingTokenStorage(new TokenStorage(), new class(['request_stack' => function () use ($requestStack) {\n            return $requestStack;\n        },\n        ]) implements ContainerInterface {\n            use ServiceLocatorTrait;\n        });\n\n        $tokenStorage->setToken($newToken);\n\n        $request->cookies->set('MOCKSESSID', true);\n\n        $sessionId = $session->getId();\n        $usageIndex = $session->getUsageIndex();\n\n        $event = new ResponseEvent(\n            $this->createMock(HttpKernelInterface::class),\n            $request,\n            HttpKernelInterface::MAIN_REQUEST,\n            new Response()\n        );\n\n        $listener = new ContextListener($tokenStorage, [], 'session', null, new EventDispatcher(), null, [$tokenStorage, 'enableUsageTracking']);\n        $listener->onKernelResponse($event);\n\n        if ($session->getId() === $sessionId) {\n            $this->assertSame($usageIndex, $session->getUsageIndex());\n        } else {\n            $this->assertNotSame($usageIndex, $session->getUsageIndex());\n        }\n\n        return $session;\n    }\n\n    private function handleEventWithPreviousSession($userProviders, UserInterface $user = null, RememberMeServicesInterface $rememberMeServices = null)\n    {\n        $tokenUser = $user ?? new InMemoryUser('foo', 'bar');\n        $session = new Session(new MockArraySessionStorage());\n        $session->set('_security_context_key', serialize(new UsernamePasswordToken($tokenUser, '', 'context_key', ['ROLE_USER'])));\n\n        $request = new Request();\n        $request->setSession($session);\n        $request->cookies->set('MOCKSESSID', true);\n        $requestStack = new RequestStack();\n        $requestStack->push($request);\n\n        $tokenStorage = new TokenStorage();\n        $usageIndex = $session->getUsageIndex();\n        $tokenStorage = new UsageTrackingTokenStorage($tokenStorage, new class(\n            (new \\ReflectionClass(UsageTrackingTokenStorage::class))->hasMethod('getSession') ? [\n                'request_stack' => function () use ($requestStack) {\n                return $requestStack;\n            }] : [\n                // BC for symfony/framework-bundle < 5.3\n                'session' => function () use ($session) {\n                    return $session;\n                },\n            ]\n        ) implements ContainerInterface {\n            use ServiceLocatorTrait;\n        });\n        $sessionTrackerEnabler = [$tokenStorage, 'enableUsageTracking'];\n\n        $listener = new ContextListener($tokenStorage, $userProviders, 'context_key', null, null, null, $sessionTrackerEnabler);\n\n        if ($rememberMeServices) {\n            $listener->setRememberMeServices($rememberMeServices);\n        }\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MAIN_REQUEST));\n\n        if (null !== $user) {\n            ++$usageIndex;\n        }\n\n        $this->assertSame($usageIndex, $session->getUsageIndex());\n        $tokenStorage->getToken();\n        $this->assertSame(1 + $usageIndex, $session->getUsageIndex());\n\n        return $tokenStorage;\n    }\n}\n\nclass NotSupportingUserProvider implements UserProviderInterface\n{\n    /** @var bool */\n    private $throwsUnsupportedException;\n\n    public function __construct($throwsUnsupportedException)\n    {\n        $this->throwsUnsupportedException = $throwsUnsupportedException;\n    }\n\n    public function loadUserByUsername($username): UserInterface\n    {\n        throw new UserNotFoundException();\n    }\n\n    public function loadUserByIdentifier(string $identifier): UserInterface\n    {\n        throw new UserNotFoundException();\n    }\n\n    public function refreshUser(UserInterface $user): UserInterface\n    {\n        if ($this->throwsUnsupportedException) {\n            throw new UnsupportedUserException();\n        }\n\n        return $user;\n    }\n\n    public function supportsClass($class): bool\n    {\n        return false;\n    }\n}\n\nclass SupportingUserProvider implements UserProviderInterface\n{\n    private $refreshedUser;\n\n    public function __construct(InMemoryUser $refreshedUser = null)\n    {\n        $this->refreshedUser = $refreshedUser;\n    }\n\n    public function loadUserByUsername($username): UserInterface\n    {\n    }\n\n    public function loadUserByIdentifier(string $identifier): UserInterface\n    {\n    }\n\n    public function refreshUser(UserInterface $user): UserInterface\n    {\n        if (!$user instanceof InMemoryUser) {\n            throw new UnsupportedUserException();\n        }\n\n        if (null === $this->refreshedUser) {\n            throw new UserNotFoundException();\n        }\n\n        return $this->refreshedUser;\n    }\n\n    public function supportsClass($class): bool\n    {\n        return InMemoryUser::class === $class;\n    }\n}\n"], "filenames": ["Firewall/ContextListener.php", "Tests/Firewall/ContextListenerTest.php"], "buggy_code_start_loc": [98, 109], "buggy_code_end_loc": [173, 374], "fixing_code_start_loc": [98, 109], "fixing_code_end_loc": [173, 374], "type": "CWE-287", "message": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. A vulnerability related to firewall authentication is in Symfony starting with version 5.3.0 and prior to 5.3.2. When an application defines multiple firewalls, the token authenticated by one of the firewalls was available for all other firewalls. This could be abused when the application defines different providers for each part of the application, in such a situation, a user authenticated on a part of the application could be considered authenticated on the rest of the application. Starting in version 5.3.2, a patch ensures that the authenticated token is only available for the firewall that generates it.", "other": {"cve": {"id": "CVE-2021-32693", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-17T23:15:07.597", "lastModified": "2021-06-24T19:00:31.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. A vulnerability related to firewall authentication is in Symfony starting with version 5.3.0 and prior to 5.3.2. When an application defines multiple firewalls, the token authenticated by one of the firewalls was available for all other firewalls. This could be abused when the application defines different providers for each part of the application, in such a situation, a user authenticated on a part of the application could be considered authenticated on the rest of the application. Starting in version 5.3.2, a patch ensures that the authenticated token is only available for the firewall that generates it."}, {"lang": "es", "value": "Symfony es un framework PHP para aplicaciones web y de consola y un ajuste de componentes PHP reutilizables. Una vulnerabilidad relacionada con la autenticaci\u00f3n del firewall se presenta en Symfony a partir de versi\u00f3n 5.3.0 y anteriores a 5.3.2. Cuando una aplicaci\u00f3n define m\u00faltiples firewalls, el token autenticado por uno de los firewalls estaba disponible para todos los otros firewalls. Esto podr\u00eda ser abusado cuando la aplicaci\u00f3n define diferentes proveedores para cada parte de la aplicaci\u00f3n, en tal situaci\u00f3n, un usuario autenticado en una parte de la aplicaci\u00f3n podr\u00eda ser considerado autenticado en el resto de la aplicaci\u00f3n. A partir de versi\u00f3n 5.3.2, un parche asegura que el token autenticado s\u00f3lo est\u00e1 disponible para el firewall que lo genera"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.3.0", "versionEndExcluding": "5.3.2", "matchCriteriaId": "62EC75F1-EC6A-45F1-99A0-BA5CD24E246F"}]}]}], "references": [{"url": "https://github.com/symfony/security-http/commit/6bf4c31219773a558b019ee12e54572174ff8129", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/commit/3084764ad82f29dbb025df19978b9cbc3ab34728", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-rfcf-m67m-jcrq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://symfony.com/blog/cve-2021-32693-authentication-granted-to-all-firewalls-instead-of-just-one", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/symfony/security-http/commit/6bf4c31219773a558b019ee12e54572174ff8129"}}