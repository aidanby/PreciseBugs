{"buggy_code": ["\"\"\"\n.. module: dispatch.plugins.dispatch_core.plugin\n    :platform: Unix\n    :copyright: (c) 2019 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n\"\"\"\nimport base64\nimport json\nimport logging\n\nimport requests\nfrom fastapi import HTTPException\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom jose import JWTError, jwt\nfrom jose.exceptions import JWKError\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_401_UNAUTHORIZED\n\nfrom dispatch.case import service as case_service\nfrom dispatch.config import (\n    DISPATCH_AUTHENTICATION_PROVIDER_HEADER_NAME,\n    DISPATCH_AUTHENTICATION_PROVIDER_PKCE_JWKS,\n    DISPATCH_JWT_AUDIENCE,\n    DISPATCH_JWT_EMAIL_OVERRIDE,\n    DISPATCH_JWT_SECRET,\n    DISPATCH_PKCE_DONT_VERIFY_AT_HASH,\n    DISPATCH_UI_URL,\n)\nfrom dispatch.database.core import Base\nfrom dispatch.document.models import Document, DocumentRead\nfrom dispatch.incident import service as incident_service\nfrom dispatch.incident.models import Incident\nfrom dispatch.individual import service as individual_service\nfrom dispatch.individual.models import IndividualContact, IndividualContactRead\nfrom dispatch.plugin import service as plugin_service\nfrom dispatch.plugins import dispatch_core as dispatch_plugin\nfrom dispatch.plugins.bases import (\n    AuthenticationProviderPlugin,\n    ContactPlugin,\n    DocumentResolverPlugin,\n    ParticipantPlugin,\n    TicketPlugin,\n)\nfrom dispatch.route import service as route_service\nfrom dispatch.service import service as service_service\nfrom dispatch.service.models import Service, ServiceRead\nfrom dispatch.team import service as team_service\nfrom dispatch.team.models import TeamContact, TeamContactRead\n\nlog = logging.getLogger(__name__)\n\n\nclass BasicAuthProviderPlugin(AuthenticationProviderPlugin):\n    title = \"Dispatch Plugin - Basic Authentication Provider\"\n    slug = \"dispatch-auth-provider-basic\"\n    description = \"Generic basic authentication provider.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get_current_user(self, request: Request, **kwargs):\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            log.exception(\n                f\"Malformed authorization header. Scheme: {scheme} Param: {param} Authorization: {authorization}\"\n            )\n            return\n\n        token = authorization.split()[1]\n\n        try:\n            data = jwt.decode(token, DISPATCH_JWT_SECRET)\n        except (JWKError, JWTError) as e:\n            raise HTTPException(\n                status_code=HTTP_401_UNAUTHORIZED, detail=[{\"msg\": str(e)}]\n            ) from None\n        return data[\"email\"]\n\n\nclass PKCEAuthProviderPlugin(AuthenticationProviderPlugin):\n    title = \"Dispatch Plugin - PKCE Authentication Provider\"\n    slug = \"dispatch-auth-provider-pkce\"\n    description = \"Generic PCKE authentication provider.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get_current_user(self, request: Request, **kwargs):\n        credentials_exception = HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED, detail=[{\"msg\": \"Could not validate credentials\"}]\n        )\n\n        authorization: str = request.headers.get(\n            \"Authorization\", request.headers.get(\"authorization\")\n        )\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            raise credentials_exception\n\n        token = authorization.split()[1]\n\n        # Parse out the Key information. Add padding just in case\n        key_info = json.loads(base64.b64decode(token.split(\".\")[0] + \"=========\").decode(\"utf-8\"))\n\n        # Grab all possible keys to account for key rotation and find the right key\n        keys = requests.get(DISPATCH_AUTHENTICATION_PROVIDER_PKCE_JWKS).json()[\"keys\"]\n        for potential_key in keys:\n            if potential_key[\"kid\"] == key_info[\"kid\"]:\n                key = potential_key\n\n        try:\n            jwt_opts = {}\n            if DISPATCH_PKCE_DONT_VERIFY_AT_HASH:\n                jwt_opts = {\"verify_at_hash\": False}\n            # If DISPATCH_JWT_AUDIENCE is defined, the we must include audience in the decode\n            if DISPATCH_JWT_AUDIENCE:\n                data = jwt.decode(token, key, audience=DISPATCH_JWT_AUDIENCE, options=jwt_opts)\n            else:\n                data = jwt.decode(token, key, options=jwt_opts)\n        except JWTError as err:\n            log.debug(\"JWT Decode error: {}\".format(err))\n            raise credentials_exception from err\n\n        # Support overriding where email is returned in the id token\n        if DISPATCH_JWT_EMAIL_OVERRIDE:\n            return data[DISPATCH_JWT_EMAIL_OVERRIDE]\n        else:\n            return data[\"email\"]\n\n\nclass HeaderAuthProviderPlugin(AuthenticationProviderPlugin):\n    title = \"Dispatch Plugin - HTTP Header Authentication Provider\"\n    slug = \"dispatch-auth-provider-header\"\n    description = \"Authenticate users based on HTTP request header.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Filippo Giunchedi\"\n    author_url = \"https://github.com/filippog\"\n\n    def get_current_user(self, request: Request, **kwargs):\n        value: str = request.headers.get(DISPATCH_AUTHENTICATION_PROVIDER_HEADER_NAME)\n        if not value:\n            log.error(\n                f\"Unable to authenticate. Header {DISPATCH_AUTHENTICATION_PROVIDER_HEADER_NAME} not found.\"\n            )\n            raise HTTPException(status_code=HTTP_401_UNAUTHORIZED)\n        return value\n\n\nclass DispatchTicketPlugin(TicketPlugin):\n    title = \"Dispatch Plugin - Ticket Management\"\n    slug = \"dispatch-ticket\"\n    description = \"Uses Dispatch itself to create a ticket.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def create(\n        self,\n        incident_id: int,\n        title: str,\n        commander_email: str,\n        reporter_email: str,\n        plugin_metadata: dict,\n        db_session=None,\n    ):\n        \"\"\"Creates a Dispatch incident ticket.\"\"\"\n        incident = incident_service.get(db_session=db_session, incident_id=incident_id)\n\n        resource_id = (\n            f\"dispatch-{incident.project.organization.slug}-{incident.project.slug}-{incident.id}\"\n        )\n        return {\n            \"resource_id\": resource_id,\n            \"weblink\": f\"{DISPATCH_UI_URL}/{incident.project.organization.name}/incidents/{resource_id}?project={incident.project.name}\",\n            \"resource_type\": \"dispatch-internal-ticket\",\n        }\n\n    def update(\n        self,\n        ticket_id: str,\n        title: str,\n        description: str,\n        incident_type: str,\n        incident_severity: str,\n        incident_priority: str,\n        status: str,\n        commander_email: str,\n        reporter_email: str,\n        conversation_weblink: str,\n        document_weblink: str,\n        storage_weblink: str,\n        conference_weblink: str,\n        cost: float,\n        incident_type_plugin_metadata: dict = None,\n    ):\n        \"\"\"Updates a Dispatch incident ticket.\"\"\"\n        return\n\n    def delete(\n        self,\n        ticket_id: str,\n    ):\n        \"\"\"Deletes a Dispatch ticket.\"\"\"\n        return\n\n    def create_case_ticket(\n        self,\n        case_id: int,\n        title: str,\n        assignee_email: str,\n        # reporter: str,\n        case_type_plugin_metadata: dict,\n        db_session=None,\n    ):\n        \"\"\"Creates a Dispatch case ticket.\"\"\"\n        case = case_service.get(db_session=db_session, case_id=case_id)\n\n        resource_id = f\"dispatch-{case.project.organization.slug}-{case.project.slug}-{case.id}\"\n\n        return {\n            \"resource_id\": resource_id,\n            \"weblink\": f\"{DISPATCH_UI_URL}/{case.project.organization.name}/cases/{resource_id}?project={case.project.name}\",\n            \"resource_type\": \"dispatch-internal-ticket\",\n        }\n\n    def update_case_ticket(\n        self,\n        ticket_id: str,\n        title: str,\n        description: str,\n        resolution: str,\n        case_type: str,\n        case_severity: str,\n        case_priority: str,\n        status: str,\n        assignee_email: str,\n        # reporter_email: str,\n        document_weblink: str,\n        storage_weblink: str,\n        case_type_plugin_metadata: dict = None,\n    ):\n        \"\"\"Updates a Dispatch case ticket.\"\"\"\n        return\n\n\nclass DispatchDocumentResolverPlugin(DocumentResolverPlugin):\n    title = \"Dispatch Plugin - Document Resolver\"\n    slug = \"dispatch-document-resolver\"\n    description = \"Uses dispatch itself to resolve incident documents.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get(\n        self,\n        incident: Incident,\n        db_session=None,\n    ):\n        \"\"\"Fetches documents from Dispatch.\"\"\"\n        recommendation = route_service.get(\n            db_session=db_session,\n            project_id=incident.project_id,\n            class_instance=incident,\n            models=[(Document, DocumentRead)],\n        )\n        return recommendation.matches\n\n\nclass DispatchContactPlugin(ContactPlugin):\n    title = \"Dispatch Plugin - Contact plugin\"\n    slug = \"dispatch-contact\"\n    description = \"Uses dispatch itself to fetch incident participants contact info.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get(self, email, db_session=None):\n        individual = individual_service.get_by_email_and_project(\n            db_session=db_session, email=email, project_id=self.project_id\n        )\n        if individual is None:\n            return {\"email\": email, \"fullname\": email}\n\n        data = individual.dict()\n        data[\"fullname\"] = data[\"name\"]\n        return data\n\n\nclass DispatchParticipantResolverPlugin(ParticipantPlugin):\n    title = \"Dispatch Plugin - Participant Resolver\"\n    slug = \"dispatch-participant-resolver\"\n    description = \"Uses dispatch itself to resolve incident participants.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get(\n        self,\n        project_id: int,\n        class_instance: Base,\n        db_session=None,\n    ):\n        \"\"\"Fetches participants from Dispatch.\"\"\"\n        models = [\n            (IndividualContact, IndividualContactRead),\n            (Service, ServiceRead),\n            (TeamContact, TeamContactRead),\n        ]\n        recommendation = route_service.get(\n            db_session=db_session,\n            project_id=project_id,\n            class_instance=class_instance,\n            models=models,\n        )\n\n        log.debug(f\"Recommendation: {recommendation}\")\n\n        individual_contacts = []\n        team_contacts = []\n        for match in recommendation.matches:\n            if match.resource_type == TeamContact.__name__:\n                team = team_service.get_or_create(\n                    db_session=db_session,\n                    email=match.resource_state[\"email\"],\n                    project=class_instance.project,\n                )\n                team_contacts.append(team)\n\n            if match.resource_type == IndividualContact.__name__:\n                individual = individual_service.get_or_create(\n                    db_session=db_session,\n                    email=match.resource_state[\"email\"],\n                    project=class_instance.project,\n                )\n\n                individual_contacts.append((individual, None))\n\n            # we need to do more work when we have a service\n            if match.resource_type == Service.__name__:\n                plugin_instance = plugin_service.get_active_instance_by_slug(\n                    db_session=db_session,\n                    slug=match.resource_state[\"type\"],\n                    project_id=project_id,\n                )\n\n                if plugin_instance:\n                    if plugin_instance.enabled:\n                        log.debug(\n                            f\"Resolving service contact. ServiceContact: {match.resource_state}\"\n                        )\n                        # ensure that service is enabled\n                        service = service_service.get_by_external_id_and_project_id(\n                            db_session=db_session,\n                            external_id=match.resource_state[\"external_id\"],\n                            project_id=project_id,\n                        )\n                        if service.is_active:\n                            individual_email = plugin_instance.instance.get(\n                                match.resource_state[\"external_id\"]\n                            )\n\n                            individual = individual_service.get_or_create(\n                                db_session=db_session,\n                                email=individual_email,\n                                project=class_instance.project,\n                            )\n\n                            individual_contacts.append((individual, match.resource_state[\"id\"]))\n                    else:\n                        log.warning(\n                            f\"Skipping service contact. Service: {match.resource_state['name']} Reason: Associated service plugin not enabled.\"\n                        )\n                else:\n                    log.warning(\n                        f\"Skipping service contact. Service: {match.resource_state['name']} Reason: Associated service plugin not found.\"\n                    )\n\n        db_session.commit()\n        return individual_contacts, team_contacts\n"], "fixing_code": ["\"\"\"\n.. module: dispatch.plugins.dispatch_core.plugin\n    :platform: Unix\n    :copyright: (c) 2019 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n\"\"\"\nimport base64\nimport json\nimport logging\n\nimport requests\nfrom fastapi import HTTPException\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom jose import JWTError, jwt\nfrom jose.exceptions import JWKError\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_401_UNAUTHORIZED\n\nfrom dispatch.case import service as case_service\nfrom dispatch.config import (\n    DISPATCH_AUTHENTICATION_PROVIDER_HEADER_NAME,\n    DISPATCH_AUTHENTICATION_PROVIDER_PKCE_JWKS,\n    DISPATCH_JWT_AUDIENCE,\n    DISPATCH_JWT_EMAIL_OVERRIDE,\n    DISPATCH_JWT_SECRET,\n    DISPATCH_PKCE_DONT_VERIFY_AT_HASH,\n    DISPATCH_UI_URL,\n)\nfrom dispatch.database.core import Base\nfrom dispatch.document.models import Document, DocumentRead\nfrom dispatch.incident import service as incident_service\nfrom dispatch.incident.models import Incident\nfrom dispatch.individual import service as individual_service\nfrom dispatch.individual.models import IndividualContact, IndividualContactRead\nfrom dispatch.plugin import service as plugin_service\nfrom dispatch.plugins import dispatch_core as dispatch_plugin\nfrom dispatch.plugins.bases import (\n    AuthenticationProviderPlugin,\n    ContactPlugin,\n    DocumentResolverPlugin,\n    ParticipantPlugin,\n    TicketPlugin,\n)\nfrom dispatch.route import service as route_service\nfrom dispatch.service import service as service_service\nfrom dispatch.service.models import Service, ServiceRead\nfrom dispatch.team import service as team_service\nfrom dispatch.team.models import TeamContact, TeamContactRead\n\nlog = logging.getLogger(__name__)\n\n\nclass BasicAuthProviderPlugin(AuthenticationProviderPlugin):\n    title = \"Dispatch Plugin - Basic Authentication Provider\"\n    slug = \"dispatch-auth-provider-basic\"\n    description = \"Generic basic authentication provider.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get_current_user(self, request: Request, **kwargs):\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            log.exception(\n                f\"Malformed authorization header. Scheme: {scheme} Param: {param} Authorization: {authorization}\"\n            )\n            return\n\n        token = authorization.split()[1]\n\n        try:\n            data = jwt.decode(token, DISPATCH_JWT_SECRET)\n        except (JWKError, JWTError):\n            raise HTTPException(\n                status_code=HTTP_401_UNAUTHORIZED,\n                detail=[{\"msg\": \"Could not validate credentials\"}],\n            ) from None\n        return data[\"email\"]\n\n\nclass PKCEAuthProviderPlugin(AuthenticationProviderPlugin):\n    title = \"Dispatch Plugin - PKCE Authentication Provider\"\n    slug = \"dispatch-auth-provider-pkce\"\n    description = \"Generic PCKE authentication provider.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get_current_user(self, request: Request, **kwargs):\n        credentials_exception = HTTPException(\n            status_code=HTTP_401_UNAUTHORIZED, detail=[{\"msg\": \"Could not validate credentials\"}]\n        )\n\n        authorization: str = request.headers.get(\n            \"Authorization\", request.headers.get(\"authorization\")\n        )\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            raise credentials_exception\n\n        token = authorization.split()[1]\n\n        # Parse out the Key information. Add padding just in case\n        key_info = json.loads(base64.b64decode(token.split(\".\")[0] + \"=========\").decode(\"utf-8\"))\n\n        # Grab all possible keys to account for key rotation and find the right key\n        keys = requests.get(DISPATCH_AUTHENTICATION_PROVIDER_PKCE_JWKS).json()[\"keys\"]\n        for potential_key in keys:\n            if potential_key[\"kid\"] == key_info[\"kid\"]:\n                key = potential_key\n\n        try:\n            jwt_opts = {}\n            if DISPATCH_PKCE_DONT_VERIFY_AT_HASH:\n                jwt_opts = {\"verify_at_hash\": False}\n            # If DISPATCH_JWT_AUDIENCE is defined, the we must include audience in the decode\n            if DISPATCH_JWT_AUDIENCE:\n                data = jwt.decode(token, key, audience=DISPATCH_JWT_AUDIENCE, options=jwt_opts)\n            else:\n                data = jwt.decode(token, key, options=jwt_opts)\n        except JWTError as err:\n            log.debug(\"JWT Decode error: {}\".format(err))\n            raise credentials_exception from err\n\n        # Support overriding where email is returned in the id token\n        if DISPATCH_JWT_EMAIL_OVERRIDE:\n            return data[DISPATCH_JWT_EMAIL_OVERRIDE]\n        else:\n            return data[\"email\"]\n\n\nclass HeaderAuthProviderPlugin(AuthenticationProviderPlugin):\n    title = \"Dispatch Plugin - HTTP Header Authentication Provider\"\n    slug = \"dispatch-auth-provider-header\"\n    description = \"Authenticate users based on HTTP request header.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Filippo Giunchedi\"\n    author_url = \"https://github.com/filippog\"\n\n    def get_current_user(self, request: Request, **kwargs):\n        value: str = request.headers.get(DISPATCH_AUTHENTICATION_PROVIDER_HEADER_NAME)\n        if not value:\n            log.error(\n                f\"Unable to authenticate. Header {DISPATCH_AUTHENTICATION_PROVIDER_HEADER_NAME} not found.\"\n            )\n            raise HTTPException(status_code=HTTP_401_UNAUTHORIZED)\n        return value\n\n\nclass DispatchTicketPlugin(TicketPlugin):\n    title = \"Dispatch Plugin - Ticket Management\"\n    slug = \"dispatch-ticket\"\n    description = \"Uses Dispatch itself to create a ticket.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def create(\n        self,\n        incident_id: int,\n        title: str,\n        commander_email: str,\n        reporter_email: str,\n        plugin_metadata: dict,\n        db_session=None,\n    ):\n        \"\"\"Creates a Dispatch incident ticket.\"\"\"\n        incident = incident_service.get(db_session=db_session, incident_id=incident_id)\n\n        resource_id = (\n            f\"dispatch-{incident.project.organization.slug}-{incident.project.slug}-{incident.id}\"\n        )\n        return {\n            \"resource_id\": resource_id,\n            \"weblink\": f\"{DISPATCH_UI_URL}/{incident.project.organization.name}/incidents/{resource_id}?project={incident.project.name}\",\n            \"resource_type\": \"dispatch-internal-ticket\",\n        }\n\n    def update(\n        self,\n        ticket_id: str,\n        title: str,\n        description: str,\n        incident_type: str,\n        incident_severity: str,\n        incident_priority: str,\n        status: str,\n        commander_email: str,\n        reporter_email: str,\n        conversation_weblink: str,\n        document_weblink: str,\n        storage_weblink: str,\n        conference_weblink: str,\n        cost: float,\n        incident_type_plugin_metadata: dict = None,\n    ):\n        \"\"\"Updates a Dispatch incident ticket.\"\"\"\n        return\n\n    def delete(\n        self,\n        ticket_id: str,\n    ):\n        \"\"\"Deletes a Dispatch ticket.\"\"\"\n        return\n\n    def create_case_ticket(\n        self,\n        case_id: int,\n        title: str,\n        assignee_email: str,\n        # reporter: str,\n        case_type_plugin_metadata: dict,\n        db_session=None,\n    ):\n        \"\"\"Creates a Dispatch case ticket.\"\"\"\n        case = case_service.get(db_session=db_session, case_id=case_id)\n\n        resource_id = f\"dispatch-{case.project.organization.slug}-{case.project.slug}-{case.id}\"\n\n        return {\n            \"resource_id\": resource_id,\n            \"weblink\": f\"{DISPATCH_UI_URL}/{case.project.organization.name}/cases/{resource_id}?project={case.project.name}\",\n            \"resource_type\": \"dispatch-internal-ticket\",\n        }\n\n    def update_case_ticket(\n        self,\n        ticket_id: str,\n        title: str,\n        description: str,\n        resolution: str,\n        case_type: str,\n        case_severity: str,\n        case_priority: str,\n        status: str,\n        assignee_email: str,\n        # reporter_email: str,\n        document_weblink: str,\n        storage_weblink: str,\n        case_type_plugin_metadata: dict = None,\n    ):\n        \"\"\"Updates a Dispatch case ticket.\"\"\"\n        return\n\n\nclass DispatchDocumentResolverPlugin(DocumentResolverPlugin):\n    title = \"Dispatch Plugin - Document Resolver\"\n    slug = \"dispatch-document-resolver\"\n    description = \"Uses dispatch itself to resolve incident documents.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get(\n        self,\n        incident: Incident,\n        db_session=None,\n    ):\n        \"\"\"Fetches documents from Dispatch.\"\"\"\n        recommendation = route_service.get(\n            db_session=db_session,\n            project_id=incident.project_id,\n            class_instance=incident,\n            models=[(Document, DocumentRead)],\n        )\n        return recommendation.matches\n\n\nclass DispatchContactPlugin(ContactPlugin):\n    title = \"Dispatch Plugin - Contact plugin\"\n    slug = \"dispatch-contact\"\n    description = \"Uses dispatch itself to fetch incident participants contact info.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get(self, email, db_session=None):\n        individual = individual_service.get_by_email_and_project(\n            db_session=db_session, email=email, project_id=self.project_id\n        )\n        if individual is None:\n            return {\"email\": email, \"fullname\": email}\n\n        data = individual.dict()\n        data[\"fullname\"] = data[\"name\"]\n        return data\n\n\nclass DispatchParticipantResolverPlugin(ParticipantPlugin):\n    title = \"Dispatch Plugin - Participant Resolver\"\n    slug = \"dispatch-participant-resolver\"\n    description = \"Uses dispatch itself to resolve incident participants.\"\n    version = dispatch_plugin.__version__\n\n    author = \"Netflix\"\n    author_url = \"https://github.com/netflix/dispatch.git\"\n\n    def get(\n        self,\n        project_id: int,\n        class_instance: Base,\n        db_session=None,\n    ):\n        \"\"\"Fetches participants from Dispatch.\"\"\"\n        models = [\n            (IndividualContact, IndividualContactRead),\n            (Service, ServiceRead),\n            (TeamContact, TeamContactRead),\n        ]\n        recommendation = route_service.get(\n            db_session=db_session,\n            project_id=project_id,\n            class_instance=class_instance,\n            models=models,\n        )\n\n        log.debug(f\"Recommendation: {recommendation}\")\n\n        individual_contacts = []\n        team_contacts = []\n        for match in recommendation.matches:\n            if match.resource_type == TeamContact.__name__:\n                team = team_service.get_or_create(\n                    db_session=db_session,\n                    email=match.resource_state[\"email\"],\n                    project=class_instance.project,\n                )\n                team_contacts.append(team)\n\n            if match.resource_type == IndividualContact.__name__:\n                individual = individual_service.get_or_create(\n                    db_session=db_session,\n                    email=match.resource_state[\"email\"],\n                    project=class_instance.project,\n                )\n\n                individual_contacts.append((individual, None))\n\n            # we need to do more work when we have a service\n            if match.resource_type == Service.__name__:\n                plugin_instance = plugin_service.get_active_instance_by_slug(\n                    db_session=db_session,\n                    slug=match.resource_state[\"type\"],\n                    project_id=project_id,\n                )\n\n                if plugin_instance:\n                    if plugin_instance.enabled:\n                        log.debug(\n                            f\"Resolving service contact. ServiceContact: {match.resource_state}\"\n                        )\n                        # ensure that service is enabled\n                        service = service_service.get_by_external_id_and_project_id(\n                            db_session=db_session,\n                            external_id=match.resource_state[\"external_id\"],\n                            project_id=project_id,\n                        )\n                        if service.is_active:\n                            individual_email = plugin_instance.instance.get(\n                                match.resource_state[\"external_id\"]\n                            )\n\n                            individual = individual_service.get_or_create(\n                                db_session=db_session,\n                                email=individual_email,\n                                project=class_instance.project,\n                            )\n\n                            individual_contacts.append((individual, match.resource_state[\"id\"]))\n                    else:\n                        log.warning(\n                            f\"Skipping service contact. Service: {match.resource_state['name']} Reason: Associated service plugin not enabled.\"\n                        )\n                else:\n                    log.warning(\n                        f\"Skipping service contact. Service: {match.resource_state['name']} Reason: Associated service plugin not found.\"\n                    )\n\n        db_session.commit()\n        return individual_contacts, team_contacts\n"], "filenames": ["src/dispatch/plugins/dispatch_core/plugin.py"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [78], "fixing_code_start_loc": [75], "fixing_code_end_loc": [79], "type": "CWE-209", "message": "Dispatch is an open source security incident management tool. The server response includes the JWT Secret Key used for signing JWT tokens in error message when the `Dispatch Plugin - Basic Authentication Provider` plugin encounters an error when attempting to decode a JWT token. Any Dispatch users who own their instance and rely on the `Dispatch Plugin - Basic Authentication Provider` plugin for authentication may be impacted, allowing for any account to be taken over within their own instance. This could be done by using the secret to sign attacker crafted JWTs. If you think that you may be impacted, we strongly suggest you to rotate the secret stored in the `DISPATCH_JWT_SECRET` envvar in the `.env` file. This issue has been addressed in commit `b1942a4319` which has been included in the `20230817` release. users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-40171", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-17T22:15:10.087", "lastModified": "2023-08-24T15:11:33.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dispatch is an open source security incident management tool. The server response includes the JWT Secret Key used for signing JWT tokens in error message when the `Dispatch Plugin - Basic Authentication Provider` plugin encounters an error when attempting to decode a JWT token. Any Dispatch users who own their instance and rely on the `Dispatch Plugin - Basic Authentication Provider` plugin for authentication may be impacted, allowing for any account to be taken over within their own instance. This could be done by using the secret to sign attacker crafted JWTs. If you think that you may be impacted, we strongly suggest you to rotate the secret stored in the `DISPATCH_JWT_SECRET` envvar in the `.env` file. This issue has been addressed in commit `b1942a4319` which has been included in the `20230817` release. users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Dispatch es una herramienta de gesti\u00f3n de incidentes de seguridad de c\u00f3digo abierto. La respuesta del servidor incluye la clave secreta JWT utilizada para firmar tokens JWT en el mensaje de error cuando el plugin `Dispatch Plugin - Basic Authentication Provider` encuentra un error al intentar decodificar un token JWT. Cualquier usuario de Dispatch que posea su propia instancia y conf\u00ede en el plugin `Dispatch Plugin - Basic Authentication Provider` para la autenticaci\u00f3n puede verse afectado, permitiendo que cualquier cuenta sea tomada dentro de su propia instancia. Esto podr\u00eda hacerse utilizando el secreto para firmar JWTs manipulados por atacantes. Si cree que puede verse afectado, le recomendamos encarecidamente que rote el secreto almacenado en la envvar `DISPATCH_JWT_SECRET` del archivo `.env`. Este problema se ha solucionado en el commit `b1942a4319` que se ha incluido en la versi\u00f3n `20230817`. Se recomienda a los usuarios que actualicen. No se conocen soluciones para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netflix:dispatch:*:*:*:*:*:*:*:*", "versionEndExcluding": "20230817", "matchCriteriaId": "1A158924-2CED-411F-878E-DE1756AF2F0D"}]}]}], "references": [{"url": "https://github.com/Netflix/dispatch/commit/b1942a4319f0de820d86b84a58ebc85398b97c70", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Netflix/dispatch/pull/3695", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Netflix/dispatch/releases/tag/latest", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/Netflix/dispatch/security/advisories/GHSA-fv3x-67q3-6pg7", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Netflix/dispatch/commit/b1942a4319f0de820d86b84a58ebc85398b97c70"}}