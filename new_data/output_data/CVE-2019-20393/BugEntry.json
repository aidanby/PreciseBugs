{"buggy_code": ["/**\n * @file parser_yang.c\n * @author Pavol Vican\n * @brief YANG parser for libyang\n *\n * Copyright (c) 2015 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#include <ctype.h>\n#include <assert.h>\n#include \"parser_yang.h\"\n#include \"parser_yang_lex.h\"\n#include \"parser.h\"\n#include \"xpath.h\"\n\nstatic void yang_free_import(struct ly_ctx *ctx, struct lys_import *imp, uint8_t start, uint8_t size);\nstatic int yang_check_must(struct lys_module *module, struct lys_restr *must, uint size, struct unres_schema *unres);\nstatic void yang_free_include(struct ly_ctx *ctx, struct lys_include *inc, uint8_t start, uint8_t size);\nstatic int yang_check_sub_module(struct lys_module *module, struct unres_schema *unres, struct lys_node *node);\nstatic void free_yang_common(struct lys_module *module, struct lys_node *node);\nstatic int yang_check_nodes(struct lys_module *module, struct lys_node *parent, struct lys_node *nodes,\n                            int options, struct unres_schema *unres);\nstatic int yang_fill_ext_substm_index(struct lys_ext_instance_complex *ext, LY_STMT stmt, enum yytokentype keyword);\nstatic void yang_free_nodes(struct ly_ctx *ctx, struct lys_node *node);\nvoid lys_iffeature_free(struct ly_ctx *ctx, struct lys_iffeature *iffeature, uint8_t iffeature_size, int shallow,\n                        void (*private_destructor)(const struct lys_node *node, void *priv));\n\nstatic int\nyang_check_string(struct lys_module *module, const char **target, char *what,\n                  char *where, char *value, struct lys_node *node)\n{\n    if (*target) {\n        LOGVAL(module->ctx, LYE_TOOMANY, (node) ? LY_VLOG_LYS : LY_VLOG_NONE, node, what, where);\n        free(value);\n        return 1;\n    } else {\n        *target = lydict_insert_zc(module->ctx, value);\n        return 0;\n    }\n}\n\nint\nyang_read_common(struct lys_module *module, char *value, enum yytokentype type)\n{\n    int ret = 0;\n\n    switch (type) {\n    case MODULE_KEYWORD:\n        module->name = lydict_insert_zc(module->ctx, value);\n        break;\n    case NAMESPACE_KEYWORD:\n        ret = yang_check_string(module, &module->ns, \"namespace\", \"module\", value, NULL);\n        break;\n    case ORGANIZATION_KEYWORD:\n        ret = yang_check_string(module, &module->org, \"organization\", \"module\", value, NULL);\n        break;\n    case CONTACT_KEYWORD:\n        ret = yang_check_string(module, &module->contact, \"contact\", \"module\", value, NULL);\n        break;\n    default:\n        free(value);\n        LOGINT(module->ctx);\n        ret = EXIT_FAILURE;\n        break;\n    }\n\n    return ret;\n}\n\nint\nyang_check_version(struct lys_module *module, struct lys_submodule *submodule, char *value, int repeat)\n{\n    int ret = EXIT_SUCCESS;\n\n    if (repeat) {\n        LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"yang version\", \"module\");\n        ret = EXIT_FAILURE;\n    } else {\n        if (!strcmp(value, \"1\")) {\n            if (submodule) {\n                if (module->version > 1) {\n                    LOGVAL(module->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                    ret = EXIT_FAILURE;\n                 }\n                submodule->version = 1;\n            } else {\n                module->version = 1;\n            }\n        } else if (!strcmp(value, \"1.1\")) {\n            if (submodule) {\n                if (module->version != 2) {\n                    LOGVAL(module->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                    ret = EXIT_FAILURE;\n                }\n                submodule->version = 2;\n            } else {\n                module->version = 2;\n            }\n        } else {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"yang-version\");\n            ret = EXIT_FAILURE;\n        }\n    }\n    free(value);\n    return ret;\n}\n\nint\nyang_read_prefix(struct lys_module *module, struct lys_import *imp, char *value)\n{\n    int ret = 0;\n\n    if (!imp && lyp_check_identifier(module->ctx, value, LY_IDENT_PREFIX, module, NULL)) {\n        free(value);\n        return EXIT_FAILURE;\n    }\n\n    if (imp) {\n        ret = yang_check_string(module, &imp->prefix, \"prefix\", \"import\", value, NULL);\n    } else {\n        ret = yang_check_string(module, &module->prefix, \"prefix\", \"module\", value, NULL);\n    }\n\n    return ret;\n}\n\nstatic int\nyang_fill_import(struct lys_module *module, struct lys_import *imp_old, struct lys_import *imp_new,\n                 char *value, struct unres_schema *unres)\n{\n    const char *exp;\n    int rc;\n\n    if (!imp_old->prefix) {\n        LOGVAL(module->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"import\");\n        goto error;\n    } else {\n        if (lyp_check_identifier(module->ctx, imp_old->prefix, LY_IDENT_PREFIX, module, NULL)) {\n            goto error;\n        }\n    }\n    memcpy(imp_new, imp_old, sizeof *imp_old);\n    exp = lydict_insert_zc(module->ctx, value);\n    rc = lyp_check_import(module, exp, imp_new);\n    lydict_remove(module->ctx, exp);\n    module->imp_size++;\n    if (rc || yang_check_ext_instance(module, &imp_new->ext, imp_new->ext_size, imp_new, unres)) {\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    free(value);\n    lydict_remove(module->ctx, imp_old->dsc);\n    lydict_remove(module->ctx, imp_old->ref);\n    lydict_remove(module->ctx, imp_old->prefix);\n    lys_extension_instances_free(module->ctx, imp_old->ext, imp_old->ext_size, NULL);\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_description(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type)\n{\n    int ret;\n    char *dsc = \"description\";\n\n    switch (type) {\n    case MODULE_KEYWORD:\n        ret = yang_check_string(module, &module->dsc, dsc, \"module\", value, NULL);\n        break;\n    case REVISION_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_revision *)node)->dsc, dsc, where, value, NULL);\n        break;\n    case IMPORT_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_import *)node)->dsc, dsc, where, value, NULL);\n        break;\n    case INCLUDE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_include *)node)->dsc, dsc, where, value, NULL);\n        break;\n    case NODE_PRINT:\n        ret = yang_check_string(module, &((struct lys_node *)node)->dsc, dsc, where, value, node);\n        break;\n    default:\n        ret = yang_check_string(module, &((struct lys_node *)node)->dsc, dsc, where, value, NULL);\n        break;\n    }\n    return ret;\n}\n\nint\nyang_read_reference(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type)\n{\n    int ret;\n    char *ref = \"reference\";\n\n    switch (type) {\n    case MODULE_KEYWORD:\n        ret = yang_check_string(module, &module->ref, ref, \"module\", value, NULL);\n        break;\n    case REVISION_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_revision *)node)->ref, ref, where, value, NULL);\n        break;\n    case IMPORT_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_import *)node)->ref, ref, where, value, NULL);\n        break;\n    case INCLUDE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_include *)node)->ref, ref, where, value, NULL);\n        break;\n    case NODE_PRINT:\n        ret = yang_check_string(module, &((struct lys_node *)node)->ref, ref, where, value, node);\n        break;\n    default:\n        ret = yang_check_string(module, &((struct lys_node *)node)->ref, ref, where, value, NULL);\n        break;\n    }\n    return ret;\n}\n\nint\nyang_fill_iffeature(struct lys_module *module, struct lys_iffeature *iffeature, void *parent,\n                    char *value, struct unres_schema *unres, int parent_is_feature)\n{\n    const char *exp;\n    int ret;\n\n    if ((module->version != 2) && ((value[0] == '(') || strchr(value, ' '))) {\n        LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        free(value);\n        return EXIT_FAILURE;\n    }\n\n    if (!(exp = transform_iffeat_schema2json(module, value))) {\n        free(value);\n        return EXIT_FAILURE;\n    }\n    free(value);\n\n    ret = resolve_iffeature_compile(iffeature, exp, (struct lys_node *)parent, parent_is_feature, unres);\n    lydict_remove(module->ctx, exp);\n\n    return (ret) ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n\nint\nyang_read_base(struct lys_module *module, struct lys_ident *ident, char *value, struct unres_schema *unres)\n{\n    const char *exp;\n\n    exp = transform_schema2json(module, value);\n    free(value);\n    if (!exp) {\n        return EXIT_FAILURE;\n    }\n\n    if (unres_schema_add_str(module, unres, ident, UNRES_IDENT, exp) == -1) {\n        lydict_remove(module->ctx, exp);\n        return EXIT_FAILURE;\n    }\n\n    lydict_remove(module->ctx, exp);\n    return EXIT_SUCCESS;\n}\n\nint\nyang_read_message(struct lys_module *module,struct lys_restr *save,char *value, char *what, int message)\n{\n    int ret;\n\n    if (message == ERROR_APP_TAG_KEYWORD) {\n        ret = yang_check_string(module, &save->eapptag, \"error_app_tag\", what, value, NULL);\n    } else {\n        ret = yang_check_string(module, &save->emsg, \"error_message\", what, value, NULL);\n    }\n    return ret;\n}\n\nint\nyang_read_presence(struct lys_module *module, struct lys_node_container *cont, char *value)\n{\n    if (cont->presence) {\n        LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, cont, \"presence\", \"container\");\n        free(value);\n        return EXIT_FAILURE;\n    } else {\n        cont->presence = lydict_insert_zc(module->ctx, value);\n        return EXIT_SUCCESS;\n    }\n}\n\nvoid *\nyang_read_when(struct lys_module *module, struct lys_node *node, enum yytokentype type, char *value)\n{\n    struct lys_when *retval;\n\n    retval = calloc(1, sizeof *retval);\n    LY_CHECK_ERR_RETURN(!retval, LOGMEM(module->ctx); free(value), NULL);\n    retval->cond = transform_schema2json(module, value);\n    if (!retval->cond) {\n        goto error;\n    }\n    switch (type) {\n    case CONTAINER_KEYWORD:\n        if (((struct lys_node_container *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"container\");\n            goto error;\n        }\n        ((struct lys_node_container *)node)->when = retval;\n        break;\n    case ANYDATA_KEYWORD:\n    case ANYXML_KEYWORD:\n        if (((struct lys_node_anydata *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", (type == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n            goto error;\n        }\n        ((struct lys_node_anydata *)node)->when = retval;\n        break;\n    case CHOICE_KEYWORD:\n        if (((struct lys_node_choice *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"choice\");\n            goto error;\n        }\n        ((struct lys_node_choice *)node)->when = retval;\n        break;\n    case CASE_KEYWORD:\n        if (((struct lys_node_case *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"case\");\n            goto error;\n        }\n        ((struct lys_node_case *)node)->when = retval;\n        break;\n    case LEAF_KEYWORD:\n        if (((struct lys_node_leaf *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"leaf\");\n            goto error;\n        }\n        ((struct lys_node_leaf *)node)->when = retval;\n        break;\n    case LEAF_LIST_KEYWORD:\n        if (((struct lys_node_leaflist *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"leaflist\");\n            goto error;\n        }\n        ((struct lys_node_leaflist *)node)->when = retval;\n        break;\n    case LIST_KEYWORD:\n        if (((struct lys_node_list *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"list\");\n            goto error;\n        }\n        ((struct lys_node_list *)node)->when = retval;\n        break;\n    case USES_KEYWORD:\n        if (((struct lys_node_uses *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"uses\");\n            goto error;\n        }\n        ((struct lys_node_uses *)node)->when = retval;\n        break;\n    case AUGMENT_KEYWORD:\n        if (((struct lys_node_augment *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"augment\");\n            goto error;\n        }\n        ((struct lys_node_augment *)node)->when = retval;\n        break;\n    case EXTENSION_INSTANCE:\n        *(struct lys_when **)node = retval;\n        break;\n    default:\n        goto error;\n        break;\n    }\n    free(value);\n    return retval;\n\nerror:\n    free(value);\n    lydict_remove(module->ctx, retval->cond);\n    free(retval);\n    return NULL;\n}\n\nvoid *\nyang_read_node(struct lys_module *module, struct lys_node *parent, struct lys_node **root,\n               char *value, int nodetype, int sizeof_struct)\n{\n    struct lys_node *node, **child;\n\n    node = calloc(1, sizeof_struct);\n    LY_CHECK_ERR_RETURN(!node, LOGMEM(module->ctx); free(value), NULL);\n\n    LOGDBG(LY_LDGYANG, \"parsing %s statement \\\"%s\\\"\", strnodetype(nodetype), value);\n    node->name = lydict_insert_zc(module->ctx, value);\n    node->module = module;\n    node->nodetype = nodetype;\n    node->parent = parent;\n\n    /* insert the node into the schema tree */\n    child = (parent) ? &parent->child : root;\n    if (*child) {\n        (*child)->prev->next = node;\n        (*child)->prev = node;\n    } else {\n        *child = node;\n        node->prev = node;\n    }\n    return node;\n}\n\nint\nyang_read_default(struct lys_module *module, void *node, char *value, enum yytokentype type)\n{\n    int ret;\n\n    switch (type) {\n    case LEAF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_node_leaf *) node)->dflt, \"default\", \"leaf\", value, node);\n        break;\n    case TYPEDEF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_tpdf *) node)->dflt, \"default\", \"typedef\", value, NULL);\n        break;\n    default:\n        free(value);\n        LOGINT(module->ctx);\n        ret = EXIT_FAILURE;\n        break;\n    }\n    return ret;\n}\n\nint\nyang_read_units(struct lys_module *module, void *node, char *value, enum yytokentype type)\n{\n    int ret;\n\n    switch (type) {\n    case LEAF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_node_leaf *) node)->units, \"units\", \"leaf\", value, node);\n        break;\n    case LEAF_LIST_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_node_leaflist *) node)->units, \"units\", \"leaflist\", value, node);\n        break;\n    case TYPEDEF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_tpdf *) node)->units, \"units\", \"typedef\", value, NULL);\n        break;\n    case ADD_KEYWORD:\n    case REPLACE_KEYWORD:\n    case DELETE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_deviate *) node)->units, \"units\", \"deviate\", value, NULL);\n        break;\n    default:\n        free(value);\n        LOGINT(module->ctx);\n        ret = EXIT_FAILURE;\n        break;\n    }\n    return ret;\n}\n\nint\nyang_read_key(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres)\n{\n    char *exp, *value;\n\n    exp = value = (char *) list->keys;\n    while ((value = strpbrk(value, \" \\t\\n\"))) {\n        list->keys_size++;\n        while (isspace(*value)) {\n            value++;\n        }\n    }\n    list->keys_size++;\n\n    list->keys_str = lydict_insert_zc(module->ctx, exp);\n    list->keys = calloc(list->keys_size, sizeof *list->keys);\n    LY_CHECK_ERR_RETURN(!list->keys, LOGMEM(module->ctx), EXIT_FAILURE);\n\n    if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nint\nyang_fill_unique(struct lys_module *module, struct lys_node_list *list, struct lys_unique *unique, char *value, struct unres_schema *unres)\n{\n    int i, j;\n    char *vaux, c;\n    struct unres_list_uniq *unique_info;\n\n    /* count the number of unique leafs in the value */\n    vaux = value;\n    while ((vaux = strpbrk(vaux, \" \\t\\n\"))) {\n       unique->expr_size++;\n        while (isspace(*vaux)) {\n            vaux++;\n        }\n    }\n    unique->expr_size++;\n    unique->expr = calloc(unique->expr_size, sizeof *unique->expr);\n    LY_CHECK_ERR_GOTO(!unique->expr, LOGMEM(module->ctx), error);\n\n    for (i = 0; i < unique->expr_size; i++) {\n        vaux = strpbrk(value, \" \\t\\n\");\n        if (vaux) {\n            c = *vaux;\n            *vaux = '\\0';\n        }\n\n        /* store token into unique structure (includes converting prefix to the module name) */\n        unique->expr[i] = transform_schema2json(module, value);\n        if (!unique->expr[i]) {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_LYS, list, value, \"unique\");\n            goto error;\n        }\n        if (vaux) {\n            *vaux = c;\n        }\n\n        /* check that the expression does not repeat */\n        for (j = 0; j < i; j++) {\n            if (ly_strequal(unique->expr[j], unique->expr[i], 1)) {\n                LOGVAL(module->ctx, LYE_INARG, LY_VLOG_LYS, list, unique->expr[i], \"unique\");\n                LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_LYS, list, \"The identifier is not unique\");\n                goto error;\n            }\n        }\n        /* try to resolve leaf */\n        if (unres) {\n            unique_info = malloc(sizeof *unique_info);\n            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(module->ctx), error);\n            unique_info->list = (struct lys_node *)list;\n            unique_info->expr = unique->expr[i];\n            unique_info->trg_type = &unique->trg_type;\n            if (unres_schema_add_node(module, unres, unique_info, UNRES_LIST_UNIQ, NULL) == -1) {\n                goto error;\n            }\n        } else {\n            if (resolve_unique((struct lys_node *)list, unique->expr[i], &unique->trg_type)) {\n                goto error;\n            }\n        }\n\n        /* move to next token */\n        value = vaux;\n        while(value && isspace(*value)) {\n            value++;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_unique(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres)\n{\n    uint8_t k;\n    char *str;\n\n    for (k = 0; k < list->unique_size; k++) {\n        str = (char *)list->unique[k].expr;\n        if (yang_fill_unique(module, list, &list->unique[k], str, unres)) {\n            goto error;\n        }\n        free(str);\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    free(str);\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_leafref_path(struct lys_module *module, struct yang_type *stype, char *value)\n{\n    if (stype->base && (stype->base != LY_TYPE_LEAFREF)) {\n        LOGVAL(module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"require-instance\");\n        goto error;\n    }\n    if (stype->type->info.lref.path) {\n        LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"path\", \"type\");\n        goto error;\n    }\n    stype->type->info.lref.path = lydict_insert_zc(module->ctx, value);\n    stype->base = LY_TYPE_LEAFREF;\n    return EXIT_SUCCESS;\n\nerror:\n    free(value);\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_require_instance(struct ly_ctx *ctx, struct yang_type *stype, int req)\n{\n    if (stype->base && (stype->base != LY_TYPE_LEAFREF)) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"require-instance\");\n        return EXIT_FAILURE;\n    }\n    if (stype->type->info.lref.req) {\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"require-instance\", \"type\");\n        return EXIT_FAILURE;\n    }\n    stype->type->info.lref.req = req;\n    stype->base = LY_TYPE_LEAFREF;\n    return EXIT_SUCCESS;\n}\n\nint\nyang_check_type(struct lys_module *module, struct lys_node *parent, struct yang_type *typ, struct lys_type *type, int tpdftype, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int rc, ret = -1;\n    unsigned int i, j;\n    int8_t req;\n    const char *name, *value, *module_name = NULL;\n    LY_DATA_TYPE base = 0, base_tmp;\n    struct lys_node *siter;\n    struct lys_type *dertype;\n    struct lys_type_enum *enms_sc = NULL;\n    struct lys_type_bit *bits_sc = NULL;\n    struct lys_type_bit bit_tmp;\n    struct yang_type *yang;\n\n    value = transform_schema2json(module, typ->name);\n    if (!value) {\n        goto error;\n    }\n\n    i = parse_identifier(value);\n    if (i < 1) {\n        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, value[-i], &value[-i]);\n        lydict_remove(ctx, value);\n        goto error;\n    }\n    /* module name */\n    name = value;\n    if (value[i]) {\n        module_name = lydict_insert(ctx, value, i);\n        name += i;\n        if ((name[0] != ':') || (parse_identifier(name + 1) < 1)) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, name[0], name);\n            lydict_remove(ctx, module_name);\n            lydict_remove(ctx, value);\n            goto error;\n        }\n        ++name;\n    }\n\n    rc = resolve_superior_type(name, module_name, module, parent, &type->der);\n    if (rc == -1) {\n        LOGVAL(ctx, LYE_INMOD, LY_VLOG_NONE, NULL, module_name);\n        lydict_remove(ctx, module_name);\n        lydict_remove(ctx, value);\n        goto error;\n\n    /* the type could not be resolved or it was resolved to an unresolved typedef or leafref */\n    } else if (rc == EXIT_FAILURE) {\n        LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_NONE, NULL, \"type\", name);\n        lydict_remove(ctx, module_name);\n        lydict_remove(ctx, value);\n        ret = EXIT_FAILURE;\n        goto error;\n    }\n    lydict_remove(ctx, module_name);\n    lydict_remove(ctx, value);\n\n    if (type->value_flags & LY_VALUE_UNRESGRP) {\n        /* resolved type in grouping, decrease the grouping's nacm number to indicate that one less\n         * unresolved item left inside the grouping, LYTYPE_GRP used as a flag for types inside a grouping.  */\n        for (siter = parent; siter && (siter->nodetype != LYS_GROUPING); siter = lys_parent(siter));\n        if (siter) {\n            assert(((struct lys_node_grp *)siter)->unres_count);\n            ((struct lys_node_grp *)siter)->unres_count--;\n        } else {\n            LOGINT(ctx);\n            goto error;\n        }\n        type->value_flags &= ~LY_VALUE_UNRESGRP;\n    }\n\n    /* check status */\n    if (lyp_check_status(type->parent->flags, type->parent->module, type->parent->name,\n                         type->der->flags, type->der->module, type->der->name, parent)) {\n        goto error;\n    }\n\n    base = typ->base;\n    base_tmp = type->base;\n    type->base = type->der->type.base;\n    if (base == 0) {\n        base = type->der->type.base;\n    }\n    switch (base) {\n    case LY_TYPE_STRING:\n        if (type->base == LY_TYPE_BINARY) {\n            if (type->info.str.pat_count) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Binary type could not include pattern statement.\");\n                goto error;\n            }\n            type->info.binary.length = type->info.str.length;\n            if (type->info.binary.length && lyp_check_length_range(ctx, type->info.binary.length->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.binary.length->expr, \"length\");\n                goto error;\n            }\n        } else if (type->base == LY_TYPE_STRING) {\n            if (type->info.str.length && lyp_check_length_range(ctx, type->info.str.length->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.str.length->expr, \"length\");\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        break;\n    case LY_TYPE_DEC64:\n        if (type->base == LY_TYPE_DEC64) {\n            /* mandatory sub-statement(s) check */\n            if (!type->info.dec64.dig && !type->der->type.der) {\n                /* decimal64 type directly derived from built-in type requires fraction-digits */\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"fraction-digits\", \"type\");\n                goto error;\n            }\n            if (type->info.dec64.dig && type->der->type.der) {\n                /* type is not directly derived from buit-in type and fraction-digits statement is prohibited */\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"fraction-digits\");\n                goto error;\n            }\n\n            /* copy fraction-digits specification from parent type for easier internal use */\n            if (type->der->type.der) {\n                type->info.dec64.dig = type->der->type.info.dec64.dig;\n                type->info.dec64.div = type->der->type.info.dec64.div;\n            }\n            if (type->info.dec64.range && lyp_check_length_range(ctx, type->info.dec64.range->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.dec64.range->expr, \"range\");\n                goto error;\n            }\n        } else if (type->base >= LY_TYPE_INT8 && type->base <=LY_TYPE_UINT64) {\n            if (type->info.dec64.dig) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Numerical type could not include fraction statement.\");\n                goto error;\n            }\n            type->info.num.range = type->info.dec64.range;\n            if (type->info.num.range && lyp_check_length_range(ctx, type->info.num.range->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.num.range->expr, \"range\");\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        break;\n    case LY_TYPE_ENUM:\n        if (type->base != LY_TYPE_ENUM) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        dertype = &type->der->type;\n\n        if (!dertype->der) {\n            if (!type->info.enums.count) {\n                /* type is derived directly from buit-in enumeartion type and enum statement is required */\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"enum\", \"type\");\n                goto error;\n            }\n        } else {\n            for (; !dertype->info.enums.count; dertype = &dertype->der->type);\n            if (module->version < 2 && type->info.enums.count) {\n                /* type is not directly derived from built-in enumeration type and enum statement is prohibited\n                 * in YANG 1.0, since YANG 1.1 enum statements can be used to restrict the base enumeration type */\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"enum\");\n                goto error;\n            }\n\n            /* restricted enumeration type - the name MUST be used in the base type */\n            enms_sc = dertype->info.enums.enm;\n            for (i = 0; i < type->info.enums.count; i++) {\n                for (j = 0; j < dertype->info.enums.count; j++) {\n                    if (ly_strequal(enms_sc[j].name, type->info.enums.enm[i].name, 1)) {\n                        break;\n                    }\n                }\n                if (j == dertype->info.enums.count) {\n                    LOGVAL(ctx, LYE_ENUM_INNAME, LY_VLOG_NONE, NULL, type->info.enums.enm[i].name);\n                    goto error;\n                }\n\n                if (type->info.enums.enm[i].flags & LYS_AUTOASSIGNED) {\n                    /* automatically assign value from base type */\n                    type->info.enums.enm[i].value = enms_sc[j].value;\n                } else {\n                    /* check that the assigned value corresponds to the original\n                     * value of the enum in the base type */\n                    if (type->info.enums.enm[i].value != enms_sc[j].value) {\n                        /* type->info.enums.enm[i].value - assigned value in restricted enum\n                         * enms_sc[j].value - value assigned to the corresponding enum (detected above) in base type */\n                        LOGVAL(ctx, LYE_ENUM_INVAL, LY_VLOG_NONE, NULL, type->info.enums.enm[i].value,\n                               type->info.enums.enm[i].name, enms_sc[j].value);\n                        goto error;\n                    }\n                }\n            }\n        }\n        break;\n    case LY_TYPE_BITS:\n        if (type->base != LY_TYPE_BITS) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        dertype = &type->der->type;\n\n        if (!dertype->der) {\n            if (!type->info.bits.count) {\n                /* type is derived directly from buit-in bits type and bit statement is required */\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"bit\", \"type\");\n                goto error;\n            }\n        } else {\n            for (; !dertype->info.enums.count; dertype = &dertype->der->type);\n            if (module->version < 2 && type->info.bits.count) {\n                /* type is not directly derived from buit-in bits type and bit statement is prohibited,\n                 * since YANG 1.1 the bit statements can be used to restrict the base bits type */\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"bit\");\n                goto error;\n            }\n\n            bits_sc = dertype->info.bits.bit;\n            for (i = 0; i < type->info.bits.count; i++) {\n                for (j = 0; j < dertype->info.bits.count; j++) {\n                    if (ly_strequal(bits_sc[j].name, type->info.bits.bit[i].name, 1)) {\n                        break;\n                    }\n                }\n                if (j == dertype->info.bits.count) {\n                    LOGVAL(ctx, LYE_BITS_INNAME, LY_VLOG_NONE, NULL, type->info.bits.bit[i].name);\n                    goto error;\n                }\n\n                /* restricted bits type */\n                if (type->info.bits.bit[i].flags & LYS_AUTOASSIGNED) {\n                    /* automatically assign position from base type */\n                    type->info.bits.bit[i].pos = bits_sc[j].pos;\n                } else {\n                    /* check that the assigned position corresponds to the original\n                     * position of the bit in the base type */\n                    if (type->info.bits.bit[i].pos != bits_sc[j].pos) {\n                        /* type->info.bits.bit[i].pos - assigned position in restricted bits\n                         * bits_sc[j].pos - position assigned to the corresponding bit (detected above) in base type */\n                        LOGVAL(ctx, LYE_BITS_INVAL, LY_VLOG_NONE, NULL, type->info.bits.bit[i].pos,\n                               type->info.bits.bit[i].name, bits_sc[j].pos);\n                        goto error;\n                    }\n                }\n            }\n        }\n\n        for (i = type->info.bits.count; i > 0; i--) {\n            j = i - 1;\n\n            /* keep them ordered by position */\n            while (j && type->info.bits.bit[j - 1].pos > type->info.bits.bit[j].pos) {\n                /* switch them */\n                memcpy(&bit_tmp, &type->info.bits.bit[j], sizeof bit_tmp);\n                memcpy(&type->info.bits.bit[j], &type->info.bits.bit[j - 1], sizeof bit_tmp);\n                memcpy(&type->info.bits.bit[j - 1], &bit_tmp, sizeof bit_tmp);\n                j--;\n            }\n        }\n        break;\n    case LY_TYPE_LEAFREF:\n        if (type->base == LY_TYPE_INST) {\n            if (type->info.lref.path) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"path\");\n                goto error;\n            }\n            if ((req = type->info.lref.req)) {\n                type->info.inst.req = req;\n            }\n        } else if (type->base == LY_TYPE_LEAFREF) {\n            /* require-instance only YANG 1.1 */\n            if (type->info.lref.req && (module->version < 2)) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"require-instance\");\n                goto error;\n            }\n            /* flag resolving for later use */\n            if (!tpdftype) {\n                for (siter = parent; siter && siter->nodetype != LYS_GROUPING; siter = lys_parent(siter));\n                if (siter) {\n                    /* just a flag - do not resolve */\n                    tpdftype = 1;\n                }\n            }\n\n            if (type->info.lref.path) {\n                if (type->der->type.der) {\n                    LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"path\");\n                    goto error;\n                }\n                value = type->info.lref.path;\n                /* store in the JSON format */\n                type->info.lref.path = transform_schema2json(module, value);\n                lydict_remove(ctx, value);\n                if (!type->info.lref.path) {\n                    goto error;\n                }\n                /* try to resolve leafref path only when this is instantiated\n                 * leaf, so it is not:\n                 * - typedef's type,\n                 * - in  grouping definition,\n                 * - just instantiated in a grouping definition,\n                 * because in those cases the nodes referenced in path might not be present\n                 * and it is not a bug.  */\n                if (!tpdftype && unres_schema_add_node(module, unres, type, UNRES_TYPE_LEAFREF, parent) == -1) {\n                    goto error;\n                }\n            } else if (!type->der->type.der) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"path\", \"type\");\n                goto error;\n            } else {\n                /* copy leafref definition into the derived type */\n                type->info.lref.path = lydict_insert(ctx, type->der->type.info.lref.path, 0);\n                /* and resolve the path at the place we are (if not in grouping/typedef) */\n                if (!tpdftype && unres_schema_add_node(module, unres, type, UNRES_TYPE_LEAFREF, parent) == -1) {\n                    goto error;\n                }\n            }\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        break;\n    case LY_TYPE_IDENT:\n        if (type->base != LY_TYPE_IDENT) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        if (type->der->type.der) {\n            if (type->info.ident.ref) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");\n                goto error;\n            }\n        } else {\n            if (!type->info.ident.ref) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"base\", \"type\");\n                goto error;\n            }\n        }\n        break;\n    case LY_TYPE_UNION:\n        if (type->base != LY_TYPE_UNION) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        if (!type->info.uni.types) {\n            if (type->der->type.der) {\n                /* this is just a derived type with no additional type specified/required */\n                assert(type->der->type.base == LY_TYPE_UNION);\n                type->info.uni.has_ptr_type = type->der->type.info.uni.has_ptr_type;\n                break;\n            }\n            LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"(union) type\");\n            goto error;\n        }\n        for (i = 0; i < type->info.uni.count; i++) {\n            dertype = &type->info.uni.types[i];\n            if (dertype->base == LY_TYPE_DER) {\n                yang = (struct yang_type *)dertype->der;\n                dertype->der = NULL;\n                dertype->parent = type->parent;\n                if (yang_check_type(module, parent, yang, dertype, tpdftype, unres)) {\n                    dertype->der = (struct lys_tpdf *)yang;\n                    ret = EXIT_FAILURE;\n                    type->base = base_tmp;\n                    base = 0;\n                    goto error;\n                } else {\n                    lydict_remove(ctx, yang->name);\n                    free(yang);\n                }\n            }\n            if (module->version < 2) {\n                if (dertype->base == LY_TYPE_EMPTY) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"empty\", typ->name);\n                    goto error;\n                } else if (dertype->base == LY_TYPE_LEAFREF) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"leafref\", typ->name);\n                    goto error;\n                }\n            }\n            if ((dertype->base == LY_TYPE_INST) || (dertype->base == LY_TYPE_LEAFREF)\n                    || ((dertype->base == LY_TYPE_UNION) && dertype->info.uni.has_ptr_type)) {\n                type->info.uni.has_ptr_type = 1;\n            }\n        }\n        break;\n\n    default:\n        if (base >= LY_TYPE_BINARY && base <= LY_TYPE_UINT64) {\n            if (type->base != base) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n                goto error;\n            }\n        } else {\n            LOGINT(ctx);\n            goto error;\n        }\n    }\n\n    /* if derived type has extension, which need validate data */\n    dertype = &type->der->type;\n    while (dertype->der) {\n        if (dertype->parent->flags & LYS_VALID_EXT) {\n            type->parent->flags |= LYS_VALID_EXT;\n        }\n        dertype = &dertype->der->type;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (base) {\n        type->base = base_tmp;\n    }\n    return ret;\n}\n\nvoid\nyang_free_type_union(struct ly_ctx *ctx, struct lys_type *type)\n{\n    struct lys_type *stype;\n    struct yang_type *yang;\n    unsigned int i;\n\n    for (i = 0; i < type->info.uni.count; ++i) {\n        stype = &type->info.uni.types[i];\n        if (stype->base == LY_TYPE_DER) {\n            yang = (struct yang_type *)stype->der;\n            stype->base = yang->base;\n            lydict_remove(ctx, yang->name);\n            free(yang);\n        } else if (stype->base == LY_TYPE_UNION) {\n            yang_free_type_union(ctx, stype);\n        }\n    }\n}\n\nvoid *\nyang_read_type(struct ly_ctx *ctx, void *parent, char *value, enum yytokentype type)\n{\n    struct yang_type *typ;\n    struct lys_deviate *dev;\n\n    typ = calloc(1, sizeof *typ);\n    LY_CHECK_ERR_RETURN(!typ, LOGMEM(ctx), NULL);\n\n    typ->flags = LY_YANG_STRUCTURE_FLAG;\n    switch (type) {\n    case LEAF_KEYWORD:\n        if (((struct lys_node_leaf *)parent)->type.der) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, parent, \"type\", \"leaf\");\n            goto error;\n        }\n        ((struct lys_node_leaf *)parent)->type.der = (struct lys_tpdf *)typ;\n        ((struct lys_node_leaf *)parent)->type.parent = (struct lys_tpdf *)parent;\n        typ->type = &((struct lys_node_leaf *)parent)->type;\n        break;\n    case LEAF_LIST_KEYWORD:\n        if (((struct lys_node_leaflist *)parent)->type.der) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, parent, \"type\", \"leaf-list\");\n            goto error;\n        }\n        ((struct lys_node_leaflist *)parent)->type.der = (struct lys_tpdf *)typ;\n        ((struct lys_node_leaflist *)parent)->type.parent = (struct lys_tpdf *)parent;\n        typ->type = &((struct lys_node_leaflist *)parent)->type;\n        break;\n    case UNION_KEYWORD:\n        ((struct lys_type *)parent)->der = (struct lys_tpdf *)typ;\n        typ->type = (struct lys_type *)parent;\n        break;\n    case TYPEDEF_KEYWORD:\n        if (((struct lys_tpdf *)parent)->type.der) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"type\", \"typedef\");\n            goto error;\n        }\n        ((struct lys_tpdf *)parent)->type.der = (struct lys_tpdf *)typ;\n        typ->type = &((struct lys_tpdf *)parent)->type;\n        break;\n    case REPLACE_KEYWORD:\n        /* deviation replace type*/\n        dev = (struct lys_deviate *)parent;\n        if (dev->type) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"type\", \"deviation\");\n            goto error;\n        }\n        dev->type = calloc(1, sizeof *dev->type);\n        LY_CHECK_ERR_GOTO(!dev->type, LOGMEM(ctx), error);\n        dev->type->der = (struct lys_tpdf *)typ;\n        typ->type = dev->type;\n        break;\n    case EXTENSION_INSTANCE:\n        ((struct lys_type *)parent)->der = (struct lys_tpdf *)typ;\n        typ->type = parent;\n        break;\n    default:\n        goto error;\n        break;\n    }\n    typ->name = lydict_insert_zc(ctx, value);\n    return typ;\n\nerror:\n    free(value);\n    free(typ);\n    return NULL;\n}\n\nvoid *\nyang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr *length;\n\n    if (is_ext_instance) {\n        length = (struct lys_restr *)stype;\n    } else {\n        if (stype->base == 0 || stype->base == LY_TYPE_STRING) {\n            stype->base = LY_TYPE_STRING;\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected length statement.\");\n            goto error;\n        }\n\n        if (stype->type->info.str.length) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"length\", \"type\");\n            goto error;\n        }\n        length = calloc(1, sizeof *length);\n        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);\n        stype->type->info.str.length = length;\n    }\n    length->expr = lydict_insert_zc(ctx, value);\n    return length;\n\nerror:\n    free(value);\n    return NULL;\n}\n\nint\nyang_read_pattern(struct ly_ctx *ctx, struct lys_restr *pattern, void **precomp, char *value, char modifier)\n{\n    char *buf;\n    size_t len;\n\n    if (precomp && lyp_precompile_pattern(ctx, value, (pcre**)&precomp[0], (pcre_extra**)&precomp[1])) {\n        free(value);\n        return EXIT_FAILURE;\n    }\n\n    len = strlen(value);\n    buf = malloc((len + 2) * sizeof *buf); /* modifier byte + value + terminating NULL byte */\n    LY_CHECK_ERR_RETURN(!buf, LOGMEM(ctx); free(value), EXIT_FAILURE);\n\n    buf[0] = modifier;\n    strcpy(&buf[1], value);\n    free(value);\n\n    pattern->expr = lydict_insert_zc(ctx, buf);\n    return EXIT_SUCCESS;\n}\n\nvoid *\nyang_read_range(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr * range;\n\n    if (is_ext_instance) {\n        range = (struct lys_restr *)stype;\n    } else {\n        if (stype->base != 0 && stype->base != LY_TYPE_DEC64) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected range statement.\");\n            goto error;\n        }\n        stype->base = LY_TYPE_DEC64;\n        if (stype->type->info.dec64.range) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"range\", \"type\");\n            goto error;\n        }\n        range = calloc(1, sizeof *range);\n        LY_CHECK_ERR_GOTO(!range, LOGMEM(ctx), error);\n        stype->type->info.dec64.range = range;\n    }\n    range->expr = lydict_insert_zc(ctx, value);\n    return range;\n\nerror:\n    free(value);\n    return NULL;\n}\n\nint\nyang_read_fraction(struct ly_ctx *ctx, struct yang_type *typ, uint32_t value)\n{\n    uint32_t i;\n\n    if (typ->base == 0 || typ->base == LY_TYPE_DEC64) {\n        typ->base = LY_TYPE_DEC64;\n    } else {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected fraction-digits statement.\");\n        goto error;\n    }\n    if (typ->type->info.dec64.dig) {\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"fraction-digits\", \"type\");\n        goto error;\n    }\n    /* range check */\n    if (value < 1 || value > 18) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", value, \"fraction-digits\");\n        goto error;\n    }\n    typ->type->info.dec64.dig = value;\n    typ->type->info.dec64.div = 10;\n    for (i = 1; i < value; i++) {\n        typ->type->info.dec64.div *= 10;\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, char *value)\n{\n    int i, j;\n\n    typ->base = LY_TYPE_ENUM;\n    if (!value[0]) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"enum name\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Enum name must not be empty.\");\n        free(value);\n        goto error;\n    }\n\n    enm->name = lydict_insert_zc(ctx, value);\n\n    /* the assigned name MUST NOT have any leading or trailing whitespace characters */\n    if (isspace(enm->name[0]) || isspace(enm->name[strlen(enm->name) - 1])) {\n        LOGVAL(ctx, LYE_ENUM_WS, LY_VLOG_NONE, NULL, enm->name);\n        goto error;\n    }\n\n    j = typ->type->info.enums.count - 1;\n    /* check the name uniqueness */\n    for (i = 0; i < j; i++) {\n        if (ly_strequal(typ->type->info.enums.enm[i].name, enm->name, 1)) {\n            LOGVAL(ctx, LYE_ENUM_DUPNAME, LY_VLOG_NONE, NULL, enm->name);\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, int64_t *value, int assign)\n{\n    int i, j;\n\n    if (!assign) {\n        /* assign value automatically */\n        if (*value > INT32_MAX) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"2147483648\", \"enum/value\");\n            goto error;\n        }\n        enm->value = *value;\n        enm->flags |= LYS_AUTOASSIGNED;\n        (*value)++;\n    } else if (typ->type->info.enums.enm == enm) {\n        /* change value, which is assigned automatically, if first enum has value. */\n        *value = typ->type->info.enums.enm[0].value;\n        (*value)++;\n    }\n\n    /* check that the value is unique */\n    j = typ->type->info.enums.count-1;\n    for (i = 0; i < j; i++) {\n        if (typ->type->info.enums.enm[i].value == typ->type->info.enums.enm[j].value) {\n            LOGVAL(ctx, LYE_ENUM_DUPVAL, LY_VLOG_NONE, NULL,\n                   typ->type->info.enums.enm[j].value, typ->type->info.enums.enm[j].name,\n                   typ->type->info.enums.enm[i].name);\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, char *value)\n{\n    int i, j;\n\n    typ->base = LY_TYPE_BITS;\n    bit->name = lydict_insert_zc(ctx, value);\n    if (lyp_check_identifier(ctx, bit->name, LY_IDENT_SIMPLE, NULL, NULL)) {\n        goto error;\n    }\n\n    j = typ->type->info.bits.count - 1;\n    /* check the name uniqueness */\n    for (i = 0; i < j; i++) {\n        if (ly_strequal(typ->type->info.bits.bit[i].name, bit->name, 1)) {\n            LOGVAL(ctx, LYE_BITS_DUPNAME, LY_VLOG_NONE, NULL, bit->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, int64_t *value, int assign)\n{\n    int i,j;\n\n    if (!assign) {\n        /* assign value automatically */\n        if (*value > UINT32_MAX) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"4294967295\", \"bit/position\");\n            goto error;\n        }\n        bit->pos = (uint32_t)*value;\n        bit->flags |= LYS_AUTOASSIGNED;\n        (*value)++;\n    }\n\n    j = typ->type->info.bits.count - 1;\n    /* check that the value is unique */\n    for (i = 0; i < j; i++) {\n        if (typ->type->info.bits.bit[i].pos == bit->pos) {\n            LOGVAL(ctx, LYE_BITS_DUPVAL, LY_VLOG_NONE, NULL, bit->pos, bit->name, typ->type->info.bits.bit[i].name);\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_augment(struct lys_module *module, struct lys_node *parent, struct lys_node_augment *aug, char *value)\n{\n    aug->nodetype = LYS_AUGMENT;\n    aug->target_name = transform_schema2json(module, value);\n    free(value);\n    if (!aug->target_name) {\n        return EXIT_FAILURE;\n    }\n    aug->parent = parent;\n    aug->module = module;\n    return EXIT_SUCCESS;\n}\n\nvoid *\nyang_read_deviate_unsupported(struct ly_ctx *ctx, struct lys_deviation *dev)\n{\n    if (dev->deviate_size) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"not-supported\\\" deviation cannot be combined with any other deviation.\");\n        return NULL;\n    }\n    dev->deviate = calloc(1, sizeof *dev->deviate);\n    LY_CHECK_ERR_RETURN(!dev->deviate, LOGMEM(ctx), NULL);\n    dev->deviate[dev->deviate_size].mod = LY_DEVIATE_NO;\n    dev->deviate_size = 1;\n    return dev->deviate;\n}\n\nvoid *\nyang_read_deviate(struct ly_ctx *ctx, struct lys_deviation *dev, LYS_DEVIATE_TYPE mod)\n{\n    struct lys_deviate *deviate;\n\n    if (dev->deviate_size && dev->deviate[0].mod == LY_DEVIATE_NO) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"not-supported\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"not-supported\\\" deviation cannot be combined with any other deviation.\");\n        return NULL;\n    }\n    if (!(dev->deviate_size % LY_YANG_ARRAY_SIZE)) {\n        deviate = realloc(dev->deviate, (LY_YANG_ARRAY_SIZE + dev->deviate_size) * sizeof *deviate);\n        LY_CHECK_ERR_RETURN(!deviate, LOGMEM(ctx), NULL);\n        memset(deviate + dev->deviate_size, 0, LY_YANG_ARRAY_SIZE * sizeof *deviate);\n        dev->deviate = deviate;\n    }\n    dev->deviate[dev->deviate_size].mod = mod;\n    return &dev->deviate[dev->deviate_size++];\n}\n\nint\nyang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n\n    /* check target node type */\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        /* check values */\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        /* remove current units value of the target */\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        /* remove its extensions */\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            /* check that there is no current value */\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { /* replace */\n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        /* remove current units value of the target ... */\n        lydict_remove(ctx, *stritem);\n\n        /* ... and replace it with the value specified in deviation */\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_deviate_unique(struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct ly_ctx *ctx = dev_target->module->ctx;\n    struct lys_node_list *list;\n    struct lys_unique *unique;\n\n    /* check target node type */\n    if (dev_target->nodetype != LYS_LIST) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"unique\\\" property.\");\n        goto error;\n    }\n\n    list = (struct lys_node_list *)dev_target;\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* reallocate the unique array of the target */\n        unique = ly_realloc(list->unique, (deviate->unique_size + list->unique_size) * sizeof *unique);\n        LY_CHECK_ERR_GOTO(!unique, LOGMEM(ctx), error);\n        list->unique = unique;\n        memset(unique + list->unique_size, 0, deviate->unique_size * sizeof *unique);\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_fill_deviate_default(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target,\n                          struct ly_set *dflt_check, const char *value)\n{\n    struct lys_node *node;\n    struct lys_node_choice *choice;\n    struct lys_node_leaf *leaf;\n    struct lys_node_leaflist *llist;\n    int rc, i, j;\n    unsigned int u;\n\n    u = strlen(value);\n    if (dev_target->nodetype == LYS_CHOICE) {\n        choice = (struct lys_node_choice *)dev_target;\n        rc = resolve_choice_default_schema_nodeid(value, choice->child, (const struct lys_node **)&node);\n        if (rc || !node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n            goto error;\n        }\n        if (deviate->mod == LY_DEVIATE_DEL) {\n            if (!choice->dflt || (choice->dflt != node)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n                goto error;\n            }\n            choice->dflt = NULL;\n            /* remove extensions of this default instance from the target node */\n            j = -1;\n            while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_DEFAULT)) != -1) {\n                lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n                --j;\n            }\n        } else { /* add or replace */\n            choice->dflt = node;\n            if (!choice->dflt) {\n                /* default branch not found */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                goto error;\n            }\n        }\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        leaf = (struct lys_node_leaf *)dev_target;\n        if (deviate->mod == LY_DEVIATE_DEL) {\n            if (!leaf->dflt || !ly_strequal(leaf->dflt, value, 1)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n                goto error;\n            }\n            /* remove value */\n            lydict_remove(ctx, leaf->dflt);\n            leaf->dflt = NULL;\n            leaf->flags &= ~LYS_DFLTJSON;\n            /* remove extensions of this default instance from the target node */\n            j = -1;\n            while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_DEFAULT)) != -1) {\n                lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n                --j;\n            }\n        } else { /* add (already checked) and replace */\n            /* remove value */\n            lydict_remove(ctx, leaf->dflt);\n            leaf->flags &= ~LYS_DFLTJSON;\n\n            /* set new value */\n            leaf->dflt = lydict_insert(ctx, value, u);\n\n            /* remember to check it later (it may not fit now, but the type can be deviated too) */\n            ly_set_add(dflt_check, dev_target, 0);\n        }\n    } else { /* LYS_LEAFLIST */\n        llist = (struct lys_node_leaflist *)dev_target;\n        if (deviate->mod == LY_DEVIATE_DEL) {\n            /* find and remove the value in target list */\n            for (i = 0; i < llist->dflt_size; i++) {\n                if (llist->dflt[i] && ly_strequal(llist->dflt[i], value, 1)) {\n                    /* match, remove the value */\n                    lydict_remove(llist->module->ctx, llist->dflt[i]);\n                    llist->dflt[i] = NULL;\n                    /* remove extensions of this default instance from the target node */\n                    j = -1;\n                    while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_DEFAULT)) != -1) {\n                        if (dev_target->ext[j]->insubstmt_index == i) {\n                            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n                            --j;\n                        } else if (dev_target->ext[j]->insubstmt_index > i) {\n                            /* decrease the substatement index of the extension because of the changed array of defaults */\n                            dev_target->ext[j]->insubstmt_index--;\n                        }\n                    }\n                    break;\n                }\n            }\n            if (i == llist->dflt_size) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The default value to delete not found in the target node.\");\n                goto error;\n            }\n        } else {\n            /* add or replace, anyway we place items into the deviate's list\n               which propagates to the target */\n            /* we just want to check that the value isn't already in the list */\n            for (i = 0; i < llist->dflt_size; i++) {\n                if (ly_strequal(llist->dflt[i], value, 1)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", value);\n                    goto error;\n                }\n            }\n            /* store it in target node */\n            llist->dflt[llist->dflt_size++] = lydict_insert(ctx, value, u);\n\n            /* remember to check it later (it may not fit now, but the type can be deviated too) */\n            ly_set_add(dflt_check, dev_target, 0);\n            llist->flags &= ~LYS_DFLTJSON;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_deviate_default(struct lys_module *module, struct lys_deviate *deviate,\n                          struct lys_node *dev_target, struct ly_set * dflt_check)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i;\n    struct lys_node_leaflist *llist;\n    const char **dflt;\n\n    /* check target node type */\n    if (module->version < 2 && dev_target->nodetype == LYS_LEAFLIST) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"default\\\" property.\");\n        goto error;\n    } else if (deviate->dflt_size > 1 && dev_target->nodetype != LYS_LEAFLIST) { /* from YANG 1.1 */\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow multiple \\\"default\\\" properties.\");\n        goto error;\n    } else if (!(dev_target->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"default\\\" property.\");\n        goto error;\n    }\n\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* check that there is no current value */\n        if ((dev_target->nodetype == LYS_LEAF && ((struct lys_node_leaf *)dev_target)->dflt) ||\n                (dev_target->nodetype == LYS_CHOICE && ((struct lys_node_choice *)dev_target)->dflt)) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n            goto error;\n        }\n\n        /* check collision with mandatory/min-elements */\n        if ((dev_target->flags & LYS_MAND_TRUE) ||\n                (dev_target->nodetype == LYS_LEAFLIST && ((struct lys_node_leaflist *)dev_target)->min)) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"deviation\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                   \"Adding the \\\"default\\\" statement is forbidden on %s statement.\",\n                   (dev_target->flags & LYS_MAND_TRUE) ? \"nodes with the \\\"mandatory\\\"\" : \"leaflists with non-zero \\\"min-elements\\\"\");\n            goto error;\n        }\n    } else if (deviate->mod == LY_DEVIATE_RPL) {\n        /* check that there was a value before */\n        if (((dev_target->nodetype & (LYS_LEAF | LYS_LEAFLIST)) && !((struct lys_node_leaf *)dev_target)->dflt) ||\n                (dev_target->nodetype == LYS_CHOICE && !((struct lys_node_choice *)dev_target)->dflt)) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n            goto error;\n        }\n    }\n\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        /* reallocate default list in the target */\n        llist = (struct lys_node_leaflist *)dev_target;\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            /* reallocate (enlarge) the unique array of the target */\n            dflt = realloc(llist->dflt, (deviate->dflt_size + llist->dflt_size) * sizeof *dflt);\n            LY_CHECK_ERR_GOTO(!dflt, LOGMEM(ctx), error);\n            llist->dflt = dflt;\n        } else if (deviate->mod == LY_DEVIATE_RPL) {\n            /* reallocate (replace) the unique array of the target */\n            for (i = 0; i < llist->dflt_size; i++) {\n                lydict_remove(ctx, llist->dflt[i]);\n            }\n            dflt = realloc(llist->dflt, deviate->dflt_size * sizeof *dflt);\n            LY_CHECK_ERR_GOTO(!dflt, LOGMEM(ctx), error);\n            llist->dflt = dflt;\n            llist->dflt_size = 0;\n        }\n    }\n\n    for (i = 0; i < deviate->dflt_size; ++i) {\n        if (yang_fill_deviate_default(ctx, deviate, dev_target, dflt_check, deviate->dflt[i])) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_deviate_mandatory(struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct ly_ctx *ctx = dev_target->module->ctx;\n    struct lys_node *parent;\n\n    /* check target node type */\n    if (!(dev_target->nodetype & (LYS_LEAF | LYS_CHOICE | LYS_ANYDATA))) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"mandatory\\\" property.\");\n        goto error;\n    }\n\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* check that there is no current value */\n        if (dev_target->flags & LYS_MAND_MASK) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n            goto error;\n        } else {\n            if (dev_target->nodetype == LYS_LEAF && ((struct lys_node_leaf *)dev_target)->dflt) {\n                /* RFC 6020, 7.6.4 - default statement must not with mandatory true */\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"leaf\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                goto error;\n            } else if (dev_target->nodetype == LYS_CHOICE && ((struct lys_node_choice *)dev_target)->dflt) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"choice\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"mandatory\\\" statement is forbidden on choices with \\\"default\\\".\");\n                goto error;\n            }\n        }\n    } else { /* replace */\n        if (!(dev_target->flags & LYS_MAND_MASK)) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n            goto error;\n        }\n    }\n\n    /* remove current mandatory value of the target ... */\n    dev_target->flags &= ~LYS_MAND_MASK;\n\n    /* ... and replace it with the value specified in deviation */\n    dev_target->flags |= deviate->flags & LYS_MAND_MASK;\n\n    /* check for mandatory node in default case, first find the closest parent choice to the changed node */\n    for (parent = dev_target->parent;\n         parent && !(parent->nodetype & (LYS_CHOICE | LYS_GROUPING | LYS_ACTION));\n         parent = parent->parent) {\n        if (parent->nodetype == LYS_CONTAINER && ((struct lys_node_container *)parent)->presence) {\n            /* stop also on presence containers */\n            break;\n        }\n    }\n    /* and if it is a choice with the default case, check it for presence of a mandatory node in it */\n    if (parent && parent->nodetype == LYS_CHOICE && ((struct lys_node_choice *)parent)->dflt) {\n        if (lyp_check_mandatory_choice(parent)) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_deviate_minmax(struct lys_deviate *deviate, struct lys_node *dev_target, uint32_t value, int type)\n{\n    struct ly_ctx *ctx = dev_target->module->ctx;\n    uint32_t *ui32val, *min, *max;\n\n    /* check target node type */\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        max = &((struct lys_node_leaflist *)dev_target)->max;\n        min = &((struct lys_node_leaflist *)dev_target)->min;\n    } else if (dev_target->nodetype == LYS_LIST) {\n        max = &((struct lys_node_list *)dev_target)->max;\n        min = &((struct lys_node_list *)dev_target)->min;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, (type) ? \"max-elements\" : \"min-elements\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"%s\\\" property.\", (type) ? \"max-elements\" : \"min-elements\");\n        goto error;\n    }\n\n    ui32val = (type) ? max : min;\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* check that there is no current value */\n        if (*ui32val) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, (type) ? \"max-elements\" : \"min-elements\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n            goto error;\n        }\n    } else if (deviate->mod == LY_DEVIATE_RPL) {\n        /* unfortunately, there is no way to check reliably that there\n         * was a value before, it could have been the default */\n    }\n\n    /* add (already checked) and replace */\n    /* set new value specified in deviation */\n    *ui32val = value;\n\n    /* check min-elements is smaller than max-elements */\n    if (*max && *min > *max) {\n        if (type) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"max-elements\\\".\", value);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"min-elements\\\".\", value);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n        }\n        goto error;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_deviate_must(struct lys_module *module, struct unres_schema *unres,\n                        struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, erase_must = 1;\n    struct lys_restr **trg_must, *must;\n    uint8_t *trg_must_size;\n\n    /* check target node type */\n    switch (dev_target->nodetype) {\n        case LYS_LEAF:\n            trg_must = &((struct lys_node_leaf *)dev_target)->must;\n            trg_must_size = &((struct lys_node_leaf *)dev_target)->must_size;\n            break;\n        case LYS_CONTAINER:\n            trg_must = &((struct lys_node_container *)dev_target)->must;\n            trg_must_size = &((struct lys_node_container *)dev_target)->must_size;\n            break;\n        case LYS_LEAFLIST:\n            trg_must = &((struct lys_node_leaflist *)dev_target)->must;\n            trg_must_size = &((struct lys_node_leaflist *)dev_target)->must_size;\n            break;\n        case LYS_LIST:\n            trg_must = &((struct lys_node_list *)dev_target)->must;\n            trg_must_size = &((struct lys_node_list *)dev_target)->must_size;\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            trg_must = &((struct lys_node_anydata *)dev_target)->must;\n            trg_must_size = &((struct lys_node_anydata *)dev_target)->must_size;\n            break;\n        default:\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"must\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"must\\\" property.\");\n            goto error;\n    }\n\n    /* flag will be checked again, clear it for now */\n    dev_target->flags &= ~(LYS_XPCONF_DEP | LYS_XPSTATE_DEP);\n\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* reallocate the must array of the target */\n        must = ly_realloc(*trg_must, (deviate->must_size + *trg_must_size) * sizeof *must);\n        LY_CHECK_ERR_GOTO(!must, LOGMEM(ctx), error);\n        *trg_must = must;\n        memcpy(&(*trg_must)[*trg_must_size], deviate->must, deviate->must_size * sizeof *must);\n        *trg_must_size = *trg_must_size + deviate->must_size;\n        erase_must = 0;\n    } else if (deviate->mod == LY_DEVIATE_DEL) {\n        /* find must to delete, we are ok with just matching conditions */\n        for (j = 0; j < deviate->must_size; ++j) {\n            for (i = 0; i < *trg_must_size; i++) {\n                if (ly_strequal(deviate->must[j].expr, (*trg_must)[i].expr, 1)) {\n                    /* we have a match, free the must structure ... */\n                    lys_restr_free(module->ctx, &((*trg_must)[i]), NULL);\n                    /* ... and maintain the array */\n                    (*trg_must_size)--;\n                    if (i != *trg_must_size) {\n                        memcpy(&(*trg_must)[i], &(*trg_must)[*trg_must_size], sizeof *must);\n                    }\n                    if (!(*trg_must_size)) {\n                        free(*trg_must);\n                        *trg_must = NULL;\n                    } else {\n                        memset(&(*trg_must)[*trg_must_size], 0, sizeof *must);\n                    }\n\n                    i = -1; /* set match flag */\n                    break;\n                }\n            }\n            if (i != -1) {\n                /* no match found */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->must[j].expr, \"must\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value does not match any must from the target.\");\n                goto error;\n            }\n        }\n    }\n\n    if (yang_check_must(module, deviate->must, deviate->must_size, unres)) {\n        goto error;\n    }\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && *trg_must_size\n            && (unres_schema_add_node(module, unres, dev_target, UNRES_XPATH, NULL) == -1)) {\n        goto error;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (deviate->mod == LY_DEVIATE_ADD && erase_must) {\n        for (i = 0; i < deviate->must_size; ++i) {\n            lys_restr_free(module->ctx, &deviate->must[i], NULL);\n        }\n        free(deviate->must);\n    }\n    return EXIT_FAILURE;\n}\n\nint\nyang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n\n    /* find unique structures to delete */\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n\n        if (j == deviate->unique[index].expr_size) {\n            /* we have a match, free the unique structure ... */\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            /* ... and maintain the array */\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n\n            k = i; /* remember index for removing extensions */\n            i = -1; /* set match flag */\n            break;\n        }\n    }\n\n    if (i != -1) {\n        /* no match found */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n\n    /* remove extensions of this unique instance from the target node */\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            /* decrease the substatement index of the extension because of the changed array of uniques */\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\nint yang_check_deviate_unique(struct lys_module *module, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct lys_node_list *list;\n    char *str;\n    uint i = 0;\n    struct lys_unique *last_unique = NULL;\n\n    if (yang_read_deviate_unique(deviate, dev_target)) {\n        goto error;\n    }\n    list = (struct lys_node_list *)dev_target;\n    last_unique = &list->unique[list->unique_size];\n    for (i = 0; i < deviate->unique_size; ++i) {\n        str = (char *) deviate->unique[i].expr;\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (yang_fill_unique(module, list, &list->unique[list->unique_size], str, NULL)) {\n                free(str);\n                goto error;\n            }\n            list->unique_size++;\n        } else if (deviate->mod == LY_DEVIATE_DEL) {\n            if (yang_fill_unique(module, list, &deviate->unique[i], str, NULL)) {\n                free(str);\n                goto error;\n            }\n            if (yang_deviate_delete_unique(module, deviate, list, i, str)) {\n                free(str);\n                goto error;\n            }\n        }\n        free(str);\n    }\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        free(deviate->unique);\n        deviate->unique = last_unique;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        for (i = i + 1; i < deviate->unique_size; ++i) {\n            free(deviate->unique[i].expr);\n        }\n        free(deviate->unique);\n        deviate->unique = last_unique;\n\n    }\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_fill_include(struct lys_module *trg, char *value, struct lys_include *inc,\n                  struct unres_schema *unres)\n{\n    const char *str;\n    int rc;\n    int ret = 0;\n\n    str = lydict_insert_zc(trg->ctx, value);\n    rc = lyp_check_include(trg, str, inc, unres);\n    if (!rc) {\n        /* success, copy the filled data into the final array */\n        memcpy(&trg->inc[trg->inc_size], inc, sizeof *inc);\n        if (yang_check_ext_instance(trg, &trg->inc[trg->inc_size].ext, trg->inc[trg->inc_size].ext_size,\n                                    &trg->inc[trg->inc_size], unres)) {\n            ret = -1;\n        }\n        trg->inc_size++;\n    } else if (rc == -1) {\n        lys_extension_instances_free(trg->ctx, inc->ext, inc->ext_size, NULL);\n        ret = -1;\n    }\n\n    lydict_remove(trg->ctx, str);\n    return ret;\n}\n\nstruct lys_ext_instance *\nyang_ext_instance(void *node, enum yytokentype type, int is_ext_instance)\n{\n    struct lys_ext_instance ***ext, **tmp, *instance = NULL;\n    LYEXT_PAR parent_type;\n    uint8_t *size;\n\n    switch (type) {\n    case MODULE_KEYWORD:\n    case SUBMODULE_KEYWORD:\n        ext = &((struct lys_module *)node)->ext;\n        size = &((struct lys_module *)node)->ext_size;\n        parent_type = LYEXT_PAR_MODULE;\n        break;\n    case BELONGS_TO_KEYWORD:\n        if (is_ext_instance) {\n            ext = &((struct lys_ext_instance *)node)->ext;\n            size = &((struct lys_ext_instance *)node)->ext_size;\n            parent_type = LYEXT_PAR_EXTINST;\n        } else {\n            ext = &((struct lys_module *)node)->ext;\n            size = &((struct lys_module *)node)->ext_size;\n            parent_type = LYEXT_PAR_MODULE;\n        }\n        break;\n    case IMPORT_KEYWORD:\n        ext = &((struct lys_import *)node)->ext;\n        size = &((struct lys_import *)node)->ext_size;\n        parent_type = LYEXT_PAR_IMPORT;\n        break;\n    case INCLUDE_KEYWORD:\n        ext = &((struct lys_include *)node)->ext;\n        size = &((struct lys_include *)node)->ext_size;\n        parent_type = LYEXT_PAR_INCLUDE;\n        break;\n    case REVISION_KEYWORD:\n        ext = &((struct lys_revision *)node)->ext;\n        size = &((struct lys_revision *)node)->ext_size;\n        parent_type = LYEXT_PAR_REVISION;\n        break;\n    case GROUPING_KEYWORD:\n    case CONTAINER_KEYWORD:\n    case LEAF_KEYWORD:\n    case LEAF_LIST_KEYWORD:\n    case LIST_KEYWORD:\n    case CHOICE_KEYWORD:\n    case CASE_KEYWORD:\n    case ANYXML_KEYWORD:\n    case ANYDATA_KEYWORD:\n    case USES_KEYWORD:\n    case AUGMENT_KEYWORD:\n    case ACTION_KEYWORD:\n    case RPC_KEYWORD:\n    case INPUT_KEYWORD:\n    case OUTPUT_KEYWORD:\n    case NOTIFICATION_KEYWORD:\n        ext = &((struct lys_node *)node)->ext;\n        size = &((struct lys_node *)node)->ext_size;\n        parent_type = LYEXT_PAR_NODE;\n        break;\n    case ARGUMENT_KEYWORD:\n        if (is_ext_instance) {\n            ext = &((struct lys_ext_instance *)node)->ext;\n            size = &((struct lys_ext_instance *)node)->ext_size;\n            parent_type = LYEXT_PAR_EXTINST;\n        } else {\n            ext = &((struct lys_ext *)node)->ext;\n            size = &((struct lys_ext *)node)->ext_size;\n            parent_type = LYEXT_PAR_EXT;\n        }\n        break;\n    case EXTENSION_KEYWORD:\n        ext = &((struct lys_ext *)node)->ext;\n        size = &((struct lys_ext *)node)->ext_size;\n        parent_type = LYEXT_PAR_EXT;\n        break;\n    case FEATURE_KEYWORD:\n        ext = &((struct lys_feature *)node)->ext;\n        size = &((struct lys_feature *)node)->ext_size;\n        parent_type = LYEXT_PAR_FEATURE;\n        break;\n    case IDENTITY_KEYWORD:\n        ext = &((struct lys_ident *)node)->ext;\n        size = &((struct lys_ident *)node)->ext_size;\n        parent_type = LYEXT_PAR_IDENT;\n        break;\n    case IF_FEATURE_KEYWORD:\n        ext = &((struct lys_iffeature *)node)->ext;\n        size = &((struct lys_iffeature *)node)->ext_size;\n        parent_type = LYEXT_PAR_IFFEATURE;\n        break;\n    case TYPEDEF_KEYWORD:\n        ext = &((struct lys_tpdf *)node)->ext;\n        size = &((struct lys_tpdf *)node)->ext_size;\n        parent_type = LYEXT_PAR_TPDF;\n        break;\n    case TYPE_KEYWORD:\n        ext = &((struct yang_type *)node)->type->ext;\n        size = &((struct yang_type *)node)->type->ext_size;\n        parent_type = LYEXT_PAR_TYPE;\n        break;\n    case LENGTH_KEYWORD:\n    case PATTERN_KEYWORD:\n    case RANGE_KEYWORD:\n    case MUST_KEYWORD:\n        ext = &((struct lys_restr *)node)->ext;\n        size = &((struct lys_restr *)node)->ext_size;\n        parent_type = LYEXT_PAR_RESTR;\n        break;\n    case WHEN_KEYWORD:\n        ext = &((struct lys_when *)node)->ext;\n        size = &((struct lys_when *)node)->ext_size;\n        parent_type = LYEXT_PAR_RESTR;\n        break;\n    case ENUM_KEYWORD:\n        ext = &((struct lys_type_enum *)node)->ext;\n        size = &((struct lys_type_enum *)node)->ext_size;\n        parent_type = LYEXT_PAR_TYPE_ENUM;\n        break;\n    case BIT_KEYWORD:\n        ext = &((struct lys_type_bit *)node)->ext;\n        size = &((struct lys_type_bit *)node)->ext_size;\n        parent_type = LYEXT_PAR_TYPE_BIT;\n        break;\n    case REFINE_KEYWORD:\n        ext = &((struct lys_type_bit *)node)->ext;\n        size = &((struct lys_type_bit *)node)->ext_size;\n        parent_type = LYEXT_PAR_REFINE;\n        break;\n    case DEVIATION_KEYWORD:\n        ext = &((struct lys_deviation *)node)->ext;\n        size = &((struct lys_deviation *)node)->ext_size;\n        parent_type = LYEXT_PAR_DEVIATION;\n        break;\n    case NOT_SUPPORTED_KEYWORD:\n    case ADD_KEYWORD:\n    case DELETE_KEYWORD:\n    case REPLACE_KEYWORD:\n        ext = &((struct lys_deviate *)node)->ext;\n        size = &((struct lys_deviate *)node)->ext_size;\n        parent_type = LYEXT_PAR_DEVIATE;\n        break;\n    case EXTENSION_INSTANCE:\n        ext = &((struct lys_ext_instance *)node)->ext;\n        size = &((struct lys_ext_instance *)node)->ext_size;\n        parent_type = LYEXT_PAR_EXTINST;\n        break;\n    default:\n        LOGINT(NULL);\n        return NULL;\n    }\n\n    instance = calloc(1, sizeof *instance);\n    if (!instance) {\n        goto error;\n    }\n    instance->parent_type = parent_type;\n    tmp = realloc(*ext, (*size + 1) * sizeof *tmp);\n    if (!tmp) {\n        goto error;\n    }\n    tmp[*size] = instance;\n    *ext = tmp;\n    (*size)++;\n    return instance;\n\nerror:\n    LOGMEM(NULL);\n    free(instance);\n    return NULL;\n}\n\nvoid *\nyang_read_ext(struct lys_module *module, void *actual, char *ext_name, char *ext_arg,\n              enum yytokentype actual_type, enum yytokentype backup_type, int is_ext_instance)\n{\n    struct lys_ext_instance *instance;\n    LY_STMT stmt = LY_STMT_UNKNOWN;\n    LYEXT_SUBSTMT insubstmt;\n    uint8_t insubstmt_index = 0;\n\n    if (backup_type != NODE) {\n        switch (actual_type) {\n        case YANG_VERSION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_VERSION;\n            stmt = LY_STMT_VERSION;\n            break;\n        case NAMESPACE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_NAMESPACE;\n            stmt = LY_STMT_NAMESPACE;\n            break;\n        case PREFIX_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_PREFIX;\n            stmt = LY_STMT_PREFIX;\n            break;\n        case REVISION_DATE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_REVISIONDATE;\n            stmt = LY_STMT_REVISIONDATE;\n            break;\n        case DESCRIPTION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_DESCRIPTION;\n            stmt = LY_STMT_DESCRIPTION;\n            break;\n        case REFERENCE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_REFERENCE;\n            stmt = LY_STMT_REFERENCE;\n            break;\n        case CONTACT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_CONTACT;\n            stmt = LY_STMT_CONTACT;\n            break;\n        case ORGANIZATION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ORGANIZATION;\n            stmt = LY_STMT_ORGANIZATION;\n            break;\n        case YIN_ELEMENT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_YINELEM;\n            stmt = LY_STMT_YINELEM;\n            break;\n        case STATUS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_STATUS;\n            stmt = LY_STMT_STATUS;\n            break;\n        case BASE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_BASE;\n            stmt = LY_STMT_BASE;\n            if (backup_type == IDENTITY_KEYWORD) {\n                insubstmt_index = ((struct lys_ident *)actual)->base_size;\n            } else if (backup_type == TYPE_KEYWORD) {\n                insubstmt_index = ((struct yang_type *)actual)->type->info.ident.count;\n            }\n            break;\n        case DEFAULT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_DEFAULT;\n            stmt = LY_STMT_DEFAULT;\n            switch (backup_type) {\n            case LEAF_LIST_KEYWORD:\n                insubstmt_index = ((struct lys_node_leaflist *)actual)->dflt_size;\n                break;\n            case REFINE_KEYWORD:\n                insubstmt_index = ((struct lys_refine *)actual)->dflt_size;\n                break;\n            case ADD_KEYWORD:\n                insubstmt_index = ((struct lys_deviate *)actual)->dflt_size;\n                break;\n            default:\n                /* nothing changes */\n                break;\n            }\n            break;\n        case UNITS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_UNITS;\n            stmt = LY_STMT_UNITS;\n            break;\n        case REQUIRE_INSTANCE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_REQINSTANCE;\n            stmt = LY_STMT_REQINSTANCE;\n            break;\n        case PATH_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_PATH;\n            stmt = LY_STMT_PATH;\n            break;\n        case ERROR_MESSAGE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ERRMSG;\n            stmt = LY_STMT_ERRMSG;\n            break;\n        case ERROR_APP_TAG_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ERRTAG;\n            stmt = LY_STMT_ERRTAG;\n            break;\n        case MODIFIER_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MODIFIER;\n            stmt = LY_STMT_MODIFIER;\n            break;\n        case FRACTION_DIGITS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_DIGITS;\n            stmt = LY_STMT_DIGITS;\n            break;\n        case VALUE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_VALUE;\n            stmt = LY_STMT_VALUE;\n            break;\n        case POSITION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_POSITION;\n            stmt = LY_STMT_POSITION;\n            break;\n        case PRESENCE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_PRESENCE;\n            stmt = LY_STMT_PRESENCE;\n            break;\n        case CONFIG_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_CONFIG;\n            stmt = LY_STMT_CONFIG;\n            break;\n        case MANDATORY_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MANDATORY;\n            stmt = LY_STMT_MANDATORY;\n            break;\n        case MIN_ELEMENTS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MIN;\n            stmt = LY_STMT_MIN;\n            break;\n        case MAX_ELEMENTS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MAX;\n            stmt = LY_STMT_MAX;\n            break;\n        case ORDERED_BY_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ORDEREDBY;\n            stmt = LY_STMT_ORDEREDBY;\n            break;\n        case KEY_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_KEY;\n            stmt = LY_STMT_KEY;\n            break;\n        case UNIQUE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_UNIQUE;\n            stmt = LY_STMT_UNIQUE;\n            switch (backup_type) {\n            case LIST_KEYWORD:\n                insubstmt_index = ((struct lys_node_list *)actual)->unique_size;\n                break;\n            case ADD_KEYWORD:\n            case DELETE_KEYWORD:\n            case REPLACE_KEYWORD:\n                insubstmt_index = ((struct lys_deviate *)actual)->unique_size;\n                break;\n            default:\n                /* nothing changes */\n                break;\n            }\n            break;\n        default:\n            LOGINT(module->ctx);\n            return NULL;\n        }\n\n        instance = yang_ext_instance(actual, backup_type, is_ext_instance);\n    } else {\n        switch (actual_type) {\n        case ARGUMENT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ARGUMENT;\n            stmt = LY_STMT_ARGUMENT;\n            break;\n        case BELONGS_TO_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_BELONGSTO;\n            stmt = LY_STMT_BELONGSTO;\n            break;\n        default:\n            insubstmt = LYEXT_SUBSTMT_SELF;\n            break;\n        }\n\n        instance = yang_ext_instance(actual, actual_type, is_ext_instance);\n    }\n\n    if (!instance) {\n        return NULL;\n    }\n    instance->insubstmt = insubstmt;\n    instance->insubstmt_index = insubstmt_index;\n    instance->flags |= LYEXT_OPT_YANG;\n    instance->def = (struct lys_ext *)ext_name;    /* hack for UNRES */\n    instance->arg_value = lydict_insert_zc(module->ctx, ext_arg);\n    if (is_ext_instance && stmt != LY_STMT_UNKNOWN && instance->parent_type == LYEXT_PAR_EXTINST) {\n        instance->insubstmt_index = yang_fill_ext_substm_index(actual, stmt, backup_type);\n    }\n    return instance;\n}\n\nstatic int\ncheck_status_flag(struct lys_node *node, struct lys_node *parent)\n{\n    struct ly_ctx *ctx = node->module->ctx;\n    char *str;\n\n    if (node->nodetype & (LYS_OUTPUT | LYS_INPUT)) {\n        return EXIT_SUCCESS;\n    }\n\n    if (parent && (parent->flags & (LYS_STATUS_DEPRC | LYS_STATUS_OBSLT))) {\n        /* status is not inherited by specification, but it not make sense to have\n         * current in deprecated or deprecated in obsolete, so we print warning\n         * and fix the schema by inheriting */\n        if (!(node->flags & (LYS_STATUS_MASK))) {\n            /* status not explicitely specified on the current node -> inherit */\n            str = lys_path(node, LYS_PATH_FIRST_PREFIX);\n            LOGWRN(ctx, \"Missing status in %s subtree (%s), inheriting.\",\n                   parent->flags & LYS_STATUS_DEPRC ? \"deprecated\" : \"obsolete\", str);\n            free(str);\n            node->flags |= parent->flags & LYS_STATUS_MASK;\n        } else if ((parent->flags & LYS_STATUS_MASK) > (node->flags & LYS_STATUS_MASK)) {\n            /* invalid combination of statuses */\n            switch (node->flags & LYS_STATUS_MASK) {\n                case 0:\n                case LYS_STATUS_CURR:\n                    LOGVAL(ctx, LYE_INSTATUS, LY_VLOG_LYS, parent, \"current\", strnodetype(node->nodetype), \"is child of\",\n                           parent->flags & LYS_STATUS_DEPRC ? \"deprecated\" : \"obsolete\", parent->name);\n                    break;\n                case LYS_STATUS_DEPRC:\n                    LOGVAL(ctx, LYE_INSTATUS, LY_VLOG_LYS, parent, \"deprecated\", strnodetype(node->nodetype), \"is child of\",\n                           \"obsolete\", parent->name);\n                    break;\n            }\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nstore_config_flag(struct lys_node *node, int options)\n{\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n    case LYS_CHOICE:\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        if (options & LYS_PARSE_OPT_CFG_IGNORE) {\n            node->flags |= node->flags & (~(LYS_CONFIG_MASK | LYS_CONFIG_SET));\n        } else if (!(options & LYS_PARSE_OPT_CFG_NOINHERIT)) {\n            if (!(node->flags & LYS_CONFIG_MASK)) {\n                /* get config flag from parent */\n                if (node->parent) {\n                    node->flags |= node->parent->flags & LYS_CONFIG_MASK;\n                } else {\n                    /* default config is true */\n                    node->flags |= LYS_CONFIG_W;\n                }\n            }\n        }\n        break;\n    case LYS_CASE:\n        if (!(options & (LYS_PARSE_OPT_CFG_IGNORE | LYS_PARSE_OPT_CFG_NOINHERIT))) {\n            if (!(node->flags & LYS_CONFIG_MASK)) {\n                /* get config flag from parent */\n                if (node->parent) {\n                    node->flags |= node->parent->flags & LYS_CONFIG_MASK;\n                } else {\n                    /* default config is true */\n                    node->flags |= LYS_CONFIG_W;\n                }\n            }\n        }\n        break;\n    default:\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_parse_mem(struct lys_module *module, struct lys_submodule *submodule, struct unres_schema *unres,\n               const char *data, unsigned int size_data, struct lys_node **node)\n{\n    unsigned int size;\n    YY_BUFFER_STATE bp;\n    yyscan_t scanner = NULL;\n    int ret = 0;\n    struct lys_module *trg;\n    struct yang_parameter param;\n\n    size = (size_data) ? size_data : strlen(data) + 2;\n    yylex_init(&scanner);\n    yyset_extra(module->ctx, scanner);\n    bp = yy_scan_buffer((char *)data, size, scanner);\n    yy_switch_to_buffer(bp, scanner);\n    memset(&param, 0, sizeof param);\n    param.module = module;\n    param.submodule = submodule;\n    param.unres = unres;\n    param.node = node;\n    param.flags |= YANG_REMOVE_IMPORT;\n    if (yyparse(scanner, &param)) {\n        if (param.flags & YANG_REMOVE_IMPORT) {\n            trg = (submodule) ? (struct lys_module *)submodule : module;\n            yang_free_import(trg->ctx, trg->imp, 0, trg->imp_size);\n            yang_free_include(trg->ctx, trg->inc, 0, trg->inc_size);\n            trg->inc_size = 0;\n            trg->imp_size = 0;\n        }\n        ret = (param.flags & YANG_EXIST_MODULE) ? 1 : -1;\n    }\n    yy_delete_buffer(bp, scanner);\n    yylex_destroy(scanner);\n    return ret;\n}\n\nint\nyang_parse_ext_substatement(struct lys_module *module, struct unres_schema *unres, const char *data,\n                            char *ext_name, struct lys_ext_instance_complex *ext)\n{\n    unsigned int size;\n    YY_BUFFER_STATE bp;\n    yyscan_t scanner = NULL;\n    int ret = 0;\n    struct yang_parameter param;\n    struct lys_node *node = NULL;\n\n    if (!data) {\n        return EXIT_SUCCESS;\n    }\n    size = strlen(data) + 2;\n    yylex_init(&scanner);\n    bp = yy_scan_buffer((char *)data, size, scanner);\n    yy_switch_to_buffer(bp, scanner);\n    memset(&param, 0, sizeof param);\n    param.module = module;\n    param.unres = unres;\n    param.node = &node;\n    param.actual_node = (void **)ext;\n    param.data_node = (void **)ext_name;\n    param.flags |= EXT_INSTANCE_SUBSTMT;\n    if (yyparse(scanner, &param)) {\n        yang_free_nodes(module->ctx, node);\n        ret = -1;\n    } else {\n        /* success parse, but it needs some sematic controls */\n        if (node && yang_check_nodes(module, (struct lys_node *)ext, node, LYS_PARSE_OPT_CFG_NOINHERIT, unres)) {\n            ret = -1;\n        }\n    }\n    yy_delete_buffer(bp, scanner);\n    yylex_destroy(scanner);\n    return ret;\n}\n\nstruct lys_module *\nyang_read_module(struct ly_ctx *ctx, const char* data, unsigned int size, const char *revision, int implement)\n{\n    struct lys_module *module = NULL, *tmp_mod;\n    struct unres_schema *unres = NULL;\n    struct lys_node *node = NULL;\n    int ret;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_GOTO(!unres, LOGMEM(ctx), error);\n\n    module = calloc(1, sizeof *module);\n    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);\n\n    /* initiale module */\n    module->ctx = ctx;\n    module->type = 0;\n    module->implemented = (implement ? 1 : 0);\n\n    /* add into the list of processed modules */\n    if (lyp_check_circmod_add(module)) {\n        goto error;\n    }\n\n    ret = yang_parse_mem(module, NULL, unres, data, size, &node);\n    if (ret == -1) {\n        if (ly_vecode(ctx) == LYVE_SUBMODULE && !module->name) {\n            /* Remove this module from the list of processed modules,\n               as we're about to free it */\n            lyp_check_circmod_pop(ctx);\n\n            free(module);\n            module = NULL;\n        } else {\n            free_yang_common(module, node);\n        }\n        goto error;\n    } else if (ret == 1) {\n        assert(!unres->count);\n    } else {\n        if (yang_check_sub_module(module, unres, node)) {\n            goto error;\n        }\n\n        if (!implement && module->implemented && lys_make_implemented_r(module, unres)) {\n            goto error;\n        }\n\n        if (unres->count && resolve_unres_schema(module, unres)) {\n            goto error;\n        }\n\n        /* check correctness of includes */\n        if (lyp_check_include_missing(module)) {\n            goto error;\n        }\n    }\n\n    lyp_sort_revisions(module);\n\n    if (lyp_rfn_apply_ext(module) || lyp_deviation_apply_ext(module)) {\n        goto error;\n    }\n\n    if (revision) {\n        /* check revision of the parsed model */\n        if (!module->rev_size || strcmp(revision, module->rev[0].date)) {\n            LOGVRB(\"Module \\\"%s\\\" parsed with the wrong revision (\\\"%s\\\" instead \\\"%s\\\").\",\n                   module->name, module->rev[0].date, revision);\n            goto error;\n        }\n    }\n\n    /* add into context if not already there */\n    if (!ret) {\n        if (lyp_ctx_add_module(module)) {\n            goto error;\n        }\n\n        /* remove our submodules from the parsed submodules list */\n        lyp_del_includedup(module, 0);\n    } else {\n        tmp_mod = module;\n\n        /* get the model from the context */\n        module = (struct lys_module *)ly_ctx_get_module(ctx, module->name, revision, 0);\n        assert(module);\n\n        /* free what was parsed */\n        lys_free(tmp_mod, NULL, 0, 0);\n    }\n\n    unres_schema_free(NULL, &unres, 0);\n    lyp_check_circmod_pop(ctx);\n    LOGVRB(\"Module \\\"%s%s%s\\\" successfully parsed as %s.\", module->name, (module->rev_size ? \"@\" : \"\"),\n           (module->rev_size ? module->rev[0].date : \"\"), (module->implemented ? \"implemented\" : \"imported\"));\n    return module;\n\nerror:\n    /* cleanup */\n    unres_schema_free(module, &unres, 1);\n\n    if (!module) {\n        if (ly_vecode(ctx) != LYVE_SUBMODULE) {\n            LOGERR(ctx, ly_errno, \"Module parsing failed.\");\n        }\n        return NULL;\n    }\n\n    if (module->name) {\n        LOGERR(ctx, ly_errno, \"Module \\\"%s\\\" parsing failed.\", module->name);\n    } else {\n        LOGERR(ctx, ly_errno, \"Module parsing failed.\");\n    }\n\n    lyp_check_circmod_pop(ctx);\n    lys_sub_module_remove_devs_augs(module);\n    lyp_del_includedup(module, 1);\n    lys_free(module, NULL, 0, 1);\n    return NULL;\n}\n\nstruct lys_submodule *\nyang_read_submodule(struct lys_module *module, const char *data, unsigned int size, struct unres_schema *unres)\n{\n    struct lys_submodule *submodule;\n    struct lys_node *node = NULL;\n\n    submodule = calloc(1, sizeof *submodule);\n    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(module->ctx), error);\n\n    submodule->ctx = module->ctx;\n    submodule->type = 1;\n    submodule->implemented = module->implemented;\n    submodule->belongsto = module;\n\n    /* add into the list of processed modules */\n    if (lyp_check_circmod_add((struct lys_module *)submodule)) {\n        goto error;\n    }\n\n    /* module cannot be changed in this case and 1 cannot be returned */\n    if (yang_parse_mem(module, submodule, unres, data, size, &node)) {\n        free_yang_common((struct lys_module *)submodule, node);\n        goto error;\n    }\n\n    lyp_sort_revisions((struct lys_module *)submodule);\n\n    if (yang_check_sub_module((struct lys_module *)submodule, unres, node)) {\n        goto error;\n    }\n\n    lyp_check_circmod_pop(module->ctx);\n\n    LOGVRB(\"Submodule \\\"%s\\\" successfully parsed.\", submodule->name);\n    return submodule;\n\nerror:\n    /* cleanup */\n    if (!submodule || !submodule->name) {\n        free(submodule);\n        LOGERR(module->ctx, ly_errno, \"Submodule parsing failed.\");\n        return NULL;\n    }\n\n    LOGERR(module->ctx, ly_errno, \"Submodule \\\"%s\\\" parsing failed.\", submodule->name);\n\n    unres_schema_free((struct lys_module *)submodule, &unres, 0);\n    lyp_check_circmod_pop(module->ctx);\n    lys_sub_module_remove_devs_augs((struct lys_module *)submodule);\n    lys_submodule_module_data_free(submodule);\n    lys_submodule_free(submodule, NULL);\n    return NULL;\n}\n\nstatic int\nread_indent(const char *input, int indent, int size, int in_index, int *out_index, char *output)\n{\n    int k = 0, j;\n\n    while (in_index < size) {\n        if (input[in_index] == ' ') {\n            k++;\n        } else if (input[in_index] == '\\t') {\n            /* RFC 6020 6.1.3 tab character is treated as 8 space characters */\n            k += 8;\n        } else  if (input[in_index] == '\\\\' && input[in_index + 1] == 't') {\n            /* RFC 6020 6.1.3 tab character is treated as 8 space characters */\n            k += 8;\n            ++in_index;\n        } else {\n            break;\n        }\n        ++in_index;\n        if (k >= indent) {\n            for (j = k - indent; j > 0; --j) {\n                output[*out_index] = ' ';\n                if (j > 1) {\n                    ++(*out_index);\n                }\n            }\n            break;\n        }\n    }\n    return in_index - 1;\n}\n\nchar *\nyang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent)\n{\n    int i = 0, out_index = offset, space = 0;\n\n    while (i < size) {\n        switch (input[i]) {\n        case '\\n':\n            out_index -= space;\n            output[out_index] = '\\n';\n            space = 0;\n            i = read_indent(input, indent, size, i + 1, &out_index, output);\n            break;\n        case ' ':\n        case '\\t':\n            output[out_index] = input[i];\n            ++space;\n            break;\n        case '\\\\':\n            if (input[i + 1] == 'n') {\n                out_index -= space;\n                output[out_index] = '\\n';\n                space = 0;\n                i = read_indent(input, indent, size, i + 2, &out_index, output);\n            } else if (input[i + 1] == 't') {\n                output[out_index] = '\\t';\n                ++i;\n                ++space;\n            } else if (input[i + 1] == '\\\\') {\n                output[out_index] = '\\\\';\n                ++i;\n            } else if ((i + 1) != size && input[i + 1] == '\"') {\n                output[out_index] = '\"';\n                ++i;\n            } else {\n                /* backslash must not be followed by any other character */\n                LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, input + i);\n                return NULL;\n            }\n            break;\n        default:\n            output[out_index] = input[i];\n            space = 0;\n            break;\n        }\n        ++i;\n        ++out_index;\n    }\n    output[out_index] = '\\0';\n    if (size != out_index) {\n        output = realloc(output, out_index + 1);\n        LY_CHECK_ERR_RETURN(!output, LOGMEM(ctx), NULL);\n    }\n    return output;\n}\n\n/* free function */\n\nvoid\nyang_type_free(struct ly_ctx *ctx, struct lys_type *type)\n{\n    struct yang_type *stype = (struct yang_type *)type->der;\n    unsigned int i;\n\n    if (!stype) {\n        return ;\n    }\n    if (type->base == LY_TYPE_DER || type->base == LY_TYPE_UNION) {\n        lydict_remove(ctx, stype->name);\n        if (stype->base == LY_TYPE_IDENT && (!(stype->flags & LYS_NO_ERASE_IDENTITY))) {\n            for (i = 0; i < type->info.ident.count; ++i) {\n                free(type->info.ident.ref[i]);\n            }\n        }\n        if (stype->base == LY_TYPE_UNION) {\n            for (i = 0; i < type->info.uni.count; ++i) {\n                yang_type_free(ctx, &type->info.uni.types[i]);\n            }\n            free(type->info.uni.types);\n            type->base = LY_TYPE_DER;\n        } else {\n            type->base = stype->base;\n        }\n        free(stype);\n        type->der = NULL;\n    }\n    lys_type_free(ctx, type, NULL);\n    memset(type, 0, sizeof (struct lys_type));\n}\n\nstatic void\nyang_tpdf_free(struct ly_ctx *ctx, struct lys_tpdf *tpdf, uint16_t start, uint16_t size)\n{\n    uint8_t i;\n\n    assert(ctx);\n    if (!tpdf) {\n        return;\n    }\n\n    for (i = start; i < size; ++i) {\n        lydict_remove(ctx, tpdf[i].name);\n        lydict_remove(ctx, tpdf[i].dsc);\n        lydict_remove(ctx, tpdf[i].ref);\n\n        yang_type_free(ctx, &tpdf[i].type);\n\n        lydict_remove(ctx, tpdf[i].units);\n        lydict_remove(ctx, tpdf[i].dflt);\n        lys_extension_instances_free(ctx, tpdf[i].ext, tpdf[i].ext_size, NULL);\n    }\n}\n\nstatic void\nyang_free_import(struct ly_ctx *ctx, struct lys_import *imp, uint8_t start, uint8_t size)\n{\n    uint8_t i;\n\n    for (i = start; i < size; ++i){\n        free((char *)imp[i].module);\n        lydict_remove(ctx, imp[i].prefix);\n        lydict_remove(ctx, imp[i].dsc);\n        lydict_remove(ctx, imp[i].ref);\n        lys_extension_instances_free(ctx, imp[i].ext, imp[i].ext_size, NULL);\n    }\n}\n\nstatic void\nyang_free_include(struct ly_ctx *ctx, struct lys_include *inc, uint8_t start, uint8_t size)\n{\n    uint8_t i;\n\n    for (i = start; i < size; ++i){\n        free((char *)inc[i].submodule);\n        lydict_remove(ctx, inc[i].dsc);\n        lydict_remove(ctx, inc[i].ref);\n        lys_extension_instances_free(ctx, inc[i].ext, inc[i].ext_size, NULL);\n    }\n}\n\nstatic void\nyang_free_ident_base(struct lys_ident *ident, uint32_t start, uint32_t size)\n{\n    uint32_t i;\n    uint8_t j;\n\n    /* free base name */\n    for (i = start; i < size; ++i) {\n        for (j = 0; j < ident[i].base_size; ++j) {\n            free(ident[i].base[j]);\n        }\n    }\n}\n\nstatic void\nyang_free_grouping(struct ly_ctx *ctx, struct lys_node_grp * grp)\n{\n    yang_tpdf_free(ctx, grp->tpdf, 0, grp->tpdf_size);\n    free(grp->tpdf);\n}\n\nstatic void\nyang_free_container(struct ly_ctx *ctx, struct lys_node_container * cont)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, cont->tpdf, 0, cont->tpdf_size);\n    free(cont->tpdf);\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->must_size; ++i) {\n        lys_restr_free(ctx, &cont->must[i], NULL);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, NULL);\n}\n\nstatic void\nyang_free_leaf(struct ly_ctx *ctx, struct lys_node_leaf *leaf)\n{\n    uint8_t i;\n\n    for (i = 0; i < leaf->must_size; i++) {\n        lys_restr_free(ctx, &leaf->must[i], NULL);\n    }\n    free(leaf->must);\n\n    lys_when_free(ctx, leaf->when, NULL);\n\n    yang_type_free(ctx, &leaf->type);\n    lydict_remove(ctx, leaf->units);\n    lydict_remove(ctx, leaf->dflt);\n}\n\nstatic void\nyang_free_leaflist(struct ly_ctx *ctx, struct lys_node_leaflist *leaflist)\n{\n    uint8_t i;\n\n    for (i = 0; i < leaflist->must_size; i++) {\n        lys_restr_free(ctx, &leaflist->must[i], NULL);\n    }\n    free(leaflist->must);\n\n    for (i = 0; i < leaflist->dflt_size; i++) {\n        lydict_remove(ctx, leaflist->dflt[i]);\n    }\n    free(leaflist->dflt);\n\n    lys_when_free(ctx, leaflist->when, NULL);\n\n    yang_type_free(ctx, &leaflist->type);\n    lydict_remove(ctx, leaflist->units);\n}\n\nstatic void\nyang_free_list(struct ly_ctx *ctx, struct lys_node_list *list)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, list->tpdf, 0, list->tpdf_size);\n    free(list->tpdf);\n\n    for (i = 0; i < list->must_size; ++i) {\n        lys_restr_free(ctx, &list->must[i], NULL);\n    }\n    free(list->must);\n\n    lys_when_free(ctx, list->when, NULL);\n\n    for (i = 0; i < list->unique_size; ++i) {\n        free(list->unique[i].expr);\n    }\n    free(list->unique);\n\n    free(list->keys);\n}\n\nstatic void\nyang_free_choice(struct ly_ctx *ctx, struct lys_node_choice *choice)\n{\n    free(choice->dflt);\n    lys_when_free(ctx, choice->when, NULL);\n}\n\nstatic void\nyang_free_anydata(struct ly_ctx *ctx, struct lys_node_anydata *anydata)\n{\n    uint8_t i;\n\n    for (i = 0; i < anydata->must_size; ++i) {\n        lys_restr_free(ctx, &anydata->must[i], NULL);\n    }\n    free(anydata->must);\n\n    lys_when_free(ctx, anydata->when, NULL);\n}\n\nstatic void\nyang_free_inout(struct ly_ctx *ctx, struct lys_node_inout *inout)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, inout->tpdf, 0, inout->tpdf_size);\n    free(inout->tpdf);\n\n    for (i = 0; i < inout->must_size; ++i) {\n        lys_restr_free(ctx, &inout->must[i], NULL);\n    }\n    free(inout->must);\n}\n\nstatic void\nyang_free_notif(struct ly_ctx *ctx, struct lys_node_notif *notif)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, notif->tpdf, 0, notif->tpdf_size);\n    free(notif->tpdf);\n\n    for (i = 0; i < notif->must_size; ++i) {\n        lys_restr_free(ctx, &notif->must[i], NULL);\n    }\n    free(notif->must);\n}\n\nstatic void\nyang_free_uses(struct ly_ctx *ctx, struct lys_node_uses *uses)\n{\n    int i, j;\n\n    for (i = 0; i < uses->refine_size; i++) {\n        lydict_remove(ctx, uses->refine[i].target_name);\n        lydict_remove(ctx, uses->refine[i].dsc);\n        lydict_remove(ctx, uses->refine[i].ref);\n\n        for (j = 0; j < uses->refine[i].must_size; j++) {\n            lys_restr_free(ctx, &uses->refine[i].must[j], NULL);\n        }\n        free(uses->refine[i].must);\n\n        for (j = 0; j < uses->refine[i].dflt_size; j++) {\n            lydict_remove(ctx, uses->refine[i].dflt[j]);\n        }\n        free(uses->refine[i].dflt);\n\n        if (uses->refine[i].target_type & LYS_CONTAINER) {\n            lydict_remove(ctx, uses->refine[i].mod.presence);\n        }\n        lys_extension_instances_free(ctx, uses->refine[i].ext, uses->refine[i].ext_size, NULL);\n    }\n    free(uses->refine);\n\n    lys_when_free(ctx, uses->when, NULL);\n}\n\nstatic void\nyang_free_nodes(struct ly_ctx *ctx, struct lys_node *node)\n{\n    struct lys_node *tmp, *child, *sibling;\n\n    if (!node) {\n        return;\n    }\n    tmp = node;\n\n    while (tmp) {\n        child = tmp->child;\n        sibling = tmp->next;\n        /* common part */\n        lydict_remove(ctx, tmp->name);\n        if (!(tmp->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            lys_iffeature_free(ctx, tmp->iffeature, tmp->iffeature_size, 0, NULL);\n            lydict_remove(ctx, tmp->dsc);\n            lydict_remove(ctx, tmp->ref);\n        }\n\n        switch (tmp->nodetype) {\n        case LYS_GROUPING:\n        case LYS_RPC:\n        case LYS_ACTION:\n            yang_free_grouping(ctx, (struct lys_node_grp *)tmp);\n            break;\n        case LYS_CONTAINER:\n            yang_free_container(ctx, (struct lys_node_container *)tmp);\n            break;\n        case LYS_LEAF:\n            yang_free_leaf(ctx, (struct lys_node_leaf *)tmp);\n            break;\n        case LYS_LEAFLIST:\n            yang_free_leaflist(ctx, (struct lys_node_leaflist *)tmp);\n            break;\n        case LYS_LIST:\n            yang_free_list(ctx, (struct lys_node_list *)tmp);\n            break;\n        case LYS_CHOICE:\n            yang_free_choice(ctx, (struct lys_node_choice *)tmp);\n            break;\n        case LYS_CASE:\n            lys_when_free(ctx, ((struct lys_node_case *)tmp)->when, NULL);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            yang_free_anydata(ctx, (struct lys_node_anydata *)tmp);\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            yang_free_inout(ctx, (struct lys_node_inout *)tmp);\n            break;\n        case LYS_NOTIF:\n            yang_free_notif(ctx, (struct lys_node_notif *)tmp);\n            break;\n        case LYS_USES:\n            yang_free_uses(ctx, (struct lys_node_uses *)tmp);\n            break;\n        default:\n            break;\n        }\n        lys_extension_instances_free(ctx, tmp->ext, tmp->ext_size, NULL);\n        yang_free_nodes(ctx, child);\n        free(tmp);\n        tmp = sibling;\n    }\n}\n\nstatic void\nyang_free_augment(struct ly_ctx *ctx, struct lys_node_augment *aug)\n{\n    lydict_remove(ctx, aug->target_name);\n    lydict_remove(ctx, aug->dsc);\n    lydict_remove(ctx, aug->ref);\n\n    lys_iffeature_free(ctx, aug->iffeature, aug->iffeature_size, 0, NULL);\n    lys_when_free(ctx, aug->when, NULL);\n    yang_free_nodes(ctx, aug->child);\n    lys_extension_instances_free(ctx, aug->ext, aug->ext_size, NULL);\n}\n\nstatic void\nyang_free_deviate(struct ly_ctx *ctx, struct lys_deviation *dev, uint index)\n{\n    uint i, j;\n\n    for (i = index; i < dev->deviate_size; ++i) {\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].type) {\n            yang_type_free(ctx, dev->deviate[i].type);\n            free(dev->deviate[i].type);\n        }\n\n        for (j = 0; j < dev->deviate[i].dflt_size; ++j) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        for (j = 0; j < dev->deviate[i].must_size; ++j) {\n            lys_restr_free(ctx, &dev->deviate[i].must[j], NULL);\n        }\n        free(dev->deviate[i].must);\n\n        for (j = 0; j < dev->deviate[i].unique_size; ++j) {\n            free(dev->deviate[i].unique[j].expr);\n        }\n        free(dev->deviate[i].unique);\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, NULL);\n    }\n}\n\nvoid\nyang_free_ext_data(struct yang_ext_substmt *substmt)\n{\n    int i;\n\n    if (!substmt) {\n        return;\n    }\n\n    free(substmt->ext_substmt);\n    if (substmt->ext_modules) {\n        for (i = 0; substmt->ext_modules[i]; ++i) {\n            free(substmt->ext_modules[i]);\n        }\n        free(substmt->ext_modules);\n    }\n    free(substmt);\n}\n\n/* free common item from module and submodule */\nstatic void\nfree_yang_common(struct lys_module *module, struct lys_node *node)\n{\n    uint i;\n    yang_tpdf_free(module->ctx, module->tpdf, 0, module->tpdf_size);\n    module->tpdf_size = 0;\n    yang_free_ident_base(module->ident, 0, module->ident_size);\n    yang_free_nodes(module->ctx, node);\n    for (i = 0; i < module->augment_size; ++i) {\n        yang_free_augment(module->ctx, &module->augment[i]);\n    }\n    module->augment_size = 0;\n    for (i = 0; i < module->deviation_size; ++i) {\n        yang_free_deviate(module->ctx, &module->deviation[i], 0);\n        free(module->deviation[i].deviate);\n        lydict_remove(module->ctx, module->deviation[i].target_name);\n        lydict_remove(module->ctx, module->deviation[i].dsc);\n        lydict_remove(module->ctx, module->deviation[i].ref);\n    }\n    module->deviation_size = 0;\n}\n\n/* check function*/\n\nint\nyang_check_ext_instance(struct lys_module *module, struct lys_ext_instance ***ext, uint size,\n                        void *parent, struct unres_schema *unres)\n{\n    struct unres_ext *info;\n    uint i;\n\n    for (i = 0; i < size; ++i) {\n        info = malloc(sizeof *info);\n        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);\n        info->data.yang = (*ext)[i]->parent;\n        info->datatype = LYS_IN_YANG;\n        info->parent = parent;\n        info->mod = module;\n        info->parent_type = (*ext)[i]->parent_type;\n        info->substmt = (*ext)[i]->insubstmt;\n        info->substmt_index = (*ext)[i]->insubstmt_index;\n        info->ext_index = i;\n        if (unres_schema_add_node(module, unres, ext, UNRES_EXT, (struct lys_node *)info) == -1) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_check_imports(struct lys_module *module, struct unres_schema *unres)\n{\n    struct lys_import *imp;\n    struct lys_include *inc;\n    uint8_t imp_size, inc_size, j = 0, i = 0;\n    char *s;\n\n    imp = module->imp;\n    imp_size = module->imp_size;\n    inc = module->inc;\n    inc_size = module->inc_size;\n\n    if (imp_size) {\n        module->imp = calloc(imp_size, sizeof *module->imp);\n        module->imp_size = 0;\n        LY_CHECK_ERR_GOTO(!module->imp, LOGMEM(module->ctx), error);\n    }\n\n    if (inc_size) {\n        module->inc = calloc(inc_size, sizeof *module->inc);\n        module->inc_size = 0;\n        LY_CHECK_ERR_GOTO(!module->inc, LOGMEM(module->ctx), error);\n    }\n\n    for (i = 0; i < imp_size; ++i) {\n        s = (char *) imp[i].module;\n        imp[i].module = NULL;\n        if (yang_fill_import(module, &imp[i], &module->imp[module->imp_size], s, unres)) {\n            ++i;\n            goto error;\n        }\n    }\n    for (j = 0; j < inc_size; ++j) {\n        s = (char *) inc[j].submodule;\n        inc[j].submodule = NULL;\n        if (yang_fill_include(module, s, &inc[j], unres)) {\n            ++j;\n            goto error;\n        }\n    }\n    free(inc);\n    free(imp);\n\n    return EXIT_SUCCESS;\n\nerror:\n    yang_free_import(module->ctx, imp, i, imp_size);\n    yang_free_include(module->ctx, inc, j, inc_size);\n    free(imp);\n    free(inc);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_iffeatures(struct lys_module *module, void *ptr, void *parent, enum yytokentype type, struct unres_schema *unres)\n{\n    struct lys_iffeature *iffeature;\n    uint8_t *ptr_size, size, i;\n    char *s;\n    int parent_is_feature = 0;\n\n    switch (type) {\n    case FEATURE_KEYWORD:\n        iffeature = ((struct lys_feature *)parent)->iffeature;\n        size = ((struct lys_feature *)parent)->iffeature_size;\n        ptr_size = &((struct lys_feature *)parent)->iffeature_size;\n        parent_is_feature = 1;\n        break;\n    case IDENTITY_KEYWORD:\n        iffeature = ((struct lys_ident *)parent)->iffeature;\n        size = ((struct lys_ident *)parent)->iffeature_size;\n        ptr_size = &((struct lys_ident *)parent)->iffeature_size;\n        break;\n    case ENUM_KEYWORD:\n        iffeature = ((struct lys_type_enum *)ptr)->iffeature;\n        size = ((struct lys_type_enum *)ptr)->iffeature_size;\n        ptr_size = &((struct lys_type_enum *)ptr)->iffeature_size;\n        break;\n    case BIT_KEYWORD:\n        iffeature = ((struct lys_type_bit *)ptr)->iffeature;\n        size = ((struct lys_type_bit *)ptr)->iffeature_size;\n        ptr_size = &((struct lys_type_bit *)ptr)->iffeature_size;\n        break;\n    case REFINE_KEYWORD:\n        iffeature = ((struct lys_refine *)ptr)->iffeature;\n        size = ((struct lys_refine *)ptr)->iffeature_size;\n        ptr_size = &((struct lys_refine *)ptr)->iffeature_size;\n        break;\n    default:\n        iffeature = ((struct lys_node *)parent)->iffeature;\n        size = ((struct lys_node *)parent)->iffeature_size;\n        ptr_size = &((struct lys_node *)parent)->iffeature_size;\n        break;\n    }\n\n    *ptr_size = 0;\n    for (i = 0; i < size; ++i) {\n        s = (char *)iffeature[i].features;\n        iffeature[i].features = NULL;\n        if (yang_fill_iffeature(module, &iffeature[i], parent, s, unres, parent_is_feature)) {\n            *ptr_size = size;\n            return EXIT_FAILURE;\n        }\n        if (yang_check_ext_instance(module, &iffeature[i].ext, iffeature[i].ext_size, &iffeature[i], unres)) {\n            *ptr_size = size;\n            return EXIT_FAILURE;\n        }\n        (*ptr_size)++;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\nyang_check_identityref(struct lys_module *module, struct lys_type *type, struct unres_schema *unres)\n{\n    uint size, i;\n    int rc;\n    struct lys_ident **ref;\n    const char *value;\n    char *expr;\n\n    ref = type->info.ident.ref;\n    size = type->info.ident.count;\n    type->info.ident.count = 0;\n    type->info.ident.ref = NULL;\n    ((struct yang_type *)type->der)->flags |= LYS_NO_ERASE_IDENTITY;\n\n    for (i = 0; i < size; ++i) {\n        expr = (char *)ref[i];\n        /* store in the JSON format */\n        value = transform_schema2json(module, expr);\n        free(expr);\n\n        if (!value) {\n            goto error;\n        }\n        rc = unres_schema_add_str(module, unres, type, UNRES_TYPE_IDENTREF, value);\n        lydict_remove(module->ctx, value);\n\n        if (rc == -1) {\n            goto error;\n        }\n    }\n    free(ref);\n\n    return EXIT_SUCCESS;\nerror:\n    for (i = i+1; i < size; ++i) {\n        free(ref[i]);\n    }\n    free(ref);\n    return EXIT_FAILURE;\n}\n\nint\nyang_fill_type(struct lys_module *module, struct lys_type *type, struct yang_type *stype,\n               void *parent, struct unres_schema *unres)\n{\n    unsigned int i, j;\n\n    type->parent = parent;\n    if (yang_check_ext_instance(module, &type->ext, type->ext_size, type, unres)) {\n        return EXIT_FAILURE;\n    }\n    for (j = 0; j < type->ext_size; ++j) {\n        if (type->ext[j]->flags & LYEXT_OPT_VALID) {\n            type->parent->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    switch (stype->base) {\n    case LY_TYPE_ENUM:\n        for (i = 0; i < type->info.enums.count; ++i) {\n            if (yang_check_iffeatures(module, &type->info.enums.enm[i], parent, ENUM_KEYWORD, unres)) {\n                return EXIT_FAILURE;\n            }\n            if (yang_check_ext_instance(module, &type->info.enums.enm[i].ext, type->info.enums.enm[i].ext_size,\n                                        &type->info.enums.enm[i], unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.enums.enm[i].ext_size; ++j) {\n                if (type->info.enums.enm[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_BITS:\n        for (i = 0; i < type->info.bits.count; ++i) {\n            if (yang_check_iffeatures(module, &type->info.bits.bit[i], parent, BIT_KEYWORD, unres)) {\n                return EXIT_FAILURE;\n            }\n            if (yang_check_ext_instance(module, &type->info.bits.bit[i].ext, type->info.bits.bit[i].ext_size,\n                                        &type->info.bits.bit[i], unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.bits.bit[i].ext_size; ++j) {\n                if (type->info.bits.bit[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_IDENT:\n        if (yang_check_identityref(module, type, unres)) {\n            return EXIT_FAILURE;\n        }\n        break;\n    case LY_TYPE_STRING:\n        if (type->info.str.length) {\n            if (yang_check_ext_instance(module, &type->info.str.length->ext,\n                                        type->info.str.length->ext_size, type->info.str.length, unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.str.length->ext_size; ++j) {\n                if (type->info.str.length->ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n\n        for (i = 0; i < type->info.str.pat_count; ++i) {\n            if (yang_check_ext_instance(module, &type->info.str.patterns[i].ext, type->info.str.patterns[i].ext_size,\n                                        &type->info.str.patterns[i], unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.str.patterns[i].ext_size; ++j) {\n                if (type->info.str.patterns[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_DEC64:\n        if (type->info.dec64.range) {\n            if (yang_check_ext_instance(module, &type->info.dec64.range->ext,\n                                        type->info.dec64.range->ext_size, type->info.dec64.range, unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.dec64.range->ext_size; ++j) {\n                if (type->info.dec64.range->ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_UNION:\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (yang_fill_type(module, &type->info.uni.types[i], (struct yang_type *)type->info.uni.types[i].der,\n                               parent, unres)) {\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    default:\n        /* nothing checks */\n        break;\n    }\n    return EXIT_SUCCESS;\n}\n\nint\nyang_check_typedef(struct lys_module *module, struct lys_node *parent, struct unres_schema *unres)\n{\n    struct lys_tpdf *tpdf;\n    uint8_t *ptr_tpdf_size = NULL;\n    uint16_t j, i, tpdf_size, *ptr_tpdf_size16 = NULL;\n\n    if (!parent) {\n        tpdf = module->tpdf;\n        //ptr_tpdf_size = &module->tpdf_size;\n        ptr_tpdf_size16 = &module->tpdf_size;\n    } else {\n        switch (parent->nodetype) {\n        case LYS_GROUPING:\n            tpdf = ((struct lys_node_grp *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_grp *)parent)->tpdf_size;\n            break;\n        case LYS_CONTAINER:\n            tpdf = ((struct lys_node_container *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_container *)parent)->tpdf_size;\n            break;\n        case LYS_LIST:\n            tpdf = ((struct lys_node_list *)parent)->tpdf;\n            ptr_tpdf_size = &((struct lys_node_list *)parent)->tpdf_size;\n            break;\n        case LYS_RPC:\n        case LYS_ACTION:\n            tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_rpc_action *)parent)->tpdf_size;\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            tpdf = ((struct lys_node_inout *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_inout *)parent)->tpdf_size;\n            break;\n        case LYS_NOTIF:\n            tpdf = ((struct lys_node_notif *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_notif *)parent)->tpdf_size;\n            break;\n        default:\n            LOGINT(module->ctx);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (ptr_tpdf_size16) {\n        tpdf_size = *ptr_tpdf_size16;\n        *ptr_tpdf_size16 = 0;\n    } else {\n        tpdf_size = *ptr_tpdf_size;\n        *ptr_tpdf_size = 0;\n    }\n\n    for (i = 0; i < tpdf_size; ++i) {\n        if (lyp_check_identifier(module->ctx, tpdf[i].name, LY_IDENT_TYPE, module, parent)) {\n            goto error;\n        }\n\n        if (yang_fill_type(module, &tpdf[i].type, (struct yang_type *)tpdf[i].type.der, &tpdf[i], unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &tpdf[i].ext, tpdf[i].ext_size, &tpdf[i], unres)) {\n            goto error;\n        }\n        for (j = 0; j < tpdf[i].ext_size; ++j) {\n            if (tpdf[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                tpdf[i].flags |= LYS_VALID_EXT;\n                break;\n            }\n        }\n        if (unres_schema_add_node(module, unres, &tpdf[i].type, UNRES_TYPE_DER_TPDF, parent) == -1) {\n            goto error;\n        }\n\n        if (ptr_tpdf_size16) {\n            (*ptr_tpdf_size16)++;\n        } else {\n            (*ptr_tpdf_size)++;\n        }\n        /* check default value*/\n        if (!(module->ctx->models.flags & LY_CTX_TRUSTED)\n                && unres_schema_add_node(module, unres, &tpdf[i].type, UNRES_TYPEDEF_DFLT, (struct lys_node *)(&tpdf[i].dflt)) == -1)  {\n            ++i;\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    yang_tpdf_free(module->ctx, tpdf, i, tpdf_size);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_identities(struct lys_module *module, struct unres_schema *unres)\n{\n    uint32_t i, size, base_size;\n    uint8_t j;\n\n    size = module->ident_size;\n    module->ident_size = 0;\n    for (i = 0; i < size; ++i) {\n        base_size = module->ident[i].base_size;\n        module->ident[i].base_size = 0;\n        for (j = 0; j < base_size; ++j) {\n            if (yang_read_base(module, &module->ident[i], (char *)module->ident[i].base[j], unres)) {\n                ++j;\n                module->ident_size = size;\n                goto error;\n            }\n        }\n        module->ident_size++;\n        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &module->ident[i].ext, module->ident[i].ext_size, &module->ident[i], unres)) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    for (; j< module->ident[i].base_size; ++j) {\n        free(module->ident[i].base[j]);\n    }\n    yang_free_ident_base(module->ident, i + 1, size);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_must(struct lys_module *module, struct lys_restr *must, uint size, struct unres_schema *unres)\n{\n    uint i;\n\n    for (i = 0; i < size; ++i) {\n        if (yang_check_ext_instance(module, &must[i].ext, must[i].ext_size, &must[i], unres)) {\n            return EXIT_FAILURE;\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\nyang_check_container(struct lys_module *module, struct lys_node_container *cont, struct lys_node **child,\n                     int options, struct unres_schema *unres)\n{\n    if (yang_check_typedef(module, (struct lys_node *)cont, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, cont, CONTAINER_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)cont, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (cont->when && yang_check_ext_instance(module, &cont->when->ext, cont->when->ext_size, cont->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, cont->must, cont->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)cont)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, cont, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\nerror:\n\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_leaf(struct lys_module *module, struct lys_node_leaf *leaf, int options, struct unres_schema *unres)\n{\n    if (yang_fill_type(module, &leaf->type, (struct yang_type *)leaf->type.der, leaf, unres)) {\n        yang_type_free(module->ctx, &leaf->type);\n        goto error;\n    }\n    if (yang_check_iffeatures(module, NULL, leaf, LEAF_KEYWORD, unres)) {\n        yang_type_free(module->ctx, &leaf->type);\n        goto error;\n    }\n\n    if (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DER, (struct lys_node *)leaf) == -1) {\n        yang_type_free(module->ctx, &leaf->type);\n        goto error;\n    }\n\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) &&\n            (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT, (struct lys_node *)&leaf->dflt) == -1)) {\n        goto error;\n    }\n\n    if (leaf->when && yang_check_ext_instance(module, &leaf->when->ext, leaf->when->ext_size, leaf->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, leaf->must, leaf->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (leaf->when || leaf->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)leaf)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, leaf, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_leaflist(struct lys_module *module, struct lys_node_leaflist *leaflist, int options,\n                    struct unres_schema *unres)\n{\n    int i, j;\n\n    if (yang_fill_type(module, &leaflist->type, (struct yang_type *)leaflist->type.der, leaflist, unres)) {\n        yang_type_free(module->ctx, &leaflist->type);\n        goto error;\n    }\n    if (yang_check_iffeatures(module, NULL, leaflist, LEAF_LIST_KEYWORD, unres)) {\n        yang_type_free(module->ctx, &leaflist->type);\n        goto error;\n    }\n\n    if (unres_schema_add_node(module, unres, &leaflist->type, UNRES_TYPE_DER, (struct lys_node *)leaflist) == -1) {\n        yang_type_free(module->ctx, &leaflist->type);\n        goto error;\n    }\n\n    for (i = 0; i < leaflist->dflt_size; ++i) {\n        /* check for duplicity in case of configuration data,\n         * in case of status data duplicities are allowed */\n        if (leaflist->flags & LYS_CONFIG_W) {\n            for (j = i +1; j < leaflist->dflt_size; ++j) {\n                if (ly_strequal(leaflist->dflt[i], leaflist->dflt[j], 1)) {\n                    LOGVAL(module->ctx, LYE_INARG, LY_VLOG_LYS, leaflist, leaflist->dflt[i], \"default\");\n                    LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_LYS, leaflist, \"Duplicated default value \\\"%s\\\".\", leaflist->dflt[i]);\n                    goto error;\n                }\n            }\n        }\n        /* check default value (if not defined, there still could be some restrictions\n         * that need to be checked against a default value from a derived type) */\n        if (!(module->ctx->models.flags & LY_CTX_TRUSTED) &&\n                (unres_schema_add_node(module, unres, &leaflist->type, UNRES_TYPE_DFLT,\n                                       (struct lys_node *)(&leaflist->dflt[i])) == -1)) {\n            goto error;\n        }\n    }\n\n    if (leaflist->when && yang_check_ext_instance(module, &leaflist->when->ext, leaflist->when->ext_size, leaflist->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, leaflist->must, leaflist->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (leaflist->when || leaflist->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)leaflist)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, leaflist, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_list(struct lys_module *module, struct lys_node_list *list, struct lys_node **child,\n                int options, struct unres_schema *unres)\n{\n    struct lys_node *node;\n\n    if (yang_check_typedef(module, (struct lys_node *)list, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, list, LIST_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (list->flags & LYS_CONFIG_R) {\n        /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data\n         * ignore oredering MASK - 0x7F\n         */\n        list->flags &= 0x7F;\n    }\n    /* check - if list is configuration, key statement is mandatory\n     * (but only if we are not in a grouping or augment, then the check is deferred) */\n    for (node = (struct lys_node *)list; node && !(node->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); node = node->parent);\n    if (!node && (list->flags & LYS_CONFIG_W) && !list->keys) {\n        LOGVAL(module->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, list, \"key\", \"list\");\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)list, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (list->keys && yang_read_key(module, list, unres)) {\n        goto error;\n    }\n\n    if (yang_read_unique(module, list, unres)) {\n        goto error;\n    }\n\n    if (list->when && yang_check_ext_instance(module, &list->when->ext, list->when->ext_size, list->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, list->must, list->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (list->when || list->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)list)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, list, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_choice(struct lys_module *module, struct lys_node_choice *choice, struct lys_node **child,\n                  int options, struct unres_schema *unres)\n{\n    char *value;\n\n    if (yang_check_iffeatures(module, NULL, choice, CHOICE_KEYWORD, unres)) {\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)choice, *child, options, unres)) {\n        *child = NULL;\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (choice->dflt) {\n        value = (char *)choice->dflt;\n        choice->dflt = NULL;\n        if (unres_schema_add_str(module, unres, choice, UNRES_CHOICE_DFLT, value) == -1) {\n            free(value);\n            goto error;\n        }\n        free(value);\n    }\n\n    if (choice->when && yang_check_ext_instance(module, &choice->when->ext, choice->when->ext_size, choice->when, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && choice->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)choice)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, choice, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_rpc_action(struct lys_module *module, struct lys_node_rpc_action *rpc, struct lys_node **child,\n                      int options, struct unres_schema *unres)\n{\n    struct lys_node *node;\n\n    if (rpc->nodetype == LYS_ACTION) {\n        for (node = rpc->parent; node; node = lys_parent(node)) {\n            if ((node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF))\n                    || ((node->nodetype == LYS_LIST) && !((struct lys_node_list *)node)->keys)) {\n                LOGVAL(module->ctx, LYE_INPAR, LY_VLOG_LYS, rpc->parent, strnodetype(node->nodetype), \"action\");\n                goto error;\n            }\n        }\n    }\n    if (yang_check_typedef(module, (struct lys_node *)rpc, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, rpc, RPC_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)rpc, *child, options | LYS_PARSE_OPT_CFG_IGNORE, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_notif(struct lys_module *module, struct lys_node_notif *notif, struct lys_node **child,\n                 int options, struct unres_schema *unres)\n{\n    if (yang_check_typedef(module, (struct lys_node *)notif, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, notif, NOTIFICATION_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)notif, *child, options | LYS_PARSE_OPT_CFG_IGNORE, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (yang_check_must(module, notif->must, notif->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && notif->must_size) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)notif)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, notif, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_augment(struct lys_module *module, struct lys_node_augment *augment, int options, struct unres_schema *unres)\n{\n    struct lys_node *child;\n\n    child = augment->child;\n    augment->child = NULL;\n\n    if (yang_check_iffeatures(module, NULL, augment, AUGMENT_KEYWORD, unres)) {\n        yang_free_nodes(module->ctx, child);\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)augment, child, options, unres)) {\n        goto error;\n    }\n\n    if (yang_check_ext_instance(module, &augment->ext, augment->ext_size, augment, unres)) {\n        goto error;\n    }\n\n    if (augment->when && yang_check_ext_instance(module, &augment->when->ext, augment->when->ext_size, augment->when, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && augment->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)augment)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, augment, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_uses(struct lys_module *module, struct lys_node_uses *uses, int options, struct unres_schema *unres)\n{\n    uint i, size;\n\n    size = uses->augment_size;\n    uses->augment_size = 0;\n\n    if (yang_check_iffeatures(module, NULL, uses, USES_KEYWORD, unres)) {\n        goto error;\n    }\n\n    for (i = 0; i < uses->refine_size; ++i) {\n        if (yang_check_iffeatures(module, &uses->refine[i], uses, REFINE_KEYWORD, unres)) {\n            goto error;\n        }\n        if (yang_check_must(module, uses->refine[i].must, uses->refine[i].must_size, unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &uses->refine[i].ext, uses->refine[i].ext_size, &uses->refine[i], unres)) {\n            goto error;\n        }\n    }\n\n    for (i = 0; i < size; ++i) {\n        uses->augment_size++;\n        if (yang_check_augment(module, &uses->augment[i], options, unres)) {\n            goto error;\n        }\n    }\n\n    if (unres_schema_add_node(module, unres, uses, UNRES_USES, NULL) == -1) {\n        goto error;\n    }\n\n    if (uses->when && yang_check_ext_instance(module, &uses->when->ext, uses->when->ext_size, uses->when, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && uses->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)uses)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, uses, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    for (i = uses->augment_size; i < size; ++i) {\n        yang_free_augment(module->ctx, &uses->augment[i]);\n    }\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_anydata(struct lys_module *module, struct lys_node_anydata *anydata, struct lys_node **child,\n                   int options, struct unres_schema *unres)\n{\n    if (yang_check_iffeatures(module, NULL, anydata, ANYDATA_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)anydata, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (anydata->when && yang_check_ext_instance(module, &anydata->when->ext, anydata->when->ext_size, anydata->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, anydata->must, anydata->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (anydata->when || anydata->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)anydata)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, anydata, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_nodes(struct lys_module *module, struct lys_node *parent, struct lys_node *nodes,\n                 int options, struct unres_schema *unres)\n{\n    struct lys_node *node = nodes, *sibling, *child;\n    int i;\n\n    while (node) {\n        sibling = node->next;\n        child = node->child;\n        node->next = NULL;\n        node->child = NULL;\n        node->parent = NULL;\n        node->prev = node;\n\n        if (lys_node_addchild(parent, module->type ? ((struct lys_submodule *)module)->belongsto: module, node, 0) ||\n            check_status_flag(node, parent)) {\n            lys_node_unlink(node);\n            yang_free_nodes(module->ctx, node);\n            goto error;\n        }\n        if (node->parent != parent) {\n            assert(node->parent->parent == parent);\n            assert((node->parent->nodetype == LYS_CASE) && (node->parent->flags & LYS_IMPLICIT));\n            store_config_flag(node->parent, options);\n        }\n        store_config_flag(node, options);\n        if (yang_check_ext_instance(module, &node->ext, node->ext_size, node, unres)) {\n            goto error;\n        }\n        for (i = 0; i < node->ext_size; ++i) {\n            if (node->ext[i]->flags & LYEXT_OPT_VALID) {\n                node->flags |= LYS_VALID_EXT;\n                break;\n            }\n        }\n\n        switch (node->nodetype) {\n        case LYS_GROUPING:\n            if (yang_check_typedef(module, node, unres)) {\n                goto error;\n            }\n            if (yang_check_iffeatures(module, NULL, node, GROUPING_KEYWORD, unres)) {\n                goto error;\n            }\n            if (yang_check_nodes(module, node, child, options | LYS_PARSE_OPT_INGRP, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        case LYS_CONTAINER:\n            if (yang_check_container(module, (struct lys_node_container *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_LEAF:\n            if (yang_check_leaf(module, (struct lys_node_leaf *)node, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        case LYS_LEAFLIST:\n            if (yang_check_leaflist(module, (struct lys_node_leaflist *)node, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        case LYS_LIST:\n            if (yang_check_list(module, (struct lys_node_list *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_CHOICE:\n            if (yang_check_choice(module, (struct lys_node_choice *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_CASE:\n            if (yang_check_iffeatures(module, NULL, node, CASE_KEYWORD, unres)) {\n                goto error;\n            }\n            if (yang_check_nodes(module, node, child, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            if (((struct lys_node_case *)node)->when) {\n                if (yang_check_ext_instance(module, &((struct lys_node_case *)node)->when->ext,\n                        ((struct lys_node_case *)node)->when->ext_size, ((struct lys_node_case *)node)->when, unres)) {\n                    goto error;\n                }\n                /* check XPath dependencies */\n                if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (options & LYS_PARSE_OPT_INGRP)) {\n                    if (lyxp_node_check_syntax(node)) {\n                        goto error;\n                    }\n                } else {\n                    if (unres_schema_add_node(module, unres, node, UNRES_XPATH, NULL) == -1) {\n                        goto error;\n                    }\n                }\n            }\n            break;\n        case LYS_ANYDATA:\n        case LYS_ANYXML:\n            if (yang_check_anydata(module, (struct lys_node_anydata *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_RPC:\n        case LYS_ACTION:\n            if (yang_check_rpc_action(module, (struct lys_node_rpc_action *)node, &child, options, unres)){\n                goto error;\n            }\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            if (yang_check_typedef(module, node, unres)) {\n                goto error;\n            }\n            if (yang_check_nodes(module, node, child, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            if (((struct lys_node_inout *)node)->must_size) {\n                if (yang_check_must(module, ((struct lys_node_inout *)node)->must, ((struct lys_node_inout *)node)->must_size, unres)) {\n                    goto error;\n                }\n                /* check XPath dependencies */\n                if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (options & LYS_PARSE_OPT_INGRP)) {\n                    if (lyxp_node_check_syntax(node)) {\n                        goto error;\n                    }\n                } else {\n                    if (unres_schema_add_node(module, unres, node, UNRES_XPATH, NULL) == -1) {\n                        goto error;\n                    }\n                }\n            }\n            break;\n        case LYS_NOTIF:\n            if (yang_check_notif(module, (struct lys_node_notif *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_USES:\n            if (yang_check_uses(module, (struct lys_node_uses *)node, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        default:\n            LOGINT(module->ctx);\n            goto error;\n        }\n        node = sibling;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    yang_free_nodes(module->ctx, sibling);\n    yang_free_nodes(module->ctx, child);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_deviate(struct lys_module *module, struct unres_schema *unres, struct lys_deviate *deviate,\n                   struct lys_node *dev_target, struct ly_set *dflt_check)\n{\n    struct lys_node_leaflist *llist;\n    struct lys_type *type;\n    struct lys_tpdf *tmp_parent;\n    int i, j;\n\n    if (yang_check_ext_instance(module, &deviate->ext, deviate->ext_size, deviate, unres)) {\n        goto error;\n    }\n    if (deviate->must_size && yang_check_deviate_must(module, unres, deviate, dev_target)) {\n        goto error;\n    }\n    if (deviate->unique && yang_check_deviate_unique(module, deviate, dev_target)) {\n        goto error;\n    }\n    if (deviate->dflt_size) {\n        if (yang_read_deviate_default(module, deviate, dev_target, dflt_check)) {\n            goto error;\n        }\n        if (dev_target->nodetype == LYS_LEAFLIST && deviate->mod == LY_DEVIATE_DEL) {\n            /* consolidate the final list in the target after removing items from it */\n            llist = (struct lys_node_leaflist *)dev_target;\n            for (i = j = 0; j < llist->dflt_size; j++) {\n                llist->dflt[i] = llist->dflt[j];\n                if (llist->dflt[i]) {\n                    i++;\n                }\n            }\n            llist->dflt_size = i + 1;\n        }\n    }\n\n    if (deviate->max_set && yang_read_deviate_minmax(deviate, dev_target, deviate->max, 1)) {\n        goto error;\n    }\n\n    if (deviate->min_set && yang_read_deviate_minmax(deviate, dev_target, deviate->min, 0)) {\n        goto error;\n    }\n\n    if (deviate->units && yang_read_deviate_units(module->ctx, deviate, dev_target)) {\n        goto error;\n    }\n\n    if ((deviate->flags & LYS_CONFIG_MASK)) {\n        /* add and replace are the same in this case */\n        /* remove current config value of the target ... */\n        dev_target->flags &= ~LYS_CONFIG_MASK;\n\n        /* ... and replace it with the value specified in deviation */\n        dev_target->flags |= deviate->flags & LYS_CONFIG_MASK;\n    }\n\n    if ((deviate->flags & LYS_MAND_MASK) && yang_check_deviate_mandatory(deviate, dev_target)) {\n        goto error;\n    }\n\n    if (deviate->type) {\n        /* check target node type */\n        if (dev_target->nodetype == LYS_LEAF) {\n            type = &((struct lys_node_leaf *)dev_target)->type;\n        } else if (dev_target->nodetype == LYS_LEAFLIST) {\n            type = &((struct lys_node_leaflist *)dev_target)->type;\n        } else {\n            LOGVAL(module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"type\");\n            LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"type\\\" property.\");\n            goto error;\n        }\n        /* remove type and initialize it */\n        tmp_parent = type->parent;\n        lys_type_free(module->ctx, type, NULL);\n        memcpy(type, deviate->type, sizeof *deviate->type);\n        free(deviate->type);\n        deviate->type = type;\n        deviate->type->parent = tmp_parent;\n        if (yang_fill_type(module, type, (struct yang_type *)type->der, tmp_parent, unres)) {\n            goto error;\n        }\n\n        if (unres_schema_add_node(module, unres, deviate->type, UNRES_TYPE_DER, dev_target) == -1) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (deviate->type) {\n        yang_type_free(module->ctx, deviate->type);\n        deviate->type = NULL;\n    }\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_deviation(struct lys_module *module, struct unres_schema *unres, struct lys_deviation *dev)\n{\n    int rc;\n    uint i;\n    struct lys_node *dev_target = NULL, *parent;\n    struct ly_set *dflt_check = ly_set_new(), *set;\n    unsigned int u;\n    const char *value, *target_name;\n    struct lys_node_leaflist *llist;\n    struct lys_node_leaf *leaf;\n    struct lys_node_inout *inout;\n    struct unres_schema tmp_unres;\n    struct lys_module *mod;\n\n    /* resolve target node */\n    rc = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n    if (rc == -1) {\n        LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, dev->target_name, \"deviation\");\n        ly_set_free(set);\n        i = 0;\n        goto free_type_error;\n    }\n    dev_target = set->set.s[0];\n    ly_set_free(set);\n\n    if (dev_target->module == lys_main_module(module)) {\n        LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, dev->target_name, \"deviation\");\n        LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Deviating own module is not allowed.\");\n        i = 0;\n        goto free_type_error;\n    }\n\n    if (!dflt_check) {\n        LOGMEM(module->ctx);\n        i = 0;\n        goto free_type_error;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        /* you cannot remove a key leaf */\n        if ((dev_target->nodetype == LYS_LEAF) && dev_target->parent && (dev_target->parent->nodetype == LYS_LIST)) {\n            for (i = 0; i < ((struct lys_node_list *)dev_target->parent)->keys_size; ++i) {\n                if (((struct lys_node_list *)dev_target->parent)->keys[i] == (struct lys_node_leaf *)dev_target) {\n                    LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"not-supported\", \"deviation\");\n                    LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"not-supported\\\" deviation cannot remove a list key.\");\n                    i = 0;\n                    goto free_type_error;\n                }\n            }\n        }\n        /* unlink and store the original node */\n        parent = dev_target->parent;\n        lys_node_unlink(dev_target);\n        if (parent) {\n            if (parent->nodetype & (LYS_AUGMENT | LYS_USES)) {\n                /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                 * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                 * path), so we need to remember the augment as an addition */\n                /* remember uses parent so we can reconnect to it */\n                dev_target->parent = parent;\n            } else if (parent->nodetype & (LYS_RPC | LYS_ACTION)) {\n                /* re-create implicit node */\n                inout = calloc(1, sizeof *inout);\n                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);\n\n                inout->nodetype = dev_target->nodetype;\n                inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? \"input\" : \"output\", 0);\n                inout->module = dev_target->module;\n                inout->flags = LYS_IMPLICIT;\n\n                /* insert it manually */\n                assert(parent->child && !parent->child->next\n                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));\n                parent->child->next = (struct lys_node *)inout;\n                inout->prev = parent->child;\n                parent->child->prev = (struct lys_node *)inout;\n                inout->parent = parent;\n            }\n        }\n        dev->orig_node = dev_target;\n    } else {\n        /* store a shallow copy of the original node */\n        memset(&tmp_unres, 0, sizeof tmp_unres);\n        dev->orig_node = lys_node_dup(dev_target->module, NULL, dev_target, &tmp_unres, 1);\n        /* just to be safe */\n        if (tmp_unres.count) {\n            LOGINT(module->ctx);\n            i = 0;\n            goto free_type_error;\n        }\n    }\n\n    if (yang_check_ext_instance(module, &dev->ext, dev->ext_size, dev, unres)) {\n        i = 0;\n        goto free_type_error;\n    }\n\n    for (i = 0; i < dev->deviate_size; ++i) {\n        if (yang_check_deviate(module, unres, &dev->deviate[i], dev_target, dflt_check)) {\n            yang_free_deviate(module->ctx, dev, i + 1);\n            dev->deviate_size = i + 1;\n            goto free_type_error;\n        }\n    }\n    /* now check whether default value, if any, matches the type */\n    for (u = 0; u < dflt_check->number; ++u) {\n        value = NULL;\n        rc = EXIT_SUCCESS;\n        if (dflt_check->set.s[u]->nodetype == LYS_LEAF) {\n            leaf = (struct lys_node_leaf *)dflt_check->set.s[u];\n            target_name = leaf->name;\n            value = leaf->dflt;\n            rc = unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&leaf->dflt));\n        } else { /* LYS_LEAFLIST */\n            llist = (struct lys_node_leaflist *)dflt_check->set.s[u];\n            target_name = llist->name;\n            for (i = 0; i < llist->dflt_size; i++) {\n                rc = unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                           (struct lys_node *)(&llist->dflt[i]));\n                if (rc == -1) {\n                    value = llist->dflt[i];\n                    break;\n                }\n            }\n        }\n        if (rc == -1) {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n            LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                \"The default value \\\"%s\\\" of the deviated node \\\"%s\\\"no longer matches its type.\",\n                target_name);\n            goto error;\n        }\n    }\n    ly_set_free(dflt_check);\n    dflt_check = NULL;\n\n    /* mark all the affected modules as deviated and implemented */\n    for (parent = dev_target; parent; parent = lys_parent(parent)) {\n        mod = lys_node_module(parent);\n        if (module != mod) {\n            mod->deviated = 1;            /* main module */\n            parent->module->deviated = 1; /* possible submodule */\n            if (!mod->implemented) {\n                mod->implemented = 1;\n                if (unres_schema_add_node(mod, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    goto error;\n                }\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nfree_type_error:\n    /* we need to free types because they are for now allocated dynamically (use i as it is now, is set correctly) */\n    for (; i < dev->deviate_size; ++i) {\n        if (dev->deviate[i].type) {\n            yang_type_free(module->ctx, dev->deviate[i].type);\n            free(dev->deviate[i].type);\n            dev->deviate[i].type = NULL;\n        }\n    }\nerror:\n    ly_set_free(dflt_check);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_sub_module(struct lys_module *module, struct unres_schema *unres, struct lys_node *node)\n{\n    uint i, erase_identities = 1, erase_nodes = 1, aug_size, dev_size = 0;\n\n    aug_size = module->augment_size;\n    module->augment_size = 0;\n    dev_size = module->deviation_size;\n    module->deviation_size = 0;\n\n    if (yang_check_typedef(module, NULL, unres)) {\n        goto error;\n    }\n\n    if (yang_check_ext_instance(module, &module->ext, module->ext_size, module, unres)) {\n        goto error;\n    }\n\n    /* check extension in revision */\n    for (i = 0; i < module->rev_size; ++i) {\n        if (yang_check_ext_instance(module, &module->rev[i].ext, module->rev[i].ext_size, &module->rev[i], unres)) {\n            goto error;\n        }\n    }\n\n    /* check extension in definition of extension */\n    for (i = 0; i < module->extensions_size; ++i) {\n        if (yang_check_ext_instance(module, &module->extensions[i].ext, module->extensions[i].ext_size, &module->extensions[i], unres)) {\n            goto error;\n        }\n    }\n\n    /* check features */\n    for (i = 0; i < module->features_size; ++i) {\n        if (yang_check_iffeatures(module, NULL, &module->features[i], FEATURE_KEYWORD, unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &module->features[i].ext, module->features[i].ext_size, &module->features[i], unres)) {\n            goto error;\n        }\n\n        /* check for circular dependencies */\n        if (module->features[i].iffeature_size && (unres_schema_add_node(module, unres, &module->features[i], UNRES_FEATURE, NULL) == -1)) {\n            goto error;\n        }\n    }\n    erase_identities = 0;\n    if (yang_check_identities(module, unres)) {\n        goto error;\n    }\n    erase_nodes = 0;\n    if (yang_check_nodes(module, NULL, node, 0, unres)) {\n        goto error;\n    }\n\n    /* check deviation */\n    for (i = 0; i < dev_size; ++i) {\n        module->deviation_size++;\n        if (yang_check_deviation(module, unres, &module->deviation[i])) {\n            goto error;\n        }\n    }\n\n    /* check augments */\n    for (i = 0; i < aug_size; ++i) {\n        module->augment_size++;\n        if (yang_check_augment(module, &module->augment[i], 0, unres)) {\n            goto error;\n        }\n        if (unres_schema_add_node(module, unres, &module->augment[i], UNRES_AUGMENT, NULL) == -1) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (erase_identities) {\n        yang_free_ident_base(module->ident, 0, module->ident_size);\n    }\n    if (erase_nodes) {\n        yang_free_nodes(module->ctx, node);\n    }\n    for (i = module->augment_size; i < aug_size; ++i) {\n        yang_free_augment(module->ctx, &module->augment[i]);\n    }\n    for (i = module->deviation_size; i < dev_size; ++i) {\n        yang_free_deviate(module->ctx, &module->deviation[i], 0);\n        free(module->deviation[i].deviate);\n        lydict_remove(module->ctx, module->deviation[i].target_name);\n        lydict_remove(module->ctx, module->deviation[i].dsc);\n        lydict_remove(module->ctx, module->deviation[i].ref);\n    }\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n                         const char *parent_name, char *value, int parent_stmt, LY_STMT stmt)\n{\n    int c;\n    const char **str, ***p = NULL;\n    void *reallocated;\n    struct lyext_substmt *info;\n\n    c = 0;\n    if (stmt == LY_STMT_PREFIX && parent_stmt == LY_STMT_BELONGSTO) {\n        /* str contains no NULL value */\n        str = lys_ext_complex_get_substmt(LY_STMT_BELONGSTO, ext, &info);\n        if (info->cardinality < LY_STMT_CARD_SOME) {\n            str++;\n        } else {\n           /* get the index in the array to add new item */\n            p = (const char ***)str;\n            for (c = 0; p[0][c + 1]; c++);\n            str = p[1];\n        }\n        str[c] = lydict_insert_zc(module->ctx, value);\n    }  else {\n        str = lys_ext_complex_get_substmt(stmt, ext, &info);\n        if (!str) {\n            LOGVAL(module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n        if (info->cardinality < LY_STMT_CARD_SOME && *str) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances, str is actually const char *** */\n            p = (const char ***)str;\n            if (!p[0]) {\n                /* allocate initial array */\n                p[0] = calloc(2, sizeof(const char *));\n                LY_CHECK_ERR_GOTO(!p[0], LOGMEM(module->ctx), error);\n                if (stmt == LY_STMT_BELONGSTO) {\n                    /* allocate another array for the belongs-to's prefixes */\n                    p[1] = calloc(2, sizeof(const char *));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                } else if (stmt == LY_STMT_ARGUMENT) {\n                    /* allocate another array for the yin element */\n                    ((uint8_t **)p)[1] = calloc(2, sizeof(uint8_t));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                    /* default value of yin element */\n                    ((uint8_t *)p[1])[0] = 2;\n                }\n            } else {\n                /* get the index in the array to add new item */\n                for (c = 0; p[0][c]; c++);\n            }\n            str = p[0];\n        }\n\n        str[c] = lydict_insert_zc(module->ctx, value);\n        value = NULL;\n\n        if (c) {\n            /* enlarge the array(s) */\n            reallocated = realloc(p[0], (c + 2) * sizeof(const char *));\n            if (!reallocated) {\n                LOGMEM(module->ctx);\n                lydict_remove(module->ctx, p[0][c]);\n                p[0][c] = NULL;\n                return EXIT_FAILURE;\n            }\n            p[0] = reallocated;\n            p[0][c + 1] = NULL;\n\n            if (stmt == LY_STMT_BELONGSTO) {\n                /* enlarge the second belongs-to's array with prefixes */\n                reallocated = realloc(p[1], (c + 2) * sizeof(const char *));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    lydict_remove(module->ctx, p[1][c]);\n                    p[1][c] = NULL;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                p[1][c + 1] = NULL;\n            } else if (stmt == LY_STMT_ARGUMENT) {\n                /* enlarge the second argument's array with yin element */\n                reallocated = realloc(p[1], (c + 2) * sizeof(uint8_t));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    ((uint8_t *)p[1])[c] = 0;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                ((uint8_t *)p[1])[c + 1] = 0;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    free(value);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_fill_ext_substm_index(struct lys_ext_instance_complex *ext, LY_STMT stmt, enum yytokentype keyword)\n{\n    int c = 0, decrement = 0;\n    const char **str, ***p = NULL;\n    struct lyext_substmt *info;\n\n\n    if (keyword == BELONGS_TO_KEYWORD || stmt == LY_STMT_BELONGSTO) {\n        stmt = LY_STMT_BELONGSTO;\n        decrement = -1;\n    } else if (keyword == ARGUMENT_KEYWORD || stmt == LY_STMT_ARGUMENT) {\n        stmt = LY_STMT_ARGUMENT;\n        decrement = -1;\n    }\n\n    str = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!str || info->cardinality < LY_STMT_CARD_SOME || !((const char ***)str)[0]) {\n        return 0;\n    } else {\n        p = (const char ***)str;\n        /* get the index in the array */\n        for (c = 0; p[0][c]; c++);\n        return c + decrement;\n    }\n}\n\nvoid **\nyang_getplace_for_extcomplex_struct(struct lys_ext_instance_complex *ext, int *index,\n                                    char *parent_name, char *node_name, LY_STMT stmt)\n{\n    struct ly_ctx *ctx = ext->module->ctx;\n    int c;\n    void **data, ***p = NULL;\n    void *reallocated;\n    struct lyext_substmt *info;\n\n    data = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!data) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return NULL;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME && *data) {\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return NULL;\n    }\n\n    c = 0;\n    if (info->cardinality >= LY_STMT_CARD_SOME) {\n        /* there can be multiple instances, so instead of pointer to array,\n         * we have in data pointer to pointer to array */\n        p = (void ***)data;\n        data = *p;\n        if (!data) {\n            /* allocate initial array */\n            *p = data = calloc(2, sizeof(void *));\n            LY_CHECK_ERR_RETURN(!data, LOGMEM(ctx), NULL);\n        } else {\n            for (c = 0; *data; data++, c++);\n        }\n    }\n\n    if (c) {\n        /* enlarge the array */\n        reallocated = realloc(*p, (c + 2) * sizeof(void *));\n        LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), NULL);\n        *p = reallocated;\n        data = *p;\n        data[c + 1] = NULL;\n    }\n\n    if (index) {\n        *index = c;\n        return data;\n    } else {\n        return &data[c];\n    }\n}\n\nint\nyang_fill_extcomplex_flags(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                           LY_STMT stmt, uint16_t value, uint16_t mask)\n{\n    uint16_t *data;\n    struct lyext_substmt *info;\n\n    data = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!data) {\n        LOGVAL(ext->module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME && (*data & mask)) {\n        LOGVAL(ext->module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n\n    *data |= value;\n    return EXIT_SUCCESS;\n}\n\nint\nyang_fill_extcomplex_uint8(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                           LY_STMT stmt, uint8_t value)\n{\n    struct ly_ctx *ctx = ext->module->ctx;\n    uint8_t *val, **pp = NULL, *reallocated;\n    struct lyext_substmt *info;\n    int i = 0;\n\n    val = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!val) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (stmt == LY_STMT_DIGITS) {\n        if (info->cardinality < LY_STMT_CARD_SOME && *val) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n            return EXIT_FAILURE;\n        }\n\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances */\n            pp = (uint8_t**)val;\n            if (!(*pp)) {\n                *pp = calloc(2, sizeof(uint8_t)); /* allocate initial array */\n                LY_CHECK_ERR_RETURN(!*pp, LOGMEM(ctx), EXIT_FAILURE);\n            } else {\n                for (i = 0; (*pp)[i]; i++);\n            }\n            val = &(*pp)[i];\n        }\n\n        /* stored value */\n        *val = value;\n\n        if (i) {\n            /* enlarge the array */\n            reallocated = realloc(*pp, (i + 2) * sizeof *val);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n            *pp = reallocated;\n            (*pp)[i + 1] = 0;\n        }\n    } else {\n        if (*val) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n            return EXIT_FAILURE;\n        }\n\n        if (stmt == LY_STMT_REQINSTANCE) {\n            *val = (value == 1) ? 1 : 2;\n        } else if (stmt == LY_STMT_MODIFIER) {\n            *val =  1;\n        } else {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_extcomplex_node(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                     struct lys_node *node, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    struct lys_node **snode, *siter;\n\n    snode = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!snode) {\n        LOGVAL(ext->module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME) {\n        LY_TREE_FOR(node, siter) {\n            if (stmt == lys_snode2stmt(siter->nodetype)) {\n                LOGVAL(ext->module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n                return EXIT_FAILURE;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_fill_extcomplex_module(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext,\n                            char *parent_name, char **values, int implemented)\n{\n    int c, i;\n    struct lys_module **modules, ***p, *reallocated, **pp;\n    struct lyext_substmt *info;\n\n    if (!values) {\n        return EXIT_SUCCESS;\n    }\n    pp = modules = lys_ext_complex_get_substmt(LY_STMT_MODULE, ext, &info);\n    if (!modules) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"module\", parent_name);\n        return EXIT_FAILURE;\n    }\n\n    for (i = 0; values[i]; ++i) {\n        c = 0;\n        if (info->cardinality < LY_STMT_CARD_SOME && *modules) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"module\", parent_name);\n            return EXIT_FAILURE;\n        }\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances, so instead of pointer to array,\n             * we have in modules pointer to pointer to array */\n            p = (struct lys_module ***)pp;\n            modules = *p;\n            if (!modules) {\n                /* allocate initial array */\n                *p = modules = calloc(2, sizeof(struct lys_module *));\n                LY_CHECK_ERR_RETURN(!*p, LOGMEM(ctx), EXIT_FAILURE);\n            } else {\n                for (c = 0; *modules; modules++, c++);\n            }\n        }\n\n        if (c) {\n            /* enlarge the array */\n            reallocated = realloc(*p, (c + 2) * sizeof(struct lys_module *));\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n            *p = (struct lys_module **)reallocated;\n            modules = *p;\n            modules[c + 1] = NULL;\n        }\n\n        modules[c] = yang_read_module(ctx, values[i], 0, NULL, implemented);\n        if (!modules[c]) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n", "/**\n * @file parser_yang.h\n * @author Pavol Vican\n * @brief Parsers for libyang\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#ifndef LY_PARSER_YANG_H_\n#define LY_PARSER_YANG_H_\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libyang.h\"\n#include \"resolve.h\"\n#include \"common.h\"\n#include \"tree_schema.h\"\n#include \"context.h\"\n\n#define LYS_SYSTEMORDERED 0x40\n#define LYS_ORDERED_MASK 0xC0\n#define LYS_MIN_ELEMENTS 0x01\n#define LYS_MAX_ELEMENTS 0x02\n#define LYS_RPC_INPUT 0x01\n#define LYS_RPC_OUTPUT 0x02\n#define LYS_DATADEF 0x04\n#define LYS_TYPE_DEF 0x08\n#define LYS_CHOICE_DEFAULT 0x10\n#define LYS_NO_ERASE_IDENTITY 0x20\n#define LY_YANG_ARRAY_SIZE 8\n#define YANG_REMOVE_IMPORT 0x01\n#define YANG_EXIST_MODULE 0x02\n#define EXT_INSTANCE_SUBSTMT 0x04\n\nstruct type_node {\n    union {\n        struct lys_node_leaflist *ptr_leaflist;\n        struct lys_node_list *ptr_list;\n        struct lys_node_leaf *ptr_leaf;\n        struct lys_tpdf *ptr_tpdf;\n        struct lys_node_anydata *ptr_anydata;\n        struct lys_node_rpc_action *ptr_rpc;\n        struct lys_node_choice *ptr_choice;\n    };\n    uint flag;\n};\n\nstruct yang_parameter {\n    struct lys_module *module;\n    struct lys_submodule *submodule;\n    struct unres_schema *unres;\n    struct lys_node **node;\n    char **value;\n    void **data_node;\n    void **actual_node;\n    uint8_t flags;\n};\n\nstruct yang_ext_substmt {\n    char *ext_substmt;  /* pointer to string, which contains substmts without module statement */\n    char **ext_modules; /* array of char *, which contains module statements */\n};\n\nstruct yang_type {\n    char flags;       /**< this is used to distinguish lyxml_elem * from a YANG temporary parsing structure */\n    LY_DATA_TYPE base;\n    const char *name;\n    struct lys_type *type;\n};\n\n#include \"parser_yang_bis.h\"\n\nchar *yang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent);\n\nint yang_read_common(struct lys_module *module,char *value, enum yytokentype type);\n\nint yang_read_prefix(struct lys_module *module, struct lys_import *imp, char *value);\n\nint yang_check_version(struct lys_module *module, struct lys_submodule *submodule, char *value, int repeat);\n\nint yang_check_imports(struct lys_module *module, struct unres_schema *unres);\n\nint yang_read_description(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type);\n\nint yang_read_reference(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type);\n\nint yang_read_message(struct lys_module *module,struct lys_restr *save,char *value, char *what, int message);\n\nint yang_read_presence(struct lys_module *module, struct lys_node_container *cont, char *value);\n\nint yang_read_config(void *node, int value, enum yytokentype type);\n\nvoid *yang_read_when(struct lys_module *module, struct lys_node *node, enum yytokentype type, char *value);\n\n/**\n * @brief Allocate memory for node and add to the tree\n *\n * @param[in/out] node Pointer to the array.\n * @param[in] parent Pointer to the parent.\n * @param[in] root Pointer to the root of schema tree.\n * @param[in] value Name of node\n * @param[in] nodetype Type of node\n * @param[in] sizeof_struct Size of struct\n * @return Pointer to the node, NULL on error.\n*/\nvoid *yang_read_node(struct lys_module *module, struct lys_node *parent, struct lys_node **root,\n                     char *value, int nodetype, int sizeof_struct);\n\nint yang_read_default(struct lys_module *module, void *node, char *value, enum yytokentype type);\n\nint yang_read_units(struct lys_module *module, void *node, char *value, enum yytokentype type);\n\nint yang_read_key(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres);\n\nint yang_read_unique(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres);\n\nvoid *yang_read_type(struct ly_ctx *ctx, void *parent, char *value, enum yytokentype type);\n\nvoid *yang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance);\n\nint yang_check_type(struct lys_module *module, struct lys_node *parent, struct yang_type *typ, struct lys_type *type, int tpdftype, struct unres_schema *unres);\n\nint yang_fill_type(struct lys_module *module, struct lys_type *type, struct yang_type *stype,\n                   void *parent, struct unres_schema *unres);\n\nvoid yang_free_type_union(struct ly_ctx *ctx, struct lys_type *type);\n\nvoid yang_type_free(struct ly_ctx *ctx, struct lys_type *type);\n\nint yang_read_leafref_path(struct lys_module *module, struct yang_type *stype, char *value);\n\nint yang_read_require_instance(struct ly_ctx *ctx, struct yang_type *stype, int req);\n\nint yang_read_pattern(struct ly_ctx *ctx, struct lys_restr *pattern, void **precomp, char *value, char modifier);\n\nvoid *yang_read_range(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance);\n\nint yang_read_fraction(struct ly_ctx *ctx, struct yang_type *typ, uint32_t value);\n\nint yang_read_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, char *value);\n\nint yang_check_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, int64_t *value, int assign);\n\nint yang_read_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, char *value);\n\nint yang_check_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, int64_t *value, int assign);\n\nvoid *yang_read_typedef(struct lys_module *module, struct lys_node *parent, char *value);\n\nint yang_read_augment(struct lys_module *module, struct lys_node *parent, struct lys_node_augment *aug, char *value);\n\nvoid *yang_read_deviate(struct ly_ctx *ctx, struct lys_deviation *dev, LYS_DEVIATE_TYPE mod);\n\nvoid *yang_read_deviate_unsupported(struct ly_ctx *ctx, struct lys_deviation *dev);\n\nint yang_fill_unique(struct lys_module *module, struct lys_node_list *list, struct lys_unique *unique, char *value, struct unres_schema *unres);\n\nint yang_fill_iffeature(struct lys_module *module, struct lys_iffeature *iffeature, void *parent,\n                        char *value, struct unres_schema *unres, int parent_is_feature);\n\nvoid yang_free_ext_data(struct yang_ext_substmt *substmt);\n\nvoid *yang_read_ext(struct lys_module *module, void *actual, char *ext_name, char *ext_arg,\n                    enum yytokentype actual_type, enum yytokentype backup_type, int is_ext_instance);\n\nint yang_check_ext_instance(struct lys_module *module, struct lys_ext_instance ***ext, uint size,\n                            void *parent, struct unres_schema *unres);\n\nint yang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n                             const char *parent_name, char *value, int parent_stmt, LY_STMT stmt);\n\nvoid **yang_getplace_for_extcomplex_struct(struct lys_ext_instance_complex *ext, int *index,\n                                    char *parent_name, char *node_name, LY_STMT stmt);\n\nint yang_extcomplex_node(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                         struct lys_node *node, LY_STMT stmt);\n\nint yang_fill_extcomplex_flags(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                               LY_STMT stmt, uint16_t value, uint16_t mask);\n\nint yang_fill_extcomplex_uint8(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                               LY_STMT stmt, uint8_t value);\n\nint yang_parse_ext_substatement(struct lys_module *module, struct unres_schema *unres, const char *data,\n                                char *ext_name, struct lys_ext_instance_complex *ext);\n\nint yang_fill_extcomplex_module(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext,\n                                char *parent_name, char **values, int implemented);\n\n\n/* **\n * @brief Parse YANG from in-memory string\n *\n * yang parser expected at the end of the input string 2 zero byte\n *\n * @param[in] module Pointer to the libyang module.\n * @param[in] submodule Pointer to the libyang submodule.\n * @param[in] unres Pointer to a unres_schema\n * @param[in] data Pointer to a NULL-terminated string containing YANG data to parse.\n * @param[in] size_data Size of input string\n * @param[in/out] node Pointer to node\n * @return 0 on success, -1 on error, 1 on module is already in context.\n */\nint yang_parse_mem(struct lys_module *module, struct lys_submodule *submodule, struct unres_schema *unres,\n                   const char *data, unsigned int size_data, struct lys_node **node);\n\nstruct lys_module *yang_read_module(struct ly_ctx *ctx, const char* data, unsigned int size, const char *revision, int implement);\n\nstruct lys_submodule *yang_read_submodule(struct lys_module *module, const char *data, unsigned int size, struct unres_schema *unres);\n\n#endif /* LY_PARSER_YANG_H_ */\n", "/* A Bison parser, made by GNU Bison 3.2.4.  */\n\n/* Bison implementation for Yacc-like parsers in C\n\n   Copyright (C) 1984, 1989-1990, 2000-2015, 2018 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n/* As a special exception, you may create a larger work that contains\n   part or all of the Bison parser skeleton and distribute that work\n   under terms of your choice, so long as that work isn't itself a\n   parser generator using the skeleton or a modified version thereof\n   as a parser skeleton.  Alternatively, if you modify or redistribute\n   the parser skeleton itself, you may (at your option) remove this\n   special exception, which will cause the skeleton and the resulting\n   Bison output files to be licensed under the GNU General Public\n   License without this special exception.\n\n   This special exception was added by the Free Software Foundation in\n   version 2.2 of Bison.  */\n\n/* C LALR(1) parser skeleton written by Richard Stallman, by\n   simplifying the original so-called \"semantic\" parser.  */\n\n/* All symbols defined below should begin with yy or YY, to avoid\n   infringing on user name space.  This should be done even for local\n   variables, as they might otherwise be expanded by user macros.\n   There are some unavoidable exceptions within include files to\n   define necessary library symbols; they are noted \"INFRINGES ON\n   USER NAME SPACE\" below.  */\n\n/* Undocumented macros, especially those whose name start with YY_,\n   are private implementation details.  Do not rely on them.  */\n\n/* Identify Bison output.  */\n#define YYBISON 1\n\n/* Bison version.  */\n#define YYBISON_VERSION \"3.2.4\"\n\n/* Skeleton name.  */\n#define YYSKELETON_NAME \"yacc.c\"\n\n/* Pure parsers.  */\n#define YYPURE 2\n\n/* Push parsers.  */\n#define YYPUSH 0\n\n/* Pull parsers.  */\n#define YYPULL 1\n\n\n\n\n/* First part of user prologue.  */\n\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"libyang.h\"\n#include \"common.h\"\n#include \"context.h\"\n#include \"resolve.h\"\n#include \"parser_yang.h\"\n#include \"parser_yang_lex.h\"\n#include \"parser.h\"\n\n#define YANG_ADDELEM(current_ptr, size, array_name)                                      \\\n    if ((size) == LY_ARRAY_MAX(size)) {                                                  \\\n         LOGERR(trg->ctx, LY_EINT, \"Reached limit (%\"PRIu64\") for storing %s.\", LY_ARRAY_MAX(size), array_name); \\\n         free(s);                                                                        \\\n         YYABORT;                                                                        \\\n    } else if (!((size) % LY_YANG_ARRAY_SIZE)) {                                         \\\n        void *tmp;                                                                       \\\n                                                                                         \\\n        tmp = realloc((current_ptr), (sizeof *(current_ptr)) * ((size) + LY_YANG_ARRAY_SIZE)); \\\n        if (!tmp) {                                                                      \\\n            LOGMEM(trg->ctx);                                                            \\\n            free(s);                                                                     \\\n            YYABORT;                                                                     \\\n        }                                                                                \\\n        memset(tmp + (sizeof *(current_ptr)) * (size), 0, (sizeof *(current_ptr)) * LY_YANG_ARRAY_SIZE); \\\n        (current_ptr) = tmp;                                                             \\\n    }                                                                                    \\\n    actual = &(current_ptr)[(size)++];                                                   \\\n\nvoid yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...);\n/* pointer on the current parsed element 'actual' */\n\n\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n/* Enabling verbose error messages.  */\n#ifdef YYERROR_VERBOSE\n# undef YYERROR_VERBOSE\n# define YYERROR_VERBOSE 1\n#else\n# define YYERROR_VERBOSE 0\n#endif\n\n/* In a future release of Bison, this section will be replaced\n   by #include \"parser_yang_bis.h\".  */\n#ifndef YY_YY_PARSER_YANG_BIS_H_INCLUDED\n# define YY_YY_PARSER_YANG_BIS_H_INCLUDED\n/* Debug traces.  */\n#ifndef YYDEBUG\n# define YYDEBUG 0\n#endif\n#if YYDEBUG\nextern int yydebug;\n#endif\n\n/* Token type.  */\n#ifndef YYTOKENTYPE\n# define YYTOKENTYPE\n  enum yytokentype\n  {\n    UNION_KEYWORD = 258,\n    ANYXML_KEYWORD = 259,\n    WHITESPACE = 260,\n    ERROR = 261,\n    EOL = 262,\n    STRING = 263,\n    STRINGS = 264,\n    IDENTIFIER = 265,\n    IDENTIFIERPREFIX = 266,\n    REVISION_DATE = 267,\n    TAB = 268,\n    DOUBLEDOT = 269,\n    URI = 270,\n    INTEGER = 271,\n    NON_NEGATIVE_INTEGER = 272,\n    ZERO = 273,\n    DECIMAL = 274,\n    ARGUMENT_KEYWORD = 275,\n    AUGMENT_KEYWORD = 276,\n    BASE_KEYWORD = 277,\n    BELONGS_TO_KEYWORD = 278,\n    BIT_KEYWORD = 279,\n    CASE_KEYWORD = 280,\n    CHOICE_KEYWORD = 281,\n    CONFIG_KEYWORD = 282,\n    CONTACT_KEYWORD = 283,\n    CONTAINER_KEYWORD = 284,\n    DEFAULT_KEYWORD = 285,\n    DESCRIPTION_KEYWORD = 286,\n    ENUM_KEYWORD = 287,\n    ERROR_APP_TAG_KEYWORD = 288,\n    ERROR_MESSAGE_KEYWORD = 289,\n    EXTENSION_KEYWORD = 290,\n    DEVIATION_KEYWORD = 291,\n    DEVIATE_KEYWORD = 292,\n    FEATURE_KEYWORD = 293,\n    FRACTION_DIGITS_KEYWORD = 294,\n    GROUPING_KEYWORD = 295,\n    IDENTITY_KEYWORD = 296,\n    IF_FEATURE_KEYWORD = 297,\n    IMPORT_KEYWORD = 298,\n    INCLUDE_KEYWORD = 299,\n    INPUT_KEYWORD = 300,\n    KEY_KEYWORD = 301,\n    LEAF_KEYWORD = 302,\n    LEAF_LIST_KEYWORD = 303,\n    LENGTH_KEYWORD = 304,\n    LIST_KEYWORD = 305,\n    MANDATORY_KEYWORD = 306,\n    MAX_ELEMENTS_KEYWORD = 307,\n    MIN_ELEMENTS_KEYWORD = 308,\n    MODULE_KEYWORD = 309,\n    MUST_KEYWORD = 310,\n    NAMESPACE_KEYWORD = 311,\n    NOTIFICATION_KEYWORD = 312,\n    ORDERED_BY_KEYWORD = 313,\n    ORGANIZATION_KEYWORD = 314,\n    OUTPUT_KEYWORD = 315,\n    PATH_KEYWORD = 316,\n    PATTERN_KEYWORD = 317,\n    POSITION_KEYWORD = 318,\n    PREFIX_KEYWORD = 319,\n    PRESENCE_KEYWORD = 320,\n    RANGE_KEYWORD = 321,\n    REFERENCE_KEYWORD = 322,\n    REFINE_KEYWORD = 323,\n    REQUIRE_INSTANCE_KEYWORD = 324,\n    REVISION_KEYWORD = 325,\n    REVISION_DATE_KEYWORD = 326,\n    RPC_KEYWORD = 327,\n    STATUS_KEYWORD = 328,\n    SUBMODULE_KEYWORD = 329,\n    TYPE_KEYWORD = 330,\n    TYPEDEF_KEYWORD = 331,\n    UNIQUE_KEYWORD = 332,\n    UNITS_KEYWORD = 333,\n    USES_KEYWORD = 334,\n    VALUE_KEYWORD = 335,\n    WHEN_KEYWORD = 336,\n    YANG_VERSION_KEYWORD = 337,\n    YIN_ELEMENT_KEYWORD = 338,\n    ADD_KEYWORD = 339,\n    CURRENT_KEYWORD = 340,\n    DELETE_KEYWORD = 341,\n    DEPRECATED_KEYWORD = 342,\n    FALSE_KEYWORD = 343,\n    NOT_SUPPORTED_KEYWORD = 344,\n    OBSOLETE_KEYWORD = 345,\n    REPLACE_KEYWORD = 346,\n    SYSTEM_KEYWORD = 347,\n    TRUE_KEYWORD = 348,\n    UNBOUNDED_KEYWORD = 349,\n    USER_KEYWORD = 350,\n    ACTION_KEYWORD = 351,\n    MODIFIER_KEYWORD = 352,\n    ANYDATA_KEYWORD = 353,\n    NODE = 354,\n    NODE_PRINT = 355,\n    EXTENSION_INSTANCE = 356,\n    SUBMODULE_EXT_KEYWORD = 357\n  };\n#endif\n\n/* Value type.  */\n#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED\n\nunion YYSTYPE\n{\n\n\n  int32_t i;\n  uint32_t uint;\n  char *str;\n  char **p_str;\n  void *v;\n  char ch;\n  struct yang_type *type;\n  struct lys_deviation *dev;\n  struct lys_deviate *deviate;\n  union {\n    uint32_t index;\n    struct lys_node_container *container;\n    struct lys_node_anydata *anydata;\n    struct type_node node;\n    struct lys_node_case *cs;\n    struct lys_node_grp *grouping;\n    struct lys_refine *refine;\n    struct lys_node_notif *notif;\n    struct lys_node_uses *uses;\n    struct lys_node_inout *inout;\n    struct lys_node_augment *augment;\n  } nodes;\n  enum yytokentype token;\n  struct {\n    void *actual;\n    enum yytokentype token;\n  } backup_token;\n  struct {\n    struct lys_revision **revision;\n    int index;\n  } revisions;\n\n\n};\n\ntypedef union YYSTYPE YYSTYPE;\n# define YYSTYPE_IS_TRIVIAL 1\n# define YYSTYPE_IS_DECLARED 1\n#endif\n\n/* Location type.  */\n#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED\ntypedef struct YYLTYPE YYLTYPE;\nstruct YYLTYPE\n{\n  int first_line;\n  int first_column;\n  int last_line;\n  int last_column;\n};\n# define YYLTYPE_IS_DECLARED 1\n# define YYLTYPE_IS_TRIVIAL 1\n#endif\n\n\n\nint yyparse (void *scanner, struct yang_parameter *param);\n\n#endif /* !YY_YY_PARSER_YANG_BIS_H_INCLUDED  */\n\n\n\n#ifdef short\n# undef short\n#endif\n\n#ifdef YYTYPE_UINT8\ntypedef YYTYPE_UINT8 yytype_uint8;\n#else\ntypedef unsigned char yytype_uint8;\n#endif\n\n#ifdef YYTYPE_INT8\ntypedef YYTYPE_INT8 yytype_int8;\n#else\ntypedef signed char yytype_int8;\n#endif\n\n#ifdef YYTYPE_UINT16\ntypedef YYTYPE_UINT16 yytype_uint16;\n#else\ntypedef unsigned short yytype_uint16;\n#endif\n\n#ifdef YYTYPE_INT16\ntypedef YYTYPE_INT16 yytype_int16;\n#else\ntypedef short yytype_int16;\n#endif\n\n#ifndef YYSIZE_T\n# ifdef __SIZE_TYPE__\n#  define YYSIZE_T __SIZE_TYPE__\n# elif defined size_t\n#  define YYSIZE_T size_t\n# elif ! defined YYSIZE_T\n#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */\n#  define YYSIZE_T size_t\n# else\n#  define YYSIZE_T unsigned\n# endif\n#endif\n\n#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)\n\n#ifndef YY_\n# if defined YYENABLE_NLS && YYENABLE_NLS\n#  if ENABLE_NLS\n#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */\n#   define YY_(Msgid) dgettext (\"bison-runtime\", Msgid)\n#  endif\n# endif\n# ifndef YY_\n#  define YY_(Msgid) Msgid\n# endif\n#endif\n\n#ifndef YY_ATTRIBUTE\n# if (defined __GNUC__                                               \\\n      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \\\n     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C\n#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)\n# else\n#  define YY_ATTRIBUTE(Spec) /* empty */\n# endif\n#endif\n\n#ifndef YY_ATTRIBUTE_PURE\n# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))\n#endif\n\n#ifndef YY_ATTRIBUTE_UNUSED\n# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))\n#endif\n\n/* Suppress unused-variable warnings by \"using\" E.  */\n#if ! defined lint || defined __GNUC__\n# define YYUSE(E) ((void) (E))\n#else\n# define YYUSE(E) /* empty */\n#endif\n\n#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__\n/* Suppress an incorrect diagnostic about yylval being uninitialized.  */\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \\\n    _Pragma (\"GCC diagnostic push\") \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")\\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wmaybe-uninitialized\\\"\")\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END \\\n    _Pragma (\"GCC diagnostic pop\")\n#else\n# define YY_INITIAL_VALUE(Value) Value\n#endif\n#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END\n#endif\n#ifndef YY_INITIAL_VALUE\n# define YY_INITIAL_VALUE(Value) /* Nothing. */\n#endif\n\n\n#if ! defined yyoverflow || YYERROR_VERBOSE\n\n/* The parser invokes alloca or malloc; define the necessary symbols.  */\n\n# ifdef YYSTACK_USE_ALLOCA\n#  if YYSTACK_USE_ALLOCA\n#   ifdef __GNUC__\n#    define YYSTACK_ALLOC __builtin_alloca\n#   elif defined __BUILTIN_VA_ARG_INCR\n#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */\n#   elif defined _AIX\n#    define YYSTACK_ALLOC __alloca\n#   elif defined _MSC_VER\n#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */\n#    define alloca _alloca\n#   else\n#    define YYSTACK_ALLOC alloca\n#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS\n#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */\n      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */\n#     ifndef EXIT_SUCCESS\n#      define EXIT_SUCCESS 0\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n\n# ifdef YYSTACK_ALLOC\n   /* Pacify GCC's 'empty if-body' warning.  */\n#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n    /* The OS might guarantee only one guard page at the bottom of the stack,\n       and a page size can be as small as 4096 bytes.  So we cannot safely\n       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number\n       to allow for a few compiler-allocated temporary stack slots.  */\n#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */\n#  endif\n# else\n#  define YYSTACK_ALLOC YYMALLOC\n#  define YYSTACK_FREE YYFREE\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM\n#  endif\n#  if (defined __cplusplus && ! defined EXIT_SUCCESS \\\n       && ! ((defined YYMALLOC || defined malloc) \\\n             && (defined YYFREE || defined free)))\n#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */\n#   ifndef EXIT_SUCCESS\n#    define EXIT_SUCCESS 0\n#   endif\n#  endif\n#  ifndef YYMALLOC\n#   define YYMALLOC malloc\n#   if ! defined malloc && ! defined EXIT_SUCCESS\nvoid *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */\n#   endif\n#  endif\n#  ifndef YYFREE\n#   define YYFREE free\n#   if ! defined free && ! defined EXIT_SUCCESS\nvoid free (void *); /* INFRINGES ON USER NAME SPACE */\n#   endif\n#  endif\n# endif\n#endif /* ! defined yyoverflow || YYERROR_VERBOSE */\n\n\n#if (! defined yyoverflow \\\n     && (! defined __cplusplus \\\n         || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \\\n             && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))\n\n/* A type that is properly aligned for any stack member.  */\nunion yyalloc\n{\n  yytype_int16 yyss_alloc;\n  YYSTYPE yyvs_alloc;\n  YYLTYPE yyls_alloc;\n};\n\n/* The size of the maximum gap between one aligned stack and the next.  */\n# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)\n\n/* The size of an array large to enough to hold all stacks, each with\n   N elements.  */\n# define YYSTACK_BYTES(N) \\\n     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \\\n      + 2 * YYSTACK_GAP_MAXIMUM)\n\n# define YYCOPY_NEEDED 1\n\n/* Relocate STACK from its old location to the new one.  The\n   local variables YYSIZE and YYSTACKSIZE give the old and new number of\n   elements in the stack, and YYPTR gives the new location of the\n   stack.  Advance YYPTR to a properly aligned location for the next\n   stack.  */\n# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \\\n    do                                                                  \\\n      {                                                                 \\\n        YYSIZE_T yynewbytes;                                            \\\n        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \\\n        Stack = &yyptr->Stack_alloc;                                    \\\n        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \\\n        yyptr += yynewbytes / sizeof (*yyptr);                          \\\n      }                                                                 \\\n    while (0)\n\n#endif\n\n#if defined YYCOPY_NEEDED && YYCOPY_NEEDED\n/* Copy COUNT objects from SRC to DST.  The source and destination do\n   not overlap.  */\n# ifndef YYCOPY\n#  if defined __GNUC__ && 1 < __GNUC__\n#   define YYCOPY(Dst, Src, Count) \\\n      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))\n#  else\n#   define YYCOPY(Dst, Src, Count)              \\\n      do                                        \\\n        {                                       \\\n          YYSIZE_T yyi;                         \\\n          for (yyi = 0; yyi < (Count); yyi++)   \\\n            (Dst)[yyi] = (Src)[yyi];            \\\n        }                                       \\\n      while (0)\n#  endif\n# endif\n#endif /* !YYCOPY_NEEDED */\n\n/* YYFINAL -- State number of the termination state.  */\n#define YYFINAL  6\n/* YYLAST -- Last index in YYTABLE.  */\n#define YYLAST   3466\n\n/* YYNTOKENS -- Number of terminals.  */\n#define YYNTOKENS  113\n/* YYNNTS -- Number of nonterminals.  */\n#define YYNNTS  329\n/* YYNRULES -- Number of rules.  */\n#define YYNRULES  827\n/* YYNSTATES -- Number of states.  */\n#define YYNSTATES  1318\n\n/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned\n   by yylex, with out-of-bounds checking.  */\n#define YYUNDEFTOK  2\n#define YYMAXUTOK   357\n\n#define YYTRANSLATE(YYX)                                                \\\n  ((unsigned) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)\n\n/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM\n   as returned by yylex, without out-of-bounds checking.  */\nstatic const yytype_uint8 yytranslate[] =\n{\n       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     111,   112,     2,   103,     2,     2,     2,   107,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,   106,\n       2,   110,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,   108,     2,   109,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,   104,     2,   105,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,\n       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,\n      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,\n      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,\n      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,\n      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,\n      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,\n      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,\n      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,\n      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,\n      95,    96,    97,    98,    99,   100,   101,   102\n};\n\n#if YYDEBUG\n  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */\nstatic const yytype_uint16 yyrline[] =\n{\n       0,   338,   338,   339,   340,   342,   365,   368,   370,   369,\n     393,   404,   414,   424,   425,   431,   436,   442,   453,   463,\n     476,   477,   483,   485,   489,   491,   495,   497,   498,   499,\n     501,   509,   517,   518,   523,   534,   545,   556,   564,   569,\n     570,   574,   575,   586,   597,   608,   612,   614,   637,   654,\n     658,   660,   661,   666,   671,   676,   682,   686,   688,   692,\n     694,   698,   700,   704,   706,   719,   730,   731,   743,   747,\n     748,   752,   753,   758,   765,   765,   776,   782,   830,   849,\n     852,   853,   854,   855,   856,   857,   858,   859,   860,   861,\n     864,   879,   886,   887,   891,   892,   893,   899,   904,   910,\n     928,   930,   931,   935,   940,   941,   963,   964,   965,   978,\n     983,   985,   986,   987,   988,  1003,  1017,  1022,  1023,  1038,\n    1039,  1040,  1046,  1051,  1057,  1114,  1119,  1120,  1122,  1138,\n    1143,  1144,  1169,  1170,  1184,  1185,  1191,  1196,  1202,  1206,\n    1208,  1261,  1272,  1275,  1278,  1283,  1288,  1294,  1299,  1305,\n    1310,  1319,  1320,  1324,  1371,  1372,  1374,  1375,  1379,  1385,\n    1398,  1399,  1400,  1404,  1405,  1407,  1411,  1429,  1434,  1436,\n    1437,  1453,  1458,  1467,  1468,  1472,  1488,  1493,  1498,  1503,\n    1509,  1513,  1529,  1544,  1545,  1549,  1550,  1560,  1565,  1570,\n    1575,  1581,  1585,  1596,  1608,  1609,  1612,  1620,  1631,  1632,\n    1647,  1648,  1649,  1661,  1667,  1672,  1678,  1683,  1685,  1686,\n    1701,  1706,  1707,  1712,  1716,  1718,  1723,  1725,  1726,  1727,\n    1740,  1752,  1753,  1755,  1763,  1775,  1776,  1791,  1792,  1793,\n    1805,  1811,  1816,  1822,  1827,  1829,  1830,  1846,  1850,  1852,\n    1856,  1858,  1862,  1864,  1868,  1870,  1880,  1887,  1888,  1892,\n    1893,  1899,  1904,  1909,  1910,  1911,  1912,  1913,  1919,  1920,\n    1921,  1922,  1923,  1924,  1925,  1926,  1929,  1939,  1946,  1947,\n    1970,  1971,  1972,  1973,  1974,  1979,  1985,  1991,  1996,  2001,\n    2002,  2003,  2008,  2009,  2011,  2051,  2061,  2064,  2065,  2066,\n    2069,  2074,  2075,  2080,  2086,  2092,  2098,  2103,  2109,  2119,\n    2174,  2177,  2178,  2179,  2182,  2193,  2198,  2199,  2205,  2218,\n    2231,  2241,  2247,  2252,  2258,  2268,  2315,  2318,  2319,  2320,\n    2321,  2330,  2336,  2342,  2355,  2368,  2378,  2384,  2389,  2394,\n    2395,  2396,  2397,  2402,  2404,  2414,  2421,  2422,  2442,  2445,\n    2446,  2447,  2457,  2464,  2471,  2478,  2484,  2490,  2492,  2493,\n    2495,  2496,  2497,  2498,  2499,  2500,  2501,  2507,  2517,  2524,\n    2525,  2539,  2540,  2541,  2542,  2548,  2553,  2558,  2561,  2571,\n    2578,  2588,  2595,  2596,  2619,  2622,  2623,  2624,  2625,  2632,\n    2639,  2646,  2651,  2657,  2667,  2674,  2675,  2707,  2708,  2709,\n    2710,  2716,  2721,  2726,  2727,  2729,  2730,  2732,  2745,  2750,\n    2751,  2783,  2786,  2800,  2816,  2838,  2889,  2908,  2927,  2948,\n    2969,  2974,  2980,  2981,  2984,  2999,  3008,  3009,  3011,  3022,\n    3031,  3032,  3033,  3034,  3040,  3045,  3050,  3051,  3052,  3057,\n    3059,  3074,  3081,  3091,  3098,  3099,  3123,  3126,  3127,  3133,\n    3138,  3143,  3144,  3145,  3152,  3160,  3175,  3205,  3206,  3207,\n    3208,  3209,  3211,  3226,  3256,  3265,  3272,  3273,  3305,  3306,\n    3307,  3308,  3314,  3319,  3324,  3325,  3326,  3328,  3340,  3360,\n    3361,  3367,  3373,  3375,  3376,  3378,  3379,  3382,  3390,  3395,\n    3396,  3398,  3399,  3400,  3402,  3410,  3415,  3416,  3448,  3449,\n    3455,  3456,  3462,  3468,  3475,  3482,  3490,  3499,  3507,  3512,\n    3513,  3545,  3546,  3552,  3553,  3559,  3566,  3574,  3579,  3580,\n    3594,  3595,  3596,  3602,  3608,  3615,  3622,  3630,  3639,  3648,\n    3653,  3654,  3658,  3659,  3664,  3670,  3675,  3677,  3678,  3679,\n    3692,  3697,  3699,  3700,  3701,  3714,  3718,  3720,  3725,  3727,\n    3728,  3748,  3753,  3755,  3756,  3757,  3777,  3782,  3784,  3785,\n    3786,  3798,  3867,  3872,  3873,  3877,  3881,  3883,  3884,  3886,\n    3890,  3892,  3892,  3899,  3902,  3911,  3930,  3932,  3933,  3936,\n    3936,  3953,  3953,  3960,  3960,  3967,  3970,  3972,  3974,  3975,\n    3977,  3979,  3981,  3982,  3984,  3986,  3987,  3989,  3990,  3992,\n    3994,  3997,  4000,  4002,  4003,  4005,  4006,  4008,  4010,  4021,\n    4022,  4025,  4026,  4038,  4039,  4041,  4042,  4044,  4045,  4051,\n    4052,  4055,  4056,  4057,  4081,  4082,  4085,  4091,  4095,  4100,\n    4101,  4102,  4105,  4110,  4120,  4122,  4123,  4125,  4126,  4128,\n    4129,  4130,  4132,  4133,  4135,  4136,  4138,  4139,  4143,  4144,\n    4171,  4209,  4210,  4212,  4214,  4216,  4217,  4219,  4220,  4222,\n    4223,  4226,  4227,  4230,  4232,  4233,  4236,  4236,  4243,  4245,\n    4246,  4247,  4248,  4249,  4250,  4251,  4253,  4254,  4255,  4257,\n    4258,  4259,  4260,  4261,  4262,  4263,  4264,  4265,  4266,  4269,\n    4270,  4271,  4272,  4273,  4274,  4275,  4276,  4277,  4278,  4279,\n    4280,  4281,  4282,  4283,  4284,  4285,  4286,  4287,  4288,  4289,\n    4290,  4291,  4292,  4293,  4294,  4295,  4296,  4297,  4298,  4299,\n    4300,  4301,  4302,  4303,  4304,  4305,  4306,  4307,  4308,  4309,\n    4310,  4311,  4312,  4313,  4314,  4315,  4316,  4317,  4318,  4319,\n    4320,  4321,  4322,  4323,  4324,  4325,  4326,  4327,  4328,  4329,\n    4330,  4331,  4332,  4333,  4334,  4335,  4336,  4337,  4338,  4340,\n    4347,  4354,  4374,  4392,  4408,  4435,  4442,  4460,  4500,  4502,\n    4503,  4504,  4505,  4506,  4507,  4508,  4509,  4510,  4511,  4512,\n    4513,  4514,  4516,  4517,  4518,  4519,  4520,  4521,  4522,  4523,\n    4524,  4525,  4526,  4527,  4528,  4529,  4531,  4532,  4533,  4534,\n    4536,  4544,  4545,  4550,  4555,  4560,  4565,  4570,  4575,  4580,\n    4585,  4590,  4595,  4600,  4605,  4610,  4615,  4620,  4634,  4654,\n    4659,  4664,  4669,  4682,  4687,  4691,  4701,  4716,  4731,  4746,\n    4761,  4781,  4796,  4797,  4803,  4810,  4825,  4828\n};\n#endif\n\n#if YYDEBUG || YYERROR_VERBOSE || 0\n/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.\n   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */\nstatic const char *const yytname[] =\n{\n  \"$end\", \"error\", \"$undefined\", \"UNION_KEYWORD\", \"ANYXML_KEYWORD\",\n  \"WHITESPACE\", \"ERROR\", \"EOL\", \"STRING\", \"STRINGS\", \"IDENTIFIER\",\n  \"IDENTIFIERPREFIX\", \"REVISION_DATE\", \"TAB\", \"DOUBLEDOT\", \"URI\",\n  \"INTEGER\", \"NON_NEGATIVE_INTEGER\", \"ZERO\", \"DECIMAL\", \"ARGUMENT_KEYWORD\",\n  \"AUGMENT_KEYWORD\", \"BASE_KEYWORD\", \"BELONGS_TO_KEYWORD\", \"BIT_KEYWORD\",\n  \"CASE_KEYWORD\", \"CHOICE_KEYWORD\", \"CONFIG_KEYWORD\", \"CONTACT_KEYWORD\",\n  \"CONTAINER_KEYWORD\", \"DEFAULT_KEYWORD\", \"DESCRIPTION_KEYWORD\",\n  \"ENUM_KEYWORD\", \"ERROR_APP_TAG_KEYWORD\", \"ERROR_MESSAGE_KEYWORD\",\n  \"EXTENSION_KEYWORD\", \"DEVIATION_KEYWORD\", \"DEVIATE_KEYWORD\",\n  \"FEATURE_KEYWORD\", \"FRACTION_DIGITS_KEYWORD\", \"GROUPING_KEYWORD\",\n  \"IDENTITY_KEYWORD\", \"IF_FEATURE_KEYWORD\", \"IMPORT_KEYWORD\",\n  \"INCLUDE_KEYWORD\", \"INPUT_KEYWORD\", \"KEY_KEYWORD\", \"LEAF_KEYWORD\",\n  \"LEAF_LIST_KEYWORD\", \"LENGTH_KEYWORD\", \"LIST_KEYWORD\",\n  \"MANDATORY_KEYWORD\", \"MAX_ELEMENTS_KEYWORD\", \"MIN_ELEMENTS_KEYWORD\",\n  \"MODULE_KEYWORD\", \"MUST_KEYWORD\", \"NAMESPACE_KEYWORD\",\n  \"NOTIFICATION_KEYWORD\", \"ORDERED_BY_KEYWORD\", \"ORGANIZATION_KEYWORD\",\n  \"OUTPUT_KEYWORD\", \"PATH_KEYWORD\", \"PATTERN_KEYWORD\", \"POSITION_KEYWORD\",\n  \"PREFIX_KEYWORD\", \"PRESENCE_KEYWORD\", \"RANGE_KEYWORD\",\n  \"REFERENCE_KEYWORD\", \"REFINE_KEYWORD\", \"REQUIRE_INSTANCE_KEYWORD\",\n  \"REVISION_KEYWORD\", \"REVISION_DATE_KEYWORD\", \"RPC_KEYWORD\",\n  \"STATUS_KEYWORD\", \"SUBMODULE_KEYWORD\", \"TYPE_KEYWORD\", \"TYPEDEF_KEYWORD\",\n  \"UNIQUE_KEYWORD\", \"UNITS_KEYWORD\", \"USES_KEYWORD\", \"VALUE_KEYWORD\",\n  \"WHEN_KEYWORD\", \"YANG_VERSION_KEYWORD\", \"YIN_ELEMENT_KEYWORD\",\n  \"ADD_KEYWORD\", \"CURRENT_KEYWORD\", \"DELETE_KEYWORD\", \"DEPRECATED_KEYWORD\",\n  \"FALSE_KEYWORD\", \"NOT_SUPPORTED_KEYWORD\", \"OBSOLETE_KEYWORD\",\n  \"REPLACE_KEYWORD\", \"SYSTEM_KEYWORD\", \"TRUE_KEYWORD\", \"UNBOUNDED_KEYWORD\",\n  \"USER_KEYWORD\", \"ACTION_KEYWORD\", \"MODIFIER_KEYWORD\", \"ANYDATA_KEYWORD\",\n  \"NODE\", \"NODE_PRINT\", \"EXTENSION_INSTANCE\", \"SUBMODULE_EXT_KEYWORD\",\n  \"'+'\", \"'{'\", \"'}'\", \"';'\", \"'/'\", \"'['\", \"']'\", \"'='\", \"'('\", \"')'\",\n  \"$accept\", \"start\", \"tmp_string\", \"string_1\", \"string_2\", \"$@1\",\n  \"module_arg_str\", \"module_stmt\", \"module_header_stmts\",\n  \"module_header_stmt\", \"submodule_arg_str\", \"submodule_stmt\",\n  \"submodule_header_stmts\", \"submodule_header_stmt\", \"yang_version_arg\",\n  \"yang_version_stmt\", \"namespace_arg_str\", \"namespace_stmt\",\n  \"linkage_stmts\", \"import_stmt\", \"import_arg_str\", \"import_opt_stmt\",\n  \"include_arg_str\", \"include_stmt\", \"include_end\", \"include_opt_stmt\",\n  \"revision_date_arg\", \"revision_date_stmt\", \"belongs_to_arg_str\",\n  \"belongs_to_stmt\", \"prefix_arg\", \"prefix_stmt\", \"meta_stmts\",\n  \"organization_arg\", \"organization_stmt\", \"contact_arg\", \"contact_stmt\",\n  \"description_arg\", \"description_stmt\", \"reference_arg\", \"reference_stmt\",\n  \"revision_stmts\", \"revision_arg_stmt\", \"revision_stmts_opt\",\n  \"revision_stmt\", \"revision_end\", \"revision_opt_stmt\", \"date_arg_str\",\n  \"$@2\", \"body_stmts_end\", \"body_stmts\", \"body_stmt\", \"extension_arg_str\",\n  \"extension_stmt\", \"extension_end\", \"extension_opt_stmt\", \"argument_str\",\n  \"argument_stmt\", \"argument_end\", \"yin_element_arg\", \"yin_element_stmt\",\n  \"yin_element_arg_str\", \"status_arg\", \"status_stmt\", \"status_arg_str\",\n  \"feature_arg_str\", \"feature_stmt\", \"feature_end\", \"feature_opt_stmt\",\n  \"if_feature_arg\", \"if_feature_stmt\", \"if_feature_end\",\n  \"identity_arg_str\", \"identity_stmt\", \"identity_end\", \"identity_opt_stmt\",\n  \"base_arg\", \"base_stmt\", \"typedef_arg_str\", \"typedef_stmt\",\n  \"type_opt_stmt\", \"type_stmt\", \"type_arg_str\", \"type_end\",\n  \"type_body_stmts\", \"some_restrictions\", \"union_stmt\", \"union_spec\",\n  \"fraction_digits_arg\", \"fraction_digits_stmt\", \"fraction_digits_arg_str\",\n  \"length_stmt\", \"length_arg_str\", \"length_end\", \"message_opt_stmt\",\n  \"pattern_sep\", \"pattern_stmt\", \"pattern_arg_str\", \"pattern_end\",\n  \"pattern_opt_stmt\", \"modifier_arg\", \"modifier_stmt\",\n  \"enum_specification\", \"enum_stmts\", \"enum_stmt\", \"enum_arg_str\",\n  \"enum_end\", \"enum_opt_stmt\", \"value_arg\", \"value_stmt\",\n  \"integer_value_arg_str\", \"range_stmt\", \"range_end\", \"path_arg\",\n  \"path_stmt\", \"require_instance_arg\", \"require_instance_stmt\",\n  \"require_instance_arg_str\", \"bits_specification\", \"bit_stmts\",\n  \"bit_stmt\", \"bit_arg_str\", \"bit_end\", \"bit_opt_stmt\",\n  \"position_value_arg\", \"position_stmt\", \"position_value_arg_str\",\n  \"error_message_arg\", \"error_message_stmt\", \"error_app_tag_arg\",\n  \"error_app_tag_stmt\", \"units_arg\", \"units_stmt\", \"default_arg\",\n  \"default_stmt\", \"grouping_arg_str\", \"grouping_stmt\", \"grouping_end\",\n  \"grouping_opt_stmt\", \"data_def_stmt\", \"container_arg_str\",\n  \"container_stmt\", \"container_end\", \"container_opt_stmt\", \"leaf_stmt\",\n  \"leaf_arg_str\", \"leaf_opt_stmt\", \"leaf_list_arg_str\", \"leaf_list_stmt\",\n  \"leaf_list_opt_stmt\", \"list_arg_str\", \"list_stmt\", \"list_opt_stmt\",\n  \"choice_arg_str\", \"choice_stmt\", \"choice_end\", \"choice_opt_stmt\",\n  \"short_case_case_stmt\", \"short_case_stmt\", \"case_arg_str\", \"case_stmt\",\n  \"case_end\", \"case_opt_stmt\", \"anyxml_arg_str\", \"anyxml_stmt\",\n  \"anydata_arg_str\", \"anydata_stmt\", \"anyxml_end\", \"anyxml_opt_stmt\",\n  \"uses_arg_str\", \"uses_stmt\", \"uses_end\", \"uses_opt_stmt\",\n  \"refine_args_str\", \"refine_arg_str\", \"refine_stmt\", \"refine_end\",\n  \"refine_body_opt_stmts\", \"uses_augment_arg_str\", \"uses_augment_arg\",\n  \"uses_augment_stmt\", \"augment_arg_str\", \"augment_arg\", \"augment_stmt\",\n  \"augment_opt_stmt\", \"action_arg_str\", \"action_stmt\", \"rpc_arg_str\",\n  \"rpc_stmt\", \"rpc_end\", \"rpc_opt_stmt\", \"input_arg\", \"input_stmt\",\n  \"input_output_opt_stmt\", \"output_arg\", \"output_stmt\",\n  \"notification_arg_str\", \"notification_stmt\", \"notification_end\",\n  \"notification_opt_stmt\", \"deviation_arg\", \"deviation_stmt\",\n  \"deviation_opt_stmt\", \"deviation_arg_str\", \"deviate_body_stmt\",\n  \"deviate_not_supported\", \"deviate_not_supported_stmt\",\n  \"deviate_not_supported_end\", \"deviate_stmts\", \"deviate_add\",\n  \"deviate_add_stmt\", \"deviate_add_end\", \"deviate_add_opt_stmt\",\n  \"deviate_delete\", \"deviate_delete_stmt\", \"deviate_delete_end\",\n  \"deviate_delete_opt_stmt\", \"deviate_replace\", \"deviate_replace_stmt\",\n  \"deviate_replace_end\", \"deviate_replace_opt_stmt\", \"when_arg_str\",\n  \"when_stmt\", \"when_end\", \"when_opt_stmt\", \"config_arg\", \"config_stmt\",\n  \"config_arg_str\", \"mandatory_arg\", \"mandatory_stmt\", \"mandatory_arg_str\",\n  \"presence_arg\", \"presence_stmt\", \"min_value_arg\", \"min_elements_stmt\",\n  \"min_value_arg_str\", \"max_value_arg\", \"max_elements_stmt\",\n  \"max_value_arg_str\", \"ordered_by_arg\", \"ordered_by_stmt\",\n  \"ordered_by_arg_str\", \"must_agr_str\", \"must_stmt\", \"must_end\",\n  \"unique_arg\", \"unique_stmt\", \"unique_arg_str\", \"key_arg\", \"key_stmt\",\n  \"key_arg_str\", \"$@3\", \"range_arg_str\", \"absolute_schema_nodeid\",\n  \"absolute_schema_nodeids\", \"absolute_schema_nodeid_opt\",\n  \"descendant_schema_nodeid\", \"$@4\", \"path_arg_str\", \"$@5\", \"$@6\",\n  \"absolute_path\", \"absolute_paths\", \"absolute_path_opt\", \"relative_path\",\n  \"relative_path_part1\", \"relative_path_part1_opt\", \"descendant_path\",\n  \"descendant_path_opt\", \"path_predicate\", \"path_equality_expr\",\n  \"path_key_expr\", \"rel_path_keyexpr\", \"rel_path_keyexpr_part1\",\n  \"rel_path_keyexpr_part1_opt\", \"rel_path_keyexpr_part2\",\n  \"current_function_invocation\", \"positive_integer_value\",\n  \"non_negative_integer_value\", \"integer_value\", \"integer_value_convert\",\n  \"prefix_arg_str\", \"identifier_arg_str\", \"node_identifier\",\n  \"identifier_ref_arg_str\", \"stmtend\", \"semicolom\", \"curly_bracket_close\",\n  \"curly_bracket_open\", \"stmtsep\", \"unknown_statement\", \"string_opt\",\n  \"string_opt_part1\", \"string_opt_part2\", \"unknown_string\",\n  \"unknown_string_part1\", \"unknown_string_part2\", \"unknown_statement_end\",\n  \"unknown_statement2_opt\", \"unknown_statement2\", \"unknown_statement2_end\",\n  \"unknown_statement2_yang_stmt\", \"unknown_statement2_module_stmt\",\n  \"unknown_statement3_opt\", \"unknown_statement3_opt_end\", \"sep_stmt\",\n  \"optsep\", \"sep\", \"whitespace_opt\", \"string\", \"$@7\", \"strings\",\n  \"identifier\", \"identifier1\", \"yang_stmt\", \"identifiers\",\n  \"identifiers_ref\", \"type_ext_alloc\", \"typedef_ext_alloc\",\n  \"iffeature_ext_alloc\", \"restriction_ext_alloc\", \"when_ext_alloc\",\n  \"revision_ext_alloc\", \"datadef_ext_check\", \"not_supported_ext_check\",\n  \"not_supported_ext\", \"datadef_ext_stmt\", \"restriction_ext_stmt\",\n  \"ext_substatements\", YY_NULLPTR\n};\n#endif\n\n# ifdef YYPRINT\n/* YYTOKNUM[NUM] -- (External) token number corresponding to the\n   (internal) symbol number NUM (which must be that of a token).  */\nstatic const yytype_uint16 yytoknum[] =\n{\n       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,\n     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,\n     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,\n     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,\n     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,\n     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,\n     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,\n     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,\n     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,\n     345,   346,   347,   348,   349,   350,   351,   352,   353,   354,\n     355,   356,   357,    43,   123,   125,    59,    47,    91,    93,\n      61,    40,    41\n};\n# endif\n\n#define YYPACT_NINF -1012\n\n#define yypact_value_is_default(Yystate) \\\n  (!!((Yystate) == (-1012)))\n\n#define YYTABLE_NINF -757\n\n#define yytable_value_is_error(Yytable_value) \\\n  0\n\n  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing\n     STATE-NUM.  */\nstatic const yytype_int16 yypact[] =\n{\n     440,   100, -1012, -1012,   566,  1894, -1012, -1012, -1012,   266,\n     266, -1012,   266, -1012,   266,   266, -1012,   266,   266,   266,\n     266, -1012,   266,   266, -1012, -1012, -1012, -1012,   266, -1012,\n   -1012, -1012,   266,   266,   266,   266,   266,   266,   266,   266,\n     266,   266,   266,   266,   266,   266,   266,   266,   266,   266,\n   -1012, -1012,   266, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,    -8,    31,    79,   868,    70,   125,   481,\n     266, -1012, -1012,  3273,  3273,  3273,  2893,  3273,    71,  2703,\n    2703,  2703,  2703,  2703,    98,  2988,    94,    52,   287,  2703,\n      77,  2703,   104,   287,  3273,  2703,  2703,   182,    58,   246,\n    2988,  2703,   321,  2703,   279,   279,   266, -1012,   266, -1012,\n     266, -1012,   266,   266,   266,   266, -1012, -1012, -1012, -1012,\n   -1012,   266, -1012,   266, -1012,   266,   266,   266,   266,   266,\n   -1012,   266,   266,   266,   266, -1012,   266,   266,   266, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n      29, -1012,   134, -1012, -1012, -1012,   -22,  2798,   266, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   151, -1012, -1012, -1012, -1012, -1012,   156,\n   -1012,    67, -1012, -1012, -1012,   224, -1012, -1012, -1012,   161,\n   -1012, -1012, -1012, -1012,   224, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   224, -1012, -1012, -1012,   224, -1012,   224,\n   -1012,   224, -1012,   224, -1012, -1012, -1012,   224, -1012, -1012,\n   -1012, -1012,   224, -1012, -1012, -1012, -1012, -1012, -1012,   224,\n   -1012, -1012, -1012,   224, -1012, -1012, -1012, -1012,   224, -1012,\n   -1012, -1012,   224, -1012, -1012, -1012, -1012,   224, -1012,   224,\n   -1012, -1012,   224, -1012,   262,   202, -1012,   224, -1012, -1012,\n   -1012,   224, -1012, -1012,   224, -1012,   224, -1012, -1012, -1012,\n   -1012,   224, -1012, -1012, -1012,   224, -1012, -1012, -1012, -1012,\n   -1012,   224, -1012, -1012,   224, -1012, -1012, -1012,   224, -1012,\n   -1012, -1012, -1012, -1012,   224, -1012, -1012, -1012,   224, -1012,\n   -1012, -1012, -1012,  2893,   279,  3273,   279,  2703,   279,  2703,\n    2703,  2703, -1012,  2703,   279,  2703,   279,    58,   279,  3273,\n    3273,  3273,  3273,  3273,   266,  3273,  3273,  3273,  3273,   266,\n    2893,  3273,  3273, -1012, -1012,   279, -1012, -1012, -1012, -1012,\n   -1012, -1012,   266, -1012,   266, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012,   266,   266, -1012,   266,   266, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,   266, -1012, -1012,\n     266,   266, -1012,   266, -1012,   266, -1012,   266, -1012,   266,\n     266, -1012, -1012, -1012,  3368, -1012, -1012,   291, -1012, -1012,\n   -1012,   266, -1012,   266, -1012, -1012,   266,   266, -1012, -1012,\n   -1012,   266,   266,   266, -1012, -1012,   266, -1012, -1012, -1012,\n     266, -1012,   228,  2703,   266,   274, -1012,   189, -1012,   288,\n   -1012,   298, -1012,   303, -1012,   370, -1012,   380, -1012,   389,\n   -1012,   393, -1012,   407, -1012,   411, -1012,   419, -1012,   426,\n   -1012,   463, -1012,   238, -1012,   314, -1012,   317, -1012,   505,\n   -1012,   506, -1012,   521, -1012,   407, -1012,   279,   279,   266,\n     266,   266,   266,   326,   279,   279,   109,   279,   112,   608,\n     266,   266, -1012,   262, -1012,  3083,   266,   332, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012,  1964,  1994,  2191,   347,\n   -1012, -1012,    19, -1012,    54,   266,   355, -1012, -1012,   368,\n     373, -1012, -1012, -1012,    48,  3368, -1012,   266,   831,   279,\n     186,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   266, -1012,   127,   515,   266, -1012, -1012,\n   -1012,   515, -1012, -1012,   188, -1012,   279, -1012,   473, -1012,\n     306, -1012,  2552,   266,   266,   397,  1000, -1012, -1012, -1012,\n   -1012,   783, -1012,   230,   503,   404,   887,   359,   438,   929,\n    1958,  1645,   817,   947,   344,  2074,  1547,  1768,   235,   852,\n     279,   279,   279,   279,   266,   -22,   280, -1012,   266,   266,\n   -1012, -1012,   375,  2703,   375,   279, -1012, -1012, -1012,   224,\n   -1012, -1012,  3368, -1012, -1012, -1012, -1012, -1012,   266,   266,\n   -1012,  3273,  2703, -1012, -1012, -1012,    -8, -1012, -1012, -1012,\n   -1012, -1012, -1012,   279,   474, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012,   266,   266, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012,  3273,  3273,   279,   279, -1012, -1012,\n   -1012, -1012, -1012,   125,   224, -1012, -1012,   266,   266, -1012,\n     399,   473,   266,   528,   528,   545, -1012,   567, -1012,   279,\n   -1012,   279,   279,   279,   480, -1012,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n    2988,  2988,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   266,   266,   423, -1012,   570, -1012,   428,  2046, -1012,\n   -1012,   434, -1012,   465, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,   479, -1012, -1012,\n   -1012,   571, -1012, -1012, -1012, -1012, -1012, -1012,   266,   266,\n     266,   266,   266,   266, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012,   279, -1012,   473,   266,   279,\n     279,   279,   279, -1012,   266, -1012, -1012, -1012,   266,   279,\n     279,   266,    51,  3273,    51,  3273,  3273,  3273,   279,   266,\n     459,  2367,   385,   509,   279,   279,   341,   365, -1012, -1012,\n     483, -1012, -1012,   574, -1012, -1012,   486, -1012, -1012,   591,\n   -1012,   592, -1012,   521, -1012,   473, -1012,   473, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012,   885,  1126, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   332,   266, -1012, -1012, -1012, -1012,   266,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,   467,   492,   279,\n     279, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012,   279,   279,   279,   279,   279,   473,   473,   279,\n     279,   279,   279,   279,   279,   279,   279,  1460,   205,   524,\n     216,   201,   493,   579, -1012, -1012, -1012, -1012, -1012, -1012,\n     266, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012,   473, -1012, -1012,   279,\n     293,   279,   279,   497,  3178, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,   473,\n   -1012, -1012,   279,    73,   120,   133,   163, -1012,    50, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012,   510,   222,   279,   279,   279,   473, -1012,   824,   346,\n     985,  3368, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012,   279,   279,   279\n};\n\n  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.\n     Performed when YYTABLE does not specify something else to do.  Zero\n     means the default is an error.  */\nstatic const yytype_uint16 yydefact[] =\n{\n     790,     0,     2,     3,     0,   757,     1,   649,   650,     0,\n       0,   652,     0,   763,     0,     0,   761,     0,     0,     0,\n       0,   762,     0,     0,   766,   764,   765,   767,     0,   768,\n     769,   770,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n     759,   760,     0,   771,   802,   806,   619,   792,   803,   797,\n     793,   794,   619,   809,   796,   815,   814,   819,   804,   813,\n     818,   799,   800,   795,   798,   810,   811,   805,   816,   817,\n     812,   820,   801,     0,     0,     0,     0,     0,     0,     0,\n     627,   758,   651,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,   571,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,   791,   822,     0,   619,     0,   619,\n       0,   619,     0,     0,     0,     0,   789,   787,   788,   786,\n     619,     0,   619,     0,   619,     0,     0,     0,     0,     0,\n     651,     0,     0,     0,     0,   651,     0,     0,     0,   778,\n     777,   780,   781,   782,   776,   775,   774,   773,   785,   772,\n       0,   779,     0,   784,   783,   619,     0,   629,   653,   679,\n       5,   669,   680,   681,   682,   683,   684,   685,   686,   687,\n     688,   689,   690,   691,   692,   693,   694,   695,   696,   697,\n     698,   699,   700,   701,   702,   703,   704,   705,   706,   707,\n     708,   709,   710,   711,   712,   713,   666,   714,   715,   716,\n     717,   718,   719,   720,   721,   722,   723,   724,   725,   726,\n     727,   728,   729,   730,   731,   732,   733,   734,   735,   736,\n     737,   738,   739,   740,   741,   742,   743,   670,   744,   671,\n     672,   673,   674,   745,   675,   676,   677,   678,   746,   747,\n     748,   651,   608,     0,    10,   749,   667,   668,   651,     0,\n      17,     0,    99,   750,   613,     0,   138,   651,   651,     0,\n      47,   651,   651,   529,     0,   525,   659,   662,   660,   664,\n     665,   663,   658,     0,    58,   656,   661,     0,   243,     0,\n      60,     0,   239,     0,   237,   598,   170,     0,   167,   651,\n     610,   563,     0,   559,   561,   609,   651,   651,   534,     0,\n     530,   651,   545,     0,   541,   651,   599,   540,     0,   537,\n     600,   651,     0,    25,   651,   651,   550,     0,   546,     0,\n      56,   575,     0,   213,     0,     0,   236,     0,   233,   651,\n     605,     0,    49,   651,     0,   535,     0,    62,   651,   651,\n     219,     0,   215,    74,    76,     0,    45,   651,   651,   651,\n     114,     0,   109,   558,     0,   555,   651,   569,     0,   241,\n     603,   604,   601,   209,     0,   206,   651,   602,     0,   191,\n     621,   620,   651,     0,   807,     0,   808,     0,   821,     0,\n       0,     0,   180,     0,   823,     0,   824,     0,   825,     0,\n       0,     0,     0,     0,   445,     0,     0,     0,     0,   452,\n       0,     0,     0,   619,   619,   826,   651,   651,   827,   651,\n     628,   651,     7,   619,   607,   619,   619,   101,   100,   618,\n     616,   139,   619,   619,   611,   612,   619,   528,   527,   526,\n      59,   651,   244,    61,   240,   238,   168,   169,   560,   651,\n     533,   532,   531,   543,   542,   544,   538,   539,    26,   549,\n     548,   547,    57,   214,     0,   578,   572,     0,   574,   582,\n     234,   235,    50,   606,   536,    63,   218,   217,   216,   651,\n      46,   111,   113,   112,   110,   556,   557,   567,   242,   207,\n     208,   192,     0,   625,   624,     0,   150,     0,   140,     0,\n     124,     0,   172,     0,   551,     0,   182,     0,   564,     0,\n     518,     0,    65,     0,   368,     0,   357,     0,   334,     0,\n     266,     0,   245,     0,   285,     0,   298,     0,   314,     0,\n     454,     0,   383,     0,   430,     0,   370,   447,   447,   645,\n     647,   632,   630,     6,    13,    20,   104,   614,     0,     0,\n     657,   562,   587,   577,   581,     0,    75,   570,   651,   634,\n     622,   623,   626,   619,   151,   149,   619,   619,   126,   125,\n     619,   173,   171,   619,   553,   552,   619,   183,   181,   619,\n     211,   210,   619,   520,   519,   619,    69,    68,   619,   372,\n     369,   619,   359,   358,   619,   336,   335,   619,   268,   267,\n     619,   247,   246,   619,   619,   619,   619,   456,   455,   619,\n     385,   384,   619,   434,   431,   371,     0,     0,     0,   631,\n     651,    27,    12,    27,    19,     0,     0,   617,   619,     0,\n     576,   579,   583,   580,   585,     0,   568,   636,   156,   142,\n       0,   175,   175,   185,   175,   522,    71,   374,   361,   338,\n     270,   249,   286,   300,   316,   458,   387,   436,   446,   619,\n     619,   619,   258,   259,   260,   261,   262,   263,   264,   265,\n     619,   453,   651,   627,   651,     0,    51,     0,    14,    15,\n      16,    51,    21,   619,     0,   102,   615,    48,   654,   584,\n       0,   565,     0,     0,     0,     0,   153,   154,   619,   155,\n     221,     0,   127,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n     449,   450,   451,   448,   648,     0,     0,     8,     0,     0,\n     619,   619,    66,     0,    66,    22,   651,   651,   108,     0,\n     103,   655,     0,   586,   644,   635,   638,   651,   627,   627,\n     643,     0,     0,   152,   159,   619,     0,   162,   619,   619,\n     619,   158,   157,   194,   220,   141,   147,   148,   146,   619,\n     144,   145,   174,   178,   179,   176,   177,   554,   184,   189,\n     190,   186,   187,   188,   212,   521,   523,   524,    70,    72,\n      73,   373,   381,   382,   380,   619,   619,   378,   379,   619,\n     360,   365,   366,   364,   619,   619,   619,   337,   345,   346,\n     344,   619,   341,   350,   351,   352,   353,   356,   619,   348,\n     349,   354,   355,   619,   342,   343,   269,   277,   278,   276,\n     619,   619,   619,   619,   619,   619,   619,   275,   274,   619,\n     248,   251,   252,   250,   619,   619,   619,   619,   619,   284,\n     296,   297,   295,   619,   619,   290,   292,   619,   293,   294,\n     619,   299,   312,   313,   311,   619,   619,   305,   304,   619,\n     307,   308,   309,   310,   619,   315,   327,   328,   326,   619,\n     619,   619,   619,   619,   619,   619,   322,   323,   324,   325,\n     619,   321,   320,   457,   462,   463,   461,   619,   619,   619,\n     619,   619,     0,     0,   386,   391,   392,   390,   619,   619,\n     619,   619,   435,   439,   440,   438,   619,   619,   619,   619,\n     619,   646,   651,   651,     0,     0,    28,    29,    52,    53,\n      54,    55,    78,    64,     0,    23,    78,   107,   106,   105,\n       0,   654,   637,     0,     0,     0,   224,     0,   197,   164,\n     165,   160,   161,   163,   193,   222,   143,   376,   375,   377,\n     363,   367,   362,   340,   347,   339,   272,   282,   279,   283,\n     280,   281,   271,   273,   254,   253,   255,   256,   257,   288,\n     289,   287,   291,   302,   303,   301,   306,   318,   329,   330,\n     333,   331,   332,   317,   319,   460,   464,   465,   466,   459,\n       0,     0,   389,   393,   394,   388,   437,   441,   442,   443,\n     444,   633,     9,     0,    31,     0,    37,     0,    77,   619,\n      24,     0,   588,     0,   651,   641,   639,   640,   619,   225,\n     619,   619,   198,   196,   619,   413,   414,     0,   651,   396,\n     397,     0,   651,   619,   619,    39,    38,   651,     0,     0,\n       0,     0,     0,     0,   619,    80,    81,    82,    83,    84,\n      85,    86,    87,    88,    89,    67,   651,   654,   645,   227,\n     223,   200,   195,   619,   412,   619,   399,   398,   395,    32,\n      41,    11,     0,     0,     0,     0,     0,     0,    79,    18,\n       0,     0,     0,     0,   420,   401,     0,     0,   417,   418,\n       0,   567,   651,     0,    90,   474,     0,   467,   651,     0,\n     115,     0,   128,     0,   432,   654,   589,   654,   642,   226,\n     231,   232,   230,   619,   229,   199,   204,   205,   203,   619,\n     202,     0,     0,    30,    36,    33,    34,    35,    40,    44,\n      42,    43,   619,   566,   416,   619,    92,    91,   619,   473,\n     619,   117,   116,   619,   130,   129,   433,     0,     0,   228,\n     201,   415,   424,   425,   423,   619,   619,   619,   619,   619,\n     619,   400,   410,   411,   619,   405,   406,   407,   404,   408,\n     409,   619,   420,    94,   469,   119,   132,   654,   654,   422,\n     426,   429,   427,   428,   421,   403,   402,     0,     0,     0,\n       0,     0,     0,     0,   419,    93,    97,    98,   619,    96,\n       0,   468,   470,   471,   118,   122,   123,   121,   619,   131,\n     136,   137,   135,   619,   133,   597,   654,   590,   593,    95,\n       0,   120,   134,     0,     0,   484,   497,   477,   506,   619,\n     651,   475,   476,   651,   481,   651,   483,   651,   482,   654,\n     594,   595,   472,     0,     0,     0,     0,   592,   591,   619,\n     479,   478,   619,   486,   485,   619,   499,   498,   619,   508,\n     507,     0,     0,   488,   501,   510,   654,   480,     0,     0,\n       0,     0,   487,   489,   492,   493,   494,   495,   496,   619,\n     491,   500,   502,   505,   619,   504,   509,   619,   512,   513,\n     514,   515,   516,   517,   596,   490,   503,   511\n};\n\n  /* YYPGOTO[NTERM-NUM].  */\nstatic const yytype_int16 yypgoto[] =\n{\n   -1012, -1012, -1012,   245, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012,   -16, -1012,    -2,    -9, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1011, -1012,    22,\n   -1012,  -534,   -24, -1012,   658, -1012,   681, -1012,    63, -1012,\n     105,   -41, -1012, -1012,  -237, -1012, -1012,   305, -1012,  -225,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,  -486, -1012, -1012,\n   -1012, -1012, -1012,    41, -1012, -1012, -1012, -1012, -1012, -1012,\n     -11, -1012, -1012, -1012, -1012, -1012, -1012,  -657, -1012,    -3,\n   -1012,  -653, -1012, -1012, -1012, -1012, -1012, -1012, -1012,    23,\n   -1012,    30, -1012, -1012,    53, -1012,    35, -1012, -1012, -1012,\n   -1012,    10, -1012, -1012,  -236, -1012, -1012, -1012, -1012,  -366,\n   -1012,    38, -1012, -1012,    40, -1012,    43, -1012, -1012, -1012,\n     -21, -1012, -1012, -1012, -1012,  -355, -1012, -1012,    12, -1012,\n      18, -1012,  -704, -1012,  -480, -1012,    16, -1012, -1012,  -560,\n   -1012,   -80, -1012, -1012,   -67, -1012, -1012, -1012,   -63, -1012,\n   -1012,   -39, -1012, -1012,   -36, -1012, -1012, -1012, -1012, -1012,\n     -33, -1012, -1012, -1012,   -28, -1012,   -27,   206, -1012, -1012,\n     667, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012,  -435, -1012,   -62, -1012, -1012,  -365,\n   -1012, -1012,    42,   211, -1012,    44, -1012,   -87, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012,    74, -1012, -1012, -1012,  -473, -1012, -1012,  -667,\n   -1012, -1012,  -675, -1012,  -722, -1012, -1012,  -662, -1012, -1012,\n    -271, -1012, -1012,   -35, -1012, -1012,  -725, -1012, -1012,    46,\n   -1012, -1012, -1012,  -390,  -319,  -335,  -461, -1012, -1012, -1012,\n   -1012,   214,    97, -1012, -1012,   239, -1012, -1012, -1012,   135,\n   -1012, -1012, -1012,  -441, -1012, -1012, -1012,   155,   693, -1012,\n   -1012, -1012,   185,   -93,  -328,  1164, -1012, -1012, -1012,   526,\n     110, -1012, -1012, -1012,  -433, -1012, -1012, -1012, -1012, -1012,\n    -143, -1012, -1012,  -260,    84,    -4,  1453,   166,  -694,   119,\n   -1012,   660,   -12, -1012,   137,   -20,   -23, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012\n};\n\n  /* YYDEFGOTO[NTERM-NUM].  */\nstatic const yytype_int16 yydefgoto[] =\n{\n      -1,     1,   261,   262,   553,   933,   263,     2,   631,   632,\n     269,     3,   633,   634,   944,   688,   332,    54,   686,   740,\n    1023,  1106,  1025,   741,  1056,  1107,   365,    55,   279,    56,\n     351,    57,   742,   339,   938,   293,   939,   299,   783,   356,\n     784,   942,   521,   943,   144,   597,   718,   366,   489,  1027,\n    1028,  1064,  1113,  1065,  1157,  1208,   271,    62,   438,   749,\n     636,   750,   371,  1174,   372,  1119,  1066,  1162,  1210,   509,\n    1175,   579,  1121,  1067,  1165,  1211,   275,    64,   507,   669,\n     711,   127,   505,   575,   705,   706,   765,   766,   307,    65,\n     308,   136,   511,   582,   713,   401,   137,   515,   588,   715,\n     388,    66,   707,   964,   708,   957,  1043,  1103,   384,    67,\n     385,   138,   591,   342,    68,   361,    69,   362,   709,   774,\n     710,   955,  1040,  1102,   347,    70,   348,   303,   785,   301,\n     786,   378,    73,   297,    74,   531,   670,   612,   723,   671,\n     529,   672,   609,   722,   673,   533,   724,   535,   674,   725,\n     537,   675,   726,   527,   676,   606,   721,   828,   829,   525,\n    1177,   603,   720,   523,   677,   545,   678,   600,   719,   541,\n     679,   621,   728,  1050,  1051,   919,  1087,  1142,  1046,  1047,\n     920,  1109,  1110,  1071,  1141,   543,  1178,  1123,  1072,   624,\n     729,   170,   171,   626,   172,   173,   539,  1179,   618,   727,\n    1116,  1074,  1209,  1117,  1249,  1250,  1251,  1271,  1252,  1253,\n    1254,  1274,  1288,  1255,  1256,  1277,  1289,  1257,  1258,  1280,\n    1290,   519,  1180,   594,   717,   284,    75,   285,   319,    76,\n     320,   354,    77,   328,    78,   329,   323,    79,   324,   337,\n      80,   338,   513,   680,   585,   374,    81,   375,   312,    82,\n     313,   459,   517,   646,  1112,   567,   376,   497,   343,   344,\n     345,   475,   476,   563,   478,   479,   565,   643,   699,   640,\n     950,  1126,  1237,  1238,  1244,  1268,  1127,   330,   331,   386,\n     387,   352,   264,   377,   276,   441,   442,   638,   443,   124,\n     390,   502,   503,   571,   176,   430,   629,   570,   702,   757,\n    1036,   758,   759,   628,   428,   391,     4,   177,   752,   294,\n     451,   295,   265,   266,   267,   268,   392,    83,    84,    85,\n      86,    87,    88,    89,    90,    91,   175,   140,     5\n};\n\n  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If\n     positive, shift that token.  If negative, reduce the rule whose\n     number is the opposite.  If YYTABLE_NINF, syntax error.  */\nstatic const yytype_int16 yytable[] =\n{\n      11,   901,   174,   881,   897,    92,    92,   780,    92,   160,\n      92,    92,   314,    92,    92,    92,    92,    71,    92,    92,\n     865,   877,   161,    72,    92,   639,   162,   169,    92,    92,\n      92,    92,    92,    92,    92,    92,    92,    92,    92,    92,\n      92,    92,    92,    92,    92,    92,    63,   848,    92,   764,\n     163,   139,   808,   164,   835,   751,   165,   869,   779,   180,\n     180,   166,   167,   882,   898,   506,   180,   126,    60,   305,\n     363,   864,   876,   278,   131,    36,   277,    15,     7,   180,\n       8,   129,   426,    41,   427,   180,    92,   296,   296,   296,\n     296,   296,   542,   315,   353,  1144,  1149,   296,   690,   296,\n       6,   687,   180,   296,   296,   159,   180,   128,   315,   296,\n      61,   296,   180,   960,     7,   305,     8,     7,  -573,     8,\n     273,   130,    92,   273,    92,     7,    92,     8,    92,    92,\n      92,    92,     7,   423,     8,   737,   687,    92,     7,    92,\n       8,    92,    92,    92,    92,    92,   321,    92,    92,    92,\n      92,   141,    92,    92,    92,  -587,  -587,  -654,   645,   281,\n     815,   142,   843,   856,   282,   296,   892,   910,     7,   334,\n       8,   436,   335,   437,    11,    93,    94,  1269,    95,  1270,\n      96,    97,   316,    98,    99,   100,   101,   317,   102,   103,\n     180,     7,   635,     8,   104,   143,   180,   273,   105,   106,\n     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,\n     117,   118,   119,   120,   121,   122,   477,   637,   123,   298,\n     300,   302,   304,    14,  1272,    12,  1273,     7,   333,     8,\n     340,   781,    20,   273,   355,   357,    20,  1275,   424,  1276,\n     379,   822,   389,   130,   866,   878,   807,    20,   834,   847,\n     735,   868,   880,   896,   180,   433,   912,  1033,   130,   309,\n     435,    20,   325,    22,    23,   446,    20,  1278,    43,  1279,\n     358,     7,    43,     8,    46,   359,   746,   130,    46,   270,\n     272,   747,   280,    43,     7,     7,     8,     8,   932,    46,\n     273,   712,   393,   576,   395,   180,   397,    43,   399,   400,\n     402,   403,    43,   913,   305,   326,  1229,   405,    46,   407,\n    1215,   409,   410,   411,   412,   413,   141,   415,   416,   417,\n     418,  1224,   420,   421,   422,   953,   954,  1287,   439,   180,\n     440,   367,   568,   368,   569,   782,   369,   380,   381,   382,\n     914,   274,   613,   283,   292,   292,   292,   292,   292,   306,\n     311,   318,   322,   327,   292,   336,   292,   341,   346,   350,\n     292,   292,   360,   364,   370,   373,   292,   383,   292,   474,\n     278,    17,    20,   277,    19,    20,    19,  1245,   573,  1246,\n     574,   562,  1247,  1100,  1248,   296,   130,   296,   296,   296,\n      20,   296,   577,   296,   578,    33,    20,   278,   564,   133,\n     277,   133,   580,    18,   581,    41,    20,   583,    43,   584,\n      11,    43,    45,   474,   698,    11,    20,    46,   614,   126,\n    1189,   615,    48,    47,    48,   141,    43,   130,    11,   630,\n      11,  1167,    43,  1168,    38,    20,    45,    22,    23,   645,\n      11,    11,    43,    11,    11,  -651,  1143,  -651,    40,   859,\n     684,  1301,    43,    11,   883,   899,    11,    11,    46,    11,\n     695,    11,   315,    11,   795,    11,    11,  1188,  1070,    20,\n    1148,    43,   644,   697,   586,  1187,   587,    11,   751,    11,\n    1190,   698,    11,    11,   589,   145,   590,    11,    11,    11,\n    1129,   296,    11,   592,  -651,   593,    11,   595,   703,   596,\n      11,    52,   763,  1212,  1213,    43,   146,   147,  1032,   788,\n     148,   598,   704,   599,  -651,   601,   510,   602,   512,   514,\n     516,   149,   518,   604,   520,   605,   150,  1053,   151,   152,\n     607,   153,   608,  1057,    20,   683,    22,    23,   154,  1076,\n      20,   155,  1243,   798,  1125,    11,    11,    11,    11,  1048,\n    1052,   130,   701,   315,  1234,    20,    11,    11,   738,   739,\n     156,  1220,    11,  1300,  1305,  1267,  1297,   610,  1312,   611,\n      43,     7,  1145,     8,  1281,  1077,    43,   157,  1197,   158,\n     508,  1176,    46,  1083,  1293,  1302,  1308,  1152,   125,    49,\n    1158,    43,  1291,  1236,   524,   526,   528,   530,   532,  1198,\n     534,   536,   538,   540,  1259,  1235,   544,   546,   787,   616,\n     619,   617,   620,     7,  1135,     8,   315,  1286,   692,   273,\n       9,  1296,   572,  1311,   691,   622,  1298,   623,  1313,  1221,\n     689,    92,  1034,   315,  1035,   845,   858,  1307,   274,   894,\n      10,   823,   292,    11,   292,   292,   292,  1176,   292,  1038,\n     292,  1039,   364,   394,   824,   396,   693,   398,   825,   951,\n     844,   857,  1185,    58,   893,   274,   404,   744,   406,  1186,\n     408,  1041,    41,  1042,  1054,  1085,  1055,  1086,  1155,    92,\n    1156,    11,   826,    92,   809,   827,    59,   849,   830,   870,\n     884,   900,   911,   831,   832,  1160,  1163,  1161,  1164,    92,\n      92,   425,  1111,   946,  1111,   714,  1029,   716,   805,   814,\n     821,   840,   522,   863,   875,   889,   907,   918,   926,   841,\n     854,  1031,  1218,   890,   908,   791,   927,   792,  1044,   767,\n      11,   296,    11,   793,    92,    92,   768,  1140,   842,   855,\n     315,   769,   891,   909,   770,   928,   771,  1134,   292,   772,\n     296,   625,   778,   965,    92,    92,   168,  1207,  1166,   627,\n     804,   813,   820,   839,   853,   862,   874,   888,   906,   917,\n     925,   929,   902,   930,   776,  1118,  1153,   641,   789,   700,\n     796,   799,   802,   811,   818,   837,   851,   860,   872,   886,\n     904,   915,   923,   806,   816,   833,   846,   753,   867,   879,\n     895,   694,   921,  1260,   642,   940,   349,   940,  1294,  1303,\n    1309,  1037,   756,    19,    20,  1295,   777,  1310,  1101,   931,\n     790,   145,   797,   800,   803,   812,   819,   838,   852,   861,\n     873,   887,   905,   916,   924,     0,     7,   431,     8,   760,\n       0,     0,   273,   147,    17,     0,   148,   941,    20,   941,\n      43,    17,     0,   743,    19,   703,    46,   149,   126,   130,\n       0,    48,   945,   704,   151,   152,     0,   153,     0,   761,\n     762,     0,   133,     0,   154,    33,    34,    35,     0,   133,\n       0,   958,    42,    20,    43,     0,     0,     0,   775,   145,\n      46,     0,   149,   128,   130,     0,   156,   150,   141,     0,\n       0,    47,    48,     0,   934,   935,     0,     0,    92,    92,\n     146,   147,   155,   157,   148,   158,    20,   132,    20,    43,\n      22,    23,   836,   133,     0,    46,     0,   130,   128,  1292,\n     134,     0,   151,   152,   135,   153,     0,     0,     0,   748,\n       0,  1073,   154,    11,    11,     0,   956,     0,    11,   547,\n     548,   145,    43,     0,    43,     0,    17,   922,    46,   554,\n      20,   555,   556,     0,   156,     0,   141,     0,   557,   558,\n       0,   130,   559,   147,     0,     0,   148,     0,    20,     0,\n      33,   157,     0,   158,   133,     0,     0,   149,   292,     0,\n    1171,     0,   794,     0,   151,   152,    43,   153,   315,   315,\n       0,     0,    46,     0,   154,     0,     0,   292,   683,     0,\n     141,     0,    17,     0,    43,    19,     0,    11,    11,     0,\n      46,     0,    14,   128,     0,  1068,   156,     0,     0,     0,\n       0,     0,     0,     0,   801,     0,    33,    34,    35,    28,\n       0,     0,     0,   157,  1069,   158,     0,     0,     0,   132,\n       0,     0,   850,     0,    92,    92,    92,    92,    92,    92,\n     126,    39,   134,    48,     0,     0,   135,     0,     0,    44,\n       0,     0,     0,     0,    11,  -166,     0,     0,  1010,  1011,\n      11,     0,     0,     0,    11,     0,     0,    11,     0,   315,\n    1306,  1133,  1139,     0,     0,    11,     0,     0,     0,   648,\n       0,     0,   649,   650,     0,     0,   651,  1191,     0,   652,\n       0,     0,   653,     0,     0,   654,     0,     0,   655,  1024,\n    1026,   656,     0,     0,   657,     0,     0,   658,     0,     0,\n     659,  1184,     0,   660,     0,     0,   661,     0,     0,   662,\n     663,   664,   665,  1132,  1138,   666,     0,     0,   667,     0,\n      11,  1261,     0,    17,     0,    11,    19,    20,     0,     0,\n       0,     0,     0,     0,   696,  1130,  1136,     0,   130,  1146,\n    1150,     0,     0,     0,     0,     0,     0,    33,    34,    35,\n       0,   133,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,    42,     0,    43,     0,   730,   731,   732,  1314,  1228,\n    1233,     0,     0,     0,  1172,  1182,   733,  1131,  1137,     0,\n       0,  1147,  1151,     0,     0,     0,    92,     0,     0,   745,\n       0,     0,     0,     0,  1092,  1093,  1094,  1095,  1096,  1097,\n       0,  1181,   315,     0,   773,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,  1173,  1183,     0,  1219,\n       0,  1227,  1232,  1299,  1304,  1045,  1049,     0,     0,    11,\n      11,    11,    11,     0,     0,     0,   936,   937,     0,     0,\n    1172,  1216,  1222,  1225,  1230,     0,     0,     0,  1114,   315,\n    1120,  1122,  1124,     0,     0,     0,     0,     0,     0,     0,\n       0,   959,     0,     0,   961,   962,   963,     0,     0,     0,\n       0,     0,     0,     0,     0,   966,     0,     0,     0,     0,\n       0,     0,  1173,  1217,  1223,  1226,  1231,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,   967,   968,     0,     0,   969,     0,  1108,     0,  1115,\n     970,   971,   972,     0,     0,     0,     0,   973,     0,     0,\n       0,     0,     0,     0,   974,     0,     0,     0,     0,   975,\n       0,     0,     0,     0,     0,     0,   976,   977,   978,   979,\n     980,   981,   982,     0,     0,   983,     0,     0,     0,     0,\n     984,   985,   986,   987,   988,     0,  1240,     0,     0,   989,\n     990,     0,     0,   991,     0,     0,   992,     0,     0,     0,\n       0,   993,   994,     0,     0,   995,     0,     0,     0,     0,\n     996,     0,     0,     0,     0,   997,   998,   999,  1000,  1001,\n    1002,  1003,     0,     0,     0,     0,  1004,     0,     0,     0,\n       0,     0,     0,  1005,  1006,  1007,  1008,  1009,     0,     0,\n       0,     0,     0,     0,  1012,  1013,  1014,  1015,   449,     0,\n       0,     0,  1016,  1017,  1018,  1019,  1020,   450,     0,     0,\n       0,   452,     0,   453,   145,   454,     0,   455,     0,     0,\n       0,   456,     0,     0,     0,     0,   458,     0,     0,     0,\n       0,     0,     0,   462,     0,   146,   147,   464,     0,   148,\n       0,    20,   466,     0,     0,     0,   468,     0,     0,     0,\n       0,   471,   130,   472,     0,     0,   473,   151,   152,     0,\n     153,   480,     0,     0,     0,   482,     0,   154,   484,     0,\n     485,     0,     0,     0,     0,   488,     0,    43,     0,   490,\n       0,     0,     0,    46,     0,   494,     0,     0,   495,   156,\n       0,   141,   498,     0,     0,   178,     0,     0,   499,     0,\n       0,   145,   501,     0,     0,  1075,   157,     0,   158,     0,\n       0,     0,     0,     0,  1079,  1214,  1080,  1081,     0,     0,\n    1082,     0,     0,   147,    17,     0,   148,     0,    20,  1089,\n    1090,     0,     0,     0,     0,     0,     0,   149,     0,   130,\n    1098,     0,     0,    32,   151,   152,     0,   153,     0,    34,\n      35,     0,   133,   414,   154,    37,     0,     0,   419,  1104,\n       0,  1105,     0,     0,    43,     0,     0,     0,     0,     0,\n      46,     0,     0,   128,    47,     0,   156,     0,   141,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,   157,     0,   158,     0,     0,     0,   145,\n       0,     0,   885,     0,     0,     0,     0,     0,     0,  1169,\n       0,     0,     0,     0,     0,  1170,     0,     0,     0,     0,\n     146,   147,    17,     0,   148,    19,    20,     0,  1192,     0,\n       0,  1193,     0,     0,  1194,     0,  1195,   130,     0,  1196,\n       0,     0,   151,   152,     0,   153,    33,     0,     0,     0,\n       0,  1199,  1200,  1201,  1202,  1203,  1204,     0,     0,     0,\n    1205,     0,    43,     0,   432,     0,     0,  1206,    46,     0,\n       0,   434,     0,     0,     0,     0,   141,     0,     0,     0,\n     444,   445,     0,     0,   447,   448,     0,     0,     0,     0,\n       0,     0,     0,   158,  1239,     0,     0,     0,     0,     0,\n     817,     0,     0,     0,  1241,     0,     0,     0,     0,  1242,\n       0,     0,   457,     0,     0,     0,     0,     0,     0,   460,\n     461,     0,   145,     0,   463,  1262,     0,     0,   465,     0,\n       0,     0,     0,     0,   467,     0,     0,   469,   470,     0,\n       0,     0,     0,     0,   147,  1282,     0,   148,  1283,    20,\n       0,  1284,   481,     0,  1285,     0,   483,     0,   149,     0,\n     130,   486,   487,     0,     0,   151,   152,     0,   153,     0,\n     491,   492,   493,   133,     0,  1315,     0,     0,     0,   496,\n    1316,     0,     0,  1317,     0,    43,     0,     0,     0,   500,\n       0,    46,     0,     0,   128,   504,     0,   156,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,   158,     0,     0,     0,\n       0,     0,     0,   903,     0,     0,     0,     0,     0,   549,\n     550,     0,   551,     0,   552,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,    -4,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,   560,     0,     0,     0,     0,     0,\n       0,     0,   561,   949,    12,    13,    14,    15,    16,     0,\n       0,    17,    18,     0,    19,    20,    21,    22,    23,    24,\n      25,    26,    27,    28,     0,    29,  -753,    30,    31,     0,\n      32,     0,   566,  -754,     0,    33,    34,    35,     0,  -754,\n      36,     0,    37,    38,     0,    39,  -754,    40,    41,    42,\n    -754,    43,   145,    44,  -756,    45,     0,    46,   145,  -751,\n    -752,    47,    48,     0,    49,  -755,    50,    51,     0,     0,\n       0,     0,     0,     0,   147,     0,     0,   148,     0,    20,\n     147,    52,     0,   148,     0,     0,    53,     0,   145,     0,\n     130,     0,     0,     0,   149,   151,   152,     0,   153,     0,\n       0,   151,   152,     0,   153,     0,     0,     0,     0,   133,\n     147,   647,     0,   148,     0,    43,     0,     0,     0,     0,\n       0,    46,     0,     0,   149,     0,     0,   156,     0,   141,\n     128,   151,   152,   156,   153,     0,     0,     0,     0,   133,\n     145,     0,     0,     0,     0,     0,   158,     0,     0,     0,\n       0,     0,   158,   810,     0,     0,     0,  1058,     0,   668,\n     128,     0,   147,   156,     0,   148,     0,     0,     0,     0,\n       0,  1059,  1060,   685,  1061,     0,   149,  1062,     0,     0,\n       0,     0,   158,   151,   152,     0,   153,     0,     0,   681,\n       0,    17,     0,   154,    19,    20,     0,     0,  1030,     0,\n       0,     0,     0,     0,     0,     0,   130,     0,  1063,     0,\n       0,     0,   128,     0,     0,   156,    34,    35,     0,   133,\n       0,     0,    37,     0,     0,   734,     0,   736,     0,     0,\n       0,    43,     0,     0,   158,     0,     0,    46,     0,   126,\n       0,     0,    48,     0,     0,   141,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,   871,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,   179,     0,     0,     0,   947,\n     948,   181,   310,     0,     0,     0,     0,     0,     0,     0,\n     952,   182,   183,   184,   185,   186,   187,   188,   189,   190,\n     191,   192,   193,   194,   195,   196,   197,   198,   199,   200,\n     201,   202,   203,   204,   205,   206,   207,   208,   209,   210,\n     211,   212,   213,   214,   215,   216,   217,   218,   219,   220,\n     221,   222,   223,   224,   225,   226,   227,   228,   229,   230,\n     231,   232,   233,   234,   235,   236,   237,   238,   239,   240,\n     241,   242,   243,   244,   245,   246,   247,   248,   249,   250,\n     251,   252,   253,   254,   255,   256,   257,   258,   259,   260,\n       0,     0,     0,     0,     0,     0,   682,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,   179,     0,     0,     0,     0,     0,   181,   310,     0,\n       0,     0,     0,     0,     0,  1021,  1022,   182,   183,   184,\n     185,   186,   187,   188,   189,   190,   191,   192,   193,   194,\n     195,   196,   197,   198,   199,   200,   201,   202,   203,   204,\n     205,   206,   207,   208,   209,   210,   211,   212,   213,   214,\n     215,   216,   217,   218,   219,   220,   221,   222,   223,   224,\n     225,   226,   227,   228,   229,   230,   231,   232,   233,   234,\n     235,   236,   237,   238,   239,   240,   241,   242,   243,   244,\n     245,   246,   247,   248,   249,   250,   251,   252,   253,   254,\n     255,   256,   257,   258,   259,   260,     0,     0,     0,     0,\n       0,     0,  1128,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,  1078,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,  1084,     0,     0,     0,  1088,     0,     0,     0,     0,\n    1091,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,  1099,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,   179,     0,     0,     0,\n       0,     0,     0,   273,     0,  1154,     0,     0,     0,     0,\n       0,  1159,   182,   183,   184,   185,   186,   187,   188,   189,\n     190,   191,   192,   193,   194,   195,   196,   197,   198,   199,\n     200,   201,   202,   203,   204,   205,   206,   207,   208,   209,\n     210,   211,   212,   213,   214,   215,   754,   217,   218,   219,\n     220,   221,   222,   223,   224,   225,   226,   227,   228,   229,\n     230,   231,   232,   233,   234,   235,   236,   237,   238,   239,\n     240,   241,   242,   243,   244,   245,   246,     0,   248,     0,\n       0,     0,     0,   253,     0,     0,     0,     0,   258,   259,\n     260,     0,     0,     0,     0,     0,     0,   755,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,  1263,     0,     0,  1264,   179,  1265,     0,\n    1266,   180,   286,   181,   287,   288,     0,     0,     0,   289,\n     290,   291,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,   429,   286,   181,   287,\n     288,     0,     0,     0,   289,   290,   291,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260,   179,     0,     0,\n       0,   180,     0,   181,   273,     0,     0,     0,     0,     0,\n       0,     0,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,   180,     0,   181,   310,\n       0,     0,     0,     0,     0,     0,     0,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260,   179,     0,     0,\n       0,     0,     0,   181,   310,     0,     0,   477,     0,     0,\n       0,     0,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,     0,     0,   181,   310,\n       0,     0,  1236,     0,     0,     0,     0,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260,   179,     0,     0,\n       0,   180,     0,   181,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,     0,     0,   181,   310,\n       0,     0,     0,     0,     0,     0,     0,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260\n};\n\nstatic const yytype_int16 yycheck[] =\n{\n       4,   726,    89,   725,   726,     9,    10,   711,    12,    89,\n      14,    15,   105,    17,    18,    19,    20,     5,    22,    23,\n     724,   725,    89,     5,    28,   559,    89,    89,    32,    33,\n      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,\n      44,    45,    46,    47,    48,    49,     5,   722,    52,   706,\n      89,    86,   719,    89,   721,     5,    89,   724,   711,     8,\n       8,    89,    89,   725,   726,   393,     8,    75,     5,    17,\n      12,   724,   725,    96,    85,    56,    96,    23,     5,     8,\n       7,    84,   104,    64,   106,     8,    90,    99,   100,   101,\n     102,   103,   420,   105,   114,  1106,  1107,   109,   632,   111,\n       0,    82,     8,   115,   116,    89,     8,    76,   120,   121,\n       5,   123,     8,   766,     5,    17,     7,     5,    14,     7,\n      11,    42,   126,    11,   128,     5,   130,     7,   132,   133,\n     134,   135,     5,   104,     7,     8,    82,   141,     5,   143,\n       7,   145,   146,   147,   148,   149,    94,   151,   152,   153,\n     154,    81,   156,   157,   158,   107,   108,   107,   107,    88,\n     720,    87,   722,   723,    93,   177,   726,   727,     5,    92,\n       7,   104,    95,   106,   178,     9,    10,   104,    12,   106,\n      14,    15,    88,    17,    18,    19,    20,    93,    22,    23,\n       8,     5,    83,     7,    28,    70,     8,    11,    32,    33,\n      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,\n      44,    45,    46,    47,    48,    49,    14,   105,    52,   100,\n     101,   102,   103,    22,   104,    20,   106,     5,   109,     7,\n     111,   711,    31,    11,   115,   116,    31,   104,   104,   106,\n     121,   721,   123,    42,   724,   725,   719,    31,   721,   722,\n     683,   724,   725,   726,     8,   104,    21,   951,    42,   104,\n     104,    31,   107,    33,    34,   104,    31,   104,    67,   106,\n      88,     5,    67,     7,    73,    93,    88,    42,    73,    94,\n      95,    93,    97,    67,     5,     5,     7,     7,     8,    73,\n      11,   105,   126,   104,   128,     8,   130,    67,   132,   133,\n     134,   135,    67,    68,    17,    18,   105,   141,    73,   143,\n     105,   145,   146,   147,   148,   149,    81,   151,   152,   153,\n     154,   105,   156,   157,   158,   758,   759,   105,   104,     8,\n     106,    85,   104,    87,   106,   105,    90,    16,    17,    18,\n     105,    96,   104,    98,    99,   100,   101,   102,   103,   104,\n     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,\n     115,   116,   117,   118,   119,   120,   121,   122,   123,   107,\n     393,    27,    31,   393,    30,    31,    30,    84,   104,    86,\n     106,   474,    89,  1077,    91,   397,    42,   399,   400,   401,\n      31,   403,   104,   405,   106,    51,    31,   420,   107,    55,\n     420,    55,   104,    28,   106,    64,    31,   104,    67,   106,\n     414,    67,    71,   107,   108,   419,    31,    73,   104,    75,\n    1142,   104,    78,    77,    78,    81,    67,    42,   432,   103,\n     434,  1125,    67,  1127,    59,    31,    71,    33,    34,   107,\n     444,   445,    67,   447,   448,     5,   105,     7,    63,   105,\n     103,   105,    67,   457,   725,   726,   460,   461,    73,   463,\n     105,   465,   474,   467,   105,   469,   470,  1142,  1028,    31,\n     105,    67,   565,   105,   104,  1142,   106,   481,     5,   483,\n    1142,   108,   486,   487,   104,     4,   106,   491,   492,   493,\n     105,   503,   496,   104,    54,   106,   500,   104,    24,   106,\n     504,    97,   105,  1197,  1198,    67,    25,    26,   109,   105,\n      29,   104,    32,   106,    74,   104,   397,   106,   399,   400,\n     401,    40,   403,   104,   405,   106,    45,   104,    47,    48,\n     104,    50,   106,   105,    31,   628,    33,    34,    57,   105,\n      31,    60,  1236,   105,    85,   549,   550,   551,   552,  1010,\n    1011,    42,   645,   565,  1211,    31,   560,   561,    43,    44,\n      79,    37,   566,  1288,  1289,  1259,  1288,   104,  1290,   106,\n      67,     5,  1106,     7,  1268,   110,    67,    96,   111,    98,\n     395,  1141,    73,   104,  1288,  1289,  1290,   104,    62,    80,\n     104,    67,  1286,    14,   409,   410,   411,   412,   413,   107,\n     415,   416,   417,   418,   107,   112,   421,   422,   105,   104,\n     104,   106,   106,     5,   105,     7,   628,   107,   634,    11,\n      54,  1288,   503,  1290,   633,   104,  1288,   106,  1290,   105,\n     632,   635,   104,   645,   106,   722,   723,  1290,   393,   726,\n      74,   721,   397,   647,   399,   400,   401,  1207,   403,   104,\n     405,   106,   407,   127,   721,   129,   634,   131,   721,   752,\n     722,   723,  1142,     5,   726,   420,   140,   691,   142,  1142,\n     144,   104,    64,   106,   104,   104,   106,   106,   104,   683,\n     106,   685,   721,   687,   719,   721,     5,   722,   721,   724,\n     725,   726,   727,   721,   721,   104,   104,   106,   106,   703,\n     704,   175,  1092,   744,  1094,   652,   943,   654,   719,   720,\n     721,   722,   407,   724,   725,   726,   727,   728,   729,   722,\n     723,   946,  1208,   726,   727,   715,   729,   715,   964,   706,\n     734,   743,   736,   715,   738,   739,   706,  1103,   722,   723,\n     752,   706,   726,   727,   706,   729,   706,  1102,   503,   706,\n     762,   545,   711,   774,   758,   759,    89,  1192,  1123,   548,\n     719,   720,   721,   722,   723,   724,   725,   726,   727,   728,\n     729,   729,   726,   729,   711,  1094,  1111,   563,   715,   644,\n     717,   718,   719,   720,   721,   722,   723,   724,   725,   726,\n     727,   728,   729,   719,   720,   721,   722,   700,   724,   725,\n     726,   635,   728,  1244,   565,   742,   113,   744,  1288,  1289,\n    1290,   954,   702,    30,    31,  1288,   711,  1290,  1078,   735,\n     715,     4,   717,   718,   719,   720,   721,   722,   723,   724,\n     725,   726,   727,   728,   729,    -1,     5,   177,     7,   702,\n      -1,    -1,    11,    26,    27,    -1,    29,   742,    31,   744,\n      67,    27,    -1,   687,    30,    24,    73,    40,    75,    42,\n      -1,    78,   743,    32,    47,    48,    -1,    50,    -1,   703,\n     704,    -1,    55,    -1,    57,    51,    52,    53,    -1,    55,\n      -1,   762,    65,    31,    67,    -1,    -1,    -1,   105,     4,\n      73,    -1,    40,    76,    42,    -1,    79,    45,    81,    -1,\n      -1,    77,    78,    -1,   738,   739,    -1,    -1,   912,   913,\n      25,    26,    60,    96,    29,    98,    31,    49,    31,    67,\n      33,    34,   105,    55,    -1,    73,    -1,    42,    76,   105,\n      62,    -1,    47,    48,    66,    50,    -1,    -1,    -1,   694,\n      -1,  1028,    57,   947,   948,    -1,   761,    -1,   952,   423,\n     424,     4,    67,    -1,    67,    -1,    27,   105,    73,   433,\n      31,   435,   436,    -1,    79,    -1,    81,    -1,   442,   443,\n      -1,    42,   446,    26,    -1,    -1,    29,    -1,    31,    -1,\n      51,    96,    -1,    98,    55,    -1,    -1,    40,   743,    -1,\n     105,    -1,   105,    -1,    47,    48,    67,    50,  1010,  1011,\n      -1,    -1,    73,    -1,    57,    -1,    -1,   762,  1101,    -1,\n      81,    -1,    27,    -1,    67,    30,    -1,  1021,  1022,    -1,\n      73,    -1,    22,    76,    -1,  1028,    79,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,   105,    -1,    51,    52,    53,    39,\n      -1,    -1,    -1,    96,  1028,    98,    -1,    -1,    -1,    49,\n      -1,    -1,   105,    -1,  1058,  1059,  1060,  1061,  1062,  1063,\n      75,    61,    62,    78,    -1,    -1,    66,    -1,    -1,    69,\n      -1,    -1,    -1,    -1,  1078,    75,    -1,    -1,   912,   913,\n    1084,    -1,    -1,    -1,  1088,    -1,    -1,  1091,    -1,  1101,\n     105,  1102,  1103,    -1,    -1,  1099,    -1,    -1,    -1,   573,\n      -1,    -1,   576,   577,    -1,    -1,   580,  1142,    -1,   583,\n      -1,    -1,   586,    -1,    -1,   589,    -1,    -1,   592,   934,\n     935,   595,    -1,    -1,   598,    -1,    -1,   601,    -1,    -1,\n     604,  1142,    -1,   607,    -1,    -1,   610,    -1,    -1,   613,\n     614,   615,   616,  1102,  1103,   619,    -1,    -1,   622,    -1,\n    1154,  1244,    -1,    27,    -1,  1159,    30,    31,    -1,    -1,\n      -1,    -1,    -1,    -1,   638,  1102,  1103,    -1,    42,  1106,\n    1107,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,    53,\n      -1,    55,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    65,    -1,    67,    -1,   669,   670,   671,  1291,  1210,\n    1211,    -1,    -1,    -1,  1141,  1142,   680,  1102,  1103,    -1,\n      -1,  1106,  1107,    -1,    -1,    -1,  1220,    -1,    -1,   693,\n      -1,    -1,    -1,    -1,  1058,  1059,  1060,  1061,  1062,  1063,\n      -1,   105,  1244,    -1,   708,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,  1141,  1142,    -1,  1208,\n      -1,  1210,  1211,  1288,  1289,  1010,  1011,    -1,    -1,  1263,\n    1264,  1265,  1266,    -1,    -1,    -1,   740,   741,    -1,    -1,\n    1207,  1208,  1209,  1210,  1211,    -1,    -1,    -1,  1093,  1291,\n    1095,  1096,  1097,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,   765,    -1,    -1,   768,   769,   770,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,   779,    -1,    -1,    -1,    -1,\n      -1,    -1,  1207,  1208,  1209,  1210,  1211,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,   805,   806,    -1,    -1,   809,    -1,  1092,    -1,  1094,\n     814,   815,   816,    -1,    -1,    -1,    -1,   821,    -1,    -1,\n      -1,    -1,    -1,    -1,   828,    -1,    -1,    -1,    -1,   833,\n      -1,    -1,    -1,    -1,    -1,    -1,   840,   841,   842,   843,\n     844,   845,   846,    -1,    -1,   849,    -1,    -1,    -1,    -1,\n     854,   855,   856,   857,   858,    -1,  1220,    -1,    -1,   863,\n     864,    -1,    -1,   867,    -1,    -1,   870,    -1,    -1,    -1,\n      -1,   875,   876,    -1,    -1,   879,    -1,    -1,    -1,    -1,\n     884,    -1,    -1,    -1,    -1,   889,   890,   891,   892,   893,\n     894,   895,    -1,    -1,    -1,    -1,   900,    -1,    -1,    -1,\n      -1,    -1,    -1,   907,   908,   909,   910,   911,    -1,    -1,\n      -1,    -1,    -1,    -1,   918,   919,   920,   921,   284,    -1,\n      -1,    -1,   926,   927,   928,   929,   930,   293,    -1,    -1,\n      -1,   297,    -1,   299,     4,   301,    -1,   303,    -1,    -1,\n      -1,   307,    -1,    -1,    -1,    -1,   312,    -1,    -1,    -1,\n      -1,    -1,    -1,   319,    -1,    25,    26,   323,    -1,    29,\n      -1,    31,   328,    -1,    -1,    -1,   332,    -1,    -1,    -1,\n      -1,   337,    42,   339,    -1,    -1,   342,    47,    48,    -1,\n      50,   347,    -1,    -1,    -1,   351,    -1,    57,   354,    -1,\n     356,    -1,    -1,    -1,    -1,   361,    -1,    67,    -1,   365,\n      -1,    -1,    -1,    73,    -1,   371,    -1,    -1,   374,    79,\n      -1,    81,   378,    -1,    -1,    92,    -1,    -1,   384,    -1,\n      -1,     4,   388,    -1,    -1,  1029,    96,    -1,    98,    -1,\n      -1,    -1,    -1,    -1,  1038,   105,  1040,  1041,    -1,    -1,\n    1044,    -1,    -1,    26,    27,    -1,    29,    -1,    31,  1053,\n    1054,    -1,    -1,    -1,    -1,    -1,    -1,    40,    -1,    42,\n    1064,    -1,    -1,    46,    47,    48,    -1,    50,    -1,    52,\n      53,    -1,    55,   150,    57,    58,    -1,    -1,   155,  1083,\n      -1,  1085,    -1,    -1,    67,    -1,    -1,    -1,    -1,    -1,\n      73,    -1,    -1,    76,    77,    -1,    79,    -1,    81,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    96,    -1,    98,    -1,    -1,    -1,     4,\n      -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,    -1,  1133,\n      -1,    -1,    -1,    -1,    -1,  1139,    -1,    -1,    -1,    -1,\n      25,    26,    27,    -1,    29,    30,    31,    -1,  1152,    -1,\n      -1,  1155,    -1,    -1,  1158,    -1,  1160,    42,    -1,  1163,\n      -1,    -1,    47,    48,    -1,    50,    51,    -1,    -1,    -1,\n      -1,  1175,  1176,  1177,  1178,  1179,  1180,    -1,    -1,    -1,\n    1184,    -1,    67,    -1,   261,    -1,    -1,  1191,    73,    -1,\n      -1,   268,    -1,    -1,    -1,    -1,    81,    -1,    -1,    -1,\n     277,   278,    -1,    -1,   281,   282,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    98,  1218,    -1,    -1,    -1,    -1,    -1,\n     105,    -1,    -1,    -1,  1228,    -1,    -1,    -1,    -1,  1233,\n      -1,    -1,   309,    -1,    -1,    -1,    -1,    -1,    -1,   316,\n     317,    -1,     4,    -1,   321,  1249,    -1,    -1,   325,    -1,\n      -1,    -1,    -1,    -1,   331,    -1,    -1,   334,   335,    -1,\n      -1,    -1,    -1,    -1,    26,  1269,    -1,    29,  1272,    31,\n      -1,  1275,   349,    -1,  1278,    -1,   353,    -1,    40,    -1,\n      42,   358,   359,    -1,    -1,    47,    48,    -1,    50,    -1,\n     367,   368,   369,    55,    -1,  1299,    -1,    -1,    -1,   376,\n    1304,    -1,    -1,  1307,    -1,    67,    -1,    -1,    -1,   386,\n      -1,    73,    -1,    -1,    76,   392,    -1,    79,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    98,    -1,    -1,    -1,\n      -1,    -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,   426,\n     427,    -1,   429,    -1,   431,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,     0,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,   451,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,   459,   749,    20,    21,    22,    23,    24,    -1,\n      -1,    27,    28,    -1,    30,    31,    32,    33,    34,    35,\n      36,    37,    38,    39,    -1,    41,    42,    43,    44,    -1,\n      46,    -1,   489,    49,    -1,    51,    52,    53,    -1,    55,\n      56,    -1,    58,    59,    -1,    61,    62,    63,    64,    65,\n      66,    67,     4,    69,    70,    71,    -1,    73,     4,    75,\n      76,    77,    78,    -1,    80,    81,    82,    83,    -1,    -1,\n      -1,    -1,    -1,    -1,    26,    -1,    -1,    29,    -1,    31,\n      26,    97,    -1,    29,    -1,    -1,   102,    -1,     4,    -1,\n      42,    -1,    -1,    -1,    40,    47,    48,    -1,    50,    -1,\n      -1,    47,    48,    -1,    50,    -1,    -1,    -1,    -1,    55,\n      26,   568,    -1,    29,    -1,    67,    -1,    -1,    -1,    -1,\n      -1,    73,    -1,    -1,    40,    -1,    -1,    79,    -1,    81,\n      76,    47,    48,    79,    50,    -1,    -1,    -1,    -1,    55,\n       4,    -1,    -1,    -1,    -1,    -1,    98,    -1,    -1,    -1,\n      -1,    -1,    98,   105,    -1,    -1,    -1,    21,    -1,   105,\n      76,    -1,    26,    79,    -1,    29,    -1,    -1,    -1,    -1,\n      -1,    35,    36,   630,    38,    -1,    40,    41,    -1,    -1,\n      -1,    -1,    98,    47,    48,    -1,    50,    -1,    -1,   105,\n      -1,    27,    -1,    57,    30,    31,    -1,    -1,   944,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    42,    -1,    72,    -1,\n      -1,    -1,    76,    -1,    -1,    79,    52,    53,    -1,    55,\n      -1,    -1,    58,    -1,    -1,   682,    -1,   684,    -1,    -1,\n      -1,    67,    -1,    -1,    98,    -1,    -1,    73,    -1,    75,\n      -1,    -1,    78,    -1,    -1,    81,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   105,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,   746,\n     747,    10,    11,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n     757,    20,    21,    22,    23,    24,    25,    26,    27,    28,\n      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,\n      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,\n      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,\n      59,    60,    61,    62,    63,    64,    65,    66,    67,    68,\n      69,    70,    71,    72,    73,    74,    75,    76,    77,    78,\n      79,    80,    81,    82,    83,    84,    85,    86,    87,    88,\n      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,\n      -1,    -1,    -1,    -1,    -1,    -1,   105,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,     4,    -1,    -1,    -1,    -1,    -1,    10,    11,    -1,\n      -1,    -1,    -1,    -1,    -1,   932,   933,    20,    21,    22,\n      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,\n      33,    34,    35,    36,    37,    38,    39,    40,    41,    42,\n      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,\n      53,    54,    55,    56,    57,    58,    59,    60,    61,    62,\n      63,    64,    65,    66,    67,    68,    69,    70,    71,    72,\n      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,\n      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,\n      93,    94,    95,    96,    97,    98,    -1,    -1,    -1,    -1,\n      -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,  1034,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,  1048,    -1,    -1,    -1,  1052,    -1,    -1,    -1,    -1,\n    1057,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,  1076,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,\n      -1,    -1,    -1,    11,    -1,  1112,    -1,    -1,    -1,    -1,\n      -1,  1118,    20,    21,    22,    23,    24,    25,    26,    27,\n      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,\n      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,\n      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,\n      58,    59,    60,    61,    62,    63,    64,    65,    66,    67,\n      68,    69,    70,    71,    72,    73,    74,    75,    76,    77,\n      78,    79,    80,    81,    82,    83,    84,    -1,    86,    -1,\n      -1,    -1,    -1,    91,    -1,    -1,    -1,    -1,    96,    97,\n      98,    -1,    -1,    -1,    -1,    -1,    -1,   105,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,  1250,    -1,    -1,  1253,     4,  1255,    -1,\n    1257,     8,     9,    10,    11,    12,    -1,    -1,    -1,    16,\n      17,    18,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,     8,     9,    10,    11,\n      12,    -1,    -1,    -1,    16,    17,    18,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98,     4,    -1,    -1,\n      -1,     8,    -1,    10,    11,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,     8,    -1,    10,    11,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98,     4,    -1,    -1,\n      -1,    -1,    -1,    10,    11,    -1,    -1,    14,    -1,    -1,\n      -1,    -1,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,    -1,    -1,    10,    11,\n      -1,    -1,    14,    -1,    -1,    -1,    -1,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98,     4,    -1,    -1,\n      -1,     8,    -1,    10,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,    -1,    -1,    10,    11,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98\n};\n\n  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing\n     symbol of state STATE-NUM.  */\nstatic const yytype_uint16 yystos[] =\n{\n       0,   114,   120,   124,   419,   441,     0,     5,     7,    54,\n      74,   418,    20,    21,    22,    23,    24,    27,    28,    30,\n      31,    32,    33,    34,    35,    36,    37,    38,    39,    41,\n      43,    44,    46,    51,    52,    53,    56,    58,    59,    61,\n      63,    64,    65,    67,    69,    71,    73,    77,    78,    80,\n      82,    83,    97,   102,   130,   140,   142,   144,   147,   149,\n     151,   153,   170,   176,   190,   202,   214,   222,   227,   229,\n     238,   241,   243,   245,   247,   339,   342,   345,   347,   350,\n     353,   359,   362,   430,   431,   432,   433,   434,   435,   436,\n     437,   438,   418,   420,   420,   420,   420,   420,   420,   420,\n     420,   420,   420,   420,   420,   420,   420,   420,   420,   420,\n     420,   420,   420,   420,   420,   420,   420,   420,   420,   420,\n     420,   420,   420,   420,   402,   402,    75,   194,    76,   192,\n      42,   183,    49,    55,    62,    66,   204,   209,   224,   356,\n     440,    81,   335,    70,   157,     4,    25,    26,    29,    40,\n      45,    47,    48,    50,    57,    60,    79,    96,    98,   249,\n     254,   257,   261,   264,   267,   273,   277,   279,   283,   299,\n     304,   305,   307,   308,   310,   439,   407,   420,   419,     4,\n       8,    10,    20,    21,    22,    23,    24,    25,    26,    27,\n      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,\n      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,\n      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,\n      58,    59,    60,    61,    62,    63,    64,    65,    66,    67,\n      68,    69,    70,    71,    72,    73,    74,    75,    76,    77,\n      78,    79,    80,    81,    82,    83,    84,    85,    86,    87,\n      88,    89,    90,    91,    92,    93,    94,    95,    96,    97,\n      98,   115,   116,   119,   395,   425,   426,   427,   428,   123,\n     395,   169,   395,    11,   116,   189,   397,   428,   429,   141,\n     395,    88,    93,   116,   338,   340,     9,    11,    12,    16,\n      17,    18,   116,   148,   422,   424,   425,   246,   422,   150,\n     422,   242,   422,   240,   422,    17,   116,   201,   203,   390,\n      11,   116,   361,   363,   396,   425,    88,    93,   116,   341,\n     343,    94,   116,   349,   351,   390,    18,   116,   346,   348,\n     390,   391,   129,   422,    92,    95,   116,   352,   354,   146,\n     422,   116,   226,   371,   372,   373,   116,   237,   239,   391,\n     116,   143,   394,   428,   344,   422,   152,   422,    88,    93,\n     116,   228,   230,    12,   116,   139,   160,    85,    87,    90,\n     116,   175,   177,   116,   358,   360,   369,   396,   244,   422,\n      16,    17,    18,   116,   221,   223,   392,   393,   213,   422,\n     403,   418,   429,   420,   402,   420,   402,   420,   402,   420,\n     420,   208,   420,   420,   402,   420,   402,   420,   402,   420,\n     420,   420,   420,   420,   419,   420,   420,   420,   420,   419,\n     420,   420,   420,   104,   104,   402,   104,   106,   417,     8,\n     408,   424,   419,   104,   419,   104,   104,   106,   171,   104,\n     106,   398,   399,   401,   419,   419,   104,   419,   419,   398,\n     398,   423,   398,   398,   398,   398,   398,   419,   398,   364,\n     419,   419,   398,   419,   398,   419,   398,   419,   398,   419,\n     419,   398,   398,   398,   107,   374,   375,    14,   377,   378,\n     398,   419,   398,   419,   398,   398,   419,   419,   398,   161,\n     398,   419,   419,   419,   398,   398,   419,   370,   398,   398,\n     419,   398,   404,   405,   419,   195,   397,   191,   395,   182,\n     422,   205,   422,   355,   422,   210,   422,   365,   422,   334,\n     422,   155,   160,   276,   395,   272,   395,   266,   395,   253,\n     395,   248,   395,   258,   395,   260,   395,   263,   395,   309,\n     395,   282,   397,   298,   395,   278,   395,   402,   402,   419,\n     419,   419,   419,   117,   402,   402,   402,   402,   402,   402,\n     419,   419,   396,   376,   107,   379,   419,   368,   104,   106,\n     410,   406,   422,   104,   106,   196,   104,   104,   106,   184,\n     104,   106,   206,   104,   106,   357,   104,   106,   211,   104,\n     106,   225,   104,   106,   336,   104,   106,   158,   104,   106,\n     280,   104,   106,   274,   104,   106,   268,   104,   106,   255,\n     104,   106,   250,   104,   104,   104,   104,   106,   311,   104,\n     106,   284,   104,   106,   302,   280,   306,   306,   416,   409,\n     103,   121,   122,   125,   126,    83,   173,   105,   400,   144,\n     382,   374,   378,   380,   396,   107,   366,   419,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   105,   192,\n     249,   252,   254,   257,   261,   264,   267,   277,   279,   283,\n     356,   105,   105,   396,   103,   419,   131,    82,   128,   130,\n     144,   131,   128,   142,   420,   105,   402,   105,   108,   381,\n     382,   396,   411,    24,    32,   197,   198,   215,   217,   231,\n     233,   193,   105,   207,   207,   212,   207,   337,   159,   281,\n     275,   269,   256,   251,   259,   262,   265,   312,   285,   303,\n     402,   402,   402,   402,   419,   407,   419,     8,    43,    44,\n     132,   136,   145,   420,   145,   402,    88,    93,   116,   172,\n     174,     5,   421,   375,    54,   105,   403,   412,   414,   415,\n     427,   420,   420,   105,   190,   199,   200,   202,   204,   209,\n     224,   227,   229,   402,   232,   105,   151,   153,   176,   194,\n     245,   247,   105,   151,   153,   241,   243,   105,   105,   151,\n     153,   214,   241,   243,   105,   105,   151,   153,   105,   151,\n     153,   105,   151,   153,   176,   183,   335,   339,   342,   356,\n     105,   151,   153,   176,   183,   252,   335,   105,   151,   153,\n     176,   183,   247,   254,   257,   261,   264,   267,   270,   271,\n     273,   277,   279,   335,   339,   342,   105,   151,   153,   176,\n     183,   192,   249,   252,   299,   310,   335,   339,   345,   356,\n     105,   151,   153,   176,   192,   249,   252,   299,   310,   105,\n     151,   153,   176,   183,   194,   245,   247,   335,   339,   342,\n     356,   105,   151,   153,   176,   183,   194,   245,   247,   335,\n     339,   347,   350,   353,   356,   105,   151,   153,   176,   183,\n     192,   249,   252,   299,   310,   335,   339,   347,   350,   353,\n     356,   359,   362,   105,   151,   153,   176,   183,   192,   249,\n     252,   356,    21,    68,   105,   151,   153,   176,   183,   288,\n     293,   335,   105,   151,   153,   176,   183,   192,   249,   305,\n     308,   417,     8,   118,   420,   420,   402,   402,   147,   149,\n     151,   153,   154,   156,   127,   422,   154,   419,   419,   398,\n     383,   396,   419,   407,   407,   234,   395,   218,   422,   402,\n     194,   402,   402,   402,   216,   233,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     420,   420,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   419,   419,   133,   395,   135,   395,   162,   163,   157,\n     398,   162,   109,   421,   104,   106,   413,   413,   104,   106,\n     235,   104,   106,   219,   217,   116,   291,   292,   369,   116,\n     286,   287,   369,   104,   104,   106,   137,   105,    21,    35,\n      36,    38,    41,    72,   164,   166,   179,   186,   192,   249,\n     252,   296,   301,   310,   314,   402,   105,   110,   419,   402,\n     402,   402,   402,   104,   419,   104,   106,   289,   419,   402,\n     402,   419,   420,   420,   420,   420,   420,   420,   402,   419,\n     421,   416,   236,   220,   402,   402,   134,   138,   116,   294,\n     295,   366,   367,   165,   395,   116,   313,   316,   367,   178,\n     395,   185,   395,   300,   395,    85,   384,   389,   105,   105,\n     151,   153,   176,   183,   238,   105,   151,   153,   176,   183,\n     222,   297,   290,   105,   140,   144,   151,   153,   105,   140,\n     151,   153,   104,   368,   419,   104,   106,   167,   104,   419,\n     104,   106,   180,   104,   106,   187,   302,   421,   421,   402,\n     402,   105,   151,   153,   176,   183,   252,   273,   299,   310,\n     335,   105,   151,   153,   183,   247,   339,   342,   345,   347,\n     350,   356,   402,   402,   402,   402,   402,   111,   107,   402,\n     402,   402,   402,   402,   402,   402,   402,   297,   168,   315,\n     181,   188,   421,   421,   105,   105,   151,   153,   170,   176,\n      37,   105,   151,   153,   105,   151,   153,   176,   183,   105,\n     151,   153,   176,   183,   190,   112,    14,   385,   386,   402,\n     420,   402,   402,   421,   387,    84,    86,    89,    91,   317,\n     318,   319,   321,   322,   323,   326,   327,   330,   331,   107,\n     386,   396,   402,   419,   419,   419,   419,   421,   388,   104,\n     106,   320,   104,   106,   324,   104,   106,   328,   104,   106,\n     332,   421,   402,   402,   402,   402,   107,   105,   325,   329,\n     333,   421,   105,   245,   247,   339,   342,   347,   350,   356,\n     359,   105,   245,   247,   356,   359,   105,   194,   245,   247,\n     339,   342,   347,   350,   396,   402,   402,   402\n};\n\n  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */\nstatic const yytype_uint16 yyr1[] =\n{\n       0,   113,   114,   114,   114,   115,   116,   117,   118,   117,\n     119,   120,   121,   122,   122,   122,   122,   123,   124,   125,\n     126,   126,   126,   127,   128,   129,   130,   131,   131,   131,\n     132,   133,   134,   134,   134,   134,   134,   135,   136,   137,\n     137,   138,   138,   138,   138,   139,   140,   141,   142,   143,\n     144,   145,   145,   145,   145,   145,   146,   147,   148,   149,\n     150,   151,   152,   153,   154,   155,   156,   156,   157,   158,\n     158,   159,   159,   159,   161,   160,   160,   162,   163,   163,\n     164,   164,   164,   164,   164,   164,   164,   164,   164,   164,\n     165,   166,   167,   167,   168,   168,   168,   168,   168,   169,\n     170,   171,   171,   172,   173,   173,   174,   174,   174,   175,\n     176,   177,   177,   177,   177,   178,   179,   180,   180,   181,\n     181,   181,   181,   181,   182,   183,   184,   184,   185,   186,\n     187,   187,   188,   188,   188,   188,   188,   188,   189,   190,\n     191,   192,   193,   193,   193,   193,   193,   193,   193,   194,\n     195,   196,   196,   197,   197,   197,   198,   198,   198,   198,\n     198,   198,   198,   198,   198,   199,   200,   201,   202,   203,\n     203,   204,   205,   206,   206,   207,   207,   207,   207,   207,\n     208,   209,   210,   211,   211,   212,   212,   212,   212,   212,\n     212,   213,   214,   215,   216,   216,   217,   218,   219,   219,\n     220,   220,   220,   220,   220,   220,   221,   222,   223,   223,\n     224,   225,   225,   226,   227,   228,   229,   230,   230,   230,\n     231,   232,   232,   233,   234,   235,   235,   236,   236,   236,\n     236,   236,   236,   237,   238,   239,   239,   240,   241,   242,\n     243,   244,   245,   246,   247,   248,   249,   250,   250,   251,\n     251,   251,   251,   251,   251,   251,   251,   251,   252,   252,\n     252,   252,   252,   252,   252,   252,   253,   254,   255,   255,\n     256,   256,   256,   256,   256,   256,   256,   256,   256,   256,\n     256,   256,   256,   256,   257,   258,   259,   259,   259,   259,\n     259,   259,   259,   259,   259,   259,   259,   259,   260,   261,\n     262,   262,   262,   262,   262,   262,   262,   262,   262,   262,\n     262,   262,   262,   262,   263,   264,   265,   265,   265,   265,\n     265,   265,   265,   265,   265,   265,   265,   265,   265,   265,\n     265,   265,   265,   265,   266,   267,   268,   268,   269,   269,\n     269,   269,   269,   269,   269,   269,   269,   269,   270,   270,\n     271,   271,   271,   271,   271,   271,   271,   272,   273,   274,\n     274,   275,   275,   275,   275,   275,   275,   275,   276,   277,\n     278,   279,   280,   280,   281,   281,   281,   281,   281,   281,\n     281,   281,   281,   282,   283,   284,   284,   285,   285,   285,\n     285,   285,   285,   285,   285,   286,   286,   287,   288,   289,\n     289,   290,   290,   290,   290,   290,   290,   290,   290,   290,\n     290,   290,   291,   291,   292,   293,   294,   294,   295,   296,\n     297,   297,   297,   297,   297,   297,   297,   297,   297,   297,\n     298,   299,   300,   301,   302,   302,   303,   303,   303,   303,\n     303,   303,   303,   303,   303,   304,   305,   306,   306,   306,\n     306,   306,   307,   308,   309,   310,   311,   311,   312,   312,\n     312,   312,   312,   312,   312,   312,   312,   313,   314,   315,\n     315,   315,   315,   316,   316,   317,   317,   318,   319,   320,\n     320,   321,   321,   321,   322,   323,   324,   324,   325,   325,\n     325,   325,   325,   325,   325,   325,   325,   326,   327,   328,\n     328,   329,   329,   329,   329,   329,   330,   331,   332,   332,\n     333,   333,   333,   333,   333,   333,   333,   333,   334,   335,\n     336,   336,   337,   337,   337,   338,   339,   340,   340,   340,\n     341,   342,   343,   343,   343,   344,   345,   346,   347,   348,\n     348,   349,   350,   351,   351,   351,   352,   353,   354,   354,\n     354,   355,   356,   357,   357,   358,   359,   360,   360,   361,\n     362,   364,   363,   363,   365,   366,   367,   368,   368,   370,\n     369,   372,   371,   373,   371,   371,   374,   375,   376,   376,\n     377,   378,   379,   379,   380,   381,   381,   382,   382,   383,\n     384,   385,   386,   387,   387,   388,   388,   389,   390,   391,\n     391,   392,   392,   393,   393,   394,   394,   395,   395,   396,\n     396,   397,   397,   397,   398,   398,   399,   400,   401,   402,\n     402,   402,   403,   404,   405,   406,   406,   407,   407,   408,\n     408,   408,   409,   409,   410,   410,   411,   411,   412,   412,\n     412,   413,   413,   414,   415,   416,   416,   417,   417,   418,\n     418,   419,   419,   420,   421,   421,   423,   422,   422,   424,\n     424,   424,   424,   424,   424,   424,   425,   425,   425,   426,\n     426,   426,   426,   426,   426,   426,   426,   426,   426,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   428,\n     429,   430,   431,   432,   433,   434,   435,   436,   437,   438,\n     438,   438,   438,   438,   438,   438,   438,   438,   438,   438,\n     438,   438,   439,   439,   439,   439,   439,   439,   439,   439,\n     439,   439,   439,   439,   439,   439,   440,   440,   440,   440,\n     441,   441,   441,   441,   441,   441,   441,   441,   441,   441,\n     441,   441,   441,   441,   441,   441,   441,   441,   441,   441,\n     441,   441,   441,   441,   441,   441,   441,   441,   441,   441,\n     441,   441,   441,   441,   441,   441,   441,   441\n};\n\n  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */\nstatic const yytype_uint8 yyr2[] =\n{\n       0,     2,     1,     1,     1,     1,     3,     0,     0,     6,\n       1,    13,     1,     0,     2,     2,     2,     1,    13,     1,\n       0,     2,     3,     1,     4,     1,     4,     0,     3,     3,\n       7,     1,     0,     2,     2,     2,     2,     1,     4,     1,\n       4,     0,     2,     2,     2,     1,     4,     1,     7,     1,\n       4,     0,     2,     2,     2,     2,     1,     4,     1,     4,\n       1,     4,     1,     4,     1,     1,     0,     3,     4,     1,\n       4,     0,     2,     2,     0,     3,     1,     1,     0,     3,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     4,     1,     4,     0,     3,     2,     2,     2,     1,\n       4,     1,     4,     1,     0,     4,     2,     2,     1,     1,\n       4,     2,     2,     2,     1,     1,     4,     1,     4,     0,\n       3,     2,     2,     2,     1,     4,     1,     3,     1,     4,\n       1,     4,     0,     2,     3,     2,     2,     2,     1,     4,\n       1,     7,     0,     3,     2,     2,     2,     2,     2,     4,\n       1,     1,     4,     1,     1,     1,     0,     2,     2,     2,\n       3,     3,     2,     3,     3,     2,     0,     1,     4,     2,\n       1,     4,     1,     1,     4,     0,     2,     2,     2,     2,\n       1,     4,     1,     1,     4,     0,     2,     2,     2,     2,\n       2,     1,     4,     3,     0,     3,     4,     1,     1,     4,\n       0,     3,     2,     2,     2,     2,     1,     4,     2,     1,\n       4,     1,     4,     1,     4,     1,     4,     2,     2,     1,\n       2,     0,     2,     5,     1,     1,     4,     0,     3,     2,\n       2,     2,     2,     1,     4,     2,     1,     1,     4,     1,\n       4,     1,     4,     1,     4,     1,     4,     1,     4,     0,\n       2,     2,     2,     3,     3,     3,     3,     3,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     4,     1,     4,\n       0,     3,     3,     3,     2,     2,     2,     2,     2,     3,\n       3,     3,     3,     3,     7,     1,     0,     3,     3,     3,\n       2,     3,     2,     2,     2,     2,     2,     2,     1,     7,\n       0,     3,     3,     3,     2,     2,     3,     2,     2,     2,\n       2,     2,     2,     2,     1,     7,     0,     3,     3,     3,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     3,\n       3,     3,     3,     3,     1,     4,     1,     4,     0,     3,\n       3,     2,     2,     2,     2,     2,     2,     3,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     4,     1,\n       4,     0,     3,     3,     2,     2,     2,     3,     1,     4,\n       1,     4,     1,     4,     0,     3,     3,     3,     2,     2,\n       2,     2,     2,     1,     4,     1,     4,     0,     3,     3,\n       2,     2,     2,     3,     3,     2,     1,     1,     4,     1,\n       4,     0,     3,     3,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     1,     1,     7,     2,     1,     1,     7,\n       0,     3,     3,     2,     2,     2,     3,     3,     3,     3,\n       1,     4,     1,     4,     1,     4,     0,     3,     2,     2,\n       2,     3,     3,     3,     3,     2,     5,     0,     3,     3,\n       3,     3,     2,     5,     1,     4,     1,     4,     0,     3,\n       3,     2,     2,     2,     3,     3,     3,     1,     7,     0,\n       2,     2,     5,     2,     1,     1,     1,     1,     3,     1,\n       3,     1,     1,     1,     1,     3,     1,     4,     0,     2,\n       3,     2,     2,     2,     2,     2,     2,     1,     3,     1,\n       4,     0,     2,     3,     2,     2,     1,     3,     1,     4,\n       0,     3,     2,     2,     2,     2,     2,     2,     1,     4,\n       1,     4,     0,     2,     2,     1,     4,     2,     2,     1,\n       1,     4,     2,     2,     1,     1,     4,     1,     4,     2,\n       1,     1,     4,     2,     2,     1,     1,     4,     2,     2,\n       1,     1,     4,     1,     4,     1,     4,     2,     1,     1,\n       4,     0,     3,     1,     1,     2,     2,     0,     2,     0,\n       3,     0,     2,     0,     2,     1,     3,     2,     0,     2,\n       3,     2,     0,     2,     2,     0,     2,     0,     5,     5,\n       5,     4,     4,     0,     2,     0,     5,     5,     1,     1,\n       1,     1,     1,     1,     1,     1,     2,     2,     1,     1,\n       1,     2,     2,     1,     2,     4,     1,     1,     1,     0,\n       2,     2,     3,     2,     1,     0,     1,     0,     2,     0,\n       2,     3,     0,     5,     1,     4,     0,     3,     1,     3,\n       3,     1,     4,     1,     1,     0,     4,     2,     5,     1,\n       1,     0,     2,     2,     0,     1,     0,     3,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     0,     0,     0,     0,     0,     0,     0,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       0,     3,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     4,     4,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     4,     3,     4,     4,     4,     4,     4\n};\n\n\n#define yyerrok         (yyerrstatus = 0)\n#define yyclearin       (yychar = YYEMPTY)\n#define YYEMPTY         (-2)\n#define YYEOF           0\n\n#define YYACCEPT        goto yyacceptlab\n#define YYABORT         goto yyabortlab\n#define YYERROR         goto yyerrorlab\n\n\n#define YYRECOVERING()  (!!yyerrstatus)\n\n#define YYBACKUP(Token, Value)                                  \\\ndo                                                              \\\n  if (yychar == YYEMPTY)                                        \\\n    {                                                           \\\n      yychar = (Token);                                         \\\n      yylval = (Value);                                         \\\n      YYPOPSTACK (yylen);                                       \\\n      yystate = *yyssp;                                         \\\n      goto yybackup;                                            \\\n    }                                                           \\\n  else                                                          \\\n    {                                                           \\\n      yyerror (&yylloc, scanner, param, YY_(\"syntax error: cannot back up\")); \\\n      YYERROR;                                                  \\\n    }                                                           \\\nwhile (0)\n\n/* Error token number */\n#define YYTERROR        1\n#define YYERRCODE       256\n\n\n/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].\n   If N is 0, then set CURRENT to the empty location which ends\n   the previous symbol: RHS[0] (always defined).  */\n\n#ifndef YYLLOC_DEFAULT\n# define YYLLOC_DEFAULT(Current, Rhs, N)                                \\\n    do                                                                  \\\n      if (N)                                                            \\\n        {                                                               \\\n          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \\\n          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \\\n          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \\\n          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \\\n        }                                                               \\\n      else                                                              \\\n        {                                                               \\\n          (Current).first_line   = (Current).last_line   =              \\\n            YYRHSLOC (Rhs, 0).last_line;                                \\\n          (Current).first_column = (Current).last_column =              \\\n            YYRHSLOC (Rhs, 0).last_column;                              \\\n        }                                                               \\\n    while (0)\n#endif\n\n#define YYRHSLOC(Rhs, K) ((Rhs)[K])\n\n\n/* Enable debugging if requested.  */\n#if YYDEBUG\n\n# ifndef YYFPRINTF\n#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */\n#  define YYFPRINTF fprintf\n# endif\n\n# define YYDPRINTF(Args)                        \\\ndo {                                            \\\n  if (yydebug)                                  \\\n    YYFPRINTF Args;                             \\\n} while (0)\n\n\n/* YY_LOCATION_PRINT -- Print the location on the stream.\n   This macro was not mandated originally: define only if we know\n   we won't break user code: when these are the locations we know.  */\n\n#ifndef YY_LOCATION_PRINT\n# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL\n\n/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */\n\nYY_ATTRIBUTE_UNUSED\nstatic int\nyy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)\n{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }\n\n#  define YY_LOCATION_PRINT(File, Loc)          \\\n  yy_location_print_ (File, &(Loc))\n\n# else\n#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)\n# endif\n#endif\n\n\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \\\ndo {                                                                      \\\n  if (yydebug)                                                            \\\n    {                                                                     \\\n      YYFPRINTF (stderr, \"%s \", Title);                                   \\\n      yy_symbol_print (stderr,                                            \\\n                  Type, Value, Location, scanner, param); \\\n      YYFPRINTF (stderr, \"\\n\");                                           \\\n    }                                                                     \\\n} while (0)\n\n\n/*-----------------------------------.\n| Print this symbol's value on YYO.  |\n`-----------------------------------*/\n\nstatic void\nyy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *scanner, struct yang_parameter *param)\n{\n  FILE *yyoutput = yyo;\n  YYUSE (yyoutput);\n  YYUSE (yylocationp);\n  YYUSE (scanner);\n  YYUSE (param);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}\n\n\n/*---------------------------.\n| Print this symbol on YYO.  |\n`---------------------------*/\n\nstatic void\nyy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *scanner, struct yang_parameter *param)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yytype, yyvaluep, yylocationp, scanner, param);\n  YYFPRINTF (yyo, \")\");\n}\n\n/*------------------------------------------------------------------.\n| yy_stack_print -- Print the state stack from its BOTTOM up to its |\n| TOP (included).                                                   |\n`------------------------------------------------------------------*/\n\nstatic void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}\n\n# define YY_STACK_PRINT(Bottom, Top)                            \\\ndo {                                                            \\\n  if (yydebug)                                                  \\\n    yy_stack_print ((Bottom), (Top));                           \\\n} while (0)\n\n\n/*------------------------------------------------.\n| Report that the YYRULE is going to be reduced.  |\n`------------------------------------------------*/\n\nstatic void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, void *scanner, struct yang_parameter *param)\n{\n  unsigned long yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                       , &(yylsp[(yyi + 1) - (yynrhs)])                       , scanner, param);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}\n\n# define YY_REDUCE_PRINT(Rule)          \\\ndo {                                    \\\n  if (yydebug)                          \\\n    yy_reduce_print (yyssp, yyvsp, yylsp, Rule, scanner, param); \\\n} while (0)\n\n/* Nonzero means print parse trace.  It is left uninitialized so that\n   multiple parsers can coexist.  */\nint yydebug;\n#else /* !YYDEBUG */\n# define YYDPRINTF(Args)\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)\n# define YY_STACK_PRINT(Bottom, Top)\n# define YY_REDUCE_PRINT(Rule)\n#endif /* !YYDEBUG */\n\n\n/* YYINITDEPTH -- initial size of the parser's stacks.  */\n#ifndef YYINITDEPTH\n# define YYINITDEPTH 200\n#endif\n\n/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only\n   if the built-in stack extension method is used).\n\n   Do not make this value too large; the results are undefined if\n   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)\n   evaluated with infinite-precision integer arithmetic.  */\n\n#ifndef YYMAXDEPTH\n# define YYMAXDEPTH 10000\n#endif\n\n\n#if YYERROR_VERBOSE\n\n# ifndef yystrlen\n#  if defined __GLIBC__ && defined _STRING_H\n#   define yystrlen strlen\n#  else\n/* Return the length of YYSTR.  */\nstatic YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}\n#  endif\n# endif\n\n# ifndef yystpcpy\n#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE\n#   define yystpcpy stpcpy\n#  else\n/* Copy YYSRC to YYDEST, returning the address of the terminating '\\0' in\n   YYDEST.  */\nstatic char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}\n#  endif\n# endif\n\n# ifndef yytnamerr\n/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\nstatic YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return (YYSIZE_T) (yystpcpy (yyres, yystr) - yyres);\n}\n# endif\n\n/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message\n   about the unexpected token YYTOKEN for the state stack whose top is\n   YYSSP.\n\n   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is\n   not large enough to hold the message.  In that case, also set\n   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the\n   required number of bytes is too large to store.  */\nstatic int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n    default: /* Avoid compiler warnings. */\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}\n#endif /* YYERROR_VERBOSE */\n\n/*-----------------------------------------------.\n| Release the memory associated to this symbol.  |\n`-----------------------------------------------*/\n\nstatic void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, void *scanner, struct yang_parameter *param)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yylocationp);\n  YYUSE (scanner);\n  YYUSE (param);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 115: /* tmp_string  */\n\n      { free((((*yyvaluep).p_str)) ? *((*yyvaluep).p_str) : NULL); }\n\n        break;\n\n    case 210: /* pattern_arg_str  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 399: /* semicolom  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 401: /* curly_bracket_open  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 405: /* string_opt_part1  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 430: /* type_ext_alloc  */\n\n      { yang_type_free(param->module->ctx, ((*yyvaluep).v)); }\n\n        break;\n\n    case 431: /* typedef_ext_alloc  */\n\n      { yang_type_free(param->module->ctx, &((struct lys_tpdf *)((*yyvaluep).v))->type); }\n\n        break;\n\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}\n\n\n\n\n/*----------.\n| yyparse.  |\n`----------*/\n\nint\nyyparse (void *scanner, struct yang_parameter *param)\n{\n/* The lookahead symbol.  */\nint yychar;\nchar *s = NULL, *tmp_s = NULL, *ext_name = NULL;\nstruct lys_module *trg = NULL;\nstruct lys_node *tpdf_parent = NULL, *data_node = NULL;\nstruct lys_ext_instance_complex *ext_instance = NULL;\nint is_ext_instance;\nvoid *actual = NULL;\nenum yytokentype backup_type, actual_type = MODULE_KEYWORD;\nint64_t cnt_val = 0;\nint is_value = 0;\nvoid *yang_type = NULL;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n/* Location data for the lookahead symbol.  */\nstatic YYLTYPE yyloc_default\n# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL\n  = { 1, 1, 1, 1 }\n# endif\n;\nYYLTYPE yylloc = yyloc_default;\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n       'yyls': related to locations.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    /* The location stack.  */\n    YYLTYPE yylsa[YYINITDEPTH];\n    YYLTYPE *yyls;\n    YYLTYPE *yylsp;\n\n    /* The locations where the error started and ended.  */\n    YYLTYPE yyerror_range[3];\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n  YYLTYPE yyloc;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yylsp = yyls = yylsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n\n/* User initialization code.  */\n\n{ yylloc.last_column = 0;\n                  if (param->flags & EXT_INSTANCE_SUBSTMT) {\n                    is_ext_instance = 1;\n                    ext_instance = (struct lys_ext_instance_complex *)param->actual_node;\n                    ext_name = (char *)param->data_node;\n                  } else {\n                    is_ext_instance = 0;\n                  }\n                  yylloc.last_line = is_ext_instance;     /* HACK for flex - return SUBMODULE_KEYWORD or SUBMODULE_EXT_KEYWORD */\n                  param->value = &s;\n                  param->data_node = (void **)&data_node;\n                  param->actual_node = &actual;\n                  backup_type = NODE;\n                  trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;\n                }\n\n\n  yylsp[0] = yylloc;\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = (yytype_int16) yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n        YYLTYPE *yyls1 = yyls;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yyls1, yysize * sizeof (*yylsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n        yyls = yyls1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n        YYSTACK_RELOCATE (yyls_alloc, yyls);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n      yylsp = yyls + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, &yylloc, scanner);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n  *++yylsp = yylloc;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n  /* Default location. */\n  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);\n  yyerror_range[1] = yyloc;\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 5:\n\n    { if (yyget_text(scanner)[0] == '\"') {\n                      char *tmp;\n\n                      s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {\n                        YYABORT;\n                      }\n                      s = tmp;\n                    } else {\n                      s = calloc(1, yyget_leng(scanner) - 1);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);\n                    }\n                    (yyval.p_str) = &s;\n                  }\n\n    break;\n\n  case 8:\n\n    { if (yyget_leng(scanner) > 2) {\n                int length_s = strlen(s), length_tmp = yyget_leng(scanner);\n                char *tmp;\n\n                tmp = realloc(s, length_s + length_tmp - 1);\n                if (!tmp) {\n                  LOGMEM(trg->ctx);\n                  YYABORT;\n                }\n                s = tmp;\n                if (yyget_text(scanner)[0] == '\"') {\n                  if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {\n                    YYABORT;\n                  }\n                  s = tmp;\n                } else {\n                  memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);\n                  s[length_s + length_tmp - 2] = '\\0';\n                }\n              }\n            }\n\n    break;\n\n  case 10:\n\n    { if (param->submodule) {\n                                       free(s);\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"module\");\n                                       YYABORT;\n                                     }\n                                     trg = param->module;\n                                     yang_read_common(trg,s,MODULE_KEYWORD);\n                                     s = NULL;\n                                     actual_type = MODULE_KEYWORD;\n                                   }\n\n    break;\n\n  case 12:\n\n    { if (!param->module->ns) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"namespace\", \"module\");\n                                            YYABORT;\n                                          }\n                                          if (!param->module->prefix) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"module\");\n                                            YYABORT;\n                                          }\n                                        }\n\n    break;\n\n  case 13:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 14:\n\n    { if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {\n                                              YYABORT;\n                                            }\n                                            (yyval.i) = 1;\n                                            s = NULL;\n                                          }\n\n    break;\n\n  case 15:\n\n    { if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 16:\n\n    { if (yang_read_prefix(trg, NULL, s)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 17:\n\n    { if (!param->submodule) {\n                                          free(s);\n                                          LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);\n                                          YYABORT;\n                                        }\n                                        trg = (struct lys_module *)param->submodule;\n                                        yang_read_common(trg,s,MODULE_KEYWORD);\n                                        s = NULL;\n                                        actual_type = SUBMODULE_KEYWORD;\n                                      }\n\n    break;\n\n  case 19:\n\n    { if (!param->submodule->prefix) {\n                                                  LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                                  YYABORT;\n                                                }\n                                                if (!(yyvsp[0].i)) {\n                                                  /* check version compatibility with the main module */\n                                                  if (param->module->version > 1) {\n                                                      LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                                                      YYABORT;\n                                                  }\n                                                }\n                                              }\n\n    break;\n\n  case 20:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 21:\n\n    { if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {\n                                                 YYABORT;\n                                               }\n                                               (yyval.i) = 1;\n                                               s = NULL;\n                                             }\n\n    break;\n\n  case 23:\n\n    { backup_type = actual_type;\n                           actual_type = YANG_VERSION_KEYWORD;\n                         }\n\n    break;\n\n  case 25:\n\n    { backup_type = actual_type;\n                            actual_type = NAMESPACE_KEYWORD;\n                          }\n\n    break;\n\n  case 30:\n\n    { actual_type = (yyvsp[-4].token);\n                   backup_type = NODE;\n                   actual = NULL;\n                 }\n\n    break;\n\n  case 31:\n\n    { YANG_ADDELEM(trg->imp, trg->imp_size, \"imports\");\n                                     /* HACK for unres */\n                                     ((struct lys_import *)actual)->module = (struct lys_module *)s;\n                                     s = NULL;\n                                     (yyval.token) = actual_type;\n                                     actual_type = IMPORT_KEYWORD;\n                                   }\n\n    break;\n\n  case 32:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 33:\n\n    { if (yang_read_prefix(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 34:\n\n    { if (trg->version != 2) {\n                                          LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                          free(s);\n                                          YYABORT;\n                                        }\n                                        if (yang_read_description(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        (yyval.i) = (yyvsp[-1].i);\n                                      }\n\n    break;\n\n  case 35:\n\n    { if (trg->version != 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      if (yang_read_reference(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      (yyval.i) = (yyvsp[-1].i);\n                                    }\n\n    break;\n\n  case 36:\n\n    { if ((yyvsp[-1].i)) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"import\");\n                                            free(s);\n                                            YYABORT;\n                                          }\n                                          memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);\n                                          free(s);\n                                          s = NULL;\n                                          (yyval.i) = 1;\n                                        }\n\n    break;\n\n  case 37:\n\n    { YANG_ADDELEM(trg->inc, trg->inc_size, \"includes\");\n                                     /* HACK for unres */\n                                     ((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;\n                                     s = NULL;\n                                     (yyval.token) = actual_type;\n                                     actual_type = INCLUDE_KEYWORD;\n                                   }\n\n    break;\n\n  case 38:\n\n    { actual_type = (yyvsp[-1].token);\n                                                                backup_type = NODE;\n                                                                actual = NULL;\n                                                              }\n\n    break;\n\n  case 41:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 42:\n\n    { if (trg->version != 2) {\n                                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                           free(s);\n                                           YYABORT;\n                                         }\n                                         if (yang_read_description(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                            YYABORT;\n                                         }\n                                         s = NULL;\n                                         (yyval.i) = (yyvsp[-1].i);\n                                       }\n\n    break;\n\n  case 43:\n\n    { if (trg->version != 2) {\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                         free(s);\n                                         YYABORT;\n                                       }\n                                       if (yang_read_reference(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       (yyval.i) = (yyvsp[-1].i);\n                                     }\n\n    break;\n\n  case 44:\n\n    { if ((yyvsp[-1].i)) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"include\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);\n                                           free(s);\n                                           s = NULL;\n                                           (yyval.i) = 1;\n                                         }\n\n    break;\n\n  case 45:\n\n    { backup_type = actual_type;\n                                  actual_type = REVISION_DATE_KEYWORD;\n                                }\n\n    break;\n\n  case 47:\n\n    { (yyval.token) = actual_type;\n                                         if (is_ext_instance) {\n                                           if (yang_read_extcomplex_str(trg, ext_instance, \"belongs-to\", ext_name, s,\n                                                                        0, LY_STMT_BELONGSTO)) {\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           if (param->submodule->prefix) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {\n                                             LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"belongs-to\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           free(s);\n                                         }\n                                         s = NULL;\n                                         actual_type = BELONGS_TO_KEYWORD;\n                                       }\n\n    break;\n\n  case 48:\n\n    { if (is_ext_instance) {\n                         if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", \"belongs-to\", s,\n                                                      LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {\n                           YYABORT;\n                         }\n                       } else {\n                         if (yang_read_prefix(trg, NULL, s)) {\n                           YYABORT;\n                         }\n                       }\n                       s = NULL;\n                       actual_type = (yyvsp[-4].token);\n                     }\n\n    break;\n\n  case 49:\n\n    { backup_type = actual_type;\n                             actual_type = PREFIX_KEYWORD;\n                           }\n\n    break;\n\n  case 52:\n\n    { if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 53:\n\n    { if (yang_read_common(trg, s, CONTACT_KEYWORD)) {\n                                 YYABORT;\n                               }\n                               s = NULL;\n                             }\n\n    break;\n\n  case 54:\n\n    { if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 55:\n\n    { if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                   YYABORT;\n                                 }\n                                 s=NULL;\n                               }\n\n    break;\n\n  case 56:\n\n    { backup_type = actual_type;\n                           actual_type = ORGANIZATION_KEYWORD;\n                         }\n\n    break;\n\n  case 58:\n\n    { backup_type = actual_type;\n                      actual_type = CONTACT_KEYWORD;\n                    }\n\n    break;\n\n  case 60:\n\n    { backup_type = actual_type;\n                          actual_type = DESCRIPTION_KEYWORD;\n                        }\n\n    break;\n\n  case 62:\n\n    { backup_type = actual_type;\n                        actual_type = REFERENCE_KEYWORD;\n                      }\n\n    break;\n\n  case 64:\n\n    { if (trg->rev_size) {\n                                      struct lys_revision *tmp;\n\n                                      tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);\n                                      if (!tmp) {\n                                        LOGMEM(trg->ctx);\n                                        YYABORT;\n                                      }\n                                      trg->rev = tmp;\n                                    }\n                                  }\n\n    break;\n\n  case 65:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  if (!is_ext_instance) {\n                                    YANG_ADDELEM(trg->rev, trg->rev_size, \"revisions\");\n                                  }\n                                  memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);\n                                  free(s);\n                                  s = NULL;\n                                  actual_type = REVISION_KEYWORD;\n                                }\n\n    break;\n\n  case 67:\n\n    { int i;\n\n                                                /* check uniqueness of the revision date - not required by RFC */\n                                                for (i = 0; i < (trg->rev_size - 1); i++) {\n                                                  if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {\n                                                    LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\",\n                                                           trg->rev[trg->rev_size - 1].date);\n                                                    break;\n                                                  }\n                                                }\n                                              }\n\n    break;\n\n  case 68:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                                                                     actual = (yyvsp[-1].backup_token).actual;\n                                                                   }\n\n    break;\n\n  case 72:\n\n    { if (yang_read_description(trg, actual, s, \"revision\",REVISION_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 73:\n\n    { if (yang_read_reference(trg, actual, s, \"revision\", REVISION_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 74:\n\n    { s = strdup(yyget_text(scanner));\n                              if (!s) {\n                                LOGMEM(trg->ctx);\n                                YYABORT;\n                              }\n                              if (lyp_check_date(trg->ctx, s)) {\n                                  free(s);\n                                  YYABORT;\n                              }\n                            }\n\n    break;\n\n  case 76:\n\n    { if (lyp_check_date(trg->ctx, s)) {\n                   free(s);\n                   YYABORT;\n               }\n             }\n\n    break;\n\n  case 77:\n\n    { void *tmp;\n\n                             if (trg->tpdf_size) {\n                               tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->tpdf = tmp;\n                             }\n\n                             if (trg->features_size) {\n                               tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->features = tmp;\n                             }\n\n                             if (trg->ident_size) {\n                               tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->ident = tmp;\n                             }\n\n                             if (trg->augment_size) {\n                               tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->augment = tmp;\n                             }\n\n                             if (trg->extensions_size) {\n                               tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->extensions = tmp;\n                             }\n                           }\n\n    break;\n\n  case 78:\n\n    { /* check the module with respect to the context now */\n                         if (!param->submodule) {\n                           switch (lyp_ctx_check_module(trg)) {\n                           case -1:\n                             YYABORT;\n                           case 0:\n                             break;\n                           case 1:\n                             /* it's already there */\n                             param->flags |= YANG_EXIST_MODULE;\n                             YYABORT;\n                           }\n                         }\n                         param->flags &= (~YANG_REMOVE_IMPORT);\n                         if (yang_check_imports(trg, param->unres)) {\n                           YYABORT;\n                         }\n                         actual = NULL;\n                       }\n\n    break;\n\n  case 79:\n\n    { actual = NULL; }\n\n    break;\n\n  case 90:\n\n    { (yyval.backup_token).token = actual_type;\n                                        (yyval.backup_token).actual = actual;\n                                        YANG_ADDELEM(trg->extensions, trg->extensions_size, \"extensions\");\n                                        trg->extensions_size--;\n                                        ((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                        ((struct lys_ext *)actual)->module = trg;\n                                        if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {\n                                          trg->extensions_size++;\n                                          YYABORT;\n                                        }\n                                        trg->extensions_size++;\n                                        s = NULL;\n                                        actual_type = EXTENSION_KEYWORD;\n                                      }\n\n    break;\n\n  case 91:\n\n    { struct lys_ext *ext = actual;\n                  ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);\n                  actual_type = (yyvsp[-1].backup_token).token;\n                  actual = (yyvsp[-1].backup_token).actual;\n                }\n\n    break;\n\n  case 96:\n\n    { if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"extension\");\n                                        YYABORT;\n                                      }\n                                      ((struct lys_ext *)actual)->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 97:\n\n    { if (yang_read_description(trg, actual, s, \"extension\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 98:\n\n    { if (yang_read_reference(trg, actual, s, \"extension\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 99:\n\n    { (yyval.token) = actual_type;\n                                   if (is_ext_instance) {\n                                     if (yang_read_extcomplex_str(trg, ext_instance, \"argument\", ext_name, s,\n                                                                  0, LY_STMT_ARGUMENT)) {\n                                       YYABORT;\n                                     }\n                                   } else {\n                                     if (((struct lys_ext *)actual)->argument) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"argument\", \"extension\");\n                                        free(s);\n                                        YYABORT;\n                                     }\n                                     ((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);\n                                   }\n                                   s = NULL;\n                                   actual_type = ARGUMENT_KEYWORD;\n                                 }\n\n    break;\n\n  case 100:\n\n    { actual_type = (yyvsp[-1].token); }\n\n    break;\n\n  case 103:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                       backup_type = actual_type;\n                                       actual_type = YIN_ELEMENT_KEYWORD;\n                                     }\n\n    break;\n\n  case 105:\n\n    { if (is_ext_instance) {\n         int c;\n         const char ***p;\n         uint8_t *val;\n         struct lyext_substmt *info;\n\n         c = 0;\n         p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);\n         if (info->cardinality >= LY_STMT_CARD_SOME) {\n           /* get the index in the array to add new item */\n           for (c = 0; p[0][c + 1]; c++);\n           val = (uint8_t *)p[1];\n         } else {\n           val = (uint8_t *)(p + 1);\n         }\n         val[c] = ((yyvsp[-1].uint) == LYS_YINELEM) ? 1 : 2;\n       } else {\n         ((struct lys_ext *)actual)->flags |= (yyvsp[-1].uint);\n       }\n     }\n\n    break;\n\n  case 106:\n\n    { (yyval.uint) = LYS_YINELEM; }\n\n    break;\n\n  case 107:\n\n    { (yyval.uint) = 0; }\n\n    break;\n\n  case 108:\n\n    { if (!strcmp(s, \"true\")) {\n                 (yyval.uint) = LYS_YINELEM;\n               } else if (!strcmp(s, \"false\")) {\n                 (yyval.uint) = 0;\n               } else {\n                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\n    break;\n\n  case 109:\n\n    { (yyval.i) = (yyvsp[0].i);\n                             backup_type = actual_type;\n                             actual_type = STATUS_KEYWORD;\n                           }\n\n    break;\n\n  case 110:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 111:\n\n    { (yyval.i) = LYS_STATUS_CURR; }\n\n    break;\n\n  case 112:\n\n    { (yyval.i) = LYS_STATUS_OBSLT; }\n\n    break;\n\n  case 113:\n\n    { (yyval.i) = LYS_STATUS_DEPRC; }\n\n    break;\n\n  case 114:\n\n    { if (!strcmp(s, \"current\")) {\n                 (yyval.i) = LYS_STATUS_CURR;\n               } else if (!strcmp(s, \"obsolete\")) {\n                 (yyval.i) = LYS_STATUS_OBSLT;\n               } else if (!strcmp(s, \"deprecated\")) {\n                 (yyval.i) = LYS_STATUS_DEPRC;\n               } else {\n                 LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\n    break;\n\n  case 115:\n\n    { /* check uniqueness of feature's names */\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      (yyval.backup_token).token = actual_type;\n                                      (yyval.backup_token).actual = actual;\n                                      YANG_ADDELEM(trg->features, trg->features_size, \"features\");\n                                      ((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);\n                                      ((struct lys_feature *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = FEATURE_KEYWORD;\n                                    }\n\n    break;\n\n  case 116:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n                actual_type = (yyvsp[-1].backup_token).token;\n              }\n\n    break;\n\n  case 118:\n\n    { struct lys_iffeature *tmp;\n\n          if (((struct lys_feature *)actual)->iffeature_size) {\n            tmp = realloc(((struct lys_feature *)actual)->iffeature,\n                          ((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);\n            if (!tmp) {\n              LOGMEM(trg->ctx);\n              YYABORT;\n            }\n            ((struct lys_feature *)actual)->iffeature = tmp;\n          }\n        }\n\n    break;\n\n  case 121:\n\n    { if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"feature\");\n                                      YYABORT;\n                                    }\n                                    ((struct lys_feature *)actual)->flags |= (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 122:\n\n    { if (yang_read_description(trg, actual, s, \"feature\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 123:\n\n    { if (yang_read_reference(trg, actual, s, \"feature\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 124:\n\n    { (yyval.backup_token).token = actual_type;\n                         (yyval.backup_token).actual = actual;\n                         switch (actual_type) {\n                         case FEATURE_KEYWORD:\n                           YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,\n                                        ((struct lys_feature *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case IDENTITY_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"identity\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,\n                                        ((struct lys_ident *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case ENUM_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,\n                                        ((struct lys_type_enum *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case BIT_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"bit\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,\n                                        ((struct lys_type_bit *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case REFINE_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,\n                                        ((struct lys_refine *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case EXTENSION_INSTANCE:\n                           /* nothing change */\n                           break;\n                         default:\n                           /* lys_node_* */\n                           YANG_ADDELEM(((struct lys_node *)actual)->iffeature,\n                                        ((struct lys_node *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         }\n                         ((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;\n                         s = NULL;\n                         actual_type = IF_FEATURE_KEYWORD;\n                       }\n\n    break;\n\n  case 125:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n                   actual_type = (yyvsp[-1].backup_token).token;\n                 }\n\n    break;\n\n  case 128:\n\n    { const char *tmp;\n\n                                       tmp = lydict_insert_zc(trg->ctx, s);\n                                       s = NULL;\n                                       if (dup_identities_check(tmp, trg)) {\n                                         lydict_remove(trg->ctx, tmp);\n                                         YYABORT;\n                                       }\n                                       (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       YANG_ADDELEM(trg->ident, trg->ident_size, \"identities\");\n                                       ((struct lys_ident *)actual)->name = tmp;\n                                       ((struct lys_ident *)actual)->module = trg;\n                                       actual_type = IDENTITY_KEYWORD;\n                                     }\n\n    break;\n\n  case 129:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n                 actual_type = (yyvsp[-1].backup_token).token;\n               }\n\n    break;\n\n  case 131:\n\n    { void *tmp;\n\n           if (((struct lys_ident *)actual)->base_size) {\n             tmp = realloc(((struct lys_ident *)actual)->base,\n                           ((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->base = tmp;\n           }\n\n           if (((struct lys_ident *)actual)->iffeature_size) {\n             tmp = realloc(((struct lys_ident *)actual)->iffeature,\n                           ((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 133:\n\n    { void *identity;\n\n                                   if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {\n                                     free(s);\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"base\", \"identity\");\n                                     YYABORT;\n                                   }\n                                   identity = actual;\n                                   YANG_ADDELEM(((struct lys_ident *)actual)->base,\n                                                ((struct lys_ident *)actual)->base_size, \"bases\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   s = NULL;\n                                   actual = identity;\n                                 }\n\n    break;\n\n  case 135:\n\n    { if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"identity\");\n                                       YYABORT;\n                                     }\n                                     ((struct lys_ident *)actual)->flags |= (yyvsp[0].i);\n                                   }\n\n    break;\n\n  case 136:\n\n    { if (yang_read_description(trg, actual, s, \"identity\", NODE)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 137:\n\n    { if (yang_read_reference(trg, actual, s, \"identity\", NODE)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 138:\n\n    { backup_type = actual_type;\n                                   actual_type = BASE_KEYWORD;\n                                 }\n\n    break;\n\n  case 140:\n\n    { tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;\n                                      (yyval.backup_token).token = actual_type;\n                                      (yyval.backup_token).actual = actual;\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      switch (actual_type) {\n                                      case MODULE_KEYWORD:\n                                      case SUBMODULE_KEYWORD:\n                                        YANG_ADDELEM(trg->tpdf, trg->tpdf_size, \"typedefs\");\n                                        break;\n                                      case GROUPING_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_grp *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case CONTAINER_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_container *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case LIST_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_list *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case RPC_KEYWORD:\n                                      case ACTION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case INPUT_KEYWORD:\n                                      case OUTPUT_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_inout *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case NOTIFICATION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_notif *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case EXTENSION_INSTANCE:\n                                        /* typedef is already allocated */\n                                        break;\n                                      default:\n                                        /* another type of nodetype is error*/\n                                        LOGINT(trg->ctx);\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      ((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                      ((struct lys_tpdf *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = TYPEDEF_KEYWORD;\n                                    }\n\n    break;\n\n  case 141:\n\n    { if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {\n                      LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"typedef\");\n                      YYABORT;\n                    }\n                    actual_type = (yyvsp[-4].backup_token).token;\n                    actual = (yyvsp[-4].backup_token).actual;\n                  }\n\n    break;\n\n  case 142:\n\n    { (yyval.nodes).node.ptr_tpdf = actual;\n                            (yyval.nodes).node.flag = 0;\n                          }\n\n    break;\n\n  case 143:\n\n    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;\n                                       (yyval.nodes) = (yyvsp[-2].nodes);\n                                     }\n\n    break;\n\n  case 144:\n\n    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n\n    break;\n\n  case 145:\n\n    { if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n\n    break;\n\n  case 146:\n\n    { if ((yyvsp[-1].nodes).node.ptr_tpdf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"typedef\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_tpdf->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 147:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 148:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 149:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 150:\n\n    { (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       actual_type = TYPE_KEYWORD;\n                                     }\n\n    break;\n\n  case 153:\n\n    { if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&\n                                         ((struct yang_type *)actual)->type->info.str.pat_count) {\n                                       void *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,\n                                                     ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.str.patterns = tmp;\n\n#ifdef LY_ENABLED_CACHE\n                                       if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,\n                                                       2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;\n                                       }\n#endif\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {\n                                       struct lys_type *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,\n                                                     ((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.uni.types = tmp;\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {\n                                       struct lys_ident **tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,\n                                                     ((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.ident.ref = tmp;\n                                     }\n                                   }\n\n    break;\n\n  case 157:\n\n    { if (yang_read_require_instance(trg->ctx, actual, (yyvsp[0].i))) {\n                                                 YYABORT;\n                                               }\n                                             }\n\n    break;\n\n  case 158:\n\n    { /* leafref_specification */\n                                   if (yang_read_leafref_path(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 159:\n\n    { /* identityref_specification */\n                                   if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {\n                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");\n                                     return EXIT_FAILURE;\n                                   }\n                                   ((struct yang_type *)actual)->base = LY_TYPE_IDENT;\n                                   yang_type = actual;\n                                   YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,\n                                                ((struct yang_type *)actual)->type->info.ident.count, \"identity refs\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   actual = yang_type;\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 162:\n\n    { if (yang_read_fraction(trg->ctx, actual, (yyvsp[0].uint))) {\n                                                YYABORT;\n                                              }\n                                            }\n\n    break;\n\n  case 165:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                                   actual = (yyvsp[-1].backup_token).actual;\n                                 }\n\n    break;\n\n  case 166:\n\n    { struct yang_type *stype = (struct yang_type *)actual;\n\n                         (yyval.backup_token).token = actual_type;\n                         (yyval.backup_token).actual = actual;\n                         if (stype->base != 0 && stype->base != LY_TYPE_UNION) {\n                           LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected type statement.\");\n                           YYABORT;\n                         }\n                         stype->base = LY_TYPE_UNION;\n                         if (strcmp(stype->name, \"union\")) {\n                           /* type can be a substatement only in \"union\" type, not in derived types */\n                           LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"derived type\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, \"union types\")\n                         actual_type = UNION_KEYWORD;\n                       }\n\n    break;\n\n  case 167:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                               backup_type = actual_type;\n                                               actual_type = FRACTION_DIGITS_KEYWORD;\n                                             }\n\n    break;\n\n  case 168:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 169:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 170:\n\n    { char *endptr = NULL;\n               unsigned long val;\n               errno = 0;\n\n               val = strtoul(s, &endptr, 10);\n               if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                 LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"fraction-digits\");\n                 free(s);\n                 s = NULL;\n                 YYABORT;\n               }\n               (yyval.uint) = (uint32_t) val;\n               free(s);\n               s =NULL;\n             }\n\n    break;\n\n  case 171:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n               actual_type = (yyvsp[-1].backup_token).token;\n             }\n\n    break;\n\n  case 172:\n\n    { (yyval.backup_token).token = actual_type;\n                         (yyval.backup_token).actual = actual;\n                         if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {\n                           YYABORT;\n                         }\n                         actual_type = LENGTH_KEYWORD;\n                         s = NULL;\n                       }\n\n    break;\n\n  case 175:\n\n    { switch (actual_type) {\n                               case MUST_KEYWORD:\n                                 (yyval.str) = \"must\";\n                                 break;\n                               case LENGTH_KEYWORD:\n                                 (yyval.str) = \"length\";\n                                 break;\n                               case RANGE_KEYWORD:\n                                 (yyval.str) = \"range\";\n                                 break;\n                               default:\n                                 LOGINT(trg->ctx);\n                                 YYABORT;\n                                 break;\n                               }\n                             }\n\n    break;\n\n  case 176:\n\n    { if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 177:\n\n    { if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 178:\n\n    { if (yang_read_description(trg, actual, s, (yyvsp[-1].str), NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 179:\n\n    { if (yang_read_reference(trg, actual, s, (yyvsp[-1].str), NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 180:\n\n    { (yyval.backup_token).token = actual_type;\n                   (yyval.backup_token).actual = actual;\n                 }\n\n    break;\n\n  case 181:\n\n    {struct lys_restr *pattern = actual;\n                                                                        actual = NULL;\n#ifdef LY_ENABLED_CACHE\n                                                                        if ((yyvsp[-2].backup_token).token != EXTENSION_INSTANCE &&\n                                                                            !(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {\n                                                                          unsigned int c = 2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1);\n                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          ++c;\n                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];\n                                                                        }\n#endif\n                                                                        if (yang_read_pattern(trg->ctx, pattern, actual, (yyvsp[-1].str), (yyvsp[0].ch))) {\n                                                                          YYABORT;\n                                                                        }\n                                                                        actual_type = (yyvsp[-2].backup_token).token;\n                                                                        actual = (yyvsp[-2].backup_token).actual;\n                                                                      }\n\n    break;\n\n  case 182:\n\n    { if (actual_type != EXTENSION_INSTANCE) {\n                            if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {\n                              free(s);\n                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected pattern statement.\");\n                              YYABORT;\n                            }\n                            ((struct yang_type *)actual)->base = LY_TYPE_STRING;\n                            YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,\n                                         ((struct yang_type *)actual)->type->info.str.pat_count, \"patterns\");\n                          }\n                          (yyval.str) = s;\n                          s = NULL;\n                          actual_type = PATTERN_KEYWORD;\n                        }\n\n    break;\n\n  case 183:\n\n    { (yyval.ch) = 0x06; }\n\n    break;\n\n  case 184:\n\n    { (yyval.ch) = (yyvsp[-1].ch); }\n\n    break;\n\n  case 185:\n\n    { (yyval.ch) = 0x06; /* ACK */ }\n\n    break;\n\n  case 186:\n\n    { if (trg->version < 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"modifier\");\n                                        YYABORT;\n                                      }\n                                      if ((yyvsp[-1].ch) != 0x06) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"modifier\", \"pattern\");\n                                        YYABORT;\n                                      }\n                                      (yyval.ch) = (yyvsp[0].ch);\n                                    }\n\n    break;\n\n  case 187:\n\n    { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 188:\n\n    { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 189:\n\n    { if (yang_read_description(trg, actual, s, \"pattern\", NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 190:\n\n    { if (yang_read_reference(trg, actual, s, \"pattern\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 191:\n\n    { backup_type = actual_type;\n                       actual_type = MODIFIER_KEYWORD;\n                     }\n\n    break;\n\n  case 192:\n\n    { if (!strcmp(s, \"invert-match\")) {\n                                                             (yyval.ch) = 0x15;\n                                                             free(s);\n                                                             s = NULL;\n                                                           } else {\n                                                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                                                             free(s);\n                                                             YYABORT;\n                                                           }\n                                                         }\n\n    break;\n\n  case 193:\n\n    { struct lys_type_enum * tmp;\n\n                                                   cnt_val = 0;\n                                                   tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,\n                                                                 ((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);\n                                                   if (!tmp) {\n                                                     LOGMEM(trg->ctx);\n                                                     YYABORT;\n                                                   }\n                                                   ((struct yang_type *)actual)->type->info.enums.enm = tmp;\n                                                 }\n\n    break;\n\n  case 196:\n\n    { if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n               YYABORT;\n             }\n             actual = (yyvsp[-1].backup_token).actual;\n             actual_type = (yyvsp[-1].backup_token).token;\n           }\n\n    break;\n\n  case 197:\n\n    { (yyval.backup_token).token = actual_type;\n                       (yyval.backup_token).actual = yang_type = actual;\n                       YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, \"enums\");\n                       if (yang_read_enum(trg->ctx, yang_type, actual, s)) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       is_value = 0;\n                       actual_type = ENUM_KEYWORD;\n                     }\n\n    break;\n\n  case 199:\n\n    { if (((struct lys_type_enum *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_enum *)actual)->iffeature,\n                           ((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_enum *)actual)->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 202:\n\n    { if (is_value) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"value\", \"enum\");\n                                  YYABORT;\n                                }\n                                ((struct lys_type_enum *)actual)->value = (yyvsp[0].i);\n\n                                /* keep the highest enum value for automatic increment */\n                                if ((yyvsp[0].i) >= cnt_val) {\n                                  cnt_val = (yyvsp[0].i) + 1;\n                                }\n                                is_value = 1;\n                              }\n\n    break;\n\n  case 203:\n\n    { if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"enum\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_enum *)actual)->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 204:\n\n    { if (yang_read_description(trg, actual, s, \"enum\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 205:\n\n    { if (yang_read_reference(trg, actual, s, \"enum\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 206:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                   backup_type = actual_type;\n                                   actual_type = VALUE_KEYWORD;\n                                 }\n\n    break;\n\n  case 207:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 208:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 209:\n\n    { /* convert it to int32_t */\n                int64_t val;\n                char *endptr;\n\n                val = strtoll(s, &endptr, 10);\n                if (val < INT32_MIN || val > INT32_MAX || *endptr) {\n                    LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"value\");\n                    free(s);\n                    YYABORT;\n                }\n                free(s);\n                s = NULL;\n                (yyval.i) = (int32_t) val;\n             }\n\n    break;\n\n  case 210:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                                                        actual = (yyvsp[-1].backup_token).actual;\n                                                      }\n\n    break;\n\n  case 213:\n\n    { backup_type = actual_type;\n                         actual_type = PATH_KEYWORD;\n                       }\n\n    break;\n\n  case 215:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                                 backup_type = actual_type;\n                                                 actual_type = REQUIRE_INSTANCE_KEYWORD;\n                                               }\n\n    break;\n\n  case 216:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 217:\n\n    { (yyval.i) = 1; }\n\n    break;\n\n  case 218:\n\n    { (yyval.i) = -1; }\n\n    break;\n\n  case 219:\n\n    { if (!strcmp(s,\"true\")) {\n                  (yyval.i) = 1;\n                } else if (!strcmp(s,\"false\")) {\n                  (yyval.i) = -1;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"require-instance\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 220:\n\n    { struct lys_type_bit * tmp;\n\n                                         cnt_val = 0;\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,\n                                                       ((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.bits.bit = tmp;\n                                       }\n\n    break;\n\n  case 223:\n\n    { if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n                      YYABORT;\n                    }\n                    actual = (yyvsp[-2].backup_token).actual;\n                    actual_type = (yyvsp[-2].backup_token).token;\n                  }\n\n    break;\n\n  case 224:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = yang_type = actual;\n                                  YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,\n                                               ((struct yang_type *)actual)->type->info.bits.count, \"bits\");\n                                  if (yang_read_bit(trg->ctx, yang_type, actual, s)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                  is_value = 0;\n                                  actual_type = BIT_KEYWORD;\n                                }\n\n    break;\n\n  case 226:\n\n    { if (((struct lys_type_bit *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_bit *)actual)->iffeature,\n                           ((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_bit *)actual)->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 229:\n\n    { if (is_value) {\n                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"position\", \"bit\");\n                                    YYABORT;\n                                  }\n                                  ((struct lys_type_bit *)actual)->pos = (yyvsp[0].uint);\n\n                                  /* keep the highest position value for automatic increment */\n                                  if ((yyvsp[0].uint) >= cnt_val) {\n                                    cnt_val = (yyvsp[0].uint) + 1;\n                                  }\n                                  is_value = 1;\n                                }\n\n    break;\n\n  case 230:\n\n    { if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"bit\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_bit *)actual)->flags |= (yyvsp[0].i);\n                              }\n\n    break;\n\n  case 231:\n\n    { if (yang_read_description(trg, actual, s, \"bit\", NODE)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n\n    break;\n\n  case 232:\n\n    { if (yang_read_reference(trg, actual, s, \"bit\", NODE)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 233:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                             backup_type = actual_type;\n                                             actual_type = POSITION_KEYWORD;\n                                           }\n\n    break;\n\n  case 234:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 235:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 236:\n\n    { /* convert it to uint32_t */\n                unsigned long val;\n                char *endptr = NULL;\n                errno = 0;\n\n                val = strtoul(s, &endptr, 10);\n                if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"position\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n                (yyval.uint) = (uint32_t) val;\n              }\n\n    break;\n\n  case 237:\n\n    { backup_type = actual_type;\n                            actual_type = ERROR_MESSAGE_KEYWORD;\n                          }\n\n    break;\n\n  case 239:\n\n    { backup_type = actual_type;\n                            actual_type = ERROR_APP_TAG_KEYWORD;\n                          }\n\n    break;\n\n  case 241:\n\n    { backup_type = actual_type;\n                    actual_type = UNITS_KEYWORD;\n                  }\n\n    break;\n\n  case 243:\n\n    { backup_type = actual_type;\n                      actual_type = DEFAULT_KEYWORD;\n                    }\n\n    break;\n\n  case 245:\n\n    { (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       data_node = actual;\n                                       actual_type = GROUPING_KEYWORD;\n                                     }\n\n    break;\n\n  case 246:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing grouping statement \\\"%s\\\"\", data_node->name);\n                 actual_type = (yyvsp[-1].backup_token).token;\n                 actual = (yyvsp[-1].backup_token).actual;\n                 data_node = (yyvsp[-1].backup_token).actual;\n               }\n\n    break;\n\n  case 249:\n\n    { (yyval.nodes).grouping = actual; }\n\n    break;\n\n  case 250:\n\n    { if ((yyvsp[-1].nodes).grouping->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).grouping, \"status\", \"grouping\");\n                                       YYABORT;\n                                     }\n                                     (yyvsp[-1].nodes).grouping->flags |= (yyvsp[0].i);\n                                   }\n\n    break;\n\n  case 251:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).grouping, s, \"grouping\", NODE_PRINT)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 252:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).grouping, s, \"grouping\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 257:\n\n    { if (trg->version < 2) {\n                                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).grouping, \"notification\");\n                                                     YYABORT;\n                                                   }\n                                                 }\n\n    break;\n\n  case 266:\n\n    { (yyval.backup_token).token = actual_type;\n                                        (yyval.backup_token).actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = CONTAINER_KEYWORD;\n                                      }\n\n    break;\n\n  case 267:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing container statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-1].backup_token).token;\n                  actual = (yyvsp[-1].backup_token).actual;\n                  data_node = (yyvsp[-1].backup_token).actual;\n                }\n\n    break;\n\n  case 269:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].nodes).container->iffeature_size) {\n              tmp = realloc((yyvsp[-1].nodes).container->iffeature, (yyvsp[-1].nodes).container->iffeature_size * sizeof *(yyvsp[-1].nodes).container->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).container->iffeature = tmp;\n            }\n\n            if ((yyvsp[-1].nodes).container->must_size) {\n              tmp = realloc((yyvsp[-1].nodes).container->must, (yyvsp[-1].nodes).container->must_size * sizeof *(yyvsp[-1].nodes).container->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).container->must = tmp;\n            }\n          }\n\n    break;\n\n  case 270:\n\n    { (yyval.nodes).container = actual; }\n\n    break;\n\n  case 274:\n\n    { if (yang_read_presence(trg, (yyvsp[-1].nodes).container, s)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 275:\n\n    { if ((yyvsp[-1].nodes).container->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, \"config\", \"container\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 276:\n\n    { if ((yyvsp[-1].nodes).container->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, \"status\", \"container\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 277:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).container, s, \"container\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 278:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).container, s, \"container\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 281:\n\n    { if (trg->version < 2) {\n                                                      LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).container, \"notification\");\n                                                      YYABORT;\n                                                    }\n                                                  }\n\n    break;\n\n  case 284:\n\n    { void *tmp;\n\n                  if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {\n                    LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"type\", \"leaf\");\n                    YYABORT;\n                  }\n                  if ((yyvsp[-1].nodes).node.ptr_leaf->dflt && ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_TRUE)) {\n                    /* RFC 6020, 7.6.4 - default statement must not with mandatory true */\n                    LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"mandatory\", \"leaf\");\n                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    YYABORT;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_leaf->iffeature_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->iffeature, (yyvsp[-1].nodes).node.ptr_leaf->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_leaf->iffeature = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_leaf->must_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->must, (yyvsp[-1].nodes).node.ptr_leaf->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_leaf->must = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing leaf statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-4].backup_token).token;\n                  actual = (yyvsp[-4].backup_token).actual;\n                  data_node = (yyvsp[-4].backup_token).actual;\n                }\n\n    break;\n\n  case 285:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LEAF_KEYWORD;\n                                 }\n\n    break;\n\n  case 286:\n\n    { (yyval.nodes).node.ptr_leaf = actual;\n                            (yyval.nodes).node.flag = 0;\n                          }\n\n    break;\n\n  case 289:\n\n    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;\n                                       (yyval.nodes) = (yyvsp[-2].nodes);\n                                     }\n\n    break;\n\n  case 290:\n\n    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n\n    break;\n\n  case 292:\n\n    { if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n\n    break;\n\n  case 293:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"config\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 294:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"mandatory\", \"leaf\");\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 295:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"status\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 296:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 297:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 298:\n\n    { (yyval.backup_token).token = actual_type;\n                                        (yyval.backup_token).actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = LEAF_LIST_KEYWORD;\n                                      }\n\n    break;\n\n  case 299:\n\n    { void *tmp;\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_R) {\n                          /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data\n                           * ignore oredering MASK - 0x7F\n                           */\n                          (yyvsp[-1].nodes).node.ptr_leaflist->flags &= 0x7F;\n                        }\n                        if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {\n                          LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"type\", \"leaf-list\");\n                          YYABORT;\n                        }\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size && (yyvsp[-1].nodes).node.ptr_leaflist->min) {\n                          LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                          LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist,\n                                 \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                          YYABORT;\n                        }\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size) {\n                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->iffeature, (yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->iffeature);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          (yyvsp[-1].nodes).node.ptr_leaflist->iffeature = tmp;\n                        }\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->must_size) {\n                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->must, (yyvsp[-1].nodes).node.ptr_leaflist->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->must);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          (yyvsp[-1].nodes).node.ptr_leaflist->must = tmp;\n                        }\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size) {\n                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->dflt, (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->dflt);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          (yyvsp[-1].nodes).node.ptr_leaflist->dflt = tmp;\n                        }\n\n                        LOGDBG(LY_LDGYANG, \"finished parsing leaf-list statement \\\"%s\\\"\", data_node->name);\n                        actual_type = (yyvsp[-4].backup_token).token;\n                        actual = (yyvsp[-4].backup_token).actual;\n                        data_node = (yyvsp[-4].backup_token).actual;\n                      }\n\n    break;\n\n  case 300:\n\n    { (yyval.nodes).node.ptr_leaflist = actual;\n                                 (yyval.nodes).node.flag = 0;\n                               }\n\n    break;\n\n  case 303:\n\n    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;\n                                            (yyval.nodes) = (yyvsp[-2].nodes);\n                                          }\n\n    break;\n\n  case 304:\n\n    { if (trg->version < 2) {\n                                         free(s);\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"default\");\n                                         YYABORT;\n                                       }\n                                       YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_leaflist->dflt,\n                                                    (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size, \"defaults\");\n                                       (*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);\n                                       s = NULL;\n                                       actual = (yyvsp[-1].nodes).node.ptr_leaflist;\n                                     }\n\n    break;\n\n  case 305:\n\n    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n\n    break;\n\n  case 307:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"config\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 308:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            (yyvsp[-1].nodes).node.ptr_leaflist->min = (yyvsp[0].uint);\n                                            (yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;\n                                            (yyval.nodes) = (yyvsp[-1].nodes);\n                                            if ((yyvsp[-1].nodes).node.ptr_leaflist->max && ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max)) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 309:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"max-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            (yyvsp[-1].nodes).node.ptr_leaflist->max = (yyvsp[0].uint);\n                                            (yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;\n                                            (yyval.nodes) = (yyvsp[-1].nodes);\n                                            if ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"max-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 310:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"ordered by\", \"leaf-list\");\n                                            YYABORT;\n                                          }\n                                          if ((yyvsp[0].i) & LYS_USERORDERED) {\n                                            (yyvsp[-1].nodes).node.ptr_leaflist->flags |= LYS_USERORDERED;\n                                          }\n                                          (yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);\n                                          (yyval.nodes) = (yyvsp[-1].nodes);\n                                        }\n\n    break;\n\n  case 311:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"status\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 312:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 313:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 314:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LIST_KEYWORD;\n                                 }\n\n    break;\n\n  case 315:\n\n    { void *tmp;\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->iffeature_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->iffeature, (yyvsp[-1].nodes).node.ptr_list->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->iffeature = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->must_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->must, (yyvsp[-1].nodes).node.ptr_list->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->must = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->tpdf_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->tpdf, (yyvsp[-1].nodes).node.ptr_list->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->tpdf = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->unique_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->unique);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->unique = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing list statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-4].backup_token).token;\n                  actual = (yyvsp[-4].backup_token).actual;\n                  data_node = (yyvsp[-4].backup_token).actual;\n                }\n\n    break;\n\n  case 316:\n\n    { (yyval.nodes).node.ptr_list = actual;\n                            (yyval.nodes).node.flag = 0;\n                          }\n\n    break;\n\n  case 320:\n\n    { if ((yyvsp[-1].nodes).node.ptr_list->keys) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"key\", \"list\");\n                                  free(s);\n                                  YYABORT;\n                              }\n                              (yyvsp[-1].nodes).node.ptr_list->keys = (struct lys_node_leaf **)s;\n                              (yyval.nodes) = (yyvsp[-1].nodes);\n                              s = NULL;\n                            }\n\n    break;\n\n  case 321:\n\n    { YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size, \"uniques\");\n                                 ((struct lys_unique *)actual)->expr = (const char **)s;\n                                 (yyval.nodes) = (yyvsp[-1].nodes);\n                                 s = NULL;\n                                 actual = (yyvsp[-1].nodes).node.ptr_list;\n                               }\n\n    break;\n\n  case 322:\n\n    { if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"config\", \"list\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 323:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"min-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       (yyvsp[-1].nodes).node.ptr_list->min = (yyvsp[0].uint);\n                                       (yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;\n                                       (yyval.nodes) = (yyvsp[-1].nodes);\n                                       if ((yyvsp[-1].nodes).node.ptr_list->max && ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max)) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 324:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"max-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       (yyvsp[-1].nodes).node.ptr_list->max = (yyvsp[0].uint);\n                                       (yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;\n                                       (yyval.nodes) = (yyvsp[-1].nodes);\n                                       if ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 325:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"ordered by\", \"list\");\n                                       YYABORT;\n                                     }\n                                     if ((yyvsp[0].i) & LYS_USERORDERED) {\n                                       (yyvsp[-1].nodes).node.ptr_list->flags |= LYS_USERORDERED;\n                                     }\n                                     (yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);\n                                     (yyval.nodes) = (yyvsp[-1].nodes);\n                                   }\n\n    break;\n\n  case 326:\n\n    { if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"status\", \"list\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 327:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 328:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 332:\n\n    { if (trg->version < 2) {\n                                                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_list, \"notification\");\n                                                 YYABORT;\n                                               }\n                                             }\n\n    break;\n\n  case 334:\n\n    { (yyval.backup_token).token = actual_type;\n                                     (yyval.backup_token).actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = CHOICE_KEYWORD;\n                                   }\n\n    break;\n\n  case 335:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing choice statement \\\"%s\\\"\", data_node->name);\n               actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n               data_node = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 337:\n\n    { struct lys_iffeature *tmp;\n\n           if (((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_TRUE) && (yyvsp[-1].nodes).node.ptr_choice->dflt) {\n              LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"default\", \"choice\");\n              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"The \\\"default\\\" statement is forbidden on choices with \\\"mandatory\\\".\");\n              YYABORT;\n            }\n\n           if ((yyvsp[-1].nodes).node.ptr_choice->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).node.ptr_choice->iffeature, (yyvsp[-1].nodes).node.ptr_choice->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).node.ptr_choice->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 338:\n\n    { (yyval.nodes).node.ptr_choice = actual;\n                              (yyval.nodes).node.flag = 0;\n                            }\n\n    break;\n\n  case 341:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_CHOICE_DEFAULT) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"default\", \"choice\");\n                                      free(s);\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).node.ptr_choice->dflt = (struct lys_node *) s;\n                                    s = NULL;\n                                    (yyval.nodes) = (yyvsp[-1].nodes);\n                                    (yyval.nodes).node.flag |= LYS_CHOICE_DEFAULT;\n                                  }\n\n    break;\n\n  case 342:\n\n    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"config\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);\n                                   (yyval.nodes) = (yyvsp[-1].nodes);\n                                 }\n\n    break;\n\n  case 343:\n\n    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"mandatory\", \"choice\");\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);\n                                    (yyval.nodes) = (yyvsp[-1].nodes);\n                                  }\n\n    break;\n\n  case 344:\n\n    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"status\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);\n                                   (yyval.nodes) = (yyvsp[-1].nodes);\n                                 }\n\n    break;\n\n  case 345:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        (yyval.nodes) = (yyvsp[-1].nodes);\n                                      }\n\n    break;\n\n  case 346:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      (yyval.nodes) = (yyvsp[-1].nodes);\n                                    }\n\n    break;\n\n  case 356:\n\n    { if (trg->version < 2 ) {\n                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"choice\");\n                     YYABORT;\n                   }\n                 }\n\n    break;\n\n  case 357:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = CASE_KEYWORD;\n                                 }\n\n    break;\n\n  case 358:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing case statement \\\"%s\\\"\", data_node->name);\n             actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n             data_node = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 360:\n\n    { struct lys_iffeature *tmp;\n\n           if ((yyvsp[-1].nodes).cs->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).cs->iffeature, (yyvsp[-1].nodes).cs->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).cs->iffeature = tmp;\n           }\n          }\n\n    break;\n\n  case 361:\n\n    { (yyval.nodes).cs = actual; }\n\n    break;\n\n  case 364:\n\n    { if ((yyvsp[-1].nodes).cs->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).cs, \"status\", \"case\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).cs->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 365:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).cs, s, \"case\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 366:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).cs, s, \"case\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 368:\n\n    { (yyval.backup_token).token = actual_type;\n                                     (yyval.backup_token).actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ANYXML_KEYWORD;\n                                   }\n\n    break;\n\n  case 369:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing anyxml statement \\\"%s\\\"\", data_node->name);\n               actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n               data_node = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 370:\n\n    { (yyval.backup_token).token = actual_type;\n                                      (yyval.backup_token).actual = actual;\n                                      if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {\n                                        YYABORT;\n                                      }\n                                      data_node = actual;\n                                      s = NULL;\n                                      actual_type = ANYDATA_KEYWORD;\n                                    }\n\n    break;\n\n  case 371:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing anydata statement \\\"%s\\\"\", data_node->name);\n                actual_type = (yyvsp[-1].backup_token).token;\n                actual = (yyvsp[-1].backup_token).actual;\n                data_node = (yyvsp[-1].backup_token).actual;\n              }\n\n    break;\n\n  case 373:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].nodes).node.ptr_anydata->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->iffeature, (yyvsp[-1].nodes).node.ptr_anydata->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).node.ptr_anydata->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).node.ptr_anydata->must_size) {\n             tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->must, (yyvsp[-1].nodes).node.ptr_anydata->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).node.ptr_anydata->must = tmp;\n           }\n         }\n\n    break;\n\n  case 374:\n\n    { (yyval.nodes).node.ptr_anydata = actual;\n                              (yyval.nodes).node.flag = actual_type;\n                            }\n\n    break;\n\n  case 378:\n\n    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"config\",\n                                            ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);\n                                 }\n\n    break;\n\n  case 379:\n\n    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_MAND_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"mandatory\",\n                                               ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 380:\n\n    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"status\",\n                                            ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);\n                                 }\n\n    break;\n\n  case 381:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 382:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 383:\n\n    { (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {\n                                         YYABORT;\n                                       }\n                                       data_node = actual;\n                                       s = NULL;\n                                       actual_type = USES_KEYWORD;\n                                     }\n\n    break;\n\n  case 384:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing uses statement \\\"%s\\\"\", data_node->name);\n             actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n             data_node = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 386:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].nodes).uses->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).uses->iffeature, (yyvsp[-1].nodes).uses->iffeature_size * sizeof *(yyvsp[-1].nodes).uses->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).uses->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).uses->refine_size) {\n             tmp = realloc((yyvsp[-1].nodes).uses->refine, (yyvsp[-1].nodes).uses->refine_size * sizeof *(yyvsp[-1].nodes).uses->refine);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).uses->refine = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).uses->augment_size) {\n             tmp = realloc((yyvsp[-1].nodes).uses->augment, (yyvsp[-1].nodes).uses->augment_size * sizeof *(yyvsp[-1].nodes).uses->augment);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).uses->augment = tmp;\n           }\n         }\n\n    break;\n\n  case 387:\n\n    { (yyval.nodes).uses = actual; }\n\n    break;\n\n  case 390:\n\n    { if ((yyvsp[-1].nodes).uses->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).uses, \"status\", \"uses\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).uses->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 391:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).uses, s, \"uses\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 392:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).uses, s, \"uses\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 397:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,\n                                               ((struct lys_node_uses *)actual)->refine_size, \"refines\");\n                                  ((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);\n                                  free(s);\n                                  s = NULL;\n                                  if (!((struct lys_refine *)actual)->target_name) {\n                                    YYABORT;\n                                  }\n                                  actual_type = REFINE_KEYWORD;\n                                }\n\n    break;\n\n  case 398:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 400:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].nodes).refine->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).refine->iffeature, (yyvsp[-1].nodes).refine->iffeature_size * sizeof *(yyvsp[-1].nodes).refine->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).refine->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).refine->must_size) {\n             tmp = realloc((yyvsp[-1].nodes).refine->must, (yyvsp[-1].nodes).refine->must_size * sizeof *(yyvsp[-1].nodes).refine->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).refine->must = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).refine->dflt_size) {\n             tmp = realloc((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size * sizeof *(yyvsp[-1].nodes).refine->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).refine->dflt = tmp;\n           }\n         }\n\n    break;\n\n  case 401:\n\n    { (yyval.nodes).refine = actual;\n                                    actual_type = REFINE_KEYWORD;\n                                  }\n\n    break;\n\n  case 402:\n\n    { actual = (yyvsp[-2].nodes).refine;\n                                               actual_type = REFINE_KEYWORD;\n                                               if ((yyvsp[-2].nodes).refine->target_type) {\n                                                 if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {\n                                                   (yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"must\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 (yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;\n                                               }\n                                             }\n\n    break;\n\n  case 403:\n\n    { /* leaf, leaf-list, list, container or anyxml */\n               /* check possibility of statements combination */\n               if ((yyvsp[-2].nodes).refine->target_type) {\n                 if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {\n                   (yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);\n                 } else {\n                   free(s);\n                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"refine\");\n                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                   YYABORT;\n                 }\n               } else {\n                 (yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;\n               }\n             }\n\n    break;\n\n  case 404:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                             if ((yyvsp[-1].nodes).refine->target_type & LYS_CONTAINER) {\n                                               if ((yyvsp[-1].nodes).refine->mod.presence) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                                 free(s);\n                                                 YYABORT;\n                                               }\n                                               (yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;\n                                               (yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                             } else {\n                                               free(s);\n                                               LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                               LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                               YYABORT;\n                                             }\n                                           } else {\n                                             (yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;\n                                             (yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                           }\n                                           s = NULL;\n                                           (yyval.nodes) = (yyvsp[-1].nodes);\n                                         }\n\n    break;\n\n  case 405:\n\n    { int i;\n\n                                          if ((yyvsp[-1].nodes).refine->dflt_size) {\n                                            if (trg->version < 2) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              YYABORT;\n                                            }\n                                            if ((yyvsp[-1].nodes).refine->target_type & LYS_LEAFLIST) {\n                                              (yyvsp[-1].nodes).refine->target_type = LYS_LEAFLIST;\n                                            } else {\n                                              free(s);\n                                              LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                              YYABORT;\n                                            }\n                                          } else {\n                                            if ((yyvsp[-1].nodes).refine->target_type) {\n                                              if (trg->version < 2 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE))) {\n                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE);\n                                              } if (trg->version > 1 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {\n                                                /* YANG 1.1 */\n                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);\n                                              } else {\n                                                free(s);\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              if (trg->version < 2) {\n                                                (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE;\n                                              } else {\n                                                /* YANG 1.1 */\n                                                (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;\n                                              }\n                                            }\n                                          }\n                                          /* check for duplicity */\n                                          for (i = 0; i < (yyvsp[-1].nodes).refine->dflt_size; ++i) {\n                                              if (ly_strequal((yyvsp[-1].nodes).refine->dflt[i], s, 0)) {\n                                                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"default\");\n                                                  LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", s);\n                                                  YYABORT;\n                                              }\n                                          }\n                                          YANG_ADDELEM((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size, \"defaults\");\n                                          *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                          actual = (yyvsp[-1].nodes).refine;\n                                          s = NULL;\n                                          (yyval.nodes) = (yyvsp[-1].nodes);\n                                        }\n\n    break;\n\n  case 406:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                           if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {\n                                             (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);\n                                             if ((yyvsp[-1].nodes).refine->flags & LYS_CONFIG_MASK) {\n                                               LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                               YYABORT;\n                                             }\n                                             (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                           } else {\n                                             LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                             LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;\n                                           (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                         }\n                                         (yyval.nodes) = (yyvsp[-1].nodes);\n                                       }\n\n    break;\n\n  case 407:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                              if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {\n                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);\n                                                if ((yyvsp[-1].nodes).refine->flags & LYS_MAND_MASK) {\n                                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                  YYABORT;\n                                                }\n                                                (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                              } else {\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;\n                                              (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                            }\n                                            (yyval.nodes) = (yyvsp[-1].nodes);\n                                          }\n\n    break;\n\n  case 408:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                                 if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   (yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MINSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;\n                                                   (yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 (yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;\n                                                 (yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);\n                                               }\n                                               (yyval.nodes) = (yyvsp[-1].nodes);\n                                             }\n\n    break;\n\n  case 409:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                                 if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   (yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MAXSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;\n                                                   (yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 (yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;\n                                                 (yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);\n                                               }\n                                               (yyval.nodes) = (yyvsp[-1].nodes);\n                                             }\n\n    break;\n\n  case 410:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).refine, s, \"refine\", NODE)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n\n    break;\n\n  case 411:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).refine, s, \"refine\", NODE)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n\n    break;\n\n  case 414:\n\n    { void *parent;\n\n                                         (yyval.backup_token).token = actual_type;\n                                         (yyval.backup_token).actual = actual;\n                                         parent = actual;\n                                         YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,\n                                                      ((struct lys_node_uses *)actual)->augment_size, \"augments\");\n                                         if (yang_read_augment(trg, parent, actual, s)) {\n                                           YYABORT;\n                                         }\n                                         data_node = actual;\n                                         s = NULL;\n                                         actual_type = AUGMENT_KEYWORD;\n                                       }\n\n    break;\n\n  case 415:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                         actual_type = (yyvsp[-4].backup_token).token;\n                         actual = (yyvsp[-4].backup_token).actual;\n                         data_node = (yyvsp[-4].backup_token).actual;\n                       }\n\n    break;\n\n  case 418:\n\n    { (yyval.backup_token).token = actual_type;\n                               (yyval.backup_token).actual = actual;\n                               YANG_ADDELEM(trg->augment, trg->augment_size, \"augments\");\n                               if (yang_read_augment(trg, NULL, actual, s)) {\n                                 YYABORT;\n                               }\n                               data_node = actual;\n                               s = NULL;\n                               actual_type = AUGMENT_KEYWORD;\n                             }\n\n    break;\n\n  case 419:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                    actual_type = (yyvsp[-4].backup_token).token;\n                    actual = (yyvsp[-4].backup_token).actual;\n                    data_node = (yyvsp[-4].backup_token).actual;\n                  }\n\n    break;\n\n  case 420:\n\n    { (yyval.nodes).augment = actual; }\n\n    break;\n\n  case 423:\n\n    { if ((yyvsp[-1].nodes).augment->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).augment, \"status\", \"augment\");\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).augment->flags |= (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 424:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).augment, s, \"augment\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 425:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).augment, s, \"augment\", NODE_PRINT)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 428:\n\n    { if (trg->version < 2) {\n                                                    LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).augment, \"notification\");\n                                                    YYABORT;\n                                                  }\n                                                }\n\n    break;\n\n  case 430:\n\n    { if (param->module->version != 2) {\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"action\");\n                                       free(s);\n                                       YYABORT;\n                                     }\n                                     (yyval.backup_token).token = actual_type;\n                                     (yyval.backup_token).actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ACTION_KEYWORD;\n                                   }\n\n    break;\n\n  case 431:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing action statement \\\"%s\\\"\", data_node->name);\n               actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n               data_node = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 432:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = RPC_KEYWORD;\n                                }\n\n    break;\n\n  case 433:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing rpc statement \\\"%s\\\"\", data_node->name);\n            actual_type = (yyvsp[-1].backup_token).token;\n            actual = (yyvsp[-1].backup_token).actual;\n            data_node = (yyvsp[-1].backup_token).actual;\n          }\n\n    break;\n\n  case 435:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].nodes).node.ptr_rpc->iffeature_size) {\n              tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->iffeature, (yyvsp[-1].nodes).node.ptr_rpc->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).node.ptr_rpc->iffeature = tmp;\n            }\n\n            if ((yyvsp[-1].nodes).node.ptr_rpc->tpdf_size) {\n              tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->tpdf, (yyvsp[-1].nodes).node.ptr_rpc->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->tpdf);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).node.ptr_rpc->tpdf = tmp;\n            }\n          }\n\n    break;\n\n  case 436:\n\n    { (yyval.nodes).node.ptr_rpc = actual;\n                           (yyval.nodes).node.flag = 0;\n                         }\n\n    break;\n\n  case 438:\n\n    { if ((yyvsp[-1].nodes).node.ptr_rpc->flags & LYS_STATUS_MASK) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_rpc, \"status\", \"rpc\");\n                                  YYABORT;\n                                }\n                                (yyvsp[-1].nodes).node.ptr_rpc->flags |= (yyvsp[0].i);\n                             }\n\n    break;\n\n  case 439:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n\n    break;\n\n  case 440:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 443:\n\n    { if ((yyvsp[-2].nodes).node.flag & LYS_RPC_INPUT) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, \"input\", \"rpc\");\n                                         YYABORT;\n                                       }\n                                       (yyvsp[-2].nodes).node.flag |= LYS_RPC_INPUT;\n                                       (yyval.nodes) = (yyvsp[-2].nodes);\n                                     }\n\n    break;\n\n  case 444:\n\n    { if ((yyvsp[-2].nodes).node.flag & LYS_RPC_OUTPUT) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, \"output\", \"rpc\");\n                                          YYABORT;\n                                        }\n                                        (yyvsp[-2].nodes).node.flag |= LYS_RPC_OUTPUT;\n                                        (yyval.nodes) = (yyvsp[-2].nodes);\n                                      }\n\n    break;\n\n  case 445:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  s = strdup(\"input\");\n                                  if (!s) {\n                                    LOGMEM(trg->ctx);\n                                    YYABORT;\n                                  }\n                                  if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = INPUT_KEYWORD;\n                                }\n\n    break;\n\n  case 446:\n\n    { void *tmp;\n                  struct lys_node_inout *input = actual;\n\n                  if (input->must_size) {\n                    tmp = realloc(input->must, input->must_size * sizeof *input->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->must = tmp;\n                  }\n\n                  if (input->tpdf_size) {\n                    tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->tpdf = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing input statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-4].backup_token).token;\n                  actual = (yyvsp[-4].backup_token).actual;\n                  data_node = (yyvsp[-4].backup_token).actual;\n                }\n\n    break;\n\n  case 452:\n\n    { (yyval.backup_token).token = actual_type;\n                                    (yyval.backup_token).actual = actual;\n                                    s = strdup(\"output\");\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {\n                                      YYABORT;\n                                    }\n                                    data_node = actual;\n                                    s = NULL;\n                                    actual_type = OUTPUT_KEYWORD;\n                                  }\n\n    break;\n\n  case 453:\n\n    { void *tmp;\n                   struct lys_node_inout *output = actual;\n\n                   if (output->must_size) {\n                     tmp = realloc(output->must, output->must_size * sizeof *output->must);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->must = tmp;\n                   }\n\n                   if (output->tpdf_size) {\n                     tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->tpdf = tmp;\n                   }\n\n                   LOGDBG(LY_LDGYANG, \"finished parsing output statement \\\"%s\\\"\", data_node->name);\n                   actual_type = (yyvsp[-4].backup_token).token;\n                   actual = (yyvsp[-4].backup_token).actual;\n                   data_node = (yyvsp[-4].backup_token).actual;\n                 }\n\n    break;\n\n  case 454:\n\n    { (yyval.backup_token).token = actual_type;\n                                           (yyval.backup_token).actual = actual;\n                                           if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {\n                                             YYABORT;\n                                           }\n                                           data_node = actual;\n                                           actual_type = NOTIFICATION_KEYWORD;\n                                         }\n\n    break;\n\n  case 455:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing notification statement \\\"%s\\\"\", data_node->name);\n                     actual_type = (yyvsp[-1].backup_token).token;\n                     actual = (yyvsp[-1].backup_token).actual;\n                     data_node = (yyvsp[-1].backup_token).actual;\n                   }\n\n    break;\n\n  case 457:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].nodes).notif->must_size) {\n              tmp = realloc((yyvsp[-1].nodes).notif->must, (yyvsp[-1].nodes).notif->must_size * sizeof *(yyvsp[-1].nodes).notif->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).notif->must = tmp;\n            }\n\n           if ((yyvsp[-1].nodes).notif->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).notif->iffeature, (yyvsp[-1].nodes).notif->iffeature_size * sizeof *(yyvsp[-1].nodes).notif->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).notif->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).notif->tpdf_size) {\n             tmp = realloc((yyvsp[-1].nodes).notif->tpdf, (yyvsp[-1].nodes).notif->tpdf_size * sizeof *(yyvsp[-1].nodes).notif->tpdf);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).notif->tpdf = tmp;\n           }\n          }\n\n    break;\n\n  case 458:\n\n    { (yyval.nodes).notif = actual; }\n\n    break;\n\n  case 461:\n\n    { if ((yyvsp[-1].nodes).notif->flags & LYS_STATUS_MASK) {\n                                           LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).notif, \"status\", \"notification\");\n                                           YYABORT;\n                                         }\n                                         (yyvsp[-1].nodes).notif->flags |= (yyvsp[0].i);\n                                       }\n\n    break;\n\n  case 462:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).notif, s, \"notification\", NODE_PRINT)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n\n    break;\n\n  case 463:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).notif, s, \"notification\", NODE_PRINT)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n\n    break;\n\n  case 467:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   YANG_ADDELEM(trg->deviation, trg->deviation_size, \"deviations\");\n                                   ((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);\n                                   free(s);\n                                   if (!((struct lys_deviation *)actual)->target_name) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                   actual_type = DEVIATION_KEYWORD;\n                                 }\n\n    break;\n\n  case 468:\n\n    { void *tmp;\n\n                      if ((yyvsp[-1].dev)->deviate_size) {\n                        tmp = realloc((yyvsp[-1].dev)->deviate, (yyvsp[-1].dev)->deviate_size * sizeof *(yyvsp[-1].dev)->deviate);\n                        if (!tmp) {\n                          LOGINT(trg->ctx);\n                          YYABORT;\n                        }\n                        (yyvsp[-1].dev)->deviate = tmp;\n                      } else {\n                        LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"deviate\", \"deviation\");\n                        YYABORT;\n                      }\n                      actual_type = (yyvsp[-4].backup_token).token;\n                      actual = (yyvsp[-4].backup_token).actual;\n                    }\n\n    break;\n\n  case 469:\n\n    { (yyval.dev) = actual; }\n\n    break;\n\n  case 470:\n\n    { if (yang_read_description(trg, (yyvsp[-1].dev), s, \"deviation\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           (yyval.dev) = (yyvsp[-1].dev);\n                                         }\n\n    break;\n\n  case 471:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].dev), s, \"deviation\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                         (yyval.dev) = (yyvsp[-1].dev);\n                                       }\n\n    break;\n\n  case 477:\n\n    { (yyval.backup_token).token = actual_type;\n                                               (yyval.backup_token).actual = actual;\n                                               if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {\n                                                 YYABORT;\n                                               }\n                                               actual_type = NOT_SUPPORTED_KEYWORD;\n                                             }\n\n    break;\n\n  case 478:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                              actual = (yyvsp[-2].backup_token).actual;\n                            }\n\n    break;\n\n  case 484:\n\n    { (yyval.backup_token).token = actual_type;\n                           (yyval.backup_token).actual = actual;\n                           if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {\n                             YYABORT;\n                           }\n                           actual_type = ADD_KEYWORD;\n                         }\n\n    break;\n\n  case 485:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                    actual = (yyvsp[-2].backup_token).actual;\n                  }\n\n    break;\n\n  case 487:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].deviate)->must_size) {\n             tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->must = tmp;\n           }\n\n           if ((yyvsp[-1].deviate)->unique_size) {\n             tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->unique = tmp;\n           }\n\n           if ((yyvsp[-1].deviate)->dflt_size) {\n             tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->dflt = tmp;\n           }\n         }\n\n    break;\n\n  case 488:\n\n    { (yyval.deviate) = actual; }\n\n    break;\n\n  case 489:\n\n    { if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       (yyval.deviate) = (yyvsp[-1].deviate);\n                                     }\n\n    break;\n\n  case 491:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, \"uniques\");\n                                        ((struct lys_unique *)actual)->expr = (const char **)s;\n                                        s = NULL;\n                                        actual = (yyvsp[-1].deviate);\n                                        (yyval.deviate)= (yyvsp[-1].deviate);\n                                      }\n\n    break;\n\n  case 492:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");\n                                         *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                         s = NULL;\n                                         actual = (yyvsp[-1].deviate);\n                                         (yyval.deviate) = (yyvsp[-1].deviate);\n                                       }\n\n    break;\n\n  case 493:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                          YYABORT;\n                                        }\n                                        (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                        (yyval.deviate) = (yyvsp[-1].deviate);\n                                      }\n\n    break;\n\n  case 494:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                             YYABORT;\n                                           }\n                                           (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                           (yyval.deviate) = (yyvsp[-1].deviate);\n                                         }\n\n    break;\n\n  case 495:\n\n    { if ((yyvsp[-1].deviate)->min_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              (yyvsp[-1].deviate)->min = (yyvsp[0].uint);\n                                              (yyvsp[-1].deviate)->min_set = 1;\n                                              (yyval.deviate) =  (yyvsp[-1].deviate);\n                                            }\n\n    break;\n\n  case 496:\n\n    { if ((yyvsp[-1].deviate)->max_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              (yyvsp[-1].deviate)->max = (yyvsp[0].uint);\n                                              (yyvsp[-1].deviate)->max_set = 1;\n                                              (yyval.deviate) =  (yyvsp[-1].deviate);\n                                            }\n\n    break;\n\n  case 497:\n\n    { (yyval.backup_token).token = actual_type;\n                                 (yyval.backup_token).actual = actual;\n                                 if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {\n                                   YYABORT;\n                                 }\n                                 actual_type = DELETE_KEYWORD;\n                               }\n\n    break;\n\n  case 498:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                       actual = (yyvsp[-2].backup_token).actual;\n                     }\n\n    break;\n\n  case 500:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].deviate)->must_size) {\n              tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].deviate)->must = tmp;\n            }\n\n            if ((yyvsp[-1].deviate)->unique_size) {\n              tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].deviate)->unique = tmp;\n            }\n\n            if ((yyvsp[-1].deviate)->dflt_size) {\n              tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].deviate)->dflt = tmp;\n            }\n          }\n\n    break;\n\n  case 501:\n\n    { (yyval.deviate) = actual; }\n\n    break;\n\n  case 502:\n\n    { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                          (yyval.deviate) = (yyvsp[-1].deviate);\n                                        }\n\n    break;\n\n  case 504:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, \"uniques\");\n                                           ((struct lys_unique *)actual)->expr = (const char **)s;\n                                           s = NULL;\n                                           actual = (yyvsp[-1].deviate);\n                                           (yyval.deviate) = (yyvsp[-1].deviate);\n                                         }\n\n    break;\n\n  case 505:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");\n                                            *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                            s = NULL;\n                                            actual = (yyvsp[-1].deviate);\n                                            (yyval.deviate) = (yyvsp[-1].deviate);\n                                          }\n\n    break;\n\n  case 506:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {\n                                     YYABORT;\n                                   }\n                                   actual_type = REPLACE_KEYWORD;\n                                 }\n\n    break;\n\n  case 507:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                        actual = (yyvsp[-2].backup_token).actual;\n                      }\n\n    break;\n\n  case 509:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].deviate)->dflt_size) {\n             tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->dflt = tmp;\n           }\n         }\n\n    break;\n\n  case 510:\n\n    { (yyval.deviate) = actual; }\n\n    break;\n\n  case 512:\n\n    { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           (yyval.deviate) = (yyvsp[-1].deviate);\n                                         }\n\n    break;\n\n  case 513:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");\n                                             *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                             s = NULL;\n                                             actual = (yyvsp[-1].deviate);\n                                             (yyval.deviate) = (yyvsp[-1].deviate);\n                                           }\n\n    break;\n\n  case 514:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                              YYABORT;\n                                            }\n                                            (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                            (yyval.deviate) = (yyvsp[-1].deviate);\n                                          }\n\n    break;\n\n  case 515:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                                 YYABORT;\n                                               }\n                                               (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                               (yyval.deviate) = (yyvsp[-1].deviate);\n                                             }\n\n    break;\n\n  case 516:\n\n    { if ((yyvsp[-1].deviate)->min_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  (yyvsp[-1].deviate)->min = (yyvsp[0].uint);\n                                                  (yyvsp[-1].deviate)->min_set = 1;\n                                                  (yyval.deviate) =  (yyvsp[-1].deviate);\n                                                }\n\n    break;\n\n  case 517:\n\n    { if ((yyvsp[-1].deviate)->max_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  (yyvsp[-1].deviate)->max = (yyvsp[0].uint);\n                                                  (yyvsp[-1].deviate)->max_set = 1;\n                                                  (yyval.deviate) =  (yyvsp[-1].deviate);\n                                                }\n\n    break;\n\n  case 518:\n\n    { (yyval.backup_token).token = actual_type;\n                        (yyval.backup_token).actual = actual;\n                        if (!(actual = yang_read_when(trg, actual, actual_type, s))) {\n                          YYABORT;\n                        }\n                        s = NULL;\n                        actual_type = WHEN_KEYWORD;\n                      }\n\n    break;\n\n  case 519:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 523:\n\n    { if (yang_read_description(trg, actual, s, \"when\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 524:\n\n    { if (yang_read_reference(trg, actual, s, \"when\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 525:\n\n    { (yyval.i) = (yyvsp[0].i);\n                             backup_type = actual_type;\n                             actual_type = CONFIG_KEYWORD;\n                           }\n\n    break;\n\n  case 526:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 527:\n\n    { (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET; }\n\n    break;\n\n  case 528:\n\n    { (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET; }\n\n    break;\n\n  case 529:\n\n    { if (!strcmp(s, \"true\")) {\n                  (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET;\n                } else if (!strcmp(s, \"false\")) {\n                  (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"config\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 530:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                   backup_type = actual_type;\n                                   actual_type = MANDATORY_KEYWORD;\n                                 }\n\n    break;\n\n  case 531:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 532:\n\n    { (yyval.i) = LYS_MAND_TRUE; }\n\n    break;\n\n  case 533:\n\n    { (yyval.i) = LYS_MAND_FALSE; }\n\n    break;\n\n  case 534:\n\n    { if (!strcmp(s, \"true\")) {\n                  (yyval.i) = LYS_MAND_TRUE;\n                } else if (!strcmp(s, \"false\")) {\n                  (yyval.i) = LYS_MAND_FALSE;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"mandatory\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 535:\n\n    { backup_type = actual_type;\n                       actual_type = PRESENCE_KEYWORD;\n                     }\n\n    break;\n\n  case 537:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                   backup_type = actual_type;\n                                   actual_type = MIN_ELEMENTS_KEYWORD;\n                                 }\n\n    break;\n\n  case 538:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 539:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 540:\n\n    { if (strlen(s) == 1 && s[0] == '0') {\n                  (yyval.uint) = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"min-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  (yyval.uint) = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 541:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                   backup_type = actual_type;\n                                   actual_type = MAX_ELEMENTS_KEYWORD;\n                                 }\n\n    break;\n\n  case 542:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 543:\n\n    { (yyval.uint) = 0; }\n\n    break;\n\n  case 544:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 545:\n\n    { if (!strcmp(s, \"unbounded\")) {\n                  (yyval.uint) = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"max-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  (yyval.uint) = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 546:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                     backup_type = actual_type;\n                                     actual_type = ORDERED_BY_KEYWORD;\n                                   }\n\n    break;\n\n  case 547:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 548:\n\n    { (yyval.i) = LYS_USERORDERED; }\n\n    break;\n\n  case 549:\n\n    { (yyval.i) = LYS_SYSTEMORDERED; }\n\n    break;\n\n  case 550:\n\n    { if (!strcmp(s, \"user\")) {\n                  (yyval.i) = LYS_USERORDERED;\n                } else if (!strcmp(s, \"system\")) {\n                  (yyval.i) = LYS_SYSTEMORDERED;\n                } else {\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s=NULL;\n              }\n\n    break;\n\n  case 551:\n\n    { (yyval.backup_token).token = actual_type;\n                       (yyval.backup_token).actual = actual;\n                       switch (actual_type) {\n                       case CONTAINER_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_container *)actual)->must,\n                                     ((struct lys_node_container *)actual)->must_size, \"musts\");\n                         break;\n                       case ANYDATA_KEYWORD:\n                       case ANYXML_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,\n                                     ((struct lys_node_anydata *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,\n                                     ((struct lys_node_leaf *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,\n                                     ((struct lys_node_leaflist *)actual)->must_size, \"musts\");\n                         break;\n                       case LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_list *)actual)->must,\n                                     ((struct lys_node_list *)actual)->must_size, \"musts\");\n                         break;\n                       case REFINE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_refine *)actual)->must,\n                                     ((struct lys_refine *)actual)->must_size, \"musts\");\n                         break;\n                       case ADD_KEYWORD:\n                       case DELETE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_deviate *)actual)->must,\n                                      ((struct lys_deviate *)actual)->must_size, \"musts\");\n                         break;\n                       case NOTIFICATION_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_notif *)actual)->must,\n                                     ((struct lys_node_notif *)actual)->must_size, \"musts\");\n                         break;\n                       case INPUT_KEYWORD:\n                       case OUTPUT_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_inout *)actual)->must,\n                                     ((struct lys_node_inout *)actual)->must_size, \"musts\");\n                         break;\n                       case EXTENSION_INSTANCE:\n                         /* must is already allocated */\n                         break;\n                       default:\n                         free(s);\n                         LOGINT(trg->ctx);\n                         YYABORT;\n                       }\n                       ((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);\n                       free(s);\n                       if (!((struct lys_restr *)actual)->expr) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       actual_type = MUST_KEYWORD;\n                     }\n\n    break;\n\n  case 552:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 555:\n\n    { backup_type = actual_type;\n                             actual_type = UNIQUE_KEYWORD;\n                           }\n\n    break;\n\n  case 559:\n\n    { backup_type = actual_type;\n                       actual_type = KEY_KEYWORD;\n                     }\n\n    break;\n\n  case 561:\n\n    { s = strdup(yyget_text(scanner));\n                               if (!s) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                             }\n\n    break;\n\n  case 564:\n\n    { (yyval.backup_token).token = actual_type;\n                        (yyval.backup_token).actual = actual;\n                        if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {\n                          YYABORT;\n                        }\n                        actual_type = RANGE_KEYWORD;\n                        s = NULL;\n                      }\n\n    break;\n\n  case 565:\n\n    { if (s) {\n                                                s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                strcat(s,\"/\");\n                                                strcat(s, yyget_text(scanner));\n                                              } else {\n                                                s = malloc(yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                s[0]='/';\n                                                memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);\n                                              }\n                                            }\n\n    break;\n\n  case 569:\n\n    { if (s) {\n                                              s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                              strcat(s, yyget_text(scanner));\n                                            } else {\n                                              s = strdup(yyget_text(scanner));\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                            }\n                                          }\n\n    break;\n\n  case 571:\n\n    { tmp_s = yyget_text(scanner); }\n\n    break;\n\n  case 572:\n\n    { s = strdup(tmp_s);\n                                                                if (!s) {\n                                                                  LOGMEM(trg->ctx);\n                                                                  YYABORT;\n                                                                }\n                                                                s[strlen(s) - 1] = '\\0';\n                                                             }\n\n    break;\n\n  case 573:\n\n    { tmp_s = yyget_text(scanner); }\n\n    break;\n\n  case 574:\n\n    { s = strdup(tmp_s);\n                                                      if (!s) {\n                                                        LOGMEM(trg->ctx);\n                                                        YYABORT;\n                                                      }\n                                                      s[strlen(s) - 1] = '\\0';\n                                                    }\n\n    break;\n\n  case 598:\n\n    { /* convert it to uint32_t */\n                                                unsigned long val;\n\n                                                val = strtoul(yyget_text(scanner), NULL, 10);\n                                                if (val > UINT32_MAX) {\n                                                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Converted number is very long.\");\n                                                    YYABORT;\n                                                }\n                                                (yyval.uint) = (uint32_t) val;\n                                             }\n\n    break;\n\n  case 599:\n\n    { (yyval.uint) = 0; }\n\n    break;\n\n  case 600:\n\n    { (yyval.uint) = (yyvsp[0].uint); }\n\n    break;\n\n  case 601:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 602:\n\n    { /* convert it to int32_t */\n                             int64_t val;\n\n                             val = strtoll(yyget_text(scanner), NULL, 10);\n                             if (val < INT32_MIN || val > INT32_MAX) {\n                                 LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                                        \"The number is not in the correct range (INT32_MIN..INT32_MAX): \\\"%d\\\"\",val);\n                                 YYABORT;\n                             }\n                             (yyval.i) = (int32_t) val;\n                           }\n\n    break;\n\n  case 608:\n\n    { if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                    free(s);\n                    YYABORT;\n                }\n              }\n\n    break;\n\n  case 613:\n\n    { char *tmp;\n\n               if ((tmp = strchr(s, ':'))) {\n                 *tmp = '\\0';\n                 /* check prefix */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 *tmp = ':';\n               } else {\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n               }\n             }\n\n    break;\n\n  case 614:\n\n    { s = (yyvsp[-1].str); }\n\n    break;\n\n  case 615:\n\n    { s = (yyvsp[-3].str); }\n\n    break;\n\n  case 616:\n\n    { actual_type = backup_type;\n                 backup_type = NODE;\n                 (yyval.str) = s;\n                 s = NULL;\n               }\n\n    break;\n\n  case 617:\n\n    { actual_type = backup_type;\n                           backup_type = NODE;\n                         }\n\n    break;\n\n  case 618:\n\n    { (yyval.str) = s;\n                          s = NULL;\n                        }\n\n    break;\n\n  case 622:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                     actual = (yyvsp[-1].backup_token).actual;\n                   }\n\n    break;\n\n  case 623:\n\n    { (yyval.backup_token).token = actual_type;\n                                                (yyval.backup_token).actual = actual;\n                                                if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, (yyvsp[-1].str), s,\n                                                                             actual_type, backup_type, is_ext_instance))) {\n                                                  YYABORT;\n                                                }\n                                                s = NULL;\n                                                actual_type = EXTENSION_INSTANCE;\n                                              }\n\n    break;\n\n  case 624:\n\n    { (yyval.str) = s; s = NULL; }\n\n    break;\n\n  case 639:\n\n    {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length = 0, old_length = 0;\n        char *tmp_value;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen((yyvsp[-2].str));\n        old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;\n        tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_substmt = tmp_value;\n        tmp_value += old_length - 2;\n        memcpy(tmp_value, (yyvsp[-2].str), length);\n        tmp_value[length] = ' ';\n        tmp_value[length + 1] = '\\0';\n        tmp_value[length + 2] = '\\0';\n      }\n\n    break;\n\n  case 640:\n\n    {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length;\n        char *tmp_value, **array;\n        int i = 0;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen((yyvsp[-2].str));\n        if (!substmt->ext_modules) {\n          array = malloc(2 * sizeof *substmt->ext_modules);\n        } else {\n          for (i = 0; substmt->ext_modules[i]; ++i);\n          array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);\n        }\n        if (!array) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_modules = array;\n        array[i + 1] = NULL;\n        tmp_value = malloc(length + 2);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        array[i] = tmp_value;\n        memcpy(tmp_value, (yyvsp[-2].str), length);\n        tmp_value[length] = '\\0';\n        tmp_value[length + 1] = '\\0';\n      }\n\n    break;\n\n  case 643:\n\n    { (yyval.str) = yyget_text(scanner); }\n\n    break;\n\n  case 644:\n\n    { (yyval.str) = yyget_text(scanner); }\n\n    break;\n\n  case 656:\n\n    { s = strdup(yyget_text(scanner));\n                  if (!s) {\n                    LOGMEM(trg->ctx);\n                    YYABORT;\n                  }\n                }\n\n    break;\n\n  case 749:\n\n    { s = strdup(yyget_text(scanner));\n                          if (!s) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                        }\n\n    break;\n\n  case 750:\n\n    { s = strdup(yyget_text(scanner));\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                  }\n\n    break;\n\n  case 751:\n\n    { struct lys_type **type;\n\n                             type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                            \"type\", LY_STMT_TYPE);\n                             if (!type) {\n                               YYABORT;\n                             }\n                             /* allocate type structure */\n                             (*type) = calloc(1, sizeof **type);\n                             if (!*type) {\n                               LOGMEM(trg->ctx);\n                               YYABORT;\n                             }\n\n                             /* HACK for unres */\n                             (*type)->parent = (struct lys_tpdf *)ext_instance;\n                             (yyval.v) = actual = *type;\n                             is_ext_instance = 0;\n                            }\n\n    break;\n\n  case 752:\n\n    { struct lys_tpdf **tpdf;\n\n                                tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                               \"typedef\", LY_STMT_TYPEDEF);\n                                if (!tpdf) {\n                                  YYABORT;\n                                }\n                                /* allocate typedef structure */\n                                (*tpdf) = calloc(1, sizeof **tpdf);\n                                if (!*tpdf) {\n                                  LOGMEM(trg->ctx);\n                                  YYABORT;\n                                }\n\n                                (yyval.v) = actual = *tpdf;\n                                is_ext_instance = 0;\n                              }\n\n    break;\n\n  case 753:\n\n    { struct lys_iffeature **iffeature;\n\n                                 iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                          \"if-feature\", LY_STMT_IFFEATURE);\n                                 if (!iffeature) {\n                                   YYABORT;\n                                 }\n                                 /* allocate typedef structure */\n                                 (*iffeature) = calloc(1, sizeof **iffeature);\n                                 if (!*iffeature) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 (yyval.v) = actual = *iffeature;\n                               }\n\n    break;\n\n  case 754:\n\n    { struct lys_restr **restr;\n                                    LY_STMT stmt;\n\n                                    s = yyget_text(scanner);\n                                    if (!strcmp(s, \"must\")) {\n                                      stmt = LY_STMT_MUST;\n                                    } else if (!strcmp(s, \"pattern\")) {\n                                      stmt = LY_STMT_PATTERN;\n                                    } else if (!strcmp(s, \"range\")) {\n                                      stmt = LY_STMT_RANGE;\n                                    } else {\n                                      stmt = LY_STMT_LENGTH;\n                                    }\n                                    restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);\n                                    if (!restr) {\n                                      YYABORT;\n                                    }\n                                    /* allocate structure for must */\n                                    (*restr) = calloc(1, sizeof(struct lys_restr));\n                                    if (!*restr) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    (yyval.v) = actual = *restr;\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 755:\n\n    { actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, \"when\", LY_STMT_WHEN);\n                             if (!actual) {\n                               YYABORT;\n                             }\n                             (yyval.v) = actual;\n                           }\n\n    break;\n\n  case 756:\n\n    { struct lys_revision **rev;\n                                 int i;\n\n                                 rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,\n                                                                                                   \"revision\", LY_STMT_REVISION);\n                                 if (!rev) {\n                                   YYABORT;\n                                 }\n                                 rev[i] = calloc(1, sizeof **rev);\n                                 if (!rev[i]) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 actual = rev[i];\n                                 (yyval.revisions).revision = rev;\n                                 (yyval.revisions).index = i;\n                               }\n\n    break;\n\n  case 757:\n\n    { LY_STMT stmt;\n\n                                s = yyget_text(scanner);\n                                if (!strcmp(s, \"action\")) {\n                                  stmt = LY_STMT_ACTION;\n                                } else if (!strcmp(s, \"anydata\")) {\n                                  stmt = LY_STMT_ANYDATA;\n                                } else if (!strcmp(s, \"anyxml\")) {\n                                  stmt = LY_STMT_ANYXML;\n                                } else if (!strcmp(s, \"case\")) {\n                                  stmt = LY_STMT_CASE;\n                                } else if (!strcmp(s, \"choice\")) {\n                                  stmt = LY_STMT_CHOICE;\n                                } else if (!strcmp(s, \"container\")) {\n                                  stmt = LY_STMT_CONTAINER;\n                                } else if (!strcmp(s, \"grouping\")) {\n                                  stmt = LY_STMT_GROUPING;\n                                } else if (!strcmp(s, \"input\")) {\n                                  stmt = LY_STMT_INPUT;\n                                } else if (!strcmp(s, \"leaf\")) {\n                                  stmt = LY_STMT_LEAF;\n                                } else if (!strcmp(s, \"leaf-list\")) {\n                                  stmt = LY_STMT_LEAFLIST;\n                                } else if (!strcmp(s, \"list\")) {\n                                  stmt = LY_STMT_LIST;\n                                } else if (!strcmp(s, \"notification\")) {\n                                  stmt = LY_STMT_NOTIFICATION;\n                                } else if (!strcmp(s, \"output\")) {\n                                  stmt = LY_STMT_OUTPUT;\n                                } else {\n                                  stmt = LY_STMT_USES;\n                                }\n                                if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {\n                                  YYABORT;\n                                }\n                                actual = NULL;\n                                s = NULL;\n                                is_ext_instance = 0;\n                              }\n\n    break;\n\n  case 758:\n\n    { LOGERR(trg->ctx, ly_errno, \"Extension's substatement \\\"%s\\\" not supported.\", yyget_text(scanner)); }\n\n    break;\n\n  case 790:\n\n    { actual_type = EXTENSION_INSTANCE;\n                                actual = ext_instance;\n                                if (!is_ext_instance) {\n                                  LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n                                  YYABORT;\n                                }\n                                (yyval.i) = 0;\n                              }\n\n    break;\n\n  case 792:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", ext_name, s,\n                                                                  0, LY_STMT_PREFIX)) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 793:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"description\", ext_name, s,\n                                                                       0, LY_STMT_DESCRIPTION)) {\n                                            YYABORT;\n                                          }\n                                        }\n\n    break;\n\n  case 794:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"reference\", ext_name, s,\n                                                                     0, LY_STMT_REFERENCE)) {\n                                          YYABORT;\n                                        }\n                                      }\n\n    break;\n\n  case 795:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"units\", ext_name, s,\n                                                                     0, LY_STMT_UNITS)) {\n                                      YYABORT;\n                                    }\n                                  }\n\n    break;\n\n  case 796:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"base\", ext_name, s,\n                                                                0, LY_STMT_BASE)) {\n                                     YYABORT;\n                                   }\n                                 }\n\n    break;\n\n  case 797:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"contact\", ext_name, s,\n                                                                     0, LY_STMT_CONTACT)) {\n                                        YYABORT;\n                                      }\n                                    }\n\n    break;\n\n  case 798:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"default\", ext_name, s,\n                                                                     0, LY_STMT_DEFAULT)) {\n                                        YYABORT;\n                                      }\n                                    }\n\n    break;\n\n  case 799:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"error-message\", ext_name, s,\n                                                                         0, LY_STMT_ERRMSG)) {\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 800:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"error-app-tag\", ext_name, s,\n                                                                         0, LY_STMT_ERRTAG)) {\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 801:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"key\", ext_name, s,\n                                                               0, LY_STMT_KEY)) {\n                                    YYABORT;\n                                  }\n                                }\n\n    break;\n\n  case 802:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"namespace\", ext_name, s,\n                                                                     0, LY_STMT_NAMESPACE)) {\n                                          YYABORT;\n                                        }\n                                      }\n\n    break;\n\n  case 803:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"organization\", ext_name, s,\n                                                                        0, LY_STMT_ORGANIZATION)) {\n                                             YYABORT;\n                                           }\n                                         }\n\n    break;\n\n  case 804:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"path\", ext_name, s,\n                                                                0, LY_STMT_PATH)) {\n                                     YYABORT;\n                                   }\n                                 }\n\n    break;\n\n  case 805:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"presence\", ext_name, s,\n                                                                    0, LY_STMT_PRESENCE)) {\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 806:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"revision-date\", ext_name, s,\n                                                                         0, LY_STMT_REVISIONDATE)) {\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 807:\n\n    { struct lys_type *type = (yyvsp[-2].v);\n\n       if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n\n    break;\n\n  case 808:\n\n    { struct lys_tpdf *tpdf = (yyvsp[-2].v);\n\n       if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {\n         yang_type_free(trg->ctx, &tpdf->type);\n       }\n       if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {\n         yang_type_free(trg->ctx, &tpdf->type);\n         YYABORT;\n       }\n       /* check default value*/\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n\n    break;\n\n  case 809:\n\n    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"status\", LY_STMT_STATUS,\n                                                                    (yyvsp[0].i), LYS_STATUS_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 810:\n\n    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"config\", LY_STMT_CONFIG,\n                                                                    (yyvsp[0].i), LYS_CONFIG_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 811:\n\n    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"mandatory\", LY_STMT_MANDATORY,\n                                                                       (yyvsp[0].i), LYS_MAND_MASK)) {\n                                          YYABORT;\n                                        }\n                                      }\n\n    break;\n\n  case 812:\n\n    { if ((yyvsp[-1].i) & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"ordered by\", ext_name);\n                                            YYABORT;\n                                         }\n                                         if ((yyvsp[0].i) & LYS_USERORDERED) {\n                                           if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"ordered-by\", LY_STMT_ORDEREDBY,\n                                                                          (yyvsp[0].i), LYS_USERORDERED)) {\n                                             YYABORT;\n                                           }\n                                         }\n                                         (yyvsp[-1].i) |= (yyvsp[0].i);\n                                         (yyval.i) = (yyvsp[-1].i);\n                                       }\n\n    break;\n\n  case 813:\n\n    { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"require-instance\",\n                                                                              LY_STMT_REQINSTANCE, (yyvsp[0].i))) {\n                                                 YYABORT;\n                                               }\n                                             }\n\n    break;\n\n  case 814:\n\n    { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"modifier\", LY_STMT_MODIFIER, 0)) {\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 815:\n\n    { /* range check */\n       if ((yyvsp[0].uint) < 1 || (yyvsp[0].uint) > 18) {\n         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"fraction-digits\");\n         YYABORT;\n       }\n       if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"fraction-digits\", LY_STMT_DIGITS, (yyvsp[0].uint))) {\n         YYABORT;\n       }\n     }\n\n    break;\n\n  case 816:\n\n    { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"min-elements\", LY_STMT_MIN);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = (yyvsp[0].uint);\n                                         }\n\n    break;\n\n  case 817:\n\n    { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"max-elements\", LY_STMT_MAX);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = (yyvsp[0].uint);\n                                         }\n\n    break;\n\n  case 818:\n\n    { uint32_t **val;\n\n                                       val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                              \"position\", LY_STMT_POSITION);\n                                       if (!val) {\n                                         YYABORT;\n                                       }\n                                       /* store the value */\n                                       *val = malloc(sizeof(uint32_t));\n                                       if (!*val) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       **val = (yyvsp[0].uint);\n                                     }\n\n    break;\n\n  case 819:\n\n    { int32_t **val;\n\n                                    val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                          \"value\", LY_STMT_VALUE);\n                                    if (!val) {\n                                      YYABORT;\n                                    }\n                                    /* store the value */\n                                    *val = malloc(sizeof(int32_t));\n                                    if (!*val) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    **val = (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 820:\n\n    { struct lys_unique **unique;\n                                     int rc;\n\n                                     unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                        \"unique\", LY_STMT_UNIQUE);\n                                     if (!unique) {\n                                       YYABORT;\n                                     }\n                                     *unique = calloc(1, sizeof(struct lys_unique));\n                                     if (!*unique) {\n                                       LOGMEM(trg->ctx);\n                                       YYABORT;\n                                     }\n                                     rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);\n                                     free(s);\n                                     s = NULL;\n                                     if (rc) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 821:\n\n    { struct lys_iffeature *iffeature;\n\n       iffeature = (yyvsp[-2].v);\n       s = (char *)iffeature->features;\n       iffeature->features = NULL;\n       if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {\n         YYABORT;\n       }\n       if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {\n         YYABORT;\n       }\n       s = NULL;\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 823:\n\n    { if (yang_check_ext_instance(trg, &((struct lys_restr *)(yyvsp[-2].v))->ext, ((struct lys_restr *)(yyvsp[-2].v))->ext_size, (yyvsp[-2].v), param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 824:\n\n    { if (yang_check_ext_instance(trg, &(*(struct lys_when **)(yyvsp[-2].v))->ext, (*(struct lys_when **)(yyvsp[-2].v))->ext_size,\n                                   *(struct lys_when **)(yyvsp[-2].v), param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 825:\n\n    { int i;\n\n       for (i = 0; i < (yyvsp[-2].revisions).index; ++i) {\n         if (!strcmp((yyvsp[-2].revisions).revision[i]->date, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->date)) {\n           LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\", (yyvsp[-2].revisions).revision[i]->date);\n           break;\n         }\n       }\n       if (yang_check_ext_instance(trg, &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext_size,\n                                   &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index], param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 826:\n\n    { actual = ext_instance;\n                                                                    is_ext_instance = 1;\n                                                                  }\n\n    break;\n\n\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n  *++yylsp = yyloc;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (&yylloc, scanner, param, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (&yylloc, scanner, param, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n  yyerror_range[1] = yylloc;\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, &yylloc, scanner, param);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n      yyerror_range[1] = *yylsp;\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yylsp, scanner, param);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  yyerror_range[2] = yylloc;\n  /* Using YYLLOC is tempting, but would change the location of\n     the lookahead.  YYLOC is available though.  */\n  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);\n  *++yylsp = yyloc;\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (&yylloc, scanner, param, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, &yylloc, scanner, param);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yylsp, scanner, param);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}\n\n\n\nvoid\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }\n}\n", "/**\n * @file yang.y\n * @author Pavol Vican\n * @brief YANG parser for libyang (bison grammar)\n *\n * Copyright (c) 2015 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n%define api.pure full\n%locations\n\n%parse-param {void *scanner}\n%parse-param {struct yang_parameter *param}\n\n%lex-param {void *scanner}\n\n%{\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"libyang.h\"\n#include \"common.h\"\n#include \"context.h\"\n#include \"resolve.h\"\n#include \"parser_yang.h\"\n#include \"parser_yang_lex.h\"\n#include \"parser.h\"\n\n#define YANG_ADDELEM(current_ptr, size, array_name)                                      \\\n    if ((size) == LY_ARRAY_MAX(size)) {                                                  \\\n         LOGERR(trg->ctx, LY_EINT, \"Reached limit (%\"PRIu64\") for storing %s.\", LY_ARRAY_MAX(size), array_name); \\\n         free(s);                                                                        \\\n         YYABORT;                                                                        \\\n    } else if (!((size) % LY_YANG_ARRAY_SIZE)) {                                         \\\n        void *tmp;                                                                       \\\n                                                                                         \\\n        tmp = realloc((current_ptr), (sizeof *(current_ptr)) * ((size) + LY_YANG_ARRAY_SIZE)); \\\n        if (!tmp) {                                                                      \\\n            LOGMEM(trg->ctx);                                                            \\\n            free(s);                                                                     \\\n            YYABORT;                                                                     \\\n        }                                                                                \\\n        memset(tmp + (sizeof *(current_ptr)) * (size), 0, (sizeof *(current_ptr)) * LY_YANG_ARRAY_SIZE); \\\n        (current_ptr) = tmp;                                                             \\\n    }                                                                                    \\\n    actual = &(current_ptr)[(size)++];                                                   \\\n\nvoid yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...);\n/* pointer on the current parsed element 'actual' */\n%}\n\n%union {\n  int32_t i;\n  uint32_t uint;\n  char *str;\n  char **p_str;\n  void *v;\n  char ch;\n  struct yang_type *type;\n  struct lys_deviation *dev;\n  struct lys_deviate *deviate;\n  union {\n    uint32_t index;\n    struct lys_node_container *container;\n    struct lys_node_anydata *anydata;\n    struct type_node node;\n    struct lys_node_case *cs;\n    struct lys_node_grp *grouping;\n    struct lys_refine *refine;\n    struct lys_node_notif *notif;\n    struct lys_node_uses *uses;\n    struct lys_node_inout *inout;\n    struct lys_node_augment *augment;\n  } nodes;\n  enum yytokentype token;\n  struct {\n    void *actual;\n    enum yytokentype token;\n  } backup_token;\n  struct {\n    struct lys_revision **revision;\n    int index;\n  } revisions;\n}\n\n%token UNION_KEYWORD\n%token ANYXML_KEYWORD\n%token WHITESPACE\n%token ERROR\n%token EOL\n%token STRING\n%token STRINGS\n%token IDENTIFIER\n%token IDENTIFIERPREFIX\n%token REVISION_DATE\n%token TAB\n%token DOUBLEDOT\n%token URI\n%token INTEGER\n%token NON_NEGATIVE_INTEGER\n%token ZERO\n%token DECIMAL\n%token ARGUMENT_KEYWORD\n%token AUGMENT_KEYWORD\n%token BASE_KEYWORD\n%token BELONGS_TO_KEYWORD\n%token BIT_KEYWORD\n%token CASE_KEYWORD\n%token CHOICE_KEYWORD\n%token CONFIG_KEYWORD\n%token CONTACT_KEYWORD\n%token CONTAINER_KEYWORD\n%token DEFAULT_KEYWORD\n%token DESCRIPTION_KEYWORD\n%token ENUM_KEYWORD\n%token ERROR_APP_TAG_KEYWORD\n%token ERROR_MESSAGE_KEYWORD\n%token EXTENSION_KEYWORD\n%token DEVIATION_KEYWORD\n%token DEVIATE_KEYWORD\n%token FEATURE_KEYWORD\n%token FRACTION_DIGITS_KEYWORD\n%token GROUPING_KEYWORD\n%token IDENTITY_KEYWORD\n%token IF_FEATURE_KEYWORD\n%token IMPORT_KEYWORD\n%token INCLUDE_KEYWORD\n%token INPUT_KEYWORD\n%token KEY_KEYWORD\n%token LEAF_KEYWORD\n%token LEAF_LIST_KEYWORD\n%token LENGTH_KEYWORD\n%token LIST_KEYWORD\n%token MANDATORY_KEYWORD\n%token MAX_ELEMENTS_KEYWORD\n%token MIN_ELEMENTS_KEYWORD\n%token MODULE_KEYWORD\n%token MUST_KEYWORD\n%token NAMESPACE_KEYWORD\n%token NOTIFICATION_KEYWORD\n%token ORDERED_BY_KEYWORD\n%token ORGANIZATION_KEYWORD\n%token OUTPUT_KEYWORD\n%token PATH_KEYWORD\n%token PATTERN_KEYWORD\n%token POSITION_KEYWORD\n%token PREFIX_KEYWORD\n%token PRESENCE_KEYWORD\n%token RANGE_KEYWORD\n%token REFERENCE_KEYWORD\n%token REFINE_KEYWORD\n%token REQUIRE_INSTANCE_KEYWORD\n%token REVISION_KEYWORD\n%token REVISION_DATE_KEYWORD\n%token RPC_KEYWORD\n%token STATUS_KEYWORD\n%token SUBMODULE_KEYWORD\n%token TYPE_KEYWORD\n%token TYPEDEF_KEYWORD\n%token UNIQUE_KEYWORD\n%token UNITS_KEYWORD\n%token USES_KEYWORD\n%token VALUE_KEYWORD\n%token WHEN_KEYWORD\n%token YANG_VERSION_KEYWORD\n%token YIN_ELEMENT_KEYWORD\n%token ADD_KEYWORD\n%token CURRENT_KEYWORD\n%token DELETE_KEYWORD\n%token DEPRECATED_KEYWORD\n%token FALSE_KEYWORD\n%token NOT_SUPPORTED_KEYWORD\n%token OBSOLETE_KEYWORD\n%token REPLACE_KEYWORD\n%token SYSTEM_KEYWORD\n%token TRUE_KEYWORD\n%token UNBOUNDED_KEYWORD\n%token USER_KEYWORD\n%token ACTION_KEYWORD\n%token MODIFIER_KEYWORD\n%token ANYDATA_KEYWORD\n%token NODE\n%token NODE_PRINT\n%token EXTENSION_INSTANCE\n%token SUBMODULE_EXT_KEYWORD\n\n%type <uint> positive_integer_value\n%type <uint> non_negative_integer_value\n%type <uint> max_value_arg_str\n%type <uint> max_value_arg\n%type <uint> max_elements_stmt\n%type <uint> min_value_arg_str\n%type <uint> min_value_arg\n%type <uint> min_elements_stmt\n%type <uint> fraction_digits_arg_str\n%type <uint> fraction_digits_arg\n%type <uint> position_value_arg_str\n%type <uint> position_value_arg\n%type <uint> yin_element_arg_str\n%type <uint> yin_element_arg\n%type <uint> fraction_digits_stmt\n%type <uint> position_stmt\n%type <i> value_stmt\n%type <i> require_instance_stmt\n%type <i> require_instance_arg_str\n%type <i> require_instance_arg\n%type <i> import_opt_stmt\n%type <i> include_opt_stmt\n%type <i> module_header_stmt\n%type <i> submodule_header_stmt\n%type <str> message_opt_stmt\n%type <i> status_stmt\n%type <i> status_arg_str\n%type <i> status_arg\n%type <i> config_stmt\n%type <i> config_arg_str\n%type <i> config_arg\n%type <i> mandatory_stmt\n%type <i> mandatory_arg_str\n%type <i> mandatory_arg\n%type <i> ordered_by_stmt\n%type <i> ordered_by_arg_str\n%type <i> ordered_by_arg\n%type <i> integer_value_arg_str\n%type <i> value_arg\n%type <i> integer_value\n%type <i> ext_substatements\n%type <str> pattern_arg_str\n%type <nodes> container_opt_stmt\n%type <nodes> anyxml_opt_stmt\n%type <nodes> choice_opt_stmt\n%type <nodes> case_opt_stmt\n%type <nodes> grouping_opt_stmt\n%type <nodes> leaf_opt_stmt\n%type <nodes> leaf_list_opt_stmt\n%type <nodes> list_opt_stmt\n%type <nodes> type_opt_stmt\n%type <nodes> uses_opt_stmt\n%type <nodes> refine_body_opt_stmts\n%type <nodes> augment_opt_stmt\n%type <nodes> rpc_opt_stmt\n%type <nodes> notification_opt_stmt\n%type <dev> deviation_opt_stmt\n%type <deviate> deviate_add_opt_stmt\n%type <deviate> deviate_delete_opt_stmt\n%type <deviate> deviate_replace_opt_stmt\n%type <ch> pattern_opt_stmt\n%type <ch> pattern_end\n%type <ch> modifier_stmt\n%type <p_str> tmp_string\n%type <str> string_opt_part1\n%type <str> semicolom\n%type <str> curly_bracket_open\n%type <str> unknown_statement2_yang_stmt\n%type <str> unknown_statement2_module_stmt\n%type <v> type_ext_alloc\n%type <v> typedef_ext_alloc\n%type <v> iffeature_ext_alloc\n%type <v> restriction_ext_alloc\n%type <v> when_ext_alloc\n%type <revisions> revision_ext_alloc\n%type <token> import_arg_str\n%type <token> include_arg_str\n%type <token> argument_str\n%type <token> belongs_to_arg_str\n%type <backup_token> revision_arg_stmt\n%type <backup_token> grouping_arg_str\n%type <backup_token> container_arg_str\n%type <backup_token> leaf_arg_str\n%type <backup_token> leaf_list_arg_str\n%type <backup_token> list_arg_str\n%type <backup_token> choice_arg_str\n%type <backup_token> case_arg_str\n%type <backup_token> anyxml_arg_str\n%type <backup_token> anydata_arg_str\n%type <backup_token> uses_arg_str\n%type <backup_token> uses_augment_arg\n%type <backup_token> augment_arg\n%type <backup_token> action_arg_str\n%type <backup_token> rpc_arg_str\n%type <backup_token> input_arg\n%type <backup_token> output_arg\n%type <backup_token> notification_arg_str\n%type <backup_token> extension_arg_str\n%type <backup_token> feature_arg_str\n%type <backup_token> identity_arg_str\n%type <backup_token> if_feature_arg\n%type <backup_token> typedef_arg_str\n%type <backup_token> type_arg_str\n%type <backup_token> length_arg_str\n%type <backup_token> pattern_sep\n%type <backup_token> range_arg_str\n%type <backup_token> union_spec\n%type <backup_token> enum_arg_str\n%type <backup_token> bit_arg_str\n%type <backup_token> when_arg_str\n%type <backup_token> must_agr_str\n%type <backup_token> refine_arg_str\n%type <backup_token> deviation_arg\n%type <backup_token> deviate_not_supported\n%type <backup_token> deviate_add\n%type <backup_token> deviate_delete\n%type <backup_token> deviate_replace\n%type <backup_token> string_opt\n\n%destructor { free($$); } pattern_arg_str string_opt_part1 semicolom curly_bracket_open\n%destructor { free(($$) ? *$$ : NULL); } tmp_string\n%destructor { yang_type_free(param->module->ctx, $$); } type_ext_alloc\n%destructor { yang_type_free(param->module->ctx, &((struct lys_tpdf *)$$)->type); } typedef_ext_alloc\n\n%initial-action { yylloc.last_column = 0;\n                  if (param->flags & EXT_INSTANCE_SUBSTMT) {\n                    is_ext_instance = 1;\n                    ext_instance = (struct lys_ext_instance_complex *)param->actual_node;\n                    ext_name = (char *)param->data_node;\n                  } else {\n                    is_ext_instance = 0;\n                  }\n                  yylloc.last_line = is_ext_instance;     /* HACK for flex - return SUBMODULE_KEYWORD or SUBMODULE_EXT_KEYWORD */\n                  param->value = &s;\n                  param->data_node = (void **)&data_node;\n                  param->actual_node = &actual;\n                  backup_type = NODE;\n                  trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;\n                }\n\n%%\n\n/* to simplify code, store the module/submodule being processed as trg */\n\nstart: module_stmt\n |  submodule_stmt\n |  ext_substatements\n\ntmp_string: STRING { if (yyget_text(scanner)[0] == '\"') {\n                      char *tmp;\n\n                      s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {\n                        YYABORT;\n                      }\n                      s = tmp;\n                    } else {\n                      s = calloc(1, yyget_leng(scanner) - 1);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);\n                    }\n                    $$ = &s;\n                  }\n\nstring_1: tmp_string optsep string_2\n\n\nstring_2: @EMPTYDIR@\n  |  string_2 '+' optsep\n     STRING { if (yyget_leng(scanner) > 2) {\n                int length_s = strlen(s), length_tmp = yyget_leng(scanner);\n                char *tmp;\n\n                tmp = realloc(s, length_s + length_tmp - 1);\n                if (!tmp) {\n                  LOGMEM(trg->ctx);\n                  YYABORT;\n                }\n                s = tmp;\n                if (yyget_text(scanner)[0] == '\"') {\n                  if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {\n                    YYABORT;\n                  }\n                  s = tmp;\n                } else {\n                  memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);\n                  s[length_s + length_tmp - 2] = '\\0';\n                }\n              }\n            }\n     optsep;\n\nmodule_arg_str: identifier_arg_str { if (param->submodule) {\n                                       free(s);\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"module\");\n                                       YYABORT;\n                                     }\n                                     trg = param->module;\n                                     yang_read_common(trg,s,MODULE_KEYWORD);\n                                     s = NULL;\n                                     actual_type = MODULE_KEYWORD;\n                                   }\n\nmodule_stmt: optsep MODULE_KEYWORD sep module_arg_str\n             '{' stmtsep\n                 module_header_stmts\n                 linkage_stmts\n                 meta_stmts\n                 revision_stmts\n                 body_stmts_end\n             '}' optsep\n\n\nmodule_header_stmts: module_header_stmt { if (!param->module->ns) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"namespace\", \"module\");\n                                            YYABORT;\n                                          }\n                                          if (!param->module->prefix) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"module\");\n                                            YYABORT;\n                                          }\n                                        }\n\nmodule_header_stmt: @EMPTYDIR@  { $$ = 0; }\n  |  module_header_stmt yang_version_stmt { if (yang_check_version(param->module, param->submodule, s, $1)) {\n                                              YYABORT;\n                                            }\n                                            $$ = 1;\n                                            s = NULL;\n                                          }\n  |  module_header_stmt namespace_stmt { if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  module_header_stmt prefix_stmt { if (yang_read_prefix(trg, NULL, s)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\nsubmodule_arg_str: identifier_arg_str { if (!param->submodule) {\n                                          free(s);\n                                          LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);\n                                          YYABORT;\n                                        }\n                                        trg = (struct lys_module *)param->submodule;\n                                        yang_read_common(trg,s,MODULE_KEYWORD);\n                                        s = NULL;\n                                        actual_type = SUBMODULE_KEYWORD;\n                                      }\n\nsubmodule_stmt: optsep SUBMODULE_KEYWORD sep submodule_arg_str\n                '{' stmtsep\n                    submodule_header_stmts\n                    linkage_stmts\n                    meta_stmts\n                    revision_stmts\n                    body_stmts_end\n                '}' optsep\n\n\nsubmodule_header_stmts: submodule_header_stmt { if (!param->submodule->prefix) {\n                                                  LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                                  YYABORT;\n                                                }\n                                                if (!$1) {\n                                                  /* check version compatibility with the main module */\n                                                  if (param->module->version > 1) {\n                                                      LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                                                      YYABORT;\n                                                  }\n                                                }\n                                              }\n\nsubmodule_header_stmt: @EMPTYDIR@ { $$ = 0; }\n  |  submodule_header_stmt yang_version_stmt { if (yang_check_version(param->module, param->submodule, s, $1)) {\n                                                 YYABORT;\n                                               }\n                                               $$ = 1;\n                                               s = NULL;\n                                             }\n  |  submodule_header_stmt belongs_to_stmt stmtsep\n\nyang_version_arg: string { backup_type = actual_type;\n                           actual_type = YANG_VERSION_KEYWORD;\n                         }\n\nyang_version_stmt: YANG_VERSION_KEYWORD sep yang_version_arg stmtend\n\nnamespace_arg_str: string { backup_type = actual_type;\n                            actual_type = NAMESPACE_KEYWORD;\n                          }\n\nnamespace_stmt: NAMESPACE_KEYWORD sep namespace_arg_str stmtend\n\nlinkage_stmts: @EMPTYDIR@\n |  linkage_stmts import_stmt stmtsep\n |  linkage_stmts include_stmt stmtsep\n\nimport_stmt: IMPORT_KEYWORD sep import_arg_str\n             '{' stmtsep\n                 import_opt_stmt\n             '}' { actual_type = $3;\n                   backup_type = NODE;\n                   actual = NULL;\n                 }\n\nimport_arg_str: identifier_arg_str { YANG_ADDELEM(trg->imp, trg->imp_size, \"imports\");\n                                     /* HACK for unres */\n                                     ((struct lys_import *)actual)->module = (struct lys_module *)s;\n                                     s = NULL;\n                                     $$ = actual_type;\n                                     actual_type = IMPORT_KEYWORD;\n                                   }\n\nimport_opt_stmt: @EMPTYDIR@ { $$ = 0; }\n  |  import_opt_stmt prefix_stmt { if (yang_read_prefix(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  import_opt_stmt description_stmt { if (trg->version != 2) {\n                                          LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                          free(s);\n                                          YYABORT;\n                                        }\n                                        if (yang_read_description(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        $$ = $1;\n                                      }\n  |  import_opt_stmt reference_stmt { if (trg->version != 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      if (yang_read_reference(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      $$ = $1;\n                                    }\n  |  import_opt_stmt revision_date_stmt { if ($1) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"import\");\n                                            free(s);\n                                            YYABORT;\n                                          }\n                                          memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);\n                                          free(s);\n                                          s = NULL;\n                                          $$ = 1;\n                                        }\n\ninclude_arg_str: identifier_arg_str { YANG_ADDELEM(trg->inc, trg->inc_size, \"includes\");\n                                     /* HACK for unres */\n                                     ((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;\n                                     s = NULL;\n                                     $$ = actual_type;\n                                     actual_type = INCLUDE_KEYWORD;\n                                   }\n\ninclude_stmt: INCLUDE_KEYWORD sep include_arg_str include_end { actual_type = $3;\n                                                                backup_type = NODE;\n                                                                actual = NULL;\n                                                              }\n\ninclude_end: ';'\n  | '{' stmtsep\n        include_opt_stmt\n    '}'\n\ninclude_opt_stmt: @EMPTYDIR@ { $$ = 0; }\n  |  include_opt_stmt description_stmt { if (trg->version != 2) {\n                                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                           free(s);\n                                           YYABORT;\n                                         }\n                                         if (yang_read_description(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                            YYABORT;\n                                         }\n                                         s = NULL;\n                                         $$ = $1;\n                                       }\n  |  include_opt_stmt reference_stmt { if (trg->version != 2) {\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                         free(s);\n                                         YYABORT;\n                                       }\n                                       if (yang_read_reference(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       $$ = $1;\n                                     }\n  |  include_opt_stmt revision_date_stmt { if ($1) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"include\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);\n                                           free(s);\n                                           s = NULL;\n                                           $$ = 1;\n                                         }\n\nrevision_date_arg: date_arg_str { backup_type = actual_type;\n                                  actual_type = REVISION_DATE_KEYWORD;\n                                }\n\nrevision_date_stmt: REVISION_DATE_KEYWORD sep revision_date_arg stmtend\n\nbelongs_to_arg_str: identifier_arg_str { $$ = actual_type;\n                                         if (is_ext_instance) {\n                                           if (yang_read_extcomplex_str(trg, ext_instance, \"belongs-to\", ext_name, s,\n                                                                        0, LY_STMT_BELONGSTO)) {\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           if (param->submodule->prefix) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {\n                                             LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"belongs-to\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           free(s);\n                                         }\n                                         s = NULL;\n                                         actual_type = BELONGS_TO_KEYWORD;\n                                       }\n\nbelongs_to_stmt: BELONGS_TO_KEYWORD sep belongs_to_arg_str\n                 '{' stmtsep\n                     prefix_stmt\n                 '}' { if (is_ext_instance) {\n                         if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", \"belongs-to\", s,\n                                                      LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {\n                           YYABORT;\n                         }\n                       } else {\n                         if (yang_read_prefix(trg, NULL, s)) {\n                           YYABORT;\n                         }\n                       }\n                       s = NULL;\n                       actual_type = $3;\n                     }\n\nprefix_arg: prefix_arg_str { backup_type = actual_type;\n                             actual_type = PREFIX_KEYWORD;\n                           }\n\nprefix_stmt: PREFIX_KEYWORD sep prefix_arg stmtend\n\nmeta_stmts: @EMPTYDIR@\n  |  meta_stmts organization_stmt { if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  meta_stmts contact_stmt { if (yang_read_common(trg, s, CONTACT_KEYWORD)) {\n                                 YYABORT;\n                               }\n                               s = NULL;\n                             }\n  |  meta_stmts description_stmt { if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  meta_stmts reference_stmt { if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                   YYABORT;\n                                 }\n                                 s=NULL;\n                               }\n\norganization_arg: string { backup_type = actual_type;\n                           actual_type = ORGANIZATION_KEYWORD;\n                         }\n\norganization_stmt: ORGANIZATION_KEYWORD sep organization_arg stmtend\n\ncontact_arg: string { backup_type = actual_type;\n                      actual_type = CONTACT_KEYWORD;\n                    }\n\ncontact_stmt: CONTACT_KEYWORD sep contact_arg stmtend\n\ndescription_arg: string { backup_type = actual_type;\n                          actual_type = DESCRIPTION_KEYWORD;\n                        }\n\ndescription_stmt: DESCRIPTION_KEYWORD sep description_arg stmtend\n\nreference_arg: string { backup_type = actual_type;\n                        actual_type = REFERENCE_KEYWORD;\n                      }\n\nreference_stmt: REFERENCE_KEYWORD sep reference_arg stmtend\n\nrevision_stmts: revision_stmts_opt { if (trg->rev_size) {\n                                      struct lys_revision *tmp;\n\n                                      tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);\n                                      if (!tmp) {\n                                        LOGMEM(trg->ctx);\n                                        YYABORT;\n                                      }\n                                      trg->rev = tmp;\n                                    }\n                                  }\n\n\nrevision_arg_stmt: date_arg_str { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  if (!is_ext_instance) {\n                                    YANG_ADDELEM(trg->rev, trg->rev_size, \"revisions\");\n                                  }\n                                  memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);\n                                  free(s);\n                                  s = NULL;\n                                  actual_type = REVISION_KEYWORD;\n                                }\n\nrevision_stmts_opt: @EMPTYDIR@\n  |  revision_stmts_opt revision_stmt stmtsep { int i;\n\n                                                /* check uniqueness of the revision date - not required by RFC */\n                                                for (i = 0; i < (trg->rev_size - 1); i++) {\n                                                  if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {\n                                                    LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\",\n                                                           trg->rev[trg->rev_size - 1].date);\n                                                    break;\n                                                  }\n                                                }\n                                              }\n\nrevision_stmt: REVISION_KEYWORD sep revision_arg_stmt revision_end { actual_type = $3.token;\n                                                                     actual = $3.actual;\n                                                                   }\n\nrevision_end: ';'\n  | '{' stmtsep\n        revision_opt_stmt\n    '}'\n\nrevision_opt_stmt: @EMPTYDIR@\n  |  revision_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"revision\",REVISION_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  revision_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"revision\", REVISION_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  ;\n\ndate_arg_str: REVISION_DATE { s = strdup(yyget_text(scanner));\n                              if (!s) {\n                                LOGMEM(trg->ctx);\n                                YYABORT;\n                              }\n                              if (lyp_check_date(trg->ctx, s)) {\n                                  free(s);\n                                  YYABORT;\n                              }\n                            }\n              optsep\n  | string_1 { if (lyp_check_date(trg->ctx, s)) {\n                   free(s);\n                   YYABORT;\n               }\n             }\n\nbody_stmts_end: body_stmts { void *tmp;\n\n                             if (trg->tpdf_size) {\n                               tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->tpdf = tmp;\n                             }\n\n                             if (trg->features_size) {\n                               tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->features = tmp;\n                             }\n\n                             if (trg->ident_size) {\n                               tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->ident = tmp;\n                             }\n\n                             if (trg->augment_size) {\n                               tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->augment = tmp;\n                             }\n\n                             if (trg->extensions_size) {\n                               tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->extensions = tmp;\n                             }\n                           }\n\nbody_stmts: @EMPTYDIR@ { /* check the module with respect to the context now */\n                         if (!param->submodule) {\n                           switch (lyp_ctx_check_module(trg)) {\n                           case -1:\n                             YYABORT;\n                           case 0:\n                             break;\n                           case 1:\n                             /* it's already there */\n                             param->flags |= YANG_EXIST_MODULE;\n                             YYABORT;\n                           }\n                         }\n                         param->flags &= (~YANG_REMOVE_IMPORT);\n                         if (yang_check_imports(trg, param->unres)) {\n                           YYABORT;\n                         }\n                         actual = NULL;\n                       }\n  | body_stmts body_stmt stmtsep { actual = NULL; }\n\n\nbody_stmt: extension_stmt\n  | feature_stmt\n  | identity_stmt\n  | typedef_stmt\n  | grouping_stmt\n  | data_def_stmt\n  | augment_stmt\n  | rpc_stmt\n  | notification_stmt\n  | deviation_stmt\n\n\nextension_arg_str: identifier_arg_str { $$.token = actual_type;\n                                        $$.actual = actual;\n                                        YANG_ADDELEM(trg->extensions, trg->extensions_size, \"extensions\");\n                                        trg->extensions_size--;\n                                        ((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                        ((struct lys_ext *)actual)->module = trg;\n                                        if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {\n                                          trg->extensions_size++;\n                                          YYABORT;\n                                        }\n                                        trg->extensions_size++;\n                                        s = NULL;\n                                        actual_type = EXTENSION_KEYWORD;\n                                      }\n\nextension_stmt: EXTENSION_KEYWORD sep extension_arg_str extension_end\n                { struct lys_ext *ext = actual;\n                  ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                }\n\nextension_end: ';'\n  | '{' stmtsep\n        extension_opt_stmt\n    '}'\n\nextension_opt_stmt: @EMPTYDIR@\n  |  extension_opt_stmt argument_stmt stmtsep\n  |  extension_opt_stmt status_stmt { if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"extension\");\n                                        YYABORT;\n                                      }\n                                      ((struct lys_ext *)actual)->flags |= $2;\n                                    }\n  |  extension_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"extension\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  extension_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"extension\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\nargument_str: identifier_arg_str { $$ = actual_type;\n                                   if (is_ext_instance) {\n                                     if (yang_read_extcomplex_str(trg, ext_instance, \"argument\", ext_name, s,\n                                                                  0, LY_STMT_ARGUMENT)) {\n                                       YYABORT;\n                                     }\n                                   } else {\n                                     if (((struct lys_ext *)actual)->argument) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"argument\", \"extension\");\n                                        free(s);\n                                        YYABORT;\n                                     }\n                                     ((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);\n                                   }\n                                   s = NULL;\n                                   actual_type = ARGUMENT_KEYWORD;\n                                 }\n\nargument_stmt: ARGUMENT_KEYWORD sep  argument_str argument_end { actual_type = $3; }\n\nargument_end: ';'\n  | '{' stmtsep\n        yin_element_stmt\n    '}'\n\nyin_element_arg: yin_element_arg_str { $$ = $1;\n                                       backup_type = actual_type;\n                                       actual_type = YIN_ELEMENT_KEYWORD;\n                                     }\n\nyin_element_stmt: @EMPTYDIR@\n  |  YIN_ELEMENT_KEYWORD sep yin_element_arg stmtend\n     { if (is_ext_instance) {\n         int c;\n         const char ***p;\n         uint8_t *val;\n         struct lyext_substmt *info;\n\n         c = 0;\n         p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);\n         if (info->cardinality >= LY_STMT_CARD_SOME) {\n           /* get the index in the array to add new item */\n           for (c = 0; p[0][c + 1]; c++);\n           val = (uint8_t *)p[1];\n         } else {\n           val = (uint8_t *)(p + 1);\n         }\n         val[c] = ($3 == LYS_YINELEM) ? 1 : 2;\n       } else {\n         ((struct lys_ext *)actual)->flags |= $3;\n       }\n     }\n\nyin_element_arg_str: TRUE_KEYWORD optsep { $$ = LYS_YINELEM; }\n  | FALSE_KEYWORD optsep { $$ = 0; }\n  | string_1 { if (!strcmp(s, \"true\")) {\n                 $$ = LYS_YINELEM;\n               } else if (!strcmp(s, \"false\")) {\n                 $$ = 0;\n               } else {\n                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\nstatus_arg: status_arg_str { $$ = $1;\n                             backup_type = actual_type;\n                             actual_type = STATUS_KEYWORD;\n                           }\n\nstatus_stmt:  STATUS_KEYWORD sep status_arg stmtend { $$ = $3; }\n\nstatus_arg_str: CURRENT_KEYWORD optsep { $$ = LYS_STATUS_CURR; }\n  | OBSOLETE_KEYWORD optsep { $$ = LYS_STATUS_OBSLT; }\n  | DEPRECATED_KEYWORD optsep { $$ = LYS_STATUS_DEPRC; }\n  | string_1 { if (!strcmp(s, \"current\")) {\n                 $$ = LYS_STATUS_CURR;\n               } else if (!strcmp(s, \"obsolete\")) {\n                 $$ = LYS_STATUS_OBSLT;\n               } else if (!strcmp(s, \"deprecated\")) {\n                 $$ = LYS_STATUS_DEPRC;\n               } else {\n                 LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\nfeature_arg_str: identifier_arg_str { /* check uniqueness of feature's names */\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      $$.token = actual_type;\n                                      $$.actual = actual;\n                                      YANG_ADDELEM(trg->features, trg->features_size, \"features\");\n                                      ((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);\n                                      ((struct lys_feature *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = FEATURE_KEYWORD;\n                                    }\n\nfeature_stmt: FEATURE_KEYWORD sep feature_arg_str feature_end\n              { actual = $3.actual;\n                actual_type = $3.token;\n              }\n\nfeature_end: ';'\n  | '{' stmtsep\n        feature_opt_stmt\n    '}' { struct lys_iffeature *tmp;\n\n          if (((struct lys_feature *)actual)->iffeature_size) {\n            tmp = realloc(((struct lys_feature *)actual)->iffeature,\n                          ((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);\n            if (!tmp) {\n              LOGMEM(trg->ctx);\n              YYABORT;\n            }\n            ((struct lys_feature *)actual)->iffeature = tmp;\n          }\n        }\n\nfeature_opt_stmt: @EMPTYDIR@\n  |  feature_opt_stmt if_feature_stmt stmtsep\n  |  feature_opt_stmt status_stmt { if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"feature\");\n                                      YYABORT;\n                                    }\n                                    ((struct lys_feature *)actual)->flags |= $2;\n                                  }\n  |  feature_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"feature\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  feature_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"feature\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\nif_feature_arg: string { $$.token = actual_type;\n                         $$.actual = actual;\n                         switch (actual_type) {\n                         case FEATURE_KEYWORD:\n                           YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,\n                                        ((struct lys_feature *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case IDENTITY_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"identity\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,\n                                        ((struct lys_ident *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case ENUM_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,\n                                        ((struct lys_type_enum *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case BIT_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"bit\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,\n                                        ((struct lys_type_bit *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case REFINE_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,\n                                        ((struct lys_refine *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case EXTENSION_INSTANCE:\n                           /* nothing change */\n                           break;\n                         default:\n                           /* lys_node_* */\n                           YANG_ADDELEM(((struct lys_node *)actual)->iffeature,\n                                        ((struct lys_node *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         }\n                         ((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;\n                         s = NULL;\n                         actual_type = IF_FEATURE_KEYWORD;\n                       }\n\nif_feature_stmt: IF_FEATURE_KEYWORD sep if_feature_arg if_feature_end\n                 { actual = $3.actual;\n                   actual_type = $3.token;\n                 }\n\nif_feature_end: ';'\n  | '{' stmtsep '}'\n\nidentity_arg_str: identifier_arg_str { const char *tmp;\n\n                                       tmp = lydict_insert_zc(trg->ctx, s);\n                                       s = NULL;\n                                       if (dup_identities_check(tmp, trg)) {\n                                         lydict_remove(trg->ctx, tmp);\n                                         YYABORT;\n                                       }\n                                       $$.token = actual_type;\n                                       $$.actual = actual;\n                                       YANG_ADDELEM(trg->ident, trg->ident_size, \"identities\");\n                                       ((struct lys_ident *)actual)->name = tmp;\n                                       ((struct lys_ident *)actual)->module = trg;\n                                       actual_type = IDENTITY_KEYWORD;\n                                     }\n\nidentity_stmt: IDENTITY_KEYWORD sep identity_arg_str identity_end\n               { actual = $3.actual;\n                 actual_type = $3.token;\n               }\n\nidentity_end: ';'\n  |  '{' stmtsep\n         identity_opt_stmt\n     '}' { void *tmp;\n\n           if (((struct lys_ident *)actual)->base_size) {\n             tmp = realloc(((struct lys_ident *)actual)->base,\n                           ((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->base = tmp;\n           }\n\n           if (((struct lys_ident *)actual)->iffeature_size) {\n             tmp = realloc(((struct lys_ident *)actual)->iffeature,\n                           ((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->iffeature = tmp;\n           }\n         }\n\nidentity_opt_stmt: @EMPTYDIR@\n  |  identity_opt_stmt base_stmt { void *identity;\n\n                                   if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {\n                                     free(s);\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"base\", \"identity\");\n                                     YYABORT;\n                                   }\n                                   identity = actual;\n                                   YANG_ADDELEM(((struct lys_ident *)actual)->base,\n                                                ((struct lys_ident *)actual)->base_size, \"bases\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   s = NULL;\n                                   actual = identity;\n                                 }\n  |  identity_opt_stmt if_feature_stmt stmtsep\n  |  identity_opt_stmt status_stmt { if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"identity\");\n                                       YYABORT;\n                                     }\n                                     ((struct lys_ident *)actual)->flags |= $2;\n                                   }\n  |  identity_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"identity\", NODE)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  identity_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"identity\", NODE)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\nbase_arg: identifier_ref_arg_str { backup_type = actual_type;\n                                   actual_type = BASE_KEYWORD;\n                                 }\n\nbase_stmt: BASE_KEYWORD sep base_arg stmtend\n\ntypedef_arg_str: identifier_arg_str { tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;\n                                      $$.token = actual_type;\n                                      $$.actual = actual;\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      switch (actual_type) {\n                                      case MODULE_KEYWORD:\n                                      case SUBMODULE_KEYWORD:\n                                        YANG_ADDELEM(trg->tpdf, trg->tpdf_size, \"typedefs\");\n                                        break;\n                                      case GROUPING_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_grp *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case CONTAINER_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_container *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case LIST_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_list *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case RPC_KEYWORD:\n                                      case ACTION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case INPUT_KEYWORD:\n                                      case OUTPUT_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_inout *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case NOTIFICATION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_notif *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case EXTENSION_INSTANCE:\n                                        /* typedef is already allocated */\n                                        break;\n                                      default:\n                                        /* another type of nodetype is error*/\n                                        LOGINT(trg->ctx);\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      ((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                      ((struct lys_tpdf *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = TYPEDEF_KEYWORD;\n                                    }\n\ntypedef_stmt: TYPEDEF_KEYWORD sep typedef_arg_str\n              '{' stmtsep\n                  type_opt_stmt\n              '}' { if (!($6.node.flag & LYS_TYPE_DEF)) {\n                      LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"typedef\");\n                      YYABORT;\n                    }\n                    actual_type = $3.token;\n                    actual = $3.actual;\n                  }\n\ntype_opt_stmt: @EMPTYDIR@ { $$.node.ptr_tpdf = actual;\n                            $$.node.flag = 0;\n                          }\n  |  type_opt_stmt type_stmt stmtsep { $1.node.flag |= LYS_TYPE_DEF;\n                                       $$ = $1;\n                                     }\n  |  type_opt_stmt units_stmt { if (yang_read_units(trg, $1.node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n  |  type_opt_stmt default_stmt { if (yang_read_default(trg, $1.node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n  |  type_opt_stmt status_stmt { if ($1.node.ptr_tpdf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"typedef\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_tpdf->flags |= $2;\n                               }\n  |  type_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  type_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\ntype_stmt: TYPE_KEYWORD sep type_arg_str type_end\n           { actual_type = $3.token;\n             actual = $3.actual;\n           }\n\ntype_arg_str: identifier_ref_arg_str { $$.token = actual_type;\n                                       $$.actual = actual;\n                                       if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       actual_type = TYPE_KEYWORD;\n                                     }\n\ntype_end: ';'\n  |  '{' stmtsep\n         type_body_stmts\n      '}'\n\ntype_body_stmts: some_restrictions { if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&\n                                         ((struct yang_type *)actual)->type->info.str.pat_count) {\n                                       void *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,\n                                                     ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.str.patterns = tmp;\n\n#ifdef LY_ENABLED_CACHE\n                                       if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,\n                                                       2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;\n                                       }\n#endif\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {\n                                       struct lys_type *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,\n                                                     ((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.uni.types = tmp;\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {\n                                       struct lys_ident **tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,\n                                                     ((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.ident.ref = tmp;\n                                     }\n                                   }\n  | enum_specification\n  | bits_specification\n\nsome_restrictions: @EMPTYDIR@\n  |  some_restrictions require_instance_stmt { if (yang_read_require_instance(trg->ctx, actual, $2)) {\n                                                 YYABORT;\n                                               }\n                                             }\n  |  some_restrictions path_stmt { /* leafref_specification */\n                                   if (yang_read_leafref_path(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  some_restrictions base_stmt { /* identityref_specification */\n                                   if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {\n                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");\n                                     return EXIT_FAILURE;\n                                   }\n                                   ((struct yang_type *)actual)->base = LY_TYPE_IDENT;\n                                   yang_type = actual;\n                                   YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,\n                                                ((struct yang_type *)actual)->type->info.ident.count, \"identity refs\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   actual = yang_type;\n                                   s = NULL;\n                                 }\n  |  some_restrictions length_stmt stmtsep\n  |  some_restrictions pattern_stmt stmtsep\n  |  some_restrictions fraction_digits_stmt { if (yang_read_fraction(trg->ctx, actual, $2)) {\n                                                YYABORT;\n                                              }\n                                            }\n  |  some_restrictions range_stmt stmtsep\n  |  some_restrictions union_stmt stmtsep\n\nunion_stmt: union_spec type_stmt { actual_type = $1.token;\n                                   actual = $1.actual;\n                                 }\n\nunion_spec: @EMPTYDIR@ { struct yang_type *stype = (struct yang_type *)actual;\n\n                         $$.token = actual_type;\n                         $$.actual = actual;\n                         if (stype->base != 0 && stype->base != LY_TYPE_UNION) {\n                           LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected type statement.\");\n                           YYABORT;\n                         }\n                         stype->base = LY_TYPE_UNION;\n                         if (strcmp(stype->name, \"union\")) {\n                           /* type can be a substatement only in \"union\" type, not in derived types */\n                           LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"derived type\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, \"union types\")\n                         actual_type = UNION_KEYWORD;\n                       }\n\nfraction_digits_arg: fraction_digits_arg_str { $$ = $1;\n                                               backup_type = actual_type;\n                                               actual_type = FRACTION_DIGITS_KEYWORD;\n                                             }\n\nfraction_digits_stmt: FRACTION_DIGITS_KEYWORD sep fraction_digits_arg stmtend { $$ = $3; }\n\nfraction_digits_arg_str: positive_integer_value optsep { $$ = $1; }\n  | string_1 { char *endptr = NULL;\n               unsigned long val;\n               errno = 0;\n\n               val = strtoul(s, &endptr, 10);\n               if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                 LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"fraction-digits\");\n                 free(s);\n                 s = NULL;\n                 YYABORT;\n               }\n               $$ = (uint32_t) val;\n               free(s);\n               s =NULL;\n             }\n\nlength_stmt: LENGTH_KEYWORD sep length_arg_str length_end\n             { actual = $3.actual;\n               actual_type = $3.token;\n             }\n\nlength_arg_str: string { $$.token = actual_type;\n                         $$.actual = actual;\n                         if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {\n                           YYABORT;\n                         }\n                         actual_type = LENGTH_KEYWORD;\n                         s = NULL;\n                       }\n\nlength_end: ';'\n  |  '{' stmtsep\n         message_opt_stmt\n      '}'\n\nmessage_opt_stmt: @EMPTYDIR@ { switch (actual_type) {\n                               case MUST_KEYWORD:\n                                 $$ = \"must\";\n                                 break;\n                               case LENGTH_KEYWORD:\n                                 $$ = \"length\";\n                                 break;\n                               case RANGE_KEYWORD:\n                                 $$ = \"range\";\n                                 break;\n                               default:\n                                 LOGINT(trg->ctx);\n                                 YYABORT;\n                                 break;\n                               }\n                             }\n  |  message_opt_stmt error_message_stmt { if (yang_read_message(trg, actual, s, $1, ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  message_opt_stmt error_app_tag_stmt { if (yang_read_message(trg, actual, s, $1, ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  message_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, $1, NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  message_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, $1, NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\npattern_sep: sep { $$.token = actual_type;\n                   $$.actual = actual;\n                 }\n\npattern_stmt: PATTERN_KEYWORD pattern_sep pattern_arg_str pattern_end  {struct lys_restr *pattern = actual;\n                                                                        actual = NULL;\n#ifdef LY_ENABLED_CACHE\n                                                                        if ($2.token != EXTENSION_INSTANCE &&\n                                                                            !(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {\n                                                                          unsigned int c = 2 * (((struct yang_type *)$2.actual)->type->info.str.pat_count - 1);\n                                                                          YANG_ADDELEM(((struct yang_type *)$2.actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          ++c;\n                                                                          YANG_ADDELEM(((struct yang_type *)$2.actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          actual = &(((struct yang_type *)$2.actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)$2.actual)->type->info.str.pat_count - 1)];\n                                                                        }\n#endif\n                                                                        if (yang_read_pattern(trg->ctx, pattern, actual, $3, $4)) {\n                                                                          YYABORT;\n                                                                        }\n                                                                        actual_type = $2.token;\n                                                                        actual = $2.actual;\n                                                                      }\n\npattern_arg_str: string { if (actual_type != EXTENSION_INSTANCE) {\n                            if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {\n                              free(s);\n                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected pattern statement.\");\n                              YYABORT;\n                            }\n                            ((struct yang_type *)actual)->base = LY_TYPE_STRING;\n                            YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,\n                                         ((struct yang_type *)actual)->type->info.str.pat_count, \"patterns\");\n                          }\n                          $$ = s;\n                          s = NULL;\n                          actual_type = PATTERN_KEYWORD;\n                        }\n\npattern_end: ';' { $$ = 0x06; }\n  |  '{' stmtsep\n         pattern_opt_stmt\n     '}' { $$ = $3; }\n\npattern_opt_stmt: @EMPTYDIR@ { $$ = 0x06; /* ACK */ }\n  |  pattern_opt_stmt modifier_stmt { if (trg->version < 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"modifier\");\n                                        YYABORT;\n                                      }\n                                      if ($1 != 0x06) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"modifier\", \"pattern\");\n                                        YYABORT;\n                                      }\n                                      $$ = $2;\n                                    }\n  |  pattern_opt_stmt error_message_stmt { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  pattern_opt_stmt error_app_tag_stmt { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  pattern_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"pattern\", NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  pattern_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"pattern\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\nmodifier_arg: string { backup_type = actual_type;\n                       actual_type = MODIFIER_KEYWORD;\n                     }\n\nmodifier_stmt: MODIFIER_KEYWORD sep modifier_arg stmtend { if (!strcmp(s, \"invert-match\")) {\n                                                             $$ = 0x15;\n                                                             free(s);\n                                                             s = NULL;\n                                                           } else {\n                                                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                                                             free(s);\n                                                             YYABORT;\n                                                           }\n                                                         }\n\nenum_specification: enum_stmt stmtsep enum_stmts { struct lys_type_enum * tmp;\n\n                                                   cnt_val = 0;\n                                                   tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,\n                                                                 ((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);\n                                                   if (!tmp) {\n                                                     LOGMEM(trg->ctx);\n                                                     YYABORT;\n                                                   }\n                                                   ((struct yang_type *)actual)->type->info.enums.enm = tmp;\n                                                 }\n\nenum_stmts: @EMPTYDIR@\n  | enum_stmts enum_stmt stmtsep;\n\n\nenum_stmt: ENUM_KEYWORD sep enum_arg_str enum_end\n           { if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n               YYABORT;\n             }\n             actual = $3.actual;\n             actual_type = $3.token;\n           }\n\nenum_arg_str: string { $$.token = actual_type;\n                       $$.actual = yang_type = actual;\n                       YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, \"enums\");\n                       if (yang_read_enum(trg->ctx, yang_type, actual, s)) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       is_value = 0;\n                       actual_type = ENUM_KEYWORD;\n                     }\n\nenum_end: ';'\n  |  '{' stmtsep\n         enum_opt_stmt\n     '}' { if (((struct lys_type_enum *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_enum *)actual)->iffeature,\n                           ((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_enum *)actual)->iffeature = tmp;\n           }\n         }\n\nenum_opt_stmt: @EMPTYDIR@\n  |  enum_opt_stmt if_feature_stmt stmtsep\n  |  enum_opt_stmt value_stmt { if (is_value) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"value\", \"enum\");\n                                  YYABORT;\n                                }\n                                ((struct lys_type_enum *)actual)->value = $2;\n\n                                /* keep the highest enum value for automatic increment */\n                                if ($2 >= cnt_val) {\n                                  cnt_val = $2 + 1;\n                                }\n                                is_value = 1;\n                              }\n  |  enum_opt_stmt status_stmt { if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"enum\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_enum *)actual)->flags |= $2;\n                               }\n  |  enum_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"enum\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  enum_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"enum\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\nvalue_arg: integer_value_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = VALUE_KEYWORD;\n                                 }\n\nvalue_stmt: VALUE_KEYWORD sep value_arg stmtend { $$ = $3; }\n\ninteger_value_arg_str: integer_value optsep { $$ = $1; }\n  |  string_1 { /* convert it to int32_t */\n                int64_t val;\n                char *endptr;\n\n                val = strtoll(s, &endptr, 10);\n                if (val < INT32_MIN || val > INT32_MAX || *endptr) {\n                    LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"value\");\n                    free(s);\n                    YYABORT;\n                }\n                free(s);\n                s = NULL;\n                $$ = (int32_t) val;\n             }\n\nrange_stmt: RANGE_KEYWORD sep range_arg_str range_end { actual_type = $3.token;\n                                                        actual = $3.actual;\n                                                      }\n\n\nrange_end: ';'\n  |  '{' stmtsep\n         message_opt_stmt\n      '}'\n   ;\n\npath_arg: path_arg_str { backup_type = actual_type;\n                         actual_type = PATH_KEYWORD;\n                       }\n\npath_stmt: PATH_KEYWORD sep path_arg stmtend\n\nrequire_instance_arg: require_instance_arg_str { $$ = $1;\n                                                 backup_type = actual_type;\n                                                 actual_type = REQUIRE_INSTANCE_KEYWORD;\n                                               }\n\nrequire_instance_stmt: REQUIRE_INSTANCE_KEYWORD sep require_instance_arg stmtend { $$ = $3; }\n\nrequire_instance_arg_str: TRUE_KEYWORD optsep { $$ = 1; }\n  |  FALSE_KEYWORD optsep { $$ = -1; }\n  |  string_1 { if (!strcmp(s,\"true\")) {\n                  $$ = 1;\n                } else if (!strcmp(s,\"false\")) {\n                  $$ = -1;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"require-instance\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\nbits_specification: bit_stmt bit_stmts { struct lys_type_bit * tmp;\n\n                                         cnt_val = 0;\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,\n                                                       ((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.bits.bit = tmp;\n                                       }\n\nbit_stmts: @EMPTYDIR@\n  | bit_stmts bit_stmt;\n\nbit_stmt: BIT_KEYWORD sep bit_arg_str bit_end\n          stmtsep { if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n                      YYABORT;\n                    }\n                    actual = $3.actual;\n                    actual_type = $3.token;\n                  }\n\nbit_arg_str: identifier_arg_str { $$.token = actual_type;\n                                  $$.actual = yang_type = actual;\n                                  YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,\n                                               ((struct yang_type *)actual)->type->info.bits.count, \"bits\");\n                                  if (yang_read_bit(trg->ctx, yang_type, actual, s)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                  is_value = 0;\n                                  actual_type = BIT_KEYWORD;\n                                }\n\nbit_end: ';'\n  |  '{' stmtsep\n         bit_opt_stmt\n     '}' { if (((struct lys_type_bit *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_bit *)actual)->iffeature,\n                           ((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_bit *)actual)->iffeature = tmp;\n           }\n         }\n\nbit_opt_stmt: @EMPTYDIR@\n  |  bit_opt_stmt if_feature_stmt stmtsep\n  |  bit_opt_stmt position_stmt { if (is_value) {\n                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"position\", \"bit\");\n                                    YYABORT;\n                                  }\n                                  ((struct lys_type_bit *)actual)->pos = $2;\n\n                                  /* keep the highest position value for automatic increment */\n                                  if ($2 >= cnt_val) {\n                                    cnt_val = $2 + 1;\n                                  }\n                                  is_value = 1;\n                                }\n  |  bit_opt_stmt status_stmt { if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"bit\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_bit *)actual)->flags |= $2;\n                              }\n  |  bit_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"bit\", NODE)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n  |  bit_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"bit\", NODE)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\nposition_value_arg: position_value_arg_str { $$ = $1;\n                                             backup_type = actual_type;\n                                             actual_type = POSITION_KEYWORD;\n                                           }\n\nposition_stmt: POSITION_KEYWORD sep position_value_arg stmtend { $$ = $3; }\n\nposition_value_arg_str: non_negative_integer_value optsep { $$ = $1; }\n  |  string_1 { /* convert it to uint32_t */\n                unsigned long val;\n                char *endptr = NULL;\n                errno = 0;\n\n                val = strtoul(s, &endptr, 10);\n                if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"position\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n                $$ = (uint32_t) val;\n              }\n\nerror_message_arg: string { backup_type = actual_type;\n                            actual_type = ERROR_MESSAGE_KEYWORD;\n                          }\n\nerror_message_stmt: ERROR_MESSAGE_KEYWORD sep error_message_arg stmtend\n\nerror_app_tag_arg: string { backup_type = actual_type;\n                            actual_type = ERROR_APP_TAG_KEYWORD;\n                          }\n\nerror_app_tag_stmt: ERROR_APP_TAG_KEYWORD sep error_app_tag_arg stmtend\n\nunits_arg: string { backup_type = actual_type;\n                    actual_type = UNITS_KEYWORD;\n                  }\n\nunits_stmt: UNITS_KEYWORD sep units_arg stmtend\n\ndefault_arg: string { backup_type = actual_type;\n                      actual_type = DEFAULT_KEYWORD;\n                    }\n\ndefault_stmt: DEFAULT_KEYWORD sep default_arg stmtend\n\ngrouping_arg_str: identifier_arg_str { $$.token = actual_type;\n                                       $$.actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       data_node = actual;\n                                       actual_type = GROUPING_KEYWORD;\n                                     }\n\ngrouping_stmt: GROUPING_KEYWORD sep grouping_arg_str grouping_end\n               { LOGDBG(LY_LDGYANG, \"finished parsing grouping statement \\\"%s\\\"\", data_node->name);\n                 actual_type = $3.token;\n                 actual = $3.actual;\n                 data_node = $3.actual;\n               }\n\ngrouping_end: ';'\n  |  '{' stmtsep\n         grouping_opt_stmt\n     '}'\n\ngrouping_opt_stmt: @EMPTYDIR@ { $$.grouping = actual; }\n  |  grouping_opt_stmt status_stmt { if ($1.grouping->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.grouping, \"status\", \"grouping\");\n                                       YYABORT;\n                                     }\n                                     $1.grouping->flags |= $2;\n                                   }\n  |  grouping_opt_stmt description_stmt { if (yang_read_description(trg, $1.grouping, s, \"grouping\", NODE_PRINT)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  grouping_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.grouping, s, \"grouping\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  |  grouping_opt_stmt grouping_stmt stmtsep\n  |  grouping_opt_stmt typedef_stmt stmtsep\n  |  grouping_opt_stmt data_def_stmt stmtsep\n  |  grouping_opt_stmt action_stmt stmtsep\n  |  grouping_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.grouping, \"notification\");\n                                                     YYABORT;\n                                                   }\n                                                 }\n\ndata_def_stmt: container_stmt\n  |  leaf_stmt\n  |  leaf_list_stmt\n  |  list_stmt\n  |  choice_stmt\n  |  anyxml_stmt\n  |  anydata_stmt\n  |  uses_stmt\n  ;\n\ncontainer_arg_str: identifier_arg_str { $$.token = actual_type;\n                                        $$.actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = CONTAINER_KEYWORD;\n                                      }\n\ncontainer_stmt: CONTAINER_KEYWORD sep container_arg_str container_end\n                { LOGDBG(LY_LDGYANG, \"finished parsing container statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                  data_node = $3.actual;\n                }\n\ncontainer_end: ';'\n  |  '{' stmtsep\n         container_opt_stmt\n      '}' { void *tmp;\n\n            if ($3.container->iffeature_size) {\n              tmp = realloc($3.container->iffeature, $3.container->iffeature_size * sizeof *$3.container->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.container->iffeature = tmp;\n            }\n\n            if ($3.container->must_size) {\n              tmp = realloc($3.container->must, $3.container->must_size * sizeof *$3.container->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.container->must = tmp;\n            }\n          }\n\ncontainer_opt_stmt: @EMPTYDIR@ { $$.container = actual; }\n  |  container_opt_stmt when_stmt stmtsep\n  |  container_opt_stmt if_feature_stmt stmtsep\n  |  container_opt_stmt must_stmt stmtsep\n  |  container_opt_stmt presence_stmt { if (yang_read_presence(trg, $1.container, s)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  |  container_opt_stmt config_stmt { if ($1.container->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.container, \"config\", \"container\");\n                                        YYABORT;\n                                      }\n                                      $1.container->flags |= $2;\n                                    }\n  |  container_opt_stmt status_stmt { if ($1.container->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.container, \"status\", \"container\");\n                                        YYABORT;\n                                      }\n                                      $1.container->flags |= $2;\n                                    }\n  |  container_opt_stmt description_stmt { if (yang_read_description(trg, $1.container, s, \"container\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  container_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.container, s, \"container\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  container_opt_stmt grouping_stmt stmtsep\n  |  container_opt_stmt action_stmt stmtsep\n  |  container_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                      LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.container, \"notification\");\n                                                      YYABORT;\n                                                    }\n                                                  }\n  |  container_opt_stmt typedef_stmt stmtsep\n  |  container_opt_stmt data_def_stmt stmtsep\n\nleaf_stmt: LEAF_KEYWORD sep leaf_arg_str\n           '{' stmtsep\n               leaf_opt_stmt\n            '}' { void *tmp;\n\n                  if (!($6.node.flag & LYS_TYPE_DEF)) {\n                    LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaf, \"type\", \"leaf\");\n                    YYABORT;\n                  }\n                  if ($6.node.ptr_leaf->dflt && ($6.node.ptr_leaf->flags & LYS_MAND_TRUE)) {\n                    /* RFC 6020, 7.6.4 - default statement must not with mandatory true */\n                    LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaf, \"mandatory\", \"leaf\");\n                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $6.node.ptr_leaf, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    YYABORT;\n                  }\n\n                  if ($6.node.ptr_leaf->iffeature_size) {\n                    tmp = realloc($6.node.ptr_leaf->iffeature, $6.node.ptr_leaf->iffeature_size * sizeof *$6.node.ptr_leaf->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_leaf->iffeature = tmp;\n                  }\n\n                  if ($6.node.ptr_leaf->must_size) {\n                    tmp = realloc($6.node.ptr_leaf->must, $6.node.ptr_leaf->must_size * sizeof *$6.node.ptr_leaf->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_leaf->must = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing leaf statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                  data_node = $3.actual;\n                }\n\nleaf_arg_str: identifier_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LEAF_KEYWORD;\n                                 }\n\nleaf_opt_stmt: @EMPTYDIR@ { $$.node.ptr_leaf = actual;\n                            $$.node.flag = 0;\n                          }\n  |  leaf_opt_stmt when_stmt stmtsep\n  |  leaf_opt_stmt if_feature_stmt stmtsep\n  |  leaf_opt_stmt type_stmt stmtsep { $1.node.flag |= LYS_TYPE_DEF;\n                                       $$ = $1;\n                                     }\n  |  leaf_opt_stmt units_stmt { if (yang_read_units(trg, $1.node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n  |  leaf_opt_stmt must_stmt stmtsep\n  |  leaf_opt_stmt default_stmt { if (yang_read_default(trg, $1.node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n  |  leaf_opt_stmt config_stmt { if ($1.node.ptr_leaf->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaf, \"config\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_leaf->flags |= $2;\n                               }\n  |  leaf_opt_stmt mandatory_stmt { if ($1.node.ptr_leaf->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaf, \"mandatory\", \"leaf\");\n                                      YYABORT;\n                                    }\n                                    $1.node.ptr_leaf->flags |= $2;\n                                  }\n  |  leaf_opt_stmt status_stmt { if ($1.node.ptr_leaf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaf, \"status\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_leaf->flags |= $2;\n                               }\n  |  leaf_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  leaf_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\nleaf_list_arg_str: identifier_arg_str { $$.token = actual_type;\n                                        $$.actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = LEAF_LIST_KEYWORD;\n                                      }\n\n  leaf_list_stmt: LEAF_LIST_KEYWORD sep leaf_list_arg_str\n                  '{' stmtsep\n                      leaf_list_opt_stmt\n                  '}' { void *tmp;\n\n                        if ($6.node.ptr_leaflist->flags & LYS_CONFIG_R) {\n                          /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data\n                           * ignore oredering MASK - 0x7F\n                           */\n                          $6.node.ptr_leaflist->flags &= 0x7F;\n                        }\n                        if (!($6.node.flag & LYS_TYPE_DEF)) {\n                          LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaflist, \"type\", \"leaf-list\");\n                          YYABORT;\n                        }\n                        if ($6.node.ptr_leaflist->dflt_size && $6.node.ptr_leaflist->min) {\n                          LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                          LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $6.node.ptr_leaflist,\n                                 \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                          YYABORT;\n                        }\n\n                        if ($6.node.ptr_leaflist->iffeature_size) {\n                          tmp = realloc($6.node.ptr_leaflist->iffeature, $6.node.ptr_leaflist->iffeature_size * sizeof *$6.node.ptr_leaflist->iffeature);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          $6.node.ptr_leaflist->iffeature = tmp;\n                        }\n\n                        if ($6.node.ptr_leaflist->must_size) {\n                          tmp = realloc($6.node.ptr_leaflist->must, $6.node.ptr_leaflist->must_size * sizeof *$6.node.ptr_leaflist->must);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          $6.node.ptr_leaflist->must = tmp;\n                        }\n\n                        if ($6.node.ptr_leaflist->dflt_size) {\n                          tmp = realloc($6.node.ptr_leaflist->dflt, $6.node.ptr_leaflist->dflt_size * sizeof *$6.node.ptr_leaflist->dflt);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          $6.node.ptr_leaflist->dflt = tmp;\n                        }\n\n                        LOGDBG(LY_LDGYANG, \"finished parsing leaf-list statement \\\"%s\\\"\", data_node->name);\n                        actual_type = $3.token;\n                        actual = $3.actual;\n                        data_node = $3.actual;\n                      }\n\nleaf_list_opt_stmt: @EMPTYDIR@ { $$.node.ptr_leaflist = actual;\n                                 $$.node.flag = 0;\n                               }\n  |  leaf_list_opt_stmt when_stmt stmtsep\n  |  leaf_list_opt_stmt if_feature_stmt stmtsep\n  |  leaf_list_opt_stmt type_stmt stmtsep { $1.node.flag |= LYS_TYPE_DEF;\n                                            $$ = $1;\n                                          }\n  |  leaf_list_opt_stmt default_stmt { if (trg->version < 2) {\n                                         free(s);\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.node.ptr_leaflist, \"default\");\n                                         YYABORT;\n                                       }\n                                       YANG_ADDELEM($1.node.ptr_leaflist->dflt,\n                                                    $1.node.ptr_leaflist->dflt_size, \"defaults\");\n                                       (*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);\n                                       s = NULL;\n                                       actual = $1.node.ptr_leaflist;\n                                     }\n  |  leaf_list_opt_stmt units_stmt { if (yang_read_units(trg, $1.node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n  |  leaf_list_opt_stmt must_stmt stmtsep\n  |  leaf_list_opt_stmt config_stmt { if ($1.node.ptr_leaflist->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"config\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      $1.node.ptr_leaflist->flags |= $2;\n                                    }\n  |  leaf_list_opt_stmt min_elements_stmt { if ($1.node.flag & LYS_MIN_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            $1.node.ptr_leaflist->min = $2;\n                                            $1.node.flag |= LYS_MIN_ELEMENTS;\n                                            $$ = $1;\n                                            if ($1.node.ptr_leaflist->max && ($1.node.ptr_leaflist->min > $1.node.ptr_leaflist->max)) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"min-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n  |  leaf_list_opt_stmt max_elements_stmt { if ($1.node.flag & LYS_MAX_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"max-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            $1.node.ptr_leaflist->max = $2;\n                                            $1.node.flag |= LYS_MAX_ELEMENTS;\n                                            $$ = $1;\n                                            if ($1.node.ptr_leaflist->min > $1.node.ptr_leaflist->max) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"max-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n  |  leaf_list_opt_stmt ordered_by_stmt { if ($1.node.flag & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"ordered by\", \"leaf-list\");\n                                            YYABORT;\n                                          }\n                                          if ($2 & LYS_USERORDERED) {\n                                            $1.node.ptr_leaflist->flags |= LYS_USERORDERED;\n                                          }\n                                          $1.node.flag |= $2;\n                                          $$ = $1;\n                                        }\n  |  leaf_list_opt_stmt status_stmt { if ($1.node.ptr_leaflist->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"status\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      $1.node.ptr_leaflist->flags |= $2;\n                                    }\n  |  leaf_list_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  leaf_list_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\nlist_arg_str: identifier_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LIST_KEYWORD;\n                                 }\n\nlist_stmt: LIST_KEYWORD sep list_arg_str\n           '{' stmtsep\n               list_opt_stmt\n            '}' { void *tmp;\n\n                  if ($6.node.ptr_list->iffeature_size) {\n                    tmp = realloc($6.node.ptr_list->iffeature, $6.node.ptr_list->iffeature_size * sizeof *$6.node.ptr_list->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->iffeature = tmp;\n                  }\n\n                  if ($6.node.ptr_list->must_size) {\n                    tmp = realloc($6.node.ptr_list->must, $6.node.ptr_list->must_size * sizeof *$6.node.ptr_list->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->must = tmp;\n                  }\n\n                  if ($6.node.ptr_list->tpdf_size) {\n                    tmp = realloc($6.node.ptr_list->tpdf, $6.node.ptr_list->tpdf_size * sizeof *$6.node.ptr_list->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->tpdf = tmp;\n                  }\n\n                  if ($6.node.ptr_list->unique_size) {\n                    tmp = realloc($6.node.ptr_list->unique, $6.node.ptr_list->unique_size * sizeof *$6.node.ptr_list->unique);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->unique = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing list statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                  data_node = $3.actual;\n                }\n\nlist_opt_stmt: @EMPTYDIR@ { $$.node.ptr_list = actual;\n                            $$.node.flag = 0;\n                          }\n  |  list_opt_stmt when_stmt stmtsep\n  |  list_opt_stmt if_feature_stmt stmtsep\n  |  list_opt_stmt must_stmt stmtsep\n  |  list_opt_stmt key_stmt { if ($1.node.ptr_list->keys) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"key\", \"list\");\n                                  free(s);\n                                  YYABORT;\n                              }\n                              $1.node.ptr_list->keys = (struct lys_node_leaf **)s;\n                              $$ = $1;\n                              s = NULL;\n                            }\n  |  list_opt_stmt unique_stmt { YANG_ADDELEM($1.node.ptr_list->unique, $1.node.ptr_list->unique_size, \"uniques\");\n                                 ((struct lys_unique *)actual)->expr = (const char **)s;\n                                 $$ = $1;\n                                 s = NULL;\n                                 actual = $1.node.ptr_list;\n                               }\n  |  list_opt_stmt config_stmt { if ($1.node.ptr_list->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"config\", \"list\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_list->flags |= $2;\n                               }\n  |  list_opt_stmt min_elements_stmt { if ($1.node.flag & LYS_MIN_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"min-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       $1.node.ptr_list->min = $2;\n                                       $1.node.flag |= LYS_MIN_ELEMENTS;\n                                       $$ = $1;\n                                       if ($1.node.ptr_list->max && ($1.node.ptr_list->min > $1.node.ptr_list->max)) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n  |  list_opt_stmt max_elements_stmt { if ($1.node.flag & LYS_MAX_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"max-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       $1.node.ptr_list->max = $2;\n                                       $1.node.flag |= LYS_MAX_ELEMENTS;\n                                       $$ = $1;\n                                       if ($1.node.ptr_list->min > $1.node.ptr_list->max) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n  |  list_opt_stmt ordered_by_stmt { if ($1.node.flag & LYS_ORDERED_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"ordered by\", \"list\");\n                                       YYABORT;\n                                     }\n                                     if ($2 & LYS_USERORDERED) {\n                                       $1.node.ptr_list->flags |= LYS_USERORDERED;\n                                     }\n                                     $1.node.flag |= $2;\n                                     $$ = $1;\n                                   }\n  |  list_opt_stmt status_stmt { if ($1.node.ptr_list->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"status\", \"list\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_list->flags |= $2;\n                               }\n  |  list_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  list_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  list_opt_stmt typedef_stmt stmtsep\n  |  list_opt_stmt grouping_stmt stmtsep\n  |  list_opt_stmt action_stmt stmtsep\n  |  list_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.node.ptr_list, \"notification\");\n                                                 YYABORT;\n                                               }\n                                             }\n  |  list_opt_stmt data_def_stmt stmtsep\n\nchoice_arg_str: identifier_arg_str { $$.token = actual_type;\n                                     $$.actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = CHOICE_KEYWORD;\n                                   }\n\nchoice_stmt: CHOICE_KEYWORD sep choice_arg_str choice_end\n             { LOGDBG(LY_LDGYANG, \"finished parsing choice statement \\\"%s\\\"\", data_node->name);\n               actual_type = $3.token;\n               actual = $3.actual;\n               data_node = $3.actual;\n             }\n\nchoice_end: ';'\n  |  '{' stmtsep\n         choice_opt_stmt\n     '}' { struct lys_iffeature *tmp;\n\n           if (($3.node.ptr_choice->flags & LYS_MAND_TRUE) && $3.node.ptr_choice->dflt) {\n              LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, $3.node.ptr_choice, \"default\", \"choice\");\n              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $3.node.ptr_choice, \"The \\\"default\\\" statement is forbidden on choices with \\\"mandatory\\\".\");\n              YYABORT;\n            }\n\n           if ($3.node.ptr_choice->iffeature_size) {\n             tmp = realloc($3.node.ptr_choice->iffeature, $3.node.ptr_choice->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.node.ptr_choice->iffeature = tmp;\n           }\n         }\n\nchoice_opt_stmt: @EMPTYDIR@ { $$.node.ptr_choice = actual;\n                              $$.node.flag = 0;\n                            }\n  |  choice_opt_stmt when_stmt stmtsep\n  |  choice_opt_stmt if_feature_stmt stmtsep\n  |  choice_opt_stmt default_stmt { if ($1.node.flag & LYS_CHOICE_DEFAULT) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"default\", \"choice\");\n                                      free(s);\n                                      YYABORT;\n                                    }\n                                    $1.node.ptr_choice->dflt = (struct lys_node *) s;\n                                    s = NULL;\n                                    $$ = $1;\n                                    $$.node.flag |= LYS_CHOICE_DEFAULT;\n                                  }\n  |  choice_opt_stmt config_stmt { if ($1.node.ptr_choice->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"config\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_choice->flags |= $2;\n                                   $$ = $1;\n                                 }\n|  choice_opt_stmt mandatory_stmt { if ($1.node.ptr_choice->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"mandatory\", \"choice\");\n                                      YYABORT;\n                                    }\n                                    $1.node.ptr_choice->flags |= $2;\n                                    $$ = $1;\n                                  }\n  |  choice_opt_stmt status_stmt { if ($1.node.ptr_choice->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"status\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_choice->flags |= $2;\n                                   $$ = $1;\n                                 }\n  |  choice_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        $$ = $1;\n                                      }\n  |  choice_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      $$ = $1;\n                                    }\n  |  choice_opt_stmt short_case_case_stmt stmtsep\n\nshort_case_case_stmt:  short_case_stmt\n  |  case_stmt\n\nshort_case_stmt: container_stmt\n  |  leaf_stmt\n  |  leaf_list_stmt\n  |  list_stmt\n  |  anyxml_stmt\n  |  anydata_stmt\n  |  choice_stmt { if (trg->version < 2 ) {\n                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"choice\");\n                     YYABORT;\n                   }\n                 }\n\ncase_arg_str: identifier_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = CASE_KEYWORD;\n                                 }\n\ncase_stmt: CASE_KEYWORD sep case_arg_str case_end\n           { LOGDBG(LY_LDGYANG, \"finished parsing case statement \\\"%s\\\"\", data_node->name);\n             actual_type = $3.token;\n             actual = $3.actual;\n             data_node = $3.actual;\n           }\n\ncase_end: ';'\n  |  '{' stmtsep\n         case_opt_stmt\n      '}' { struct lys_iffeature *tmp;\n\n           if ($3.cs->iffeature_size) {\n             tmp = realloc($3.cs->iffeature, $3.cs->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.cs->iffeature = tmp;\n           }\n          }\n\ncase_opt_stmt: @EMPTYDIR@ { $$.cs = actual; }\n  |  case_opt_stmt when_stmt stmtsep\n  |  case_opt_stmt if_feature_stmt stmtsep\n  |  case_opt_stmt status_stmt { if ($1.cs->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.cs, \"status\", \"case\");\n                                   YYABORT;\n                                 }\n                                 $1.cs->flags |= $2;\n                               }\n  |  case_opt_stmt description_stmt { if (yang_read_description(trg, $1.cs, s, \"case\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  case_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.cs, s, \"case\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  case_opt_stmt data_def_stmt stmtsep\n\n\nanyxml_arg_str: identifier_arg_str { $$.token = actual_type;\n                                     $$.actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ANYXML_KEYWORD;\n                                   }\n\nanyxml_stmt: ANYXML_KEYWORD sep anyxml_arg_str anyxml_end\n             { LOGDBG(LY_LDGYANG, \"finished parsing anyxml statement \\\"%s\\\"\", data_node->name);\n               actual_type = $3.token;\n               actual = $3.actual;\n               data_node = $3.actual;\n             }\n\nanydata_arg_str: identifier_arg_str { $$.token = actual_type;\n                                      $$.actual = actual;\n                                      if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {\n                                        YYABORT;\n                                      }\n                                      data_node = actual;\n                                      s = NULL;\n                                      actual_type = ANYDATA_KEYWORD;\n                                    }\n\nanydata_stmt: ANYDATA_KEYWORD sep anydata_arg_str anyxml_end\n              { LOGDBG(LY_LDGYANG, \"finished parsing anydata statement \\\"%s\\\"\", data_node->name);\n                actual_type = $3.token;\n                actual = $3.actual;\n                data_node = $3.actual;\n              }\n\nanyxml_end: ';'\n  |  '{' stmtsep\n         anyxml_opt_stmt\n     '}' { void *tmp;\n\n           if ($3.node.ptr_anydata->iffeature_size) {\n             tmp = realloc($3.node.ptr_anydata->iffeature, $3.node.ptr_anydata->iffeature_size * sizeof *$3.node.ptr_anydata->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.node.ptr_anydata->iffeature = tmp;\n           }\n\n           if ($3.node.ptr_anydata->must_size) {\n             tmp = realloc($3.node.ptr_anydata->must, $3.node.ptr_anydata->must_size * sizeof *$3.node.ptr_anydata->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.node.ptr_anydata->must = tmp;\n           }\n         }\n\nanyxml_opt_stmt: @EMPTYDIR@ { $$.node.ptr_anydata = actual;\n                              $$.node.flag = actual_type;\n                            }\n  |  anyxml_opt_stmt when_stmt stmtsep\n  |  anyxml_opt_stmt if_feature_stmt stmtsep\n  |  anyxml_opt_stmt must_stmt stmtsep\n  |  anyxml_opt_stmt config_stmt { if ($1.node.ptr_anydata->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_anydata, \"config\",\n                                            ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_anydata->flags |= $2;\n                                 }\n  |  anyxml_opt_stmt mandatory_stmt { if ($1.node.ptr_anydata->flags & LYS_MAND_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_anydata, \"mandatory\",\n                                               ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                        YYABORT;\n                                      }\n                                      $1.node.ptr_anydata->flags |= $2;\n                                    }\n  |  anyxml_opt_stmt status_stmt { if ($1.node.ptr_anydata->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_anydata, \"status\",\n                                            ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_anydata->flags |= $2;\n                                 }\n  |  anyxml_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_anydata, s, ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  |  anyxml_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_anydata, s, ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\nuses_arg_str: identifier_ref_arg_str { $$.token = actual_type;\n                                       $$.actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {\n                                         YYABORT;\n                                       }\n                                       data_node = actual;\n                                       s = NULL;\n                                       actual_type = USES_KEYWORD;\n                                     }\n\nuses_stmt: USES_KEYWORD sep uses_arg_str uses_end\n           { LOGDBG(LY_LDGYANG, \"finished parsing uses statement \\\"%s\\\"\", data_node->name);\n             actual_type = $3.token;\n             actual = $3.actual;\n             data_node = $3.actual;\n           }\n\nuses_end: ';'\n  |  '{' stmtsep\n         uses_opt_stmt\n     '}' { void *tmp;\n\n           if ($3.uses->iffeature_size) {\n             tmp = realloc($3.uses->iffeature, $3.uses->iffeature_size * sizeof *$3.uses->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.uses->iffeature = tmp;\n           }\n\n           if ($3.uses->refine_size) {\n             tmp = realloc($3.uses->refine, $3.uses->refine_size * sizeof *$3.uses->refine);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.uses->refine = tmp;\n           }\n\n           if ($3.uses->augment_size) {\n             tmp = realloc($3.uses->augment, $3.uses->augment_size * sizeof *$3.uses->augment);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.uses->augment = tmp;\n           }\n         }\n\nuses_opt_stmt: @EMPTYDIR@ { $$.uses = actual; }\n  |  uses_opt_stmt when_stmt stmtsep\n  |  uses_opt_stmt if_feature_stmt stmtsep\n  |  uses_opt_stmt status_stmt { if ($1.uses->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.uses, \"status\", \"uses\");\n                                   YYABORT;\n                                 }\n                                 $1.uses->flags |= $2;\n                               }\n  |  uses_opt_stmt description_stmt { if (yang_read_description(trg, $1.uses, s, \"uses\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  uses_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.uses, s, \"uses\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  uses_opt_stmt refine_stmt stmtsep\n  |  uses_opt_stmt uses_augment_stmt stmtsep\n\nrefine_args_str: descendant_schema_nodeid optsep\n  | string_1\n\nrefine_arg_str: refine_args_str { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,\n                                               ((struct lys_node_uses *)actual)->refine_size, \"refines\");\n                                  ((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);\n                                  free(s);\n                                  s = NULL;\n                                  if (!((struct lys_refine *)actual)->target_name) {\n                                    YYABORT;\n                                  }\n                                  actual_type = REFINE_KEYWORD;\n                                }\n\nrefine_stmt: REFINE_KEYWORD sep refine_arg_str refine_end\n             { actual_type = $3.token;\n               actual = $3.actual;\n             }\n\nrefine_end: ';'\n  |  '{' stmtsep\n         refine_body_opt_stmts\n     '}' { void *tmp;\n\n           if ($3.refine->iffeature_size) {\n             tmp = realloc($3.refine->iffeature, $3.refine->iffeature_size * sizeof *$3.refine->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.refine->iffeature = tmp;\n           }\n\n           if ($3.refine->must_size) {\n             tmp = realloc($3.refine->must, $3.refine->must_size * sizeof *$3.refine->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.refine->must = tmp;\n           }\n\n           if ($3.refine->dflt_size) {\n             tmp = realloc($3.refine->dflt, $3.refine->dflt_size * sizeof *$3.refine->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.refine->dflt = tmp;\n           }\n         }\n\nrefine_body_opt_stmts: @EMPTYDIR@ { $$.refine = actual;\n                                    actual_type = REFINE_KEYWORD;\n                                  }\n  |  refine_body_opt_stmts must_stmt stmtsep { actual = $1.refine;\n                                               actual_type = REFINE_KEYWORD;\n                                               if ($1.refine->target_type) {\n                                                 if ($1.refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {\n                                                   $1.refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"must\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 $1.refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;\n                                               }\n                                             }\n  |  refine_body_opt_stmts if_feature_stmt\n     stmtsep { /* leaf, leaf-list, list, container or anyxml */\n               /* check possibility of statements combination */\n               if ($1.refine->target_type) {\n                 if ($1.refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {\n                   $1.refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);\n                 } else {\n                   free(s);\n                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"refine\");\n                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                   YYABORT;\n                 }\n               } else {\n                 $1.refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;\n               }\n             }\n  |  refine_body_opt_stmts presence_stmt { if ($1.refine->target_type) {\n                                             if ($1.refine->target_type & LYS_CONTAINER) {\n                                               if ($1.refine->mod.presence) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                                 free(s);\n                                                 YYABORT;\n                                               }\n                                               $1.refine->target_type = LYS_CONTAINER;\n                                               $1.refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                             } else {\n                                               free(s);\n                                               LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                               LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                               YYABORT;\n                                             }\n                                           } else {\n                                             $1.refine->target_type = LYS_CONTAINER;\n                                             $1.refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                           }\n                                           s = NULL;\n                                           $$ = $1;\n                                         }\n  |  refine_body_opt_stmts default_stmt { int i;\n\n                                          if ($1.refine->dflt_size) {\n                                            if (trg->version < 2) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              YYABORT;\n                                            }\n                                            if ($1.refine->target_type & LYS_LEAFLIST) {\n                                              $1.refine->target_type = LYS_LEAFLIST;\n                                            } else {\n                                              free(s);\n                                              LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                              YYABORT;\n                                            }\n                                          } else {\n                                            if ($1.refine->target_type) {\n                                              if (trg->version < 2 && ($1.refine->target_type & (LYS_LEAF | LYS_CHOICE))) {\n                                                $1.refine->target_type &= (LYS_LEAF | LYS_CHOICE);\n                                              } if (trg->version > 1 && ($1.refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {\n                                                /* YANG 1.1 */\n                                                $1.refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);\n                                              } else {\n                                                free(s);\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              if (trg->version < 2) {\n                                                $1.refine->target_type = LYS_LEAF | LYS_CHOICE;\n                                              } else {\n                                                /* YANG 1.1 */\n                                                $1.refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;\n                                              }\n                                            }\n                                          }\n                                          /* check for duplicity */\n                                          for (i = 0; i < $1.refine->dflt_size; ++i) {\n                                              if (ly_strequal($1.refine->dflt[i], s, 0)) {\n                                                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"default\");\n                                                  LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", s);\n                                                  YYABORT;\n                                              }\n                                          }\n                                          YANG_ADDELEM($1.refine->dflt, $1.refine->dflt_size, \"defaults\");\n                                          *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                          actual = $1.refine;\n                                          s = NULL;\n                                          $$ = $1;\n                                        }\n  |  refine_body_opt_stmts config_stmt { if ($1.refine->target_type) {\n                                           if ($1.refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {\n                                             $1.refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);\n                                             if ($1.refine->flags & LYS_CONFIG_MASK) {\n                                               LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                               YYABORT;\n                                             }\n                                             $1.refine->flags |= $2;\n                                           } else {\n                                             LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                             LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           $1.refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;\n                                           $1.refine->flags |= $2;\n                                         }\n                                         $$ = $1;\n                                       }\n  |  refine_body_opt_stmts mandatory_stmt { if ($1.refine->target_type) {\n                                              if ($1.refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {\n                                                $1.refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);\n                                                if ($1.refine->flags & LYS_MAND_MASK) {\n                                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                  YYABORT;\n                                                }\n                                                $1.refine->flags |= $2;\n                                              } else {\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              $1.refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;\n                                              $1.refine->flags |= $2;\n                                            }\n                                            $$ = $1;\n                                          }\n  |  refine_body_opt_stmts min_elements_stmt { if ($1.refine->target_type) {\n                                                 if ($1.refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   $1.refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ($1.refine->flags & LYS_RFN_MINSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   $1.refine->flags |= LYS_RFN_MINSET;\n                                                   $1.refine->mod.list.min = $2;\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 $1.refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 $1.refine->flags |= LYS_RFN_MINSET;\n                                                 $1.refine->mod.list.min = $2;\n                                               }\n                                               $$ = $1;\n                                             }\n  |  refine_body_opt_stmts max_elements_stmt { if ($1.refine->target_type) {\n                                                 if ($1.refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   $1.refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ($1.refine->flags & LYS_RFN_MAXSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   $1.refine->flags |= LYS_RFN_MAXSET;\n                                                   $1.refine->mod.list.max = $2;\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 $1.refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 $1.refine->flags |= LYS_RFN_MAXSET;\n                                                 $1.refine->mod.list.max = $2;\n                                               }\n                                               $$ = $1;\n                                             }\n  |  refine_body_opt_stmts description_stmt { if (yang_read_description(trg, $1.refine, s, \"refine\", NODE)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n  |  refine_body_opt_stmts reference_stmt { if (yang_read_reference(trg, $1.refine, s, \"refine\", NODE)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n\nuses_augment_arg_str: descendant_schema_nodeid optsep\n  |  string_1\n  ;\n\nuses_augment_arg: uses_augment_arg_str { void *parent;\n\n                                         $$.token = actual_type;\n                                         $$.actual = actual;\n                                         parent = actual;\n                                         YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,\n                                                      ((struct lys_node_uses *)actual)->augment_size, \"augments\");\n                                         if (yang_read_augment(trg, parent, actual, s)) {\n                                           YYABORT;\n                                         }\n                                         data_node = actual;\n                                         s = NULL;\n                                         actual_type = AUGMENT_KEYWORD;\n                                       }\n\nuses_augment_stmt: AUGMENT_KEYWORD sep uses_augment_arg\n                   '{' stmtsep\n                       augment_opt_stmt\n                   '}' { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                         actual_type = $3.token;\n                         actual = $3.actual;\n                         data_node = $3.actual;\n                       }\n\naugment_arg_str: absolute_schema_nodeids optsep\n  |  string_1\n\naugment_arg: augment_arg_str { $$.token = actual_type;\n                               $$.actual = actual;\n                               YANG_ADDELEM(trg->augment, trg->augment_size, \"augments\");\n                               if (yang_read_augment(trg, NULL, actual, s)) {\n                                 YYABORT;\n                               }\n                               data_node = actual;\n                               s = NULL;\n                               actual_type = AUGMENT_KEYWORD;\n                             }\n\naugment_stmt: AUGMENT_KEYWORD sep augment_arg\n              '{' stmtsep\n                  augment_opt_stmt\n              '}' { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                    actual_type = $3.token;\n                    actual = $3.actual;\n                    data_node = $3.actual;\n                  }\n\naugment_opt_stmt: @EMPTYDIR@ { $$.augment = actual; }\n  |  augment_opt_stmt when_stmt stmtsep\n  |  augment_opt_stmt if_feature_stmt stmtsep\n  |  augment_opt_stmt status_stmt { if ($1.augment->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.augment, \"status\", \"augment\");\n                                      YYABORT;\n                                    }\n                                    $1.augment->flags |= $2;\n                                  }\n  |  augment_opt_stmt description_stmt { if (yang_read_description(trg, $1.augment, s, \"augment\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  augment_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.augment, s, \"augment\", NODE_PRINT)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n  |  augment_opt_stmt data_def_stmt stmtsep\n  |  augment_opt_stmt action_stmt stmtsep\n  |  augment_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                    LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.augment, \"notification\");\n                                                    YYABORT;\n                                                  }\n                                                }\n  |  augment_opt_stmt case_stmt stmtsep\n\naction_arg_str: identifier_arg_str { if (param->module->version != 2) {\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"action\");\n                                       free(s);\n                                       YYABORT;\n                                     }\n                                     $$.token = actual_type;\n                                     $$.actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ACTION_KEYWORD;\n                                   }\n\naction_stmt: ACTION_KEYWORD sep action_arg_str rpc_end\n             { LOGDBG(LY_LDGYANG, \"finished parsing action statement \\\"%s\\\"\", data_node->name);\n               actual_type = $3.token;\n               actual = $3.actual;\n               data_node = $3.actual;\n             }\n\nrpc_arg_str: identifier_arg_str { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = RPC_KEYWORD;\n                                }\n\nrpc_stmt: RPC_KEYWORD sep rpc_arg_str rpc_end\n          { LOGDBG(LY_LDGYANG, \"finished parsing rpc statement \\\"%s\\\"\", data_node->name);\n            actual_type = $3.token;\n            actual = $3.actual;\n            data_node = $3.actual;\n          }\n\nrpc_end: ';'\n  |  '{' stmtsep\n         rpc_opt_stmt\n      '}' { void *tmp;\n\n            if ($3.node.ptr_rpc->iffeature_size) {\n              tmp = realloc($3.node.ptr_rpc->iffeature, $3.node.ptr_rpc->iffeature_size * sizeof *$3.node.ptr_rpc->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.node.ptr_rpc->iffeature = tmp;\n            }\n\n            if ($3.node.ptr_rpc->tpdf_size) {\n              tmp = realloc($3.node.ptr_rpc->tpdf, $3.node.ptr_rpc->tpdf_size * sizeof *$3.node.ptr_rpc->tpdf);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.node.ptr_rpc->tpdf = tmp;\n            }\n          }\n\n\nrpc_opt_stmt: @EMPTYDIR@ { $$.node.ptr_rpc = actual;\n                           $$.node.flag = 0;\n                         }\n  |  rpc_opt_stmt if_feature_stmt stmtsep\n  |  rpc_opt_stmt status_stmt { if ($1.node.ptr_rpc->flags & LYS_STATUS_MASK) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_rpc, \"status\", \"rpc\");\n                                  YYABORT;\n                                }\n                                $1.node.ptr_rpc->flags |= $2;\n                             }\n  |  rpc_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n  |  rpc_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  rpc_opt_stmt typedef_stmt stmtsep\n  |  rpc_opt_stmt grouping_stmt stmtsep\n  |  rpc_opt_stmt input_stmt stmtsep { if ($1.node.flag & LYS_RPC_INPUT) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_rpc, \"input\", \"rpc\");\n                                         YYABORT;\n                                       }\n                                       $1.node.flag |= LYS_RPC_INPUT;\n                                       $$ = $1;\n                                     }\n  |  rpc_opt_stmt output_stmt stmtsep { if ($1.node.flag & LYS_RPC_OUTPUT) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_rpc, \"output\", \"rpc\");\n                                          YYABORT;\n                                        }\n                                        $1.node.flag |= LYS_RPC_OUTPUT;\n                                        $$ = $1;\n                                      }\n\ninput_arg: INPUT_KEYWORD optsep { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  s = strdup(\"input\");\n                                  if (!s) {\n                                    LOGMEM(trg->ctx);\n                                    YYABORT;\n                                  }\n                                  if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = INPUT_KEYWORD;\n                                }\n\ninput_stmt: input_arg\n            '{' stmtsep\n                input_output_opt_stmt\n            '}' { void *tmp;\n                  struct lys_node_inout *input = actual;\n\n                  if (input->must_size) {\n                    tmp = realloc(input->must, input->must_size * sizeof *input->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->must = tmp;\n                  }\n\n                  if (input->tpdf_size) {\n                    tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->tpdf = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing input statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $1.token;\n                  actual = $1.actual;\n                  data_node = $1.actual;\n                }\n\ninput_output_opt_stmt: @EMPTYDIR@\n  |  input_output_opt_stmt must_stmt stmtsep\n  |  input_output_opt_stmt typedef_stmt stmtsep\n  |  input_output_opt_stmt grouping_stmt stmtsep\n  |  input_output_opt_stmt data_def_stmt stmtsep\n\noutput_arg: OUTPUT_KEYWORD optsep { $$.token = actual_type;\n                                    $$.actual = actual;\n                                    s = strdup(\"output\");\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {\n                                      YYABORT;\n                                    }\n                                    data_node = actual;\n                                    s = NULL;\n                                    actual_type = OUTPUT_KEYWORD;\n                                  }\n\noutput_stmt: output_arg\n             '{' stmtsep\n                 input_output_opt_stmt\n             '}' { void *tmp;\n                   struct lys_node_inout *output = actual;\n\n                   if (output->must_size) {\n                     tmp = realloc(output->must, output->must_size * sizeof *output->must);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->must = tmp;\n                   }\n\n                   if (output->tpdf_size) {\n                     tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->tpdf = tmp;\n                   }\n\n                   LOGDBG(LY_LDGYANG, \"finished parsing output statement \\\"%s\\\"\", data_node->name);\n                   actual_type = $1.token;\n                   actual = $1.actual;\n                   data_node = $1.actual;\n                 }\n\nnotification_arg_str: identifier_arg_str { $$.token = actual_type;\n                                           $$.actual = actual;\n                                           if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {\n                                             YYABORT;\n                                           }\n                                           data_node = actual;\n                                           actual_type = NOTIFICATION_KEYWORD;\n                                         }\n\nnotification_stmt: NOTIFICATION_KEYWORD sep notification_arg_str notification_end\n                   { LOGDBG(LY_LDGYANG, \"finished parsing notification statement \\\"%s\\\"\", data_node->name);\n                     actual_type = $3.token;\n                     actual = $3.actual;\n                     data_node = $3.actual;\n                   }\n\nnotification_end: ';'\n  |  '{' stmtsep\n         notification_opt_stmt\n      '}' { void *tmp;\n\n            if ($3.notif->must_size) {\n              tmp = realloc($3.notif->must, $3.notif->must_size * sizeof *$3.notif->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.notif->must = tmp;\n            }\n\n           if ($3.notif->iffeature_size) {\n             tmp = realloc($3.notif->iffeature, $3.notif->iffeature_size * sizeof *$3.notif->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.notif->iffeature = tmp;\n           }\n\n           if ($3.notif->tpdf_size) {\n             tmp = realloc($3.notif->tpdf, $3.notif->tpdf_size * sizeof *$3.notif->tpdf);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.notif->tpdf = tmp;\n           }\n          }\n\nnotification_opt_stmt: @EMPTYDIR@ { $$.notif = actual; }\n  |  notification_opt_stmt must_stmt stmtsep\n  |  notification_opt_stmt if_feature_stmt stmtsep\n  |  notification_opt_stmt status_stmt { if ($1.notif->flags & LYS_STATUS_MASK) {\n                                           LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.notif, \"status\", \"notification\");\n                                           YYABORT;\n                                         }\n                                         $1.notif->flags |= $2;\n                                       }\n  |  notification_opt_stmt description_stmt { if (yang_read_description(trg, $1.notif, s, \"notification\", NODE_PRINT)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n  |  notification_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.notif, s, \"notification\", NODE_PRINT)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n  |  notification_opt_stmt typedef_stmt stmtsep\n  |  notification_opt_stmt grouping_stmt stmtsep\n  |  notification_opt_stmt data_def_stmt stmtsep\n\ndeviation_arg: deviation_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   YANG_ADDELEM(trg->deviation, trg->deviation_size, \"deviations\");\n                                   ((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);\n                                   free(s);\n                                   if (!((struct lys_deviation *)actual)->target_name) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                   actual_type = DEVIATION_KEYWORD;\n                                 }\n\ndeviation_stmt: DEVIATION_KEYWORD sep deviation_arg\n                '{' stmtsep\n                    deviation_opt_stmt\n                '}' { void *tmp;\n\n                      if ($6->deviate_size) {\n                        tmp = realloc($6->deviate, $6->deviate_size * sizeof *$6->deviate);\n                        if (!tmp) {\n                          LOGINT(trg->ctx);\n                          YYABORT;\n                        }\n                        $6->deviate = tmp;\n                      } else {\n                        LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"deviate\", \"deviation\");\n                        YYABORT;\n                      }\n                      actual_type = $3.token;\n                      actual = $3.actual;\n                    }\n\ndeviation_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviation_opt_stmt description_stmt { if (yang_read_description(trg, $1, s, \"deviation\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           $$ = $1;\n                                         }\n  |  deviation_opt_stmt reference_stmt { if (yang_read_reference(trg, $1, s, \"deviation\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                         $$ = $1;\n                                       }\n  |  deviation_opt_stmt DEVIATE_KEYWORD sep deviate_body_stmt stmtsep\n\ndeviation_arg_str: absolute_schema_nodeids optsep\n  | string_1\n\ndeviate_body_stmt: deviate_not_supported_stmt\n  |  deviate_stmts\n\n\ndeviate_not_supported: NOT_SUPPORTED_KEYWORD { $$.token = actual_type;\n                                               $$.actual = actual;\n                                               if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {\n                                                 YYABORT;\n                                               }\n                                               actual_type = NOT_SUPPORTED_KEYWORD;\n                                             }\n\ndeviate_not_supported_stmt: deviate_not_supported optsep deviate_not_supported_end\n                            { actual_type = $1.token;\n                              actual = $1.actual;\n                            }\n\ndeviate_not_supported_end: ';'\n  | '{' stmtsep '}'\n\ndeviate_stmts: deviate_add_stmt\n  |  deviate_replace_stmt\n  |  deviate_delete_stmt\n\ndeviate_add: ADD_KEYWORD { $$.token = actual_type;\n                           $$.actual = actual;\n                           if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {\n                             YYABORT;\n                           }\n                           actual_type = ADD_KEYWORD;\n                         }\n\ndeviate_add_stmt: deviate_add optsep deviate_add_end\n                  { actual_type = $1.token;\n                    actual = $1.actual;\n                  }\n\ndeviate_add_end: ';'\n  |  '{' stmtsep\n         deviate_add_opt_stmt\n     '}' { void *tmp;\n\n           if ($3->must_size) {\n             tmp = realloc($3->must, $3->must_size * sizeof *$3->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->must = tmp;\n           }\n\n           if ($3->unique_size) {\n             tmp = realloc($3->unique, $3->unique_size * sizeof *$3->unique);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->unique = tmp;\n           }\n\n           if ($3->dflt_size) {\n             tmp = realloc($3->dflt, $3->dflt_size * sizeof *$3->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->dflt = tmp;\n           }\n         }\n\ndeviate_add_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviate_add_opt_stmt units_stmt { if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       $$ = $1;\n                                     }\n  |  deviate_add_opt_stmt must_stmt stmtsep\n  |  deviate_add_opt_stmt unique_stmt { YANG_ADDELEM($1->unique, $1->unique_size, \"uniques\");\n                                        ((struct lys_unique *)actual)->expr = (const char **)s;\n                                        s = NULL;\n                                        actual = $1;\n                                        $$= $1;\n                                      }\n  |  deviate_add_opt_stmt default_stmt { YANG_ADDELEM($1->dflt, $1->dflt_size, \"defaults\");\n                                         *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                         s = NULL;\n                                         actual = $1;\n                                         $$ = $1;\n                                       }\n  |  deviate_add_opt_stmt config_stmt { if ($1->flags & LYS_CONFIG_MASK) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                          YYABORT;\n                                        }\n                                        $1->flags = $2;\n                                        $$ = $1;\n                                      }\n  |  deviate_add_opt_stmt mandatory_stmt { if ($1->flags & LYS_MAND_MASK) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                             YYABORT;\n                                           }\n                                           $1->flags = $2;\n                                           $$ = $1;\n                                         }\n  |  deviate_add_opt_stmt min_elements_stmt { if ($1->min_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              $1->min = $2;\n                                              $1->min_set = 1;\n                                              $$ =  $1;\n                                            }\n  |  deviate_add_opt_stmt max_elements_stmt { if ($1->max_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              $1->max = $2;\n                                              $1->max_set = 1;\n                                              $$ =  $1;\n                                            }\n\ndeviate_delete: DELETE_KEYWORD { $$.token = actual_type;\n                                 $$.actual = actual;\n                                 if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {\n                                   YYABORT;\n                                 }\n                                 actual_type = DELETE_KEYWORD;\n                               }\n\ndeviate_delete_stmt: deviate_delete optsep deviate_delete_end\n                     { actual_type = $1.token;\n                       actual = $1.actual;\n                     }\n\ndeviate_delete_end: ';'\n  |  '{' stmtsep\n         deviate_delete_opt_stmt\n      '}' { void *tmp;\n\n            if ($3->must_size) {\n              tmp = realloc($3->must, $3->must_size * sizeof *$3->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3->must = tmp;\n            }\n\n            if ($3->unique_size) {\n              tmp = realloc($3->unique, $3->unique_size * sizeof *$3->unique);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3->unique = tmp;\n            }\n\n            if ($3->dflt_size) {\n              tmp = realloc($3->dflt, $3->dflt_size * sizeof *$3->dflt);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3->dflt = tmp;\n            }\n          }\n\ndeviate_delete_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviate_delete_opt_stmt units_stmt { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                          $$ = $1;\n                                        }\n  |  deviate_delete_opt_stmt must_stmt stmtsep\n  |  deviate_delete_opt_stmt unique_stmt { YANG_ADDELEM($1->unique, $1->unique_size, \"uniques\");\n                                           ((struct lys_unique *)actual)->expr = (const char **)s;\n                                           s = NULL;\n                                           actual = $1;\n                                           $$ = $1;\n                                         }\n  |  deviate_delete_opt_stmt default_stmt { YANG_ADDELEM($1->dflt, $1->dflt_size, \"defaults\");\n                                            *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                            s = NULL;\n                                            actual = $1;\n                                            $$ = $1;\n                                          }\n\ndeviate_replace: REPLACE_KEYWORD { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {\n                                     YYABORT;\n                                   }\n                                   actual_type = REPLACE_KEYWORD;\n                                 }\n\ndeviate_replace_stmt: deviate_replace optsep deviate_replace_end\n                      { actual_type = $1.token;\n                        actual = $1.actual;\n                      }\n\ndeviate_replace_end: ';'\n  |  '{' stmtsep\n         deviate_replace_opt_stmt\n     '}' { void *tmp;\n\n           if ($3->dflt_size) {\n             tmp = realloc($3->dflt, $3->dflt_size * sizeof *$3->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->dflt = tmp;\n           }\n         }\n\ndeviate_replace_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviate_replace_opt_stmt type_stmt stmtsep\n  |  deviate_replace_opt_stmt units_stmt { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           $$ = $1;\n                                         }\n  |  deviate_replace_opt_stmt default_stmt { YANG_ADDELEM($1->dflt, $1->dflt_size, \"defaults\");\n                                             *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                             s = NULL;\n                                             actual = $1;\n                                             $$ = $1;\n                                           }\n  |  deviate_replace_opt_stmt config_stmt { if ($1->flags & LYS_CONFIG_MASK) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                              YYABORT;\n                                            }\n                                            $1->flags = $2;\n                                            $$ = $1;\n                                          }\n  |  deviate_replace_opt_stmt mandatory_stmt { if ($1->flags & LYS_MAND_MASK) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                                 YYABORT;\n                                               }\n                                               $1->flags = $2;\n                                               $$ = $1;\n                                             }\n  |  deviate_replace_opt_stmt min_elements_stmt { if ($1->min_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  $1->min = $2;\n                                                  $1->min_set = 1;\n                                                  $$ =  $1;\n                                                }\n  |  deviate_replace_opt_stmt max_elements_stmt { if ($1->max_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  $1->max = $2;\n                                                  $1->max_set = 1;\n                                                  $$ =  $1;\n                                                }\n\nwhen_arg_str: string  { $$.token = actual_type;\n                        $$.actual = actual;\n                        if (!(actual = yang_read_when(trg, actual, actual_type, s))) {\n                          YYABORT;\n                        }\n                        s = NULL;\n                        actual_type = WHEN_KEYWORD;\n                      }\n\nwhen_stmt: WHEN_KEYWORD sep when_arg_str when_end\n           { actual_type = $3.token;\n             actual = $3.actual;\n           }\n\nwhen_end: ';'\n  |  '{' stmtsep\n         when_opt_stmt\n     '}'\n\nwhen_opt_stmt: @EMPTYDIR@\n  |  when_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"when\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  when_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"when\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\nconfig_arg: config_arg_str { $$ = $1;\n                             backup_type = actual_type;\n                             actual_type = CONFIG_KEYWORD;\n                           }\n\nconfig_stmt: CONFIG_KEYWORD sep config_arg stmtend { $$ = $3; }\n\nconfig_arg_str: TRUE_KEYWORD optsep { $$ = LYS_CONFIG_W | LYS_CONFIG_SET; }\n  |  FALSE_KEYWORD optsep { $$ = LYS_CONFIG_R | LYS_CONFIG_SET; }\n  |  string_1 { if (!strcmp(s, \"true\")) {\n                  $$ = LYS_CONFIG_W | LYS_CONFIG_SET;\n                } else if (!strcmp(s, \"false\")) {\n                  $$ = LYS_CONFIG_R | LYS_CONFIG_SET;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"config\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\nmandatory_arg: mandatory_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = MANDATORY_KEYWORD;\n                                 }\n\nmandatory_stmt: MANDATORY_KEYWORD sep mandatory_arg stmtend { $$ = $3; }\n\nmandatory_arg_str: TRUE_KEYWORD optsep { $$ = LYS_MAND_TRUE; }\n  |  FALSE_KEYWORD optsep { $$ = LYS_MAND_FALSE; }\n  |  string_1 { if (!strcmp(s, \"true\")) {\n                  $$ = LYS_MAND_TRUE;\n                } else if (!strcmp(s, \"false\")) {\n                  $$ = LYS_MAND_FALSE;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"mandatory\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\npresence_arg: string { backup_type = actual_type;\n                       actual_type = PRESENCE_KEYWORD;\n                     }\n\npresence_stmt: PRESENCE_KEYWORD sep presence_arg stmtend\n\nmin_value_arg: min_value_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = MIN_ELEMENTS_KEYWORD;\n                                 }\n\nmin_elements_stmt: MIN_ELEMENTS_KEYWORD sep min_value_arg stmtend { $$ = $3; }\n\nmin_value_arg_str: non_negative_integer_value optsep { $$ = $1; }\n  |  string_1 { if (strlen(s) == 1 && s[0] == '0') {\n                  $$ = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"min-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  $$ = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\nmax_value_arg: max_value_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = MAX_ELEMENTS_KEYWORD;\n                                 }\n\nmax_elements_stmt: MAX_ELEMENTS_KEYWORD sep max_value_arg stmtend { $$ = $3; }\n\nmax_value_arg_str: UNBOUNDED_KEYWORD optsep { $$ = 0; }\n  |  positive_integer_value optsep { $$ = $1; }\n  |  string_1 { if (!strcmp(s, \"unbounded\")) {\n                  $$ = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"max-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  $$ = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\nordered_by_arg: ordered_by_arg_str { $$ = $1;\n                                     backup_type = actual_type;\n                                     actual_type = ORDERED_BY_KEYWORD;\n                                   }\n\nordered_by_stmt: ORDERED_BY_KEYWORD sep ordered_by_arg stmtend { $$ = $3; }\n\nordered_by_arg_str: USER_KEYWORD optsep { $$ = LYS_USERORDERED; }\n  |  SYSTEM_KEYWORD optsep { $$ = LYS_SYSTEMORDERED; }\n  |  string_1 { if (!strcmp(s, \"user\")) {\n                  $$ = LYS_USERORDERED;\n                } else if (!strcmp(s, \"system\")) {\n                  $$ = LYS_SYSTEMORDERED;\n                } else {\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s=NULL;\n              }\n\nmust_agr_str: string { $$.token = actual_type;\n                       $$.actual = actual;\n                       switch (actual_type) {\n                       case CONTAINER_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_container *)actual)->must,\n                                     ((struct lys_node_container *)actual)->must_size, \"musts\");\n                         break;\n                       case ANYDATA_KEYWORD:\n                       case ANYXML_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,\n                                     ((struct lys_node_anydata *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,\n                                     ((struct lys_node_leaf *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,\n                                     ((struct lys_node_leaflist *)actual)->must_size, \"musts\");\n                         break;\n                       case LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_list *)actual)->must,\n                                     ((struct lys_node_list *)actual)->must_size, \"musts\");\n                         break;\n                       case REFINE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_refine *)actual)->must,\n                                     ((struct lys_refine *)actual)->must_size, \"musts\");\n                         break;\n                       case ADD_KEYWORD:\n                       case DELETE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_deviate *)actual)->must,\n                                      ((struct lys_deviate *)actual)->must_size, \"musts\");\n                         break;\n                       case NOTIFICATION_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_notif *)actual)->must,\n                                     ((struct lys_node_notif *)actual)->must_size, \"musts\");\n                         break;\n                       case INPUT_KEYWORD:\n                       case OUTPUT_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_inout *)actual)->must,\n                                     ((struct lys_node_inout *)actual)->must_size, \"musts\");\n                         break;\n                       case EXTENSION_INSTANCE:\n                         /* must is already allocated */\n                         break;\n                       default:\n                         free(s);\n                         LOGINT(trg->ctx);\n                         YYABORT;\n                       }\n                       ((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);\n                       free(s);\n                       if (!((struct lys_restr *)actual)->expr) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       actual_type = MUST_KEYWORD;\n                     }\n\nmust_stmt: MUST_KEYWORD sep must_agr_str must_end\n           { actual_type = $3.token;\n             actual = $3.actual;\n           }\n\nmust_end: ';'\n  |  '{' stmtsep\n         message_opt_stmt\n     '}'\n\nunique_arg: unique_arg_str { backup_type = actual_type;\n                             actual_type = UNIQUE_KEYWORD;\n                           }\n\nunique_stmt: UNIQUE_KEYWORD sep unique_arg stmtend\n\nunique_arg_str: descendant_schema_nodeid optsep\n  |  string_1\n\nkey_arg: key_arg_str { backup_type = actual_type;\n                       actual_type = KEY_KEYWORD;\n                     }\n\nkey_stmt: KEY_KEYWORD sep key_arg stmtend;\n\nkey_arg_str: node_identifier { s = strdup(yyget_text(scanner));\n                               if (!s) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                             }\n             optsep\n  |  string_1\n  ;\n\nrange_arg_str: string { $$.token = actual_type;\n                        $$.actual = actual;\n                        if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {\n                          YYABORT;\n                        }\n                        actual_type = RANGE_KEYWORD;\n                        s = NULL;\n                      }\n\nabsolute_schema_nodeid: '/' node_identifier { if (s) {\n                                                s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                strcat(s,\"/\");\n                                                strcat(s, yyget_text(scanner));\n                                              } else {\n                                                s = malloc(yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                s[0]='/';\n                                                memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);\n                                              }\n                                            }\n\nabsolute_schema_nodeids: absolute_schema_nodeid absolute_schema_nodeid_opt;\n\nabsolute_schema_nodeid_opt: @EMPTYDIR@\n  |  absolute_schema_nodeid_opt absolute_schema_nodeid\n  ;\n\ndescendant_schema_nodeid: node_identifier { if (s) {\n                                              s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                              strcat(s, yyget_text(scanner));\n                                            } else {\n                                              s = strdup(yyget_text(scanner));\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                            }\n                                          }\n                          absolute_schema_nodeid_opt;\n\npath_arg_str: { tmp_s = yyget_text(scanner); } absolute_paths { s = strdup(tmp_s);\n                                                                if (!s) {\n                                                                  LOGMEM(trg->ctx);\n                                                                  YYABORT;\n                                                                }\n                                                                s[strlen(s) - 1] = '\\0';\n                                                             }\n  |  { tmp_s = yyget_text(scanner); } relative_path { s = strdup(tmp_s);\n                                                      if (!s) {\n                                                        LOGMEM(trg->ctx);\n                                                        YYABORT;\n                                                      }\n                                                      s[strlen(s) - 1] = '\\0';\n                                                    }\n  |  string_1\n  ;\n\nabsolute_path: '/' node_identifier path_predicate\n\nabsolute_paths: absolute_path absolute_path_opt\n\nabsolute_path_opt: @EMPTYDIR@\n  |  absolute_path_opt absolute_path;\n\nrelative_path: relative_path_part1 relative_path_part1_opt descendant_path\n\nrelative_path_part1: DOUBLEDOT '/';\n\nrelative_path_part1_opt: @EMPTYDIR@\n  |  relative_path_part1_opt relative_path_part1;\n\ndescendant_path: node_identifier descendant_path_opt\n\ndescendant_path_opt: @EMPTYDIR@\n  |  path_predicate absolute_paths;\n\npath_predicate: @EMPTYDIR@\n  | path_predicate '[' whitespace_opt path_equality_expr ']'\n\npath_equality_expr: node_identifier whitespace_opt '=' whitespace_opt path_key_expr\n\npath_key_expr: current_function_invocation whitespace_opt '/' whitespace_opt\n                     rel_path_keyexpr\n\nrel_path_keyexpr: rel_path_keyexpr_part1 rel_path_keyexpr_part1_opt\n                    node_identifier rel_path_keyexpr_part2\n\nrel_path_keyexpr_part1: DOUBLEDOT whitespace_opt '/' whitespace_opt;\n\nrel_path_keyexpr_part1_opt: @EMPTYDIR@\n  |  rel_path_keyexpr_part1_opt rel_path_keyexpr_part1;\n\nrel_path_keyexpr_part2: @EMPTYDIR@\n  | rel_path_keyexpr_part2 whitespace_opt '/' whitespace_opt node_identifier;\n\ncurrent_function_invocation: CURRENT_KEYWORD whitespace_opt '(' whitespace_opt ')'\n\npositive_integer_value: NON_NEGATIVE_INTEGER { /* convert it to uint32_t */\n                                                unsigned long val;\n\n                                                val = strtoul(yyget_text(scanner), NULL, 10);\n                                                if (val > UINT32_MAX) {\n                                                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Converted number is very long.\");\n                                                    YYABORT;\n                                                }\n                                                $$ = (uint32_t) val;\n                                             }\n\nnon_negative_integer_value: ZERO { $$ = 0; }\n  |  positive_integer_value { $$ = $1; }\n  ;\n\ninteger_value: ZERO { $$ = 0; }\n  |  integer_value_convert { /* convert it to int32_t */\n                             int64_t val;\n\n                             val = strtoll(yyget_text(scanner), NULL, 10);\n                             if (val < INT32_MIN || val > INT32_MAX) {\n                                 LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                                        \"The number is not in the correct range (INT32_MIN..INT32_MAX): \\\"%d\\\"\",val);\n                                 YYABORT;\n                             }\n                             $$ = (int32_t) val;\n                           }\n\ninteger_value_convert: INTEGER\n  |  NON_NEGATIVE_INTEGER\n\nprefix_arg_str: string_1\n  |  identifiers optsep;\n\nidentifier_arg_str: identifiers optsep\n  |  string_1 { if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                    free(s);\n                    YYABORT;\n                }\n              }\n\nnode_identifier: identifier\n  |  IDENTIFIERPREFIX\n  ;\n\nidentifier_ref_arg_str: identifiers optsep\n  | identifiers_ref optsep\n  | string_1 { char *tmp;\n\n               if ((tmp = strchr(s, ':'))) {\n                 *tmp = '\\0';\n                 /* check prefix */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 *tmp = ':';\n               } else {\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n               }\n             }\n\nstmtend: semicolom stmtsep { s = $1; }\n  | curly_bracket_open stmtsep curly_bracket_close stmtsep { s = $1; }\n\n\nsemicolom: ';' { actual_type = backup_type;\n                 backup_type = NODE;\n                 $$ = s;\n                 s = NULL;\n               }\n\ncurly_bracket_close: '}' { actual_type = backup_type;\n                           backup_type = NODE;\n                         }\n\ncurly_bracket_open: '{' { $$ = s;\n                          s = NULL;\n                        }\n\n\nstmtsep: @EMPTYDIR@\n  | stmtsep sep_stmt\n  | stmtsep unknown_statement\n  ;\n\nunknown_statement: identifiers_ref string_opt unknown_statement_end\n                   { actual_type = $2.token;\n                     actual = $2.actual;\n                   }\n\nstring_opt: string_opt_part1 string_opt_part2 { $$.token = actual_type;\n                                                $$.actual = actual;\n                                                if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, $1, s,\n                                                                             actual_type, backup_type, is_ext_instance))) {\n                                                  YYABORT;\n                                                }\n                                                s = NULL;\n                                                actual_type = EXTENSION_INSTANCE;\n                                              }\n\nstring_opt_part1: optsep { $$ = s; s = NULL; }\n\nstring_opt_part2: @EMPTYDIR@\n  |  string\n\nunknown_string: @EMPTYDIR@\n  |  sep unknown_string_part1\n\nunknown_string_part1: @EMPTYDIR@\n  |  strings optsep\n  |  STRING optsep unknown_string_part2\n\nunknown_string_part2: @EMPTYDIR@\n  |  unknown_string_part2 '+' optsep STRING optsep\n\nunknown_statement_end: ';'\n  |  '{' optsep unknown_statement2_opt '}'\n\nunknown_statement2_opt: @EMPTYDIR@\n  |  unknown_statement2_opt unknown_statement2 optsep\n\n/* unknown_statement2 read yang statement or extension; yang statement is parsed later */\n\nunknown_statement2: unknown_statement\n  |  unknown_statement2_yang_stmt unknown_string unknown_statement2_end\n     {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length = 0, old_length = 0;\n        char *tmp_value;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen($1);\n        old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;\n        tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_substmt = tmp_value;\n        tmp_value += old_length - 2;\n        memcpy(tmp_value, $1, length);\n        tmp_value[length] = ' ';\n        tmp_value[length + 1] = '\\0';\n        tmp_value[length + 2] = '\\0';\n      }\n  |  unknown_statement2_module_stmt unknown_string unknown_statement2_end\n     {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length;\n        char *tmp_value, **array;\n        int i = 0;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen($1);\n        if (!substmt->ext_modules) {\n          array = malloc(2 * sizeof *substmt->ext_modules);\n        } else {\n          for (i = 0; substmt->ext_modules[i]; ++i);\n          array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);\n        }\n        if (!array) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_modules = array;\n        array[i + 1] = NULL;\n        tmp_value = malloc(length + 2);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        array[i] = tmp_value;\n        memcpy(tmp_value, $1, length);\n        tmp_value[length] = '\\0';\n        tmp_value[length + 1] = '\\0';\n      }\n\nunknown_statement2_end: ';'\n  |  '{' optsep unknown_statement3_opt '}'\n\nunknown_statement2_yang_stmt: yang_stmt { $$ = yyget_text(scanner); }\n\nunknown_statement2_module_stmt: MODULE_KEYWORD { $$ = yyget_text(scanner); }\n\nunknown_statement3_opt: @EMPTYDIR@\n  |  unknown_statement3_opt node_identifier unknown_string unknown_statement3_opt_end;\n\nunknown_statement3_opt_end: ';' optsep\n  |  '{' optsep unknown_statement3_opt '}' optsep\n\nsep_stmt: WHITESPACE\n  | EOL\n  ;\n\noptsep: @EMPTYDIR@\n  | optsep sep_stmt\n  ;\n\nsep: sep_stmt optsep;\n\nwhitespace_opt: @EMPTYDIR@\n  | WHITESPACE\n  ;\n\nstring: strings { s = strdup(yyget_text(scanner));\n                  if (!s) {\n                    LOGMEM(trg->ctx);\n                    YYABORT;\n                  }\n                }\n        optsep\n  |  string_1\n\nstrings: STRINGS\n  |  REVISION_DATE\n  |  identifier\n  |  IDENTIFIERPREFIX\n  |  ZERO\n  |  INTEGER\n  |  NON_NEGATIVE_INTEGER\n\nidentifier: MODULE_KEYWORD\n  |  identifier1\n  |  yang_stmt\n\nidentifier1: IDENTIFIER\n  |  CURRENT_KEYWORD\n  |  DEPRECATED_KEYWORD\n  |  FALSE_KEYWORD\n  |  NOT_SUPPORTED_KEYWORD\n  |  OBSOLETE_KEYWORD\n  |  SYSTEM_KEYWORD\n  |  TRUE_KEYWORD\n  |  UNBOUNDED_KEYWORD\n  |  USER_KEYWORD\n\n\nyang_stmt: ANYXML_KEYWORD\n  |  ARGUMENT_KEYWORD\n  |  AUGMENT_KEYWORD\n  |  BASE_KEYWORD\n  |  BELONGS_TO_KEYWORD\n  |  BIT_KEYWORD\n  |  CASE_KEYWORD\n  |  CHOICE_KEYWORD\n  |  CONFIG_KEYWORD\n  |  CONTACT_KEYWORD\n  |  CONTAINER_KEYWORD\n  |  DEFAULT_KEYWORD\n  |  DESCRIPTION_KEYWORD\n  |  ENUM_KEYWORD\n  |  ERROR_APP_TAG_KEYWORD\n  |  ERROR_MESSAGE_KEYWORD\n  |  EXTENSION_KEYWORD\n  |  DEVIATION_KEYWORD\n  |  DEVIATE_KEYWORD\n  |  FEATURE_KEYWORD\n  |  FRACTION_DIGITS_KEYWORD\n  |  GROUPING_KEYWORD\n  |  IDENTITY_KEYWORD\n  |  IF_FEATURE_KEYWORD\n  |  IMPORT_KEYWORD\n  |  INCLUDE_KEYWORD\n  |  INPUT_KEYWORD\n  |  KEY_KEYWORD\n  |  LEAF_KEYWORD\n  |  LEAF_LIST_KEYWORD\n  |  LENGTH_KEYWORD\n  |  LIST_KEYWORD\n  |  MANDATORY_KEYWORD\n  |  MAX_ELEMENTS_KEYWORD\n  |  MIN_ELEMENTS_KEYWORD\n  |  MUST_KEYWORD\n  |  NAMESPACE_KEYWORD\n  |  NOTIFICATION_KEYWORD\n  |  ORDERED_BY_KEYWORD\n  |  ORGANIZATION_KEYWORD\n  |  OUTPUT_KEYWORD\n  |  PATH_KEYWORD\n  |  PATTERN_KEYWORD\n  |  POSITION_KEYWORD\n  |  PREFIX_KEYWORD\n  |  PRESENCE_KEYWORD\n  |  RANGE_KEYWORD\n  |  REFERENCE_KEYWORD\n  |  REFINE_KEYWORD\n  |  REQUIRE_INSTANCE_KEYWORD\n  |  REVISION_KEYWORD\n  |  REVISION_DATE_KEYWORD\n  |  RPC_KEYWORD\n  |  STATUS_KEYWORD\n  |  SUBMODULE_KEYWORD\n  |  TYPE_KEYWORD\n  |  TYPEDEF_KEYWORD\n  |  UNIQUE_KEYWORD\n  |  UNITS_KEYWORD\n  |  USES_KEYWORD\n  |  VALUE_KEYWORD\n  |  WHEN_KEYWORD\n  |  YANG_VERSION_KEYWORD\n  |  YIN_ELEMENT_KEYWORD\n  |  ADD_KEYWORD\n  |  DELETE_KEYWORD\n  |  REPLACE_KEYWORD\n  |  ACTION_KEYWORD\n  |  MODIFIER_KEYWORD\n  |  ANYDATA_KEYWORD\n\nidentifiers: identifier { s = strdup(yyget_text(scanner));\n                          if (!s) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                        }\n\nidentifiers_ref: IDENTIFIERPREFIX { s = strdup(yyget_text(scanner));\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                  }\n\ntype_ext_alloc: @EMPTYDIR@ { struct lys_type **type;\n\n                             type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                            \"type\", LY_STMT_TYPE);\n                             if (!type) {\n                               YYABORT;\n                             }\n                             /* allocate type structure */\n                             (*type) = calloc(1, sizeof **type);\n                             if (!*type) {\n                               LOGMEM(trg->ctx);\n                               YYABORT;\n                             }\n\n                             /* HACK for unres */\n                             (*type)->parent = (struct lys_tpdf *)ext_instance;\n                             $$ = actual = *type;\n                             is_ext_instance = 0;\n                            }\n\ntypedef_ext_alloc: @EMPTYDIR@ { struct lys_tpdf **tpdf;\n\n                                tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                               \"typedef\", LY_STMT_TYPEDEF);\n                                if (!tpdf) {\n                                  YYABORT;\n                                }\n                                /* allocate typedef structure */\n                                (*tpdf) = calloc(1, sizeof **tpdf);\n                                if (!*tpdf) {\n                                  LOGMEM(trg->ctx);\n                                  YYABORT;\n                                }\n\n                                $$ = actual = *tpdf;\n                                is_ext_instance = 0;\n                              }\n\niffeature_ext_alloc: @EMPTYDIR@ { struct lys_iffeature **iffeature;\n\n                                 iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                          \"if-feature\", LY_STMT_IFFEATURE);\n                                 if (!iffeature) {\n                                   YYABORT;\n                                 }\n                                 /* allocate typedef structure */\n                                 (*iffeature) = calloc(1, sizeof **iffeature);\n                                 if (!*iffeature) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 $$ = actual = *iffeature;\n                               }\n\nrestriction_ext_alloc: @EMPTYDIR@ { struct lys_restr **restr;\n                                    LY_STMT stmt;\n\n                                    s = yyget_text(scanner);\n                                    if (!strcmp(s, \"must\")) {\n                                      stmt = LY_STMT_MUST;\n                                    } else if (!strcmp(s, \"pattern\")) {\n                                      stmt = LY_STMT_PATTERN;\n                                    } else if (!strcmp(s, \"range\")) {\n                                      stmt = LY_STMT_RANGE;\n                                    } else {\n                                      stmt = LY_STMT_LENGTH;\n                                    }\n                                    restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);\n                                    if (!restr) {\n                                      YYABORT;\n                                    }\n                                    /* allocate structure for must */\n                                    (*restr) = calloc(1, sizeof(struct lys_restr));\n                                    if (!*restr) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    $$ = actual = *restr;\n                                    s = NULL;\n                                  }\n\nwhen_ext_alloc: @EMPTYDIR@ { actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, \"when\", LY_STMT_WHEN);\n                             if (!actual) {\n                               YYABORT;\n                             }\n                             $$ = actual;\n                           }\n\nrevision_ext_alloc: @EMPTYDIR@ { struct lys_revision **rev;\n                                 int i;\n\n                                 rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,\n                                                                                                   \"revision\", LY_STMT_REVISION);\n                                 if (!rev) {\n                                   YYABORT;\n                                 }\n                                 rev[i] = calloc(1, sizeof **rev);\n                                 if (!rev[i]) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 actual = rev[i];\n                                 $$.revision = rev;\n                                 $$.index = i;\n                               }\n\ndatadef_ext_check: @EMPTYDIR@ { LY_STMT stmt;\n\n                                s = yyget_text(scanner);\n                                if (!strcmp(s, \"action\")) {\n                                  stmt = LY_STMT_ACTION;\n                                } else if (!strcmp(s, \"anydata\")) {\n                                  stmt = LY_STMT_ANYDATA;\n                                } else if (!strcmp(s, \"anyxml\")) {\n                                  stmt = LY_STMT_ANYXML;\n                                } else if (!strcmp(s, \"case\")) {\n                                  stmt = LY_STMT_CASE;\n                                } else if (!strcmp(s, \"choice\")) {\n                                  stmt = LY_STMT_CHOICE;\n                                } else if (!strcmp(s, \"container\")) {\n                                  stmt = LY_STMT_CONTAINER;\n                                } else if (!strcmp(s, \"grouping\")) {\n                                  stmt = LY_STMT_GROUPING;\n                                } else if (!strcmp(s, \"input\")) {\n                                  stmt = LY_STMT_INPUT;\n                                } else if (!strcmp(s, \"leaf\")) {\n                                  stmt = LY_STMT_LEAF;\n                                } else if (!strcmp(s, \"leaf-list\")) {\n                                  stmt = LY_STMT_LEAFLIST;\n                                } else if (!strcmp(s, \"list\")) {\n                                  stmt = LY_STMT_LIST;\n                                } else if (!strcmp(s, \"notification\")) {\n                                  stmt = LY_STMT_NOTIFICATION;\n                                } else if (!strcmp(s, \"output\")) {\n                                  stmt = LY_STMT_OUTPUT;\n                                } else {\n                                  stmt = LY_STMT_USES;\n                                }\n                                if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {\n                                  YYABORT;\n                                }\n                                actual = NULL;\n                                s = NULL;\n                                is_ext_instance = 0;\n                              }\n\nnot_supported_ext_check: not_supported_ext { LOGERR(trg->ctx, ly_errno, \"Extension's substatement \\\"%s\\\" not supported.\", yyget_text(scanner)); }\n\nnot_supported_ext: YANG_VERSION_KEYWORD\n  |  YIN_ELEMENT_KEYWORD\n  |  BIT_KEYWORD\n  |  ENUM_KEYWORD\n  |  AUGMENT_KEYWORD\n  |  DEVIATION_KEYWORD\n  |  DEVIATE_KEYWORD\n  |  EXTENSION_KEYWORD\n  |  FEATURE_KEYWORD\n  |  IDENTITY_KEYWORD\n  |  IMPORT_KEYWORD\n  |  INCLUDE_KEYWORD\n  |  SUBMODULE_EXT_KEYWORD\n\ndatadef_ext_stmt: action_stmt\n  |  anydata_stmt\n  |  anyxml_stmt\n  |  case_stmt\n  |  choice_stmt\n  |  container_stmt\n  |  grouping_stmt\n  |  input_stmt\n  |  leaf_stmt\n  |  leaf_list_stmt\n  |  list_stmt\n  |  notification_stmt\n  |  output_stmt\n  |  uses_stmt\n\nrestriction_ext_stmt: must_stmt\n  |  pattern_stmt\n  |  range_stmt\n  |  length_stmt\n\next_substatements: @EMPTYDIR@ { actual_type = EXTENSION_INSTANCE;\n                                actual = ext_instance;\n                                if (!is_ext_instance) {\n                                  LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n                                  YYABORT;\n                                }\n                                $$ = 0;\n                              }\n  |  ext_substatements belongs_to_stmt stmtsep\n  |  ext_substatements prefix_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", ext_name, s,\n                                                                  0, LY_STMT_PREFIX)) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements description_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"description\", ext_name, s,\n                                                                       0, LY_STMT_DESCRIPTION)) {\n                                            YYABORT;\n                                          }\n                                        }\n  |  ext_substatements reference_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"reference\", ext_name, s,\n                                                                     0, LY_STMT_REFERENCE)) {\n                                          YYABORT;\n                                        }\n                                      }\n  |  ext_substatements units_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"units\", ext_name, s,\n                                                                     0, LY_STMT_UNITS)) {\n                                      YYABORT;\n                                    }\n                                  }\n  |  ext_substatements base_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"base\", ext_name, s,\n                                                                0, LY_STMT_BASE)) {\n                                     YYABORT;\n                                   }\n                                 }\n  |  ext_substatements contact_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"contact\", ext_name, s,\n                                                                     0, LY_STMT_CONTACT)) {\n                                        YYABORT;\n                                      }\n                                    }\n  |  ext_substatements default_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"default\", ext_name, s,\n                                                                     0, LY_STMT_DEFAULT)) {\n                                        YYABORT;\n                                      }\n                                    }\n  |  ext_substatements error_message_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"error-message\", ext_name, s,\n                                                                         0, LY_STMT_ERRMSG)) {\n                                              YYABORT;\n                                            }\n                                          }\n  |  ext_substatements error_app_tag_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"error-app-tag\", ext_name, s,\n                                                                         0, LY_STMT_ERRTAG)) {\n                                              YYABORT;\n                                            }\n                                          }\n  |  ext_substatements key_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"key\", ext_name, s,\n                                                               0, LY_STMT_KEY)) {\n                                    YYABORT;\n                                  }\n                                }\n  |  ext_substatements namespace_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"namespace\", ext_name, s,\n                                                                     0, LY_STMT_NAMESPACE)) {\n                                          YYABORT;\n                                        }\n                                      }\n  |  ext_substatements organization_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"organization\", ext_name, s,\n                                                                        0, LY_STMT_ORGANIZATION)) {\n                                             YYABORT;\n                                           }\n                                         }\n  |  ext_substatements path_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"path\", ext_name, s,\n                                                                0, LY_STMT_PATH)) {\n                                     YYABORT;\n                                   }\n                                 }\n  |  ext_substatements presence_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"presence\", ext_name, s,\n                                                                    0, LY_STMT_PRESENCE)) {\n                                         YYABORT;\n                                       }\n                                     }\n  |  ext_substatements revision_date_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"revision-date\", ext_name, s,\n                                                                         0, LY_STMT_REVISIONDATE)) {\n                                              YYABORT;\n                                            }\n                                          }\n  |  ext_substatements type_ext_alloc type_stmt stmtsep\n     { struct lys_type *type = $2;\n\n       if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n  |  ext_substatements typedef_ext_alloc typedef_stmt stmtsep\n     { struct lys_tpdf *tpdf = $2;\n\n       if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {\n         yang_type_free(trg->ctx, &tpdf->type);\n       }\n       if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {\n         yang_type_free(trg->ctx, &tpdf->type);\n         YYABORT;\n       }\n       /* check default value*/\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n  |  ext_substatements status_stmt { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"status\", LY_STMT_STATUS,\n                                                                    $2, LYS_STATUS_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements config_stmt { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"config\", LY_STMT_CONFIG,\n                                                                    $2, LYS_CONFIG_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements mandatory_stmt { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"mandatory\", LY_STMT_MANDATORY,\n                                                                       $2, LYS_MAND_MASK)) {\n                                          YYABORT;\n                                        }\n                                      }\n  |  ext_substatements ordered_by_stmt { if ($1 & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"ordered by\", ext_name);\n                                            YYABORT;\n                                         }\n                                         if ($2 & LYS_USERORDERED) {\n                                           if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"ordered-by\", LY_STMT_ORDEREDBY,\n                                                                          $2, LYS_USERORDERED)) {\n                                             YYABORT;\n                                           }\n                                         }\n                                         $1 |= $2;\n                                         $$ = $1;\n                                       }\n  |  ext_substatements require_instance_stmt { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"require-instance\",\n                                                                              LY_STMT_REQINSTANCE, $2)) {\n                                                 YYABORT;\n                                               }\n                                             }\n  |  ext_substatements modifier_stmt { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"modifier\", LY_STMT_MODIFIER, 0)) {\n                                         YYABORT;\n                                       }\n                                     }\n  |  ext_substatements fraction_digits_stmt\n     { /* range check */\n       if ($2 < 1 || $2 > 18) {\n         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"fraction-digits\");\n         YYABORT;\n       }\n       if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"fraction-digits\", LY_STMT_DIGITS, $2)) {\n         YYABORT;\n       }\n     }\n  |  ext_substatements min_elements_stmt { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"min-elements\", LY_STMT_MIN);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = $2;\n                                         }\n  |  ext_substatements max_elements_stmt { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"max-elements\", LY_STMT_MAX);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = $2;\n                                         }\n  |  ext_substatements position_stmt { uint32_t **val;\n\n                                       val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                              \"position\", LY_STMT_POSITION);\n                                       if (!val) {\n                                         YYABORT;\n                                       }\n                                       /* store the value */\n                                       *val = malloc(sizeof(uint32_t));\n                                       if (!*val) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       **val = $2;\n                                     }\n  |  ext_substatements value_stmt { int32_t **val;\n\n                                    val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                          \"value\", LY_STMT_VALUE);\n                                    if (!val) {\n                                      YYABORT;\n                                    }\n                                    /* store the value */\n                                    *val = malloc(sizeof(int32_t));\n                                    if (!*val) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    **val = $2;\n                                  }\n  |  ext_substatements unique_stmt { struct lys_unique **unique;\n                                     int rc;\n\n                                     unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                        \"unique\", LY_STMT_UNIQUE);\n                                     if (!unique) {\n                                       YYABORT;\n                                     }\n                                     *unique = calloc(1, sizeof(struct lys_unique));\n                                     if (!*unique) {\n                                       LOGMEM(trg->ctx);\n                                       YYABORT;\n                                     }\n                                     rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);\n                                     free(s);\n                                     s = NULL;\n                                     if (rc) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements iffeature_ext_alloc if_feature_stmt stmtsep\n     { struct lys_iffeature *iffeature;\n\n       iffeature = $2;\n       s = (char *)iffeature->features;\n       iffeature->features = NULL;\n       if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {\n         YYABORT;\n       }\n       if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {\n         YYABORT;\n       }\n       s = NULL;\n       actual = ext_instance;\n     }\n  |  ext_substatements argument_stmt stmtsep\n  |  ext_substatements restriction_ext_alloc restriction_ext_stmt stmtsep\n     { if (yang_check_ext_instance(trg, &((struct lys_restr *)$2)->ext, ((struct lys_restr *)$2)->ext_size, $2, param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n  |  ext_substatements when_ext_alloc when_stmt stmtsep\n     { if (yang_check_ext_instance(trg, &(*(struct lys_when **)$2)->ext, (*(struct lys_when **)$2)->ext_size,\n                                   *(struct lys_when **)$2, param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n  |  ext_substatements revision_ext_alloc revision_stmt stmtsep\n     { int i;\n\n       for (i = 0; i < $2.index; ++i) {\n         if (!strcmp($2.revision[i]->date, $2.revision[$2.index]->date)) {\n           LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\", $2.revision[i]->date);\n           break;\n         }\n       }\n       if (yang_check_ext_instance(trg, &$2.revision[$2.index]->ext, $2.revision[$2.index]->ext_size,\n                                   &$2.revision[$2.index], param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n  |  ext_substatements datadef_ext_check datadef_ext_stmt stmtsep { actual = ext_instance;\n                                                                    is_ext_instance = 1;\n                                                                  }\n  |  ext_substatements not_supported_ext_check unknown_string unknown_statement3_opt_end\n\n%%\n\nvoid\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }\n}\n"], "fixing_code": ["/**\n * @file parser_yang.c\n * @author Pavol Vican\n * @brief YANG parser for libyang\n *\n * Copyright (c) 2015 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#include <ctype.h>\n#include <assert.h>\n#include \"parser_yang.h\"\n#include \"parser_yang_lex.h\"\n#include \"parser.h\"\n#include \"xpath.h\"\n\nstatic void yang_free_import(struct ly_ctx *ctx, struct lys_import *imp, uint8_t start, uint8_t size);\nstatic int yang_check_must(struct lys_module *module, struct lys_restr *must, uint size, struct unres_schema *unres);\nstatic void yang_free_include(struct ly_ctx *ctx, struct lys_include *inc, uint8_t start, uint8_t size);\nstatic int yang_check_sub_module(struct lys_module *module, struct unres_schema *unres, struct lys_node *node);\nstatic void free_yang_common(struct lys_module *module, struct lys_node *node);\nstatic int yang_check_nodes(struct lys_module *module, struct lys_node *parent, struct lys_node *nodes,\n                            int options, struct unres_schema *unres);\nstatic int yang_fill_ext_substm_index(struct lys_ext_instance_complex *ext, LY_STMT stmt, enum yytokentype keyword);\nstatic void yang_free_nodes(struct ly_ctx *ctx, struct lys_node *node);\nvoid lys_iffeature_free(struct ly_ctx *ctx, struct lys_iffeature *iffeature, uint8_t iffeature_size, int shallow,\n                        void (*private_destructor)(const struct lys_node *node, void *priv));\n\nstatic int\nyang_check_string(struct lys_module *module, const char **target, char *what,\n                  char *where, char *value, struct lys_node *node)\n{\n    if (*target) {\n        LOGVAL(module->ctx, LYE_TOOMANY, (node) ? LY_VLOG_LYS : LY_VLOG_NONE, node, what, where);\n        free(value);\n        return 1;\n    } else {\n        *target = lydict_insert_zc(module->ctx, value);\n        return 0;\n    }\n}\n\nint\nyang_read_common(struct lys_module *module, char *value, enum yytokentype type)\n{\n    int ret = 0;\n\n    switch (type) {\n    case MODULE_KEYWORD:\n        module->name = lydict_insert_zc(module->ctx, value);\n        break;\n    case NAMESPACE_KEYWORD:\n        ret = yang_check_string(module, &module->ns, \"namespace\", \"module\", value, NULL);\n        break;\n    case ORGANIZATION_KEYWORD:\n        ret = yang_check_string(module, &module->org, \"organization\", \"module\", value, NULL);\n        break;\n    case CONTACT_KEYWORD:\n        ret = yang_check_string(module, &module->contact, \"contact\", \"module\", value, NULL);\n        break;\n    default:\n        free(value);\n        LOGINT(module->ctx);\n        ret = EXIT_FAILURE;\n        break;\n    }\n\n    return ret;\n}\n\nint\nyang_check_version(struct lys_module *module, struct lys_submodule *submodule, char *value, int repeat)\n{\n    int ret = EXIT_SUCCESS;\n\n    if (repeat) {\n        LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"yang version\", \"module\");\n        ret = EXIT_FAILURE;\n    } else {\n        if (!strcmp(value, \"1\")) {\n            if (submodule) {\n                if (module->version > 1) {\n                    LOGVAL(module->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                    ret = EXIT_FAILURE;\n                 }\n                submodule->version = 1;\n            } else {\n                module->version = 1;\n            }\n        } else if (!strcmp(value, \"1.1\")) {\n            if (submodule) {\n                if (module->version != 2) {\n                    LOGVAL(module->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                    ret = EXIT_FAILURE;\n                }\n                submodule->version = 2;\n            } else {\n                module->version = 2;\n            }\n        } else {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"yang-version\");\n            ret = EXIT_FAILURE;\n        }\n    }\n    free(value);\n    return ret;\n}\n\nint\nyang_read_prefix(struct lys_module *module, struct lys_import *imp, char *value)\n{\n    int ret = 0;\n\n    if (!imp && lyp_check_identifier(module->ctx, value, LY_IDENT_PREFIX, module, NULL)) {\n        free(value);\n        return EXIT_FAILURE;\n    }\n\n    if (imp) {\n        ret = yang_check_string(module, &imp->prefix, \"prefix\", \"import\", value, NULL);\n    } else {\n        ret = yang_check_string(module, &module->prefix, \"prefix\", \"module\", value, NULL);\n    }\n\n    return ret;\n}\n\nstatic int\nyang_fill_import(struct lys_module *module, struct lys_import *imp_old, struct lys_import *imp_new,\n                 char *value, struct unres_schema *unres)\n{\n    const char *exp;\n    int rc;\n\n    if (!imp_old->prefix) {\n        LOGVAL(module->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"import\");\n        goto error;\n    } else {\n        if (lyp_check_identifier(module->ctx, imp_old->prefix, LY_IDENT_PREFIX, module, NULL)) {\n            goto error;\n        }\n    }\n    memcpy(imp_new, imp_old, sizeof *imp_old);\n    exp = lydict_insert_zc(module->ctx, value);\n    rc = lyp_check_import(module, exp, imp_new);\n    lydict_remove(module->ctx, exp);\n    module->imp_size++;\n    if (rc || yang_check_ext_instance(module, &imp_new->ext, imp_new->ext_size, imp_new, unres)) {\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    free(value);\n    lydict_remove(module->ctx, imp_old->dsc);\n    lydict_remove(module->ctx, imp_old->ref);\n    lydict_remove(module->ctx, imp_old->prefix);\n    lys_extension_instances_free(module->ctx, imp_old->ext, imp_old->ext_size, NULL);\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_description(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type)\n{\n    int ret;\n    char *dsc = \"description\";\n\n    switch (type) {\n    case MODULE_KEYWORD:\n        ret = yang_check_string(module, &module->dsc, dsc, \"module\", value, NULL);\n        break;\n    case REVISION_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_revision *)node)->dsc, dsc, where, value, NULL);\n        break;\n    case IMPORT_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_import *)node)->dsc, dsc, where, value, NULL);\n        break;\n    case INCLUDE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_include *)node)->dsc, dsc, where, value, NULL);\n        break;\n    case NODE_PRINT:\n        ret = yang_check_string(module, &((struct lys_node *)node)->dsc, dsc, where, value, node);\n        break;\n    default:\n        ret = yang_check_string(module, &((struct lys_node *)node)->dsc, dsc, where, value, NULL);\n        break;\n    }\n    return ret;\n}\n\nint\nyang_read_reference(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type)\n{\n    int ret;\n    char *ref = \"reference\";\n\n    switch (type) {\n    case MODULE_KEYWORD:\n        ret = yang_check_string(module, &module->ref, ref, \"module\", value, NULL);\n        break;\n    case REVISION_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_revision *)node)->ref, ref, where, value, NULL);\n        break;\n    case IMPORT_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_import *)node)->ref, ref, where, value, NULL);\n        break;\n    case INCLUDE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_include *)node)->ref, ref, where, value, NULL);\n        break;\n    case NODE_PRINT:\n        ret = yang_check_string(module, &((struct lys_node *)node)->ref, ref, where, value, node);\n        break;\n    default:\n        ret = yang_check_string(module, &((struct lys_node *)node)->ref, ref, where, value, NULL);\n        break;\n    }\n    return ret;\n}\n\nint\nyang_fill_iffeature(struct lys_module *module, struct lys_iffeature *iffeature, void *parent,\n                    char *value, struct unres_schema *unres, int parent_is_feature)\n{\n    const char *exp;\n    int ret;\n\n    if ((module->version != 2) && ((value[0] == '(') || strchr(value, ' '))) {\n        LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        free(value);\n        return EXIT_FAILURE;\n    }\n\n    if (!(exp = transform_iffeat_schema2json(module, value))) {\n        free(value);\n        return EXIT_FAILURE;\n    }\n    free(value);\n\n    ret = resolve_iffeature_compile(iffeature, exp, (struct lys_node *)parent, parent_is_feature, unres);\n    lydict_remove(module->ctx, exp);\n\n    return (ret) ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n\nint\nyang_read_base(struct lys_module *module, struct lys_ident *ident, char *value, struct unres_schema *unres)\n{\n    const char *exp;\n\n    exp = transform_schema2json(module, value);\n    free(value);\n    if (!exp) {\n        return EXIT_FAILURE;\n    }\n\n    if (unres_schema_add_str(module, unres, ident, UNRES_IDENT, exp) == -1) {\n        lydict_remove(module->ctx, exp);\n        return EXIT_FAILURE;\n    }\n\n    lydict_remove(module->ctx, exp);\n    return EXIT_SUCCESS;\n}\n\nint\nyang_read_message(struct lys_module *module,struct lys_restr *save,char *value, char *what, int message)\n{\n    int ret;\n\n    if (message == ERROR_APP_TAG_KEYWORD) {\n        ret = yang_check_string(module, &save->eapptag, \"error_app_tag\", what, value, NULL);\n    } else {\n        ret = yang_check_string(module, &save->emsg, \"error_message\", what, value, NULL);\n    }\n    return ret;\n}\n\nint\nyang_read_presence(struct lys_module *module, struct lys_node_container *cont, char *value)\n{\n    if (cont->presence) {\n        LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, cont, \"presence\", \"container\");\n        free(value);\n        return EXIT_FAILURE;\n    } else {\n        cont->presence = lydict_insert_zc(module->ctx, value);\n        return EXIT_SUCCESS;\n    }\n}\n\nvoid *\nyang_read_when(struct lys_module *module, struct lys_node *node, enum yytokentype type, char *value)\n{\n    struct lys_when *retval;\n\n    retval = calloc(1, sizeof *retval);\n    LY_CHECK_ERR_RETURN(!retval, LOGMEM(module->ctx); free(value), NULL);\n    retval->cond = transform_schema2json(module, value);\n    if (!retval->cond) {\n        goto error;\n    }\n    switch (type) {\n    case CONTAINER_KEYWORD:\n        if (((struct lys_node_container *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"container\");\n            goto error;\n        }\n        ((struct lys_node_container *)node)->when = retval;\n        break;\n    case ANYDATA_KEYWORD:\n    case ANYXML_KEYWORD:\n        if (((struct lys_node_anydata *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", (type == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n            goto error;\n        }\n        ((struct lys_node_anydata *)node)->when = retval;\n        break;\n    case CHOICE_KEYWORD:\n        if (((struct lys_node_choice *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"choice\");\n            goto error;\n        }\n        ((struct lys_node_choice *)node)->when = retval;\n        break;\n    case CASE_KEYWORD:\n        if (((struct lys_node_case *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"case\");\n            goto error;\n        }\n        ((struct lys_node_case *)node)->when = retval;\n        break;\n    case LEAF_KEYWORD:\n        if (((struct lys_node_leaf *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"leaf\");\n            goto error;\n        }\n        ((struct lys_node_leaf *)node)->when = retval;\n        break;\n    case LEAF_LIST_KEYWORD:\n        if (((struct lys_node_leaflist *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"leaflist\");\n            goto error;\n        }\n        ((struct lys_node_leaflist *)node)->when = retval;\n        break;\n    case LIST_KEYWORD:\n        if (((struct lys_node_list *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"list\");\n            goto error;\n        }\n        ((struct lys_node_list *)node)->when = retval;\n        break;\n    case USES_KEYWORD:\n        if (((struct lys_node_uses *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"uses\");\n            goto error;\n        }\n        ((struct lys_node_uses *)node)->when = retval;\n        break;\n    case AUGMENT_KEYWORD:\n        if (((struct lys_node_augment *)node)->when) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_LYS, node, \"when\", \"augment\");\n            goto error;\n        }\n        ((struct lys_node_augment *)node)->when = retval;\n        break;\n    case EXTENSION_INSTANCE:\n        *(struct lys_when **)node = retval;\n        break;\n    default:\n        goto error;\n        break;\n    }\n    free(value);\n    return retval;\n\nerror:\n    free(value);\n    lydict_remove(module->ctx, retval->cond);\n    free(retval);\n    return NULL;\n}\n\nvoid *\nyang_read_node(struct lys_module *module, struct lys_node *parent, struct lys_node **root,\n               char *value, int nodetype, int sizeof_struct)\n{\n    struct lys_node *node, **child;\n\n    node = calloc(1, sizeof_struct);\n    LY_CHECK_ERR_RETURN(!node, LOGMEM(module->ctx); free(value), NULL);\n\n    LOGDBG(LY_LDGYANG, \"parsing %s statement \\\"%s\\\"\", strnodetype(nodetype), value);\n    node->name = lydict_insert_zc(module->ctx, value);\n    node->module = module;\n    node->nodetype = nodetype;\n    node->parent = parent;\n\n    /* insert the node into the schema tree */\n    child = (parent) ? &parent->child : root;\n    if (*child) {\n        (*child)->prev->next = node;\n        (*child)->prev = node;\n    } else {\n        *child = node;\n        node->prev = node;\n    }\n    return node;\n}\n\nint\nyang_read_default(struct lys_module *module, void *node, char *value, enum yytokentype type)\n{\n    int ret;\n\n    switch (type) {\n    case LEAF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_node_leaf *) node)->dflt, \"default\", \"leaf\", value, node);\n        break;\n    case TYPEDEF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_tpdf *) node)->dflt, \"default\", \"typedef\", value, NULL);\n        break;\n    default:\n        free(value);\n        LOGINT(module->ctx);\n        ret = EXIT_FAILURE;\n        break;\n    }\n    return ret;\n}\n\nint\nyang_read_units(struct lys_module *module, void *node, char *value, enum yytokentype type)\n{\n    int ret;\n\n    switch (type) {\n    case LEAF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_node_leaf *) node)->units, \"units\", \"leaf\", value, node);\n        break;\n    case LEAF_LIST_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_node_leaflist *) node)->units, \"units\", \"leaflist\", value, node);\n        break;\n    case TYPEDEF_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_tpdf *) node)->units, \"units\", \"typedef\", value, NULL);\n        break;\n    case ADD_KEYWORD:\n    case REPLACE_KEYWORD:\n    case DELETE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_deviate *) node)->units, \"units\", \"deviate\", value, NULL);\n        break;\n    default:\n        free(value);\n        LOGINT(module->ctx);\n        ret = EXIT_FAILURE;\n        break;\n    }\n    return ret;\n}\n\nint\nyang_read_key(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres)\n{\n    char *exp, *value;\n\n    exp = value = (char *) list->keys;\n    while ((value = strpbrk(value, \" \\t\\n\"))) {\n        list->keys_size++;\n        while (isspace(*value)) {\n            value++;\n        }\n    }\n    list->keys_size++;\n\n    list->keys_str = lydict_insert_zc(module->ctx, exp);\n    list->keys = calloc(list->keys_size, sizeof *list->keys);\n    LY_CHECK_ERR_RETURN(!list->keys, LOGMEM(module->ctx), EXIT_FAILURE);\n\n    if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nint\nyang_fill_unique(struct lys_module *module, struct lys_node_list *list, struct lys_unique *unique, char *value, struct unres_schema *unres)\n{\n    int i, j;\n    char *vaux, c;\n    struct unres_list_uniq *unique_info;\n\n    /* count the number of unique leafs in the value */\n    vaux = value;\n    while ((vaux = strpbrk(vaux, \" \\t\\n\"))) {\n       unique->expr_size++;\n        while (isspace(*vaux)) {\n            vaux++;\n        }\n    }\n    unique->expr_size++;\n    unique->expr = calloc(unique->expr_size, sizeof *unique->expr);\n    LY_CHECK_ERR_GOTO(!unique->expr, LOGMEM(module->ctx), error);\n\n    for (i = 0; i < unique->expr_size; i++) {\n        vaux = strpbrk(value, \" \\t\\n\");\n        if (vaux) {\n            c = *vaux;\n            *vaux = '\\0';\n        }\n\n        /* store token into unique structure (includes converting prefix to the module name) */\n        unique->expr[i] = transform_schema2json(module, value);\n        if (!unique->expr[i]) {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_LYS, list, value, \"unique\");\n            goto error;\n        }\n        if (vaux) {\n            *vaux = c;\n        }\n\n        /* check that the expression does not repeat */\n        for (j = 0; j < i; j++) {\n            if (ly_strequal(unique->expr[j], unique->expr[i], 1)) {\n                LOGVAL(module->ctx, LYE_INARG, LY_VLOG_LYS, list, unique->expr[i], \"unique\");\n                LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_LYS, list, \"The identifier is not unique\");\n                goto error;\n            }\n        }\n        /* try to resolve leaf */\n        if (unres) {\n            unique_info = malloc(sizeof *unique_info);\n            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(module->ctx), error);\n            unique_info->list = (struct lys_node *)list;\n            unique_info->expr = unique->expr[i];\n            unique_info->trg_type = &unique->trg_type;\n            if (unres_schema_add_node(module, unres, unique_info, UNRES_LIST_UNIQ, NULL) == -1) {\n                goto error;\n            }\n        } else {\n            if (resolve_unique((struct lys_node *)list, unique->expr[i], &unique->trg_type)) {\n                goto error;\n            }\n        }\n\n        /* move to next token */\n        value = vaux;\n        while(value && isspace(*value)) {\n            value++;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_unique(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres)\n{\n    uint8_t k;\n    char *str;\n\n    for (k = 0; k < list->unique_size; k++) {\n        str = (char *)list->unique[k].expr;\n        if (yang_fill_unique(module, list, &list->unique[k], str, unres)) {\n            goto error;\n        }\n        free(str);\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    free(str);\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_leafref_path(struct lys_module *module, struct yang_type *stype, char *value)\n{\n    if (stype->base && (stype->base != LY_TYPE_LEAFREF)) {\n        LOGVAL(module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"require-instance\");\n        goto error;\n    }\n    if (stype->type->info.lref.path) {\n        LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"path\", \"type\");\n        goto error;\n    }\n    stype->type->info.lref.path = lydict_insert_zc(module->ctx, value);\n    stype->base = LY_TYPE_LEAFREF;\n    return EXIT_SUCCESS;\n\nerror:\n    free(value);\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_require_instance(struct ly_ctx *ctx, struct yang_type *stype, int req)\n{\n    if (stype->base && (stype->base != LY_TYPE_LEAFREF)) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"require-instance\");\n        return EXIT_FAILURE;\n    }\n    if (stype->type->info.lref.req) {\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"require-instance\", \"type\");\n        return EXIT_FAILURE;\n    }\n    stype->type->info.lref.req = req;\n    stype->base = LY_TYPE_LEAFREF;\n    return EXIT_SUCCESS;\n}\n\nint\nyang_check_type(struct lys_module *module, struct lys_node *parent, struct yang_type *typ, struct lys_type *type, int tpdftype, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int rc, ret = -1;\n    unsigned int i, j;\n    int8_t req;\n    const char *name, *value, *module_name = NULL;\n    LY_DATA_TYPE base = 0, base_tmp;\n    struct lys_node *siter;\n    struct lys_type *dertype;\n    struct lys_type_enum *enms_sc = NULL;\n    struct lys_type_bit *bits_sc = NULL;\n    struct lys_type_bit bit_tmp;\n    struct yang_type *yang;\n\n    value = transform_schema2json(module, typ->name);\n    if (!value) {\n        goto error;\n    }\n\n    i = parse_identifier(value);\n    if (i < 1) {\n        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, value[-i], &value[-i]);\n        lydict_remove(ctx, value);\n        goto error;\n    }\n    /* module name */\n    name = value;\n    if (value[i]) {\n        module_name = lydict_insert(ctx, value, i);\n        name += i;\n        if ((name[0] != ':') || (parse_identifier(name + 1) < 1)) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, name[0], name);\n            lydict_remove(ctx, module_name);\n            lydict_remove(ctx, value);\n            goto error;\n        }\n        ++name;\n    }\n\n    rc = resolve_superior_type(name, module_name, module, parent, &type->der);\n    if (rc == -1) {\n        LOGVAL(ctx, LYE_INMOD, LY_VLOG_NONE, NULL, module_name);\n        lydict_remove(ctx, module_name);\n        lydict_remove(ctx, value);\n        goto error;\n\n    /* the type could not be resolved or it was resolved to an unresolved typedef or leafref */\n    } else if (rc == EXIT_FAILURE) {\n        LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_NONE, NULL, \"type\", name);\n        lydict_remove(ctx, module_name);\n        lydict_remove(ctx, value);\n        ret = EXIT_FAILURE;\n        goto error;\n    }\n    lydict_remove(ctx, module_name);\n    lydict_remove(ctx, value);\n\n    if (type->value_flags & LY_VALUE_UNRESGRP) {\n        /* resolved type in grouping, decrease the grouping's nacm number to indicate that one less\n         * unresolved item left inside the grouping, LYTYPE_GRP used as a flag for types inside a grouping.  */\n        for (siter = parent; siter && (siter->nodetype != LYS_GROUPING); siter = lys_parent(siter));\n        if (siter) {\n            assert(((struct lys_node_grp *)siter)->unres_count);\n            ((struct lys_node_grp *)siter)->unres_count--;\n        } else {\n            LOGINT(ctx);\n            goto error;\n        }\n        type->value_flags &= ~LY_VALUE_UNRESGRP;\n    }\n\n    /* check status */\n    if (lyp_check_status(type->parent->flags, type->parent->module, type->parent->name,\n                         type->der->flags, type->der->module, type->der->name, parent)) {\n        goto error;\n    }\n\n    base = typ->base;\n    base_tmp = type->base;\n    type->base = type->der->type.base;\n    if (base == 0) {\n        base = type->der->type.base;\n    }\n    switch (base) {\n    case LY_TYPE_STRING:\n        if (type->base == LY_TYPE_BINARY) {\n            if (type->info.str.pat_count) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Binary type could not include pattern statement.\");\n                goto error;\n            }\n            type->info.binary.length = type->info.str.length;\n            if (type->info.binary.length && lyp_check_length_range(ctx, type->info.binary.length->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.binary.length->expr, \"length\");\n                goto error;\n            }\n        } else if (type->base == LY_TYPE_STRING) {\n            if (type->info.str.length && lyp_check_length_range(ctx, type->info.str.length->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.str.length->expr, \"length\");\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        break;\n    case LY_TYPE_DEC64:\n        if (type->base == LY_TYPE_DEC64) {\n            /* mandatory sub-statement(s) check */\n            if (!type->info.dec64.dig && !type->der->type.der) {\n                /* decimal64 type directly derived from built-in type requires fraction-digits */\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"fraction-digits\", \"type\");\n                goto error;\n            }\n            if (type->info.dec64.dig && type->der->type.der) {\n                /* type is not directly derived from buit-in type and fraction-digits statement is prohibited */\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"fraction-digits\");\n                goto error;\n            }\n\n            /* copy fraction-digits specification from parent type for easier internal use */\n            if (type->der->type.der) {\n                type->info.dec64.dig = type->der->type.info.dec64.dig;\n                type->info.dec64.div = type->der->type.info.dec64.div;\n            }\n            if (type->info.dec64.range && lyp_check_length_range(ctx, type->info.dec64.range->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.dec64.range->expr, \"range\");\n                goto error;\n            }\n        } else if (type->base >= LY_TYPE_INT8 && type->base <=LY_TYPE_UINT64) {\n            if (type->info.dec64.dig) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Numerical type could not include fraction statement.\");\n                goto error;\n            }\n            type->info.num.range = type->info.dec64.range;\n            if (type->info.num.range && lyp_check_length_range(ctx, type->info.num.range->expr, type)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, type->info.num.range->expr, \"range\");\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        break;\n    case LY_TYPE_ENUM:\n        if (type->base != LY_TYPE_ENUM) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        dertype = &type->der->type;\n\n        if (!dertype->der) {\n            if (!type->info.enums.count) {\n                /* type is derived directly from buit-in enumeartion type and enum statement is required */\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"enum\", \"type\");\n                goto error;\n            }\n        } else {\n            for (; !dertype->info.enums.count; dertype = &dertype->der->type);\n            if (module->version < 2 && type->info.enums.count) {\n                /* type is not directly derived from built-in enumeration type and enum statement is prohibited\n                 * in YANG 1.0, since YANG 1.1 enum statements can be used to restrict the base enumeration type */\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"enum\");\n                goto error;\n            }\n\n            /* restricted enumeration type - the name MUST be used in the base type */\n            enms_sc = dertype->info.enums.enm;\n            for (i = 0; i < type->info.enums.count; i++) {\n                for (j = 0; j < dertype->info.enums.count; j++) {\n                    if (ly_strequal(enms_sc[j].name, type->info.enums.enm[i].name, 1)) {\n                        break;\n                    }\n                }\n                if (j == dertype->info.enums.count) {\n                    LOGVAL(ctx, LYE_ENUM_INNAME, LY_VLOG_NONE, NULL, type->info.enums.enm[i].name);\n                    goto error;\n                }\n\n                if (type->info.enums.enm[i].flags & LYS_AUTOASSIGNED) {\n                    /* automatically assign value from base type */\n                    type->info.enums.enm[i].value = enms_sc[j].value;\n                } else {\n                    /* check that the assigned value corresponds to the original\n                     * value of the enum in the base type */\n                    if (type->info.enums.enm[i].value != enms_sc[j].value) {\n                        /* type->info.enums.enm[i].value - assigned value in restricted enum\n                         * enms_sc[j].value - value assigned to the corresponding enum (detected above) in base type */\n                        LOGVAL(ctx, LYE_ENUM_INVAL, LY_VLOG_NONE, NULL, type->info.enums.enm[i].value,\n                               type->info.enums.enm[i].name, enms_sc[j].value);\n                        goto error;\n                    }\n                }\n            }\n        }\n        break;\n    case LY_TYPE_BITS:\n        if (type->base != LY_TYPE_BITS) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        dertype = &type->der->type;\n\n        if (!dertype->der) {\n            if (!type->info.bits.count) {\n                /* type is derived directly from buit-in bits type and bit statement is required */\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"bit\", \"type\");\n                goto error;\n            }\n        } else {\n            for (; !dertype->info.enums.count; dertype = &dertype->der->type);\n            if (module->version < 2 && type->info.bits.count) {\n                /* type is not directly derived from buit-in bits type and bit statement is prohibited,\n                 * since YANG 1.1 the bit statements can be used to restrict the base bits type */\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"bit\");\n                goto error;\n            }\n\n            bits_sc = dertype->info.bits.bit;\n            for (i = 0; i < type->info.bits.count; i++) {\n                for (j = 0; j < dertype->info.bits.count; j++) {\n                    if (ly_strequal(bits_sc[j].name, type->info.bits.bit[i].name, 1)) {\n                        break;\n                    }\n                }\n                if (j == dertype->info.bits.count) {\n                    LOGVAL(ctx, LYE_BITS_INNAME, LY_VLOG_NONE, NULL, type->info.bits.bit[i].name);\n                    goto error;\n                }\n\n                /* restricted bits type */\n                if (type->info.bits.bit[i].flags & LYS_AUTOASSIGNED) {\n                    /* automatically assign position from base type */\n                    type->info.bits.bit[i].pos = bits_sc[j].pos;\n                } else {\n                    /* check that the assigned position corresponds to the original\n                     * position of the bit in the base type */\n                    if (type->info.bits.bit[i].pos != bits_sc[j].pos) {\n                        /* type->info.bits.bit[i].pos - assigned position in restricted bits\n                         * bits_sc[j].pos - position assigned to the corresponding bit (detected above) in base type */\n                        LOGVAL(ctx, LYE_BITS_INVAL, LY_VLOG_NONE, NULL, type->info.bits.bit[i].pos,\n                               type->info.bits.bit[i].name, bits_sc[j].pos);\n                        goto error;\n                    }\n                }\n            }\n        }\n\n        for (i = type->info.bits.count; i > 0; i--) {\n            j = i - 1;\n\n            /* keep them ordered by position */\n            while (j && type->info.bits.bit[j - 1].pos > type->info.bits.bit[j].pos) {\n                /* switch them */\n                memcpy(&bit_tmp, &type->info.bits.bit[j], sizeof bit_tmp);\n                memcpy(&type->info.bits.bit[j], &type->info.bits.bit[j - 1], sizeof bit_tmp);\n                memcpy(&type->info.bits.bit[j - 1], &bit_tmp, sizeof bit_tmp);\n                j--;\n            }\n        }\n        break;\n    case LY_TYPE_LEAFREF:\n        if (type->base == LY_TYPE_INST) {\n            if (type->info.lref.path) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"path\");\n                goto error;\n            }\n            if ((req = type->info.lref.req)) {\n                type->info.inst.req = req;\n            }\n        } else if (type->base == LY_TYPE_LEAFREF) {\n            /* require-instance only YANG 1.1 */\n            if (type->info.lref.req && (module->version < 2)) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"require-instance\");\n                goto error;\n            }\n            /* flag resolving for later use */\n            if (!tpdftype) {\n                for (siter = parent; siter && siter->nodetype != LYS_GROUPING; siter = lys_parent(siter));\n                if (siter) {\n                    /* just a flag - do not resolve */\n                    tpdftype = 1;\n                }\n            }\n\n            if (type->info.lref.path) {\n                if (type->der->type.der) {\n                    LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"path\");\n                    goto error;\n                }\n                value = type->info.lref.path;\n                /* store in the JSON format */\n                type->info.lref.path = transform_schema2json(module, value);\n                lydict_remove(ctx, value);\n                if (!type->info.lref.path) {\n                    goto error;\n                }\n                /* try to resolve leafref path only when this is instantiated\n                 * leaf, so it is not:\n                 * - typedef's type,\n                 * - in  grouping definition,\n                 * - just instantiated in a grouping definition,\n                 * because in those cases the nodes referenced in path might not be present\n                 * and it is not a bug.  */\n                if (!tpdftype && unres_schema_add_node(module, unres, type, UNRES_TYPE_LEAFREF, parent) == -1) {\n                    goto error;\n                }\n            } else if (!type->der->type.der) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"path\", \"type\");\n                goto error;\n            } else {\n                /* copy leafref definition into the derived type */\n                type->info.lref.path = lydict_insert(ctx, type->der->type.info.lref.path, 0);\n                /* and resolve the path at the place we are (if not in grouping/typedef) */\n                if (!tpdftype && unres_schema_add_node(module, unres, type, UNRES_TYPE_LEAFREF, parent) == -1) {\n                    goto error;\n                }\n            }\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        break;\n    case LY_TYPE_IDENT:\n        if (type->base != LY_TYPE_IDENT) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        if (type->der->type.der) {\n            if (type->info.ident.ref) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");\n                goto error;\n            }\n        } else {\n            if (!type->info.ident.ref) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"base\", \"type\");\n                goto error;\n            }\n        }\n        break;\n    case LY_TYPE_UNION:\n        if (type->base != LY_TYPE_UNION) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n            goto error;\n        }\n        if (!type->info.uni.types) {\n            if (type->der->type.der) {\n                /* this is just a derived type with no additional type specified/required */\n                assert(type->der->type.base == LY_TYPE_UNION);\n                type->info.uni.has_ptr_type = type->der->type.info.uni.has_ptr_type;\n                break;\n            }\n            LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"(union) type\");\n            goto error;\n        }\n        for (i = 0; i < type->info.uni.count; i++) {\n            dertype = &type->info.uni.types[i];\n            if (dertype->base == LY_TYPE_DER) {\n                yang = (struct yang_type *)dertype->der;\n                dertype->der = NULL;\n                dertype->parent = type->parent;\n                if (yang_check_type(module, parent, yang, dertype, tpdftype, unres)) {\n                    dertype->der = (struct lys_tpdf *)yang;\n                    ret = EXIT_FAILURE;\n                    type->base = base_tmp;\n                    base = 0;\n                    goto error;\n                } else {\n                    lydict_remove(ctx, yang->name);\n                    free(yang);\n                }\n            }\n            if (module->version < 2) {\n                if (dertype->base == LY_TYPE_EMPTY) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"empty\", typ->name);\n                    goto error;\n                } else if (dertype->base == LY_TYPE_LEAFREF) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"leafref\", typ->name);\n                    goto error;\n                }\n            }\n            if ((dertype->base == LY_TYPE_INST) || (dertype->base == LY_TYPE_LEAFREF)\n                    || ((dertype->base == LY_TYPE_UNION) && dertype->info.uni.has_ptr_type)) {\n                type->info.uni.has_ptr_type = 1;\n            }\n        }\n        break;\n\n    default:\n        if (base >= LY_TYPE_BINARY && base <= LY_TYPE_UINT64) {\n            if (type->base != base) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid restriction in type \\\"%s\\\".\", type->parent->name);\n                goto error;\n            }\n        } else {\n            LOGINT(ctx);\n            goto error;\n        }\n    }\n\n    /* if derived type has extension, which need validate data */\n    dertype = &type->der->type;\n    while (dertype->der) {\n        if (dertype->parent->flags & LYS_VALID_EXT) {\n            type->parent->flags |= LYS_VALID_EXT;\n        }\n        dertype = &dertype->der->type;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (base) {\n        type->base = base_tmp;\n    }\n    return ret;\n}\n\nvoid\nyang_free_type_union(struct ly_ctx *ctx, struct lys_type *type)\n{\n    struct lys_type *stype;\n    struct yang_type *yang;\n    unsigned int i;\n\n    for (i = 0; i < type->info.uni.count; ++i) {\n        stype = &type->info.uni.types[i];\n        if (stype->base == LY_TYPE_DER) {\n            yang = (struct yang_type *)stype->der;\n            stype->base = yang->base;\n            lydict_remove(ctx, yang->name);\n            free(yang);\n        } else if (stype->base == LY_TYPE_UNION) {\n            yang_free_type_union(ctx, stype);\n        }\n    }\n}\n\nvoid *\nyang_read_type(struct ly_ctx *ctx, void *parent, char *value, enum yytokentype type)\n{\n    struct yang_type *typ;\n    struct lys_deviate *dev;\n\n    typ = calloc(1, sizeof *typ);\n    LY_CHECK_ERR_RETURN(!typ, LOGMEM(ctx), NULL);\n\n    typ->flags = LY_YANG_STRUCTURE_FLAG;\n    switch (type) {\n    case LEAF_KEYWORD:\n        if (((struct lys_node_leaf *)parent)->type.der) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, parent, \"type\", \"leaf\");\n            goto error;\n        }\n        ((struct lys_node_leaf *)parent)->type.der = (struct lys_tpdf *)typ;\n        ((struct lys_node_leaf *)parent)->type.parent = (struct lys_tpdf *)parent;\n        typ->type = &((struct lys_node_leaf *)parent)->type;\n        break;\n    case LEAF_LIST_KEYWORD:\n        if (((struct lys_node_leaflist *)parent)->type.der) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, parent, \"type\", \"leaf-list\");\n            goto error;\n        }\n        ((struct lys_node_leaflist *)parent)->type.der = (struct lys_tpdf *)typ;\n        ((struct lys_node_leaflist *)parent)->type.parent = (struct lys_tpdf *)parent;\n        typ->type = &((struct lys_node_leaflist *)parent)->type;\n        break;\n    case UNION_KEYWORD:\n        ((struct lys_type *)parent)->der = (struct lys_tpdf *)typ;\n        typ->type = (struct lys_type *)parent;\n        break;\n    case TYPEDEF_KEYWORD:\n        if (((struct lys_tpdf *)parent)->type.der) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"type\", \"typedef\");\n            goto error;\n        }\n        ((struct lys_tpdf *)parent)->type.der = (struct lys_tpdf *)typ;\n        typ->type = &((struct lys_tpdf *)parent)->type;\n        break;\n    case REPLACE_KEYWORD:\n        /* deviation replace type*/\n        dev = (struct lys_deviate *)parent;\n        if (dev->type) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"type\", \"deviation\");\n            goto error;\n        }\n        dev->type = calloc(1, sizeof *dev->type);\n        LY_CHECK_ERR_GOTO(!dev->type, LOGMEM(ctx), error);\n        dev->type->der = (struct lys_tpdf *)typ;\n        typ->type = dev->type;\n        break;\n    case EXTENSION_INSTANCE:\n        ((struct lys_type *)parent)->der = (struct lys_tpdf *)typ;\n        typ->type = parent;\n        break;\n    default:\n        goto error;\n        break;\n    }\n    typ->name = lydict_insert_zc(ctx, value);\n    return typ;\n\nerror:\n    free(value);\n    free(typ);\n    return NULL;\n}\n\nvoid *\nyang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr *length;\n\n    if (is_ext_instance) {\n        length = (struct lys_restr *)stype;\n    } else {\n        if (stype->base == 0 || stype->base == LY_TYPE_STRING) {\n            stype->base = LY_TYPE_STRING;\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected length statement.\");\n            goto error;\n        }\n\n        if (stype->type->info.str.length) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"length\", \"type\");\n            goto error;\n        }\n        length = calloc(1, sizeof *length);\n        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);\n        stype->type->info.str.length = length;\n    }\n    length->expr = lydict_insert_zc(ctx, value);\n    return length;\n\nerror:\n    free(value);\n    return NULL;\n}\n\nint\nyang_read_pattern(struct ly_ctx *ctx, struct lys_restr *pattern, void **precomp, char *value, char modifier)\n{\n    char *buf;\n    size_t len;\n\n    if (precomp && lyp_precompile_pattern(ctx, value, (pcre**)&precomp[0], (pcre_extra**)&precomp[1])) {\n        free(value);\n        return EXIT_FAILURE;\n    }\n\n    len = strlen(value);\n    buf = malloc((len + 2) * sizeof *buf); /* modifier byte + value + terminating NULL byte */\n    LY_CHECK_ERR_RETURN(!buf, LOGMEM(ctx); free(value), EXIT_FAILURE);\n\n    buf[0] = modifier;\n    strcpy(&buf[1], value);\n    free(value);\n\n    pattern->expr = lydict_insert_zc(ctx, buf);\n    return EXIT_SUCCESS;\n}\n\nvoid *\nyang_read_range(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr * range;\n\n    if (is_ext_instance) {\n        range = (struct lys_restr *)stype;\n    } else {\n        if (stype->base != 0 && stype->base != LY_TYPE_DEC64) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected range statement.\");\n            goto error;\n        }\n        stype->base = LY_TYPE_DEC64;\n        if (stype->type->info.dec64.range) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"range\", \"type\");\n            goto error;\n        }\n        range = calloc(1, sizeof *range);\n        LY_CHECK_ERR_GOTO(!range, LOGMEM(ctx), error);\n        stype->type->info.dec64.range = range;\n    }\n    range->expr = lydict_insert_zc(ctx, value);\n    return range;\n\nerror:\n    free(value);\n    return NULL;\n}\n\nint\nyang_read_fraction(struct ly_ctx *ctx, struct yang_type *typ, uint32_t value)\n{\n    uint32_t i;\n\n    if (typ->base == 0 || typ->base == LY_TYPE_DEC64) {\n        typ->base = LY_TYPE_DEC64;\n    } else {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected fraction-digits statement.\");\n        goto error;\n    }\n    if (typ->type->info.dec64.dig) {\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"fraction-digits\", \"type\");\n        goto error;\n    }\n    /* range check */\n    if (value < 1 || value > 18) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", value, \"fraction-digits\");\n        goto error;\n    }\n    typ->type->info.dec64.dig = value;\n    typ->type->info.dec64.div = 10;\n    for (i = 1; i < value; i++) {\n        typ->type->info.dec64.div *= 10;\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, char *value)\n{\n    int i, j;\n\n    typ->base = LY_TYPE_ENUM;\n    if (!value[0]) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"enum name\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Enum name must not be empty.\");\n        free(value);\n        goto error;\n    }\n\n    enm->name = lydict_insert_zc(ctx, value);\n\n    /* the assigned name MUST NOT have any leading or trailing whitespace characters */\n    if (isspace(enm->name[0]) || isspace(enm->name[strlen(enm->name) - 1])) {\n        LOGVAL(ctx, LYE_ENUM_WS, LY_VLOG_NONE, NULL, enm->name);\n        goto error;\n    }\n\n    j = typ->type->info.enums.count - 1;\n    /* check the name uniqueness */\n    for (i = 0; i < j; i++) {\n        if (ly_strequal(typ->type->info.enums.enm[i].name, enm->name, 1)) {\n            LOGVAL(ctx, LYE_ENUM_DUPNAME, LY_VLOG_NONE, NULL, enm->name);\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, int64_t *value, int assign)\n{\n    int i, j;\n\n    if (!assign) {\n        /* assign value automatically */\n        if (*value > INT32_MAX) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"2147483648\", \"enum/value\");\n            goto error;\n        }\n        enm->value = *value;\n        enm->flags |= LYS_AUTOASSIGNED;\n        (*value)++;\n    } else if (typ->type->info.enums.enm == enm) {\n        /* change value, which is assigned automatically, if first enum has value. */\n        *value = typ->type->info.enums.enm[0].value;\n        (*value)++;\n    }\n\n    /* check that the value is unique */\n    j = typ->type->info.enums.count-1;\n    for (i = 0; i < j; i++) {\n        if (typ->type->info.enums.enm[i].value == typ->type->info.enums.enm[j].value) {\n            LOGVAL(ctx, LYE_ENUM_DUPVAL, LY_VLOG_NONE, NULL,\n                   typ->type->info.enums.enm[j].value, typ->type->info.enums.enm[j].name,\n                   typ->type->info.enums.enm[i].name);\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, char *value)\n{\n    int i, j;\n\n    typ->base = LY_TYPE_BITS;\n    bit->name = lydict_insert_zc(ctx, value);\n    if (lyp_check_identifier(ctx, bit->name, LY_IDENT_SIMPLE, NULL, NULL)) {\n        goto error;\n    }\n\n    j = typ->type->info.bits.count - 1;\n    /* check the name uniqueness */\n    for (i = 0; i < j; i++) {\n        if (ly_strequal(typ->type->info.bits.bit[i].name, bit->name, 1)) {\n            LOGVAL(ctx, LYE_BITS_DUPNAME, LY_VLOG_NONE, NULL, bit->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, int64_t *value, int assign)\n{\n    int i,j;\n\n    if (!assign) {\n        /* assign value automatically */\n        if (*value > UINT32_MAX) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"4294967295\", \"bit/position\");\n            goto error;\n        }\n        bit->pos = (uint32_t)*value;\n        bit->flags |= LYS_AUTOASSIGNED;\n        (*value)++;\n    }\n\n    j = typ->type->info.bits.count - 1;\n    /* check that the value is unique */\n    for (i = 0; i < j; i++) {\n        if (typ->type->info.bits.bit[i].pos == bit->pos) {\n            LOGVAL(ctx, LYE_BITS_DUPVAL, LY_VLOG_NONE, NULL, bit->pos, bit->name, typ->type->info.bits.bit[i].name);\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_augment(struct lys_module *module, struct lys_node *parent, struct lys_node_augment *aug, char *value)\n{\n    aug->nodetype = LYS_AUGMENT;\n    aug->target_name = transform_schema2json(module, value);\n    free(value);\n    if (!aug->target_name) {\n        return EXIT_FAILURE;\n    }\n    aug->parent = parent;\n    aug->module = module;\n    return EXIT_SUCCESS;\n}\n\nvoid *\nyang_read_deviate_unsupported(struct ly_ctx *ctx, struct lys_deviation *dev)\n{\n    if (dev->deviate_size) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"not-supported\\\" deviation cannot be combined with any other deviation.\");\n        return NULL;\n    }\n    dev->deviate = calloc(1, sizeof *dev->deviate);\n    LY_CHECK_ERR_RETURN(!dev->deviate, LOGMEM(ctx), NULL);\n    dev->deviate[dev->deviate_size].mod = LY_DEVIATE_NO;\n    dev->deviate_size = 1;\n    return dev->deviate;\n}\n\nvoid *\nyang_read_deviate(struct ly_ctx *ctx, struct lys_deviation *dev, LYS_DEVIATE_TYPE mod)\n{\n    struct lys_deviate *deviate;\n\n    if (dev->deviate_size && dev->deviate[0].mod == LY_DEVIATE_NO) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"not-supported\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"not-supported\\\" deviation cannot be combined with any other deviation.\");\n        return NULL;\n    }\n    if (!(dev->deviate_size % LY_YANG_ARRAY_SIZE)) {\n        deviate = realloc(dev->deviate, (LY_YANG_ARRAY_SIZE + dev->deviate_size) * sizeof *deviate);\n        LY_CHECK_ERR_RETURN(!deviate, LOGMEM(ctx), NULL);\n        memset(deviate + dev->deviate_size, 0, LY_YANG_ARRAY_SIZE * sizeof *deviate);\n        dev->deviate = deviate;\n    }\n    dev->deviate[dev->deviate_size].mod = mod;\n    return &dev->deviate[dev->deviate_size++];\n}\n\nint\nyang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n\n    /* check target node type */\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        /* check values */\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        /* remove current units value of the target */\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        /* remove its extensions */\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            /* check that there is no current value */\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { /* replace */\n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        /* remove current units value of the target ... */\n        lydict_remove(ctx, *stritem);\n\n        /* ... and replace it with the value specified in deviation */\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_deviate_unique(struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct ly_ctx *ctx = dev_target->module->ctx;\n    struct lys_node_list *list;\n    struct lys_unique *unique;\n\n    /* check target node type */\n    if (dev_target->nodetype != LYS_LIST) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"unique\\\" property.\");\n        goto error;\n    }\n\n    list = (struct lys_node_list *)dev_target;\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* reallocate the unique array of the target */\n        unique = ly_realloc(list->unique, (deviate->unique_size + list->unique_size) * sizeof *unique);\n        LY_CHECK_ERR_GOTO(!unique, LOGMEM(ctx), error);\n        list->unique = unique;\n        memset(unique + list->unique_size, 0, deviate->unique_size * sizeof *unique);\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_fill_deviate_default(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target,\n                          struct ly_set *dflt_check, const char *value)\n{\n    struct lys_node *node;\n    struct lys_node_choice *choice;\n    struct lys_node_leaf *leaf;\n    struct lys_node_leaflist *llist;\n    int rc, i, j;\n    unsigned int u;\n\n    u = strlen(value);\n    if (dev_target->nodetype == LYS_CHOICE) {\n        choice = (struct lys_node_choice *)dev_target;\n        rc = resolve_choice_default_schema_nodeid(value, choice->child, (const struct lys_node **)&node);\n        if (rc || !node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n            goto error;\n        }\n        if (deviate->mod == LY_DEVIATE_DEL) {\n            if (!choice->dflt || (choice->dflt != node)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n                goto error;\n            }\n            choice->dflt = NULL;\n            /* remove extensions of this default instance from the target node */\n            j = -1;\n            while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_DEFAULT)) != -1) {\n                lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n                --j;\n            }\n        } else { /* add or replace */\n            choice->dflt = node;\n            if (!choice->dflt) {\n                /* default branch not found */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                goto error;\n            }\n        }\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        leaf = (struct lys_node_leaf *)dev_target;\n        if (deviate->mod == LY_DEVIATE_DEL) {\n            if (!leaf->dflt || !ly_strequal(leaf->dflt, value, 1)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n                goto error;\n            }\n            /* remove value */\n            lydict_remove(ctx, leaf->dflt);\n            leaf->dflt = NULL;\n            leaf->flags &= ~LYS_DFLTJSON;\n            /* remove extensions of this default instance from the target node */\n            j = -1;\n            while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_DEFAULT)) != -1) {\n                lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n                --j;\n            }\n        } else { /* add (already checked) and replace */\n            /* remove value */\n            lydict_remove(ctx, leaf->dflt);\n            leaf->flags &= ~LYS_DFLTJSON;\n\n            /* set new value */\n            leaf->dflt = lydict_insert(ctx, value, u);\n\n            /* remember to check it later (it may not fit now, but the type can be deviated too) */\n            ly_set_add(dflt_check, dev_target, 0);\n        }\n    } else { /* LYS_LEAFLIST */\n        llist = (struct lys_node_leaflist *)dev_target;\n        if (deviate->mod == LY_DEVIATE_DEL) {\n            /* find and remove the value in target list */\n            for (i = 0; i < llist->dflt_size; i++) {\n                if (llist->dflt[i] && ly_strequal(llist->dflt[i], value, 1)) {\n                    /* match, remove the value */\n                    lydict_remove(llist->module->ctx, llist->dflt[i]);\n                    llist->dflt[i] = NULL;\n                    /* remove extensions of this default instance from the target node */\n                    j = -1;\n                    while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_DEFAULT)) != -1) {\n                        if (dev_target->ext[j]->insubstmt_index == i) {\n                            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n                            --j;\n                        } else if (dev_target->ext[j]->insubstmt_index > i) {\n                            /* decrease the substatement index of the extension because of the changed array of defaults */\n                            dev_target->ext[j]->insubstmt_index--;\n                        }\n                    }\n                    break;\n                }\n            }\n            if (i == llist->dflt_size) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The default value to delete not found in the target node.\");\n                goto error;\n            }\n        } else {\n            /* add or replace, anyway we place items into the deviate's list\n               which propagates to the target */\n            /* we just want to check that the value isn't already in the list */\n            for (i = 0; i < llist->dflt_size; i++) {\n                if (ly_strequal(llist->dflt[i], value, 1)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", value);\n                    goto error;\n                }\n            }\n            /* store it in target node */\n            llist->dflt[llist->dflt_size++] = lydict_insert(ctx, value, u);\n\n            /* remember to check it later (it may not fit now, but the type can be deviated too) */\n            ly_set_add(dflt_check, dev_target, 0);\n            llist->flags &= ~LYS_DFLTJSON;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_deviate_default(struct lys_module *module, struct lys_deviate *deviate,\n                          struct lys_node *dev_target, struct ly_set * dflt_check)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i;\n    struct lys_node_leaflist *llist;\n    const char **dflt;\n\n    /* check target node type */\n    if (module->version < 2 && dev_target->nodetype == LYS_LEAFLIST) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"default\\\" property.\");\n        goto error;\n    } else if (deviate->dflt_size > 1 && dev_target->nodetype != LYS_LEAFLIST) { /* from YANG 1.1 */\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow multiple \\\"default\\\" properties.\");\n        goto error;\n    } else if (!(dev_target->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"default\\\" property.\");\n        goto error;\n    }\n\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* check that there is no current value */\n        if ((dev_target->nodetype == LYS_LEAF && ((struct lys_node_leaf *)dev_target)->dflt) ||\n                (dev_target->nodetype == LYS_CHOICE && ((struct lys_node_choice *)dev_target)->dflt)) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n            goto error;\n        }\n\n        /* check collision with mandatory/min-elements */\n        if ((dev_target->flags & LYS_MAND_TRUE) ||\n                (dev_target->nodetype == LYS_LEAFLIST && ((struct lys_node_leaflist *)dev_target)->min)) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"deviation\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                   \"Adding the \\\"default\\\" statement is forbidden on %s statement.\",\n                   (dev_target->flags & LYS_MAND_TRUE) ? \"nodes with the \\\"mandatory\\\"\" : \"leaflists with non-zero \\\"min-elements\\\"\");\n            goto error;\n        }\n    } else if (deviate->mod == LY_DEVIATE_RPL) {\n        /* check that there was a value before */\n        if (((dev_target->nodetype & (LYS_LEAF | LYS_LEAFLIST)) && !((struct lys_node_leaf *)dev_target)->dflt) ||\n                (dev_target->nodetype == LYS_CHOICE && !((struct lys_node_choice *)dev_target)->dflt)) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"default\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n            goto error;\n        }\n    }\n\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        /* reallocate default list in the target */\n        llist = (struct lys_node_leaflist *)dev_target;\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            /* reallocate (enlarge) the unique array of the target */\n            dflt = realloc(llist->dflt, (deviate->dflt_size + llist->dflt_size) * sizeof *dflt);\n            LY_CHECK_ERR_GOTO(!dflt, LOGMEM(ctx), error);\n            llist->dflt = dflt;\n        } else if (deviate->mod == LY_DEVIATE_RPL) {\n            /* reallocate (replace) the unique array of the target */\n            for (i = 0; i < llist->dflt_size; i++) {\n                lydict_remove(ctx, llist->dflt[i]);\n            }\n            dflt = realloc(llist->dflt, deviate->dflt_size * sizeof *dflt);\n            LY_CHECK_ERR_GOTO(!dflt, LOGMEM(ctx), error);\n            llist->dflt = dflt;\n            llist->dflt_size = 0;\n        }\n    }\n\n    for (i = 0; i < deviate->dflt_size; ++i) {\n        if (yang_fill_deviate_default(ctx, deviate, dev_target, dflt_check, deviate->dflt[i])) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_deviate_mandatory(struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct ly_ctx *ctx = dev_target->module->ctx;\n    struct lys_node *parent;\n\n    /* check target node type */\n    if (!(dev_target->nodetype & (LYS_LEAF | LYS_CHOICE | LYS_ANYDATA))) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"mandatory\\\" property.\");\n        goto error;\n    }\n\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* check that there is no current value */\n        if (dev_target->flags & LYS_MAND_MASK) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n            goto error;\n        } else {\n            if (dev_target->nodetype == LYS_LEAF && ((struct lys_node_leaf *)dev_target)->dflt) {\n                /* RFC 6020, 7.6.4 - default statement must not with mandatory true */\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"leaf\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                goto error;\n            } else if (dev_target->nodetype == LYS_CHOICE && ((struct lys_node_choice *)dev_target)->dflt) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"choice\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"mandatory\\\" statement is forbidden on choices with \\\"default\\\".\");\n                goto error;\n            }\n        }\n    } else { /* replace */\n        if (!(dev_target->flags & LYS_MAND_MASK)) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n            goto error;\n        }\n    }\n\n    /* remove current mandatory value of the target ... */\n    dev_target->flags &= ~LYS_MAND_MASK;\n\n    /* ... and replace it with the value specified in deviation */\n    dev_target->flags |= deviate->flags & LYS_MAND_MASK;\n\n    /* check for mandatory node in default case, first find the closest parent choice to the changed node */\n    for (parent = dev_target->parent;\n         parent && !(parent->nodetype & (LYS_CHOICE | LYS_GROUPING | LYS_ACTION));\n         parent = parent->parent) {\n        if (parent->nodetype == LYS_CONTAINER && ((struct lys_node_container *)parent)->presence) {\n            /* stop also on presence containers */\n            break;\n        }\n    }\n    /* and if it is a choice with the default case, check it for presence of a mandatory node in it */\n    if (parent && parent->nodetype == LYS_CHOICE && ((struct lys_node_choice *)parent)->dflt) {\n        if (lyp_check_mandatory_choice(parent)) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_deviate_minmax(struct lys_deviate *deviate, struct lys_node *dev_target, uint32_t value, int type)\n{\n    struct ly_ctx *ctx = dev_target->module->ctx;\n    uint32_t *ui32val, *min, *max;\n\n    /* check target node type */\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        max = &((struct lys_node_leaflist *)dev_target)->max;\n        min = &((struct lys_node_leaflist *)dev_target)->min;\n    } else if (dev_target->nodetype == LYS_LIST) {\n        max = &((struct lys_node_list *)dev_target)->max;\n        min = &((struct lys_node_list *)dev_target)->min;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, (type) ? \"max-elements\" : \"min-elements\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"%s\\\" property.\", (type) ? \"max-elements\" : \"min-elements\");\n        goto error;\n    }\n\n    ui32val = (type) ? max : min;\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* check that there is no current value */\n        if (*ui32val) {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, (type) ? \"max-elements\" : \"min-elements\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n            goto error;\n        }\n    } else if (deviate->mod == LY_DEVIATE_RPL) {\n        /* unfortunately, there is no way to check reliably that there\n         * was a value before, it could have been the default */\n    }\n\n    /* add (already checked) and replace */\n    /* set new value specified in deviation */\n    *ui32val = value;\n\n    /* check min-elements is smaller than max-elements */\n    if (*max && *min > *max) {\n        if (type) {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"max-elements\\\".\", value);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"min-elements\\\".\", value);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n        }\n        goto error;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nint\nyang_check_deviate_must(struct lys_module *module, struct unres_schema *unres,\n                        struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, erase_must = 1;\n    struct lys_restr **trg_must, *must;\n    uint8_t *trg_must_size;\n\n    /* check target node type */\n    switch (dev_target->nodetype) {\n        case LYS_LEAF:\n            trg_must = &((struct lys_node_leaf *)dev_target)->must;\n            trg_must_size = &((struct lys_node_leaf *)dev_target)->must_size;\n            break;\n        case LYS_CONTAINER:\n            trg_must = &((struct lys_node_container *)dev_target)->must;\n            trg_must_size = &((struct lys_node_container *)dev_target)->must_size;\n            break;\n        case LYS_LEAFLIST:\n            trg_must = &((struct lys_node_leaflist *)dev_target)->must;\n            trg_must_size = &((struct lys_node_leaflist *)dev_target)->must_size;\n            break;\n        case LYS_LIST:\n            trg_must = &((struct lys_node_list *)dev_target)->must;\n            trg_must_size = &((struct lys_node_list *)dev_target)->must_size;\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            trg_must = &((struct lys_node_anydata *)dev_target)->must;\n            trg_must_size = &((struct lys_node_anydata *)dev_target)->must_size;\n            break;\n        default:\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"must\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"must\\\" property.\");\n            goto error;\n    }\n\n    /* flag will be checked again, clear it for now */\n    dev_target->flags &= ~(LYS_XPCONF_DEP | LYS_XPSTATE_DEP);\n\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        /* reallocate the must array of the target */\n        must = ly_realloc(*trg_must, (deviate->must_size + *trg_must_size) * sizeof *must);\n        LY_CHECK_ERR_GOTO(!must, LOGMEM(ctx), error);\n        *trg_must = must;\n        memcpy(&(*trg_must)[*trg_must_size], deviate->must, deviate->must_size * sizeof *must);\n        *trg_must_size = *trg_must_size + deviate->must_size;\n        erase_must = 0;\n    } else if (deviate->mod == LY_DEVIATE_DEL) {\n        /* find must to delete, we are ok with just matching conditions */\n        for (j = 0; j < deviate->must_size; ++j) {\n            for (i = 0; i < *trg_must_size; i++) {\n                if (ly_strequal(deviate->must[j].expr, (*trg_must)[i].expr, 1)) {\n                    /* we have a match, free the must structure ... */\n                    lys_restr_free(module->ctx, &((*trg_must)[i]), NULL);\n                    /* ... and maintain the array */\n                    (*trg_must_size)--;\n                    if (i != *trg_must_size) {\n                        memcpy(&(*trg_must)[i], &(*trg_must)[*trg_must_size], sizeof *must);\n                    }\n                    if (!(*trg_must_size)) {\n                        free(*trg_must);\n                        *trg_must = NULL;\n                    } else {\n                        memset(&(*trg_must)[*trg_must_size], 0, sizeof *must);\n                    }\n\n                    i = -1; /* set match flag */\n                    break;\n                }\n            }\n            if (i != -1) {\n                /* no match found */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->must[j].expr, \"must\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value does not match any must from the target.\");\n                goto error;\n            }\n        }\n    }\n\n    if (yang_check_must(module, deviate->must, deviate->must_size, unres)) {\n        goto error;\n    }\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && *trg_must_size\n            && (unres_schema_add_node(module, unres, dev_target, UNRES_XPATH, NULL) == -1)) {\n        goto error;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (deviate->mod == LY_DEVIATE_ADD && erase_must) {\n        for (i = 0; i < deviate->must_size; ++i) {\n            lys_restr_free(module->ctx, &deviate->must[i], NULL);\n        }\n        free(deviate->must);\n    }\n    return EXIT_FAILURE;\n}\n\nint\nyang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n\n    /* find unique structures to delete */\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n\n        if (j == deviate->unique[index].expr_size) {\n            /* we have a match, free the unique structure ... */\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            /* ... and maintain the array */\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n\n            k = i; /* remember index for removing extensions */\n            i = -1; /* set match flag */\n            break;\n        }\n    }\n\n    if (i != -1) {\n        /* no match found */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n\n    /* remove extensions of this unique instance from the target node */\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            /* decrease the substatement index of the extension because of the changed array of uniques */\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\nint yang_check_deviate_unique(struct lys_module *module, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    struct lys_node_list *list;\n    char *str;\n    uint i = 0;\n    struct lys_unique *last_unique = NULL;\n\n    if (yang_read_deviate_unique(deviate, dev_target)) {\n        goto error;\n    }\n    list = (struct lys_node_list *)dev_target;\n    last_unique = &list->unique[list->unique_size];\n    for (i = 0; i < deviate->unique_size; ++i) {\n        str = (char *) deviate->unique[i].expr;\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (yang_fill_unique(module, list, &list->unique[list->unique_size], str, NULL)) {\n                free(str);\n                goto error;\n            }\n            list->unique_size++;\n        } else if (deviate->mod == LY_DEVIATE_DEL) {\n            if (yang_fill_unique(module, list, &deviate->unique[i], str, NULL)) {\n                free(str);\n                goto error;\n            }\n            if (yang_deviate_delete_unique(module, deviate, list, i, str)) {\n                free(str);\n                goto error;\n            }\n        }\n        free(str);\n    }\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        free(deviate->unique);\n        deviate->unique = last_unique;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (deviate->mod == LY_DEVIATE_ADD) {\n        for (i = i + 1; i < deviate->unique_size; ++i) {\n            free(deviate->unique[i].expr);\n        }\n        free(deviate->unique);\n        deviate->unique = last_unique;\n\n    }\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_fill_include(struct lys_module *trg, char *value, struct lys_include *inc,\n                  struct unres_schema *unres)\n{\n    const char *str;\n    int rc;\n    int ret = 0;\n\n    str = lydict_insert_zc(trg->ctx, value);\n    rc = lyp_check_include(trg, str, inc, unres);\n    if (!rc) {\n        /* success, copy the filled data into the final array */\n        memcpy(&trg->inc[trg->inc_size], inc, sizeof *inc);\n        if (yang_check_ext_instance(trg, &trg->inc[trg->inc_size].ext, trg->inc[trg->inc_size].ext_size,\n                                    &trg->inc[trg->inc_size], unres)) {\n            ret = -1;\n        }\n        trg->inc_size++;\n    } else if (rc == -1) {\n        lys_extension_instances_free(trg->ctx, inc->ext, inc->ext_size, NULL);\n        ret = -1;\n    }\n\n    lydict_remove(trg->ctx, str);\n    return ret;\n}\n\nstruct lys_ext_instance *\nyang_ext_instance(void *node, enum yytokentype type, int is_ext_instance)\n{\n    struct lys_ext_instance ***ext, **tmp, *instance = NULL;\n    LYEXT_PAR parent_type;\n    uint8_t *size;\n\n    switch (type) {\n    case MODULE_KEYWORD:\n    case SUBMODULE_KEYWORD:\n        ext = &((struct lys_module *)node)->ext;\n        size = &((struct lys_module *)node)->ext_size;\n        parent_type = LYEXT_PAR_MODULE;\n        break;\n    case BELONGS_TO_KEYWORD:\n        if (is_ext_instance) {\n            ext = &((struct lys_ext_instance *)node)->ext;\n            size = &((struct lys_ext_instance *)node)->ext_size;\n            parent_type = LYEXT_PAR_EXTINST;\n        } else {\n            ext = &((struct lys_module *)node)->ext;\n            size = &((struct lys_module *)node)->ext_size;\n            parent_type = LYEXT_PAR_MODULE;\n        }\n        break;\n    case IMPORT_KEYWORD:\n        ext = &((struct lys_import *)node)->ext;\n        size = &((struct lys_import *)node)->ext_size;\n        parent_type = LYEXT_PAR_IMPORT;\n        break;\n    case INCLUDE_KEYWORD:\n        ext = &((struct lys_include *)node)->ext;\n        size = &((struct lys_include *)node)->ext_size;\n        parent_type = LYEXT_PAR_INCLUDE;\n        break;\n    case REVISION_KEYWORD:\n        ext = &((struct lys_revision *)node)->ext;\n        size = &((struct lys_revision *)node)->ext_size;\n        parent_type = LYEXT_PAR_REVISION;\n        break;\n    case GROUPING_KEYWORD:\n    case CONTAINER_KEYWORD:\n    case LEAF_KEYWORD:\n    case LEAF_LIST_KEYWORD:\n    case LIST_KEYWORD:\n    case CHOICE_KEYWORD:\n    case CASE_KEYWORD:\n    case ANYXML_KEYWORD:\n    case ANYDATA_KEYWORD:\n    case USES_KEYWORD:\n    case AUGMENT_KEYWORD:\n    case ACTION_KEYWORD:\n    case RPC_KEYWORD:\n    case INPUT_KEYWORD:\n    case OUTPUT_KEYWORD:\n    case NOTIFICATION_KEYWORD:\n        ext = &((struct lys_node *)node)->ext;\n        size = &((struct lys_node *)node)->ext_size;\n        parent_type = LYEXT_PAR_NODE;\n        break;\n    case ARGUMENT_KEYWORD:\n        if (is_ext_instance) {\n            ext = &((struct lys_ext_instance *)node)->ext;\n            size = &((struct lys_ext_instance *)node)->ext_size;\n            parent_type = LYEXT_PAR_EXTINST;\n        } else {\n            ext = &((struct lys_ext *)node)->ext;\n            size = &((struct lys_ext *)node)->ext_size;\n            parent_type = LYEXT_PAR_EXT;\n        }\n        break;\n    case EXTENSION_KEYWORD:\n        ext = &((struct lys_ext *)node)->ext;\n        size = &((struct lys_ext *)node)->ext_size;\n        parent_type = LYEXT_PAR_EXT;\n        break;\n    case FEATURE_KEYWORD:\n        ext = &((struct lys_feature *)node)->ext;\n        size = &((struct lys_feature *)node)->ext_size;\n        parent_type = LYEXT_PAR_FEATURE;\n        break;\n    case IDENTITY_KEYWORD:\n        ext = &((struct lys_ident *)node)->ext;\n        size = &((struct lys_ident *)node)->ext_size;\n        parent_type = LYEXT_PAR_IDENT;\n        break;\n    case IF_FEATURE_KEYWORD:\n        ext = &((struct lys_iffeature *)node)->ext;\n        size = &((struct lys_iffeature *)node)->ext_size;\n        parent_type = LYEXT_PAR_IFFEATURE;\n        break;\n    case TYPEDEF_KEYWORD:\n        ext = &((struct lys_tpdf *)node)->ext;\n        size = &((struct lys_tpdf *)node)->ext_size;\n        parent_type = LYEXT_PAR_TPDF;\n        break;\n    case TYPE_KEYWORD:\n        ext = &((struct yang_type *)node)->type->ext;\n        size = &((struct yang_type *)node)->type->ext_size;\n        parent_type = LYEXT_PAR_TYPE;\n        break;\n    case LENGTH_KEYWORD:\n    case PATTERN_KEYWORD:\n    case RANGE_KEYWORD:\n    case MUST_KEYWORD:\n        ext = &((struct lys_restr *)node)->ext;\n        size = &((struct lys_restr *)node)->ext_size;\n        parent_type = LYEXT_PAR_RESTR;\n        break;\n    case WHEN_KEYWORD:\n        ext = &((struct lys_when *)node)->ext;\n        size = &((struct lys_when *)node)->ext_size;\n        parent_type = LYEXT_PAR_RESTR;\n        break;\n    case ENUM_KEYWORD:\n        ext = &((struct lys_type_enum *)node)->ext;\n        size = &((struct lys_type_enum *)node)->ext_size;\n        parent_type = LYEXT_PAR_TYPE_ENUM;\n        break;\n    case BIT_KEYWORD:\n        ext = &((struct lys_type_bit *)node)->ext;\n        size = &((struct lys_type_bit *)node)->ext_size;\n        parent_type = LYEXT_PAR_TYPE_BIT;\n        break;\n    case REFINE_KEYWORD:\n        ext = &((struct lys_type_bit *)node)->ext;\n        size = &((struct lys_type_bit *)node)->ext_size;\n        parent_type = LYEXT_PAR_REFINE;\n        break;\n    case DEVIATION_KEYWORD:\n        ext = &((struct lys_deviation *)node)->ext;\n        size = &((struct lys_deviation *)node)->ext_size;\n        parent_type = LYEXT_PAR_DEVIATION;\n        break;\n    case NOT_SUPPORTED_KEYWORD:\n    case ADD_KEYWORD:\n    case DELETE_KEYWORD:\n    case REPLACE_KEYWORD:\n        ext = &((struct lys_deviate *)node)->ext;\n        size = &((struct lys_deviate *)node)->ext_size;\n        parent_type = LYEXT_PAR_DEVIATE;\n        break;\n    case EXTENSION_INSTANCE:\n        ext = &((struct lys_ext_instance *)node)->ext;\n        size = &((struct lys_ext_instance *)node)->ext_size;\n        parent_type = LYEXT_PAR_EXTINST;\n        break;\n    default:\n        LOGINT(NULL);\n        return NULL;\n    }\n\n    instance = calloc(1, sizeof *instance);\n    if (!instance) {\n        goto error;\n    }\n    instance->parent_type = parent_type;\n    tmp = realloc(*ext, (*size + 1) * sizeof *tmp);\n    if (!tmp) {\n        goto error;\n    }\n    tmp[*size] = instance;\n    *ext = tmp;\n    (*size)++;\n    return instance;\n\nerror:\n    LOGMEM(NULL);\n    free(instance);\n    return NULL;\n}\n\nvoid *\nyang_read_ext(struct lys_module *module, void *actual, char *ext_name, char *ext_arg,\n              enum yytokentype actual_type, enum yytokentype backup_type, int is_ext_instance)\n{\n    struct lys_ext_instance *instance;\n    LY_STMT stmt = LY_STMT_UNKNOWN;\n    LYEXT_SUBSTMT insubstmt;\n    uint8_t insubstmt_index = 0;\n\n    if (backup_type != NODE) {\n        switch (actual_type) {\n        case YANG_VERSION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_VERSION;\n            stmt = LY_STMT_VERSION;\n            break;\n        case NAMESPACE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_NAMESPACE;\n            stmt = LY_STMT_NAMESPACE;\n            break;\n        case PREFIX_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_PREFIX;\n            stmt = LY_STMT_PREFIX;\n            break;\n        case REVISION_DATE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_REVISIONDATE;\n            stmt = LY_STMT_REVISIONDATE;\n            break;\n        case DESCRIPTION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_DESCRIPTION;\n            stmt = LY_STMT_DESCRIPTION;\n            break;\n        case REFERENCE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_REFERENCE;\n            stmt = LY_STMT_REFERENCE;\n            break;\n        case CONTACT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_CONTACT;\n            stmt = LY_STMT_CONTACT;\n            break;\n        case ORGANIZATION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ORGANIZATION;\n            stmt = LY_STMT_ORGANIZATION;\n            break;\n        case YIN_ELEMENT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_YINELEM;\n            stmt = LY_STMT_YINELEM;\n            break;\n        case STATUS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_STATUS;\n            stmt = LY_STMT_STATUS;\n            break;\n        case BASE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_BASE;\n            stmt = LY_STMT_BASE;\n            if (backup_type == IDENTITY_KEYWORD) {\n                insubstmt_index = ((struct lys_ident *)actual)->base_size;\n            } else if (backup_type == TYPE_KEYWORD) {\n                insubstmt_index = ((struct yang_type *)actual)->type->info.ident.count;\n            }\n            break;\n        case DEFAULT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_DEFAULT;\n            stmt = LY_STMT_DEFAULT;\n            switch (backup_type) {\n            case LEAF_LIST_KEYWORD:\n                insubstmt_index = ((struct lys_node_leaflist *)actual)->dflt_size;\n                break;\n            case REFINE_KEYWORD:\n                insubstmt_index = ((struct lys_refine *)actual)->dflt_size;\n                break;\n            case ADD_KEYWORD:\n                insubstmt_index = ((struct lys_deviate *)actual)->dflt_size;\n                break;\n            default:\n                /* nothing changes */\n                break;\n            }\n            break;\n        case UNITS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_UNITS;\n            stmt = LY_STMT_UNITS;\n            break;\n        case REQUIRE_INSTANCE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_REQINSTANCE;\n            stmt = LY_STMT_REQINSTANCE;\n            break;\n        case PATH_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_PATH;\n            stmt = LY_STMT_PATH;\n            break;\n        case ERROR_MESSAGE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ERRMSG;\n            stmt = LY_STMT_ERRMSG;\n            break;\n        case ERROR_APP_TAG_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ERRTAG;\n            stmt = LY_STMT_ERRTAG;\n            break;\n        case MODIFIER_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MODIFIER;\n            stmt = LY_STMT_MODIFIER;\n            break;\n        case FRACTION_DIGITS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_DIGITS;\n            stmt = LY_STMT_DIGITS;\n            break;\n        case VALUE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_VALUE;\n            stmt = LY_STMT_VALUE;\n            break;\n        case POSITION_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_POSITION;\n            stmt = LY_STMT_POSITION;\n            break;\n        case PRESENCE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_PRESENCE;\n            stmt = LY_STMT_PRESENCE;\n            break;\n        case CONFIG_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_CONFIG;\n            stmt = LY_STMT_CONFIG;\n            break;\n        case MANDATORY_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MANDATORY;\n            stmt = LY_STMT_MANDATORY;\n            break;\n        case MIN_ELEMENTS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MIN;\n            stmt = LY_STMT_MIN;\n            break;\n        case MAX_ELEMENTS_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_MAX;\n            stmt = LY_STMT_MAX;\n            break;\n        case ORDERED_BY_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ORDEREDBY;\n            stmt = LY_STMT_ORDEREDBY;\n            break;\n        case KEY_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_KEY;\n            stmt = LY_STMT_KEY;\n            break;\n        case UNIQUE_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_UNIQUE;\n            stmt = LY_STMT_UNIQUE;\n            switch (backup_type) {\n            case LIST_KEYWORD:\n                insubstmt_index = ((struct lys_node_list *)actual)->unique_size;\n                break;\n            case ADD_KEYWORD:\n            case DELETE_KEYWORD:\n            case REPLACE_KEYWORD:\n                insubstmt_index = ((struct lys_deviate *)actual)->unique_size;\n                break;\n            default:\n                /* nothing changes */\n                break;\n            }\n            break;\n        default:\n            LOGINT(module->ctx);\n            return NULL;\n        }\n\n        instance = yang_ext_instance(actual, backup_type, is_ext_instance);\n    } else {\n        switch (actual_type) {\n        case ARGUMENT_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_ARGUMENT;\n            stmt = LY_STMT_ARGUMENT;\n            break;\n        case BELONGS_TO_KEYWORD:\n            insubstmt = LYEXT_SUBSTMT_BELONGSTO;\n            stmt = LY_STMT_BELONGSTO;\n            break;\n        default:\n            insubstmt = LYEXT_SUBSTMT_SELF;\n            break;\n        }\n\n        instance = yang_ext_instance(actual, actual_type, is_ext_instance);\n    }\n\n    if (!instance) {\n        return NULL;\n    }\n    instance->insubstmt = insubstmt;\n    instance->insubstmt_index = insubstmt_index;\n    instance->flags |= LYEXT_OPT_YANG;\n    instance->def = (struct lys_ext *)ext_name;    /* hack for UNRES */\n    instance->arg_value = lydict_insert_zc(module->ctx, ext_arg);\n    if (is_ext_instance && stmt != LY_STMT_UNKNOWN && instance->parent_type == LYEXT_PAR_EXTINST) {\n        instance->insubstmt_index = yang_fill_ext_substm_index(actual, stmt, backup_type);\n    }\n    return instance;\n}\n\nstatic int\ncheck_status_flag(struct lys_node *node, struct lys_node *parent)\n{\n    struct ly_ctx *ctx = node->module->ctx;\n    char *str;\n\n    if (node->nodetype & (LYS_OUTPUT | LYS_INPUT)) {\n        return EXIT_SUCCESS;\n    }\n\n    if (parent && (parent->flags & (LYS_STATUS_DEPRC | LYS_STATUS_OBSLT))) {\n        /* status is not inherited by specification, but it not make sense to have\n         * current in deprecated or deprecated in obsolete, so we print warning\n         * and fix the schema by inheriting */\n        if (!(node->flags & (LYS_STATUS_MASK))) {\n            /* status not explicitely specified on the current node -> inherit */\n            str = lys_path(node, LYS_PATH_FIRST_PREFIX);\n            LOGWRN(ctx, \"Missing status in %s subtree (%s), inheriting.\",\n                   parent->flags & LYS_STATUS_DEPRC ? \"deprecated\" : \"obsolete\", str);\n            free(str);\n            node->flags |= parent->flags & LYS_STATUS_MASK;\n        } else if ((parent->flags & LYS_STATUS_MASK) > (node->flags & LYS_STATUS_MASK)) {\n            /* invalid combination of statuses */\n            switch (node->flags & LYS_STATUS_MASK) {\n                case 0:\n                case LYS_STATUS_CURR:\n                    LOGVAL(ctx, LYE_INSTATUS, LY_VLOG_LYS, parent, \"current\", strnodetype(node->nodetype), \"is child of\",\n                           parent->flags & LYS_STATUS_DEPRC ? \"deprecated\" : \"obsolete\", parent->name);\n                    break;\n                case LYS_STATUS_DEPRC:\n                    LOGVAL(ctx, LYE_INSTATUS, LY_VLOG_LYS, parent, \"deprecated\", strnodetype(node->nodetype), \"is child of\",\n                           \"obsolete\", parent->name);\n                    break;\n            }\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nstore_config_flag(struct lys_node *node, int options)\n{\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n    case LYS_CHOICE:\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        if (options & LYS_PARSE_OPT_CFG_IGNORE) {\n            node->flags |= node->flags & (~(LYS_CONFIG_MASK | LYS_CONFIG_SET));\n        } else if (!(options & LYS_PARSE_OPT_CFG_NOINHERIT)) {\n            if (!(node->flags & LYS_CONFIG_MASK)) {\n                /* get config flag from parent */\n                if (node->parent) {\n                    node->flags |= node->parent->flags & LYS_CONFIG_MASK;\n                } else {\n                    /* default config is true */\n                    node->flags |= LYS_CONFIG_W;\n                }\n            }\n        }\n        break;\n    case LYS_CASE:\n        if (!(options & (LYS_PARSE_OPT_CFG_IGNORE | LYS_PARSE_OPT_CFG_NOINHERIT))) {\n            if (!(node->flags & LYS_CONFIG_MASK)) {\n                /* get config flag from parent */\n                if (node->parent) {\n                    node->flags |= node->parent->flags & LYS_CONFIG_MASK;\n                } else {\n                    /* default config is true */\n                    node->flags |= LYS_CONFIG_W;\n                }\n            }\n        }\n        break;\n    default:\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_parse_mem(struct lys_module *module, struct lys_submodule *submodule, struct unres_schema *unres,\n               const char *data, unsigned int size_data, struct lys_node **node)\n{\n    unsigned int size;\n    YY_BUFFER_STATE bp;\n    yyscan_t scanner = NULL;\n    int ret = 0;\n    struct lys_module *trg;\n    struct yang_parameter param;\n\n    size = (size_data) ? size_data : strlen(data) + 2;\n    yylex_init(&scanner);\n    yyset_extra(module->ctx, scanner);\n    bp = yy_scan_buffer((char *)data, size, scanner);\n    yy_switch_to_buffer(bp, scanner);\n    memset(&param, 0, sizeof param);\n    param.module = module;\n    param.submodule = submodule;\n    param.unres = unres;\n    param.node = node;\n    param.flags |= YANG_REMOVE_IMPORT;\n    if (yyparse(scanner, &param)) {\n        if (param.flags & YANG_REMOVE_IMPORT) {\n            trg = (submodule) ? (struct lys_module *)submodule : module;\n            yang_free_import(trg->ctx, trg->imp, 0, trg->imp_size);\n            yang_free_include(trg->ctx, trg->inc, 0, trg->inc_size);\n            trg->inc_size = 0;\n            trg->imp_size = 0;\n        }\n        ret = (param.flags & YANG_EXIST_MODULE) ? 1 : -1;\n    }\n    yy_delete_buffer(bp, scanner);\n    yylex_destroy(scanner);\n    return ret;\n}\n\nint\nyang_parse_ext_substatement(struct lys_module *module, struct unres_schema *unres, const char *data,\n                            char *ext_name, struct lys_ext_instance_complex *ext)\n{\n    unsigned int size;\n    YY_BUFFER_STATE bp;\n    yyscan_t scanner = NULL;\n    int ret = 0;\n    struct yang_parameter param;\n    struct lys_node *node = NULL;\n\n    if (!data) {\n        return EXIT_SUCCESS;\n    }\n    size = strlen(data) + 2;\n    yylex_init(&scanner);\n    bp = yy_scan_buffer((char *)data, size, scanner);\n    yy_switch_to_buffer(bp, scanner);\n    memset(&param, 0, sizeof param);\n    param.module = module;\n    param.unres = unres;\n    param.node = &node;\n    param.actual_node = (void **)ext;\n    param.data_node = (void **)ext_name;\n    param.flags |= EXT_INSTANCE_SUBSTMT;\n    if (yyparse(scanner, &param)) {\n        yang_free_nodes(module->ctx, node);\n        ret = -1;\n    } else {\n        /* success parse, but it needs some sematic controls */\n        if (node && yang_check_nodes(module, (struct lys_node *)ext, node, LYS_PARSE_OPT_CFG_NOINHERIT, unres)) {\n            ret = -1;\n        }\n    }\n    yy_delete_buffer(bp, scanner);\n    yylex_destroy(scanner);\n    return ret;\n}\n\nstruct lys_module *\nyang_read_module(struct ly_ctx *ctx, const char* data, unsigned int size, const char *revision, int implement)\n{\n    struct lys_module *module = NULL, *tmp_mod;\n    struct unres_schema *unres = NULL;\n    struct lys_node *node = NULL;\n    int ret;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_GOTO(!unres, LOGMEM(ctx), error);\n\n    module = calloc(1, sizeof *module);\n    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);\n\n    /* initiale module */\n    module->ctx = ctx;\n    module->type = 0;\n    module->implemented = (implement ? 1 : 0);\n\n    /* add into the list of processed modules */\n    if (lyp_check_circmod_add(module)) {\n        goto error;\n    }\n\n    ret = yang_parse_mem(module, NULL, unres, data, size, &node);\n    if (ret == -1) {\n        if (ly_vecode(ctx) == LYVE_SUBMODULE && !module->name) {\n            /* Remove this module from the list of processed modules,\n               as we're about to free it */\n            lyp_check_circmod_pop(ctx);\n\n            free(module);\n            module = NULL;\n        } else {\n            free_yang_common(module, node);\n        }\n        goto error;\n    } else if (ret == 1) {\n        assert(!unres->count);\n    } else {\n        if (yang_check_sub_module(module, unres, node)) {\n            goto error;\n        }\n\n        if (!implement && module->implemented && lys_make_implemented_r(module, unres)) {\n            goto error;\n        }\n\n        if (unres->count && resolve_unres_schema(module, unres)) {\n            goto error;\n        }\n\n        /* check correctness of includes */\n        if (lyp_check_include_missing(module)) {\n            goto error;\n        }\n    }\n\n    lyp_sort_revisions(module);\n\n    if (lyp_rfn_apply_ext(module) || lyp_deviation_apply_ext(module)) {\n        goto error;\n    }\n\n    if (revision) {\n        /* check revision of the parsed model */\n        if (!module->rev_size || strcmp(revision, module->rev[0].date)) {\n            LOGVRB(\"Module \\\"%s\\\" parsed with the wrong revision (\\\"%s\\\" instead \\\"%s\\\").\",\n                   module->name, module->rev[0].date, revision);\n            goto error;\n        }\n    }\n\n    /* add into context if not already there */\n    if (!ret) {\n        if (lyp_ctx_add_module(module)) {\n            goto error;\n        }\n\n        /* remove our submodules from the parsed submodules list */\n        lyp_del_includedup(module, 0);\n    } else {\n        tmp_mod = module;\n\n        /* get the model from the context */\n        module = (struct lys_module *)ly_ctx_get_module(ctx, module->name, revision, 0);\n        assert(module);\n\n        /* free what was parsed */\n        lys_free(tmp_mod, NULL, 0, 0);\n    }\n\n    unres_schema_free(NULL, &unres, 0);\n    lyp_check_circmod_pop(ctx);\n    LOGVRB(\"Module \\\"%s%s%s\\\" successfully parsed as %s.\", module->name, (module->rev_size ? \"@\" : \"\"),\n           (module->rev_size ? module->rev[0].date : \"\"), (module->implemented ? \"implemented\" : \"imported\"));\n    return module;\n\nerror:\n    /* cleanup */\n    unres_schema_free(module, &unres, 1);\n\n    if (!module) {\n        if (ly_vecode(ctx) != LYVE_SUBMODULE) {\n            LOGERR(ctx, ly_errno, \"Module parsing failed.\");\n        }\n        return NULL;\n    }\n\n    if (module->name) {\n        LOGERR(ctx, ly_errno, \"Module \\\"%s\\\" parsing failed.\", module->name);\n    } else {\n        LOGERR(ctx, ly_errno, \"Module parsing failed.\");\n    }\n\n    lyp_check_circmod_pop(ctx);\n    lys_sub_module_remove_devs_augs(module);\n    lyp_del_includedup(module, 1);\n    lys_free(module, NULL, 0, 1);\n    return NULL;\n}\n\nstruct lys_submodule *\nyang_read_submodule(struct lys_module *module, const char *data, unsigned int size, struct unres_schema *unres)\n{\n    struct lys_submodule *submodule;\n    struct lys_node *node = NULL;\n\n    submodule = calloc(1, sizeof *submodule);\n    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(module->ctx), error);\n\n    submodule->ctx = module->ctx;\n    submodule->type = 1;\n    submodule->implemented = module->implemented;\n    submodule->belongsto = module;\n\n    /* add into the list of processed modules */\n    if (lyp_check_circmod_add((struct lys_module *)submodule)) {\n        goto error;\n    }\n\n    /* module cannot be changed in this case and 1 cannot be returned */\n    if (yang_parse_mem(module, submodule, unres, data, size, &node)) {\n        free_yang_common((struct lys_module *)submodule, node);\n        goto error;\n    }\n\n    lyp_sort_revisions((struct lys_module *)submodule);\n\n    if (yang_check_sub_module((struct lys_module *)submodule, unres, node)) {\n        goto error;\n    }\n\n    lyp_check_circmod_pop(module->ctx);\n\n    LOGVRB(\"Submodule \\\"%s\\\" successfully parsed.\", submodule->name);\n    return submodule;\n\nerror:\n    /* cleanup */\n    if (!submodule || !submodule->name) {\n        free(submodule);\n        LOGERR(module->ctx, ly_errno, \"Submodule parsing failed.\");\n        return NULL;\n    }\n\n    LOGERR(module->ctx, ly_errno, \"Submodule \\\"%s\\\" parsing failed.\", submodule->name);\n\n    unres_schema_free((struct lys_module *)submodule, &unres, 0);\n    lyp_check_circmod_pop(module->ctx);\n    lys_sub_module_remove_devs_augs((struct lys_module *)submodule);\n    lys_submodule_module_data_free(submodule);\n    lys_submodule_free(submodule, NULL);\n    return NULL;\n}\n\nstatic int\nread_indent(const char *input, int indent, int size, int in_index, int *out_index, char *output)\n{\n    int k = 0, j;\n\n    while (in_index < size) {\n        if (input[in_index] == ' ') {\n            k++;\n        } else if (input[in_index] == '\\t') {\n            /* RFC 6020 6.1.3 tab character is treated as 8 space characters */\n            k += 8;\n        } else  if (input[in_index] == '\\\\' && input[in_index + 1] == 't') {\n            /* RFC 6020 6.1.3 tab character is treated as 8 space characters */\n            k += 8;\n            ++in_index;\n        } else {\n            break;\n        }\n        ++in_index;\n        if (k >= indent) {\n            for (j = k - indent; j > 0; --j) {\n                output[*out_index] = ' ';\n                if (j > 1) {\n                    ++(*out_index);\n                }\n            }\n            break;\n        }\n    }\n    return in_index - 1;\n}\n\nchar *\nyang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent)\n{\n    int i = 0, out_index = offset, space = 0;\n\n    while (i < size) {\n        switch (input[i]) {\n        case '\\n':\n            out_index -= space;\n            output[out_index] = '\\n';\n            space = 0;\n            i = read_indent(input, indent, size, i + 1, &out_index, output);\n            break;\n        case ' ':\n        case '\\t':\n            output[out_index] = input[i];\n            ++space;\n            break;\n        case '\\\\':\n            if (input[i + 1] == 'n') {\n                out_index -= space;\n                output[out_index] = '\\n';\n                space = 0;\n                i = read_indent(input, indent, size, i + 2, &out_index, output);\n            } else if (input[i + 1] == 't') {\n                output[out_index] = '\\t';\n                ++i;\n                ++space;\n            } else if (input[i + 1] == '\\\\') {\n                output[out_index] = '\\\\';\n                ++i;\n            } else if ((i + 1) != size && input[i + 1] == '\"') {\n                output[out_index] = '\"';\n                ++i;\n            } else {\n                /* backslash must not be followed by any other character */\n                LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, input + i);\n                return NULL;\n            }\n            break;\n        default:\n            output[out_index] = input[i];\n            space = 0;\n            break;\n        }\n        ++i;\n        ++out_index;\n    }\n    output[out_index] = '\\0';\n    if (size != out_index) {\n        output = realloc(output, out_index + 1);\n        LY_CHECK_ERR_RETURN(!output, LOGMEM(ctx), NULL);\n    }\n    return output;\n}\n\n/* free function */\n\nvoid\nyang_type_free(struct ly_ctx *ctx, struct lys_type *type)\n{\n    struct yang_type *stype = (struct yang_type *)type->der;\n    unsigned int i;\n\n    if (!stype) {\n        return ;\n    }\n    if (type->base == LY_TYPE_DER || type->base == LY_TYPE_UNION) {\n        lydict_remove(ctx, stype->name);\n        if (stype->base == LY_TYPE_IDENT && (!(stype->flags & LYS_NO_ERASE_IDENTITY))) {\n            for (i = 0; i < type->info.ident.count; ++i) {\n                free(type->info.ident.ref[i]);\n            }\n        }\n        if (stype->base == LY_TYPE_UNION) {\n            for (i = 0; i < type->info.uni.count; ++i) {\n                yang_type_free(ctx, &type->info.uni.types[i]);\n            }\n            free(type->info.uni.types);\n            type->base = LY_TYPE_DER;\n        } else {\n            type->base = stype->base;\n        }\n        free(stype);\n        type->der = NULL;\n    }\n    lys_type_free(ctx, type, NULL);\n    memset(type, 0, sizeof (struct lys_type));\n}\n\nstatic void\nyang_tpdf_free(struct ly_ctx *ctx, struct lys_tpdf *tpdf, uint16_t start, uint16_t size)\n{\n    uint8_t i;\n\n    assert(ctx);\n    if (!tpdf) {\n        return;\n    }\n\n    for (i = start; i < size; ++i) {\n        lydict_remove(ctx, tpdf[i].name);\n        lydict_remove(ctx, tpdf[i].dsc);\n        lydict_remove(ctx, tpdf[i].ref);\n\n        yang_type_free(ctx, &tpdf[i].type);\n\n        lydict_remove(ctx, tpdf[i].units);\n        lydict_remove(ctx, tpdf[i].dflt);\n        lys_extension_instances_free(ctx, tpdf[i].ext, tpdf[i].ext_size, NULL);\n    }\n}\n\nstatic void\nyang_free_import(struct ly_ctx *ctx, struct lys_import *imp, uint8_t start, uint8_t size)\n{\n    uint8_t i;\n\n    for (i = start; i < size; ++i){\n        free((char *)imp[i].module);\n        lydict_remove(ctx, imp[i].prefix);\n        lydict_remove(ctx, imp[i].dsc);\n        lydict_remove(ctx, imp[i].ref);\n        lys_extension_instances_free(ctx, imp[i].ext, imp[i].ext_size, NULL);\n    }\n}\n\nstatic void\nyang_free_include(struct ly_ctx *ctx, struct lys_include *inc, uint8_t start, uint8_t size)\n{\n    uint8_t i;\n\n    for (i = start; i < size; ++i){\n        free((char *)inc[i].submodule);\n        lydict_remove(ctx, inc[i].dsc);\n        lydict_remove(ctx, inc[i].ref);\n        lys_extension_instances_free(ctx, inc[i].ext, inc[i].ext_size, NULL);\n    }\n}\n\nstatic void\nyang_free_ident_base(struct lys_ident *ident, uint32_t start, uint32_t size)\n{\n    uint32_t i;\n    uint8_t j;\n\n    /* free base name */\n    for (i = start; i < size; ++i) {\n        for (j = 0; j < ident[i].base_size; ++j) {\n            free(ident[i].base[j]);\n        }\n    }\n}\n\nstatic void\nyang_free_grouping(struct ly_ctx *ctx, struct lys_node_grp * grp)\n{\n    yang_tpdf_free(ctx, grp->tpdf, 0, grp->tpdf_size);\n    free(grp->tpdf);\n}\n\nstatic void\nyang_free_container(struct ly_ctx *ctx, struct lys_node_container * cont)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, cont->tpdf, 0, cont->tpdf_size);\n    free(cont->tpdf);\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->must_size; ++i) {\n        lys_restr_free(ctx, &cont->must[i], NULL);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, NULL);\n}\n\nstatic void\nyang_free_leaf(struct ly_ctx *ctx, struct lys_node_leaf *leaf)\n{\n    uint8_t i;\n\n    for (i = 0; i < leaf->must_size; i++) {\n        lys_restr_free(ctx, &leaf->must[i], NULL);\n    }\n    free(leaf->must);\n\n    lys_when_free(ctx, leaf->when, NULL);\n\n    yang_type_free(ctx, &leaf->type);\n    lydict_remove(ctx, leaf->units);\n    lydict_remove(ctx, leaf->dflt);\n}\n\nstatic void\nyang_free_leaflist(struct ly_ctx *ctx, struct lys_node_leaflist *leaflist)\n{\n    uint8_t i;\n\n    for (i = 0; i < leaflist->must_size; i++) {\n        lys_restr_free(ctx, &leaflist->must[i], NULL);\n    }\n    free(leaflist->must);\n\n    for (i = 0; i < leaflist->dflt_size; i++) {\n        lydict_remove(ctx, leaflist->dflt[i]);\n    }\n    free(leaflist->dflt);\n\n    lys_when_free(ctx, leaflist->when, NULL);\n\n    yang_type_free(ctx, &leaflist->type);\n    lydict_remove(ctx, leaflist->units);\n}\n\nstatic void\nyang_free_list(struct ly_ctx *ctx, struct lys_node_list *list)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, list->tpdf, 0, list->tpdf_size);\n    free(list->tpdf);\n\n    for (i = 0; i < list->must_size; ++i) {\n        lys_restr_free(ctx, &list->must[i], NULL);\n    }\n    free(list->must);\n\n    lys_when_free(ctx, list->when, NULL);\n\n    for (i = 0; i < list->unique_size; ++i) {\n        free(list->unique[i].expr);\n    }\n    free(list->unique);\n\n    free(list->keys);\n}\n\nstatic void\nyang_free_choice(struct ly_ctx *ctx, struct lys_node_choice *choice)\n{\n    free(choice->dflt);\n    lys_when_free(ctx, choice->when, NULL);\n}\n\nstatic void\nyang_free_anydata(struct ly_ctx *ctx, struct lys_node_anydata *anydata)\n{\n    uint8_t i;\n\n    for (i = 0; i < anydata->must_size; ++i) {\n        lys_restr_free(ctx, &anydata->must[i], NULL);\n    }\n    free(anydata->must);\n\n    lys_when_free(ctx, anydata->when, NULL);\n}\n\nstatic void\nyang_free_inout(struct ly_ctx *ctx, struct lys_node_inout *inout)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, inout->tpdf, 0, inout->tpdf_size);\n    free(inout->tpdf);\n\n    for (i = 0; i < inout->must_size; ++i) {\n        lys_restr_free(ctx, &inout->must[i], NULL);\n    }\n    free(inout->must);\n}\n\nstatic void\nyang_free_notif(struct ly_ctx *ctx, struct lys_node_notif *notif)\n{\n    uint8_t i;\n\n    yang_tpdf_free(ctx, notif->tpdf, 0, notif->tpdf_size);\n    free(notif->tpdf);\n\n    for (i = 0; i < notif->must_size; ++i) {\n        lys_restr_free(ctx, &notif->must[i], NULL);\n    }\n    free(notif->must);\n}\n\nstatic void\nyang_free_uses(struct ly_ctx *ctx, struct lys_node_uses *uses)\n{\n    int i, j;\n\n    for (i = 0; i < uses->refine_size; i++) {\n        lydict_remove(ctx, uses->refine[i].target_name);\n        lydict_remove(ctx, uses->refine[i].dsc);\n        lydict_remove(ctx, uses->refine[i].ref);\n\n        for (j = 0; j < uses->refine[i].must_size; j++) {\n            lys_restr_free(ctx, &uses->refine[i].must[j], NULL);\n        }\n        free(uses->refine[i].must);\n\n        for (j = 0; j < uses->refine[i].dflt_size; j++) {\n            lydict_remove(ctx, uses->refine[i].dflt[j]);\n        }\n        free(uses->refine[i].dflt);\n\n        if (uses->refine[i].target_type & LYS_CONTAINER) {\n            lydict_remove(ctx, uses->refine[i].mod.presence);\n        }\n        lys_extension_instances_free(ctx, uses->refine[i].ext, uses->refine[i].ext_size, NULL);\n    }\n    free(uses->refine);\n\n    lys_when_free(ctx, uses->when, NULL);\n}\n\nstatic void\nyang_free_nodes(struct ly_ctx *ctx, struct lys_node *node)\n{\n    struct lys_node *tmp, *child, *sibling;\n\n    if (!node) {\n        return;\n    }\n    tmp = node;\n\n    while (tmp) {\n        child = tmp->child;\n        sibling = tmp->next;\n        /* common part */\n        lydict_remove(ctx, tmp->name);\n        if (!(tmp->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            lys_iffeature_free(ctx, tmp->iffeature, tmp->iffeature_size, 0, NULL);\n            lydict_remove(ctx, tmp->dsc);\n            lydict_remove(ctx, tmp->ref);\n        }\n\n        switch (tmp->nodetype) {\n        case LYS_GROUPING:\n        case LYS_RPC:\n        case LYS_ACTION:\n            yang_free_grouping(ctx, (struct lys_node_grp *)tmp);\n            break;\n        case LYS_CONTAINER:\n            yang_free_container(ctx, (struct lys_node_container *)tmp);\n            break;\n        case LYS_LEAF:\n            yang_free_leaf(ctx, (struct lys_node_leaf *)tmp);\n            break;\n        case LYS_LEAFLIST:\n            yang_free_leaflist(ctx, (struct lys_node_leaflist *)tmp);\n            break;\n        case LYS_LIST:\n            yang_free_list(ctx, (struct lys_node_list *)tmp);\n            break;\n        case LYS_CHOICE:\n            yang_free_choice(ctx, (struct lys_node_choice *)tmp);\n            break;\n        case LYS_CASE:\n            lys_when_free(ctx, ((struct lys_node_case *)tmp)->when, NULL);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            yang_free_anydata(ctx, (struct lys_node_anydata *)tmp);\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            yang_free_inout(ctx, (struct lys_node_inout *)tmp);\n            break;\n        case LYS_NOTIF:\n            yang_free_notif(ctx, (struct lys_node_notif *)tmp);\n            break;\n        case LYS_USES:\n            yang_free_uses(ctx, (struct lys_node_uses *)tmp);\n            break;\n        default:\n            break;\n        }\n        lys_extension_instances_free(ctx, tmp->ext, tmp->ext_size, NULL);\n        yang_free_nodes(ctx, child);\n        free(tmp);\n        tmp = sibling;\n    }\n}\n\nstatic void\nyang_free_augment(struct ly_ctx *ctx, struct lys_node_augment *aug)\n{\n    lydict_remove(ctx, aug->target_name);\n    lydict_remove(ctx, aug->dsc);\n    lydict_remove(ctx, aug->ref);\n\n    lys_iffeature_free(ctx, aug->iffeature, aug->iffeature_size, 0, NULL);\n    lys_when_free(ctx, aug->when, NULL);\n    yang_free_nodes(ctx, aug->child);\n    lys_extension_instances_free(ctx, aug->ext, aug->ext_size, NULL);\n}\n\nstatic void\nyang_free_deviate(struct ly_ctx *ctx, struct lys_deviation *dev, uint index)\n{\n    uint i, j;\n\n    for (i = index; i < dev->deviate_size; ++i) {\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].type) {\n            yang_type_free(ctx, dev->deviate[i].type);\n            free(dev->deviate[i].type);\n        }\n\n        for (j = 0; j < dev->deviate[i].dflt_size; ++j) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        for (j = 0; j < dev->deviate[i].must_size; ++j) {\n            lys_restr_free(ctx, &dev->deviate[i].must[j], NULL);\n        }\n        free(dev->deviate[i].must);\n\n        for (j = 0; j < dev->deviate[i].unique_size; ++j) {\n            free(dev->deviate[i].unique[j].expr);\n        }\n        free(dev->deviate[i].unique);\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, NULL);\n    }\n}\n\nvoid\nyang_free_ext_data(struct yang_ext_substmt *substmt)\n{\n    int i;\n\n    if (!substmt) {\n        return;\n    }\n\n    free(substmt->ext_substmt);\n    if (substmt->ext_modules) {\n        for (i = 0; substmt->ext_modules[i]; ++i) {\n            free(substmt->ext_modules[i]);\n        }\n        free(substmt->ext_modules);\n    }\n    free(substmt);\n}\n\n/* free common item from module and submodule */\nstatic void\nfree_yang_common(struct lys_module *module, struct lys_node *node)\n{\n    uint i;\n    yang_tpdf_free(module->ctx, module->tpdf, 0, module->tpdf_size);\n    module->tpdf_size = 0;\n    yang_free_ident_base(module->ident, 0, module->ident_size);\n    yang_free_nodes(module->ctx, node);\n    for (i = 0; i < module->augment_size; ++i) {\n        yang_free_augment(module->ctx, &module->augment[i]);\n    }\n    module->augment_size = 0;\n    for (i = 0; i < module->deviation_size; ++i) {\n        yang_free_deviate(module->ctx, &module->deviation[i], 0);\n        free(module->deviation[i].deviate);\n        lydict_remove(module->ctx, module->deviation[i].target_name);\n        lydict_remove(module->ctx, module->deviation[i].dsc);\n        lydict_remove(module->ctx, module->deviation[i].ref);\n    }\n    module->deviation_size = 0;\n}\n\n/* check function*/\n\nint\nyang_check_ext_instance(struct lys_module *module, struct lys_ext_instance ***ext, uint size,\n                        void *parent, struct unres_schema *unres)\n{\n    struct unres_ext *info;\n    uint i;\n\n    for (i = 0; i < size; ++i) {\n        info = malloc(sizeof *info);\n        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);\n        info->data.yang = (*ext)[i]->parent;\n        info->datatype = LYS_IN_YANG;\n        info->parent = parent;\n        info->mod = module;\n        info->parent_type = (*ext)[i]->parent_type;\n        info->substmt = (*ext)[i]->insubstmt;\n        info->substmt_index = (*ext)[i]->insubstmt_index;\n        info->ext_index = i;\n        if (unres_schema_add_node(module, unres, ext, UNRES_EXT, (struct lys_node *)info) == -1) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_check_imports(struct lys_module *module, struct unres_schema *unres)\n{\n    struct lys_import *imp;\n    struct lys_include *inc;\n    uint8_t imp_size, inc_size, j = 0, i = 0;\n    char *s;\n\n    imp = module->imp;\n    imp_size = module->imp_size;\n    inc = module->inc;\n    inc_size = module->inc_size;\n\n    if (imp_size) {\n        module->imp = calloc(imp_size, sizeof *module->imp);\n        module->imp_size = 0;\n        LY_CHECK_ERR_GOTO(!module->imp, LOGMEM(module->ctx), error);\n    }\n\n    if (inc_size) {\n        module->inc = calloc(inc_size, sizeof *module->inc);\n        module->inc_size = 0;\n        LY_CHECK_ERR_GOTO(!module->inc, LOGMEM(module->ctx), error);\n    }\n\n    for (i = 0; i < imp_size; ++i) {\n        s = (char *) imp[i].module;\n        imp[i].module = NULL;\n        if (yang_fill_import(module, &imp[i], &module->imp[module->imp_size], s, unres)) {\n            ++i;\n            goto error;\n        }\n    }\n    for (j = 0; j < inc_size; ++j) {\n        s = (char *) inc[j].submodule;\n        inc[j].submodule = NULL;\n        if (yang_fill_include(module, s, &inc[j], unres)) {\n            ++j;\n            goto error;\n        }\n    }\n    free(inc);\n    free(imp);\n\n    return EXIT_SUCCESS;\n\nerror:\n    yang_free_import(module->ctx, imp, i, imp_size);\n    yang_free_include(module->ctx, inc, j, inc_size);\n    free(imp);\n    free(inc);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_iffeatures(struct lys_module *module, void *ptr, void *parent, enum yytokentype type, struct unres_schema *unres)\n{\n    struct lys_iffeature *iffeature;\n    uint8_t *ptr_size, size, i;\n    char *s;\n    int parent_is_feature = 0;\n\n    switch (type) {\n    case FEATURE_KEYWORD:\n        iffeature = ((struct lys_feature *)parent)->iffeature;\n        size = ((struct lys_feature *)parent)->iffeature_size;\n        ptr_size = &((struct lys_feature *)parent)->iffeature_size;\n        parent_is_feature = 1;\n        break;\n    case IDENTITY_KEYWORD:\n        iffeature = ((struct lys_ident *)parent)->iffeature;\n        size = ((struct lys_ident *)parent)->iffeature_size;\n        ptr_size = &((struct lys_ident *)parent)->iffeature_size;\n        break;\n    case ENUM_KEYWORD:\n        iffeature = ((struct lys_type_enum *)ptr)->iffeature;\n        size = ((struct lys_type_enum *)ptr)->iffeature_size;\n        ptr_size = &((struct lys_type_enum *)ptr)->iffeature_size;\n        break;\n    case BIT_KEYWORD:\n        iffeature = ((struct lys_type_bit *)ptr)->iffeature;\n        size = ((struct lys_type_bit *)ptr)->iffeature_size;\n        ptr_size = &((struct lys_type_bit *)ptr)->iffeature_size;\n        break;\n    case REFINE_KEYWORD:\n        iffeature = ((struct lys_refine *)ptr)->iffeature;\n        size = ((struct lys_refine *)ptr)->iffeature_size;\n        ptr_size = &((struct lys_refine *)ptr)->iffeature_size;\n        break;\n    default:\n        iffeature = ((struct lys_node *)parent)->iffeature;\n        size = ((struct lys_node *)parent)->iffeature_size;\n        ptr_size = &((struct lys_node *)parent)->iffeature_size;\n        break;\n    }\n\n    *ptr_size = 0;\n    for (i = 0; i < size; ++i) {\n        s = (char *)iffeature[i].features;\n        iffeature[i].features = NULL;\n        if (yang_fill_iffeature(module, &iffeature[i], parent, s, unres, parent_is_feature)) {\n            *ptr_size = size;\n            return EXIT_FAILURE;\n        }\n        if (yang_check_ext_instance(module, &iffeature[i].ext, iffeature[i].ext_size, &iffeature[i], unres)) {\n            *ptr_size = size;\n            return EXIT_FAILURE;\n        }\n        (*ptr_size)++;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\nyang_check_identityref(struct lys_module *module, struct lys_type *type, struct unres_schema *unres)\n{\n    uint size, i;\n    int rc;\n    struct lys_ident **ref;\n    const char *value;\n    char *expr;\n\n    ref = type->info.ident.ref;\n    size = type->info.ident.count;\n    type->info.ident.count = 0;\n    type->info.ident.ref = NULL;\n    ((struct yang_type *)type->der)->flags |= LYS_NO_ERASE_IDENTITY;\n\n    for (i = 0; i < size; ++i) {\n        expr = (char *)ref[i];\n        /* store in the JSON format */\n        value = transform_schema2json(module, expr);\n        free(expr);\n\n        if (!value) {\n            goto error;\n        }\n        rc = unres_schema_add_str(module, unres, type, UNRES_TYPE_IDENTREF, value);\n        lydict_remove(module->ctx, value);\n\n        if (rc == -1) {\n            goto error;\n        }\n    }\n    free(ref);\n\n    return EXIT_SUCCESS;\nerror:\n    for (i = i+1; i < size; ++i) {\n        free(ref[i]);\n    }\n    free(ref);\n    return EXIT_FAILURE;\n}\n\nint\nyang_fill_type(struct lys_module *module, struct lys_type *type, struct yang_type *stype,\n               void *parent, struct unres_schema *unres)\n{\n    unsigned int i, j;\n\n    type->parent = parent;\n    if (yang_check_ext_instance(module, &type->ext, type->ext_size, type, unres)) {\n        return EXIT_FAILURE;\n    }\n    for (j = 0; j < type->ext_size; ++j) {\n        if (type->ext[j]->flags & LYEXT_OPT_VALID) {\n            type->parent->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    switch (stype->base) {\n    case LY_TYPE_ENUM:\n        for (i = 0; i < type->info.enums.count; ++i) {\n            if (yang_check_iffeatures(module, &type->info.enums.enm[i], parent, ENUM_KEYWORD, unres)) {\n                return EXIT_FAILURE;\n            }\n            if (yang_check_ext_instance(module, &type->info.enums.enm[i].ext, type->info.enums.enm[i].ext_size,\n                                        &type->info.enums.enm[i], unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.enums.enm[i].ext_size; ++j) {\n                if (type->info.enums.enm[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_BITS:\n        for (i = 0; i < type->info.bits.count; ++i) {\n            if (yang_check_iffeatures(module, &type->info.bits.bit[i], parent, BIT_KEYWORD, unres)) {\n                return EXIT_FAILURE;\n            }\n            if (yang_check_ext_instance(module, &type->info.bits.bit[i].ext, type->info.bits.bit[i].ext_size,\n                                        &type->info.bits.bit[i], unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.bits.bit[i].ext_size; ++j) {\n                if (type->info.bits.bit[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_IDENT:\n        if (yang_check_identityref(module, type, unres)) {\n            return EXIT_FAILURE;\n        }\n        break;\n    case LY_TYPE_STRING:\n        if (type->info.str.length) {\n            if (yang_check_ext_instance(module, &type->info.str.length->ext,\n                                        type->info.str.length->ext_size, type->info.str.length, unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.str.length->ext_size; ++j) {\n                if (type->info.str.length->ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n\n        for (i = 0; i < type->info.str.pat_count; ++i) {\n            if (yang_check_ext_instance(module, &type->info.str.patterns[i].ext, type->info.str.patterns[i].ext_size,\n                                        &type->info.str.patterns[i], unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.str.patterns[i].ext_size; ++j) {\n                if (type->info.str.patterns[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_DEC64:\n        if (type->info.dec64.range) {\n            if (yang_check_ext_instance(module, &type->info.dec64.range->ext,\n                                        type->info.dec64.range->ext_size, type->info.dec64.range, unres)) {\n                return EXIT_FAILURE;\n            }\n            for (j = 0; j < type->info.dec64.range->ext_size; ++j) {\n                if (type->info.dec64.range->ext[j]->flags & LYEXT_OPT_VALID) {\n                    type->parent->flags |= LYS_VALID_EXT;\n                    break;\n                }\n            }\n        }\n        break;\n    case LY_TYPE_UNION:\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (yang_fill_type(module, &type->info.uni.types[i], (struct yang_type *)type->info.uni.types[i].der,\n                               parent, unres)) {\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    default:\n        /* nothing checks */\n        break;\n    }\n    return EXIT_SUCCESS;\n}\n\nint\nyang_check_typedef(struct lys_module *module, struct lys_node *parent, struct unres_schema *unres)\n{\n    struct lys_tpdf *tpdf;\n    uint8_t *ptr_tpdf_size = NULL;\n    uint16_t j, i, tpdf_size, *ptr_tpdf_size16 = NULL;\n\n    if (!parent) {\n        tpdf = module->tpdf;\n        //ptr_tpdf_size = &module->tpdf_size;\n        ptr_tpdf_size16 = &module->tpdf_size;\n    } else {\n        switch (parent->nodetype) {\n        case LYS_GROUPING:\n            tpdf = ((struct lys_node_grp *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_grp *)parent)->tpdf_size;\n            break;\n        case LYS_CONTAINER:\n            tpdf = ((struct lys_node_container *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_container *)parent)->tpdf_size;\n            break;\n        case LYS_LIST:\n            tpdf = ((struct lys_node_list *)parent)->tpdf;\n            ptr_tpdf_size = &((struct lys_node_list *)parent)->tpdf_size;\n            break;\n        case LYS_RPC:\n        case LYS_ACTION:\n            tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_rpc_action *)parent)->tpdf_size;\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            tpdf = ((struct lys_node_inout *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_inout *)parent)->tpdf_size;\n            break;\n        case LYS_NOTIF:\n            tpdf = ((struct lys_node_notif *)parent)->tpdf;\n            ptr_tpdf_size16 = &((struct lys_node_notif *)parent)->tpdf_size;\n            break;\n        default:\n            LOGINT(module->ctx);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (ptr_tpdf_size16) {\n        tpdf_size = *ptr_tpdf_size16;\n        *ptr_tpdf_size16 = 0;\n    } else {\n        tpdf_size = *ptr_tpdf_size;\n        *ptr_tpdf_size = 0;\n    }\n\n    for (i = 0; i < tpdf_size; ++i) {\n        if (lyp_check_identifier(module->ctx, tpdf[i].name, LY_IDENT_TYPE, module, parent)) {\n            goto error;\n        }\n\n        if (yang_fill_type(module, &tpdf[i].type, (struct yang_type *)tpdf[i].type.der, &tpdf[i], unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &tpdf[i].ext, tpdf[i].ext_size, &tpdf[i], unres)) {\n            goto error;\n        }\n        for (j = 0; j < tpdf[i].ext_size; ++j) {\n            if (tpdf[i].ext[j]->flags & LYEXT_OPT_VALID) {\n                tpdf[i].flags |= LYS_VALID_EXT;\n                break;\n            }\n        }\n        if (unres_schema_add_node(module, unres, &tpdf[i].type, UNRES_TYPE_DER_TPDF, parent) == -1) {\n            goto error;\n        }\n\n        if (ptr_tpdf_size16) {\n            (*ptr_tpdf_size16)++;\n        } else {\n            (*ptr_tpdf_size)++;\n        }\n        /* check default value*/\n        if (!(module->ctx->models.flags & LY_CTX_TRUSTED)\n                && unres_schema_add_node(module, unres, &tpdf[i].type, UNRES_TYPEDEF_DFLT, (struct lys_node *)(&tpdf[i].dflt)) == -1)  {\n            ++i;\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    yang_tpdf_free(module->ctx, tpdf, i, tpdf_size);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_identities(struct lys_module *module, struct unres_schema *unres)\n{\n    uint32_t i, size, base_size;\n    uint8_t j;\n\n    size = module->ident_size;\n    module->ident_size = 0;\n    for (i = 0; i < size; ++i) {\n        base_size = module->ident[i].base_size;\n        module->ident[i].base_size = 0;\n        for (j = 0; j < base_size; ++j) {\n            if (yang_read_base(module, &module->ident[i], (char *)module->ident[i].base[j], unres)) {\n                ++j;\n                module->ident_size = size;\n                goto error;\n            }\n        }\n        module->ident_size++;\n        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &module->ident[i].ext, module->ident[i].ext_size, &module->ident[i], unres)) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    for (; j< module->ident[i].base_size; ++j) {\n        free(module->ident[i].base[j]);\n    }\n    yang_free_ident_base(module->ident, i + 1, size);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_must(struct lys_module *module, struct lys_restr *must, uint size, struct unres_schema *unres)\n{\n    uint i;\n\n    for (i = 0; i < size; ++i) {\n        if (yang_check_ext_instance(module, &must[i].ext, must[i].ext_size, &must[i], unres)) {\n            return EXIT_FAILURE;\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\nyang_check_container(struct lys_module *module, struct lys_node_container *cont, struct lys_node **child,\n                     int options, struct unres_schema *unres)\n{\n    if (yang_check_typedef(module, (struct lys_node *)cont, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, cont, CONTAINER_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)cont, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (cont->when && yang_check_ext_instance(module, &cont->when->ext, cont->when->ext_size, cont->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, cont->must, cont->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)cont)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, cont, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\nerror:\n\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_leaf(struct lys_module *module, struct lys_node_leaf *leaf, int options, struct unres_schema *unres)\n{\n    if (yang_fill_type(module, &leaf->type, (struct yang_type *)leaf->type.der, leaf, unres)) {\n        yang_type_free(module->ctx, &leaf->type);\n        goto error;\n    }\n    if (yang_check_iffeatures(module, NULL, leaf, LEAF_KEYWORD, unres)) {\n        yang_type_free(module->ctx, &leaf->type);\n        goto error;\n    }\n\n    if (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DER, (struct lys_node *)leaf) == -1) {\n        yang_type_free(module->ctx, &leaf->type);\n        goto error;\n    }\n\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) &&\n            (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT, (struct lys_node *)&leaf->dflt) == -1)) {\n        goto error;\n    }\n\n    if (leaf->when && yang_check_ext_instance(module, &leaf->when->ext, leaf->when->ext_size, leaf->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, leaf->must, leaf->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (leaf->when || leaf->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)leaf)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, leaf, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_leaflist(struct lys_module *module, struct lys_node_leaflist *leaflist, int options,\n                    struct unres_schema *unres)\n{\n    int i, j;\n\n    if (yang_fill_type(module, &leaflist->type, (struct yang_type *)leaflist->type.der, leaflist, unres)) {\n        yang_type_free(module->ctx, &leaflist->type);\n        goto error;\n    }\n    if (yang_check_iffeatures(module, NULL, leaflist, LEAF_LIST_KEYWORD, unres)) {\n        yang_type_free(module->ctx, &leaflist->type);\n        goto error;\n    }\n\n    if (unres_schema_add_node(module, unres, &leaflist->type, UNRES_TYPE_DER, (struct lys_node *)leaflist) == -1) {\n        yang_type_free(module->ctx, &leaflist->type);\n        goto error;\n    }\n\n    for (i = 0; i < leaflist->dflt_size; ++i) {\n        /* check for duplicity in case of configuration data,\n         * in case of status data duplicities are allowed */\n        if (leaflist->flags & LYS_CONFIG_W) {\n            for (j = i +1; j < leaflist->dflt_size; ++j) {\n                if (ly_strequal(leaflist->dflt[i], leaflist->dflt[j], 1)) {\n                    LOGVAL(module->ctx, LYE_INARG, LY_VLOG_LYS, leaflist, leaflist->dflt[i], \"default\");\n                    LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_LYS, leaflist, \"Duplicated default value \\\"%s\\\".\", leaflist->dflt[i]);\n                    goto error;\n                }\n            }\n        }\n        /* check default value (if not defined, there still could be some restrictions\n         * that need to be checked against a default value from a derived type) */\n        if (!(module->ctx->models.flags & LY_CTX_TRUSTED) &&\n                (unres_schema_add_node(module, unres, &leaflist->type, UNRES_TYPE_DFLT,\n                                       (struct lys_node *)(&leaflist->dflt[i])) == -1)) {\n            goto error;\n        }\n    }\n\n    if (leaflist->when && yang_check_ext_instance(module, &leaflist->when->ext, leaflist->when->ext_size, leaflist->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, leaflist->must, leaflist->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (leaflist->when || leaflist->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)leaflist)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, leaflist, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_list(struct lys_module *module, struct lys_node_list *list, struct lys_node **child,\n                int options, struct unres_schema *unres)\n{\n    struct lys_node *node;\n\n    if (yang_check_typedef(module, (struct lys_node *)list, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, list, LIST_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (list->flags & LYS_CONFIG_R) {\n        /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data\n         * ignore oredering MASK - 0x7F\n         */\n        list->flags &= 0x7F;\n    }\n    /* check - if list is configuration, key statement is mandatory\n     * (but only if we are not in a grouping or augment, then the check is deferred) */\n    for (node = (struct lys_node *)list; node && !(node->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); node = node->parent);\n    if (!node && (list->flags & LYS_CONFIG_W) && !list->keys) {\n        LOGVAL(module->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, list, \"key\", \"list\");\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)list, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (list->keys && yang_read_key(module, list, unres)) {\n        goto error;\n    }\n\n    if (yang_read_unique(module, list, unres)) {\n        goto error;\n    }\n\n    if (list->when && yang_check_ext_instance(module, &list->when->ext, list->when->ext_size, list->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, list->must, list->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (list->when || list->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)list)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, list, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_choice(struct lys_module *module, struct lys_node_choice *choice, struct lys_node **child,\n                  int options, struct unres_schema *unres)\n{\n    char *value;\n\n    if (yang_check_iffeatures(module, NULL, choice, CHOICE_KEYWORD, unres)) {\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)choice, *child, options, unres)) {\n        *child = NULL;\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (choice->dflt) {\n        value = (char *)choice->dflt;\n        choice->dflt = NULL;\n        if (unres_schema_add_str(module, unres, choice, UNRES_CHOICE_DFLT, value) == -1) {\n            free(value);\n            goto error;\n        }\n        free(value);\n    }\n\n    if (choice->when && yang_check_ext_instance(module, &choice->when->ext, choice->when->ext_size, choice->when, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && choice->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)choice)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, choice, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_rpc_action(struct lys_module *module, struct lys_node_rpc_action *rpc, struct lys_node **child,\n                      int options, struct unres_schema *unres)\n{\n    struct lys_node *node;\n\n    if (rpc->nodetype == LYS_ACTION) {\n        for (node = rpc->parent; node; node = lys_parent(node)) {\n            if ((node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF))\n                    || ((node->nodetype == LYS_LIST) && !((struct lys_node_list *)node)->keys)) {\n                LOGVAL(module->ctx, LYE_INPAR, LY_VLOG_LYS, rpc->parent, strnodetype(node->nodetype), \"action\");\n                goto error;\n            }\n        }\n    }\n    if (yang_check_typedef(module, (struct lys_node *)rpc, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, rpc, RPC_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)rpc, *child, options | LYS_PARSE_OPT_CFG_IGNORE, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_notif(struct lys_module *module, struct lys_node_notif *notif, struct lys_node **child,\n                 int options, struct unres_schema *unres)\n{\n    if (yang_check_typedef(module, (struct lys_node *)notif, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, notif, NOTIFICATION_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)notif, *child, options | LYS_PARSE_OPT_CFG_IGNORE, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (yang_check_must(module, notif->must, notif->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && notif->must_size) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)notif)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, notif, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_augment(struct lys_module *module, struct lys_node_augment *augment, int options, struct unres_schema *unres)\n{\n    struct lys_node *child;\n\n    child = augment->child;\n    augment->child = NULL;\n\n    if (yang_check_iffeatures(module, NULL, augment, AUGMENT_KEYWORD, unres)) {\n        yang_free_nodes(module->ctx, child);\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)augment, child, options, unres)) {\n        goto error;\n    }\n\n    if (yang_check_ext_instance(module, &augment->ext, augment->ext_size, augment, unres)) {\n        goto error;\n    }\n\n    if (augment->when && yang_check_ext_instance(module, &augment->when->ext, augment->when->ext_size, augment->when, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && augment->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)augment)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, augment, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_uses(struct lys_module *module, struct lys_node_uses *uses, int options, struct unres_schema *unres)\n{\n    uint i, size;\n\n    size = uses->augment_size;\n    uses->augment_size = 0;\n\n    if (yang_check_iffeatures(module, NULL, uses, USES_KEYWORD, unres)) {\n        goto error;\n    }\n\n    for (i = 0; i < uses->refine_size; ++i) {\n        if (yang_check_iffeatures(module, &uses->refine[i], uses, REFINE_KEYWORD, unres)) {\n            goto error;\n        }\n        if (yang_check_must(module, uses->refine[i].must, uses->refine[i].must_size, unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &uses->refine[i].ext, uses->refine[i].ext_size, &uses->refine[i], unres)) {\n            goto error;\n        }\n    }\n\n    for (i = 0; i < size; ++i) {\n        uses->augment_size++;\n        if (yang_check_augment(module, &uses->augment[i], options, unres)) {\n            goto error;\n        }\n    }\n\n    if (unres_schema_add_node(module, unres, uses, UNRES_USES, NULL) == -1) {\n        goto error;\n    }\n\n    if (uses->when && yang_check_ext_instance(module, &uses->when->ext, uses->when->ext_size, uses->when, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && uses->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)uses)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, uses, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    for (i = uses->augment_size; i < size; ++i) {\n        yang_free_augment(module->ctx, &uses->augment[i]);\n    }\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_anydata(struct lys_module *module, struct lys_node_anydata *anydata, struct lys_node **child,\n                   int options, struct unres_schema *unres)\n{\n    if (yang_check_iffeatures(module, NULL, anydata, ANYDATA_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)anydata, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (anydata->when && yang_check_ext_instance(module, &anydata->when->ext, anydata->when->ext_size, anydata->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, anydata->must, anydata->must_size, unres)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (anydata->when || anydata->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)anydata)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, anydata, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_nodes(struct lys_module *module, struct lys_node *parent, struct lys_node *nodes,\n                 int options, struct unres_schema *unres)\n{\n    struct lys_node *node = nodes, *sibling, *child;\n    int i;\n\n    while (node) {\n        sibling = node->next;\n        child = node->child;\n        node->next = NULL;\n        node->child = NULL;\n        node->parent = NULL;\n        node->prev = node;\n\n        if (lys_node_addchild(parent, module->type ? ((struct lys_submodule *)module)->belongsto: module, node, 0) ||\n            check_status_flag(node, parent)) {\n            lys_node_unlink(node);\n            yang_free_nodes(module->ctx, node);\n            goto error;\n        }\n        if (node->parent != parent) {\n            assert(node->parent->parent == parent);\n            assert((node->parent->nodetype == LYS_CASE) && (node->parent->flags & LYS_IMPLICIT));\n            store_config_flag(node->parent, options);\n        }\n        store_config_flag(node, options);\n        if (yang_check_ext_instance(module, &node->ext, node->ext_size, node, unres)) {\n            goto error;\n        }\n        for (i = 0; i < node->ext_size; ++i) {\n            if (node->ext[i]->flags & LYEXT_OPT_VALID) {\n                node->flags |= LYS_VALID_EXT;\n                break;\n            }\n        }\n\n        switch (node->nodetype) {\n        case LYS_GROUPING:\n            if (yang_check_typedef(module, node, unres)) {\n                goto error;\n            }\n            if (yang_check_iffeatures(module, NULL, node, GROUPING_KEYWORD, unres)) {\n                goto error;\n            }\n            if (yang_check_nodes(module, node, child, options | LYS_PARSE_OPT_INGRP, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        case LYS_CONTAINER:\n            if (yang_check_container(module, (struct lys_node_container *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_LEAF:\n            if (yang_check_leaf(module, (struct lys_node_leaf *)node, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        case LYS_LEAFLIST:\n            if (yang_check_leaflist(module, (struct lys_node_leaflist *)node, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        case LYS_LIST:\n            if (yang_check_list(module, (struct lys_node_list *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_CHOICE:\n            if (yang_check_choice(module, (struct lys_node_choice *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_CASE:\n            if (yang_check_iffeatures(module, NULL, node, CASE_KEYWORD, unres)) {\n                goto error;\n            }\n            if (yang_check_nodes(module, node, child, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            if (((struct lys_node_case *)node)->when) {\n                if (yang_check_ext_instance(module, &((struct lys_node_case *)node)->when->ext,\n                        ((struct lys_node_case *)node)->when->ext_size, ((struct lys_node_case *)node)->when, unres)) {\n                    goto error;\n                }\n                /* check XPath dependencies */\n                if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (options & LYS_PARSE_OPT_INGRP)) {\n                    if (lyxp_node_check_syntax(node)) {\n                        goto error;\n                    }\n                } else {\n                    if (unres_schema_add_node(module, unres, node, UNRES_XPATH, NULL) == -1) {\n                        goto error;\n                    }\n                }\n            }\n            break;\n        case LYS_ANYDATA:\n        case LYS_ANYXML:\n            if (yang_check_anydata(module, (struct lys_node_anydata *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_RPC:\n        case LYS_ACTION:\n            if (yang_check_rpc_action(module, (struct lys_node_rpc_action *)node, &child, options, unres)){\n                goto error;\n            }\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            if (yang_check_typedef(module, node, unres)) {\n                goto error;\n            }\n            if (yang_check_nodes(module, node, child, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            if (((struct lys_node_inout *)node)->must_size) {\n                if (yang_check_must(module, ((struct lys_node_inout *)node)->must, ((struct lys_node_inout *)node)->must_size, unres)) {\n                    goto error;\n                }\n                /* check XPath dependencies */\n                if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (options & LYS_PARSE_OPT_INGRP)) {\n                    if (lyxp_node_check_syntax(node)) {\n                        goto error;\n                    }\n                } else {\n                    if (unres_schema_add_node(module, unres, node, UNRES_XPATH, NULL) == -1) {\n                        goto error;\n                    }\n                }\n            }\n            break;\n        case LYS_NOTIF:\n            if (yang_check_notif(module, (struct lys_node_notif *)node, &child, options, unres)) {\n                goto error;\n            }\n            break;\n        case LYS_USES:\n            if (yang_check_uses(module, (struct lys_node_uses *)node, options, unres)) {\n                child = NULL;\n                goto error;\n            }\n            break;\n        default:\n            LOGINT(module->ctx);\n            goto error;\n        }\n        node = sibling;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    yang_free_nodes(module->ctx, sibling);\n    yang_free_nodes(module->ctx, child);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_deviate(struct lys_module *module, struct unres_schema *unres, struct lys_deviate *deviate,\n                   struct lys_node *dev_target, struct ly_set *dflt_check)\n{\n    struct lys_node_leaflist *llist;\n    struct lys_type *type;\n    struct lys_tpdf *tmp_parent;\n    int i, j;\n\n    if (yang_check_ext_instance(module, &deviate->ext, deviate->ext_size, deviate, unres)) {\n        goto error;\n    }\n    if (deviate->must_size && yang_check_deviate_must(module, unres, deviate, dev_target)) {\n        goto error;\n    }\n    if (deviate->unique && yang_check_deviate_unique(module, deviate, dev_target)) {\n        goto error;\n    }\n    if (deviate->dflt_size) {\n        if (yang_read_deviate_default(module, deviate, dev_target, dflt_check)) {\n            goto error;\n        }\n        if (dev_target->nodetype == LYS_LEAFLIST && deviate->mod == LY_DEVIATE_DEL) {\n            /* consolidate the final list in the target after removing items from it */\n            llist = (struct lys_node_leaflist *)dev_target;\n            for (i = j = 0; j < llist->dflt_size; j++) {\n                llist->dflt[i] = llist->dflt[j];\n                if (llist->dflt[i]) {\n                    i++;\n                }\n            }\n            llist->dflt_size = i + 1;\n        }\n    }\n\n    if (deviate->max_set && yang_read_deviate_minmax(deviate, dev_target, deviate->max, 1)) {\n        goto error;\n    }\n\n    if (deviate->min_set && yang_read_deviate_minmax(deviate, dev_target, deviate->min, 0)) {\n        goto error;\n    }\n\n    if (deviate->units && yang_read_deviate_units(module->ctx, deviate, dev_target)) {\n        goto error;\n    }\n\n    if ((deviate->flags & LYS_CONFIG_MASK)) {\n        /* add and replace are the same in this case */\n        /* remove current config value of the target ... */\n        dev_target->flags &= ~LYS_CONFIG_MASK;\n\n        /* ... and replace it with the value specified in deviation */\n        dev_target->flags |= deviate->flags & LYS_CONFIG_MASK;\n    }\n\n    if ((deviate->flags & LYS_MAND_MASK) && yang_check_deviate_mandatory(deviate, dev_target)) {\n        goto error;\n    }\n\n    if (deviate->type) {\n        /* check target node type */\n        if (dev_target->nodetype == LYS_LEAF) {\n            type = &((struct lys_node_leaf *)dev_target)->type;\n        } else if (dev_target->nodetype == LYS_LEAFLIST) {\n            type = &((struct lys_node_leaflist *)dev_target)->type;\n        } else {\n            LOGVAL(module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"type\");\n            LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"type\\\" property.\");\n            goto error;\n        }\n        /* remove type and initialize it */\n        tmp_parent = type->parent;\n        lys_type_free(module->ctx, type, NULL);\n        memcpy(type, deviate->type, sizeof *deviate->type);\n        free(deviate->type);\n        deviate->type = type;\n        deviate->type->parent = tmp_parent;\n        if (yang_fill_type(module, type, (struct yang_type *)type->der, tmp_parent, unres)) {\n            goto error;\n        }\n\n        if (unres_schema_add_node(module, unres, deviate->type, UNRES_TYPE_DER, dev_target) == -1) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (deviate->type) {\n        yang_type_free(module->ctx, deviate->type);\n        deviate->type = NULL;\n    }\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_deviation(struct lys_module *module, struct unres_schema *unres, struct lys_deviation *dev)\n{\n    int rc;\n    uint i;\n    struct lys_node *dev_target = NULL, *parent;\n    struct ly_set *dflt_check = ly_set_new(), *set;\n    unsigned int u;\n    const char *value, *target_name;\n    struct lys_node_leaflist *llist;\n    struct lys_node_leaf *leaf;\n    struct lys_node_inout *inout;\n    struct unres_schema tmp_unres;\n    struct lys_module *mod;\n\n    /* resolve target node */\n    rc = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n    if (rc == -1) {\n        LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, dev->target_name, \"deviation\");\n        ly_set_free(set);\n        i = 0;\n        goto free_type_error;\n    }\n    dev_target = set->set.s[0];\n    ly_set_free(set);\n\n    if (dev_target->module == lys_main_module(module)) {\n        LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, dev->target_name, \"deviation\");\n        LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Deviating own module is not allowed.\");\n        i = 0;\n        goto free_type_error;\n    }\n\n    if (!dflt_check) {\n        LOGMEM(module->ctx);\n        i = 0;\n        goto free_type_error;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        /* you cannot remove a key leaf */\n        if ((dev_target->nodetype == LYS_LEAF) && dev_target->parent && (dev_target->parent->nodetype == LYS_LIST)) {\n            for (i = 0; i < ((struct lys_node_list *)dev_target->parent)->keys_size; ++i) {\n                if (((struct lys_node_list *)dev_target->parent)->keys[i] == (struct lys_node_leaf *)dev_target) {\n                    LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, \"not-supported\", \"deviation\");\n                    LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"\\\"not-supported\\\" deviation cannot remove a list key.\");\n                    i = 0;\n                    goto free_type_error;\n                }\n            }\n        }\n        /* unlink and store the original node */\n        parent = dev_target->parent;\n        lys_node_unlink(dev_target);\n        if (parent) {\n            if (parent->nodetype & (LYS_AUGMENT | LYS_USES)) {\n                /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                 * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                 * path), so we need to remember the augment as an addition */\n                /* remember uses parent so we can reconnect to it */\n                dev_target->parent = parent;\n            } else if (parent->nodetype & (LYS_RPC | LYS_ACTION)) {\n                /* re-create implicit node */\n                inout = calloc(1, sizeof *inout);\n                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);\n\n                inout->nodetype = dev_target->nodetype;\n                inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? \"input\" : \"output\", 0);\n                inout->module = dev_target->module;\n                inout->flags = LYS_IMPLICIT;\n\n                /* insert it manually */\n                assert(parent->child && !parent->child->next\n                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));\n                parent->child->next = (struct lys_node *)inout;\n                inout->prev = parent->child;\n                parent->child->prev = (struct lys_node *)inout;\n                inout->parent = parent;\n            }\n        }\n        dev->orig_node = dev_target;\n    } else {\n        /* store a shallow copy of the original node */\n        memset(&tmp_unres, 0, sizeof tmp_unres);\n        dev->orig_node = lys_node_dup(dev_target->module, NULL, dev_target, &tmp_unres, 1);\n        /* just to be safe */\n        if (tmp_unres.count) {\n            LOGINT(module->ctx);\n            i = 0;\n            goto free_type_error;\n        }\n    }\n\n    if (yang_check_ext_instance(module, &dev->ext, dev->ext_size, dev, unres)) {\n        i = 0;\n        goto free_type_error;\n    }\n\n    for (i = 0; i < dev->deviate_size; ++i) {\n        if (yang_check_deviate(module, unres, &dev->deviate[i], dev_target, dflt_check)) {\n            yang_free_deviate(module->ctx, dev, i + 1);\n            dev->deviate_size = i + 1;\n            goto free_type_error;\n        }\n    }\n    /* now check whether default value, if any, matches the type */\n    for (u = 0; u < dflt_check->number; ++u) {\n        value = NULL;\n        rc = EXIT_SUCCESS;\n        if (dflt_check->set.s[u]->nodetype == LYS_LEAF) {\n            leaf = (struct lys_node_leaf *)dflt_check->set.s[u];\n            target_name = leaf->name;\n            value = leaf->dflt;\n            rc = unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&leaf->dflt));\n        } else { /* LYS_LEAFLIST */\n            llist = (struct lys_node_leaflist *)dflt_check->set.s[u];\n            target_name = llist->name;\n            for (i = 0; i < llist->dflt_size; i++) {\n                rc = unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                           (struct lys_node *)(&llist->dflt[i]));\n                if (rc == -1) {\n                    value = llist->dflt[i];\n                    break;\n                }\n            }\n        }\n        if (rc == -1) {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"default\");\n            LOGVAL(module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                \"The default value \\\"%s\\\" of the deviated node \\\"%s\\\"no longer matches its type.\",\n                target_name);\n            goto error;\n        }\n    }\n    ly_set_free(dflt_check);\n    dflt_check = NULL;\n\n    /* mark all the affected modules as deviated and implemented */\n    for (parent = dev_target; parent; parent = lys_parent(parent)) {\n        mod = lys_node_module(parent);\n        if (module != mod) {\n            mod->deviated = 1;            /* main module */\n            parent->module->deviated = 1; /* possible submodule */\n            if (!mod->implemented) {\n                mod->implemented = 1;\n                if (unres_schema_add_node(mod, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    goto error;\n                }\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nfree_type_error:\n    /* we need to free types because they are for now allocated dynamically (use i as it is now, is set correctly) */\n    for (; i < dev->deviate_size; ++i) {\n        if (dev->deviate[i].type) {\n            yang_type_free(module->ctx, dev->deviate[i].type);\n            free(dev->deviate[i].type);\n            dev->deviate[i].type = NULL;\n        }\n    }\nerror:\n    ly_set_free(dflt_check);\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_check_sub_module(struct lys_module *module, struct unres_schema *unres, struct lys_node *node)\n{\n    uint i, erase_identities = 1, erase_nodes = 1, aug_size, dev_size = 0;\n\n    aug_size = module->augment_size;\n    module->augment_size = 0;\n    dev_size = module->deviation_size;\n    module->deviation_size = 0;\n\n    if (yang_check_typedef(module, NULL, unres)) {\n        goto error;\n    }\n\n    if (yang_check_ext_instance(module, &module->ext, module->ext_size, module, unres)) {\n        goto error;\n    }\n\n    /* check extension in revision */\n    for (i = 0; i < module->rev_size; ++i) {\n        if (yang_check_ext_instance(module, &module->rev[i].ext, module->rev[i].ext_size, &module->rev[i], unres)) {\n            goto error;\n        }\n    }\n\n    /* check extension in definition of extension */\n    for (i = 0; i < module->extensions_size; ++i) {\n        if (yang_check_ext_instance(module, &module->extensions[i].ext, module->extensions[i].ext_size, &module->extensions[i], unres)) {\n            goto error;\n        }\n    }\n\n    /* check features */\n    for (i = 0; i < module->features_size; ++i) {\n        if (yang_check_iffeatures(module, NULL, &module->features[i], FEATURE_KEYWORD, unres)) {\n            goto error;\n        }\n        if (yang_check_ext_instance(module, &module->features[i].ext, module->features[i].ext_size, &module->features[i], unres)) {\n            goto error;\n        }\n\n        /* check for circular dependencies */\n        if (module->features[i].iffeature_size && (unres_schema_add_node(module, unres, &module->features[i], UNRES_FEATURE, NULL) == -1)) {\n            goto error;\n        }\n    }\n    erase_identities = 0;\n    if (yang_check_identities(module, unres)) {\n        goto error;\n    }\n    erase_nodes = 0;\n    if (yang_check_nodes(module, NULL, node, 0, unres)) {\n        goto error;\n    }\n\n    /* check deviation */\n    for (i = 0; i < dev_size; ++i) {\n        module->deviation_size++;\n        if (yang_check_deviation(module, unres, &module->deviation[i])) {\n            goto error;\n        }\n    }\n\n    /* check augments */\n    for (i = 0; i < aug_size; ++i) {\n        module->augment_size++;\n        if (yang_check_augment(module, &module->augment[i], 0, unres)) {\n            goto error;\n        }\n        if (unres_schema_add_node(module, unres, &module->augment[i], UNRES_AUGMENT, NULL) == -1) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    if (erase_identities) {\n        yang_free_ident_base(module->ident, 0, module->ident_size);\n    }\n    if (erase_nodes) {\n        yang_free_nodes(module->ctx, node);\n    }\n    for (i = module->augment_size; i < aug_size; ++i) {\n        yang_free_augment(module->ctx, &module->augment[i]);\n    }\n    for (i = module->deviation_size; i < dev_size; ++i) {\n        yang_free_deviate(module->ctx, &module->deviation[i], 0);\n        free(module->deviation[i].deviate);\n        lydict_remove(module->ctx, module->deviation[i].target_name);\n        lydict_remove(module->ctx, module->deviation[i].dsc);\n        lydict_remove(module->ctx, module->deviation[i].ref);\n    }\n    return EXIT_FAILURE;\n}\n\nint\nyang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n                         const char *parent_name, char **value, int parent_stmt, LY_STMT stmt)\n{\n    int c;\n    const char **str, ***p = NULL;\n    void *reallocated;\n    struct lyext_substmt *info;\n\n    c = 0;\n    if (stmt == LY_STMT_PREFIX && parent_stmt == LY_STMT_BELONGSTO) {\n        /* str contains no NULL value */\n        str = lys_ext_complex_get_substmt(LY_STMT_BELONGSTO, ext, &info);\n        if (info->cardinality < LY_STMT_CARD_SOME) {\n            str++;\n        } else {\n           /* get the index in the array to add new item */\n            p = (const char ***)str;\n            for (c = 0; p[0][c + 1]; c++);\n            str = p[1];\n        }\n        str[c] = lydict_insert_zc(module->ctx, *value);\n        *value = NULL;\n    }  else {\n        str = lys_ext_complex_get_substmt(stmt, ext, &info);\n        if (!str) {\n            LOGVAL(module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n        if (info->cardinality < LY_STMT_CARD_SOME && *str) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances, str is actually const char *** */\n            p = (const char ***)str;\n            if (!p[0]) {\n                /* allocate initial array */\n                p[0] = calloc(2, sizeof(const char *));\n                LY_CHECK_ERR_GOTO(!p[0], LOGMEM(module->ctx), error);\n                if (stmt == LY_STMT_BELONGSTO) {\n                    /* allocate another array for the belongs-to's prefixes */\n                    p[1] = calloc(2, sizeof(const char *));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                } else if (stmt == LY_STMT_ARGUMENT) {\n                    /* allocate another array for the yin element */\n                    ((uint8_t **)p)[1] = calloc(2, sizeof(uint8_t));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                    /* default value of yin element */\n                    ((uint8_t *)p[1])[0] = 2;\n                }\n            } else {\n                /* get the index in the array to add new item */\n                for (c = 0; p[0][c]; c++);\n            }\n            str = p[0];\n        }\n\n        str[c] = lydict_insert_zc(module->ctx, *value);\n        *value = NULL;\n\n        if (c) {\n            /* enlarge the array(s) */\n            reallocated = realloc(p[0], (c + 2) * sizeof(const char *));\n            if (!reallocated) {\n                LOGMEM(module->ctx);\n                lydict_remove(module->ctx, p[0][c]);\n                p[0][c] = NULL;\n                return EXIT_FAILURE;\n            }\n            p[0] = reallocated;\n            p[0][c + 1] = NULL;\n\n            if (stmt == LY_STMT_BELONGSTO) {\n                /* enlarge the second belongs-to's array with prefixes */\n                reallocated = realloc(p[1], (c + 2) * sizeof(const char *));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    lydict_remove(module->ctx, p[1][c]);\n                    p[1][c] = NULL;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                p[1][c + 1] = NULL;\n            } else if (stmt == LY_STMT_ARGUMENT) {\n                /* enlarge the second argument's array with yin element */\n                reallocated = realloc(p[1], (c + 2) * sizeof(uint8_t));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    ((uint8_t *)p[1])[c] = 0;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                ((uint8_t *)p[1])[c + 1] = 0;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    free(*value);\n    *value = NULL;\n    return EXIT_FAILURE;\n}\n\nstatic int\nyang_fill_ext_substm_index(struct lys_ext_instance_complex *ext, LY_STMT stmt, enum yytokentype keyword)\n{\n    int c = 0, decrement = 0;\n    const char **str, ***p = NULL;\n    struct lyext_substmt *info;\n\n\n    if (keyword == BELONGS_TO_KEYWORD || stmt == LY_STMT_BELONGSTO) {\n        stmt = LY_STMT_BELONGSTO;\n        decrement = -1;\n    } else if (keyword == ARGUMENT_KEYWORD || stmt == LY_STMT_ARGUMENT) {\n        stmt = LY_STMT_ARGUMENT;\n        decrement = -1;\n    }\n\n    str = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!str || info->cardinality < LY_STMT_CARD_SOME || !((const char ***)str)[0]) {\n        return 0;\n    } else {\n        p = (const char ***)str;\n        /* get the index in the array */\n        for (c = 0; p[0][c]; c++);\n        return c + decrement;\n    }\n}\n\nvoid **\nyang_getplace_for_extcomplex_struct(struct lys_ext_instance_complex *ext, int *index,\n                                    char *parent_name, char *node_name, LY_STMT stmt)\n{\n    struct ly_ctx *ctx = ext->module->ctx;\n    int c;\n    void **data, ***p = NULL;\n    void *reallocated;\n    struct lyext_substmt *info;\n\n    data = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!data) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return NULL;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME && *data) {\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return NULL;\n    }\n\n    c = 0;\n    if (info->cardinality >= LY_STMT_CARD_SOME) {\n        /* there can be multiple instances, so instead of pointer to array,\n         * we have in data pointer to pointer to array */\n        p = (void ***)data;\n        data = *p;\n        if (!data) {\n            /* allocate initial array */\n            *p = data = calloc(2, sizeof(void *));\n            LY_CHECK_ERR_RETURN(!data, LOGMEM(ctx), NULL);\n        } else {\n            for (c = 0; *data; data++, c++);\n        }\n    }\n\n    if (c) {\n        /* enlarge the array */\n        reallocated = realloc(*p, (c + 2) * sizeof(void *));\n        LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), NULL);\n        *p = reallocated;\n        data = *p;\n        data[c + 1] = NULL;\n    }\n\n    if (index) {\n        *index = c;\n        return data;\n    } else {\n        return &data[c];\n    }\n}\n\nint\nyang_fill_extcomplex_flags(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                           LY_STMT stmt, uint16_t value, uint16_t mask)\n{\n    uint16_t *data;\n    struct lyext_substmt *info;\n\n    data = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!data) {\n        LOGVAL(ext->module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME && (*data & mask)) {\n        LOGVAL(ext->module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n\n    *data |= value;\n    return EXIT_SUCCESS;\n}\n\nint\nyang_fill_extcomplex_uint8(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                           LY_STMT stmt, uint8_t value)\n{\n    struct ly_ctx *ctx = ext->module->ctx;\n    uint8_t *val, **pp = NULL, *reallocated;\n    struct lyext_substmt *info;\n    int i = 0;\n\n    val = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!val) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (stmt == LY_STMT_DIGITS) {\n        if (info->cardinality < LY_STMT_CARD_SOME && *val) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n            return EXIT_FAILURE;\n        }\n\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances */\n            pp = (uint8_t**)val;\n            if (!(*pp)) {\n                *pp = calloc(2, sizeof(uint8_t)); /* allocate initial array */\n                LY_CHECK_ERR_RETURN(!*pp, LOGMEM(ctx), EXIT_FAILURE);\n            } else {\n                for (i = 0; (*pp)[i]; i++);\n            }\n            val = &(*pp)[i];\n        }\n\n        /* stored value */\n        *val = value;\n\n        if (i) {\n            /* enlarge the array */\n            reallocated = realloc(*pp, (i + 2) * sizeof *val);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n            *pp = reallocated;\n            (*pp)[i + 1] = 0;\n        }\n    } else {\n        if (*val) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n            return EXIT_FAILURE;\n        }\n\n        if (stmt == LY_STMT_REQINSTANCE) {\n            *val = (value == 1) ? 1 : 2;\n        } else if (stmt == LY_STMT_MODIFIER) {\n            *val =  1;\n        } else {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_extcomplex_node(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                     struct lys_node *node, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    struct lys_node **snode, *siter;\n\n    snode = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!snode) {\n        LOGVAL(ext->module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME) {\n        LY_TREE_FOR(node, siter) {\n            if (stmt == lys_snode2stmt(siter->nodetype)) {\n                LOGVAL(ext->module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n                return EXIT_FAILURE;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nyang_fill_extcomplex_module(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext,\n                            char *parent_name, char **values, int implemented)\n{\n    int c, i;\n    struct lys_module **modules, ***p, *reallocated, **pp;\n    struct lyext_substmt *info;\n\n    if (!values) {\n        return EXIT_SUCCESS;\n    }\n    pp = modules = lys_ext_complex_get_substmt(LY_STMT_MODULE, ext, &info);\n    if (!modules) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"module\", parent_name);\n        return EXIT_FAILURE;\n    }\n\n    for (i = 0; values[i]; ++i) {\n        c = 0;\n        if (info->cardinality < LY_STMT_CARD_SOME && *modules) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"module\", parent_name);\n            return EXIT_FAILURE;\n        }\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances, so instead of pointer to array,\n             * we have in modules pointer to pointer to array */\n            p = (struct lys_module ***)pp;\n            modules = *p;\n            if (!modules) {\n                /* allocate initial array */\n                *p = modules = calloc(2, sizeof(struct lys_module *));\n                LY_CHECK_ERR_RETURN(!*p, LOGMEM(ctx), EXIT_FAILURE);\n            } else {\n                for (c = 0; *modules; modules++, c++);\n            }\n        }\n\n        if (c) {\n            /* enlarge the array */\n            reallocated = realloc(*p, (c + 2) * sizeof(struct lys_module *));\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n            *p = (struct lys_module **)reallocated;\n            modules = *p;\n            modules[c + 1] = NULL;\n        }\n\n        modules[c] = yang_read_module(ctx, values[i], 0, NULL, implemented);\n        if (!modules[c]) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n", "/**\n * @file parser_yang.h\n * @author Pavol Vican\n * @brief Parsers for libyang\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#ifndef LY_PARSER_YANG_H_\n#define LY_PARSER_YANG_H_\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libyang.h\"\n#include \"resolve.h\"\n#include \"common.h\"\n#include \"tree_schema.h\"\n#include \"context.h\"\n\n#define LYS_SYSTEMORDERED 0x40\n#define LYS_ORDERED_MASK 0xC0\n#define LYS_MIN_ELEMENTS 0x01\n#define LYS_MAX_ELEMENTS 0x02\n#define LYS_RPC_INPUT 0x01\n#define LYS_RPC_OUTPUT 0x02\n#define LYS_DATADEF 0x04\n#define LYS_TYPE_DEF 0x08\n#define LYS_CHOICE_DEFAULT 0x10\n#define LYS_NO_ERASE_IDENTITY 0x20\n#define LY_YANG_ARRAY_SIZE 8\n#define YANG_REMOVE_IMPORT 0x01\n#define YANG_EXIST_MODULE 0x02\n#define EXT_INSTANCE_SUBSTMT 0x04\n\nstruct type_node {\n    union {\n        struct lys_node_leaflist *ptr_leaflist;\n        struct lys_node_list *ptr_list;\n        struct lys_node_leaf *ptr_leaf;\n        struct lys_tpdf *ptr_tpdf;\n        struct lys_node_anydata *ptr_anydata;\n        struct lys_node_rpc_action *ptr_rpc;\n        struct lys_node_choice *ptr_choice;\n    };\n    uint flag;\n};\n\nstruct yang_parameter {\n    struct lys_module *module;\n    struct lys_submodule *submodule;\n    struct unres_schema *unres;\n    struct lys_node **node;\n    char **value;\n    void **data_node;\n    void **actual_node;\n    uint8_t flags;\n};\n\nstruct yang_ext_substmt {\n    char *ext_substmt;  /* pointer to string, which contains substmts without module statement */\n    char **ext_modules; /* array of char *, which contains module statements */\n};\n\nstruct yang_type {\n    char flags;       /**< this is used to distinguish lyxml_elem * from a YANG temporary parsing structure */\n    LY_DATA_TYPE base;\n    const char *name;\n    struct lys_type *type;\n};\n\n#include \"parser_yang_bis.h\"\n\nchar *yang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent);\n\nint yang_read_common(struct lys_module *module,char *value, enum yytokentype type);\n\nint yang_read_prefix(struct lys_module *module, struct lys_import *imp, char *value);\n\nint yang_check_version(struct lys_module *module, struct lys_submodule *submodule, char *value, int repeat);\n\nint yang_check_imports(struct lys_module *module, struct unres_schema *unres);\n\nint yang_read_description(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type);\n\nint yang_read_reference(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type);\n\nint yang_read_message(struct lys_module *module,struct lys_restr *save,char *value, char *what, int message);\n\nint yang_read_presence(struct lys_module *module, struct lys_node_container *cont, char *value);\n\nint yang_read_config(void *node, int value, enum yytokentype type);\n\nvoid *yang_read_when(struct lys_module *module, struct lys_node *node, enum yytokentype type, char *value);\n\n/**\n * @brief Allocate memory for node and add to the tree\n *\n * @param[in/out] node Pointer to the array.\n * @param[in] parent Pointer to the parent.\n * @param[in] root Pointer to the root of schema tree.\n * @param[in] value Name of node\n * @param[in] nodetype Type of node\n * @param[in] sizeof_struct Size of struct\n * @return Pointer to the node, NULL on error.\n*/\nvoid *yang_read_node(struct lys_module *module, struct lys_node *parent, struct lys_node **root,\n                     char *value, int nodetype, int sizeof_struct);\n\nint yang_read_default(struct lys_module *module, void *node, char *value, enum yytokentype type);\n\nint yang_read_units(struct lys_module *module, void *node, char *value, enum yytokentype type);\n\nint yang_read_key(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres);\n\nint yang_read_unique(struct lys_module *module, struct lys_node_list *list, struct unres_schema *unres);\n\nvoid *yang_read_type(struct ly_ctx *ctx, void *parent, char *value, enum yytokentype type);\n\nvoid *yang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance);\n\nint yang_check_type(struct lys_module *module, struct lys_node *parent, struct yang_type *typ, struct lys_type *type, int tpdftype, struct unres_schema *unres);\n\nint yang_fill_type(struct lys_module *module, struct lys_type *type, struct yang_type *stype,\n                   void *parent, struct unres_schema *unres);\n\nvoid yang_free_type_union(struct ly_ctx *ctx, struct lys_type *type);\n\nvoid yang_type_free(struct ly_ctx *ctx, struct lys_type *type);\n\nint yang_read_leafref_path(struct lys_module *module, struct yang_type *stype, char *value);\n\nint yang_read_require_instance(struct ly_ctx *ctx, struct yang_type *stype, int req);\n\nint yang_read_pattern(struct ly_ctx *ctx, struct lys_restr *pattern, void **precomp, char *value, char modifier);\n\nvoid *yang_read_range(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance);\n\nint yang_read_fraction(struct ly_ctx *ctx, struct yang_type *typ, uint32_t value);\n\nint yang_read_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, char *value);\n\nint yang_check_enum(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_enum *enm, int64_t *value, int assign);\n\nint yang_read_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, char *value);\n\nint yang_check_bit(struct ly_ctx *ctx, struct yang_type *typ, struct lys_type_bit *bit, int64_t *value, int assign);\n\nvoid *yang_read_typedef(struct lys_module *module, struct lys_node *parent, char *value);\n\nint yang_read_augment(struct lys_module *module, struct lys_node *parent, struct lys_node_augment *aug, char *value);\n\nvoid *yang_read_deviate(struct ly_ctx *ctx, struct lys_deviation *dev, LYS_DEVIATE_TYPE mod);\n\nvoid *yang_read_deviate_unsupported(struct ly_ctx *ctx, struct lys_deviation *dev);\n\nint yang_fill_unique(struct lys_module *module, struct lys_node_list *list, struct lys_unique *unique, char *value, struct unres_schema *unres);\n\nint yang_fill_iffeature(struct lys_module *module, struct lys_iffeature *iffeature, void *parent,\n                        char *value, struct unres_schema *unres, int parent_is_feature);\n\nvoid yang_free_ext_data(struct yang_ext_substmt *substmt);\n\nvoid *yang_read_ext(struct lys_module *module, void *actual, char *ext_name, char *ext_arg,\n                    enum yytokentype actual_type, enum yytokentype backup_type, int is_ext_instance);\n\nint yang_check_ext_instance(struct lys_module *module, struct lys_ext_instance ***ext, uint size,\n                            void *parent, struct unres_schema *unres);\n\nint yang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n                             const char *parent_name, char **value, int parent_stmt, LY_STMT stmt);\n\nvoid **yang_getplace_for_extcomplex_struct(struct lys_ext_instance_complex *ext, int *index,\n                                    char *parent_name, char *node_name, LY_STMT stmt);\n\nint yang_extcomplex_node(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                         struct lys_node *node, LY_STMT stmt);\n\nint yang_fill_extcomplex_flags(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                               LY_STMT stmt, uint16_t value, uint16_t mask);\n\nint yang_fill_extcomplex_uint8(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                               LY_STMT stmt, uint8_t value);\n\nint yang_parse_ext_substatement(struct lys_module *module, struct unres_schema *unres, const char *data,\n                                char *ext_name, struct lys_ext_instance_complex *ext);\n\nint yang_fill_extcomplex_module(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext,\n                                char *parent_name, char **values, int implemented);\n\n\n/* **\n * @brief Parse YANG from in-memory string\n *\n * yang parser expected at the end of the input string 2 zero byte\n *\n * @param[in] module Pointer to the libyang module.\n * @param[in] submodule Pointer to the libyang submodule.\n * @param[in] unres Pointer to a unres_schema\n * @param[in] data Pointer to a NULL-terminated string containing YANG data to parse.\n * @param[in] size_data Size of input string\n * @param[in/out] node Pointer to node\n * @return 0 on success, -1 on error, 1 on module is already in context.\n */\nint yang_parse_mem(struct lys_module *module, struct lys_submodule *submodule, struct unres_schema *unres,\n                   const char *data, unsigned int size_data, struct lys_node **node);\n\nstruct lys_module *yang_read_module(struct ly_ctx *ctx, const char* data, unsigned int size, const char *revision, int implement);\n\nstruct lys_submodule *yang_read_submodule(struct lys_module *module, const char *data, unsigned int size, struct unres_schema *unres);\n\n#endif /* LY_PARSER_YANG_H_ */\n", "/* A Bison parser, made by GNU Bison 3.2.4.  */\n\n/* Bison implementation for Yacc-like parsers in C\n\n   Copyright (C) 1984, 1989-1990, 2000-2015, 2018 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n/* As a special exception, you may create a larger work that contains\n   part or all of the Bison parser skeleton and distribute that work\n   under terms of your choice, so long as that work isn't itself a\n   parser generator using the skeleton or a modified version thereof\n   as a parser skeleton.  Alternatively, if you modify or redistribute\n   the parser skeleton itself, you may (at your option) remove this\n   special exception, which will cause the skeleton and the resulting\n   Bison output files to be licensed under the GNU General Public\n   License without this special exception.\n\n   This special exception was added by the Free Software Foundation in\n   version 2.2 of Bison.  */\n\n/* C LALR(1) parser skeleton written by Richard Stallman, by\n   simplifying the original so-called \"semantic\" parser.  */\n\n/* All symbols defined below should begin with yy or YY, to avoid\n   infringing on user name space.  This should be done even for local\n   variables, as they might otherwise be expanded by user macros.\n   There are some unavoidable exceptions within include files to\n   define necessary library symbols; they are noted \"INFRINGES ON\n   USER NAME SPACE\" below.  */\n\n/* Undocumented macros, especially those whose name start with YY_,\n   are private implementation details.  Do not rely on them.  */\n\n/* Identify Bison output.  */\n#define YYBISON 1\n\n/* Bison version.  */\n#define YYBISON_VERSION \"3.2.4\"\n\n/* Skeleton name.  */\n#define YYSKELETON_NAME \"yacc.c\"\n\n/* Pure parsers.  */\n#define YYPURE 2\n\n/* Push parsers.  */\n#define YYPUSH 0\n\n/* Pull parsers.  */\n#define YYPULL 1\n\n\n\n\n/* First part of user prologue.  */\n\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"libyang.h\"\n#include \"common.h\"\n#include \"context.h\"\n#include \"resolve.h\"\n#include \"parser_yang.h\"\n#include \"parser_yang_lex.h\"\n#include \"parser.h\"\n\n#define YANG_ADDELEM(current_ptr, size, array_name)                                      \\\n    if ((size) == LY_ARRAY_MAX(size)) {                                                  \\\n         LOGERR(trg->ctx, LY_EINT, \"Reached limit (%\"PRIu64\") for storing %s.\", LY_ARRAY_MAX(size), array_name); \\\n         free(s);                                                                        \\\n         YYABORT;                                                                        \\\n    } else if (!((size) % LY_YANG_ARRAY_SIZE)) {                                         \\\n        void *tmp;                                                                       \\\n                                                                                         \\\n        tmp = realloc((current_ptr), (sizeof *(current_ptr)) * ((size) + LY_YANG_ARRAY_SIZE)); \\\n        if (!tmp) {                                                                      \\\n            LOGMEM(trg->ctx);                                                            \\\n            free(s);                                                                     \\\n            YYABORT;                                                                     \\\n        }                                                                                \\\n        memset(tmp + (sizeof *(current_ptr)) * (size), 0, (sizeof *(current_ptr)) * LY_YANG_ARRAY_SIZE); \\\n        (current_ptr) = tmp;                                                             \\\n    }                                                                                    \\\n    actual = &(current_ptr)[(size)++];                                                   \\\n\nvoid yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...);\n/* pointer on the current parsed element 'actual' */\n\n\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n/* Enabling verbose error messages.  */\n#ifdef YYERROR_VERBOSE\n# undef YYERROR_VERBOSE\n# define YYERROR_VERBOSE 1\n#else\n# define YYERROR_VERBOSE 0\n#endif\n\n/* In a future release of Bison, this section will be replaced\n   by #include \"parser_yang_bis.h\".  */\n#ifndef YY_YY_PARSER_YANG_BIS_H_INCLUDED\n# define YY_YY_PARSER_YANG_BIS_H_INCLUDED\n/* Debug traces.  */\n#ifndef YYDEBUG\n# define YYDEBUG 0\n#endif\n#if YYDEBUG\nextern int yydebug;\n#endif\n\n/* Token type.  */\n#ifndef YYTOKENTYPE\n# define YYTOKENTYPE\n  enum yytokentype\n  {\n    UNION_KEYWORD = 258,\n    ANYXML_KEYWORD = 259,\n    WHITESPACE = 260,\n    ERROR = 261,\n    EOL = 262,\n    STRING = 263,\n    STRINGS = 264,\n    IDENTIFIER = 265,\n    IDENTIFIERPREFIX = 266,\n    REVISION_DATE = 267,\n    TAB = 268,\n    DOUBLEDOT = 269,\n    URI = 270,\n    INTEGER = 271,\n    NON_NEGATIVE_INTEGER = 272,\n    ZERO = 273,\n    DECIMAL = 274,\n    ARGUMENT_KEYWORD = 275,\n    AUGMENT_KEYWORD = 276,\n    BASE_KEYWORD = 277,\n    BELONGS_TO_KEYWORD = 278,\n    BIT_KEYWORD = 279,\n    CASE_KEYWORD = 280,\n    CHOICE_KEYWORD = 281,\n    CONFIG_KEYWORD = 282,\n    CONTACT_KEYWORD = 283,\n    CONTAINER_KEYWORD = 284,\n    DEFAULT_KEYWORD = 285,\n    DESCRIPTION_KEYWORD = 286,\n    ENUM_KEYWORD = 287,\n    ERROR_APP_TAG_KEYWORD = 288,\n    ERROR_MESSAGE_KEYWORD = 289,\n    EXTENSION_KEYWORD = 290,\n    DEVIATION_KEYWORD = 291,\n    DEVIATE_KEYWORD = 292,\n    FEATURE_KEYWORD = 293,\n    FRACTION_DIGITS_KEYWORD = 294,\n    GROUPING_KEYWORD = 295,\n    IDENTITY_KEYWORD = 296,\n    IF_FEATURE_KEYWORD = 297,\n    IMPORT_KEYWORD = 298,\n    INCLUDE_KEYWORD = 299,\n    INPUT_KEYWORD = 300,\n    KEY_KEYWORD = 301,\n    LEAF_KEYWORD = 302,\n    LEAF_LIST_KEYWORD = 303,\n    LENGTH_KEYWORD = 304,\n    LIST_KEYWORD = 305,\n    MANDATORY_KEYWORD = 306,\n    MAX_ELEMENTS_KEYWORD = 307,\n    MIN_ELEMENTS_KEYWORD = 308,\n    MODULE_KEYWORD = 309,\n    MUST_KEYWORD = 310,\n    NAMESPACE_KEYWORD = 311,\n    NOTIFICATION_KEYWORD = 312,\n    ORDERED_BY_KEYWORD = 313,\n    ORGANIZATION_KEYWORD = 314,\n    OUTPUT_KEYWORD = 315,\n    PATH_KEYWORD = 316,\n    PATTERN_KEYWORD = 317,\n    POSITION_KEYWORD = 318,\n    PREFIX_KEYWORD = 319,\n    PRESENCE_KEYWORD = 320,\n    RANGE_KEYWORD = 321,\n    REFERENCE_KEYWORD = 322,\n    REFINE_KEYWORD = 323,\n    REQUIRE_INSTANCE_KEYWORD = 324,\n    REVISION_KEYWORD = 325,\n    REVISION_DATE_KEYWORD = 326,\n    RPC_KEYWORD = 327,\n    STATUS_KEYWORD = 328,\n    SUBMODULE_KEYWORD = 329,\n    TYPE_KEYWORD = 330,\n    TYPEDEF_KEYWORD = 331,\n    UNIQUE_KEYWORD = 332,\n    UNITS_KEYWORD = 333,\n    USES_KEYWORD = 334,\n    VALUE_KEYWORD = 335,\n    WHEN_KEYWORD = 336,\n    YANG_VERSION_KEYWORD = 337,\n    YIN_ELEMENT_KEYWORD = 338,\n    ADD_KEYWORD = 339,\n    CURRENT_KEYWORD = 340,\n    DELETE_KEYWORD = 341,\n    DEPRECATED_KEYWORD = 342,\n    FALSE_KEYWORD = 343,\n    NOT_SUPPORTED_KEYWORD = 344,\n    OBSOLETE_KEYWORD = 345,\n    REPLACE_KEYWORD = 346,\n    SYSTEM_KEYWORD = 347,\n    TRUE_KEYWORD = 348,\n    UNBOUNDED_KEYWORD = 349,\n    USER_KEYWORD = 350,\n    ACTION_KEYWORD = 351,\n    MODIFIER_KEYWORD = 352,\n    ANYDATA_KEYWORD = 353,\n    NODE = 354,\n    NODE_PRINT = 355,\n    EXTENSION_INSTANCE = 356,\n    SUBMODULE_EXT_KEYWORD = 357\n  };\n#endif\n\n/* Value type.  */\n#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED\n\nunion YYSTYPE\n{\n\n\n  int32_t i;\n  uint32_t uint;\n  char *str;\n  char **p_str;\n  void *v;\n  char ch;\n  struct yang_type *type;\n  struct lys_deviation *dev;\n  struct lys_deviate *deviate;\n  union {\n    uint32_t index;\n    struct lys_node_container *container;\n    struct lys_node_anydata *anydata;\n    struct type_node node;\n    struct lys_node_case *cs;\n    struct lys_node_grp *grouping;\n    struct lys_refine *refine;\n    struct lys_node_notif *notif;\n    struct lys_node_uses *uses;\n    struct lys_node_inout *inout;\n    struct lys_node_augment *augment;\n  } nodes;\n  enum yytokentype token;\n  struct {\n    void *actual;\n    enum yytokentype token;\n  } backup_token;\n  struct {\n    struct lys_revision **revision;\n    int index;\n  } revisions;\n\n\n};\n\ntypedef union YYSTYPE YYSTYPE;\n# define YYSTYPE_IS_TRIVIAL 1\n# define YYSTYPE_IS_DECLARED 1\n#endif\n\n/* Location type.  */\n#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED\ntypedef struct YYLTYPE YYLTYPE;\nstruct YYLTYPE\n{\n  int first_line;\n  int first_column;\n  int last_line;\n  int last_column;\n};\n# define YYLTYPE_IS_DECLARED 1\n# define YYLTYPE_IS_TRIVIAL 1\n#endif\n\n\n\nint yyparse (void *scanner, struct yang_parameter *param);\n\n#endif /* !YY_YY_PARSER_YANG_BIS_H_INCLUDED  */\n\n\n\n#ifdef short\n# undef short\n#endif\n\n#ifdef YYTYPE_UINT8\ntypedef YYTYPE_UINT8 yytype_uint8;\n#else\ntypedef unsigned char yytype_uint8;\n#endif\n\n#ifdef YYTYPE_INT8\ntypedef YYTYPE_INT8 yytype_int8;\n#else\ntypedef signed char yytype_int8;\n#endif\n\n#ifdef YYTYPE_UINT16\ntypedef YYTYPE_UINT16 yytype_uint16;\n#else\ntypedef unsigned short yytype_uint16;\n#endif\n\n#ifdef YYTYPE_INT16\ntypedef YYTYPE_INT16 yytype_int16;\n#else\ntypedef short yytype_int16;\n#endif\n\n#ifndef YYSIZE_T\n# ifdef __SIZE_TYPE__\n#  define YYSIZE_T __SIZE_TYPE__\n# elif defined size_t\n#  define YYSIZE_T size_t\n# elif ! defined YYSIZE_T\n#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */\n#  define YYSIZE_T size_t\n# else\n#  define YYSIZE_T unsigned\n# endif\n#endif\n\n#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)\n\n#ifndef YY_\n# if defined YYENABLE_NLS && YYENABLE_NLS\n#  if ENABLE_NLS\n#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */\n#   define YY_(Msgid) dgettext (\"bison-runtime\", Msgid)\n#  endif\n# endif\n# ifndef YY_\n#  define YY_(Msgid) Msgid\n# endif\n#endif\n\n#ifndef YY_ATTRIBUTE\n# if (defined __GNUC__                                               \\\n      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \\\n     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C\n#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)\n# else\n#  define YY_ATTRIBUTE(Spec) /* empty */\n# endif\n#endif\n\n#ifndef YY_ATTRIBUTE_PURE\n# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))\n#endif\n\n#ifndef YY_ATTRIBUTE_UNUSED\n# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))\n#endif\n\n/* Suppress unused-variable warnings by \"using\" E.  */\n#if ! defined lint || defined __GNUC__\n# define YYUSE(E) ((void) (E))\n#else\n# define YYUSE(E) /* empty */\n#endif\n\n#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__\n/* Suppress an incorrect diagnostic about yylval being uninitialized.  */\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \\\n    _Pragma (\"GCC diagnostic push\") \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")\\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wmaybe-uninitialized\\\"\")\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END \\\n    _Pragma (\"GCC diagnostic pop\")\n#else\n# define YY_INITIAL_VALUE(Value) Value\n#endif\n#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END\n#endif\n#ifndef YY_INITIAL_VALUE\n# define YY_INITIAL_VALUE(Value) /* Nothing. */\n#endif\n\n\n#if ! defined yyoverflow || YYERROR_VERBOSE\n\n/* The parser invokes alloca or malloc; define the necessary symbols.  */\n\n# ifdef YYSTACK_USE_ALLOCA\n#  if YYSTACK_USE_ALLOCA\n#   ifdef __GNUC__\n#    define YYSTACK_ALLOC __builtin_alloca\n#   elif defined __BUILTIN_VA_ARG_INCR\n#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */\n#   elif defined _AIX\n#    define YYSTACK_ALLOC __alloca\n#   elif defined _MSC_VER\n#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */\n#    define alloca _alloca\n#   else\n#    define YYSTACK_ALLOC alloca\n#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS\n#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */\n      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */\n#     ifndef EXIT_SUCCESS\n#      define EXIT_SUCCESS 0\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n\n# ifdef YYSTACK_ALLOC\n   /* Pacify GCC's 'empty if-body' warning.  */\n#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n    /* The OS might guarantee only one guard page at the bottom of the stack,\n       and a page size can be as small as 4096 bytes.  So we cannot safely\n       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number\n       to allow for a few compiler-allocated temporary stack slots.  */\n#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */\n#  endif\n# else\n#  define YYSTACK_ALLOC YYMALLOC\n#  define YYSTACK_FREE YYFREE\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM\n#  endif\n#  if (defined __cplusplus && ! defined EXIT_SUCCESS \\\n       && ! ((defined YYMALLOC || defined malloc) \\\n             && (defined YYFREE || defined free)))\n#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */\n#   ifndef EXIT_SUCCESS\n#    define EXIT_SUCCESS 0\n#   endif\n#  endif\n#  ifndef YYMALLOC\n#   define YYMALLOC malloc\n#   if ! defined malloc && ! defined EXIT_SUCCESS\nvoid *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */\n#   endif\n#  endif\n#  ifndef YYFREE\n#   define YYFREE free\n#   if ! defined free && ! defined EXIT_SUCCESS\nvoid free (void *); /* INFRINGES ON USER NAME SPACE */\n#   endif\n#  endif\n# endif\n#endif /* ! defined yyoverflow || YYERROR_VERBOSE */\n\n\n#if (! defined yyoverflow \\\n     && (! defined __cplusplus \\\n         || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \\\n             && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))\n\n/* A type that is properly aligned for any stack member.  */\nunion yyalloc\n{\n  yytype_int16 yyss_alloc;\n  YYSTYPE yyvs_alloc;\n  YYLTYPE yyls_alloc;\n};\n\n/* The size of the maximum gap between one aligned stack and the next.  */\n# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)\n\n/* The size of an array large to enough to hold all stacks, each with\n   N elements.  */\n# define YYSTACK_BYTES(N) \\\n     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \\\n      + 2 * YYSTACK_GAP_MAXIMUM)\n\n# define YYCOPY_NEEDED 1\n\n/* Relocate STACK from its old location to the new one.  The\n   local variables YYSIZE and YYSTACKSIZE give the old and new number of\n   elements in the stack, and YYPTR gives the new location of the\n   stack.  Advance YYPTR to a properly aligned location for the next\n   stack.  */\n# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \\\n    do                                                                  \\\n      {                                                                 \\\n        YYSIZE_T yynewbytes;                                            \\\n        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \\\n        Stack = &yyptr->Stack_alloc;                                    \\\n        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \\\n        yyptr += yynewbytes / sizeof (*yyptr);                          \\\n      }                                                                 \\\n    while (0)\n\n#endif\n\n#if defined YYCOPY_NEEDED && YYCOPY_NEEDED\n/* Copy COUNT objects from SRC to DST.  The source and destination do\n   not overlap.  */\n# ifndef YYCOPY\n#  if defined __GNUC__ && 1 < __GNUC__\n#   define YYCOPY(Dst, Src, Count) \\\n      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))\n#  else\n#   define YYCOPY(Dst, Src, Count)              \\\n      do                                        \\\n        {                                       \\\n          YYSIZE_T yyi;                         \\\n          for (yyi = 0; yyi < (Count); yyi++)   \\\n            (Dst)[yyi] = (Src)[yyi];            \\\n        }                                       \\\n      while (0)\n#  endif\n# endif\n#endif /* !YYCOPY_NEEDED */\n\n/* YYFINAL -- State number of the termination state.  */\n#define YYFINAL  6\n/* YYLAST -- Last index in YYTABLE.  */\n#define YYLAST   3466\n\n/* YYNTOKENS -- Number of terminals.  */\n#define YYNTOKENS  113\n/* YYNNTS -- Number of nonterminals.  */\n#define YYNNTS  329\n/* YYNRULES -- Number of rules.  */\n#define YYNRULES  827\n/* YYNSTATES -- Number of states.  */\n#define YYNSTATES  1318\n\n/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned\n   by yylex, with out-of-bounds checking.  */\n#define YYUNDEFTOK  2\n#define YYMAXUTOK   357\n\n#define YYTRANSLATE(YYX)                                                \\\n  ((unsigned) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)\n\n/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM\n   as returned by yylex, without out-of-bounds checking.  */\nstatic const yytype_uint8 yytranslate[] =\n{\n       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n     111,   112,     2,   103,     2,     2,     2,   107,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,   106,\n       2,   110,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,   108,     2,   109,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,   104,     2,   105,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,\n       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,\n      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,\n      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,\n      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,\n      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,\n      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,\n      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,\n      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,\n      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,\n      95,    96,    97,    98,    99,   100,   101,   102\n};\n\n#if YYDEBUG\n  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */\nstatic const yytype_uint16 yyrline[] =\n{\n       0,   338,   338,   339,   340,   342,   365,   368,   370,   369,\n     393,   404,   414,   424,   425,   431,   436,   442,   453,   463,\n     476,   477,   483,   485,   489,   491,   495,   497,   498,   499,\n     501,   509,   517,   518,   523,   534,   545,   556,   564,   569,\n     570,   574,   575,   586,   597,   608,   612,   614,   637,   654,\n     658,   660,   661,   666,   671,   676,   682,   686,   688,   692,\n     694,   698,   700,   704,   706,   719,   730,   731,   743,   747,\n     748,   752,   753,   758,   765,   765,   776,   782,   830,   849,\n     852,   853,   854,   855,   856,   857,   858,   859,   860,   861,\n     864,   879,   886,   887,   891,   892,   893,   899,   904,   910,\n     928,   930,   931,   935,   940,   941,   963,   964,   965,   978,\n     983,   985,   986,   987,   988,  1003,  1017,  1022,  1023,  1038,\n    1039,  1040,  1046,  1051,  1057,  1114,  1119,  1120,  1122,  1138,\n    1143,  1144,  1169,  1170,  1184,  1185,  1191,  1196,  1202,  1206,\n    1208,  1261,  1272,  1275,  1278,  1283,  1288,  1294,  1299,  1305,\n    1310,  1319,  1320,  1324,  1371,  1372,  1374,  1375,  1379,  1385,\n    1398,  1399,  1400,  1404,  1405,  1407,  1411,  1429,  1434,  1436,\n    1437,  1453,  1458,  1467,  1468,  1472,  1488,  1493,  1498,  1503,\n    1509,  1513,  1529,  1544,  1545,  1549,  1550,  1560,  1565,  1570,\n    1575,  1581,  1585,  1596,  1608,  1609,  1612,  1620,  1631,  1632,\n    1647,  1648,  1649,  1661,  1667,  1672,  1678,  1683,  1685,  1686,\n    1701,  1706,  1707,  1712,  1716,  1718,  1723,  1725,  1726,  1727,\n    1740,  1752,  1753,  1755,  1763,  1775,  1776,  1791,  1792,  1793,\n    1805,  1811,  1816,  1822,  1827,  1829,  1830,  1846,  1850,  1852,\n    1856,  1858,  1862,  1864,  1868,  1870,  1880,  1887,  1888,  1892,\n    1893,  1899,  1904,  1909,  1910,  1911,  1912,  1913,  1919,  1920,\n    1921,  1922,  1923,  1924,  1925,  1926,  1929,  1939,  1946,  1947,\n    1970,  1971,  1972,  1973,  1974,  1979,  1985,  1991,  1996,  2001,\n    2002,  2003,  2008,  2009,  2011,  2051,  2061,  2064,  2065,  2066,\n    2069,  2074,  2075,  2080,  2086,  2092,  2098,  2103,  2109,  2119,\n    2174,  2177,  2178,  2179,  2182,  2193,  2198,  2199,  2205,  2218,\n    2231,  2241,  2247,  2252,  2258,  2268,  2315,  2318,  2319,  2320,\n    2321,  2330,  2336,  2342,  2355,  2368,  2378,  2384,  2389,  2394,\n    2395,  2396,  2397,  2402,  2404,  2414,  2421,  2422,  2442,  2445,\n    2446,  2447,  2457,  2464,  2471,  2478,  2484,  2490,  2492,  2493,\n    2495,  2496,  2497,  2498,  2499,  2500,  2501,  2507,  2517,  2524,\n    2525,  2539,  2540,  2541,  2542,  2548,  2553,  2558,  2561,  2571,\n    2578,  2588,  2595,  2596,  2619,  2622,  2623,  2624,  2625,  2632,\n    2639,  2646,  2651,  2657,  2667,  2674,  2675,  2707,  2708,  2709,\n    2710,  2716,  2721,  2726,  2727,  2729,  2730,  2732,  2745,  2750,\n    2751,  2783,  2786,  2800,  2816,  2838,  2889,  2908,  2927,  2948,\n    2969,  2974,  2980,  2981,  2984,  2999,  3008,  3009,  3011,  3022,\n    3031,  3032,  3033,  3034,  3040,  3045,  3050,  3051,  3052,  3057,\n    3059,  3074,  3081,  3091,  3098,  3099,  3123,  3126,  3127,  3133,\n    3138,  3143,  3144,  3145,  3152,  3160,  3175,  3205,  3206,  3207,\n    3208,  3209,  3211,  3226,  3256,  3265,  3272,  3273,  3305,  3306,\n    3307,  3308,  3314,  3319,  3324,  3325,  3326,  3328,  3340,  3360,\n    3361,  3367,  3373,  3375,  3376,  3378,  3379,  3382,  3390,  3395,\n    3396,  3398,  3399,  3400,  3402,  3410,  3415,  3416,  3448,  3449,\n    3455,  3456,  3462,  3468,  3475,  3482,  3490,  3499,  3507,  3512,\n    3513,  3545,  3546,  3552,  3553,  3559,  3566,  3574,  3579,  3580,\n    3594,  3595,  3596,  3602,  3608,  3615,  3622,  3630,  3639,  3648,\n    3653,  3654,  3658,  3659,  3664,  3670,  3675,  3677,  3678,  3679,\n    3692,  3697,  3699,  3700,  3701,  3714,  3718,  3720,  3725,  3727,\n    3728,  3748,  3753,  3755,  3756,  3757,  3777,  3782,  3784,  3785,\n    3786,  3798,  3867,  3872,  3873,  3877,  3881,  3883,  3884,  3886,\n    3890,  3892,  3892,  3899,  3902,  3911,  3930,  3932,  3933,  3936,\n    3936,  3953,  3953,  3960,  3960,  3967,  3970,  3972,  3974,  3975,\n    3977,  3979,  3981,  3982,  3984,  3986,  3987,  3989,  3990,  3992,\n    3994,  3997,  4000,  4002,  4003,  4005,  4006,  4008,  4010,  4021,\n    4022,  4025,  4026,  4038,  4039,  4041,  4042,  4044,  4045,  4051,\n    4052,  4055,  4056,  4057,  4081,  4082,  4085,  4091,  4095,  4100,\n    4101,  4102,  4105,  4110,  4120,  4122,  4123,  4125,  4126,  4128,\n    4129,  4130,  4132,  4133,  4135,  4136,  4138,  4139,  4143,  4144,\n    4171,  4209,  4210,  4212,  4214,  4216,  4217,  4219,  4220,  4222,\n    4223,  4226,  4227,  4230,  4232,  4233,  4236,  4236,  4243,  4245,\n    4246,  4247,  4248,  4249,  4250,  4251,  4253,  4254,  4255,  4257,\n    4258,  4259,  4260,  4261,  4262,  4263,  4264,  4265,  4266,  4269,\n    4270,  4271,  4272,  4273,  4274,  4275,  4276,  4277,  4278,  4279,\n    4280,  4281,  4282,  4283,  4284,  4285,  4286,  4287,  4288,  4289,\n    4290,  4291,  4292,  4293,  4294,  4295,  4296,  4297,  4298,  4299,\n    4300,  4301,  4302,  4303,  4304,  4305,  4306,  4307,  4308,  4309,\n    4310,  4311,  4312,  4313,  4314,  4315,  4316,  4317,  4318,  4319,\n    4320,  4321,  4322,  4323,  4324,  4325,  4326,  4327,  4328,  4329,\n    4330,  4331,  4332,  4333,  4334,  4335,  4336,  4337,  4338,  4340,\n    4347,  4354,  4374,  4392,  4408,  4435,  4442,  4460,  4500,  4502,\n    4503,  4504,  4505,  4506,  4507,  4508,  4509,  4510,  4511,  4512,\n    4513,  4514,  4516,  4517,  4518,  4519,  4520,  4521,  4522,  4523,\n    4524,  4525,  4526,  4527,  4528,  4529,  4531,  4532,  4533,  4534,\n    4536,  4544,  4545,  4550,  4555,  4560,  4565,  4570,  4575,  4580,\n    4585,  4590,  4595,  4600,  4605,  4610,  4615,  4620,  4634,  4654,\n    4659,  4664,  4669,  4682,  4687,  4691,  4701,  4716,  4731,  4746,\n    4761,  4781,  4796,  4797,  4803,  4810,  4825,  4828\n};\n#endif\n\n#if YYDEBUG || YYERROR_VERBOSE || 0\n/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.\n   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */\nstatic const char *const yytname[] =\n{\n  \"$end\", \"error\", \"$undefined\", \"UNION_KEYWORD\", \"ANYXML_KEYWORD\",\n  \"WHITESPACE\", \"ERROR\", \"EOL\", \"STRING\", \"STRINGS\", \"IDENTIFIER\",\n  \"IDENTIFIERPREFIX\", \"REVISION_DATE\", \"TAB\", \"DOUBLEDOT\", \"URI\",\n  \"INTEGER\", \"NON_NEGATIVE_INTEGER\", \"ZERO\", \"DECIMAL\", \"ARGUMENT_KEYWORD\",\n  \"AUGMENT_KEYWORD\", \"BASE_KEYWORD\", \"BELONGS_TO_KEYWORD\", \"BIT_KEYWORD\",\n  \"CASE_KEYWORD\", \"CHOICE_KEYWORD\", \"CONFIG_KEYWORD\", \"CONTACT_KEYWORD\",\n  \"CONTAINER_KEYWORD\", \"DEFAULT_KEYWORD\", \"DESCRIPTION_KEYWORD\",\n  \"ENUM_KEYWORD\", \"ERROR_APP_TAG_KEYWORD\", \"ERROR_MESSAGE_KEYWORD\",\n  \"EXTENSION_KEYWORD\", \"DEVIATION_KEYWORD\", \"DEVIATE_KEYWORD\",\n  \"FEATURE_KEYWORD\", \"FRACTION_DIGITS_KEYWORD\", \"GROUPING_KEYWORD\",\n  \"IDENTITY_KEYWORD\", \"IF_FEATURE_KEYWORD\", \"IMPORT_KEYWORD\",\n  \"INCLUDE_KEYWORD\", \"INPUT_KEYWORD\", \"KEY_KEYWORD\", \"LEAF_KEYWORD\",\n  \"LEAF_LIST_KEYWORD\", \"LENGTH_KEYWORD\", \"LIST_KEYWORD\",\n  \"MANDATORY_KEYWORD\", \"MAX_ELEMENTS_KEYWORD\", \"MIN_ELEMENTS_KEYWORD\",\n  \"MODULE_KEYWORD\", \"MUST_KEYWORD\", \"NAMESPACE_KEYWORD\",\n  \"NOTIFICATION_KEYWORD\", \"ORDERED_BY_KEYWORD\", \"ORGANIZATION_KEYWORD\",\n  \"OUTPUT_KEYWORD\", \"PATH_KEYWORD\", \"PATTERN_KEYWORD\", \"POSITION_KEYWORD\",\n  \"PREFIX_KEYWORD\", \"PRESENCE_KEYWORD\", \"RANGE_KEYWORD\",\n  \"REFERENCE_KEYWORD\", \"REFINE_KEYWORD\", \"REQUIRE_INSTANCE_KEYWORD\",\n  \"REVISION_KEYWORD\", \"REVISION_DATE_KEYWORD\", \"RPC_KEYWORD\",\n  \"STATUS_KEYWORD\", \"SUBMODULE_KEYWORD\", \"TYPE_KEYWORD\", \"TYPEDEF_KEYWORD\",\n  \"UNIQUE_KEYWORD\", \"UNITS_KEYWORD\", \"USES_KEYWORD\", \"VALUE_KEYWORD\",\n  \"WHEN_KEYWORD\", \"YANG_VERSION_KEYWORD\", \"YIN_ELEMENT_KEYWORD\",\n  \"ADD_KEYWORD\", \"CURRENT_KEYWORD\", \"DELETE_KEYWORD\", \"DEPRECATED_KEYWORD\",\n  \"FALSE_KEYWORD\", \"NOT_SUPPORTED_KEYWORD\", \"OBSOLETE_KEYWORD\",\n  \"REPLACE_KEYWORD\", \"SYSTEM_KEYWORD\", \"TRUE_KEYWORD\", \"UNBOUNDED_KEYWORD\",\n  \"USER_KEYWORD\", \"ACTION_KEYWORD\", \"MODIFIER_KEYWORD\", \"ANYDATA_KEYWORD\",\n  \"NODE\", \"NODE_PRINT\", \"EXTENSION_INSTANCE\", \"SUBMODULE_EXT_KEYWORD\",\n  \"'+'\", \"'{'\", \"'}'\", \"';'\", \"'/'\", \"'['\", \"']'\", \"'='\", \"'('\", \"')'\",\n  \"$accept\", \"start\", \"tmp_string\", \"string_1\", \"string_2\", \"$@1\",\n  \"module_arg_str\", \"module_stmt\", \"module_header_stmts\",\n  \"module_header_stmt\", \"submodule_arg_str\", \"submodule_stmt\",\n  \"submodule_header_stmts\", \"submodule_header_stmt\", \"yang_version_arg\",\n  \"yang_version_stmt\", \"namespace_arg_str\", \"namespace_stmt\",\n  \"linkage_stmts\", \"import_stmt\", \"import_arg_str\", \"import_opt_stmt\",\n  \"include_arg_str\", \"include_stmt\", \"include_end\", \"include_opt_stmt\",\n  \"revision_date_arg\", \"revision_date_stmt\", \"belongs_to_arg_str\",\n  \"belongs_to_stmt\", \"prefix_arg\", \"prefix_stmt\", \"meta_stmts\",\n  \"organization_arg\", \"organization_stmt\", \"contact_arg\", \"contact_stmt\",\n  \"description_arg\", \"description_stmt\", \"reference_arg\", \"reference_stmt\",\n  \"revision_stmts\", \"revision_arg_stmt\", \"revision_stmts_opt\",\n  \"revision_stmt\", \"revision_end\", \"revision_opt_stmt\", \"date_arg_str\",\n  \"$@2\", \"body_stmts_end\", \"body_stmts\", \"body_stmt\", \"extension_arg_str\",\n  \"extension_stmt\", \"extension_end\", \"extension_opt_stmt\", \"argument_str\",\n  \"argument_stmt\", \"argument_end\", \"yin_element_arg\", \"yin_element_stmt\",\n  \"yin_element_arg_str\", \"status_arg\", \"status_stmt\", \"status_arg_str\",\n  \"feature_arg_str\", \"feature_stmt\", \"feature_end\", \"feature_opt_stmt\",\n  \"if_feature_arg\", \"if_feature_stmt\", \"if_feature_end\",\n  \"identity_arg_str\", \"identity_stmt\", \"identity_end\", \"identity_opt_stmt\",\n  \"base_arg\", \"base_stmt\", \"typedef_arg_str\", \"typedef_stmt\",\n  \"type_opt_stmt\", \"type_stmt\", \"type_arg_str\", \"type_end\",\n  \"type_body_stmts\", \"some_restrictions\", \"union_stmt\", \"union_spec\",\n  \"fraction_digits_arg\", \"fraction_digits_stmt\", \"fraction_digits_arg_str\",\n  \"length_stmt\", \"length_arg_str\", \"length_end\", \"message_opt_stmt\",\n  \"pattern_sep\", \"pattern_stmt\", \"pattern_arg_str\", \"pattern_end\",\n  \"pattern_opt_stmt\", \"modifier_arg\", \"modifier_stmt\",\n  \"enum_specification\", \"enum_stmts\", \"enum_stmt\", \"enum_arg_str\",\n  \"enum_end\", \"enum_opt_stmt\", \"value_arg\", \"value_stmt\",\n  \"integer_value_arg_str\", \"range_stmt\", \"range_end\", \"path_arg\",\n  \"path_stmt\", \"require_instance_arg\", \"require_instance_stmt\",\n  \"require_instance_arg_str\", \"bits_specification\", \"bit_stmts\",\n  \"bit_stmt\", \"bit_arg_str\", \"bit_end\", \"bit_opt_stmt\",\n  \"position_value_arg\", \"position_stmt\", \"position_value_arg_str\",\n  \"error_message_arg\", \"error_message_stmt\", \"error_app_tag_arg\",\n  \"error_app_tag_stmt\", \"units_arg\", \"units_stmt\", \"default_arg\",\n  \"default_stmt\", \"grouping_arg_str\", \"grouping_stmt\", \"grouping_end\",\n  \"grouping_opt_stmt\", \"data_def_stmt\", \"container_arg_str\",\n  \"container_stmt\", \"container_end\", \"container_opt_stmt\", \"leaf_stmt\",\n  \"leaf_arg_str\", \"leaf_opt_stmt\", \"leaf_list_arg_str\", \"leaf_list_stmt\",\n  \"leaf_list_opt_stmt\", \"list_arg_str\", \"list_stmt\", \"list_opt_stmt\",\n  \"choice_arg_str\", \"choice_stmt\", \"choice_end\", \"choice_opt_stmt\",\n  \"short_case_case_stmt\", \"short_case_stmt\", \"case_arg_str\", \"case_stmt\",\n  \"case_end\", \"case_opt_stmt\", \"anyxml_arg_str\", \"anyxml_stmt\",\n  \"anydata_arg_str\", \"anydata_stmt\", \"anyxml_end\", \"anyxml_opt_stmt\",\n  \"uses_arg_str\", \"uses_stmt\", \"uses_end\", \"uses_opt_stmt\",\n  \"refine_args_str\", \"refine_arg_str\", \"refine_stmt\", \"refine_end\",\n  \"refine_body_opt_stmts\", \"uses_augment_arg_str\", \"uses_augment_arg\",\n  \"uses_augment_stmt\", \"augment_arg_str\", \"augment_arg\", \"augment_stmt\",\n  \"augment_opt_stmt\", \"action_arg_str\", \"action_stmt\", \"rpc_arg_str\",\n  \"rpc_stmt\", \"rpc_end\", \"rpc_opt_stmt\", \"input_arg\", \"input_stmt\",\n  \"input_output_opt_stmt\", \"output_arg\", \"output_stmt\",\n  \"notification_arg_str\", \"notification_stmt\", \"notification_end\",\n  \"notification_opt_stmt\", \"deviation_arg\", \"deviation_stmt\",\n  \"deviation_opt_stmt\", \"deviation_arg_str\", \"deviate_body_stmt\",\n  \"deviate_not_supported\", \"deviate_not_supported_stmt\",\n  \"deviate_not_supported_end\", \"deviate_stmts\", \"deviate_add\",\n  \"deviate_add_stmt\", \"deviate_add_end\", \"deviate_add_opt_stmt\",\n  \"deviate_delete\", \"deviate_delete_stmt\", \"deviate_delete_end\",\n  \"deviate_delete_opt_stmt\", \"deviate_replace\", \"deviate_replace_stmt\",\n  \"deviate_replace_end\", \"deviate_replace_opt_stmt\", \"when_arg_str\",\n  \"when_stmt\", \"when_end\", \"when_opt_stmt\", \"config_arg\", \"config_stmt\",\n  \"config_arg_str\", \"mandatory_arg\", \"mandatory_stmt\", \"mandatory_arg_str\",\n  \"presence_arg\", \"presence_stmt\", \"min_value_arg\", \"min_elements_stmt\",\n  \"min_value_arg_str\", \"max_value_arg\", \"max_elements_stmt\",\n  \"max_value_arg_str\", \"ordered_by_arg\", \"ordered_by_stmt\",\n  \"ordered_by_arg_str\", \"must_agr_str\", \"must_stmt\", \"must_end\",\n  \"unique_arg\", \"unique_stmt\", \"unique_arg_str\", \"key_arg\", \"key_stmt\",\n  \"key_arg_str\", \"$@3\", \"range_arg_str\", \"absolute_schema_nodeid\",\n  \"absolute_schema_nodeids\", \"absolute_schema_nodeid_opt\",\n  \"descendant_schema_nodeid\", \"$@4\", \"path_arg_str\", \"$@5\", \"$@6\",\n  \"absolute_path\", \"absolute_paths\", \"absolute_path_opt\", \"relative_path\",\n  \"relative_path_part1\", \"relative_path_part1_opt\", \"descendant_path\",\n  \"descendant_path_opt\", \"path_predicate\", \"path_equality_expr\",\n  \"path_key_expr\", \"rel_path_keyexpr\", \"rel_path_keyexpr_part1\",\n  \"rel_path_keyexpr_part1_opt\", \"rel_path_keyexpr_part2\",\n  \"current_function_invocation\", \"positive_integer_value\",\n  \"non_negative_integer_value\", \"integer_value\", \"integer_value_convert\",\n  \"prefix_arg_str\", \"identifier_arg_str\", \"node_identifier\",\n  \"identifier_ref_arg_str\", \"stmtend\", \"semicolom\", \"curly_bracket_close\",\n  \"curly_bracket_open\", \"stmtsep\", \"unknown_statement\", \"string_opt\",\n  \"string_opt_part1\", \"string_opt_part2\", \"unknown_string\",\n  \"unknown_string_part1\", \"unknown_string_part2\", \"unknown_statement_end\",\n  \"unknown_statement2_opt\", \"unknown_statement2\", \"unknown_statement2_end\",\n  \"unknown_statement2_yang_stmt\", \"unknown_statement2_module_stmt\",\n  \"unknown_statement3_opt\", \"unknown_statement3_opt_end\", \"sep_stmt\",\n  \"optsep\", \"sep\", \"whitespace_opt\", \"string\", \"$@7\", \"strings\",\n  \"identifier\", \"identifier1\", \"yang_stmt\", \"identifiers\",\n  \"identifiers_ref\", \"type_ext_alloc\", \"typedef_ext_alloc\",\n  \"iffeature_ext_alloc\", \"restriction_ext_alloc\", \"when_ext_alloc\",\n  \"revision_ext_alloc\", \"datadef_ext_check\", \"not_supported_ext_check\",\n  \"not_supported_ext\", \"datadef_ext_stmt\", \"restriction_ext_stmt\",\n  \"ext_substatements\", YY_NULLPTR\n};\n#endif\n\n# ifdef YYPRINT\n/* YYTOKNUM[NUM] -- (External) token number corresponding to the\n   (internal) symbol number NUM (which must be that of a token).  */\nstatic const yytype_uint16 yytoknum[] =\n{\n       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,\n     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,\n     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,\n     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,\n     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,\n     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,\n     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,\n     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,\n     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,\n     345,   346,   347,   348,   349,   350,   351,   352,   353,   354,\n     355,   356,   357,    43,   123,   125,    59,    47,    91,    93,\n      61,    40,    41\n};\n# endif\n\n#define YYPACT_NINF -1012\n\n#define yypact_value_is_default(Yystate) \\\n  (!!((Yystate) == (-1012)))\n\n#define YYTABLE_NINF -757\n\n#define yytable_value_is_error(Yytable_value) \\\n  0\n\n  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing\n     STATE-NUM.  */\nstatic const yytype_int16 yypact[] =\n{\n     440,   100, -1012, -1012,   566,  1894, -1012, -1012, -1012,   266,\n     266, -1012,   266, -1012,   266,   266, -1012,   266,   266,   266,\n     266, -1012,   266,   266, -1012, -1012, -1012, -1012,   266, -1012,\n   -1012, -1012,   266,   266,   266,   266,   266,   266,   266,   266,\n     266,   266,   266,   266,   266,   266,   266,   266,   266,   266,\n   -1012, -1012,   266, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,    -8,    31,    79,   868,    70,   125,   481,\n     266, -1012, -1012,  3273,  3273,  3273,  2893,  3273,    71,  2703,\n    2703,  2703,  2703,  2703,    98,  2988,    94,    52,   287,  2703,\n      77,  2703,   104,   287,  3273,  2703,  2703,   182,    58,   246,\n    2988,  2703,   321,  2703,   279,   279,   266, -1012,   266, -1012,\n     266, -1012,   266,   266,   266,   266, -1012, -1012, -1012, -1012,\n   -1012,   266, -1012,   266, -1012,   266,   266,   266,   266,   266,\n   -1012,   266,   266,   266,   266, -1012,   266,   266,   266, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n      29, -1012,   134, -1012, -1012, -1012,   -22,  2798,   266, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   151, -1012, -1012, -1012, -1012, -1012,   156,\n   -1012,    67, -1012, -1012, -1012,   224, -1012, -1012, -1012,   161,\n   -1012, -1012, -1012, -1012,   224, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   224, -1012, -1012, -1012,   224, -1012,   224,\n   -1012,   224, -1012,   224, -1012, -1012, -1012,   224, -1012, -1012,\n   -1012, -1012,   224, -1012, -1012, -1012, -1012, -1012, -1012,   224,\n   -1012, -1012, -1012,   224, -1012, -1012, -1012, -1012,   224, -1012,\n   -1012, -1012,   224, -1012, -1012, -1012, -1012,   224, -1012,   224,\n   -1012, -1012,   224, -1012,   262,   202, -1012,   224, -1012, -1012,\n   -1012,   224, -1012, -1012,   224, -1012,   224, -1012, -1012, -1012,\n   -1012,   224, -1012, -1012, -1012,   224, -1012, -1012, -1012, -1012,\n   -1012,   224, -1012, -1012,   224, -1012, -1012, -1012,   224, -1012,\n   -1012, -1012, -1012, -1012,   224, -1012, -1012, -1012,   224, -1012,\n   -1012, -1012, -1012,  2893,   279,  3273,   279,  2703,   279,  2703,\n    2703,  2703, -1012,  2703,   279,  2703,   279,    58,   279,  3273,\n    3273,  3273,  3273,  3273,   266,  3273,  3273,  3273,  3273,   266,\n    2893,  3273,  3273, -1012, -1012,   279, -1012, -1012, -1012, -1012,\n   -1012, -1012,   266, -1012,   266, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012,   266,   266, -1012,   266,   266, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,   266, -1012, -1012,\n     266,   266, -1012,   266, -1012,   266, -1012,   266, -1012,   266,\n     266, -1012, -1012, -1012,  3368, -1012, -1012,   291, -1012, -1012,\n   -1012,   266, -1012,   266, -1012, -1012,   266,   266, -1012, -1012,\n   -1012,   266,   266,   266, -1012, -1012,   266, -1012, -1012, -1012,\n     266, -1012,   228,  2703,   266,   274, -1012,   189, -1012,   288,\n   -1012,   298, -1012,   303, -1012,   370, -1012,   380, -1012,   389,\n   -1012,   393, -1012,   407, -1012,   411, -1012,   419, -1012,   426,\n   -1012,   463, -1012,   238, -1012,   314, -1012,   317, -1012,   505,\n   -1012,   506, -1012,   521, -1012,   407, -1012,   279,   279,   266,\n     266,   266,   266,   326,   279,   279,   109,   279,   112,   608,\n     266,   266, -1012,   262, -1012,  3083,   266,   332, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012,  1964,  1994,  2191,   347,\n   -1012, -1012,    19, -1012,    54,   266,   355, -1012, -1012,   368,\n     373, -1012, -1012, -1012,    48,  3368, -1012,   266,   831,   279,\n     186,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   266, -1012,   127,   515,   266, -1012, -1012,\n   -1012,   515, -1012, -1012,   188, -1012,   279, -1012,   473, -1012,\n     306, -1012,  2552,   266,   266,   397,  1000, -1012, -1012, -1012,\n   -1012,   783, -1012,   230,   503,   404,   887,   359,   438,   929,\n    1958,  1645,   817,   947,   344,  2074,  1547,  1768,   235,   852,\n     279,   279,   279,   279,   266,   -22,   280, -1012,   266,   266,\n   -1012, -1012,   375,  2703,   375,   279, -1012, -1012, -1012,   224,\n   -1012, -1012,  3368, -1012, -1012, -1012, -1012, -1012,   266,   266,\n   -1012,  3273,  2703, -1012, -1012, -1012,    -8, -1012, -1012, -1012,\n   -1012, -1012, -1012,   279,   474, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012,   266,   266, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012,  3273,  3273,   279,   279, -1012, -1012,\n   -1012, -1012, -1012,   125,   224, -1012, -1012,   266,   266, -1012,\n     399,   473,   266,   528,   528,   545, -1012,   567, -1012,   279,\n   -1012,   279,   279,   279,   480, -1012,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   279,   279,   279,   279,   279,   279,   279,   279,   279,\n    2988,  2988,   279,   279,   279,   279,   279,   279,   279,   279,\n     279,   266,   266,   423, -1012,   570, -1012,   428,  2046, -1012,\n   -1012,   434, -1012,   465, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,   479, -1012, -1012,\n   -1012,   571, -1012, -1012, -1012, -1012, -1012, -1012,   266,   266,\n     266,   266,   266,   266, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012,   279, -1012,   473,   266,   279,\n     279,   279,   279, -1012,   266, -1012, -1012, -1012,   266,   279,\n     279,   266,    51,  3273,    51,  3273,  3273,  3273,   279,   266,\n     459,  2367,   385,   509,   279,   279,   341,   365, -1012, -1012,\n     483, -1012, -1012,   574, -1012, -1012,   486, -1012, -1012,   591,\n   -1012,   592, -1012,   521, -1012,   473, -1012,   473, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012,   885,  1126, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012,   332,   266, -1012, -1012, -1012, -1012,   266,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,   467,   492,   279,\n     279, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012,   279,   279,   279,   279,   279,   473,   473,   279,\n     279,   279,   279,   279,   279,   279,   279,  1460,   205,   524,\n     216,   201,   493,   579, -1012, -1012, -1012, -1012, -1012, -1012,\n     266, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012,   473, -1012, -1012,   279,\n     293,   279,   279,   497,  3178, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,   473,\n   -1012, -1012,   279,    73,   120,   133,   163, -1012,    50, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012,   510,   222,   279,   279,   279,   473, -1012,   824,   346,\n     985,  3368, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012,   279,   279,   279\n};\n\n  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.\n     Performed when YYTABLE does not specify something else to do.  Zero\n     means the default is an error.  */\nstatic const yytype_uint16 yydefact[] =\n{\n     790,     0,     2,     3,     0,   757,     1,   649,   650,     0,\n       0,   652,     0,   763,     0,     0,   761,     0,     0,     0,\n       0,   762,     0,     0,   766,   764,   765,   767,     0,   768,\n     769,   770,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n     759,   760,     0,   771,   802,   806,   619,   792,   803,   797,\n     793,   794,   619,   809,   796,   815,   814,   819,   804,   813,\n     818,   799,   800,   795,   798,   810,   811,   805,   816,   817,\n     812,   820,   801,     0,     0,     0,     0,     0,     0,     0,\n     627,   758,   651,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,   571,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,   791,   822,     0,   619,     0,   619,\n       0,   619,     0,     0,     0,     0,   789,   787,   788,   786,\n     619,     0,   619,     0,   619,     0,     0,     0,     0,     0,\n     651,     0,     0,     0,     0,   651,     0,     0,     0,   778,\n     777,   780,   781,   782,   776,   775,   774,   773,   785,   772,\n       0,   779,     0,   784,   783,   619,     0,   629,   653,   679,\n       5,   669,   680,   681,   682,   683,   684,   685,   686,   687,\n     688,   689,   690,   691,   692,   693,   694,   695,   696,   697,\n     698,   699,   700,   701,   702,   703,   704,   705,   706,   707,\n     708,   709,   710,   711,   712,   713,   666,   714,   715,   716,\n     717,   718,   719,   720,   721,   722,   723,   724,   725,   726,\n     727,   728,   729,   730,   731,   732,   733,   734,   735,   736,\n     737,   738,   739,   740,   741,   742,   743,   670,   744,   671,\n     672,   673,   674,   745,   675,   676,   677,   678,   746,   747,\n     748,   651,   608,     0,    10,   749,   667,   668,   651,     0,\n      17,     0,    99,   750,   613,     0,   138,   651,   651,     0,\n      47,   651,   651,   529,     0,   525,   659,   662,   660,   664,\n     665,   663,   658,     0,    58,   656,   661,     0,   243,     0,\n      60,     0,   239,     0,   237,   598,   170,     0,   167,   651,\n     610,   563,     0,   559,   561,   609,   651,   651,   534,     0,\n     530,   651,   545,     0,   541,   651,   599,   540,     0,   537,\n     600,   651,     0,    25,   651,   651,   550,     0,   546,     0,\n      56,   575,     0,   213,     0,     0,   236,     0,   233,   651,\n     605,     0,    49,   651,     0,   535,     0,    62,   651,   651,\n     219,     0,   215,    74,    76,     0,    45,   651,   651,   651,\n     114,     0,   109,   558,     0,   555,   651,   569,     0,   241,\n     603,   604,   601,   209,     0,   206,   651,   602,     0,   191,\n     621,   620,   651,     0,   807,     0,   808,     0,   821,     0,\n       0,     0,   180,     0,   823,     0,   824,     0,   825,     0,\n       0,     0,     0,     0,   445,     0,     0,     0,     0,   452,\n       0,     0,     0,   619,   619,   826,   651,   651,   827,   651,\n     628,   651,     7,   619,   607,   619,   619,   101,   100,   618,\n     616,   139,   619,   619,   611,   612,   619,   528,   527,   526,\n      59,   651,   244,    61,   240,   238,   168,   169,   560,   651,\n     533,   532,   531,   543,   542,   544,   538,   539,    26,   549,\n     548,   547,    57,   214,     0,   578,   572,     0,   574,   582,\n     234,   235,    50,   606,   536,    63,   218,   217,   216,   651,\n      46,   111,   113,   112,   110,   556,   557,   567,   242,   207,\n     208,   192,     0,   625,   624,     0,   150,     0,   140,     0,\n     124,     0,   172,     0,   551,     0,   182,     0,   564,     0,\n     518,     0,    65,     0,   368,     0,   357,     0,   334,     0,\n     266,     0,   245,     0,   285,     0,   298,     0,   314,     0,\n     454,     0,   383,     0,   430,     0,   370,   447,   447,   645,\n     647,   632,   630,     6,    13,    20,   104,   614,     0,     0,\n     657,   562,   587,   577,   581,     0,    75,   570,   651,   634,\n     622,   623,   626,   619,   151,   149,   619,   619,   126,   125,\n     619,   173,   171,   619,   553,   552,   619,   183,   181,   619,\n     211,   210,   619,   520,   519,   619,    69,    68,   619,   372,\n     369,   619,   359,   358,   619,   336,   335,   619,   268,   267,\n     619,   247,   246,   619,   619,   619,   619,   456,   455,   619,\n     385,   384,   619,   434,   431,   371,     0,     0,     0,   631,\n     651,    27,    12,    27,    19,     0,     0,   617,   619,     0,\n     576,   579,   583,   580,   585,     0,   568,   636,   156,   142,\n       0,   175,   175,   185,   175,   522,    71,   374,   361,   338,\n     270,   249,   286,   300,   316,   458,   387,   436,   446,   619,\n     619,   619,   258,   259,   260,   261,   262,   263,   264,   265,\n     619,   453,   651,   627,   651,     0,    51,     0,    14,    15,\n      16,    51,    21,   619,     0,   102,   615,    48,   654,   584,\n       0,   565,     0,     0,     0,     0,   153,   154,   619,   155,\n     221,     0,   127,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n     449,   450,   451,   448,   648,     0,     0,     8,     0,     0,\n     619,   619,    66,     0,    66,    22,   651,   651,   108,     0,\n     103,   655,     0,   586,   644,   635,   638,   651,   627,   627,\n     643,     0,     0,   152,   159,   619,     0,   162,   619,   619,\n     619,   158,   157,   194,   220,   141,   147,   148,   146,   619,\n     144,   145,   174,   178,   179,   176,   177,   554,   184,   189,\n     190,   186,   187,   188,   212,   521,   523,   524,    70,    72,\n      73,   373,   381,   382,   380,   619,   619,   378,   379,   619,\n     360,   365,   366,   364,   619,   619,   619,   337,   345,   346,\n     344,   619,   341,   350,   351,   352,   353,   356,   619,   348,\n     349,   354,   355,   619,   342,   343,   269,   277,   278,   276,\n     619,   619,   619,   619,   619,   619,   619,   275,   274,   619,\n     248,   251,   252,   250,   619,   619,   619,   619,   619,   284,\n     296,   297,   295,   619,   619,   290,   292,   619,   293,   294,\n     619,   299,   312,   313,   311,   619,   619,   305,   304,   619,\n     307,   308,   309,   310,   619,   315,   327,   328,   326,   619,\n     619,   619,   619,   619,   619,   619,   322,   323,   324,   325,\n     619,   321,   320,   457,   462,   463,   461,   619,   619,   619,\n     619,   619,     0,     0,   386,   391,   392,   390,   619,   619,\n     619,   619,   435,   439,   440,   438,   619,   619,   619,   619,\n     619,   646,   651,   651,     0,     0,    28,    29,    52,    53,\n      54,    55,    78,    64,     0,    23,    78,   107,   106,   105,\n       0,   654,   637,     0,     0,     0,   224,     0,   197,   164,\n     165,   160,   161,   163,   193,   222,   143,   376,   375,   377,\n     363,   367,   362,   340,   347,   339,   272,   282,   279,   283,\n     280,   281,   271,   273,   254,   253,   255,   256,   257,   288,\n     289,   287,   291,   302,   303,   301,   306,   318,   329,   330,\n     333,   331,   332,   317,   319,   460,   464,   465,   466,   459,\n       0,     0,   389,   393,   394,   388,   437,   441,   442,   443,\n     444,   633,     9,     0,    31,     0,    37,     0,    77,   619,\n      24,     0,   588,     0,   651,   641,   639,   640,   619,   225,\n     619,   619,   198,   196,   619,   413,   414,     0,   651,   396,\n     397,     0,   651,   619,   619,    39,    38,   651,     0,     0,\n       0,     0,     0,     0,   619,    80,    81,    82,    83,    84,\n      85,    86,    87,    88,    89,    67,   651,   654,   645,   227,\n     223,   200,   195,   619,   412,   619,   399,   398,   395,    32,\n      41,    11,     0,     0,     0,     0,     0,     0,    79,    18,\n       0,     0,     0,     0,   420,   401,     0,     0,   417,   418,\n       0,   567,   651,     0,    90,   474,     0,   467,   651,     0,\n     115,     0,   128,     0,   432,   654,   589,   654,   642,   226,\n     231,   232,   230,   619,   229,   199,   204,   205,   203,   619,\n     202,     0,     0,    30,    36,    33,    34,    35,    40,    44,\n      42,    43,   619,   566,   416,   619,    92,    91,   619,   473,\n     619,   117,   116,   619,   130,   129,   433,     0,     0,   228,\n     201,   415,   424,   425,   423,   619,   619,   619,   619,   619,\n     619,   400,   410,   411,   619,   405,   406,   407,   404,   408,\n     409,   619,   420,    94,   469,   119,   132,   654,   654,   422,\n     426,   429,   427,   428,   421,   403,   402,     0,     0,     0,\n       0,     0,     0,     0,   419,    93,    97,    98,   619,    96,\n       0,   468,   470,   471,   118,   122,   123,   121,   619,   131,\n     136,   137,   135,   619,   133,   597,   654,   590,   593,    95,\n       0,   120,   134,     0,     0,   484,   497,   477,   506,   619,\n     651,   475,   476,   651,   481,   651,   483,   651,   482,   654,\n     594,   595,   472,     0,     0,     0,     0,   592,   591,   619,\n     479,   478,   619,   486,   485,   619,   499,   498,   619,   508,\n     507,     0,     0,   488,   501,   510,   654,   480,     0,     0,\n       0,     0,   487,   489,   492,   493,   494,   495,   496,   619,\n     491,   500,   502,   505,   619,   504,   509,   619,   512,   513,\n     514,   515,   516,   517,   596,   490,   503,   511\n};\n\n  /* YYPGOTO[NTERM-NUM].  */\nstatic const yytype_int16 yypgoto[] =\n{\n   -1012, -1012, -1012,   245, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012,   -16, -1012,    -2,    -9, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1011, -1012,    22,\n   -1012,  -534,   -24, -1012,   658, -1012,   681, -1012,    63, -1012,\n     105,   -41, -1012, -1012,  -237, -1012, -1012,   305, -1012,  -225,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012,  -486, -1012, -1012,\n   -1012, -1012, -1012,    41, -1012, -1012, -1012, -1012, -1012, -1012,\n     -11, -1012, -1012, -1012, -1012, -1012, -1012,  -657, -1012,    -3,\n   -1012,  -653, -1012, -1012, -1012, -1012, -1012, -1012, -1012,    23,\n   -1012,    30, -1012, -1012,    53, -1012,    35, -1012, -1012, -1012,\n   -1012,    10, -1012, -1012,  -236, -1012, -1012, -1012, -1012,  -366,\n   -1012,    38, -1012, -1012,    40, -1012,    43, -1012, -1012, -1012,\n     -21, -1012, -1012, -1012, -1012,  -355, -1012, -1012,    12, -1012,\n      18, -1012,  -704, -1012,  -480, -1012,    16, -1012, -1012,  -560,\n   -1012,   -80, -1012, -1012,   -67, -1012, -1012, -1012,   -63, -1012,\n   -1012,   -39, -1012, -1012,   -36, -1012, -1012, -1012, -1012, -1012,\n     -33, -1012, -1012, -1012,   -28, -1012,   -27,   206, -1012, -1012,\n     667, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012,  -435, -1012,   -62, -1012, -1012,  -365,\n   -1012, -1012,    42,   211, -1012,    44, -1012,   -87, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012,\n   -1012, -1012,    74, -1012, -1012, -1012,  -473, -1012, -1012,  -667,\n   -1012, -1012,  -675, -1012,  -722, -1012, -1012,  -662, -1012, -1012,\n    -271, -1012, -1012,   -35, -1012, -1012,  -725, -1012, -1012,    46,\n   -1012, -1012, -1012,  -390,  -319,  -335,  -461, -1012, -1012, -1012,\n   -1012,   214,    97, -1012, -1012,   239, -1012, -1012, -1012,   135,\n   -1012, -1012, -1012,  -441, -1012, -1012, -1012,   155,   693, -1012,\n   -1012, -1012,   185,   -93,  -328,  1164, -1012, -1012, -1012,   526,\n     110, -1012, -1012, -1012,  -433, -1012, -1012, -1012, -1012, -1012,\n    -143, -1012, -1012,  -260,    84,    -4,  1453,   166,  -694,   119,\n   -1012,   660,   -12, -1012,   137,   -20,   -23, -1012, -1012, -1012,\n   -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012, -1012\n};\n\n  /* YYDEFGOTO[NTERM-NUM].  */\nstatic const yytype_int16 yydefgoto[] =\n{\n      -1,     1,   261,   262,   553,   933,   263,     2,   631,   632,\n     269,     3,   633,   634,   944,   688,   332,    54,   686,   740,\n    1023,  1106,  1025,   741,  1056,  1107,   365,    55,   279,    56,\n     351,    57,   742,   339,   938,   293,   939,   299,   783,   356,\n     784,   942,   521,   943,   144,   597,   718,   366,   489,  1027,\n    1028,  1064,  1113,  1065,  1157,  1208,   271,    62,   438,   749,\n     636,   750,   371,  1174,   372,  1119,  1066,  1162,  1210,   509,\n    1175,   579,  1121,  1067,  1165,  1211,   275,    64,   507,   669,\n     711,   127,   505,   575,   705,   706,   765,   766,   307,    65,\n     308,   136,   511,   582,   713,   401,   137,   515,   588,   715,\n     388,    66,   707,   964,   708,   957,  1043,  1103,   384,    67,\n     385,   138,   591,   342,    68,   361,    69,   362,   709,   774,\n     710,   955,  1040,  1102,   347,    70,   348,   303,   785,   301,\n     786,   378,    73,   297,    74,   531,   670,   612,   723,   671,\n     529,   672,   609,   722,   673,   533,   724,   535,   674,   725,\n     537,   675,   726,   527,   676,   606,   721,   828,   829,   525,\n    1177,   603,   720,   523,   677,   545,   678,   600,   719,   541,\n     679,   621,   728,  1050,  1051,   919,  1087,  1142,  1046,  1047,\n     920,  1109,  1110,  1071,  1141,   543,  1178,  1123,  1072,   624,\n     729,   170,   171,   626,   172,   173,   539,  1179,   618,   727,\n    1116,  1074,  1209,  1117,  1249,  1250,  1251,  1271,  1252,  1253,\n    1254,  1274,  1288,  1255,  1256,  1277,  1289,  1257,  1258,  1280,\n    1290,   519,  1180,   594,   717,   284,    75,   285,   319,    76,\n     320,   354,    77,   328,    78,   329,   323,    79,   324,   337,\n      80,   338,   513,   680,   585,   374,    81,   375,   312,    82,\n     313,   459,   517,   646,  1112,   567,   376,   497,   343,   344,\n     345,   475,   476,   563,   478,   479,   565,   643,   699,   640,\n     950,  1126,  1237,  1238,  1244,  1268,  1127,   330,   331,   386,\n     387,   352,   264,   377,   276,   441,   442,   638,   443,   124,\n     390,   502,   503,   571,   176,   430,   629,   570,   702,   757,\n    1036,   758,   759,   628,   428,   391,     4,   177,   752,   294,\n     451,   295,   265,   266,   267,   268,   392,    83,    84,    85,\n      86,    87,    88,    89,    90,    91,   175,   140,     5\n};\n\n  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If\n     positive, shift that token.  If negative, reduce the rule whose\n     number is the opposite.  If YYTABLE_NINF, syntax error.  */\nstatic const yytype_int16 yytable[] =\n{\n      11,   901,   174,   881,   897,    92,    92,   780,    92,   160,\n      92,    92,   314,    92,    92,    92,    92,    71,    92,    92,\n     865,   877,   161,    72,    92,   639,   162,   169,    92,    92,\n      92,    92,    92,    92,    92,    92,    92,    92,    92,    92,\n      92,    92,    92,    92,    92,    92,    63,   848,    92,   764,\n     163,   139,   808,   164,   835,   751,   165,   869,   779,   180,\n     180,   166,   167,   882,   898,   506,   180,   126,    60,   305,\n     363,   864,   876,   278,   131,    36,   277,    15,     7,   180,\n       8,   129,   426,    41,   427,   180,    92,   296,   296,   296,\n     296,   296,   542,   315,   353,  1144,  1149,   296,   690,   296,\n       6,   687,   180,   296,   296,   159,   180,   128,   315,   296,\n      61,   296,   180,   960,     7,   305,     8,     7,  -573,     8,\n     273,   130,    92,   273,    92,     7,    92,     8,    92,    92,\n      92,    92,     7,   423,     8,   737,   687,    92,     7,    92,\n       8,    92,    92,    92,    92,    92,   321,    92,    92,    92,\n      92,   141,    92,    92,    92,  -587,  -587,  -654,   645,   281,\n     815,   142,   843,   856,   282,   296,   892,   910,     7,   334,\n       8,   436,   335,   437,    11,    93,    94,  1269,    95,  1270,\n      96,    97,   316,    98,    99,   100,   101,   317,   102,   103,\n     180,     7,   635,     8,   104,   143,   180,   273,   105,   106,\n     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,\n     117,   118,   119,   120,   121,   122,   477,   637,   123,   298,\n     300,   302,   304,    14,  1272,    12,  1273,     7,   333,     8,\n     340,   781,    20,   273,   355,   357,    20,  1275,   424,  1276,\n     379,   822,   389,   130,   866,   878,   807,    20,   834,   847,\n     735,   868,   880,   896,   180,   433,   912,  1033,   130,   309,\n     435,    20,   325,    22,    23,   446,    20,  1278,    43,  1279,\n     358,     7,    43,     8,    46,   359,   746,   130,    46,   270,\n     272,   747,   280,    43,     7,     7,     8,     8,   932,    46,\n     273,   712,   393,   576,   395,   180,   397,    43,   399,   400,\n     402,   403,    43,   913,   305,   326,  1229,   405,    46,   407,\n    1215,   409,   410,   411,   412,   413,   141,   415,   416,   417,\n     418,  1224,   420,   421,   422,   953,   954,  1287,   439,   180,\n     440,   367,   568,   368,   569,   782,   369,   380,   381,   382,\n     914,   274,   613,   283,   292,   292,   292,   292,   292,   306,\n     311,   318,   322,   327,   292,   336,   292,   341,   346,   350,\n     292,   292,   360,   364,   370,   373,   292,   383,   292,   474,\n     278,    17,    20,   277,    19,    20,    19,  1245,   573,  1246,\n     574,   562,  1247,  1100,  1248,   296,   130,   296,   296,   296,\n      20,   296,   577,   296,   578,    33,    20,   278,   564,   133,\n     277,   133,   580,    18,   581,    41,    20,   583,    43,   584,\n      11,    43,    45,   474,   698,    11,    20,    46,   614,   126,\n    1189,   615,    48,    47,    48,   141,    43,   130,    11,   630,\n      11,  1167,    43,  1168,    38,    20,    45,    22,    23,   645,\n      11,    11,    43,    11,    11,  -651,  1143,  -651,    40,   859,\n     684,  1301,    43,    11,   883,   899,    11,    11,    46,    11,\n     695,    11,   315,    11,   795,    11,    11,  1188,  1070,    20,\n    1148,    43,   644,   697,   586,  1187,   587,    11,   751,    11,\n    1190,   698,    11,    11,   589,   145,   590,    11,    11,    11,\n    1129,   296,    11,   592,  -651,   593,    11,   595,   703,   596,\n      11,    52,   763,  1212,  1213,    43,   146,   147,  1032,   788,\n     148,   598,   704,   599,  -651,   601,   510,   602,   512,   514,\n     516,   149,   518,   604,   520,   605,   150,  1053,   151,   152,\n     607,   153,   608,  1057,    20,   683,    22,    23,   154,  1076,\n      20,   155,  1243,   798,  1125,    11,    11,    11,    11,  1048,\n    1052,   130,   701,   315,  1234,    20,    11,    11,   738,   739,\n     156,  1220,    11,  1300,  1305,  1267,  1297,   610,  1312,   611,\n      43,     7,  1145,     8,  1281,  1077,    43,   157,  1197,   158,\n     508,  1176,    46,  1083,  1293,  1302,  1308,  1152,   125,    49,\n    1158,    43,  1291,  1236,   524,   526,   528,   530,   532,  1198,\n     534,   536,   538,   540,  1259,  1235,   544,   546,   787,   616,\n     619,   617,   620,     7,  1135,     8,   315,  1286,   692,   273,\n       9,  1296,   572,  1311,   691,   622,  1298,   623,  1313,  1221,\n     689,    92,  1034,   315,  1035,   845,   858,  1307,   274,   894,\n      10,   823,   292,    11,   292,   292,   292,  1176,   292,  1038,\n     292,  1039,   364,   394,   824,   396,   693,   398,   825,   951,\n     844,   857,  1185,    58,   893,   274,   404,   744,   406,  1186,\n     408,  1041,    41,  1042,  1054,  1085,  1055,  1086,  1155,    92,\n    1156,    11,   826,    92,   809,   827,    59,   849,   830,   870,\n     884,   900,   911,   831,   832,  1160,  1163,  1161,  1164,    92,\n      92,   425,  1111,   946,  1111,   714,  1029,   716,   805,   814,\n     821,   840,   522,   863,   875,   889,   907,   918,   926,   841,\n     854,  1031,  1218,   890,   908,   791,   927,   792,  1044,   767,\n      11,   296,    11,   793,    92,    92,   768,  1140,   842,   855,\n     315,   769,   891,   909,   770,   928,   771,  1134,   292,   772,\n     296,   625,   778,   965,    92,    92,   168,  1207,  1166,   627,\n     804,   813,   820,   839,   853,   862,   874,   888,   906,   917,\n     925,   929,   902,   930,   776,  1118,  1153,   641,   789,   700,\n     796,   799,   802,   811,   818,   837,   851,   860,   872,   886,\n     904,   915,   923,   806,   816,   833,   846,   753,   867,   879,\n     895,   694,   921,  1260,   642,   940,   349,   940,  1294,  1303,\n    1309,  1037,   756,    19,    20,  1295,   777,  1310,  1101,   931,\n     790,   145,   797,   800,   803,   812,   819,   838,   852,   861,\n     873,   887,   905,   916,   924,     0,     7,   431,     8,   760,\n       0,     0,   273,   147,    17,     0,   148,   941,    20,   941,\n      43,    17,     0,   743,    19,   703,    46,   149,   126,   130,\n       0,    48,   945,   704,   151,   152,     0,   153,     0,   761,\n     762,     0,   133,     0,   154,    33,    34,    35,     0,   133,\n       0,   958,    42,    20,    43,     0,     0,     0,   775,   145,\n      46,     0,   149,   128,   130,     0,   156,   150,   141,     0,\n       0,    47,    48,     0,   934,   935,     0,     0,    92,    92,\n     146,   147,   155,   157,   148,   158,    20,   132,    20,    43,\n      22,    23,   836,   133,     0,    46,     0,   130,   128,  1292,\n     134,     0,   151,   152,   135,   153,     0,     0,     0,   748,\n       0,  1073,   154,    11,    11,     0,   956,     0,    11,   547,\n     548,   145,    43,     0,    43,     0,    17,   922,    46,   554,\n      20,   555,   556,     0,   156,     0,   141,     0,   557,   558,\n       0,   130,   559,   147,     0,     0,   148,     0,    20,     0,\n      33,   157,     0,   158,   133,     0,     0,   149,   292,     0,\n    1171,     0,   794,     0,   151,   152,    43,   153,   315,   315,\n       0,     0,    46,     0,   154,     0,     0,   292,   683,     0,\n     141,     0,    17,     0,    43,    19,     0,    11,    11,     0,\n      46,     0,    14,   128,     0,  1068,   156,     0,     0,     0,\n       0,     0,     0,     0,   801,     0,    33,    34,    35,    28,\n       0,     0,     0,   157,  1069,   158,     0,     0,     0,   132,\n       0,     0,   850,     0,    92,    92,    92,    92,    92,    92,\n     126,    39,   134,    48,     0,     0,   135,     0,     0,    44,\n       0,     0,     0,     0,    11,  -166,     0,     0,  1010,  1011,\n      11,     0,     0,     0,    11,     0,     0,    11,     0,   315,\n    1306,  1133,  1139,     0,     0,    11,     0,     0,     0,   648,\n       0,     0,   649,   650,     0,     0,   651,  1191,     0,   652,\n       0,     0,   653,     0,     0,   654,     0,     0,   655,  1024,\n    1026,   656,     0,     0,   657,     0,     0,   658,     0,     0,\n     659,  1184,     0,   660,     0,     0,   661,     0,     0,   662,\n     663,   664,   665,  1132,  1138,   666,     0,     0,   667,     0,\n      11,  1261,     0,    17,     0,    11,    19,    20,     0,     0,\n       0,     0,     0,     0,   696,  1130,  1136,     0,   130,  1146,\n    1150,     0,     0,     0,     0,     0,     0,    33,    34,    35,\n       0,   133,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,    42,     0,    43,     0,   730,   731,   732,  1314,  1228,\n    1233,     0,     0,     0,  1172,  1182,   733,  1131,  1137,     0,\n       0,  1147,  1151,     0,     0,     0,    92,     0,     0,   745,\n       0,     0,     0,     0,  1092,  1093,  1094,  1095,  1096,  1097,\n       0,  1181,   315,     0,   773,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,  1173,  1183,     0,  1219,\n       0,  1227,  1232,  1299,  1304,  1045,  1049,     0,     0,    11,\n      11,    11,    11,     0,     0,     0,   936,   937,     0,     0,\n    1172,  1216,  1222,  1225,  1230,     0,     0,     0,  1114,   315,\n    1120,  1122,  1124,     0,     0,     0,     0,     0,     0,     0,\n       0,   959,     0,     0,   961,   962,   963,     0,     0,     0,\n       0,     0,     0,     0,     0,   966,     0,     0,     0,     0,\n       0,     0,  1173,  1217,  1223,  1226,  1231,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,   967,   968,     0,     0,   969,     0,  1108,     0,  1115,\n     970,   971,   972,     0,     0,     0,     0,   973,     0,     0,\n       0,     0,     0,     0,   974,     0,     0,     0,     0,   975,\n       0,     0,     0,     0,     0,     0,   976,   977,   978,   979,\n     980,   981,   982,     0,     0,   983,     0,     0,     0,     0,\n     984,   985,   986,   987,   988,     0,  1240,     0,     0,   989,\n     990,     0,     0,   991,     0,     0,   992,     0,     0,     0,\n       0,   993,   994,     0,     0,   995,     0,     0,     0,     0,\n     996,     0,     0,     0,     0,   997,   998,   999,  1000,  1001,\n    1002,  1003,     0,     0,     0,     0,  1004,     0,     0,     0,\n       0,     0,     0,  1005,  1006,  1007,  1008,  1009,     0,     0,\n       0,     0,     0,     0,  1012,  1013,  1014,  1015,   449,     0,\n       0,     0,  1016,  1017,  1018,  1019,  1020,   450,     0,     0,\n       0,   452,     0,   453,   145,   454,     0,   455,     0,     0,\n       0,   456,     0,     0,     0,     0,   458,     0,     0,     0,\n       0,     0,     0,   462,     0,   146,   147,   464,     0,   148,\n       0,    20,   466,     0,     0,     0,   468,     0,     0,     0,\n       0,   471,   130,   472,     0,     0,   473,   151,   152,     0,\n     153,   480,     0,     0,     0,   482,     0,   154,   484,     0,\n     485,     0,     0,     0,     0,   488,     0,    43,     0,   490,\n       0,     0,     0,    46,     0,   494,     0,     0,   495,   156,\n       0,   141,   498,     0,     0,   178,     0,     0,   499,     0,\n       0,   145,   501,     0,     0,  1075,   157,     0,   158,     0,\n       0,     0,     0,     0,  1079,  1214,  1080,  1081,     0,     0,\n    1082,     0,     0,   147,    17,     0,   148,     0,    20,  1089,\n    1090,     0,     0,     0,     0,     0,     0,   149,     0,   130,\n    1098,     0,     0,    32,   151,   152,     0,   153,     0,    34,\n      35,     0,   133,   414,   154,    37,     0,     0,   419,  1104,\n       0,  1105,     0,     0,    43,     0,     0,     0,     0,     0,\n      46,     0,     0,   128,    47,     0,   156,     0,   141,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,   157,     0,   158,     0,     0,     0,   145,\n       0,     0,   885,     0,     0,     0,     0,     0,     0,  1169,\n       0,     0,     0,     0,     0,  1170,     0,     0,     0,     0,\n     146,   147,    17,     0,   148,    19,    20,     0,  1192,     0,\n       0,  1193,     0,     0,  1194,     0,  1195,   130,     0,  1196,\n       0,     0,   151,   152,     0,   153,    33,     0,     0,     0,\n       0,  1199,  1200,  1201,  1202,  1203,  1204,     0,     0,     0,\n    1205,     0,    43,     0,   432,     0,     0,  1206,    46,     0,\n       0,   434,     0,     0,     0,     0,   141,     0,     0,     0,\n     444,   445,     0,     0,   447,   448,     0,     0,     0,     0,\n       0,     0,     0,   158,  1239,     0,     0,     0,     0,     0,\n     817,     0,     0,     0,  1241,     0,     0,     0,     0,  1242,\n       0,     0,   457,     0,     0,     0,     0,     0,     0,   460,\n     461,     0,   145,     0,   463,  1262,     0,     0,   465,     0,\n       0,     0,     0,     0,   467,     0,     0,   469,   470,     0,\n       0,     0,     0,     0,   147,  1282,     0,   148,  1283,    20,\n       0,  1284,   481,     0,  1285,     0,   483,     0,   149,     0,\n     130,   486,   487,     0,     0,   151,   152,     0,   153,     0,\n     491,   492,   493,   133,     0,  1315,     0,     0,     0,   496,\n    1316,     0,     0,  1317,     0,    43,     0,     0,     0,   500,\n       0,    46,     0,     0,   128,   504,     0,   156,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,   158,     0,     0,     0,\n       0,     0,     0,   903,     0,     0,     0,     0,     0,   549,\n     550,     0,   551,     0,   552,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,    -4,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,   560,     0,     0,     0,     0,     0,\n       0,     0,   561,   949,    12,    13,    14,    15,    16,     0,\n       0,    17,    18,     0,    19,    20,    21,    22,    23,    24,\n      25,    26,    27,    28,     0,    29,  -753,    30,    31,     0,\n      32,     0,   566,  -754,     0,    33,    34,    35,     0,  -754,\n      36,     0,    37,    38,     0,    39,  -754,    40,    41,    42,\n    -754,    43,   145,    44,  -756,    45,     0,    46,   145,  -751,\n    -752,    47,    48,     0,    49,  -755,    50,    51,     0,     0,\n       0,     0,     0,     0,   147,     0,     0,   148,     0,    20,\n     147,    52,     0,   148,     0,     0,    53,     0,   145,     0,\n     130,     0,     0,     0,   149,   151,   152,     0,   153,     0,\n       0,   151,   152,     0,   153,     0,     0,     0,     0,   133,\n     147,   647,     0,   148,     0,    43,     0,     0,     0,     0,\n       0,    46,     0,     0,   149,     0,     0,   156,     0,   141,\n     128,   151,   152,   156,   153,     0,     0,     0,     0,   133,\n     145,     0,     0,     0,     0,     0,   158,     0,     0,     0,\n       0,     0,   158,   810,     0,     0,     0,  1058,     0,   668,\n     128,     0,   147,   156,     0,   148,     0,     0,     0,     0,\n       0,  1059,  1060,   685,  1061,     0,   149,  1062,     0,     0,\n       0,     0,   158,   151,   152,     0,   153,     0,     0,   681,\n       0,    17,     0,   154,    19,    20,     0,     0,  1030,     0,\n       0,     0,     0,     0,     0,     0,   130,     0,  1063,     0,\n       0,     0,   128,     0,     0,   156,    34,    35,     0,   133,\n       0,     0,    37,     0,     0,   734,     0,   736,     0,     0,\n       0,    43,     0,     0,   158,     0,     0,    46,     0,   126,\n       0,     0,    48,     0,     0,   141,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,   871,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,   179,     0,     0,     0,   947,\n     948,   181,   310,     0,     0,     0,     0,     0,     0,     0,\n     952,   182,   183,   184,   185,   186,   187,   188,   189,   190,\n     191,   192,   193,   194,   195,   196,   197,   198,   199,   200,\n     201,   202,   203,   204,   205,   206,   207,   208,   209,   210,\n     211,   212,   213,   214,   215,   216,   217,   218,   219,   220,\n     221,   222,   223,   224,   225,   226,   227,   228,   229,   230,\n     231,   232,   233,   234,   235,   236,   237,   238,   239,   240,\n     241,   242,   243,   244,   245,   246,   247,   248,   249,   250,\n     251,   252,   253,   254,   255,   256,   257,   258,   259,   260,\n       0,     0,     0,     0,     0,     0,   682,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,   179,     0,     0,     0,     0,     0,   181,   310,     0,\n       0,     0,     0,     0,     0,  1021,  1022,   182,   183,   184,\n     185,   186,   187,   188,   189,   190,   191,   192,   193,   194,\n     195,   196,   197,   198,   199,   200,   201,   202,   203,   204,\n     205,   206,   207,   208,   209,   210,   211,   212,   213,   214,\n     215,   216,   217,   218,   219,   220,   221,   222,   223,   224,\n     225,   226,   227,   228,   229,   230,   231,   232,   233,   234,\n     235,   236,   237,   238,   239,   240,   241,   242,   243,   244,\n     245,   246,   247,   248,   249,   250,   251,   252,   253,   254,\n     255,   256,   257,   258,   259,   260,     0,     0,     0,     0,\n       0,     0,  1128,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,  1078,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,  1084,     0,     0,     0,  1088,     0,     0,     0,     0,\n    1091,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,  1099,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,   179,     0,     0,     0,\n       0,     0,     0,   273,     0,  1154,     0,     0,     0,     0,\n       0,  1159,   182,   183,   184,   185,   186,   187,   188,   189,\n     190,   191,   192,   193,   194,   195,   196,   197,   198,   199,\n     200,   201,   202,   203,   204,   205,   206,   207,   208,   209,\n     210,   211,   212,   213,   214,   215,   754,   217,   218,   219,\n     220,   221,   222,   223,   224,   225,   226,   227,   228,   229,\n     230,   231,   232,   233,   234,   235,   236,   237,   238,   239,\n     240,   241,   242,   243,   244,   245,   246,     0,   248,     0,\n       0,     0,     0,   253,     0,     0,     0,     0,   258,   259,\n     260,     0,     0,     0,     0,     0,     0,   755,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,  1263,     0,     0,  1264,   179,  1265,     0,\n    1266,   180,   286,   181,   287,   288,     0,     0,     0,   289,\n     290,   291,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,   429,   286,   181,   287,\n     288,     0,     0,     0,   289,   290,   291,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260,   179,     0,     0,\n       0,   180,     0,   181,   273,     0,     0,     0,     0,     0,\n       0,     0,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,   180,     0,   181,   310,\n       0,     0,     0,     0,     0,     0,     0,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260,   179,     0,     0,\n       0,     0,     0,   181,   310,     0,     0,   477,     0,     0,\n       0,     0,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,     0,     0,   181,   310,\n       0,     0,  1236,     0,     0,     0,     0,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260,   179,     0,     0,\n       0,   180,     0,   181,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,   182,   183,   184,   185,   186,   187,   188,\n     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,\n     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,\n     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,\n     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,\n     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,\n     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,\n     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,\n     259,   260,   179,     0,     0,     0,     0,     0,   181,   310,\n       0,     0,     0,     0,     0,     0,     0,     0,   182,   183,\n     184,   185,   186,   187,   188,   189,   190,   191,   192,   193,\n     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,\n     204,   205,   206,   207,   208,   209,   210,   211,   212,   213,\n     214,   215,   216,   217,   218,   219,   220,   221,   222,   223,\n     224,   225,   226,   227,   228,   229,   230,   231,   232,   233,\n     234,   235,   236,   237,   238,   239,   240,   241,   242,   243,\n     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,\n     254,   255,   256,   257,   258,   259,   260\n};\n\nstatic const yytype_int16 yycheck[] =\n{\n       4,   726,    89,   725,   726,     9,    10,   711,    12,    89,\n      14,    15,   105,    17,    18,    19,    20,     5,    22,    23,\n     724,   725,    89,     5,    28,   559,    89,    89,    32,    33,\n      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,\n      44,    45,    46,    47,    48,    49,     5,   722,    52,   706,\n      89,    86,   719,    89,   721,     5,    89,   724,   711,     8,\n       8,    89,    89,   725,   726,   393,     8,    75,     5,    17,\n      12,   724,   725,    96,    85,    56,    96,    23,     5,     8,\n       7,    84,   104,    64,   106,     8,    90,    99,   100,   101,\n     102,   103,   420,   105,   114,  1106,  1107,   109,   632,   111,\n       0,    82,     8,   115,   116,    89,     8,    76,   120,   121,\n       5,   123,     8,   766,     5,    17,     7,     5,    14,     7,\n      11,    42,   126,    11,   128,     5,   130,     7,   132,   133,\n     134,   135,     5,   104,     7,     8,    82,   141,     5,   143,\n       7,   145,   146,   147,   148,   149,    94,   151,   152,   153,\n     154,    81,   156,   157,   158,   107,   108,   107,   107,    88,\n     720,    87,   722,   723,    93,   177,   726,   727,     5,    92,\n       7,   104,    95,   106,   178,     9,    10,   104,    12,   106,\n      14,    15,    88,    17,    18,    19,    20,    93,    22,    23,\n       8,     5,    83,     7,    28,    70,     8,    11,    32,    33,\n      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,\n      44,    45,    46,    47,    48,    49,    14,   105,    52,   100,\n     101,   102,   103,    22,   104,    20,   106,     5,   109,     7,\n     111,   711,    31,    11,   115,   116,    31,   104,   104,   106,\n     121,   721,   123,    42,   724,   725,   719,    31,   721,   722,\n     683,   724,   725,   726,     8,   104,    21,   951,    42,   104,\n     104,    31,   107,    33,    34,   104,    31,   104,    67,   106,\n      88,     5,    67,     7,    73,    93,    88,    42,    73,    94,\n      95,    93,    97,    67,     5,     5,     7,     7,     8,    73,\n      11,   105,   126,   104,   128,     8,   130,    67,   132,   133,\n     134,   135,    67,    68,    17,    18,   105,   141,    73,   143,\n     105,   145,   146,   147,   148,   149,    81,   151,   152,   153,\n     154,   105,   156,   157,   158,   758,   759,   105,   104,     8,\n     106,    85,   104,    87,   106,   105,    90,    16,    17,    18,\n     105,    96,   104,    98,    99,   100,   101,   102,   103,   104,\n     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,\n     115,   116,   117,   118,   119,   120,   121,   122,   123,   107,\n     393,    27,    31,   393,    30,    31,    30,    84,   104,    86,\n     106,   474,    89,  1077,    91,   397,    42,   399,   400,   401,\n      31,   403,   104,   405,   106,    51,    31,   420,   107,    55,\n     420,    55,   104,    28,   106,    64,    31,   104,    67,   106,\n     414,    67,    71,   107,   108,   419,    31,    73,   104,    75,\n    1142,   104,    78,    77,    78,    81,    67,    42,   432,   103,\n     434,  1125,    67,  1127,    59,    31,    71,    33,    34,   107,\n     444,   445,    67,   447,   448,     5,   105,     7,    63,   105,\n     103,   105,    67,   457,   725,   726,   460,   461,    73,   463,\n     105,   465,   474,   467,   105,   469,   470,  1142,  1028,    31,\n     105,    67,   565,   105,   104,  1142,   106,   481,     5,   483,\n    1142,   108,   486,   487,   104,     4,   106,   491,   492,   493,\n     105,   503,   496,   104,    54,   106,   500,   104,    24,   106,\n     504,    97,   105,  1197,  1198,    67,    25,    26,   109,   105,\n      29,   104,    32,   106,    74,   104,   397,   106,   399,   400,\n     401,    40,   403,   104,   405,   106,    45,   104,    47,    48,\n     104,    50,   106,   105,    31,   628,    33,    34,    57,   105,\n      31,    60,  1236,   105,    85,   549,   550,   551,   552,  1010,\n    1011,    42,   645,   565,  1211,    31,   560,   561,    43,    44,\n      79,    37,   566,  1288,  1289,  1259,  1288,   104,  1290,   106,\n      67,     5,  1106,     7,  1268,   110,    67,    96,   111,    98,\n     395,  1141,    73,   104,  1288,  1289,  1290,   104,    62,    80,\n     104,    67,  1286,    14,   409,   410,   411,   412,   413,   107,\n     415,   416,   417,   418,   107,   112,   421,   422,   105,   104,\n     104,   106,   106,     5,   105,     7,   628,   107,   634,    11,\n      54,  1288,   503,  1290,   633,   104,  1288,   106,  1290,   105,\n     632,   635,   104,   645,   106,   722,   723,  1290,   393,   726,\n      74,   721,   397,   647,   399,   400,   401,  1207,   403,   104,\n     405,   106,   407,   127,   721,   129,   634,   131,   721,   752,\n     722,   723,  1142,     5,   726,   420,   140,   691,   142,  1142,\n     144,   104,    64,   106,   104,   104,   106,   106,   104,   683,\n     106,   685,   721,   687,   719,   721,     5,   722,   721,   724,\n     725,   726,   727,   721,   721,   104,   104,   106,   106,   703,\n     704,   175,  1092,   744,  1094,   652,   943,   654,   719,   720,\n     721,   722,   407,   724,   725,   726,   727,   728,   729,   722,\n     723,   946,  1208,   726,   727,   715,   729,   715,   964,   706,\n     734,   743,   736,   715,   738,   739,   706,  1103,   722,   723,\n     752,   706,   726,   727,   706,   729,   706,  1102,   503,   706,\n     762,   545,   711,   774,   758,   759,    89,  1192,  1123,   548,\n     719,   720,   721,   722,   723,   724,   725,   726,   727,   728,\n     729,   729,   726,   729,   711,  1094,  1111,   563,   715,   644,\n     717,   718,   719,   720,   721,   722,   723,   724,   725,   726,\n     727,   728,   729,   719,   720,   721,   722,   700,   724,   725,\n     726,   635,   728,  1244,   565,   742,   113,   744,  1288,  1289,\n    1290,   954,   702,    30,    31,  1288,   711,  1290,  1078,   735,\n     715,     4,   717,   718,   719,   720,   721,   722,   723,   724,\n     725,   726,   727,   728,   729,    -1,     5,   177,     7,   702,\n      -1,    -1,    11,    26,    27,    -1,    29,   742,    31,   744,\n      67,    27,    -1,   687,    30,    24,    73,    40,    75,    42,\n      -1,    78,   743,    32,    47,    48,    -1,    50,    -1,   703,\n     704,    -1,    55,    -1,    57,    51,    52,    53,    -1,    55,\n      -1,   762,    65,    31,    67,    -1,    -1,    -1,   105,     4,\n      73,    -1,    40,    76,    42,    -1,    79,    45,    81,    -1,\n      -1,    77,    78,    -1,   738,   739,    -1,    -1,   912,   913,\n      25,    26,    60,    96,    29,    98,    31,    49,    31,    67,\n      33,    34,   105,    55,    -1,    73,    -1,    42,    76,   105,\n      62,    -1,    47,    48,    66,    50,    -1,    -1,    -1,   694,\n      -1,  1028,    57,   947,   948,    -1,   761,    -1,   952,   423,\n     424,     4,    67,    -1,    67,    -1,    27,   105,    73,   433,\n      31,   435,   436,    -1,    79,    -1,    81,    -1,   442,   443,\n      -1,    42,   446,    26,    -1,    -1,    29,    -1,    31,    -1,\n      51,    96,    -1,    98,    55,    -1,    -1,    40,   743,    -1,\n     105,    -1,   105,    -1,    47,    48,    67,    50,  1010,  1011,\n      -1,    -1,    73,    -1,    57,    -1,    -1,   762,  1101,    -1,\n      81,    -1,    27,    -1,    67,    30,    -1,  1021,  1022,    -1,\n      73,    -1,    22,    76,    -1,  1028,    79,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,   105,    -1,    51,    52,    53,    39,\n      -1,    -1,    -1,    96,  1028,    98,    -1,    -1,    -1,    49,\n      -1,    -1,   105,    -1,  1058,  1059,  1060,  1061,  1062,  1063,\n      75,    61,    62,    78,    -1,    -1,    66,    -1,    -1,    69,\n      -1,    -1,    -1,    -1,  1078,    75,    -1,    -1,   912,   913,\n    1084,    -1,    -1,    -1,  1088,    -1,    -1,  1091,    -1,  1101,\n     105,  1102,  1103,    -1,    -1,  1099,    -1,    -1,    -1,   573,\n      -1,    -1,   576,   577,    -1,    -1,   580,  1142,    -1,   583,\n      -1,    -1,   586,    -1,    -1,   589,    -1,    -1,   592,   934,\n     935,   595,    -1,    -1,   598,    -1,    -1,   601,    -1,    -1,\n     604,  1142,    -1,   607,    -1,    -1,   610,    -1,    -1,   613,\n     614,   615,   616,  1102,  1103,   619,    -1,    -1,   622,    -1,\n    1154,  1244,    -1,    27,    -1,  1159,    30,    31,    -1,    -1,\n      -1,    -1,    -1,    -1,   638,  1102,  1103,    -1,    42,  1106,\n    1107,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,    53,\n      -1,    55,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    65,    -1,    67,    -1,   669,   670,   671,  1291,  1210,\n    1211,    -1,    -1,    -1,  1141,  1142,   680,  1102,  1103,    -1,\n      -1,  1106,  1107,    -1,    -1,    -1,  1220,    -1,    -1,   693,\n      -1,    -1,    -1,    -1,  1058,  1059,  1060,  1061,  1062,  1063,\n      -1,   105,  1244,    -1,   708,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,  1141,  1142,    -1,  1208,\n      -1,  1210,  1211,  1288,  1289,  1010,  1011,    -1,    -1,  1263,\n    1264,  1265,  1266,    -1,    -1,    -1,   740,   741,    -1,    -1,\n    1207,  1208,  1209,  1210,  1211,    -1,    -1,    -1,  1093,  1291,\n    1095,  1096,  1097,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,   765,    -1,    -1,   768,   769,   770,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,   779,    -1,    -1,    -1,    -1,\n      -1,    -1,  1207,  1208,  1209,  1210,  1211,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,   805,   806,    -1,    -1,   809,    -1,  1092,    -1,  1094,\n     814,   815,   816,    -1,    -1,    -1,    -1,   821,    -1,    -1,\n      -1,    -1,    -1,    -1,   828,    -1,    -1,    -1,    -1,   833,\n      -1,    -1,    -1,    -1,    -1,    -1,   840,   841,   842,   843,\n     844,   845,   846,    -1,    -1,   849,    -1,    -1,    -1,    -1,\n     854,   855,   856,   857,   858,    -1,  1220,    -1,    -1,   863,\n     864,    -1,    -1,   867,    -1,    -1,   870,    -1,    -1,    -1,\n      -1,   875,   876,    -1,    -1,   879,    -1,    -1,    -1,    -1,\n     884,    -1,    -1,    -1,    -1,   889,   890,   891,   892,   893,\n     894,   895,    -1,    -1,    -1,    -1,   900,    -1,    -1,    -1,\n      -1,    -1,    -1,   907,   908,   909,   910,   911,    -1,    -1,\n      -1,    -1,    -1,    -1,   918,   919,   920,   921,   284,    -1,\n      -1,    -1,   926,   927,   928,   929,   930,   293,    -1,    -1,\n      -1,   297,    -1,   299,     4,   301,    -1,   303,    -1,    -1,\n      -1,   307,    -1,    -1,    -1,    -1,   312,    -1,    -1,    -1,\n      -1,    -1,    -1,   319,    -1,    25,    26,   323,    -1,    29,\n      -1,    31,   328,    -1,    -1,    -1,   332,    -1,    -1,    -1,\n      -1,   337,    42,   339,    -1,    -1,   342,    47,    48,    -1,\n      50,   347,    -1,    -1,    -1,   351,    -1,    57,   354,    -1,\n     356,    -1,    -1,    -1,    -1,   361,    -1,    67,    -1,   365,\n      -1,    -1,    -1,    73,    -1,   371,    -1,    -1,   374,    79,\n      -1,    81,   378,    -1,    -1,    92,    -1,    -1,   384,    -1,\n      -1,     4,   388,    -1,    -1,  1029,    96,    -1,    98,    -1,\n      -1,    -1,    -1,    -1,  1038,   105,  1040,  1041,    -1,    -1,\n    1044,    -1,    -1,    26,    27,    -1,    29,    -1,    31,  1053,\n    1054,    -1,    -1,    -1,    -1,    -1,    -1,    40,    -1,    42,\n    1064,    -1,    -1,    46,    47,    48,    -1,    50,    -1,    52,\n      53,    -1,    55,   150,    57,    58,    -1,    -1,   155,  1083,\n      -1,  1085,    -1,    -1,    67,    -1,    -1,    -1,    -1,    -1,\n      73,    -1,    -1,    76,    77,    -1,    79,    -1,    81,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    96,    -1,    98,    -1,    -1,    -1,     4,\n      -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,    -1,  1133,\n      -1,    -1,    -1,    -1,    -1,  1139,    -1,    -1,    -1,    -1,\n      25,    26,    27,    -1,    29,    30,    31,    -1,  1152,    -1,\n      -1,  1155,    -1,    -1,  1158,    -1,  1160,    42,    -1,  1163,\n      -1,    -1,    47,    48,    -1,    50,    51,    -1,    -1,    -1,\n      -1,  1175,  1176,  1177,  1178,  1179,  1180,    -1,    -1,    -1,\n    1184,    -1,    67,    -1,   261,    -1,    -1,  1191,    73,    -1,\n      -1,   268,    -1,    -1,    -1,    -1,    81,    -1,    -1,    -1,\n     277,   278,    -1,    -1,   281,   282,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    98,  1218,    -1,    -1,    -1,    -1,    -1,\n     105,    -1,    -1,    -1,  1228,    -1,    -1,    -1,    -1,  1233,\n      -1,    -1,   309,    -1,    -1,    -1,    -1,    -1,    -1,   316,\n     317,    -1,     4,    -1,   321,  1249,    -1,    -1,   325,    -1,\n      -1,    -1,    -1,    -1,   331,    -1,    -1,   334,   335,    -1,\n      -1,    -1,    -1,    -1,    26,  1269,    -1,    29,  1272,    31,\n      -1,  1275,   349,    -1,  1278,    -1,   353,    -1,    40,    -1,\n      42,   358,   359,    -1,    -1,    47,    48,    -1,    50,    -1,\n     367,   368,   369,    55,    -1,  1299,    -1,    -1,    -1,   376,\n    1304,    -1,    -1,  1307,    -1,    67,    -1,    -1,    -1,   386,\n      -1,    73,    -1,    -1,    76,   392,    -1,    79,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    98,    -1,    -1,    -1,\n      -1,    -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,   426,\n     427,    -1,   429,    -1,   431,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,     0,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,   451,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,   459,   749,    20,    21,    22,    23,    24,    -1,\n      -1,    27,    28,    -1,    30,    31,    32,    33,    34,    35,\n      36,    37,    38,    39,    -1,    41,    42,    43,    44,    -1,\n      46,    -1,   489,    49,    -1,    51,    52,    53,    -1,    55,\n      56,    -1,    58,    59,    -1,    61,    62,    63,    64,    65,\n      66,    67,     4,    69,    70,    71,    -1,    73,     4,    75,\n      76,    77,    78,    -1,    80,    81,    82,    83,    -1,    -1,\n      -1,    -1,    -1,    -1,    26,    -1,    -1,    29,    -1,    31,\n      26,    97,    -1,    29,    -1,    -1,   102,    -1,     4,    -1,\n      42,    -1,    -1,    -1,    40,    47,    48,    -1,    50,    -1,\n      -1,    47,    48,    -1,    50,    -1,    -1,    -1,    -1,    55,\n      26,   568,    -1,    29,    -1,    67,    -1,    -1,    -1,    -1,\n      -1,    73,    -1,    -1,    40,    -1,    -1,    79,    -1,    81,\n      76,    47,    48,    79,    50,    -1,    -1,    -1,    -1,    55,\n       4,    -1,    -1,    -1,    -1,    -1,    98,    -1,    -1,    -1,\n      -1,    -1,    98,   105,    -1,    -1,    -1,    21,    -1,   105,\n      76,    -1,    26,    79,    -1,    29,    -1,    -1,    -1,    -1,\n      -1,    35,    36,   630,    38,    -1,    40,    41,    -1,    -1,\n      -1,    -1,    98,    47,    48,    -1,    50,    -1,    -1,   105,\n      -1,    27,    -1,    57,    30,    31,    -1,    -1,   944,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    42,    -1,    72,    -1,\n      -1,    -1,    76,    -1,    -1,    79,    52,    53,    -1,    55,\n      -1,    -1,    58,    -1,    -1,   682,    -1,   684,    -1,    -1,\n      -1,    67,    -1,    -1,    98,    -1,    -1,    73,    -1,    75,\n      -1,    -1,    78,    -1,    -1,    81,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   105,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,   746,\n     747,    10,    11,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n     757,    20,    21,    22,    23,    24,    25,    26,    27,    28,\n      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,\n      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,\n      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,\n      59,    60,    61,    62,    63,    64,    65,    66,    67,    68,\n      69,    70,    71,    72,    73,    74,    75,    76,    77,    78,\n      79,    80,    81,    82,    83,    84,    85,    86,    87,    88,\n      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,\n      -1,    -1,    -1,    -1,    -1,    -1,   105,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,     4,    -1,    -1,    -1,    -1,    -1,    10,    11,    -1,\n      -1,    -1,    -1,    -1,    -1,   932,   933,    20,    21,    22,\n      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,\n      33,    34,    35,    36,    37,    38,    39,    40,    41,    42,\n      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,\n      53,    54,    55,    56,    57,    58,    59,    60,    61,    62,\n      63,    64,    65,    66,    67,    68,    69,    70,    71,    72,\n      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,\n      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,\n      93,    94,    95,    96,    97,    98,    -1,    -1,    -1,    -1,\n      -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,  1034,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,  1048,    -1,    -1,    -1,  1052,    -1,    -1,    -1,    -1,\n    1057,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,  1076,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,\n      -1,    -1,    -1,    11,    -1,  1112,    -1,    -1,    -1,    -1,\n      -1,  1118,    20,    21,    22,    23,    24,    25,    26,    27,\n      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,\n      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,\n      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,\n      58,    59,    60,    61,    62,    63,    64,    65,    66,    67,\n      68,    69,    70,    71,    72,    73,    74,    75,    76,    77,\n      78,    79,    80,    81,    82,    83,    84,    -1,    86,    -1,\n      -1,    -1,    -1,    91,    -1,    -1,    -1,    -1,    96,    97,\n      98,    -1,    -1,    -1,    -1,    -1,    -1,   105,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,  1250,    -1,    -1,  1253,     4,  1255,    -1,\n    1257,     8,     9,    10,    11,    12,    -1,    -1,    -1,    16,\n      17,    18,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,     8,     9,    10,    11,\n      12,    -1,    -1,    -1,    16,    17,    18,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98,     4,    -1,    -1,\n      -1,     8,    -1,    10,    11,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,     8,    -1,    10,    11,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98,     4,    -1,    -1,\n      -1,    -1,    -1,    10,    11,    -1,    -1,    14,    -1,    -1,\n      -1,    -1,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,    -1,    -1,    10,    11,\n      -1,    -1,    14,    -1,    -1,    -1,    -1,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98,     4,    -1,    -1,\n      -1,     8,    -1,    10,    -1,    -1,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    20,    21,    22,    23,    24,    25,    26,\n      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n      97,    98,     4,    -1,    -1,    -1,    -1,    -1,    10,    11,\n      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    20,    21,\n      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,\n      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,\n      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,\n      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,\n      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,\n      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,\n      92,    93,    94,    95,    96,    97,    98\n};\n\n  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing\n     symbol of state STATE-NUM.  */\nstatic const yytype_uint16 yystos[] =\n{\n       0,   114,   120,   124,   419,   441,     0,     5,     7,    54,\n      74,   418,    20,    21,    22,    23,    24,    27,    28,    30,\n      31,    32,    33,    34,    35,    36,    37,    38,    39,    41,\n      43,    44,    46,    51,    52,    53,    56,    58,    59,    61,\n      63,    64,    65,    67,    69,    71,    73,    77,    78,    80,\n      82,    83,    97,   102,   130,   140,   142,   144,   147,   149,\n     151,   153,   170,   176,   190,   202,   214,   222,   227,   229,\n     238,   241,   243,   245,   247,   339,   342,   345,   347,   350,\n     353,   359,   362,   430,   431,   432,   433,   434,   435,   436,\n     437,   438,   418,   420,   420,   420,   420,   420,   420,   420,\n     420,   420,   420,   420,   420,   420,   420,   420,   420,   420,\n     420,   420,   420,   420,   420,   420,   420,   420,   420,   420,\n     420,   420,   420,   420,   402,   402,    75,   194,    76,   192,\n      42,   183,    49,    55,    62,    66,   204,   209,   224,   356,\n     440,    81,   335,    70,   157,     4,    25,    26,    29,    40,\n      45,    47,    48,    50,    57,    60,    79,    96,    98,   249,\n     254,   257,   261,   264,   267,   273,   277,   279,   283,   299,\n     304,   305,   307,   308,   310,   439,   407,   420,   419,     4,\n       8,    10,    20,    21,    22,    23,    24,    25,    26,    27,\n      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,\n      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,\n      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,\n      58,    59,    60,    61,    62,    63,    64,    65,    66,    67,\n      68,    69,    70,    71,    72,    73,    74,    75,    76,    77,\n      78,    79,    80,    81,    82,    83,    84,    85,    86,    87,\n      88,    89,    90,    91,    92,    93,    94,    95,    96,    97,\n      98,   115,   116,   119,   395,   425,   426,   427,   428,   123,\n     395,   169,   395,    11,   116,   189,   397,   428,   429,   141,\n     395,    88,    93,   116,   338,   340,     9,    11,    12,    16,\n      17,    18,   116,   148,   422,   424,   425,   246,   422,   150,\n     422,   242,   422,   240,   422,    17,   116,   201,   203,   390,\n      11,   116,   361,   363,   396,   425,    88,    93,   116,   341,\n     343,    94,   116,   349,   351,   390,    18,   116,   346,   348,\n     390,   391,   129,   422,    92,    95,   116,   352,   354,   146,\n     422,   116,   226,   371,   372,   373,   116,   237,   239,   391,\n     116,   143,   394,   428,   344,   422,   152,   422,    88,    93,\n     116,   228,   230,    12,   116,   139,   160,    85,    87,    90,\n     116,   175,   177,   116,   358,   360,   369,   396,   244,   422,\n      16,    17,    18,   116,   221,   223,   392,   393,   213,   422,\n     403,   418,   429,   420,   402,   420,   402,   420,   402,   420,\n     420,   208,   420,   420,   402,   420,   402,   420,   402,   420,\n     420,   420,   420,   420,   419,   420,   420,   420,   420,   419,\n     420,   420,   420,   104,   104,   402,   104,   106,   417,     8,\n     408,   424,   419,   104,   419,   104,   104,   106,   171,   104,\n     106,   398,   399,   401,   419,   419,   104,   419,   419,   398,\n     398,   423,   398,   398,   398,   398,   398,   419,   398,   364,\n     419,   419,   398,   419,   398,   419,   398,   419,   398,   419,\n     419,   398,   398,   398,   107,   374,   375,    14,   377,   378,\n     398,   419,   398,   419,   398,   398,   419,   419,   398,   161,\n     398,   419,   419,   419,   398,   398,   419,   370,   398,   398,\n     419,   398,   404,   405,   419,   195,   397,   191,   395,   182,\n     422,   205,   422,   355,   422,   210,   422,   365,   422,   334,\n     422,   155,   160,   276,   395,   272,   395,   266,   395,   253,\n     395,   248,   395,   258,   395,   260,   395,   263,   395,   309,\n     395,   282,   397,   298,   395,   278,   395,   402,   402,   419,\n     419,   419,   419,   117,   402,   402,   402,   402,   402,   402,\n     419,   419,   396,   376,   107,   379,   419,   368,   104,   106,\n     410,   406,   422,   104,   106,   196,   104,   104,   106,   184,\n     104,   106,   206,   104,   106,   357,   104,   106,   211,   104,\n     106,   225,   104,   106,   336,   104,   106,   158,   104,   106,\n     280,   104,   106,   274,   104,   106,   268,   104,   106,   255,\n     104,   106,   250,   104,   104,   104,   104,   106,   311,   104,\n     106,   284,   104,   106,   302,   280,   306,   306,   416,   409,\n     103,   121,   122,   125,   126,    83,   173,   105,   400,   144,\n     382,   374,   378,   380,   396,   107,   366,   419,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   105,   192,\n     249,   252,   254,   257,   261,   264,   267,   277,   279,   283,\n     356,   105,   105,   396,   103,   419,   131,    82,   128,   130,\n     144,   131,   128,   142,   420,   105,   402,   105,   108,   381,\n     382,   396,   411,    24,    32,   197,   198,   215,   217,   231,\n     233,   193,   105,   207,   207,   212,   207,   337,   159,   281,\n     275,   269,   256,   251,   259,   262,   265,   312,   285,   303,\n     402,   402,   402,   402,   419,   407,   419,     8,    43,    44,\n     132,   136,   145,   420,   145,   402,    88,    93,   116,   172,\n     174,     5,   421,   375,    54,   105,   403,   412,   414,   415,\n     427,   420,   420,   105,   190,   199,   200,   202,   204,   209,\n     224,   227,   229,   402,   232,   105,   151,   153,   176,   194,\n     245,   247,   105,   151,   153,   241,   243,   105,   105,   151,\n     153,   214,   241,   243,   105,   105,   151,   153,   105,   151,\n     153,   105,   151,   153,   176,   183,   335,   339,   342,   356,\n     105,   151,   153,   176,   183,   252,   335,   105,   151,   153,\n     176,   183,   247,   254,   257,   261,   264,   267,   270,   271,\n     273,   277,   279,   335,   339,   342,   105,   151,   153,   176,\n     183,   192,   249,   252,   299,   310,   335,   339,   345,   356,\n     105,   151,   153,   176,   192,   249,   252,   299,   310,   105,\n     151,   153,   176,   183,   194,   245,   247,   335,   339,   342,\n     356,   105,   151,   153,   176,   183,   194,   245,   247,   335,\n     339,   347,   350,   353,   356,   105,   151,   153,   176,   183,\n     192,   249,   252,   299,   310,   335,   339,   347,   350,   353,\n     356,   359,   362,   105,   151,   153,   176,   183,   192,   249,\n     252,   356,    21,    68,   105,   151,   153,   176,   183,   288,\n     293,   335,   105,   151,   153,   176,   183,   192,   249,   305,\n     308,   417,     8,   118,   420,   420,   402,   402,   147,   149,\n     151,   153,   154,   156,   127,   422,   154,   419,   419,   398,\n     383,   396,   419,   407,   407,   234,   395,   218,   422,   402,\n     194,   402,   402,   402,   216,   233,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,\n     420,   420,   402,   402,   402,   402,   402,   402,   402,   402,\n     402,   419,   419,   133,   395,   135,   395,   162,   163,   157,\n     398,   162,   109,   421,   104,   106,   413,   413,   104,   106,\n     235,   104,   106,   219,   217,   116,   291,   292,   369,   116,\n     286,   287,   369,   104,   104,   106,   137,   105,    21,    35,\n      36,    38,    41,    72,   164,   166,   179,   186,   192,   249,\n     252,   296,   301,   310,   314,   402,   105,   110,   419,   402,\n     402,   402,   402,   104,   419,   104,   106,   289,   419,   402,\n     402,   419,   420,   420,   420,   420,   420,   420,   402,   419,\n     421,   416,   236,   220,   402,   402,   134,   138,   116,   294,\n     295,   366,   367,   165,   395,   116,   313,   316,   367,   178,\n     395,   185,   395,   300,   395,    85,   384,   389,   105,   105,\n     151,   153,   176,   183,   238,   105,   151,   153,   176,   183,\n     222,   297,   290,   105,   140,   144,   151,   153,   105,   140,\n     151,   153,   104,   368,   419,   104,   106,   167,   104,   419,\n     104,   106,   180,   104,   106,   187,   302,   421,   421,   402,\n     402,   105,   151,   153,   176,   183,   252,   273,   299,   310,\n     335,   105,   151,   153,   183,   247,   339,   342,   345,   347,\n     350,   356,   402,   402,   402,   402,   402,   111,   107,   402,\n     402,   402,   402,   402,   402,   402,   402,   297,   168,   315,\n     181,   188,   421,   421,   105,   105,   151,   153,   170,   176,\n      37,   105,   151,   153,   105,   151,   153,   176,   183,   105,\n     151,   153,   176,   183,   190,   112,    14,   385,   386,   402,\n     420,   402,   402,   421,   387,    84,    86,    89,    91,   317,\n     318,   319,   321,   322,   323,   326,   327,   330,   331,   107,\n     386,   396,   402,   419,   419,   419,   419,   421,   388,   104,\n     106,   320,   104,   106,   324,   104,   106,   328,   104,   106,\n     332,   421,   402,   402,   402,   402,   107,   105,   325,   329,\n     333,   421,   105,   245,   247,   339,   342,   347,   350,   356,\n     359,   105,   245,   247,   356,   359,   105,   194,   245,   247,\n     339,   342,   347,   350,   396,   402,   402,   402\n};\n\n  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */\nstatic const yytype_uint16 yyr1[] =\n{\n       0,   113,   114,   114,   114,   115,   116,   117,   118,   117,\n     119,   120,   121,   122,   122,   122,   122,   123,   124,   125,\n     126,   126,   126,   127,   128,   129,   130,   131,   131,   131,\n     132,   133,   134,   134,   134,   134,   134,   135,   136,   137,\n     137,   138,   138,   138,   138,   139,   140,   141,   142,   143,\n     144,   145,   145,   145,   145,   145,   146,   147,   148,   149,\n     150,   151,   152,   153,   154,   155,   156,   156,   157,   158,\n     158,   159,   159,   159,   161,   160,   160,   162,   163,   163,\n     164,   164,   164,   164,   164,   164,   164,   164,   164,   164,\n     165,   166,   167,   167,   168,   168,   168,   168,   168,   169,\n     170,   171,   171,   172,   173,   173,   174,   174,   174,   175,\n     176,   177,   177,   177,   177,   178,   179,   180,   180,   181,\n     181,   181,   181,   181,   182,   183,   184,   184,   185,   186,\n     187,   187,   188,   188,   188,   188,   188,   188,   189,   190,\n     191,   192,   193,   193,   193,   193,   193,   193,   193,   194,\n     195,   196,   196,   197,   197,   197,   198,   198,   198,   198,\n     198,   198,   198,   198,   198,   199,   200,   201,   202,   203,\n     203,   204,   205,   206,   206,   207,   207,   207,   207,   207,\n     208,   209,   210,   211,   211,   212,   212,   212,   212,   212,\n     212,   213,   214,   215,   216,   216,   217,   218,   219,   219,\n     220,   220,   220,   220,   220,   220,   221,   222,   223,   223,\n     224,   225,   225,   226,   227,   228,   229,   230,   230,   230,\n     231,   232,   232,   233,   234,   235,   235,   236,   236,   236,\n     236,   236,   236,   237,   238,   239,   239,   240,   241,   242,\n     243,   244,   245,   246,   247,   248,   249,   250,   250,   251,\n     251,   251,   251,   251,   251,   251,   251,   251,   252,   252,\n     252,   252,   252,   252,   252,   252,   253,   254,   255,   255,\n     256,   256,   256,   256,   256,   256,   256,   256,   256,   256,\n     256,   256,   256,   256,   257,   258,   259,   259,   259,   259,\n     259,   259,   259,   259,   259,   259,   259,   259,   260,   261,\n     262,   262,   262,   262,   262,   262,   262,   262,   262,   262,\n     262,   262,   262,   262,   263,   264,   265,   265,   265,   265,\n     265,   265,   265,   265,   265,   265,   265,   265,   265,   265,\n     265,   265,   265,   265,   266,   267,   268,   268,   269,   269,\n     269,   269,   269,   269,   269,   269,   269,   269,   270,   270,\n     271,   271,   271,   271,   271,   271,   271,   272,   273,   274,\n     274,   275,   275,   275,   275,   275,   275,   275,   276,   277,\n     278,   279,   280,   280,   281,   281,   281,   281,   281,   281,\n     281,   281,   281,   282,   283,   284,   284,   285,   285,   285,\n     285,   285,   285,   285,   285,   286,   286,   287,   288,   289,\n     289,   290,   290,   290,   290,   290,   290,   290,   290,   290,\n     290,   290,   291,   291,   292,   293,   294,   294,   295,   296,\n     297,   297,   297,   297,   297,   297,   297,   297,   297,   297,\n     298,   299,   300,   301,   302,   302,   303,   303,   303,   303,\n     303,   303,   303,   303,   303,   304,   305,   306,   306,   306,\n     306,   306,   307,   308,   309,   310,   311,   311,   312,   312,\n     312,   312,   312,   312,   312,   312,   312,   313,   314,   315,\n     315,   315,   315,   316,   316,   317,   317,   318,   319,   320,\n     320,   321,   321,   321,   322,   323,   324,   324,   325,   325,\n     325,   325,   325,   325,   325,   325,   325,   326,   327,   328,\n     328,   329,   329,   329,   329,   329,   330,   331,   332,   332,\n     333,   333,   333,   333,   333,   333,   333,   333,   334,   335,\n     336,   336,   337,   337,   337,   338,   339,   340,   340,   340,\n     341,   342,   343,   343,   343,   344,   345,   346,   347,   348,\n     348,   349,   350,   351,   351,   351,   352,   353,   354,   354,\n     354,   355,   356,   357,   357,   358,   359,   360,   360,   361,\n     362,   364,   363,   363,   365,   366,   367,   368,   368,   370,\n     369,   372,   371,   373,   371,   371,   374,   375,   376,   376,\n     377,   378,   379,   379,   380,   381,   381,   382,   382,   383,\n     384,   385,   386,   387,   387,   388,   388,   389,   390,   391,\n     391,   392,   392,   393,   393,   394,   394,   395,   395,   396,\n     396,   397,   397,   397,   398,   398,   399,   400,   401,   402,\n     402,   402,   403,   404,   405,   406,   406,   407,   407,   408,\n     408,   408,   409,   409,   410,   410,   411,   411,   412,   412,\n     412,   413,   413,   414,   415,   416,   416,   417,   417,   418,\n     418,   419,   419,   420,   421,   421,   423,   422,   422,   424,\n     424,   424,   424,   424,   424,   424,   425,   425,   425,   426,\n     426,   426,   426,   426,   426,   426,   426,   426,   426,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   427,\n     427,   427,   427,   427,   427,   427,   427,   427,   427,   428,\n     429,   430,   431,   432,   433,   434,   435,   436,   437,   438,\n     438,   438,   438,   438,   438,   438,   438,   438,   438,   438,\n     438,   438,   439,   439,   439,   439,   439,   439,   439,   439,\n     439,   439,   439,   439,   439,   439,   440,   440,   440,   440,\n     441,   441,   441,   441,   441,   441,   441,   441,   441,   441,\n     441,   441,   441,   441,   441,   441,   441,   441,   441,   441,\n     441,   441,   441,   441,   441,   441,   441,   441,   441,   441,\n     441,   441,   441,   441,   441,   441,   441,   441\n};\n\n  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */\nstatic const yytype_uint8 yyr2[] =\n{\n       0,     2,     1,     1,     1,     1,     3,     0,     0,     6,\n       1,    13,     1,     0,     2,     2,     2,     1,    13,     1,\n       0,     2,     3,     1,     4,     1,     4,     0,     3,     3,\n       7,     1,     0,     2,     2,     2,     2,     1,     4,     1,\n       4,     0,     2,     2,     2,     1,     4,     1,     7,     1,\n       4,     0,     2,     2,     2,     2,     1,     4,     1,     4,\n       1,     4,     1,     4,     1,     1,     0,     3,     4,     1,\n       4,     0,     2,     2,     0,     3,     1,     1,     0,     3,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     4,     1,     4,     0,     3,     2,     2,     2,     1,\n       4,     1,     4,     1,     0,     4,     2,     2,     1,     1,\n       4,     2,     2,     2,     1,     1,     4,     1,     4,     0,\n       3,     2,     2,     2,     1,     4,     1,     3,     1,     4,\n       1,     4,     0,     2,     3,     2,     2,     2,     1,     4,\n       1,     7,     0,     3,     2,     2,     2,     2,     2,     4,\n       1,     1,     4,     1,     1,     1,     0,     2,     2,     2,\n       3,     3,     2,     3,     3,     2,     0,     1,     4,     2,\n       1,     4,     1,     1,     4,     0,     2,     2,     2,     2,\n       1,     4,     1,     1,     4,     0,     2,     2,     2,     2,\n       2,     1,     4,     3,     0,     3,     4,     1,     1,     4,\n       0,     3,     2,     2,     2,     2,     1,     4,     2,     1,\n       4,     1,     4,     1,     4,     1,     4,     2,     2,     1,\n       2,     0,     2,     5,     1,     1,     4,     0,     3,     2,\n       2,     2,     2,     1,     4,     2,     1,     1,     4,     1,\n       4,     1,     4,     1,     4,     1,     4,     1,     4,     0,\n       2,     2,     2,     3,     3,     3,     3,     3,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     4,     1,     4,\n       0,     3,     3,     3,     2,     2,     2,     2,     2,     3,\n       3,     3,     3,     3,     7,     1,     0,     3,     3,     3,\n       2,     3,     2,     2,     2,     2,     2,     2,     1,     7,\n       0,     3,     3,     3,     2,     2,     3,     2,     2,     2,\n       2,     2,     2,     2,     1,     7,     0,     3,     3,     3,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     3,\n       3,     3,     3,     3,     1,     4,     1,     4,     0,     3,\n       3,     2,     2,     2,     2,     2,     2,     3,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     4,     1,\n       4,     0,     3,     3,     2,     2,     2,     3,     1,     4,\n       1,     4,     1,     4,     0,     3,     3,     3,     2,     2,\n       2,     2,     2,     1,     4,     1,     4,     0,     3,     3,\n       2,     2,     2,     3,     3,     2,     1,     1,     4,     1,\n       4,     0,     3,     3,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     1,     1,     7,     2,     1,     1,     7,\n       0,     3,     3,     2,     2,     2,     3,     3,     3,     3,\n       1,     4,     1,     4,     1,     4,     0,     3,     2,     2,\n       2,     3,     3,     3,     3,     2,     5,     0,     3,     3,\n       3,     3,     2,     5,     1,     4,     1,     4,     0,     3,\n       3,     2,     2,     2,     3,     3,     3,     1,     7,     0,\n       2,     2,     5,     2,     1,     1,     1,     1,     3,     1,\n       3,     1,     1,     1,     1,     3,     1,     4,     0,     2,\n       3,     2,     2,     2,     2,     2,     2,     1,     3,     1,\n       4,     0,     2,     3,     2,     2,     1,     3,     1,     4,\n       0,     3,     2,     2,     2,     2,     2,     2,     1,     4,\n       1,     4,     0,     2,     2,     1,     4,     2,     2,     1,\n       1,     4,     2,     2,     1,     1,     4,     1,     4,     2,\n       1,     1,     4,     2,     2,     1,     1,     4,     2,     2,\n       1,     1,     4,     1,     4,     1,     4,     2,     1,     1,\n       4,     0,     3,     1,     1,     2,     2,     0,     2,     0,\n       3,     0,     2,     0,     2,     1,     3,     2,     0,     2,\n       3,     2,     0,     2,     2,     0,     2,     0,     5,     5,\n       5,     4,     4,     0,     2,     0,     5,     5,     1,     1,\n       1,     1,     1,     1,     1,     1,     2,     2,     1,     1,\n       1,     2,     2,     1,     2,     4,     1,     1,     1,     0,\n       2,     2,     3,     2,     1,     0,     1,     0,     2,     0,\n       2,     3,     0,     5,     1,     4,     0,     3,     1,     3,\n       3,     1,     4,     1,     1,     0,     4,     2,     5,     1,\n       1,     0,     2,     2,     0,     1,     0,     3,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     0,     0,     0,     0,     0,     0,     0,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,\n       0,     3,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     4,     4,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     4,     3,     4,     4,     4,     4,     4\n};\n\n\n#define yyerrok         (yyerrstatus = 0)\n#define yyclearin       (yychar = YYEMPTY)\n#define YYEMPTY         (-2)\n#define YYEOF           0\n\n#define YYACCEPT        goto yyacceptlab\n#define YYABORT         goto yyabortlab\n#define YYERROR         goto yyerrorlab\n\n\n#define YYRECOVERING()  (!!yyerrstatus)\n\n#define YYBACKUP(Token, Value)                                  \\\ndo                                                              \\\n  if (yychar == YYEMPTY)                                        \\\n    {                                                           \\\n      yychar = (Token);                                         \\\n      yylval = (Value);                                         \\\n      YYPOPSTACK (yylen);                                       \\\n      yystate = *yyssp;                                         \\\n      goto yybackup;                                            \\\n    }                                                           \\\n  else                                                          \\\n    {                                                           \\\n      yyerror (&yylloc, scanner, param, YY_(\"syntax error: cannot back up\")); \\\n      YYERROR;                                                  \\\n    }                                                           \\\nwhile (0)\n\n/* Error token number */\n#define YYTERROR        1\n#define YYERRCODE       256\n\n\n/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].\n   If N is 0, then set CURRENT to the empty location which ends\n   the previous symbol: RHS[0] (always defined).  */\n\n#ifndef YYLLOC_DEFAULT\n# define YYLLOC_DEFAULT(Current, Rhs, N)                                \\\n    do                                                                  \\\n      if (N)                                                            \\\n        {                                                               \\\n          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \\\n          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \\\n          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \\\n          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \\\n        }                                                               \\\n      else                                                              \\\n        {                                                               \\\n          (Current).first_line   = (Current).last_line   =              \\\n            YYRHSLOC (Rhs, 0).last_line;                                \\\n          (Current).first_column = (Current).last_column =              \\\n            YYRHSLOC (Rhs, 0).last_column;                              \\\n        }                                                               \\\n    while (0)\n#endif\n\n#define YYRHSLOC(Rhs, K) ((Rhs)[K])\n\n\n/* Enable debugging if requested.  */\n#if YYDEBUG\n\n# ifndef YYFPRINTF\n#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */\n#  define YYFPRINTF fprintf\n# endif\n\n# define YYDPRINTF(Args)                        \\\ndo {                                            \\\n  if (yydebug)                                  \\\n    YYFPRINTF Args;                             \\\n} while (0)\n\n\n/* YY_LOCATION_PRINT -- Print the location on the stream.\n   This macro was not mandated originally: define only if we know\n   we won't break user code: when these are the locations we know.  */\n\n#ifndef YY_LOCATION_PRINT\n# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL\n\n/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */\n\nYY_ATTRIBUTE_UNUSED\nstatic int\nyy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)\n{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }\n\n#  define YY_LOCATION_PRINT(File, Loc)          \\\n  yy_location_print_ (File, &(Loc))\n\n# else\n#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)\n# endif\n#endif\n\n\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \\\ndo {                                                                      \\\n  if (yydebug)                                                            \\\n    {                                                                     \\\n      YYFPRINTF (stderr, \"%s \", Title);                                   \\\n      yy_symbol_print (stderr,                                            \\\n                  Type, Value, Location, scanner, param); \\\n      YYFPRINTF (stderr, \"\\n\");                                           \\\n    }                                                                     \\\n} while (0)\n\n\n/*-----------------------------------.\n| Print this symbol's value on YYO.  |\n`-----------------------------------*/\n\nstatic void\nyy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *scanner, struct yang_parameter *param)\n{\n  FILE *yyoutput = yyo;\n  YYUSE (yyoutput);\n  YYUSE (yylocationp);\n  YYUSE (scanner);\n  YYUSE (param);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}\n\n\n/*---------------------------.\n| Print this symbol on YYO.  |\n`---------------------------*/\n\nstatic void\nyy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *scanner, struct yang_parameter *param)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yytype, yyvaluep, yylocationp, scanner, param);\n  YYFPRINTF (yyo, \")\");\n}\n\n/*------------------------------------------------------------------.\n| yy_stack_print -- Print the state stack from its BOTTOM up to its |\n| TOP (included).                                                   |\n`------------------------------------------------------------------*/\n\nstatic void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}\n\n# define YY_STACK_PRINT(Bottom, Top)                            \\\ndo {                                                            \\\n  if (yydebug)                                                  \\\n    yy_stack_print ((Bottom), (Top));                           \\\n} while (0)\n\n\n/*------------------------------------------------.\n| Report that the YYRULE is going to be reduced.  |\n`------------------------------------------------*/\n\nstatic void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, void *scanner, struct yang_parameter *param)\n{\n  unsigned long yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                       , &(yylsp[(yyi + 1) - (yynrhs)])                       , scanner, param);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}\n\n# define YY_REDUCE_PRINT(Rule)          \\\ndo {                                    \\\n  if (yydebug)                          \\\n    yy_reduce_print (yyssp, yyvsp, yylsp, Rule, scanner, param); \\\n} while (0)\n\n/* Nonzero means print parse trace.  It is left uninitialized so that\n   multiple parsers can coexist.  */\nint yydebug;\n#else /* !YYDEBUG */\n# define YYDPRINTF(Args)\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)\n# define YY_STACK_PRINT(Bottom, Top)\n# define YY_REDUCE_PRINT(Rule)\n#endif /* !YYDEBUG */\n\n\n/* YYINITDEPTH -- initial size of the parser's stacks.  */\n#ifndef YYINITDEPTH\n# define YYINITDEPTH 200\n#endif\n\n/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only\n   if the built-in stack extension method is used).\n\n   Do not make this value too large; the results are undefined if\n   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)\n   evaluated with infinite-precision integer arithmetic.  */\n\n#ifndef YYMAXDEPTH\n# define YYMAXDEPTH 10000\n#endif\n\n\n#if YYERROR_VERBOSE\n\n# ifndef yystrlen\n#  if defined __GLIBC__ && defined _STRING_H\n#   define yystrlen strlen\n#  else\n/* Return the length of YYSTR.  */\nstatic YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}\n#  endif\n# endif\n\n# ifndef yystpcpy\n#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE\n#   define yystpcpy stpcpy\n#  else\n/* Copy YYSRC to YYDEST, returning the address of the terminating '\\0' in\n   YYDEST.  */\nstatic char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}\n#  endif\n# endif\n\n# ifndef yytnamerr\n/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\nstatic YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return (YYSIZE_T) (yystpcpy (yyres, yystr) - yyres);\n}\n# endif\n\n/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message\n   about the unexpected token YYTOKEN for the state stack whose top is\n   YYSSP.\n\n   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is\n   not large enough to hold the message.  In that case, also set\n   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the\n   required number of bytes is too large to store.  */\nstatic int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n    default: /* Avoid compiler warnings. */\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}\n#endif /* YYERROR_VERBOSE */\n\n/*-----------------------------------------------.\n| Release the memory associated to this symbol.  |\n`-----------------------------------------------*/\n\nstatic void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, void *scanner, struct yang_parameter *param)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yylocationp);\n  YYUSE (scanner);\n  YYUSE (param);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 115: /* tmp_string  */\n\n      { free((((*yyvaluep).p_str)) ? *((*yyvaluep).p_str) : NULL); }\n\n        break;\n\n    case 210: /* pattern_arg_str  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 399: /* semicolom  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 401: /* curly_bracket_open  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 405: /* string_opt_part1  */\n\n      { free(((*yyvaluep).str)); }\n\n        break;\n\n    case 430: /* type_ext_alloc  */\n\n      { yang_type_free(param->module->ctx, ((*yyvaluep).v)); }\n\n        break;\n\n    case 431: /* typedef_ext_alloc  */\n\n      { yang_type_free(param->module->ctx, &((struct lys_tpdf *)((*yyvaluep).v))->type); }\n\n        break;\n\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}\n\n\n\n\n/*----------.\n| yyparse.  |\n`----------*/\n\nint\nyyparse (void *scanner, struct yang_parameter *param)\n{\n/* The lookahead symbol.  */\nint yychar;\nchar *s = NULL, *tmp_s = NULL, *ext_name = NULL;\nstruct lys_module *trg = NULL;\nstruct lys_node *tpdf_parent = NULL, *data_node = NULL;\nstruct lys_ext_instance_complex *ext_instance = NULL;\nint is_ext_instance;\nvoid *actual = NULL;\nenum yytokentype backup_type, actual_type = MODULE_KEYWORD;\nint64_t cnt_val = 0;\nint is_value = 0;\nvoid *yang_type = NULL;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n/* Location data for the lookahead symbol.  */\nstatic YYLTYPE yyloc_default\n# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL\n  = { 1, 1, 1, 1 }\n# endif\n;\nYYLTYPE yylloc = yyloc_default;\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n       'yyls': related to locations.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    /* The location stack.  */\n    YYLTYPE yylsa[YYINITDEPTH];\n    YYLTYPE *yyls;\n    YYLTYPE *yylsp;\n\n    /* The locations where the error started and ended.  */\n    YYLTYPE yyerror_range[3];\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n  YYLTYPE yyloc;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yylsp = yyls = yylsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n\n/* User initialization code.  */\n\n{ yylloc.last_column = 0;\n                  if (param->flags & EXT_INSTANCE_SUBSTMT) {\n                    is_ext_instance = 1;\n                    ext_instance = (struct lys_ext_instance_complex *)param->actual_node;\n                    ext_name = (char *)param->data_node;\n                  } else {\n                    is_ext_instance = 0;\n                  }\n                  yylloc.last_line = is_ext_instance;     /* HACK for flex - return SUBMODULE_KEYWORD or SUBMODULE_EXT_KEYWORD */\n                  param->value = &s;\n                  param->data_node = (void **)&data_node;\n                  param->actual_node = &actual;\n                  backup_type = NODE;\n                  trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;\n                }\n\n\n  yylsp[0] = yylloc;\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = (yytype_int16) yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n        YYLTYPE *yyls1 = yyls;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yyls1, yysize * sizeof (*yylsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n        yyls = yyls1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n        YYSTACK_RELOCATE (yyls_alloc, yyls);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n      yylsp = yyls + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, &yylloc, scanner);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n  *++yylsp = yylloc;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n  /* Default location. */\n  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);\n  yyerror_range[1] = yyloc;\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 5:\n\n    { if (yyget_text(scanner)[0] == '\"') {\n                      char *tmp;\n\n                      s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {\n                        YYABORT;\n                      }\n                      s = tmp;\n                    } else {\n                      s = calloc(1, yyget_leng(scanner) - 1);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);\n                    }\n                    (yyval.p_str) = &s;\n                  }\n\n    break;\n\n  case 8:\n\n    { if (yyget_leng(scanner) > 2) {\n                int length_s = strlen(s), length_tmp = yyget_leng(scanner);\n                char *tmp;\n\n                tmp = realloc(s, length_s + length_tmp - 1);\n                if (!tmp) {\n                  LOGMEM(trg->ctx);\n                  YYABORT;\n                }\n                s = tmp;\n                if (yyget_text(scanner)[0] == '\"') {\n                  if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {\n                    YYABORT;\n                  }\n                  s = tmp;\n                } else {\n                  memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);\n                  s[length_s + length_tmp - 2] = '\\0';\n                }\n              }\n            }\n\n    break;\n\n  case 10:\n\n    { if (param->submodule) {\n                                       free(s);\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"module\");\n                                       YYABORT;\n                                     }\n                                     trg = param->module;\n                                     yang_read_common(trg,s,MODULE_KEYWORD);\n                                     s = NULL;\n                                     actual_type = MODULE_KEYWORD;\n                                   }\n\n    break;\n\n  case 12:\n\n    { if (!param->module->ns) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"namespace\", \"module\");\n                                            YYABORT;\n                                          }\n                                          if (!param->module->prefix) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"module\");\n                                            YYABORT;\n                                          }\n                                        }\n\n    break;\n\n  case 13:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 14:\n\n    { if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {\n                                              YYABORT;\n                                            }\n                                            (yyval.i) = 1;\n                                            s = NULL;\n                                          }\n\n    break;\n\n  case 15:\n\n    { if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 16:\n\n    { if (yang_read_prefix(trg, NULL, s)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 17:\n\n    { if (!param->submodule) {\n                                          free(s);\n                                          LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);\n                                          YYABORT;\n                                        }\n                                        trg = (struct lys_module *)param->submodule;\n                                        yang_read_common(trg,s,MODULE_KEYWORD);\n                                        s = NULL;\n                                        actual_type = SUBMODULE_KEYWORD;\n                                      }\n\n    break;\n\n  case 19:\n\n    { if (!param->submodule->prefix) {\n                                                  LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                                  YYABORT;\n                                                }\n                                                if (!(yyvsp[0].i)) {\n                                                  /* check version compatibility with the main module */\n                                                  if (param->module->version > 1) {\n                                                      LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                                                      YYABORT;\n                                                  }\n                                                }\n                                              }\n\n    break;\n\n  case 20:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 21:\n\n    { if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {\n                                                 YYABORT;\n                                               }\n                                               (yyval.i) = 1;\n                                               s = NULL;\n                                             }\n\n    break;\n\n  case 23:\n\n    { backup_type = actual_type;\n                           actual_type = YANG_VERSION_KEYWORD;\n                         }\n\n    break;\n\n  case 25:\n\n    { backup_type = actual_type;\n                            actual_type = NAMESPACE_KEYWORD;\n                          }\n\n    break;\n\n  case 30:\n\n    { actual_type = (yyvsp[-4].token);\n                   backup_type = NODE;\n                   actual = NULL;\n                 }\n\n    break;\n\n  case 31:\n\n    { YANG_ADDELEM(trg->imp, trg->imp_size, \"imports\");\n                                     /* HACK for unres */\n                                     ((struct lys_import *)actual)->module = (struct lys_module *)s;\n                                     s = NULL;\n                                     (yyval.token) = actual_type;\n                                     actual_type = IMPORT_KEYWORD;\n                                   }\n\n    break;\n\n  case 32:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 33:\n\n    { if (yang_read_prefix(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 34:\n\n    { if (trg->version != 2) {\n                                          LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                          free(s);\n                                          YYABORT;\n                                        }\n                                        if (yang_read_description(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        (yyval.i) = (yyvsp[-1].i);\n                                      }\n\n    break;\n\n  case 35:\n\n    { if (trg->version != 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      if (yang_read_reference(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      (yyval.i) = (yyvsp[-1].i);\n                                    }\n\n    break;\n\n  case 36:\n\n    { if ((yyvsp[-1].i)) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"import\");\n                                            free(s);\n                                            YYABORT;\n                                          }\n                                          memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);\n                                          free(s);\n                                          s = NULL;\n                                          (yyval.i) = 1;\n                                        }\n\n    break;\n\n  case 37:\n\n    { YANG_ADDELEM(trg->inc, trg->inc_size, \"includes\");\n                                     /* HACK for unres */\n                                     ((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;\n                                     s = NULL;\n                                     (yyval.token) = actual_type;\n                                     actual_type = INCLUDE_KEYWORD;\n                                   }\n\n    break;\n\n  case 38:\n\n    { actual_type = (yyvsp[-1].token);\n                                                                backup_type = NODE;\n                                                                actual = NULL;\n                                                              }\n\n    break;\n\n  case 41:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 42:\n\n    { if (trg->version != 2) {\n                                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                           free(s);\n                                           YYABORT;\n                                         }\n                                         if (yang_read_description(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                            YYABORT;\n                                         }\n                                         s = NULL;\n                                         (yyval.i) = (yyvsp[-1].i);\n                                       }\n\n    break;\n\n  case 43:\n\n    { if (trg->version != 2) {\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                         free(s);\n                                         YYABORT;\n                                       }\n                                       if (yang_read_reference(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       (yyval.i) = (yyvsp[-1].i);\n                                     }\n\n    break;\n\n  case 44:\n\n    { if ((yyvsp[-1].i)) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"include\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);\n                                           free(s);\n                                           s = NULL;\n                                           (yyval.i) = 1;\n                                         }\n\n    break;\n\n  case 45:\n\n    { backup_type = actual_type;\n                                  actual_type = REVISION_DATE_KEYWORD;\n                                }\n\n    break;\n\n  case 47:\n\n    { (yyval.token) = actual_type;\n                                         if (is_ext_instance) {\n                                           if (yang_read_extcomplex_str(trg, ext_instance, \"belongs-to\", ext_name, &s,\n                                                                        0, LY_STMT_BELONGSTO)) {\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           if (param->submodule->prefix) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {\n                                             LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"belongs-to\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           free(s);\n                                         }\n                                         s = NULL;\n                                         actual_type = BELONGS_TO_KEYWORD;\n                                       }\n\n    break;\n\n  case 48:\n\n    { if (is_ext_instance) {\n                         if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", \"belongs-to\", &s,\n                                                      LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {\n                           YYABORT;\n                         }\n                       } else {\n                         if (yang_read_prefix(trg, NULL, s)) {\n                           YYABORT;\n                         }\n                       }\n                       s = NULL;\n                       actual_type = (yyvsp[-4].token);\n                     }\n\n    break;\n\n  case 49:\n\n    { backup_type = actual_type;\n                             actual_type = PREFIX_KEYWORD;\n                           }\n\n    break;\n\n  case 52:\n\n    { if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 53:\n\n    { if (yang_read_common(trg, s, CONTACT_KEYWORD)) {\n                                 YYABORT;\n                               }\n                               s = NULL;\n                             }\n\n    break;\n\n  case 54:\n\n    { if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 55:\n\n    { if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                   YYABORT;\n                                 }\n                                 s=NULL;\n                               }\n\n    break;\n\n  case 56:\n\n    { backup_type = actual_type;\n                           actual_type = ORGANIZATION_KEYWORD;\n                         }\n\n    break;\n\n  case 58:\n\n    { backup_type = actual_type;\n                      actual_type = CONTACT_KEYWORD;\n                    }\n\n    break;\n\n  case 60:\n\n    { backup_type = actual_type;\n                          actual_type = DESCRIPTION_KEYWORD;\n                        }\n\n    break;\n\n  case 62:\n\n    { backup_type = actual_type;\n                        actual_type = REFERENCE_KEYWORD;\n                      }\n\n    break;\n\n  case 64:\n\n    { if (trg->rev_size) {\n                                      struct lys_revision *tmp;\n\n                                      tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);\n                                      if (!tmp) {\n                                        LOGMEM(trg->ctx);\n                                        YYABORT;\n                                      }\n                                      trg->rev = tmp;\n                                    }\n                                  }\n\n    break;\n\n  case 65:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  if (!is_ext_instance) {\n                                    YANG_ADDELEM(trg->rev, trg->rev_size, \"revisions\");\n                                  }\n                                  memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);\n                                  free(s);\n                                  s = NULL;\n                                  actual_type = REVISION_KEYWORD;\n                                }\n\n    break;\n\n  case 67:\n\n    { int i;\n\n                                                /* check uniqueness of the revision date - not required by RFC */\n                                                for (i = 0; i < (trg->rev_size - 1); i++) {\n                                                  if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {\n                                                    LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\",\n                                                           trg->rev[trg->rev_size - 1].date);\n                                                    break;\n                                                  }\n                                                }\n                                              }\n\n    break;\n\n  case 68:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                                                                     actual = (yyvsp[-1].backup_token).actual;\n                                                                   }\n\n    break;\n\n  case 72:\n\n    { if (yang_read_description(trg, actual, s, \"revision\",REVISION_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 73:\n\n    { if (yang_read_reference(trg, actual, s, \"revision\", REVISION_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 74:\n\n    { s = strdup(yyget_text(scanner));\n                              if (!s) {\n                                LOGMEM(trg->ctx);\n                                YYABORT;\n                              }\n                              if (lyp_check_date(trg->ctx, s)) {\n                                  free(s);\n                                  YYABORT;\n                              }\n                            }\n\n    break;\n\n  case 76:\n\n    { if (lyp_check_date(trg->ctx, s)) {\n                   free(s);\n                   YYABORT;\n               }\n             }\n\n    break;\n\n  case 77:\n\n    { void *tmp;\n\n                             if (trg->tpdf_size) {\n                               tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->tpdf = tmp;\n                             }\n\n                             if (trg->features_size) {\n                               tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->features = tmp;\n                             }\n\n                             if (trg->ident_size) {\n                               tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->ident = tmp;\n                             }\n\n                             if (trg->augment_size) {\n                               tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->augment = tmp;\n                             }\n\n                             if (trg->extensions_size) {\n                               tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->extensions = tmp;\n                             }\n                           }\n\n    break;\n\n  case 78:\n\n    { /* check the module with respect to the context now */\n                         if (!param->submodule) {\n                           switch (lyp_ctx_check_module(trg)) {\n                           case -1:\n                             YYABORT;\n                           case 0:\n                             break;\n                           case 1:\n                             /* it's already there */\n                             param->flags |= YANG_EXIST_MODULE;\n                             YYABORT;\n                           }\n                         }\n                         param->flags &= (~YANG_REMOVE_IMPORT);\n                         if (yang_check_imports(trg, param->unres)) {\n                           YYABORT;\n                         }\n                         actual = NULL;\n                       }\n\n    break;\n\n  case 79:\n\n    { actual = NULL; }\n\n    break;\n\n  case 90:\n\n    { (yyval.backup_token).token = actual_type;\n                                        (yyval.backup_token).actual = actual;\n                                        YANG_ADDELEM(trg->extensions, trg->extensions_size, \"extensions\");\n                                        trg->extensions_size--;\n                                        ((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                        ((struct lys_ext *)actual)->module = trg;\n                                        if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {\n                                          trg->extensions_size++;\n                                          YYABORT;\n                                        }\n                                        trg->extensions_size++;\n                                        s = NULL;\n                                        actual_type = EXTENSION_KEYWORD;\n                                      }\n\n    break;\n\n  case 91:\n\n    { struct lys_ext *ext = actual;\n                  ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);\n                  actual_type = (yyvsp[-1].backup_token).token;\n                  actual = (yyvsp[-1].backup_token).actual;\n                }\n\n    break;\n\n  case 96:\n\n    { if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"extension\");\n                                        YYABORT;\n                                      }\n                                      ((struct lys_ext *)actual)->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 97:\n\n    { if (yang_read_description(trg, actual, s, \"extension\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 98:\n\n    { if (yang_read_reference(trg, actual, s, \"extension\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 99:\n\n    { (yyval.token) = actual_type;\n                                   if (is_ext_instance) {\n                                     if (yang_read_extcomplex_str(trg, ext_instance, \"argument\", ext_name, &s,\n                                                                  0, LY_STMT_ARGUMENT)) {\n                                       YYABORT;\n                                     }\n                                   } else {\n                                     if (((struct lys_ext *)actual)->argument) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"argument\", \"extension\");\n                                        free(s);\n                                        YYABORT;\n                                     }\n                                     ((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);\n                                   }\n                                   s = NULL;\n                                   actual_type = ARGUMENT_KEYWORD;\n                                 }\n\n    break;\n\n  case 100:\n\n    { actual_type = (yyvsp[-1].token); }\n\n    break;\n\n  case 103:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                       backup_type = actual_type;\n                                       actual_type = YIN_ELEMENT_KEYWORD;\n                                     }\n\n    break;\n\n  case 105:\n\n    { if (is_ext_instance) {\n         int c;\n         const char ***p;\n         uint8_t *val;\n         struct lyext_substmt *info;\n\n         c = 0;\n         p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);\n         if (info->cardinality >= LY_STMT_CARD_SOME) {\n           /* get the index in the array to add new item */\n           for (c = 0; p[0][c + 1]; c++);\n           val = (uint8_t *)p[1];\n         } else {\n           val = (uint8_t *)(p + 1);\n         }\n         val[c] = ((yyvsp[-1].uint) == LYS_YINELEM) ? 1 : 2;\n       } else {\n         ((struct lys_ext *)actual)->flags |= (yyvsp[-1].uint);\n       }\n     }\n\n    break;\n\n  case 106:\n\n    { (yyval.uint) = LYS_YINELEM; }\n\n    break;\n\n  case 107:\n\n    { (yyval.uint) = 0; }\n\n    break;\n\n  case 108:\n\n    { if (!strcmp(s, \"true\")) {\n                 (yyval.uint) = LYS_YINELEM;\n               } else if (!strcmp(s, \"false\")) {\n                 (yyval.uint) = 0;\n               } else {\n                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\n    break;\n\n  case 109:\n\n    { (yyval.i) = (yyvsp[0].i);\n                             backup_type = actual_type;\n                             actual_type = STATUS_KEYWORD;\n                           }\n\n    break;\n\n  case 110:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 111:\n\n    { (yyval.i) = LYS_STATUS_CURR; }\n\n    break;\n\n  case 112:\n\n    { (yyval.i) = LYS_STATUS_OBSLT; }\n\n    break;\n\n  case 113:\n\n    { (yyval.i) = LYS_STATUS_DEPRC; }\n\n    break;\n\n  case 114:\n\n    { if (!strcmp(s, \"current\")) {\n                 (yyval.i) = LYS_STATUS_CURR;\n               } else if (!strcmp(s, \"obsolete\")) {\n                 (yyval.i) = LYS_STATUS_OBSLT;\n               } else if (!strcmp(s, \"deprecated\")) {\n                 (yyval.i) = LYS_STATUS_DEPRC;\n               } else {\n                 LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\n    break;\n\n  case 115:\n\n    { /* check uniqueness of feature's names */\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      (yyval.backup_token).token = actual_type;\n                                      (yyval.backup_token).actual = actual;\n                                      YANG_ADDELEM(trg->features, trg->features_size, \"features\");\n                                      ((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);\n                                      ((struct lys_feature *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = FEATURE_KEYWORD;\n                                    }\n\n    break;\n\n  case 116:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n                actual_type = (yyvsp[-1].backup_token).token;\n              }\n\n    break;\n\n  case 118:\n\n    { struct lys_iffeature *tmp;\n\n          if (((struct lys_feature *)actual)->iffeature_size) {\n            tmp = realloc(((struct lys_feature *)actual)->iffeature,\n                          ((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);\n            if (!tmp) {\n              LOGMEM(trg->ctx);\n              YYABORT;\n            }\n            ((struct lys_feature *)actual)->iffeature = tmp;\n          }\n        }\n\n    break;\n\n  case 121:\n\n    { if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"feature\");\n                                      YYABORT;\n                                    }\n                                    ((struct lys_feature *)actual)->flags |= (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 122:\n\n    { if (yang_read_description(trg, actual, s, \"feature\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 123:\n\n    { if (yang_read_reference(trg, actual, s, \"feature\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 124:\n\n    { (yyval.backup_token).token = actual_type;\n                         (yyval.backup_token).actual = actual;\n                         switch (actual_type) {\n                         case FEATURE_KEYWORD:\n                           YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,\n                                        ((struct lys_feature *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case IDENTITY_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"identity\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,\n                                        ((struct lys_ident *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case ENUM_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,\n                                        ((struct lys_type_enum *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case BIT_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"bit\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,\n                                        ((struct lys_type_bit *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case REFINE_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,\n                                        ((struct lys_refine *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case EXTENSION_INSTANCE:\n                           /* nothing change */\n                           break;\n                         default:\n                           /* lys_node_* */\n                           YANG_ADDELEM(((struct lys_node *)actual)->iffeature,\n                                        ((struct lys_node *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         }\n                         ((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;\n                         s = NULL;\n                         actual_type = IF_FEATURE_KEYWORD;\n                       }\n\n    break;\n\n  case 125:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n                   actual_type = (yyvsp[-1].backup_token).token;\n                 }\n\n    break;\n\n  case 128:\n\n    { const char *tmp;\n\n                                       tmp = lydict_insert_zc(trg->ctx, s);\n                                       s = NULL;\n                                       if (dup_identities_check(tmp, trg)) {\n                                         lydict_remove(trg->ctx, tmp);\n                                         YYABORT;\n                                       }\n                                       (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       YANG_ADDELEM(trg->ident, trg->ident_size, \"identities\");\n                                       ((struct lys_ident *)actual)->name = tmp;\n                                       ((struct lys_ident *)actual)->module = trg;\n                                       actual_type = IDENTITY_KEYWORD;\n                                     }\n\n    break;\n\n  case 129:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n                 actual_type = (yyvsp[-1].backup_token).token;\n               }\n\n    break;\n\n  case 131:\n\n    { void *tmp;\n\n           if (((struct lys_ident *)actual)->base_size) {\n             tmp = realloc(((struct lys_ident *)actual)->base,\n                           ((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->base = tmp;\n           }\n\n           if (((struct lys_ident *)actual)->iffeature_size) {\n             tmp = realloc(((struct lys_ident *)actual)->iffeature,\n                           ((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 133:\n\n    { void *identity;\n\n                                   if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {\n                                     free(s);\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"base\", \"identity\");\n                                     YYABORT;\n                                   }\n                                   identity = actual;\n                                   YANG_ADDELEM(((struct lys_ident *)actual)->base,\n                                                ((struct lys_ident *)actual)->base_size, \"bases\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   s = NULL;\n                                   actual = identity;\n                                 }\n\n    break;\n\n  case 135:\n\n    { if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"identity\");\n                                       YYABORT;\n                                     }\n                                     ((struct lys_ident *)actual)->flags |= (yyvsp[0].i);\n                                   }\n\n    break;\n\n  case 136:\n\n    { if (yang_read_description(trg, actual, s, \"identity\", NODE)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 137:\n\n    { if (yang_read_reference(trg, actual, s, \"identity\", NODE)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 138:\n\n    { backup_type = actual_type;\n                                   actual_type = BASE_KEYWORD;\n                                 }\n\n    break;\n\n  case 140:\n\n    { tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;\n                                      (yyval.backup_token).token = actual_type;\n                                      (yyval.backup_token).actual = actual;\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      switch (actual_type) {\n                                      case MODULE_KEYWORD:\n                                      case SUBMODULE_KEYWORD:\n                                        YANG_ADDELEM(trg->tpdf, trg->tpdf_size, \"typedefs\");\n                                        break;\n                                      case GROUPING_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_grp *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case CONTAINER_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_container *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case LIST_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_list *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case RPC_KEYWORD:\n                                      case ACTION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case INPUT_KEYWORD:\n                                      case OUTPUT_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_inout *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case NOTIFICATION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_notif *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case EXTENSION_INSTANCE:\n                                        /* typedef is already allocated */\n                                        break;\n                                      default:\n                                        /* another type of nodetype is error*/\n                                        LOGINT(trg->ctx);\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      ((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                      ((struct lys_tpdf *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = TYPEDEF_KEYWORD;\n                                    }\n\n    break;\n\n  case 141:\n\n    { if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {\n                      LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"typedef\");\n                      YYABORT;\n                    }\n                    actual_type = (yyvsp[-4].backup_token).token;\n                    actual = (yyvsp[-4].backup_token).actual;\n                  }\n\n    break;\n\n  case 142:\n\n    { (yyval.nodes).node.ptr_tpdf = actual;\n                            (yyval.nodes).node.flag = 0;\n                          }\n\n    break;\n\n  case 143:\n\n    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;\n                                       (yyval.nodes) = (yyvsp[-2].nodes);\n                                     }\n\n    break;\n\n  case 144:\n\n    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n\n    break;\n\n  case 145:\n\n    { if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n\n    break;\n\n  case 146:\n\n    { if ((yyvsp[-1].nodes).node.ptr_tpdf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"typedef\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_tpdf->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 147:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 148:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 149:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 150:\n\n    { (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       actual_type = TYPE_KEYWORD;\n                                     }\n\n    break;\n\n  case 153:\n\n    { if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&\n                                         ((struct yang_type *)actual)->type->info.str.pat_count) {\n                                       void *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,\n                                                     ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.str.patterns = tmp;\n\n#ifdef LY_ENABLED_CACHE\n                                       if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,\n                                                       2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;\n                                       }\n#endif\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {\n                                       struct lys_type *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,\n                                                     ((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.uni.types = tmp;\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {\n                                       struct lys_ident **tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,\n                                                     ((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.ident.ref = tmp;\n                                     }\n                                   }\n\n    break;\n\n  case 157:\n\n    { if (yang_read_require_instance(trg->ctx, actual, (yyvsp[0].i))) {\n                                                 YYABORT;\n                                               }\n                                             }\n\n    break;\n\n  case 158:\n\n    { /* leafref_specification */\n                                   if (yang_read_leafref_path(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 159:\n\n    { /* identityref_specification */\n                                   if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {\n                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");\n                                     return EXIT_FAILURE;\n                                   }\n                                   ((struct yang_type *)actual)->base = LY_TYPE_IDENT;\n                                   yang_type = actual;\n                                   YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,\n                                                ((struct yang_type *)actual)->type->info.ident.count, \"identity refs\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   actual = yang_type;\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 162:\n\n    { if (yang_read_fraction(trg->ctx, actual, (yyvsp[0].uint))) {\n                                                YYABORT;\n                                              }\n                                            }\n\n    break;\n\n  case 165:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                                   actual = (yyvsp[-1].backup_token).actual;\n                                 }\n\n    break;\n\n  case 166:\n\n    { struct yang_type *stype = (struct yang_type *)actual;\n\n                         (yyval.backup_token).token = actual_type;\n                         (yyval.backup_token).actual = actual;\n                         if (stype->base != 0 && stype->base != LY_TYPE_UNION) {\n                           LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected type statement.\");\n                           YYABORT;\n                         }\n                         stype->base = LY_TYPE_UNION;\n                         if (strcmp(stype->name, \"union\")) {\n                           /* type can be a substatement only in \"union\" type, not in derived types */\n                           LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"derived type\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, \"union types\")\n                         actual_type = UNION_KEYWORD;\n                       }\n\n    break;\n\n  case 167:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                               backup_type = actual_type;\n                                               actual_type = FRACTION_DIGITS_KEYWORD;\n                                             }\n\n    break;\n\n  case 168:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 169:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 170:\n\n    { char *endptr = NULL;\n               unsigned long val;\n               errno = 0;\n\n               val = strtoul(s, &endptr, 10);\n               if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                 LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"fraction-digits\");\n                 free(s);\n                 s = NULL;\n                 YYABORT;\n               }\n               (yyval.uint) = (uint32_t) val;\n               free(s);\n               s =NULL;\n             }\n\n    break;\n\n  case 171:\n\n    { actual = (yyvsp[-1].backup_token).actual;\n               actual_type = (yyvsp[-1].backup_token).token;\n             }\n\n    break;\n\n  case 172:\n\n    { (yyval.backup_token).token = actual_type;\n                         (yyval.backup_token).actual = actual;\n                         if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {\n                           YYABORT;\n                         }\n                         actual_type = LENGTH_KEYWORD;\n                         s = NULL;\n                       }\n\n    break;\n\n  case 175:\n\n    { switch (actual_type) {\n                               case MUST_KEYWORD:\n                                 (yyval.str) = \"must\";\n                                 break;\n                               case LENGTH_KEYWORD:\n                                 (yyval.str) = \"length\";\n                                 break;\n                               case RANGE_KEYWORD:\n                                 (yyval.str) = \"range\";\n                                 break;\n                               default:\n                                 LOGINT(trg->ctx);\n                                 YYABORT;\n                                 break;\n                               }\n                             }\n\n    break;\n\n  case 176:\n\n    { if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 177:\n\n    { if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 178:\n\n    { if (yang_read_description(trg, actual, s, (yyvsp[-1].str), NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 179:\n\n    { if (yang_read_reference(trg, actual, s, (yyvsp[-1].str), NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 180:\n\n    { (yyval.backup_token).token = actual_type;\n                   (yyval.backup_token).actual = actual;\n                 }\n\n    break;\n\n  case 181:\n\n    {struct lys_restr *pattern = actual;\n                                                                        actual = NULL;\n#ifdef LY_ENABLED_CACHE\n                                                                        if ((yyvsp[-2].backup_token).token != EXTENSION_INSTANCE &&\n                                                                            !(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {\n                                                                          unsigned int c = 2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1);\n                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          ++c;\n                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];\n                                                                        }\n#endif\n                                                                        if (yang_read_pattern(trg->ctx, pattern, actual, (yyvsp[-1].str), (yyvsp[0].ch))) {\n                                                                          YYABORT;\n                                                                        }\n                                                                        actual_type = (yyvsp[-2].backup_token).token;\n                                                                        actual = (yyvsp[-2].backup_token).actual;\n                                                                      }\n\n    break;\n\n  case 182:\n\n    { if (actual_type != EXTENSION_INSTANCE) {\n                            if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {\n                              free(s);\n                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected pattern statement.\");\n                              YYABORT;\n                            }\n                            ((struct yang_type *)actual)->base = LY_TYPE_STRING;\n                            YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,\n                                         ((struct yang_type *)actual)->type->info.str.pat_count, \"patterns\");\n                          }\n                          (yyval.str) = s;\n                          s = NULL;\n                          actual_type = PATTERN_KEYWORD;\n                        }\n\n    break;\n\n  case 183:\n\n    { (yyval.ch) = 0x06; }\n\n    break;\n\n  case 184:\n\n    { (yyval.ch) = (yyvsp[-1].ch); }\n\n    break;\n\n  case 185:\n\n    { (yyval.ch) = 0x06; /* ACK */ }\n\n    break;\n\n  case 186:\n\n    { if (trg->version < 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"modifier\");\n                                        YYABORT;\n                                      }\n                                      if ((yyvsp[-1].ch) != 0x06) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"modifier\", \"pattern\");\n                                        YYABORT;\n                                      }\n                                      (yyval.ch) = (yyvsp[0].ch);\n                                    }\n\n    break;\n\n  case 187:\n\n    { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 188:\n\n    { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 189:\n\n    { if (yang_read_description(trg, actual, s, \"pattern\", NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 190:\n\n    { if (yang_read_reference(trg, actual, s, \"pattern\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 191:\n\n    { backup_type = actual_type;\n                       actual_type = MODIFIER_KEYWORD;\n                     }\n\n    break;\n\n  case 192:\n\n    { if (!strcmp(s, \"invert-match\")) {\n                                                             (yyval.ch) = 0x15;\n                                                             free(s);\n                                                             s = NULL;\n                                                           } else {\n                                                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                                                             free(s);\n                                                             YYABORT;\n                                                           }\n                                                         }\n\n    break;\n\n  case 193:\n\n    { struct lys_type_enum * tmp;\n\n                                                   cnt_val = 0;\n                                                   tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,\n                                                                 ((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);\n                                                   if (!tmp) {\n                                                     LOGMEM(trg->ctx);\n                                                     YYABORT;\n                                                   }\n                                                   ((struct yang_type *)actual)->type->info.enums.enm = tmp;\n                                                 }\n\n    break;\n\n  case 196:\n\n    { if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n               YYABORT;\n             }\n             actual = (yyvsp[-1].backup_token).actual;\n             actual_type = (yyvsp[-1].backup_token).token;\n           }\n\n    break;\n\n  case 197:\n\n    { (yyval.backup_token).token = actual_type;\n                       (yyval.backup_token).actual = yang_type = actual;\n                       YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, \"enums\");\n                       if (yang_read_enum(trg->ctx, yang_type, actual, s)) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       is_value = 0;\n                       actual_type = ENUM_KEYWORD;\n                     }\n\n    break;\n\n  case 199:\n\n    { if (((struct lys_type_enum *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_enum *)actual)->iffeature,\n                           ((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_enum *)actual)->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 202:\n\n    { if (is_value) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"value\", \"enum\");\n                                  YYABORT;\n                                }\n                                ((struct lys_type_enum *)actual)->value = (yyvsp[0].i);\n\n                                /* keep the highest enum value for automatic increment */\n                                if ((yyvsp[0].i) >= cnt_val) {\n                                  cnt_val = (yyvsp[0].i) + 1;\n                                }\n                                is_value = 1;\n                              }\n\n    break;\n\n  case 203:\n\n    { if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"enum\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_enum *)actual)->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 204:\n\n    { if (yang_read_description(trg, actual, s, \"enum\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 205:\n\n    { if (yang_read_reference(trg, actual, s, \"enum\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 206:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                   backup_type = actual_type;\n                                   actual_type = VALUE_KEYWORD;\n                                 }\n\n    break;\n\n  case 207:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 208:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 209:\n\n    { /* convert it to int32_t */\n                int64_t val;\n                char *endptr;\n\n                val = strtoll(s, &endptr, 10);\n                if (val < INT32_MIN || val > INT32_MAX || *endptr) {\n                    LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"value\");\n                    free(s);\n                    YYABORT;\n                }\n                free(s);\n                s = NULL;\n                (yyval.i) = (int32_t) val;\n             }\n\n    break;\n\n  case 210:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                                                        actual = (yyvsp[-1].backup_token).actual;\n                                                      }\n\n    break;\n\n  case 213:\n\n    { backup_type = actual_type;\n                         actual_type = PATH_KEYWORD;\n                       }\n\n    break;\n\n  case 215:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                                 backup_type = actual_type;\n                                                 actual_type = REQUIRE_INSTANCE_KEYWORD;\n                                               }\n\n    break;\n\n  case 216:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 217:\n\n    { (yyval.i) = 1; }\n\n    break;\n\n  case 218:\n\n    { (yyval.i) = -1; }\n\n    break;\n\n  case 219:\n\n    { if (!strcmp(s,\"true\")) {\n                  (yyval.i) = 1;\n                } else if (!strcmp(s,\"false\")) {\n                  (yyval.i) = -1;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"require-instance\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 220:\n\n    { struct lys_type_bit * tmp;\n\n                                         cnt_val = 0;\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,\n                                                       ((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.bits.bit = tmp;\n                                       }\n\n    break;\n\n  case 223:\n\n    { if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n                      YYABORT;\n                    }\n                    actual = (yyvsp[-2].backup_token).actual;\n                    actual_type = (yyvsp[-2].backup_token).token;\n                  }\n\n    break;\n\n  case 224:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = yang_type = actual;\n                                  YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,\n                                               ((struct yang_type *)actual)->type->info.bits.count, \"bits\");\n                                  if (yang_read_bit(trg->ctx, yang_type, actual, s)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                  is_value = 0;\n                                  actual_type = BIT_KEYWORD;\n                                }\n\n    break;\n\n  case 226:\n\n    { if (((struct lys_type_bit *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_bit *)actual)->iffeature,\n                           ((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_bit *)actual)->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 229:\n\n    { if (is_value) {\n                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"position\", \"bit\");\n                                    YYABORT;\n                                  }\n                                  ((struct lys_type_bit *)actual)->pos = (yyvsp[0].uint);\n\n                                  /* keep the highest position value for automatic increment */\n                                  if ((yyvsp[0].uint) >= cnt_val) {\n                                    cnt_val = (yyvsp[0].uint) + 1;\n                                  }\n                                  is_value = 1;\n                                }\n\n    break;\n\n  case 230:\n\n    { if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"bit\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_bit *)actual)->flags |= (yyvsp[0].i);\n                              }\n\n    break;\n\n  case 231:\n\n    { if (yang_read_description(trg, actual, s, \"bit\", NODE)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n\n    break;\n\n  case 232:\n\n    { if (yang_read_reference(trg, actual, s, \"bit\", NODE)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 233:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                             backup_type = actual_type;\n                                             actual_type = POSITION_KEYWORD;\n                                           }\n\n    break;\n\n  case 234:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 235:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 236:\n\n    { /* convert it to uint32_t */\n                unsigned long val;\n                char *endptr = NULL;\n                errno = 0;\n\n                val = strtoul(s, &endptr, 10);\n                if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"position\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n                (yyval.uint) = (uint32_t) val;\n              }\n\n    break;\n\n  case 237:\n\n    { backup_type = actual_type;\n                            actual_type = ERROR_MESSAGE_KEYWORD;\n                          }\n\n    break;\n\n  case 239:\n\n    { backup_type = actual_type;\n                            actual_type = ERROR_APP_TAG_KEYWORD;\n                          }\n\n    break;\n\n  case 241:\n\n    { backup_type = actual_type;\n                    actual_type = UNITS_KEYWORD;\n                  }\n\n    break;\n\n  case 243:\n\n    { backup_type = actual_type;\n                      actual_type = DEFAULT_KEYWORD;\n                    }\n\n    break;\n\n  case 245:\n\n    { (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       data_node = actual;\n                                       actual_type = GROUPING_KEYWORD;\n                                     }\n\n    break;\n\n  case 246:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing grouping statement \\\"%s\\\"\", data_node->name);\n                 actual_type = (yyvsp[-1].backup_token).token;\n                 actual = (yyvsp[-1].backup_token).actual;\n                 data_node = (yyvsp[-1].backup_token).actual;\n               }\n\n    break;\n\n  case 249:\n\n    { (yyval.nodes).grouping = actual; }\n\n    break;\n\n  case 250:\n\n    { if ((yyvsp[-1].nodes).grouping->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).grouping, \"status\", \"grouping\");\n                                       YYABORT;\n                                     }\n                                     (yyvsp[-1].nodes).grouping->flags |= (yyvsp[0].i);\n                                   }\n\n    break;\n\n  case 251:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).grouping, s, \"grouping\", NODE_PRINT)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n\n    break;\n\n  case 252:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).grouping, s, \"grouping\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 257:\n\n    { if (trg->version < 2) {\n                                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).grouping, \"notification\");\n                                                     YYABORT;\n                                                   }\n                                                 }\n\n    break;\n\n  case 266:\n\n    { (yyval.backup_token).token = actual_type;\n                                        (yyval.backup_token).actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = CONTAINER_KEYWORD;\n                                      }\n\n    break;\n\n  case 267:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing container statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-1].backup_token).token;\n                  actual = (yyvsp[-1].backup_token).actual;\n                  data_node = (yyvsp[-1].backup_token).actual;\n                }\n\n    break;\n\n  case 269:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].nodes).container->iffeature_size) {\n              tmp = realloc((yyvsp[-1].nodes).container->iffeature, (yyvsp[-1].nodes).container->iffeature_size * sizeof *(yyvsp[-1].nodes).container->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).container->iffeature = tmp;\n            }\n\n            if ((yyvsp[-1].nodes).container->must_size) {\n              tmp = realloc((yyvsp[-1].nodes).container->must, (yyvsp[-1].nodes).container->must_size * sizeof *(yyvsp[-1].nodes).container->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).container->must = tmp;\n            }\n          }\n\n    break;\n\n  case 270:\n\n    { (yyval.nodes).container = actual; }\n\n    break;\n\n  case 274:\n\n    { if (yang_read_presence(trg, (yyvsp[-1].nodes).container, s)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 275:\n\n    { if ((yyvsp[-1].nodes).container->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, \"config\", \"container\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 276:\n\n    { if ((yyvsp[-1].nodes).container->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, \"status\", \"container\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 277:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).container, s, \"container\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 278:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).container, s, \"container\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 281:\n\n    { if (trg->version < 2) {\n                                                      LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).container, \"notification\");\n                                                      YYABORT;\n                                                    }\n                                                  }\n\n    break;\n\n  case 284:\n\n    { void *tmp;\n\n                  if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {\n                    LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"type\", \"leaf\");\n                    YYABORT;\n                  }\n                  if ((yyvsp[-1].nodes).node.ptr_leaf->dflt && ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_TRUE)) {\n                    /* RFC 6020, 7.6.4 - default statement must not with mandatory true */\n                    LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"mandatory\", \"leaf\");\n                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    YYABORT;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_leaf->iffeature_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->iffeature, (yyvsp[-1].nodes).node.ptr_leaf->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_leaf->iffeature = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_leaf->must_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->must, (yyvsp[-1].nodes).node.ptr_leaf->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_leaf->must = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing leaf statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-4].backup_token).token;\n                  actual = (yyvsp[-4].backup_token).actual;\n                  data_node = (yyvsp[-4].backup_token).actual;\n                }\n\n    break;\n\n  case 285:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LEAF_KEYWORD;\n                                 }\n\n    break;\n\n  case 286:\n\n    { (yyval.nodes).node.ptr_leaf = actual;\n                            (yyval.nodes).node.flag = 0;\n                          }\n\n    break;\n\n  case 289:\n\n    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;\n                                       (yyval.nodes) = (yyvsp[-2].nodes);\n                                     }\n\n    break;\n\n  case 290:\n\n    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n\n    break;\n\n  case 292:\n\n    { if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n\n    break;\n\n  case 293:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"config\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 294:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"mandatory\", \"leaf\");\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 295:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"status\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 296:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 297:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 298:\n\n    { (yyval.backup_token).token = actual_type;\n                                        (yyval.backup_token).actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = LEAF_LIST_KEYWORD;\n                                      }\n\n    break;\n\n  case 299:\n\n    { void *tmp;\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_R) {\n                          /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data\n                           * ignore oredering MASK - 0x7F\n                           */\n                          (yyvsp[-1].nodes).node.ptr_leaflist->flags &= 0x7F;\n                        }\n                        if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {\n                          LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"type\", \"leaf-list\");\n                          YYABORT;\n                        }\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size && (yyvsp[-1].nodes).node.ptr_leaflist->min) {\n                          LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                          LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist,\n                                 \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                          YYABORT;\n                        }\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size) {\n                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->iffeature, (yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->iffeature);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          (yyvsp[-1].nodes).node.ptr_leaflist->iffeature = tmp;\n                        }\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->must_size) {\n                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->must, (yyvsp[-1].nodes).node.ptr_leaflist->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->must);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          (yyvsp[-1].nodes).node.ptr_leaflist->must = tmp;\n                        }\n\n                        if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size) {\n                          tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->dflt, (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->dflt);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          (yyvsp[-1].nodes).node.ptr_leaflist->dflt = tmp;\n                        }\n\n                        LOGDBG(LY_LDGYANG, \"finished parsing leaf-list statement \\\"%s\\\"\", data_node->name);\n                        actual_type = (yyvsp[-4].backup_token).token;\n                        actual = (yyvsp[-4].backup_token).actual;\n                        data_node = (yyvsp[-4].backup_token).actual;\n                      }\n\n    break;\n\n  case 300:\n\n    { (yyval.nodes).node.ptr_leaflist = actual;\n                                 (yyval.nodes).node.flag = 0;\n                               }\n\n    break;\n\n  case 303:\n\n    { (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;\n                                            (yyval.nodes) = (yyvsp[-2].nodes);\n                                          }\n\n    break;\n\n  case 304:\n\n    { if (trg->version < 2) {\n                                         free(s);\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"default\");\n                                         YYABORT;\n                                       }\n                                       YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_leaflist->dflt,\n                                                    (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size, \"defaults\");\n                                       (*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);\n                                       s = NULL;\n                                       actual = (yyvsp[-1].nodes).node.ptr_leaflist;\n                                     }\n\n    break;\n\n  case 305:\n\n    { if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n\n    break;\n\n  case 307:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"config\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 308:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            (yyvsp[-1].nodes).node.ptr_leaflist->min = (yyvsp[0].uint);\n                                            (yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;\n                                            (yyval.nodes) = (yyvsp[-1].nodes);\n                                            if ((yyvsp[-1].nodes).node.ptr_leaflist->max && ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max)) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 309:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"max-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            (yyvsp[-1].nodes).node.ptr_leaflist->max = (yyvsp[0].uint);\n                                            (yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;\n                                            (yyval.nodes) = (yyvsp[-1].nodes);\n                                            if ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"max-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 310:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"ordered by\", \"leaf-list\");\n                                            YYABORT;\n                                          }\n                                          if ((yyvsp[0].i) & LYS_USERORDERED) {\n                                            (yyvsp[-1].nodes).node.ptr_leaflist->flags |= LYS_USERORDERED;\n                                          }\n                                          (yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);\n                                          (yyval.nodes) = (yyvsp[-1].nodes);\n                                        }\n\n    break;\n\n  case 311:\n\n    { if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"status\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 312:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n\n    break;\n\n  case 313:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 314:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LIST_KEYWORD;\n                                 }\n\n    break;\n\n  case 315:\n\n    { void *tmp;\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->iffeature_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->iffeature, (yyvsp[-1].nodes).node.ptr_list->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->iffeature = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->must_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->must, (yyvsp[-1].nodes).node.ptr_list->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->must = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->tpdf_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->tpdf, (yyvsp[-1].nodes).node.ptr_list->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->tpdf = tmp;\n                  }\n\n                  if ((yyvsp[-1].nodes).node.ptr_list->unique_size) {\n                    tmp = realloc((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->unique);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    (yyvsp[-1].nodes).node.ptr_list->unique = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing list statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-4].backup_token).token;\n                  actual = (yyvsp[-4].backup_token).actual;\n                  data_node = (yyvsp[-4].backup_token).actual;\n                }\n\n    break;\n\n  case 316:\n\n    { (yyval.nodes).node.ptr_list = actual;\n                            (yyval.nodes).node.flag = 0;\n                          }\n\n    break;\n\n  case 320:\n\n    { if ((yyvsp[-1].nodes).node.ptr_list->keys) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"key\", \"list\");\n                                  free(s);\n                                  YYABORT;\n                              }\n                              (yyvsp[-1].nodes).node.ptr_list->keys = (struct lys_node_leaf **)s;\n                              (yyval.nodes) = (yyvsp[-1].nodes);\n                              s = NULL;\n                            }\n\n    break;\n\n  case 321:\n\n    { YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size, \"uniques\");\n                                 ((struct lys_unique *)actual)->expr = (const char **)s;\n                                 (yyval.nodes) = (yyvsp[-1].nodes);\n                                 s = NULL;\n                                 actual = (yyvsp[-1].nodes).node.ptr_list;\n                               }\n\n    break;\n\n  case 322:\n\n    { if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"config\", \"list\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 323:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"min-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       (yyvsp[-1].nodes).node.ptr_list->min = (yyvsp[0].uint);\n                                       (yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;\n                                       (yyval.nodes) = (yyvsp[-1].nodes);\n                                       if ((yyvsp[-1].nodes).node.ptr_list->max && ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max)) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 324:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"max-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       (yyvsp[-1].nodes).node.ptr_list->max = (yyvsp[0].uint);\n                                       (yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;\n                                       (yyval.nodes) = (yyvsp[-1].nodes);\n                                       if ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 325:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"ordered by\", \"list\");\n                                       YYABORT;\n                                     }\n                                     if ((yyvsp[0].i) & LYS_USERORDERED) {\n                                       (yyvsp[-1].nodes).node.ptr_list->flags |= LYS_USERORDERED;\n                                     }\n                                     (yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);\n                                     (yyval.nodes) = (yyvsp[-1].nodes);\n                                   }\n\n    break;\n\n  case 326:\n\n    { if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"status\", \"list\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 327:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 328:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 332:\n\n    { if (trg->version < 2) {\n                                                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_list, \"notification\");\n                                                 YYABORT;\n                                               }\n                                             }\n\n    break;\n\n  case 334:\n\n    { (yyval.backup_token).token = actual_type;\n                                     (yyval.backup_token).actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = CHOICE_KEYWORD;\n                                   }\n\n    break;\n\n  case 335:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing choice statement \\\"%s\\\"\", data_node->name);\n               actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n               data_node = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 337:\n\n    { struct lys_iffeature *tmp;\n\n           if (((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_TRUE) && (yyvsp[-1].nodes).node.ptr_choice->dflt) {\n              LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"default\", \"choice\");\n              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"The \\\"default\\\" statement is forbidden on choices with \\\"mandatory\\\".\");\n              YYABORT;\n            }\n\n           if ((yyvsp[-1].nodes).node.ptr_choice->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).node.ptr_choice->iffeature, (yyvsp[-1].nodes).node.ptr_choice->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).node.ptr_choice->iffeature = tmp;\n           }\n         }\n\n    break;\n\n  case 338:\n\n    { (yyval.nodes).node.ptr_choice = actual;\n                              (yyval.nodes).node.flag = 0;\n                            }\n\n    break;\n\n  case 341:\n\n    { if ((yyvsp[-1].nodes).node.flag & LYS_CHOICE_DEFAULT) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"default\", \"choice\");\n                                      free(s);\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).node.ptr_choice->dflt = (struct lys_node *) s;\n                                    s = NULL;\n                                    (yyval.nodes) = (yyvsp[-1].nodes);\n                                    (yyval.nodes).node.flag |= LYS_CHOICE_DEFAULT;\n                                  }\n\n    break;\n\n  case 342:\n\n    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"config\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);\n                                   (yyval.nodes) = (yyvsp[-1].nodes);\n                                 }\n\n    break;\n\n  case 343:\n\n    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"mandatory\", \"choice\");\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);\n                                    (yyval.nodes) = (yyvsp[-1].nodes);\n                                  }\n\n    break;\n\n  case 344:\n\n    { if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"status\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);\n                                   (yyval.nodes) = (yyvsp[-1].nodes);\n                                 }\n\n    break;\n\n  case 345:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        (yyval.nodes) = (yyvsp[-1].nodes);\n                                      }\n\n    break;\n\n  case 346:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      (yyval.nodes) = (yyvsp[-1].nodes);\n                                    }\n\n    break;\n\n  case 356:\n\n    { if (trg->version < 2 ) {\n                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"choice\");\n                     YYABORT;\n                   }\n                 }\n\n    break;\n\n  case 357:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = CASE_KEYWORD;\n                                 }\n\n    break;\n\n  case 358:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing case statement \\\"%s\\\"\", data_node->name);\n             actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n             data_node = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 360:\n\n    { struct lys_iffeature *tmp;\n\n           if ((yyvsp[-1].nodes).cs->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).cs->iffeature, (yyvsp[-1].nodes).cs->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).cs->iffeature = tmp;\n           }\n          }\n\n    break;\n\n  case 361:\n\n    { (yyval.nodes).cs = actual; }\n\n    break;\n\n  case 364:\n\n    { if ((yyvsp[-1].nodes).cs->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).cs, \"status\", \"case\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).cs->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 365:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).cs, s, \"case\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 366:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).cs, s, \"case\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 368:\n\n    { (yyval.backup_token).token = actual_type;\n                                     (yyval.backup_token).actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ANYXML_KEYWORD;\n                                   }\n\n    break;\n\n  case 369:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing anyxml statement \\\"%s\\\"\", data_node->name);\n               actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n               data_node = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 370:\n\n    { (yyval.backup_token).token = actual_type;\n                                      (yyval.backup_token).actual = actual;\n                                      if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {\n                                        YYABORT;\n                                      }\n                                      data_node = actual;\n                                      s = NULL;\n                                      actual_type = ANYDATA_KEYWORD;\n                                    }\n\n    break;\n\n  case 371:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing anydata statement \\\"%s\\\"\", data_node->name);\n                actual_type = (yyvsp[-1].backup_token).token;\n                actual = (yyvsp[-1].backup_token).actual;\n                data_node = (yyvsp[-1].backup_token).actual;\n              }\n\n    break;\n\n  case 373:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].nodes).node.ptr_anydata->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->iffeature, (yyvsp[-1].nodes).node.ptr_anydata->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).node.ptr_anydata->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).node.ptr_anydata->must_size) {\n             tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->must, (yyvsp[-1].nodes).node.ptr_anydata->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).node.ptr_anydata->must = tmp;\n           }\n         }\n\n    break;\n\n  case 374:\n\n    { (yyval.nodes).node.ptr_anydata = actual;\n                              (yyval.nodes).node.flag = actual_type;\n                            }\n\n    break;\n\n  case 378:\n\n    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"config\",\n                                            ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);\n                                 }\n\n    break;\n\n  case 379:\n\n    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_MAND_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"mandatory\",\n                                               ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                        YYABORT;\n                                      }\n                                      (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);\n                                    }\n\n    break;\n\n  case 380:\n\n    { if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"status\",\n                                            ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   (yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);\n                                 }\n\n    break;\n\n  case 381:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\n    break;\n\n  case 382:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 383:\n\n    { (yyval.backup_token).token = actual_type;\n                                       (yyval.backup_token).actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {\n                                         YYABORT;\n                                       }\n                                       data_node = actual;\n                                       s = NULL;\n                                       actual_type = USES_KEYWORD;\n                                     }\n\n    break;\n\n  case 384:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing uses statement \\\"%s\\\"\", data_node->name);\n             actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n             data_node = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 386:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].nodes).uses->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).uses->iffeature, (yyvsp[-1].nodes).uses->iffeature_size * sizeof *(yyvsp[-1].nodes).uses->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).uses->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).uses->refine_size) {\n             tmp = realloc((yyvsp[-1].nodes).uses->refine, (yyvsp[-1].nodes).uses->refine_size * sizeof *(yyvsp[-1].nodes).uses->refine);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).uses->refine = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).uses->augment_size) {\n             tmp = realloc((yyvsp[-1].nodes).uses->augment, (yyvsp[-1].nodes).uses->augment_size * sizeof *(yyvsp[-1].nodes).uses->augment);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).uses->augment = tmp;\n           }\n         }\n\n    break;\n\n  case 387:\n\n    { (yyval.nodes).uses = actual; }\n\n    break;\n\n  case 390:\n\n    { if ((yyvsp[-1].nodes).uses->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).uses, \"status\", \"uses\");\n                                   YYABORT;\n                                 }\n                                 (yyvsp[-1].nodes).uses->flags |= (yyvsp[0].i);\n                               }\n\n    break;\n\n  case 391:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).uses, s, \"uses\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 392:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).uses, s, \"uses\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 397:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,\n                                               ((struct lys_node_uses *)actual)->refine_size, \"refines\");\n                                  ((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);\n                                  free(s);\n                                  s = NULL;\n                                  if (!((struct lys_refine *)actual)->target_name) {\n                                    YYABORT;\n                                  }\n                                  actual_type = REFINE_KEYWORD;\n                                }\n\n    break;\n\n  case 398:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 400:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].nodes).refine->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).refine->iffeature, (yyvsp[-1].nodes).refine->iffeature_size * sizeof *(yyvsp[-1].nodes).refine->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).refine->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).refine->must_size) {\n             tmp = realloc((yyvsp[-1].nodes).refine->must, (yyvsp[-1].nodes).refine->must_size * sizeof *(yyvsp[-1].nodes).refine->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).refine->must = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).refine->dflt_size) {\n             tmp = realloc((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size * sizeof *(yyvsp[-1].nodes).refine->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).refine->dflt = tmp;\n           }\n         }\n\n    break;\n\n  case 401:\n\n    { (yyval.nodes).refine = actual;\n                                    actual_type = REFINE_KEYWORD;\n                                  }\n\n    break;\n\n  case 402:\n\n    { actual = (yyvsp[-2].nodes).refine;\n                                               actual_type = REFINE_KEYWORD;\n                                               if ((yyvsp[-2].nodes).refine->target_type) {\n                                                 if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {\n                                                   (yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"must\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 (yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;\n                                               }\n                                             }\n\n    break;\n\n  case 403:\n\n    { /* leaf, leaf-list, list, container or anyxml */\n               /* check possibility of statements combination */\n               if ((yyvsp[-2].nodes).refine->target_type) {\n                 if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {\n                   (yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);\n                 } else {\n                   free(s);\n                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"refine\");\n                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                   YYABORT;\n                 }\n               } else {\n                 (yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;\n               }\n             }\n\n    break;\n\n  case 404:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                             if ((yyvsp[-1].nodes).refine->target_type & LYS_CONTAINER) {\n                                               if ((yyvsp[-1].nodes).refine->mod.presence) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                                 free(s);\n                                                 YYABORT;\n                                               }\n                                               (yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;\n                                               (yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                             } else {\n                                               free(s);\n                                               LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                               LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                               YYABORT;\n                                             }\n                                           } else {\n                                             (yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;\n                                             (yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                           }\n                                           s = NULL;\n                                           (yyval.nodes) = (yyvsp[-1].nodes);\n                                         }\n\n    break;\n\n  case 405:\n\n    { int i;\n\n                                          if ((yyvsp[-1].nodes).refine->dflt_size) {\n                                            if (trg->version < 2) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              YYABORT;\n                                            }\n                                            if ((yyvsp[-1].nodes).refine->target_type & LYS_LEAFLIST) {\n                                              (yyvsp[-1].nodes).refine->target_type = LYS_LEAFLIST;\n                                            } else {\n                                              free(s);\n                                              LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                              YYABORT;\n                                            }\n                                          } else {\n                                            if ((yyvsp[-1].nodes).refine->target_type) {\n                                              if (trg->version < 2 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE))) {\n                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE);\n                                              } if (trg->version > 1 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {\n                                                /* YANG 1.1 */\n                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);\n                                              } else {\n                                                free(s);\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              if (trg->version < 2) {\n                                                (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE;\n                                              } else {\n                                                /* YANG 1.1 */\n                                                (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;\n                                              }\n                                            }\n                                          }\n                                          /* check for duplicity */\n                                          for (i = 0; i < (yyvsp[-1].nodes).refine->dflt_size; ++i) {\n                                              if (ly_strequal((yyvsp[-1].nodes).refine->dflt[i], s, 0)) {\n                                                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"default\");\n                                                  LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", s);\n                                                  YYABORT;\n                                              }\n                                          }\n                                          YANG_ADDELEM((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size, \"defaults\");\n                                          *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                          actual = (yyvsp[-1].nodes).refine;\n                                          s = NULL;\n                                          (yyval.nodes) = (yyvsp[-1].nodes);\n                                        }\n\n    break;\n\n  case 406:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                           if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {\n                                             (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);\n                                             if ((yyvsp[-1].nodes).refine->flags & LYS_CONFIG_MASK) {\n                                               LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                               YYABORT;\n                                             }\n                                             (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                           } else {\n                                             LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                             LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;\n                                           (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                         }\n                                         (yyval.nodes) = (yyvsp[-1].nodes);\n                                       }\n\n    break;\n\n  case 407:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                              if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {\n                                                (yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);\n                                                if ((yyvsp[-1].nodes).refine->flags & LYS_MAND_MASK) {\n                                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                  YYABORT;\n                                                }\n                                                (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                              } else {\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              (yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;\n                                              (yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);\n                                            }\n                                            (yyval.nodes) = (yyvsp[-1].nodes);\n                                          }\n\n    break;\n\n  case 408:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                                 if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   (yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MINSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;\n                                                   (yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 (yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;\n                                                 (yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);\n                                               }\n                                               (yyval.nodes) = (yyvsp[-1].nodes);\n                                             }\n\n    break;\n\n  case 409:\n\n    { if ((yyvsp[-1].nodes).refine->target_type) {\n                                                 if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   (yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MAXSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;\n                                                   (yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 (yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 (yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;\n                                                 (yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);\n                                               }\n                                               (yyval.nodes) = (yyvsp[-1].nodes);\n                                             }\n\n    break;\n\n  case 410:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).refine, s, \"refine\", NODE)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n\n    break;\n\n  case 411:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).refine, s, \"refine\", NODE)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n\n    break;\n\n  case 414:\n\n    { void *parent;\n\n                                         (yyval.backup_token).token = actual_type;\n                                         (yyval.backup_token).actual = actual;\n                                         parent = actual;\n                                         YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,\n                                                      ((struct lys_node_uses *)actual)->augment_size, \"augments\");\n                                         if (yang_read_augment(trg, parent, actual, s)) {\n                                           YYABORT;\n                                         }\n                                         data_node = actual;\n                                         s = NULL;\n                                         actual_type = AUGMENT_KEYWORD;\n                                       }\n\n    break;\n\n  case 415:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                         actual_type = (yyvsp[-4].backup_token).token;\n                         actual = (yyvsp[-4].backup_token).actual;\n                         data_node = (yyvsp[-4].backup_token).actual;\n                       }\n\n    break;\n\n  case 418:\n\n    { (yyval.backup_token).token = actual_type;\n                               (yyval.backup_token).actual = actual;\n                               YANG_ADDELEM(trg->augment, trg->augment_size, \"augments\");\n                               if (yang_read_augment(trg, NULL, actual, s)) {\n                                 YYABORT;\n                               }\n                               data_node = actual;\n                               s = NULL;\n                               actual_type = AUGMENT_KEYWORD;\n                             }\n\n    break;\n\n  case 419:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                    actual_type = (yyvsp[-4].backup_token).token;\n                    actual = (yyvsp[-4].backup_token).actual;\n                    data_node = (yyvsp[-4].backup_token).actual;\n                  }\n\n    break;\n\n  case 420:\n\n    { (yyval.nodes).augment = actual; }\n\n    break;\n\n  case 423:\n\n    { if ((yyvsp[-1].nodes).augment->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).augment, \"status\", \"augment\");\n                                      YYABORT;\n                                    }\n                                    (yyvsp[-1].nodes).augment->flags |= (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 424:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).augment, s, \"augment\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\n    break;\n\n  case 425:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).augment, s, \"augment\", NODE_PRINT)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\n    break;\n\n  case 428:\n\n    { if (trg->version < 2) {\n                                                    LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).augment, \"notification\");\n                                                    YYABORT;\n                                                  }\n                                                }\n\n    break;\n\n  case 430:\n\n    { if (param->module->version != 2) {\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"action\");\n                                       free(s);\n                                       YYABORT;\n                                     }\n                                     (yyval.backup_token).token = actual_type;\n                                     (yyval.backup_token).actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ACTION_KEYWORD;\n                                   }\n\n    break;\n\n  case 431:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing action statement \\\"%s\\\"\", data_node->name);\n               actual_type = (yyvsp[-1].backup_token).token;\n               actual = (yyvsp[-1].backup_token).actual;\n               data_node = (yyvsp[-1].backup_token).actual;\n             }\n\n    break;\n\n  case 432:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = RPC_KEYWORD;\n                                }\n\n    break;\n\n  case 433:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing rpc statement \\\"%s\\\"\", data_node->name);\n            actual_type = (yyvsp[-1].backup_token).token;\n            actual = (yyvsp[-1].backup_token).actual;\n            data_node = (yyvsp[-1].backup_token).actual;\n          }\n\n    break;\n\n  case 435:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].nodes).node.ptr_rpc->iffeature_size) {\n              tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->iffeature, (yyvsp[-1].nodes).node.ptr_rpc->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).node.ptr_rpc->iffeature = tmp;\n            }\n\n            if ((yyvsp[-1].nodes).node.ptr_rpc->tpdf_size) {\n              tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->tpdf, (yyvsp[-1].nodes).node.ptr_rpc->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->tpdf);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).node.ptr_rpc->tpdf = tmp;\n            }\n          }\n\n    break;\n\n  case 436:\n\n    { (yyval.nodes).node.ptr_rpc = actual;\n                           (yyval.nodes).node.flag = 0;\n                         }\n\n    break;\n\n  case 438:\n\n    { if ((yyvsp[-1].nodes).node.ptr_rpc->flags & LYS_STATUS_MASK) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_rpc, \"status\", \"rpc\");\n                                  YYABORT;\n                                }\n                                (yyvsp[-1].nodes).node.ptr_rpc->flags |= (yyvsp[0].i);\n                             }\n\n    break;\n\n  case 439:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n\n    break;\n\n  case 440:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\n    break;\n\n  case 443:\n\n    { if ((yyvsp[-2].nodes).node.flag & LYS_RPC_INPUT) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, \"input\", \"rpc\");\n                                         YYABORT;\n                                       }\n                                       (yyvsp[-2].nodes).node.flag |= LYS_RPC_INPUT;\n                                       (yyval.nodes) = (yyvsp[-2].nodes);\n                                     }\n\n    break;\n\n  case 444:\n\n    { if ((yyvsp[-2].nodes).node.flag & LYS_RPC_OUTPUT) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, \"output\", \"rpc\");\n                                          YYABORT;\n                                        }\n                                        (yyvsp[-2].nodes).node.flag |= LYS_RPC_OUTPUT;\n                                        (yyval.nodes) = (yyvsp[-2].nodes);\n                                      }\n\n    break;\n\n  case 445:\n\n    { (yyval.backup_token).token = actual_type;\n                                  (yyval.backup_token).actual = actual;\n                                  s = strdup(\"input\");\n                                  if (!s) {\n                                    LOGMEM(trg->ctx);\n                                    YYABORT;\n                                  }\n                                  if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = INPUT_KEYWORD;\n                                }\n\n    break;\n\n  case 446:\n\n    { void *tmp;\n                  struct lys_node_inout *input = actual;\n\n                  if (input->must_size) {\n                    tmp = realloc(input->must, input->must_size * sizeof *input->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->must = tmp;\n                  }\n\n                  if (input->tpdf_size) {\n                    tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->tpdf = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing input statement \\\"%s\\\"\", data_node->name);\n                  actual_type = (yyvsp[-4].backup_token).token;\n                  actual = (yyvsp[-4].backup_token).actual;\n                  data_node = (yyvsp[-4].backup_token).actual;\n                }\n\n    break;\n\n  case 452:\n\n    { (yyval.backup_token).token = actual_type;\n                                    (yyval.backup_token).actual = actual;\n                                    s = strdup(\"output\");\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {\n                                      YYABORT;\n                                    }\n                                    data_node = actual;\n                                    s = NULL;\n                                    actual_type = OUTPUT_KEYWORD;\n                                  }\n\n    break;\n\n  case 453:\n\n    { void *tmp;\n                   struct lys_node_inout *output = actual;\n\n                   if (output->must_size) {\n                     tmp = realloc(output->must, output->must_size * sizeof *output->must);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->must = tmp;\n                   }\n\n                   if (output->tpdf_size) {\n                     tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->tpdf = tmp;\n                   }\n\n                   LOGDBG(LY_LDGYANG, \"finished parsing output statement \\\"%s\\\"\", data_node->name);\n                   actual_type = (yyvsp[-4].backup_token).token;\n                   actual = (yyvsp[-4].backup_token).actual;\n                   data_node = (yyvsp[-4].backup_token).actual;\n                 }\n\n    break;\n\n  case 454:\n\n    { (yyval.backup_token).token = actual_type;\n                                           (yyval.backup_token).actual = actual;\n                                           if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {\n                                             YYABORT;\n                                           }\n                                           data_node = actual;\n                                           actual_type = NOTIFICATION_KEYWORD;\n                                         }\n\n    break;\n\n  case 455:\n\n    { LOGDBG(LY_LDGYANG, \"finished parsing notification statement \\\"%s\\\"\", data_node->name);\n                     actual_type = (yyvsp[-1].backup_token).token;\n                     actual = (yyvsp[-1].backup_token).actual;\n                     data_node = (yyvsp[-1].backup_token).actual;\n                   }\n\n    break;\n\n  case 457:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].nodes).notif->must_size) {\n              tmp = realloc((yyvsp[-1].nodes).notif->must, (yyvsp[-1].nodes).notif->must_size * sizeof *(yyvsp[-1].nodes).notif->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].nodes).notif->must = tmp;\n            }\n\n           if ((yyvsp[-1].nodes).notif->iffeature_size) {\n             tmp = realloc((yyvsp[-1].nodes).notif->iffeature, (yyvsp[-1].nodes).notif->iffeature_size * sizeof *(yyvsp[-1].nodes).notif->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).notif->iffeature = tmp;\n           }\n\n           if ((yyvsp[-1].nodes).notif->tpdf_size) {\n             tmp = realloc((yyvsp[-1].nodes).notif->tpdf, (yyvsp[-1].nodes).notif->tpdf_size * sizeof *(yyvsp[-1].nodes).notif->tpdf);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].nodes).notif->tpdf = tmp;\n           }\n          }\n\n    break;\n\n  case 458:\n\n    { (yyval.nodes).notif = actual; }\n\n    break;\n\n  case 461:\n\n    { if ((yyvsp[-1].nodes).notif->flags & LYS_STATUS_MASK) {\n                                           LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).notif, \"status\", \"notification\");\n                                           YYABORT;\n                                         }\n                                         (yyvsp[-1].nodes).notif->flags |= (yyvsp[0].i);\n                                       }\n\n    break;\n\n  case 462:\n\n    { if (yang_read_description(trg, (yyvsp[-1].nodes).notif, s, \"notification\", NODE_PRINT)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n\n    break;\n\n  case 463:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].nodes).notif, s, \"notification\", NODE_PRINT)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n\n    break;\n\n  case 467:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   YANG_ADDELEM(trg->deviation, trg->deviation_size, \"deviations\");\n                                   ((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);\n                                   free(s);\n                                   if (!((struct lys_deviation *)actual)->target_name) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                   actual_type = DEVIATION_KEYWORD;\n                                 }\n\n    break;\n\n  case 468:\n\n    { void *tmp;\n\n                      if ((yyvsp[-1].dev)->deviate_size) {\n                        tmp = realloc((yyvsp[-1].dev)->deviate, (yyvsp[-1].dev)->deviate_size * sizeof *(yyvsp[-1].dev)->deviate);\n                        if (!tmp) {\n                          LOGINT(trg->ctx);\n                          YYABORT;\n                        }\n                        (yyvsp[-1].dev)->deviate = tmp;\n                      } else {\n                        LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"deviate\", \"deviation\");\n                        YYABORT;\n                      }\n                      actual_type = (yyvsp[-4].backup_token).token;\n                      actual = (yyvsp[-4].backup_token).actual;\n                    }\n\n    break;\n\n  case 469:\n\n    { (yyval.dev) = actual; }\n\n    break;\n\n  case 470:\n\n    { if (yang_read_description(trg, (yyvsp[-1].dev), s, \"deviation\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           (yyval.dev) = (yyvsp[-1].dev);\n                                         }\n\n    break;\n\n  case 471:\n\n    { if (yang_read_reference(trg, (yyvsp[-1].dev), s, \"deviation\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                         (yyval.dev) = (yyvsp[-1].dev);\n                                       }\n\n    break;\n\n  case 477:\n\n    { (yyval.backup_token).token = actual_type;\n                                               (yyval.backup_token).actual = actual;\n                                               if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {\n                                                 YYABORT;\n                                               }\n                                               actual_type = NOT_SUPPORTED_KEYWORD;\n                                             }\n\n    break;\n\n  case 478:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                              actual = (yyvsp[-2].backup_token).actual;\n                            }\n\n    break;\n\n  case 484:\n\n    { (yyval.backup_token).token = actual_type;\n                           (yyval.backup_token).actual = actual;\n                           if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {\n                             YYABORT;\n                           }\n                           actual_type = ADD_KEYWORD;\n                         }\n\n    break;\n\n  case 485:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                    actual = (yyvsp[-2].backup_token).actual;\n                  }\n\n    break;\n\n  case 487:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].deviate)->must_size) {\n             tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->must = tmp;\n           }\n\n           if ((yyvsp[-1].deviate)->unique_size) {\n             tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->unique = tmp;\n           }\n\n           if ((yyvsp[-1].deviate)->dflt_size) {\n             tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->dflt = tmp;\n           }\n         }\n\n    break;\n\n  case 488:\n\n    { (yyval.deviate) = actual; }\n\n    break;\n\n  case 489:\n\n    { if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       (yyval.deviate) = (yyvsp[-1].deviate);\n                                     }\n\n    break;\n\n  case 491:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, \"uniques\");\n                                        ((struct lys_unique *)actual)->expr = (const char **)s;\n                                        s = NULL;\n                                        actual = (yyvsp[-1].deviate);\n                                        (yyval.deviate)= (yyvsp[-1].deviate);\n                                      }\n\n    break;\n\n  case 492:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");\n                                         *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                         s = NULL;\n                                         actual = (yyvsp[-1].deviate);\n                                         (yyval.deviate) = (yyvsp[-1].deviate);\n                                       }\n\n    break;\n\n  case 493:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                          YYABORT;\n                                        }\n                                        (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                        (yyval.deviate) = (yyvsp[-1].deviate);\n                                      }\n\n    break;\n\n  case 494:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                             YYABORT;\n                                           }\n                                           (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                           (yyval.deviate) = (yyvsp[-1].deviate);\n                                         }\n\n    break;\n\n  case 495:\n\n    { if ((yyvsp[-1].deviate)->min_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              (yyvsp[-1].deviate)->min = (yyvsp[0].uint);\n                                              (yyvsp[-1].deviate)->min_set = 1;\n                                              (yyval.deviate) =  (yyvsp[-1].deviate);\n                                            }\n\n    break;\n\n  case 496:\n\n    { if ((yyvsp[-1].deviate)->max_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              (yyvsp[-1].deviate)->max = (yyvsp[0].uint);\n                                              (yyvsp[-1].deviate)->max_set = 1;\n                                              (yyval.deviate) =  (yyvsp[-1].deviate);\n                                            }\n\n    break;\n\n  case 497:\n\n    { (yyval.backup_token).token = actual_type;\n                                 (yyval.backup_token).actual = actual;\n                                 if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {\n                                   YYABORT;\n                                 }\n                                 actual_type = DELETE_KEYWORD;\n                               }\n\n    break;\n\n  case 498:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                       actual = (yyvsp[-2].backup_token).actual;\n                     }\n\n    break;\n\n  case 500:\n\n    { void *tmp;\n\n            if ((yyvsp[-1].deviate)->must_size) {\n              tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].deviate)->must = tmp;\n            }\n\n            if ((yyvsp[-1].deviate)->unique_size) {\n              tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].deviate)->unique = tmp;\n            }\n\n            if ((yyvsp[-1].deviate)->dflt_size) {\n              tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              (yyvsp[-1].deviate)->dflt = tmp;\n            }\n          }\n\n    break;\n\n  case 501:\n\n    { (yyval.deviate) = actual; }\n\n    break;\n\n  case 502:\n\n    { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                          (yyval.deviate) = (yyvsp[-1].deviate);\n                                        }\n\n    break;\n\n  case 504:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, \"uniques\");\n                                           ((struct lys_unique *)actual)->expr = (const char **)s;\n                                           s = NULL;\n                                           actual = (yyvsp[-1].deviate);\n                                           (yyval.deviate) = (yyvsp[-1].deviate);\n                                         }\n\n    break;\n\n  case 505:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");\n                                            *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                            s = NULL;\n                                            actual = (yyvsp[-1].deviate);\n                                            (yyval.deviate) = (yyvsp[-1].deviate);\n                                          }\n\n    break;\n\n  case 506:\n\n    { (yyval.backup_token).token = actual_type;\n                                   (yyval.backup_token).actual = actual;\n                                   if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {\n                                     YYABORT;\n                                   }\n                                   actual_type = REPLACE_KEYWORD;\n                                 }\n\n    break;\n\n  case 507:\n\n    { actual_type = (yyvsp[-2].backup_token).token;\n                        actual = (yyvsp[-2].backup_token).actual;\n                      }\n\n    break;\n\n  case 509:\n\n    { void *tmp;\n\n           if ((yyvsp[-1].deviate)->dflt_size) {\n             tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             (yyvsp[-1].deviate)->dflt = tmp;\n           }\n         }\n\n    break;\n\n  case 510:\n\n    { (yyval.deviate) = actual; }\n\n    break;\n\n  case 512:\n\n    { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           (yyval.deviate) = (yyvsp[-1].deviate);\n                                         }\n\n    break;\n\n  case 513:\n\n    { YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");\n                                             *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                             s = NULL;\n                                             actual = (yyvsp[-1].deviate);\n                                             (yyval.deviate) = (yyvsp[-1].deviate);\n                                           }\n\n    break;\n\n  case 514:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                              YYABORT;\n                                            }\n                                            (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                            (yyval.deviate) = (yyvsp[-1].deviate);\n                                          }\n\n    break;\n\n  case 515:\n\n    { if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                                 YYABORT;\n                                               }\n                                               (yyvsp[-1].deviate)->flags = (yyvsp[0].i);\n                                               (yyval.deviate) = (yyvsp[-1].deviate);\n                                             }\n\n    break;\n\n  case 516:\n\n    { if ((yyvsp[-1].deviate)->min_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  (yyvsp[-1].deviate)->min = (yyvsp[0].uint);\n                                                  (yyvsp[-1].deviate)->min_set = 1;\n                                                  (yyval.deviate) =  (yyvsp[-1].deviate);\n                                                }\n\n    break;\n\n  case 517:\n\n    { if ((yyvsp[-1].deviate)->max_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  (yyvsp[-1].deviate)->max = (yyvsp[0].uint);\n                                                  (yyvsp[-1].deviate)->max_set = 1;\n                                                  (yyval.deviate) =  (yyvsp[-1].deviate);\n                                                }\n\n    break;\n\n  case 518:\n\n    { (yyval.backup_token).token = actual_type;\n                        (yyval.backup_token).actual = actual;\n                        if (!(actual = yang_read_when(trg, actual, actual_type, s))) {\n                          YYABORT;\n                        }\n                        s = NULL;\n                        actual_type = WHEN_KEYWORD;\n                      }\n\n    break;\n\n  case 519:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 523:\n\n    { if (yang_read_description(trg, actual, s, \"when\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\n    break;\n\n  case 524:\n\n    { if (yang_read_reference(trg, actual, s, \"when\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 525:\n\n    { (yyval.i) = (yyvsp[0].i);\n                             backup_type = actual_type;\n                             actual_type = CONFIG_KEYWORD;\n                           }\n\n    break;\n\n  case 526:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 527:\n\n    { (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET; }\n\n    break;\n\n  case 528:\n\n    { (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET; }\n\n    break;\n\n  case 529:\n\n    { if (!strcmp(s, \"true\")) {\n                  (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET;\n                } else if (!strcmp(s, \"false\")) {\n                  (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"config\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 530:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                   backup_type = actual_type;\n                                   actual_type = MANDATORY_KEYWORD;\n                                 }\n\n    break;\n\n  case 531:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 532:\n\n    { (yyval.i) = LYS_MAND_TRUE; }\n\n    break;\n\n  case 533:\n\n    { (yyval.i) = LYS_MAND_FALSE; }\n\n    break;\n\n  case 534:\n\n    { if (!strcmp(s, \"true\")) {\n                  (yyval.i) = LYS_MAND_TRUE;\n                } else if (!strcmp(s, \"false\")) {\n                  (yyval.i) = LYS_MAND_FALSE;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"mandatory\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 535:\n\n    { backup_type = actual_type;\n                       actual_type = PRESENCE_KEYWORD;\n                     }\n\n    break;\n\n  case 537:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                   backup_type = actual_type;\n                                   actual_type = MIN_ELEMENTS_KEYWORD;\n                                 }\n\n    break;\n\n  case 538:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 539:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 540:\n\n    { if (strlen(s) == 1 && s[0] == '0') {\n                  (yyval.uint) = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"min-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  (yyval.uint) = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 541:\n\n    { (yyval.uint) = (yyvsp[0].uint);\n                                   backup_type = actual_type;\n                                   actual_type = MAX_ELEMENTS_KEYWORD;\n                                 }\n\n    break;\n\n  case 542:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 543:\n\n    { (yyval.uint) = 0; }\n\n    break;\n\n  case 544:\n\n    { (yyval.uint) = (yyvsp[-1].uint); }\n\n    break;\n\n  case 545:\n\n    { if (!strcmp(s, \"unbounded\")) {\n                  (yyval.uint) = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"max-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  (yyval.uint) = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\n    break;\n\n  case 546:\n\n    { (yyval.i) = (yyvsp[0].i);\n                                     backup_type = actual_type;\n                                     actual_type = ORDERED_BY_KEYWORD;\n                                   }\n\n    break;\n\n  case 547:\n\n    { (yyval.i) = (yyvsp[-1].i); }\n\n    break;\n\n  case 548:\n\n    { (yyval.i) = LYS_USERORDERED; }\n\n    break;\n\n  case 549:\n\n    { (yyval.i) = LYS_SYSTEMORDERED; }\n\n    break;\n\n  case 550:\n\n    { if (!strcmp(s, \"user\")) {\n                  (yyval.i) = LYS_USERORDERED;\n                } else if (!strcmp(s, \"system\")) {\n                  (yyval.i) = LYS_SYSTEMORDERED;\n                } else {\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s=NULL;\n              }\n\n    break;\n\n  case 551:\n\n    { (yyval.backup_token).token = actual_type;\n                       (yyval.backup_token).actual = actual;\n                       switch (actual_type) {\n                       case CONTAINER_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_container *)actual)->must,\n                                     ((struct lys_node_container *)actual)->must_size, \"musts\");\n                         break;\n                       case ANYDATA_KEYWORD:\n                       case ANYXML_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,\n                                     ((struct lys_node_anydata *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,\n                                     ((struct lys_node_leaf *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,\n                                     ((struct lys_node_leaflist *)actual)->must_size, \"musts\");\n                         break;\n                       case LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_list *)actual)->must,\n                                     ((struct lys_node_list *)actual)->must_size, \"musts\");\n                         break;\n                       case REFINE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_refine *)actual)->must,\n                                     ((struct lys_refine *)actual)->must_size, \"musts\");\n                         break;\n                       case ADD_KEYWORD:\n                       case DELETE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_deviate *)actual)->must,\n                                      ((struct lys_deviate *)actual)->must_size, \"musts\");\n                         break;\n                       case NOTIFICATION_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_notif *)actual)->must,\n                                     ((struct lys_node_notif *)actual)->must_size, \"musts\");\n                         break;\n                       case INPUT_KEYWORD:\n                       case OUTPUT_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_inout *)actual)->must,\n                                     ((struct lys_node_inout *)actual)->must_size, \"musts\");\n                         break;\n                       case EXTENSION_INSTANCE:\n                         /* must is already allocated */\n                         break;\n                       default:\n                         free(s);\n                         LOGINT(trg->ctx);\n                         YYABORT;\n                       }\n                       ((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);\n                       free(s);\n                       if (!((struct lys_restr *)actual)->expr) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       actual_type = MUST_KEYWORD;\n                     }\n\n    break;\n\n  case 552:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n             actual = (yyvsp[-1].backup_token).actual;\n           }\n\n    break;\n\n  case 555:\n\n    { backup_type = actual_type;\n                             actual_type = UNIQUE_KEYWORD;\n                           }\n\n    break;\n\n  case 559:\n\n    { backup_type = actual_type;\n                       actual_type = KEY_KEYWORD;\n                     }\n\n    break;\n\n  case 561:\n\n    { s = strdup(yyget_text(scanner));\n                               if (!s) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                             }\n\n    break;\n\n  case 564:\n\n    { (yyval.backup_token).token = actual_type;\n                        (yyval.backup_token).actual = actual;\n                        if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {\n                          YYABORT;\n                        }\n                        actual_type = RANGE_KEYWORD;\n                        s = NULL;\n                      }\n\n    break;\n\n  case 565:\n\n    { if (s) {\n                                                s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                strcat(s,\"/\");\n                                                strcat(s, yyget_text(scanner));\n                                              } else {\n                                                s = malloc(yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                s[0]='/';\n                                                memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);\n                                              }\n                                            }\n\n    break;\n\n  case 569:\n\n    { if (s) {\n                                              s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                              strcat(s, yyget_text(scanner));\n                                            } else {\n                                              s = strdup(yyget_text(scanner));\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                            }\n                                          }\n\n    break;\n\n  case 571:\n\n    { tmp_s = yyget_text(scanner); }\n\n    break;\n\n  case 572:\n\n    { s = strdup(tmp_s);\n                                                                if (!s) {\n                                                                  LOGMEM(trg->ctx);\n                                                                  YYABORT;\n                                                                }\n                                                                s[strlen(s) - 1] = '\\0';\n                                                             }\n\n    break;\n\n  case 573:\n\n    { tmp_s = yyget_text(scanner); }\n\n    break;\n\n  case 574:\n\n    { s = strdup(tmp_s);\n                                                      if (!s) {\n                                                        LOGMEM(trg->ctx);\n                                                        YYABORT;\n                                                      }\n                                                      s[strlen(s) - 1] = '\\0';\n                                                    }\n\n    break;\n\n  case 598:\n\n    { /* convert it to uint32_t */\n                                                unsigned long val;\n\n                                                val = strtoul(yyget_text(scanner), NULL, 10);\n                                                if (val > UINT32_MAX) {\n                                                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Converted number is very long.\");\n                                                    YYABORT;\n                                                }\n                                                (yyval.uint) = (uint32_t) val;\n                                             }\n\n    break;\n\n  case 599:\n\n    { (yyval.uint) = 0; }\n\n    break;\n\n  case 600:\n\n    { (yyval.uint) = (yyvsp[0].uint); }\n\n    break;\n\n  case 601:\n\n    { (yyval.i) = 0; }\n\n    break;\n\n  case 602:\n\n    { /* convert it to int32_t */\n                             int64_t val;\n\n                             val = strtoll(yyget_text(scanner), NULL, 10);\n                             if (val < INT32_MIN || val > INT32_MAX) {\n                                 LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                                        \"The number is not in the correct range (INT32_MIN..INT32_MAX): \\\"%d\\\"\",val);\n                                 YYABORT;\n                             }\n                             (yyval.i) = (int32_t) val;\n                           }\n\n    break;\n\n  case 608:\n\n    { if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                    free(s);\n                    YYABORT;\n                }\n              }\n\n    break;\n\n  case 613:\n\n    { char *tmp;\n\n               if ((tmp = strchr(s, ':'))) {\n                 *tmp = '\\0';\n                 /* check prefix */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 *tmp = ':';\n               } else {\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n               }\n             }\n\n    break;\n\n  case 614:\n\n    { s = (yyvsp[-1].str); }\n\n    break;\n\n  case 615:\n\n    { s = (yyvsp[-3].str); }\n\n    break;\n\n  case 616:\n\n    { actual_type = backup_type;\n                 backup_type = NODE;\n                 (yyval.str) = s;\n                 s = NULL;\n               }\n\n    break;\n\n  case 617:\n\n    { actual_type = backup_type;\n                           backup_type = NODE;\n                         }\n\n    break;\n\n  case 618:\n\n    { (yyval.str) = s;\n                          s = NULL;\n                        }\n\n    break;\n\n  case 622:\n\n    { actual_type = (yyvsp[-1].backup_token).token;\n                     actual = (yyvsp[-1].backup_token).actual;\n                   }\n\n    break;\n\n  case 623:\n\n    { (yyval.backup_token).token = actual_type;\n                                                (yyval.backup_token).actual = actual;\n                                                if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, (yyvsp[-1].str), s,\n                                                                             actual_type, backup_type, is_ext_instance))) {\n                                                  YYABORT;\n                                                }\n                                                s = NULL;\n                                                actual_type = EXTENSION_INSTANCE;\n                                              }\n\n    break;\n\n  case 624:\n\n    { (yyval.str) = s; s = NULL; }\n\n    break;\n\n  case 639:\n\n    {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length = 0, old_length = 0;\n        char *tmp_value;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen((yyvsp[-2].str));\n        old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;\n        tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_substmt = tmp_value;\n        tmp_value += old_length - 2;\n        memcpy(tmp_value, (yyvsp[-2].str), length);\n        tmp_value[length] = ' ';\n        tmp_value[length + 1] = '\\0';\n        tmp_value[length + 2] = '\\0';\n      }\n\n    break;\n\n  case 640:\n\n    {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length;\n        char *tmp_value, **array;\n        int i = 0;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen((yyvsp[-2].str));\n        if (!substmt->ext_modules) {\n          array = malloc(2 * sizeof *substmt->ext_modules);\n        } else {\n          for (i = 0; substmt->ext_modules[i]; ++i);\n          array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);\n        }\n        if (!array) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_modules = array;\n        array[i + 1] = NULL;\n        tmp_value = malloc(length + 2);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        array[i] = tmp_value;\n        memcpy(tmp_value, (yyvsp[-2].str), length);\n        tmp_value[length] = '\\0';\n        tmp_value[length + 1] = '\\0';\n      }\n\n    break;\n\n  case 643:\n\n    { (yyval.str) = yyget_text(scanner); }\n\n    break;\n\n  case 644:\n\n    { (yyval.str) = yyget_text(scanner); }\n\n    break;\n\n  case 656:\n\n    { s = strdup(yyget_text(scanner));\n                  if (!s) {\n                    LOGMEM(trg->ctx);\n                    YYABORT;\n                  }\n                }\n\n    break;\n\n  case 749:\n\n    { s = strdup(yyget_text(scanner));\n                          if (!s) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                        }\n\n    break;\n\n  case 750:\n\n    { s = strdup(yyget_text(scanner));\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                  }\n\n    break;\n\n  case 751:\n\n    { struct lys_type **type;\n\n                             type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                            \"type\", LY_STMT_TYPE);\n                             if (!type) {\n                               YYABORT;\n                             }\n                             /* allocate type structure */\n                             (*type) = calloc(1, sizeof **type);\n                             if (!*type) {\n                               LOGMEM(trg->ctx);\n                               YYABORT;\n                             }\n\n                             /* HACK for unres */\n                             (*type)->parent = (struct lys_tpdf *)ext_instance;\n                             (yyval.v) = actual = *type;\n                             is_ext_instance = 0;\n                            }\n\n    break;\n\n  case 752:\n\n    { struct lys_tpdf **tpdf;\n\n                                tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                               \"typedef\", LY_STMT_TYPEDEF);\n                                if (!tpdf) {\n                                  YYABORT;\n                                }\n                                /* allocate typedef structure */\n                                (*tpdf) = calloc(1, sizeof **tpdf);\n                                if (!*tpdf) {\n                                  LOGMEM(trg->ctx);\n                                  YYABORT;\n                                }\n\n                                (yyval.v) = actual = *tpdf;\n                                is_ext_instance = 0;\n                              }\n\n    break;\n\n  case 753:\n\n    { struct lys_iffeature **iffeature;\n\n                                 iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                          \"if-feature\", LY_STMT_IFFEATURE);\n                                 if (!iffeature) {\n                                   YYABORT;\n                                 }\n                                 /* allocate typedef structure */\n                                 (*iffeature) = calloc(1, sizeof **iffeature);\n                                 if (!*iffeature) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 (yyval.v) = actual = *iffeature;\n                               }\n\n    break;\n\n  case 754:\n\n    { struct lys_restr **restr;\n                                    LY_STMT stmt;\n\n                                    s = yyget_text(scanner);\n                                    if (!strcmp(s, \"must\")) {\n                                      stmt = LY_STMT_MUST;\n                                    } else if (!strcmp(s, \"pattern\")) {\n                                      stmt = LY_STMT_PATTERN;\n                                    } else if (!strcmp(s, \"range\")) {\n                                      stmt = LY_STMT_RANGE;\n                                    } else {\n                                      stmt = LY_STMT_LENGTH;\n                                    }\n                                    restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);\n                                    if (!restr) {\n                                      YYABORT;\n                                    }\n                                    /* allocate structure for must */\n                                    (*restr) = calloc(1, sizeof(struct lys_restr));\n                                    if (!*restr) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    (yyval.v) = actual = *restr;\n                                    s = NULL;\n                                  }\n\n    break;\n\n  case 755:\n\n    { actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, \"when\", LY_STMT_WHEN);\n                             if (!actual) {\n                               YYABORT;\n                             }\n                             (yyval.v) = actual;\n                           }\n\n    break;\n\n  case 756:\n\n    { struct lys_revision **rev;\n                                 int i;\n\n                                 rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,\n                                                                                                   \"revision\", LY_STMT_REVISION);\n                                 if (!rev) {\n                                   YYABORT;\n                                 }\n                                 rev[i] = calloc(1, sizeof **rev);\n                                 if (!rev[i]) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 actual = rev[i];\n                                 (yyval.revisions).revision = rev;\n                                 (yyval.revisions).index = i;\n                               }\n\n    break;\n\n  case 757:\n\n    { LY_STMT stmt;\n\n                                s = yyget_text(scanner);\n                                if (!strcmp(s, \"action\")) {\n                                  stmt = LY_STMT_ACTION;\n                                } else if (!strcmp(s, \"anydata\")) {\n                                  stmt = LY_STMT_ANYDATA;\n                                } else if (!strcmp(s, \"anyxml\")) {\n                                  stmt = LY_STMT_ANYXML;\n                                } else if (!strcmp(s, \"case\")) {\n                                  stmt = LY_STMT_CASE;\n                                } else if (!strcmp(s, \"choice\")) {\n                                  stmt = LY_STMT_CHOICE;\n                                } else if (!strcmp(s, \"container\")) {\n                                  stmt = LY_STMT_CONTAINER;\n                                } else if (!strcmp(s, \"grouping\")) {\n                                  stmt = LY_STMT_GROUPING;\n                                } else if (!strcmp(s, \"input\")) {\n                                  stmt = LY_STMT_INPUT;\n                                } else if (!strcmp(s, \"leaf\")) {\n                                  stmt = LY_STMT_LEAF;\n                                } else if (!strcmp(s, \"leaf-list\")) {\n                                  stmt = LY_STMT_LEAFLIST;\n                                } else if (!strcmp(s, \"list\")) {\n                                  stmt = LY_STMT_LIST;\n                                } else if (!strcmp(s, \"notification\")) {\n                                  stmt = LY_STMT_NOTIFICATION;\n                                } else if (!strcmp(s, \"output\")) {\n                                  stmt = LY_STMT_OUTPUT;\n                                } else {\n                                  stmt = LY_STMT_USES;\n                                }\n                                if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {\n                                  YYABORT;\n                                }\n                                actual = NULL;\n                                s = NULL;\n                                is_ext_instance = 0;\n                              }\n\n    break;\n\n  case 758:\n\n    { LOGERR(trg->ctx, ly_errno, \"Extension's substatement \\\"%s\\\" not supported.\", yyget_text(scanner)); }\n\n    break;\n\n  case 790:\n\n    { actual_type = EXTENSION_INSTANCE;\n                                actual = ext_instance;\n                                if (!is_ext_instance) {\n                                  LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n                                  YYABORT;\n                                }\n                                (yyval.i) = 0;\n                              }\n\n    break;\n\n  case 792:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", ext_name, &s,\n                                                                  0, LY_STMT_PREFIX)) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 793:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"description\", ext_name, &s,\n                                                                       0, LY_STMT_DESCRIPTION)) {\n                                            YYABORT;\n                                          }\n                                        }\n\n    break;\n\n  case 794:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"reference\", ext_name, &s,\n                                                                     0, LY_STMT_REFERENCE)) {\n                                          YYABORT;\n                                        }\n                                      }\n\n    break;\n\n  case 795:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"units\", ext_name, &s,\n                                                                     0, LY_STMT_UNITS)) {\n                                      YYABORT;\n                                    }\n                                  }\n\n    break;\n\n  case 796:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"base\", ext_name, &s,\n                                                                0, LY_STMT_BASE)) {\n                                     YYABORT;\n                                   }\n                                 }\n\n    break;\n\n  case 797:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"contact\", ext_name, &s,\n                                                                     0, LY_STMT_CONTACT)) {\n                                        YYABORT;\n                                      }\n                                    }\n\n    break;\n\n  case 798:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"default\", ext_name, &s,\n                                                                     0, LY_STMT_DEFAULT)) {\n                                        YYABORT;\n                                      }\n                                    }\n\n    break;\n\n  case 799:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"error-message\", ext_name, &s,\n                                                                         0, LY_STMT_ERRMSG)) {\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 800:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"error-app-tag\", ext_name, &s,\n                                                                         0, LY_STMT_ERRTAG)) {\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 801:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"key\", ext_name, &s,\n                                                               0, LY_STMT_KEY)) {\n                                    YYABORT;\n                                  }\n                                }\n\n    break;\n\n  case 802:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"namespace\", ext_name, &s,\n                                                                     0, LY_STMT_NAMESPACE)) {\n                                          YYABORT;\n                                        }\n                                      }\n\n    break;\n\n  case 803:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"organization\", ext_name, &s,\n                                                                        0, LY_STMT_ORGANIZATION)) {\n                                             YYABORT;\n                                           }\n                                         }\n\n    break;\n\n  case 804:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"path\", ext_name, &s,\n                                                                0, LY_STMT_PATH)) {\n                                     YYABORT;\n                                   }\n                                 }\n\n    break;\n\n  case 805:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"presence\", ext_name, &s,\n                                                                    0, LY_STMT_PRESENCE)) {\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 806:\n\n    { if (yang_read_extcomplex_str(trg, ext_instance, \"revision-date\", ext_name, &s,\n                                                                         0, LY_STMT_REVISIONDATE)) {\n                                              YYABORT;\n                                            }\n                                          }\n\n    break;\n\n  case 807:\n\n    { struct lys_type *type = (yyvsp[-2].v);\n\n       if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n\n    break;\n\n  case 808:\n\n    { struct lys_tpdf *tpdf = (yyvsp[-2].v);\n\n       if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {\n         yang_type_free(trg->ctx, &tpdf->type);\n       }\n       if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {\n         yang_type_free(trg->ctx, &tpdf->type);\n         YYABORT;\n       }\n       /* check default value*/\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n\n    break;\n\n  case 809:\n\n    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"status\", LY_STMT_STATUS,\n                                                                    (yyvsp[0].i), LYS_STATUS_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 810:\n\n    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"config\", LY_STMT_CONFIG,\n                                                                    (yyvsp[0].i), LYS_CONFIG_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 811:\n\n    { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"mandatory\", LY_STMT_MANDATORY,\n                                                                       (yyvsp[0].i), LYS_MAND_MASK)) {\n                                          YYABORT;\n                                        }\n                                      }\n\n    break;\n\n  case 812:\n\n    { if ((yyvsp[-1].i) & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"ordered by\", ext_name);\n                                            YYABORT;\n                                         }\n                                         if ((yyvsp[0].i) & LYS_USERORDERED) {\n                                           if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"ordered-by\", LY_STMT_ORDEREDBY,\n                                                                          (yyvsp[0].i), LYS_USERORDERED)) {\n                                             YYABORT;\n                                           }\n                                         }\n                                         (yyvsp[-1].i) |= (yyvsp[0].i);\n                                         (yyval.i) = (yyvsp[-1].i);\n                                       }\n\n    break;\n\n  case 813:\n\n    { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"require-instance\",\n                                                                              LY_STMT_REQINSTANCE, (yyvsp[0].i))) {\n                                                 YYABORT;\n                                               }\n                                             }\n\n    break;\n\n  case 814:\n\n    { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"modifier\", LY_STMT_MODIFIER, 0)) {\n                                         YYABORT;\n                                       }\n                                     }\n\n    break;\n\n  case 815:\n\n    { /* range check */\n       if ((yyvsp[0].uint) < 1 || (yyvsp[0].uint) > 18) {\n         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"fraction-digits\");\n         YYABORT;\n       }\n       if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"fraction-digits\", LY_STMT_DIGITS, (yyvsp[0].uint))) {\n         YYABORT;\n       }\n     }\n\n    break;\n\n  case 816:\n\n    { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"min-elements\", LY_STMT_MIN);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = (yyvsp[0].uint);\n                                         }\n\n    break;\n\n  case 817:\n\n    { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"max-elements\", LY_STMT_MAX);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = (yyvsp[0].uint);\n                                         }\n\n    break;\n\n  case 818:\n\n    { uint32_t **val;\n\n                                       val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                              \"position\", LY_STMT_POSITION);\n                                       if (!val) {\n                                         YYABORT;\n                                       }\n                                       /* store the value */\n                                       *val = malloc(sizeof(uint32_t));\n                                       if (!*val) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       **val = (yyvsp[0].uint);\n                                     }\n\n    break;\n\n  case 819:\n\n    { int32_t **val;\n\n                                    val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                          \"value\", LY_STMT_VALUE);\n                                    if (!val) {\n                                      YYABORT;\n                                    }\n                                    /* store the value */\n                                    *val = malloc(sizeof(int32_t));\n                                    if (!*val) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    **val = (yyvsp[0].i);\n                                  }\n\n    break;\n\n  case 820:\n\n    { struct lys_unique **unique;\n                                     int rc;\n\n                                     unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                        \"unique\", LY_STMT_UNIQUE);\n                                     if (!unique) {\n                                       YYABORT;\n                                     }\n                                     *unique = calloc(1, sizeof(struct lys_unique));\n                                     if (!*unique) {\n                                       LOGMEM(trg->ctx);\n                                       YYABORT;\n                                     }\n                                     rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);\n                                     free(s);\n                                     s = NULL;\n                                     if (rc) {\n                                       YYABORT;\n                                     }\n                                   }\n\n    break;\n\n  case 821:\n\n    { struct lys_iffeature *iffeature;\n\n       iffeature = (yyvsp[-2].v);\n       s = (char *)iffeature->features;\n       iffeature->features = NULL;\n       if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {\n         YYABORT;\n       }\n       if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {\n         YYABORT;\n       }\n       s = NULL;\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 823:\n\n    { if (yang_check_ext_instance(trg, &((struct lys_restr *)(yyvsp[-2].v))->ext, ((struct lys_restr *)(yyvsp[-2].v))->ext_size, (yyvsp[-2].v), param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 824:\n\n    { if (yang_check_ext_instance(trg, &(*(struct lys_when **)(yyvsp[-2].v))->ext, (*(struct lys_when **)(yyvsp[-2].v))->ext_size,\n                                   *(struct lys_when **)(yyvsp[-2].v), param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 825:\n\n    { int i;\n\n       for (i = 0; i < (yyvsp[-2].revisions).index; ++i) {\n         if (!strcmp((yyvsp[-2].revisions).revision[i]->date, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->date)) {\n           LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\", (yyvsp[-2].revisions).revision[i]->date);\n           break;\n         }\n       }\n       if (yang_check_ext_instance(trg, &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext_size,\n                                   &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index], param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n\n    break;\n\n  case 826:\n\n    { actual = ext_instance;\n                                                                    is_ext_instance = 1;\n                                                                  }\n\n    break;\n\n\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n  *++yylsp = yyloc;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (&yylloc, scanner, param, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (&yylloc, scanner, param, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n  yyerror_range[1] = yylloc;\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, &yylloc, scanner, param);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n      yyerror_range[1] = *yylsp;\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yylsp, scanner, param);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  yyerror_range[2] = yylloc;\n  /* Using YYLLOC is tempting, but would change the location of\n     the lookahead.  YYLOC is available though.  */\n  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);\n  *++yylsp = yyloc;\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (&yylloc, scanner, param, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, &yylloc, scanner, param);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yylsp, scanner, param);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}\n\n\n\nvoid\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }\n}\n", "/**\n * @file yang.y\n * @author Pavol Vican\n * @brief YANG parser for libyang (bison grammar)\n *\n * Copyright (c) 2015 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n%define api.pure full\n%locations\n\n%parse-param {void *scanner}\n%parse-param {struct yang_parameter *param}\n\n%lex-param {void *scanner}\n\n%{\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"libyang.h\"\n#include \"common.h\"\n#include \"context.h\"\n#include \"resolve.h\"\n#include \"parser_yang.h\"\n#include \"parser_yang_lex.h\"\n#include \"parser.h\"\n\n#define YANG_ADDELEM(current_ptr, size, array_name)                                      \\\n    if ((size) == LY_ARRAY_MAX(size)) {                                                  \\\n         LOGERR(trg->ctx, LY_EINT, \"Reached limit (%\"PRIu64\") for storing %s.\", LY_ARRAY_MAX(size), array_name); \\\n         free(s);                                                                        \\\n         YYABORT;                                                                        \\\n    } else if (!((size) % LY_YANG_ARRAY_SIZE)) {                                         \\\n        void *tmp;                                                                       \\\n                                                                                         \\\n        tmp = realloc((current_ptr), (sizeof *(current_ptr)) * ((size) + LY_YANG_ARRAY_SIZE)); \\\n        if (!tmp) {                                                                      \\\n            LOGMEM(trg->ctx);                                                            \\\n            free(s);                                                                     \\\n            YYABORT;                                                                     \\\n        }                                                                                \\\n        memset(tmp + (sizeof *(current_ptr)) * (size), 0, (sizeof *(current_ptr)) * LY_YANG_ARRAY_SIZE); \\\n        (current_ptr) = tmp;                                                             \\\n    }                                                                                    \\\n    actual = &(current_ptr)[(size)++];                                                   \\\n\nvoid yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...);\n/* pointer on the current parsed element 'actual' */\n%}\n\n%union {\n  int32_t i;\n  uint32_t uint;\n  char *str;\n  char **p_str;\n  void *v;\n  char ch;\n  struct yang_type *type;\n  struct lys_deviation *dev;\n  struct lys_deviate *deviate;\n  union {\n    uint32_t index;\n    struct lys_node_container *container;\n    struct lys_node_anydata *anydata;\n    struct type_node node;\n    struct lys_node_case *cs;\n    struct lys_node_grp *grouping;\n    struct lys_refine *refine;\n    struct lys_node_notif *notif;\n    struct lys_node_uses *uses;\n    struct lys_node_inout *inout;\n    struct lys_node_augment *augment;\n  } nodes;\n  enum yytokentype token;\n  struct {\n    void *actual;\n    enum yytokentype token;\n  } backup_token;\n  struct {\n    struct lys_revision **revision;\n    int index;\n  } revisions;\n}\n\n%token UNION_KEYWORD\n%token ANYXML_KEYWORD\n%token WHITESPACE\n%token ERROR\n%token EOL\n%token STRING\n%token STRINGS\n%token IDENTIFIER\n%token IDENTIFIERPREFIX\n%token REVISION_DATE\n%token TAB\n%token DOUBLEDOT\n%token URI\n%token INTEGER\n%token NON_NEGATIVE_INTEGER\n%token ZERO\n%token DECIMAL\n%token ARGUMENT_KEYWORD\n%token AUGMENT_KEYWORD\n%token BASE_KEYWORD\n%token BELONGS_TO_KEYWORD\n%token BIT_KEYWORD\n%token CASE_KEYWORD\n%token CHOICE_KEYWORD\n%token CONFIG_KEYWORD\n%token CONTACT_KEYWORD\n%token CONTAINER_KEYWORD\n%token DEFAULT_KEYWORD\n%token DESCRIPTION_KEYWORD\n%token ENUM_KEYWORD\n%token ERROR_APP_TAG_KEYWORD\n%token ERROR_MESSAGE_KEYWORD\n%token EXTENSION_KEYWORD\n%token DEVIATION_KEYWORD\n%token DEVIATE_KEYWORD\n%token FEATURE_KEYWORD\n%token FRACTION_DIGITS_KEYWORD\n%token GROUPING_KEYWORD\n%token IDENTITY_KEYWORD\n%token IF_FEATURE_KEYWORD\n%token IMPORT_KEYWORD\n%token INCLUDE_KEYWORD\n%token INPUT_KEYWORD\n%token KEY_KEYWORD\n%token LEAF_KEYWORD\n%token LEAF_LIST_KEYWORD\n%token LENGTH_KEYWORD\n%token LIST_KEYWORD\n%token MANDATORY_KEYWORD\n%token MAX_ELEMENTS_KEYWORD\n%token MIN_ELEMENTS_KEYWORD\n%token MODULE_KEYWORD\n%token MUST_KEYWORD\n%token NAMESPACE_KEYWORD\n%token NOTIFICATION_KEYWORD\n%token ORDERED_BY_KEYWORD\n%token ORGANIZATION_KEYWORD\n%token OUTPUT_KEYWORD\n%token PATH_KEYWORD\n%token PATTERN_KEYWORD\n%token POSITION_KEYWORD\n%token PREFIX_KEYWORD\n%token PRESENCE_KEYWORD\n%token RANGE_KEYWORD\n%token REFERENCE_KEYWORD\n%token REFINE_KEYWORD\n%token REQUIRE_INSTANCE_KEYWORD\n%token REVISION_KEYWORD\n%token REVISION_DATE_KEYWORD\n%token RPC_KEYWORD\n%token STATUS_KEYWORD\n%token SUBMODULE_KEYWORD\n%token TYPE_KEYWORD\n%token TYPEDEF_KEYWORD\n%token UNIQUE_KEYWORD\n%token UNITS_KEYWORD\n%token USES_KEYWORD\n%token VALUE_KEYWORD\n%token WHEN_KEYWORD\n%token YANG_VERSION_KEYWORD\n%token YIN_ELEMENT_KEYWORD\n%token ADD_KEYWORD\n%token CURRENT_KEYWORD\n%token DELETE_KEYWORD\n%token DEPRECATED_KEYWORD\n%token FALSE_KEYWORD\n%token NOT_SUPPORTED_KEYWORD\n%token OBSOLETE_KEYWORD\n%token REPLACE_KEYWORD\n%token SYSTEM_KEYWORD\n%token TRUE_KEYWORD\n%token UNBOUNDED_KEYWORD\n%token USER_KEYWORD\n%token ACTION_KEYWORD\n%token MODIFIER_KEYWORD\n%token ANYDATA_KEYWORD\n%token NODE\n%token NODE_PRINT\n%token EXTENSION_INSTANCE\n%token SUBMODULE_EXT_KEYWORD\n\n%type <uint> positive_integer_value\n%type <uint> non_negative_integer_value\n%type <uint> max_value_arg_str\n%type <uint> max_value_arg\n%type <uint> max_elements_stmt\n%type <uint> min_value_arg_str\n%type <uint> min_value_arg\n%type <uint> min_elements_stmt\n%type <uint> fraction_digits_arg_str\n%type <uint> fraction_digits_arg\n%type <uint> position_value_arg_str\n%type <uint> position_value_arg\n%type <uint> yin_element_arg_str\n%type <uint> yin_element_arg\n%type <uint> fraction_digits_stmt\n%type <uint> position_stmt\n%type <i> value_stmt\n%type <i> require_instance_stmt\n%type <i> require_instance_arg_str\n%type <i> require_instance_arg\n%type <i> import_opt_stmt\n%type <i> include_opt_stmt\n%type <i> module_header_stmt\n%type <i> submodule_header_stmt\n%type <str> message_opt_stmt\n%type <i> status_stmt\n%type <i> status_arg_str\n%type <i> status_arg\n%type <i> config_stmt\n%type <i> config_arg_str\n%type <i> config_arg\n%type <i> mandatory_stmt\n%type <i> mandatory_arg_str\n%type <i> mandatory_arg\n%type <i> ordered_by_stmt\n%type <i> ordered_by_arg_str\n%type <i> ordered_by_arg\n%type <i> integer_value_arg_str\n%type <i> value_arg\n%type <i> integer_value\n%type <i> ext_substatements\n%type <str> pattern_arg_str\n%type <nodes> container_opt_stmt\n%type <nodes> anyxml_opt_stmt\n%type <nodes> choice_opt_stmt\n%type <nodes> case_opt_stmt\n%type <nodes> grouping_opt_stmt\n%type <nodes> leaf_opt_stmt\n%type <nodes> leaf_list_opt_stmt\n%type <nodes> list_opt_stmt\n%type <nodes> type_opt_stmt\n%type <nodes> uses_opt_stmt\n%type <nodes> refine_body_opt_stmts\n%type <nodes> augment_opt_stmt\n%type <nodes> rpc_opt_stmt\n%type <nodes> notification_opt_stmt\n%type <dev> deviation_opt_stmt\n%type <deviate> deviate_add_opt_stmt\n%type <deviate> deviate_delete_opt_stmt\n%type <deviate> deviate_replace_opt_stmt\n%type <ch> pattern_opt_stmt\n%type <ch> pattern_end\n%type <ch> modifier_stmt\n%type <p_str> tmp_string\n%type <str> string_opt_part1\n%type <str> semicolom\n%type <str> curly_bracket_open\n%type <str> unknown_statement2_yang_stmt\n%type <str> unknown_statement2_module_stmt\n%type <v> type_ext_alloc\n%type <v> typedef_ext_alloc\n%type <v> iffeature_ext_alloc\n%type <v> restriction_ext_alloc\n%type <v> when_ext_alloc\n%type <revisions> revision_ext_alloc\n%type <token> import_arg_str\n%type <token> include_arg_str\n%type <token> argument_str\n%type <token> belongs_to_arg_str\n%type <backup_token> revision_arg_stmt\n%type <backup_token> grouping_arg_str\n%type <backup_token> container_arg_str\n%type <backup_token> leaf_arg_str\n%type <backup_token> leaf_list_arg_str\n%type <backup_token> list_arg_str\n%type <backup_token> choice_arg_str\n%type <backup_token> case_arg_str\n%type <backup_token> anyxml_arg_str\n%type <backup_token> anydata_arg_str\n%type <backup_token> uses_arg_str\n%type <backup_token> uses_augment_arg\n%type <backup_token> augment_arg\n%type <backup_token> action_arg_str\n%type <backup_token> rpc_arg_str\n%type <backup_token> input_arg\n%type <backup_token> output_arg\n%type <backup_token> notification_arg_str\n%type <backup_token> extension_arg_str\n%type <backup_token> feature_arg_str\n%type <backup_token> identity_arg_str\n%type <backup_token> if_feature_arg\n%type <backup_token> typedef_arg_str\n%type <backup_token> type_arg_str\n%type <backup_token> length_arg_str\n%type <backup_token> pattern_sep\n%type <backup_token> range_arg_str\n%type <backup_token> union_spec\n%type <backup_token> enum_arg_str\n%type <backup_token> bit_arg_str\n%type <backup_token> when_arg_str\n%type <backup_token> must_agr_str\n%type <backup_token> refine_arg_str\n%type <backup_token> deviation_arg\n%type <backup_token> deviate_not_supported\n%type <backup_token> deviate_add\n%type <backup_token> deviate_delete\n%type <backup_token> deviate_replace\n%type <backup_token> string_opt\n\n%destructor { free($$); } pattern_arg_str string_opt_part1 semicolom curly_bracket_open\n%destructor { free(($$) ? *$$ : NULL); } tmp_string\n%destructor { yang_type_free(param->module->ctx, $$); } type_ext_alloc\n%destructor { yang_type_free(param->module->ctx, &((struct lys_tpdf *)$$)->type); } typedef_ext_alloc\n\n%initial-action { yylloc.last_column = 0;\n                  if (param->flags & EXT_INSTANCE_SUBSTMT) {\n                    is_ext_instance = 1;\n                    ext_instance = (struct lys_ext_instance_complex *)param->actual_node;\n                    ext_name = (char *)param->data_node;\n                  } else {\n                    is_ext_instance = 0;\n                  }\n                  yylloc.last_line = is_ext_instance;     /* HACK for flex - return SUBMODULE_KEYWORD or SUBMODULE_EXT_KEYWORD */\n                  param->value = &s;\n                  param->data_node = (void **)&data_node;\n                  param->actual_node = &actual;\n                  backup_type = NODE;\n                  trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;\n                }\n\n%%\n\n/* to simplify code, store the module/submodule being processed as trg */\n\nstart: module_stmt\n |  submodule_stmt\n |  ext_substatements\n\ntmp_string: STRING { if (yyget_text(scanner)[0] == '\"') {\n                      char *tmp;\n\n                      s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {\n                        YYABORT;\n                      }\n                      s = tmp;\n                    } else {\n                      s = calloc(1, yyget_leng(scanner) - 1);\n                      if (!s) {\n                        LOGMEM(trg->ctx);\n                        YYABORT;\n                      }\n                      memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);\n                    }\n                    $$ = &s;\n                  }\n\nstring_1: tmp_string optsep string_2\n\n\nstring_2: @EMPTYDIR@\n  |  string_2 '+' optsep\n     STRING { if (yyget_leng(scanner) > 2) {\n                int length_s = strlen(s), length_tmp = yyget_leng(scanner);\n                char *tmp;\n\n                tmp = realloc(s, length_s + length_tmp - 1);\n                if (!tmp) {\n                  LOGMEM(trg->ctx);\n                  YYABORT;\n                }\n                s = tmp;\n                if (yyget_text(scanner)[0] == '\"') {\n                  if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {\n                    YYABORT;\n                  }\n                  s = tmp;\n                } else {\n                  memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);\n                  s[length_s + length_tmp - 2] = '\\0';\n                }\n              }\n            }\n     optsep;\n\nmodule_arg_str: identifier_arg_str { if (param->submodule) {\n                                       free(s);\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"module\");\n                                       YYABORT;\n                                     }\n                                     trg = param->module;\n                                     yang_read_common(trg,s,MODULE_KEYWORD);\n                                     s = NULL;\n                                     actual_type = MODULE_KEYWORD;\n                                   }\n\nmodule_stmt: optsep MODULE_KEYWORD sep module_arg_str\n             '{' stmtsep\n                 module_header_stmts\n                 linkage_stmts\n                 meta_stmts\n                 revision_stmts\n                 body_stmts_end\n             '}' optsep\n\n\nmodule_header_stmts: module_header_stmt { if (!param->module->ns) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"namespace\", \"module\");\n                                            YYABORT;\n                                          }\n                                          if (!param->module->prefix) {\n                                            LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"module\");\n                                            YYABORT;\n                                          }\n                                        }\n\nmodule_header_stmt: @EMPTYDIR@  { $$ = 0; }\n  |  module_header_stmt yang_version_stmt { if (yang_check_version(param->module, param->submodule, s, $1)) {\n                                              YYABORT;\n                                            }\n                                            $$ = 1;\n                                            s = NULL;\n                                          }\n  |  module_header_stmt namespace_stmt { if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  module_header_stmt prefix_stmt { if (yang_read_prefix(trg, NULL, s)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\nsubmodule_arg_str: identifier_arg_str { if (!param->submodule) {\n                                          free(s);\n                                          LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);\n                                          YYABORT;\n                                        }\n                                        trg = (struct lys_module *)param->submodule;\n                                        yang_read_common(trg,s,MODULE_KEYWORD);\n                                        s = NULL;\n                                        actual_type = SUBMODULE_KEYWORD;\n                                      }\n\nsubmodule_stmt: optsep SUBMODULE_KEYWORD sep submodule_arg_str\n                '{' stmtsep\n                    submodule_header_stmts\n                    linkage_stmts\n                    meta_stmts\n                    revision_stmts\n                    body_stmts_end\n                '}' optsep\n\n\nsubmodule_header_stmts: submodule_header_stmt { if (!param->submodule->prefix) {\n                                                  LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                                  YYABORT;\n                                                }\n                                                if (!$1) {\n                                                  /* check version compatibility with the main module */\n                                                  if (param->module->version > 1) {\n                                                      LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);\n                                                      YYABORT;\n                                                  }\n                                                }\n                                              }\n\nsubmodule_header_stmt: @EMPTYDIR@ { $$ = 0; }\n  |  submodule_header_stmt yang_version_stmt { if (yang_check_version(param->module, param->submodule, s, $1)) {\n                                                 YYABORT;\n                                               }\n                                               $$ = 1;\n                                               s = NULL;\n                                             }\n  |  submodule_header_stmt belongs_to_stmt stmtsep\n\nyang_version_arg: string { backup_type = actual_type;\n                           actual_type = YANG_VERSION_KEYWORD;\n                         }\n\nyang_version_stmt: YANG_VERSION_KEYWORD sep yang_version_arg stmtend\n\nnamespace_arg_str: string { backup_type = actual_type;\n                            actual_type = NAMESPACE_KEYWORD;\n                          }\n\nnamespace_stmt: NAMESPACE_KEYWORD sep namespace_arg_str stmtend\n\nlinkage_stmts: @EMPTYDIR@\n |  linkage_stmts import_stmt stmtsep\n |  linkage_stmts include_stmt stmtsep\n\nimport_stmt: IMPORT_KEYWORD sep import_arg_str\n             '{' stmtsep\n                 import_opt_stmt\n             '}' { actual_type = $3;\n                   backup_type = NODE;\n                   actual = NULL;\n                 }\n\nimport_arg_str: identifier_arg_str { YANG_ADDELEM(trg->imp, trg->imp_size, \"imports\");\n                                     /* HACK for unres */\n                                     ((struct lys_import *)actual)->module = (struct lys_module *)s;\n                                     s = NULL;\n                                     $$ = actual_type;\n                                     actual_type = IMPORT_KEYWORD;\n                                   }\n\nimport_opt_stmt: @EMPTYDIR@ { $$ = 0; }\n  |  import_opt_stmt prefix_stmt { if (yang_read_prefix(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  import_opt_stmt description_stmt { if (trg->version != 2) {\n                                          LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                          free(s);\n                                          YYABORT;\n                                        }\n                                        if (yang_read_description(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        $$ = $1;\n                                      }\n  |  import_opt_stmt reference_stmt { if (trg->version != 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      if (yang_read_reference(trg, actual, s, \"import\", IMPORT_KEYWORD)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      $$ = $1;\n                                    }\n  |  import_opt_stmt revision_date_stmt { if ($1) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"import\");\n                                            free(s);\n                                            YYABORT;\n                                          }\n                                          memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);\n                                          free(s);\n                                          s = NULL;\n                                          $$ = 1;\n                                        }\n\ninclude_arg_str: identifier_arg_str { YANG_ADDELEM(trg->inc, trg->inc_size, \"includes\");\n                                     /* HACK for unres */\n                                     ((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;\n                                     s = NULL;\n                                     $$ = actual_type;\n                                     actual_type = INCLUDE_KEYWORD;\n                                   }\n\ninclude_stmt: INCLUDE_KEYWORD sep include_arg_str include_end { actual_type = $3;\n                                                                backup_type = NODE;\n                                                                actual = NULL;\n                                                              }\n\ninclude_end: ';'\n  | '{' stmtsep\n        include_opt_stmt\n    '}'\n\ninclude_opt_stmt: @EMPTYDIR@ { $$ = 0; }\n  |  include_opt_stmt description_stmt { if (trg->version != 2) {\n                                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");\n                                           free(s);\n                                           YYABORT;\n                                         }\n                                         if (yang_read_description(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                            YYABORT;\n                                         }\n                                         s = NULL;\n                                         $$ = $1;\n                                       }\n  |  include_opt_stmt reference_stmt { if (trg->version != 2) {\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");\n                                         free(s);\n                                         YYABORT;\n                                       }\n                                       if (yang_read_reference(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       $$ = $1;\n                                     }\n  |  include_opt_stmt revision_date_stmt { if ($1) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"include\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);\n                                           free(s);\n                                           s = NULL;\n                                           $$ = 1;\n                                         }\n\nrevision_date_arg: date_arg_str { backup_type = actual_type;\n                                  actual_type = REVISION_DATE_KEYWORD;\n                                }\n\nrevision_date_stmt: REVISION_DATE_KEYWORD sep revision_date_arg stmtend\n\nbelongs_to_arg_str: identifier_arg_str { $$ = actual_type;\n                                         if (is_ext_instance) {\n                                           if (yang_read_extcomplex_str(trg, ext_instance, \"belongs-to\", ext_name, &s,\n                                                                        0, LY_STMT_BELONGSTO)) {\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           if (param->submodule->prefix) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {\n                                             LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"belongs-to\");\n                                             free(s);\n                                             YYABORT;\n                                           }\n                                           free(s);\n                                         }\n                                         s = NULL;\n                                         actual_type = BELONGS_TO_KEYWORD;\n                                       }\n\nbelongs_to_stmt: BELONGS_TO_KEYWORD sep belongs_to_arg_str\n                 '{' stmtsep\n                     prefix_stmt\n                 '}' { if (is_ext_instance) {\n                         if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", \"belongs-to\", &s,\n                                                      LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {\n                           YYABORT;\n                         }\n                       } else {\n                         if (yang_read_prefix(trg, NULL, s)) {\n                           YYABORT;\n                         }\n                       }\n                       s = NULL;\n                       actual_type = $3;\n                     }\n\nprefix_arg: prefix_arg_str { backup_type = actual_type;\n                             actual_type = PREFIX_KEYWORD;\n                           }\n\nprefix_stmt: PREFIX_KEYWORD sep prefix_arg stmtend\n\nmeta_stmts: @EMPTYDIR@\n  |  meta_stmts organization_stmt { if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  meta_stmts contact_stmt { if (yang_read_common(trg, s, CONTACT_KEYWORD)) {\n                                 YYABORT;\n                               }\n                               s = NULL;\n                             }\n  |  meta_stmts description_stmt { if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  meta_stmts reference_stmt { if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {\n                                   YYABORT;\n                                 }\n                                 s=NULL;\n                               }\n\norganization_arg: string { backup_type = actual_type;\n                           actual_type = ORGANIZATION_KEYWORD;\n                         }\n\norganization_stmt: ORGANIZATION_KEYWORD sep organization_arg stmtend\n\ncontact_arg: string { backup_type = actual_type;\n                      actual_type = CONTACT_KEYWORD;\n                    }\n\ncontact_stmt: CONTACT_KEYWORD sep contact_arg stmtend\n\ndescription_arg: string { backup_type = actual_type;\n                          actual_type = DESCRIPTION_KEYWORD;\n                        }\n\ndescription_stmt: DESCRIPTION_KEYWORD sep description_arg stmtend\n\nreference_arg: string { backup_type = actual_type;\n                        actual_type = REFERENCE_KEYWORD;\n                      }\n\nreference_stmt: REFERENCE_KEYWORD sep reference_arg stmtend\n\nrevision_stmts: revision_stmts_opt { if (trg->rev_size) {\n                                      struct lys_revision *tmp;\n\n                                      tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);\n                                      if (!tmp) {\n                                        LOGMEM(trg->ctx);\n                                        YYABORT;\n                                      }\n                                      trg->rev = tmp;\n                                    }\n                                  }\n\n\nrevision_arg_stmt: date_arg_str { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  if (!is_ext_instance) {\n                                    YANG_ADDELEM(trg->rev, trg->rev_size, \"revisions\");\n                                  }\n                                  memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);\n                                  free(s);\n                                  s = NULL;\n                                  actual_type = REVISION_KEYWORD;\n                                }\n\nrevision_stmts_opt: @EMPTYDIR@\n  |  revision_stmts_opt revision_stmt stmtsep { int i;\n\n                                                /* check uniqueness of the revision date - not required by RFC */\n                                                for (i = 0; i < (trg->rev_size - 1); i++) {\n                                                  if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {\n                                                    LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\",\n                                                           trg->rev[trg->rev_size - 1].date);\n                                                    break;\n                                                  }\n                                                }\n                                              }\n\nrevision_stmt: REVISION_KEYWORD sep revision_arg_stmt revision_end { actual_type = $3.token;\n                                                                     actual = $3.actual;\n                                                                   }\n\nrevision_end: ';'\n  | '{' stmtsep\n        revision_opt_stmt\n    '}'\n\nrevision_opt_stmt: @EMPTYDIR@\n  |  revision_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"revision\",REVISION_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  revision_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"revision\", REVISION_KEYWORD)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  ;\n\ndate_arg_str: REVISION_DATE { s = strdup(yyget_text(scanner));\n                              if (!s) {\n                                LOGMEM(trg->ctx);\n                                YYABORT;\n                              }\n                              if (lyp_check_date(trg->ctx, s)) {\n                                  free(s);\n                                  YYABORT;\n                              }\n                            }\n              optsep\n  | string_1 { if (lyp_check_date(trg->ctx, s)) {\n                   free(s);\n                   YYABORT;\n               }\n             }\n\nbody_stmts_end: body_stmts { void *tmp;\n\n                             if (trg->tpdf_size) {\n                               tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->tpdf = tmp;\n                             }\n\n                             if (trg->features_size) {\n                               tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->features = tmp;\n                             }\n\n                             if (trg->ident_size) {\n                               tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->ident = tmp;\n                             }\n\n                             if (trg->augment_size) {\n                               tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->augment = tmp;\n                             }\n\n                             if (trg->extensions_size) {\n                               tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);\n                               if (!tmp) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                               trg->extensions = tmp;\n                             }\n                           }\n\nbody_stmts: @EMPTYDIR@ { /* check the module with respect to the context now */\n                         if (!param->submodule) {\n                           switch (lyp_ctx_check_module(trg)) {\n                           case -1:\n                             YYABORT;\n                           case 0:\n                             break;\n                           case 1:\n                             /* it's already there */\n                             param->flags |= YANG_EXIST_MODULE;\n                             YYABORT;\n                           }\n                         }\n                         param->flags &= (~YANG_REMOVE_IMPORT);\n                         if (yang_check_imports(trg, param->unres)) {\n                           YYABORT;\n                         }\n                         actual = NULL;\n                       }\n  | body_stmts body_stmt stmtsep { actual = NULL; }\n\n\nbody_stmt: extension_stmt\n  | feature_stmt\n  | identity_stmt\n  | typedef_stmt\n  | grouping_stmt\n  | data_def_stmt\n  | augment_stmt\n  | rpc_stmt\n  | notification_stmt\n  | deviation_stmt\n\n\nextension_arg_str: identifier_arg_str { $$.token = actual_type;\n                                        $$.actual = actual;\n                                        YANG_ADDELEM(trg->extensions, trg->extensions_size, \"extensions\");\n                                        trg->extensions_size--;\n                                        ((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                        ((struct lys_ext *)actual)->module = trg;\n                                        if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {\n                                          trg->extensions_size++;\n                                          YYABORT;\n                                        }\n                                        trg->extensions_size++;\n                                        s = NULL;\n                                        actual_type = EXTENSION_KEYWORD;\n                                      }\n\nextension_stmt: EXTENSION_KEYWORD sep extension_arg_str extension_end\n                { struct lys_ext *ext = actual;\n                  ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                }\n\nextension_end: ';'\n  | '{' stmtsep\n        extension_opt_stmt\n    '}'\n\nextension_opt_stmt: @EMPTYDIR@\n  |  extension_opt_stmt argument_stmt stmtsep\n  |  extension_opt_stmt status_stmt { if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"extension\");\n                                        YYABORT;\n                                      }\n                                      ((struct lys_ext *)actual)->flags |= $2;\n                                    }\n  |  extension_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"extension\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  extension_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"extension\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\nargument_str: identifier_arg_str { $$ = actual_type;\n                                   if (is_ext_instance) {\n                                     if (yang_read_extcomplex_str(trg, ext_instance, \"argument\", ext_name, &s,\n                                                                  0, LY_STMT_ARGUMENT)) {\n                                       YYABORT;\n                                     }\n                                   } else {\n                                     if (((struct lys_ext *)actual)->argument) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"argument\", \"extension\");\n                                        free(s);\n                                        YYABORT;\n                                     }\n                                     ((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);\n                                   }\n                                   s = NULL;\n                                   actual_type = ARGUMENT_KEYWORD;\n                                 }\n\nargument_stmt: ARGUMENT_KEYWORD sep  argument_str argument_end { actual_type = $3; }\n\nargument_end: ';'\n  | '{' stmtsep\n        yin_element_stmt\n    '}'\n\nyin_element_arg: yin_element_arg_str { $$ = $1;\n                                       backup_type = actual_type;\n                                       actual_type = YIN_ELEMENT_KEYWORD;\n                                     }\n\nyin_element_stmt: @EMPTYDIR@\n  |  YIN_ELEMENT_KEYWORD sep yin_element_arg stmtend\n     { if (is_ext_instance) {\n         int c;\n         const char ***p;\n         uint8_t *val;\n         struct lyext_substmt *info;\n\n         c = 0;\n         p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);\n         if (info->cardinality >= LY_STMT_CARD_SOME) {\n           /* get the index in the array to add new item */\n           for (c = 0; p[0][c + 1]; c++);\n           val = (uint8_t *)p[1];\n         } else {\n           val = (uint8_t *)(p + 1);\n         }\n         val[c] = ($3 == LYS_YINELEM) ? 1 : 2;\n       } else {\n         ((struct lys_ext *)actual)->flags |= $3;\n       }\n     }\n\nyin_element_arg_str: TRUE_KEYWORD optsep { $$ = LYS_YINELEM; }\n  | FALSE_KEYWORD optsep { $$ = 0; }\n  | string_1 { if (!strcmp(s, \"true\")) {\n                 $$ = LYS_YINELEM;\n               } else if (!strcmp(s, \"false\")) {\n                 $$ = 0;\n               } else {\n                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\nstatus_arg: status_arg_str { $$ = $1;\n                             backup_type = actual_type;\n                             actual_type = STATUS_KEYWORD;\n                           }\n\nstatus_stmt:  STATUS_KEYWORD sep status_arg stmtend { $$ = $3; }\n\nstatus_arg_str: CURRENT_KEYWORD optsep { $$ = LYS_STATUS_CURR; }\n  | OBSOLETE_KEYWORD optsep { $$ = LYS_STATUS_OBSLT; }\n  | DEPRECATED_KEYWORD optsep { $$ = LYS_STATUS_DEPRC; }\n  | string_1 { if (!strcmp(s, \"current\")) {\n                 $$ = LYS_STATUS_CURR;\n               } else if (!strcmp(s, \"obsolete\")) {\n                 $$ = LYS_STATUS_OBSLT;\n               } else if (!strcmp(s, \"deprecated\")) {\n                 $$ = LYS_STATUS_DEPRC;\n               } else {\n                 LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                 free(s);\n                 YYABORT;\n               }\n               free(s);\n               s = NULL;\n             }\n\nfeature_arg_str: identifier_arg_str { /* check uniqueness of feature's names */\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      $$.token = actual_type;\n                                      $$.actual = actual;\n                                      YANG_ADDELEM(trg->features, trg->features_size, \"features\");\n                                      ((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);\n                                      ((struct lys_feature *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = FEATURE_KEYWORD;\n                                    }\n\nfeature_stmt: FEATURE_KEYWORD sep feature_arg_str feature_end\n              { actual = $3.actual;\n                actual_type = $3.token;\n              }\n\nfeature_end: ';'\n  | '{' stmtsep\n        feature_opt_stmt\n    '}' { struct lys_iffeature *tmp;\n\n          if (((struct lys_feature *)actual)->iffeature_size) {\n            tmp = realloc(((struct lys_feature *)actual)->iffeature,\n                          ((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);\n            if (!tmp) {\n              LOGMEM(trg->ctx);\n              YYABORT;\n            }\n            ((struct lys_feature *)actual)->iffeature = tmp;\n          }\n        }\n\nfeature_opt_stmt: @EMPTYDIR@\n  |  feature_opt_stmt if_feature_stmt stmtsep\n  |  feature_opt_stmt status_stmt { if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"feature\");\n                                      YYABORT;\n                                    }\n                                    ((struct lys_feature *)actual)->flags |= $2;\n                                  }\n  |  feature_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"feature\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  feature_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"feature\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\nif_feature_arg: string { $$.token = actual_type;\n                         $$.actual = actual;\n                         switch (actual_type) {\n                         case FEATURE_KEYWORD:\n                           YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,\n                                        ((struct lys_feature *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case IDENTITY_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"identity\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,\n                                        ((struct lys_ident *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case ENUM_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,\n                                        ((struct lys_type_enum *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case BIT_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"bit\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,\n                                        ((struct lys_type_bit *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case REFINE_KEYWORD:\n                           if (trg->version < 2) {\n                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");\n                             free(s);\n                             YYABORT;\n                           }\n                           YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,\n                                        ((struct lys_refine *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         case EXTENSION_INSTANCE:\n                           /* nothing change */\n                           break;\n                         default:\n                           /* lys_node_* */\n                           YANG_ADDELEM(((struct lys_node *)actual)->iffeature,\n                                        ((struct lys_node *)actual)->iffeature_size, \"if-features\");\n                           break;\n                         }\n                         ((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;\n                         s = NULL;\n                         actual_type = IF_FEATURE_KEYWORD;\n                       }\n\nif_feature_stmt: IF_FEATURE_KEYWORD sep if_feature_arg if_feature_end\n                 { actual = $3.actual;\n                   actual_type = $3.token;\n                 }\n\nif_feature_end: ';'\n  | '{' stmtsep '}'\n\nidentity_arg_str: identifier_arg_str { const char *tmp;\n\n                                       tmp = lydict_insert_zc(trg->ctx, s);\n                                       s = NULL;\n                                       if (dup_identities_check(tmp, trg)) {\n                                         lydict_remove(trg->ctx, tmp);\n                                         YYABORT;\n                                       }\n                                       $$.token = actual_type;\n                                       $$.actual = actual;\n                                       YANG_ADDELEM(trg->ident, trg->ident_size, \"identities\");\n                                       ((struct lys_ident *)actual)->name = tmp;\n                                       ((struct lys_ident *)actual)->module = trg;\n                                       actual_type = IDENTITY_KEYWORD;\n                                     }\n\nidentity_stmt: IDENTITY_KEYWORD sep identity_arg_str identity_end\n               { actual = $3.actual;\n                 actual_type = $3.token;\n               }\n\nidentity_end: ';'\n  |  '{' stmtsep\n         identity_opt_stmt\n     '}' { void *tmp;\n\n           if (((struct lys_ident *)actual)->base_size) {\n             tmp = realloc(((struct lys_ident *)actual)->base,\n                           ((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->base = tmp;\n           }\n\n           if (((struct lys_ident *)actual)->iffeature_size) {\n             tmp = realloc(((struct lys_ident *)actual)->iffeature,\n                           ((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_ident *)actual)->iffeature = tmp;\n           }\n         }\n\nidentity_opt_stmt: @EMPTYDIR@\n  |  identity_opt_stmt base_stmt { void *identity;\n\n                                   if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {\n                                     free(s);\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"base\", \"identity\");\n                                     YYABORT;\n                                   }\n                                   identity = actual;\n                                   YANG_ADDELEM(((struct lys_ident *)actual)->base,\n                                                ((struct lys_ident *)actual)->base_size, \"bases\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   s = NULL;\n                                   actual = identity;\n                                 }\n  |  identity_opt_stmt if_feature_stmt stmtsep\n  |  identity_opt_stmt status_stmt { if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"identity\");\n                                       YYABORT;\n                                     }\n                                     ((struct lys_ident *)actual)->flags |= $2;\n                                   }\n  |  identity_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"identity\", NODE)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  identity_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"identity\", NODE)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n\nbase_arg: identifier_ref_arg_str { backup_type = actual_type;\n                                   actual_type = BASE_KEYWORD;\n                                 }\n\nbase_stmt: BASE_KEYWORD sep base_arg stmtend\n\ntypedef_arg_str: identifier_arg_str { tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;\n                                      $$.token = actual_type;\n                                      $$.actual = actual;\n                                      if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      switch (actual_type) {\n                                      case MODULE_KEYWORD:\n                                      case SUBMODULE_KEYWORD:\n                                        YANG_ADDELEM(trg->tpdf, trg->tpdf_size, \"typedefs\");\n                                        break;\n                                      case GROUPING_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_grp *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case CONTAINER_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_container *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case LIST_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_list *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case RPC_KEYWORD:\n                                      case ACTION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case INPUT_KEYWORD:\n                                      case OUTPUT_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_inout *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case NOTIFICATION_KEYWORD:\n                                        YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,\n                                                     ((struct lys_node_notif *)tpdf_parent)->tpdf_size, \"typedefs\");\n                                        break;\n                                      case EXTENSION_INSTANCE:\n                                        /* typedef is already allocated */\n                                        break;\n                                      default:\n                                        /* another type of nodetype is error*/\n                                        LOGINT(trg->ctx);\n                                        free(s);\n                                        YYABORT;\n                                      }\n                                      ((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);\n                                      ((struct lys_tpdf *)actual)->module = trg;\n                                      s = NULL;\n                                      actual_type = TYPEDEF_KEYWORD;\n                                    }\n\ntypedef_stmt: TYPEDEF_KEYWORD sep typedef_arg_str\n              '{' stmtsep\n                  type_opt_stmt\n              '}' { if (!($6.node.flag & LYS_TYPE_DEF)) {\n                      LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"typedef\");\n                      YYABORT;\n                    }\n                    actual_type = $3.token;\n                    actual = $3.actual;\n                  }\n\ntype_opt_stmt: @EMPTYDIR@ { $$.node.ptr_tpdf = actual;\n                            $$.node.flag = 0;\n                          }\n  |  type_opt_stmt type_stmt stmtsep { $1.node.flag |= LYS_TYPE_DEF;\n                                       $$ = $1;\n                                     }\n  |  type_opt_stmt units_stmt { if (yang_read_units(trg, $1.node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n  |  type_opt_stmt default_stmt { if (yang_read_default(trg, $1.node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n  |  type_opt_stmt status_stmt { if ($1.node.ptr_tpdf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"typedef\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_tpdf->flags |= $2;\n                               }\n  |  type_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  type_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_tpdf, s, \"typedef\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\ntype_stmt: TYPE_KEYWORD sep type_arg_str type_end\n           { actual_type = $3.token;\n             actual = $3.actual;\n           }\n\ntype_arg_str: identifier_ref_arg_str { $$.token = actual_type;\n                                       $$.actual = actual;\n                                       if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       actual_type = TYPE_KEYWORD;\n                                     }\n\ntype_end: ';'\n  |  '{' stmtsep\n         type_body_stmts\n      '}'\n\ntype_body_stmts: some_restrictions { if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&\n                                         ((struct yang_type *)actual)->type->info.str.pat_count) {\n                                       void *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,\n                                                     ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.str.patterns = tmp;\n\n#ifdef LY_ENABLED_CACHE\n                                       if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,\n                                                       2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;\n                                       }\n#endif\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {\n                                       struct lys_type *tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,\n                                                     ((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.uni.types = tmp;\n                                     }\n                                     if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {\n                                       struct lys_ident **tmp;\n\n                                       tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,\n                                                     ((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);\n                                       if (!tmp) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       ((struct yang_type *)actual)->type->info.ident.ref = tmp;\n                                     }\n                                   }\n  | enum_specification\n  | bits_specification\n\nsome_restrictions: @EMPTYDIR@\n  |  some_restrictions require_instance_stmt { if (yang_read_require_instance(trg->ctx, actual, $2)) {\n                                                 YYABORT;\n                                               }\n                                             }\n  |  some_restrictions path_stmt { /* leafref_specification */\n                                   if (yang_read_leafref_path(trg, actual, s)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  some_restrictions base_stmt { /* identityref_specification */\n                                   if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {\n                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");\n                                     return EXIT_FAILURE;\n                                   }\n                                   ((struct yang_type *)actual)->base = LY_TYPE_IDENT;\n                                   yang_type = actual;\n                                   YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,\n                                                ((struct yang_type *)actual)->type->info.ident.count, \"identity refs\");\n                                   *((struct lys_ident **)actual) = (struct lys_ident *)s;\n                                   actual = yang_type;\n                                   s = NULL;\n                                 }\n  |  some_restrictions length_stmt stmtsep\n  |  some_restrictions pattern_stmt stmtsep\n  |  some_restrictions fraction_digits_stmt { if (yang_read_fraction(trg->ctx, actual, $2)) {\n                                                YYABORT;\n                                              }\n                                            }\n  |  some_restrictions range_stmt stmtsep\n  |  some_restrictions union_stmt stmtsep\n\nunion_stmt: union_spec type_stmt { actual_type = $1.token;\n                                   actual = $1.actual;\n                                 }\n\nunion_spec: @EMPTYDIR@ { struct yang_type *stype = (struct yang_type *)actual;\n\n                         $$.token = actual_type;\n                         $$.actual = actual;\n                         if (stype->base != 0 && stype->base != LY_TYPE_UNION) {\n                           LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected type statement.\");\n                           YYABORT;\n                         }\n                         stype->base = LY_TYPE_UNION;\n                         if (strcmp(stype->name, \"union\")) {\n                           /* type can be a substatement only in \"union\" type, not in derived types */\n                           LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"derived type\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, \"union types\")\n                         actual_type = UNION_KEYWORD;\n                       }\n\nfraction_digits_arg: fraction_digits_arg_str { $$ = $1;\n                                               backup_type = actual_type;\n                                               actual_type = FRACTION_DIGITS_KEYWORD;\n                                             }\n\nfraction_digits_stmt: FRACTION_DIGITS_KEYWORD sep fraction_digits_arg stmtend { $$ = $3; }\n\nfraction_digits_arg_str: positive_integer_value optsep { $$ = $1; }\n  | string_1 { char *endptr = NULL;\n               unsigned long val;\n               errno = 0;\n\n               val = strtoul(s, &endptr, 10);\n               if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                 LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"fraction-digits\");\n                 free(s);\n                 s = NULL;\n                 YYABORT;\n               }\n               $$ = (uint32_t) val;\n               free(s);\n               s =NULL;\n             }\n\nlength_stmt: LENGTH_KEYWORD sep length_arg_str length_end\n             { actual = $3.actual;\n               actual_type = $3.token;\n             }\n\nlength_arg_str: string { $$.token = actual_type;\n                         $$.actual = actual;\n                         if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {\n                           YYABORT;\n                         }\n                         actual_type = LENGTH_KEYWORD;\n                         s = NULL;\n                       }\n\nlength_end: ';'\n  |  '{' stmtsep\n         message_opt_stmt\n      '}'\n\nmessage_opt_stmt: @EMPTYDIR@ { switch (actual_type) {\n                               case MUST_KEYWORD:\n                                 $$ = \"must\";\n                                 break;\n                               case LENGTH_KEYWORD:\n                                 $$ = \"length\";\n                                 break;\n                               case RANGE_KEYWORD:\n                                 $$ = \"range\";\n                                 break;\n                               default:\n                                 LOGINT(trg->ctx);\n                                 YYABORT;\n                                 break;\n                               }\n                             }\n  |  message_opt_stmt error_message_stmt { if (yang_read_message(trg, actual, s, $1, ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  message_opt_stmt error_app_tag_stmt { if (yang_read_message(trg, actual, s, $1, ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  message_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, $1, NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  message_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, $1, NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\npattern_sep: sep { $$.token = actual_type;\n                   $$.actual = actual;\n                 }\n\npattern_stmt: PATTERN_KEYWORD pattern_sep pattern_arg_str pattern_end  {struct lys_restr *pattern = actual;\n                                                                        actual = NULL;\n#ifdef LY_ENABLED_CACHE\n                                                                        if ($2.token != EXTENSION_INSTANCE &&\n                                                                            !(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {\n                                                                          unsigned int c = 2 * (((struct yang_type *)$2.actual)->type->info.str.pat_count - 1);\n                                                                          YANG_ADDELEM(((struct yang_type *)$2.actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          ++c;\n                                                                          YANG_ADDELEM(((struct yang_type *)$2.actual)->type->info.str.patterns_pcre, c, \"patterns\");\n                                                                          actual = &(((struct yang_type *)$2.actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)$2.actual)->type->info.str.pat_count - 1)];\n                                                                        }\n#endif\n                                                                        if (yang_read_pattern(trg->ctx, pattern, actual, $3, $4)) {\n                                                                          YYABORT;\n                                                                        }\n                                                                        actual_type = $2.token;\n                                                                        actual = $2.actual;\n                                                                      }\n\npattern_arg_str: string { if (actual_type != EXTENSION_INSTANCE) {\n                            if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {\n                              free(s);\n                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected pattern statement.\");\n                              YYABORT;\n                            }\n                            ((struct yang_type *)actual)->base = LY_TYPE_STRING;\n                            YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,\n                                         ((struct yang_type *)actual)->type->info.str.pat_count, \"patterns\");\n                          }\n                          $$ = s;\n                          s = NULL;\n                          actual_type = PATTERN_KEYWORD;\n                        }\n\npattern_end: ';' { $$ = 0x06; }\n  |  '{' stmtsep\n         pattern_opt_stmt\n     '}' { $$ = $3; }\n\npattern_opt_stmt: @EMPTYDIR@ { $$ = 0x06; /* ACK */ }\n  |  pattern_opt_stmt modifier_stmt { if (trg->version < 2) {\n                                        LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"modifier\");\n                                        YYABORT;\n                                      }\n                                      if ($1 != 0x06) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"modifier\", \"pattern\");\n                                        YYABORT;\n                                      }\n                                      $$ = $2;\n                                    }\n  |  pattern_opt_stmt error_message_stmt { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_MESSAGE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  pattern_opt_stmt error_app_tag_stmt { if (yang_read_message(trg, actual, s, \"pattern\", ERROR_APP_TAG_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  pattern_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"pattern\", NODE)) {\n                                           YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  pattern_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"pattern\", NODE)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n\nmodifier_arg: string { backup_type = actual_type;\n                       actual_type = MODIFIER_KEYWORD;\n                     }\n\nmodifier_stmt: MODIFIER_KEYWORD sep modifier_arg stmtend { if (!strcmp(s, \"invert-match\")) {\n                                                             $$ = 0x15;\n                                                             free(s);\n                                                             s = NULL;\n                                                           } else {\n                                                             LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);\n                                                             free(s);\n                                                             YYABORT;\n                                                           }\n                                                         }\n\nenum_specification: enum_stmt stmtsep enum_stmts { struct lys_type_enum * tmp;\n\n                                                   cnt_val = 0;\n                                                   tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,\n                                                                 ((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);\n                                                   if (!tmp) {\n                                                     LOGMEM(trg->ctx);\n                                                     YYABORT;\n                                                   }\n                                                   ((struct yang_type *)actual)->type->info.enums.enm = tmp;\n                                                 }\n\nenum_stmts: @EMPTYDIR@\n  | enum_stmts enum_stmt stmtsep;\n\n\nenum_stmt: ENUM_KEYWORD sep enum_arg_str enum_end\n           { if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n               YYABORT;\n             }\n             actual = $3.actual;\n             actual_type = $3.token;\n           }\n\nenum_arg_str: string { $$.token = actual_type;\n                       $$.actual = yang_type = actual;\n                       YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, \"enums\");\n                       if (yang_read_enum(trg->ctx, yang_type, actual, s)) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       is_value = 0;\n                       actual_type = ENUM_KEYWORD;\n                     }\n\nenum_end: ';'\n  |  '{' stmtsep\n         enum_opt_stmt\n     '}' { if (((struct lys_type_enum *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_enum *)actual)->iffeature,\n                           ((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_enum *)actual)->iffeature = tmp;\n           }\n         }\n\nenum_opt_stmt: @EMPTYDIR@\n  |  enum_opt_stmt if_feature_stmt stmtsep\n  |  enum_opt_stmt value_stmt { if (is_value) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"value\", \"enum\");\n                                  YYABORT;\n                                }\n                                ((struct lys_type_enum *)actual)->value = $2;\n\n                                /* keep the highest enum value for automatic increment */\n                                if ($2 >= cnt_val) {\n                                  cnt_val = $2 + 1;\n                                }\n                                is_value = 1;\n                              }\n  |  enum_opt_stmt status_stmt { if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"enum\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_enum *)actual)->flags |= $2;\n                               }\n  |  enum_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"enum\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  enum_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"enum\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\nvalue_arg: integer_value_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = VALUE_KEYWORD;\n                                 }\n\nvalue_stmt: VALUE_KEYWORD sep value_arg stmtend { $$ = $3; }\n\ninteger_value_arg_str: integer_value optsep { $$ = $1; }\n  |  string_1 { /* convert it to int32_t */\n                int64_t val;\n                char *endptr;\n\n                val = strtoll(s, &endptr, 10);\n                if (val < INT32_MIN || val > INT32_MAX || *endptr) {\n                    LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"value\");\n                    free(s);\n                    YYABORT;\n                }\n                free(s);\n                s = NULL;\n                $$ = (int32_t) val;\n             }\n\nrange_stmt: RANGE_KEYWORD sep range_arg_str range_end { actual_type = $3.token;\n                                                        actual = $3.actual;\n                                                      }\n\n\nrange_end: ';'\n  |  '{' stmtsep\n         message_opt_stmt\n      '}'\n   ;\n\npath_arg: path_arg_str { backup_type = actual_type;\n                         actual_type = PATH_KEYWORD;\n                       }\n\npath_stmt: PATH_KEYWORD sep path_arg stmtend\n\nrequire_instance_arg: require_instance_arg_str { $$ = $1;\n                                                 backup_type = actual_type;\n                                                 actual_type = REQUIRE_INSTANCE_KEYWORD;\n                                               }\n\nrequire_instance_stmt: REQUIRE_INSTANCE_KEYWORD sep require_instance_arg stmtend { $$ = $3; }\n\nrequire_instance_arg_str: TRUE_KEYWORD optsep { $$ = 1; }\n  |  FALSE_KEYWORD optsep { $$ = -1; }\n  |  string_1 { if (!strcmp(s,\"true\")) {\n                  $$ = 1;\n                } else if (!strcmp(s,\"false\")) {\n                  $$ = -1;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"require-instance\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\nbits_specification: bit_stmt bit_stmts { struct lys_type_bit * tmp;\n\n                                         cnt_val = 0;\n                                         tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,\n                                                       ((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);\n                                         if (!tmp) {\n                                           LOGMEM(trg->ctx);\n                                           YYABORT;\n                                         }\n                                         ((struct yang_type *)actual)->type->info.bits.bit = tmp;\n                                       }\n\nbit_stmts: @EMPTYDIR@\n  | bit_stmts bit_stmt;\n\nbit_stmt: BIT_KEYWORD sep bit_arg_str bit_end\n          stmtsep { if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {\n                      YYABORT;\n                    }\n                    actual = $3.actual;\n                    actual_type = $3.token;\n                  }\n\nbit_arg_str: identifier_arg_str { $$.token = actual_type;\n                                  $$.actual = yang_type = actual;\n                                  YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,\n                                               ((struct yang_type *)actual)->type->info.bits.count, \"bits\");\n                                  if (yang_read_bit(trg->ctx, yang_type, actual, s)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                  is_value = 0;\n                                  actual_type = BIT_KEYWORD;\n                                }\n\nbit_end: ';'\n  |  '{' stmtsep\n         bit_opt_stmt\n     '}' { if (((struct lys_type_bit *)actual)->iffeature_size) {\n             struct lys_iffeature *tmp;\n\n             tmp = realloc(((struct lys_type_bit *)actual)->iffeature,\n                           ((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             ((struct lys_type_bit *)actual)->iffeature = tmp;\n           }\n         }\n\nbit_opt_stmt: @EMPTYDIR@\n  |  bit_opt_stmt if_feature_stmt stmtsep\n  |  bit_opt_stmt position_stmt { if (is_value) {\n                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"position\", \"bit\");\n                                    YYABORT;\n                                  }\n                                  ((struct lys_type_bit *)actual)->pos = $2;\n\n                                  /* keep the highest position value for automatic increment */\n                                  if ($2 >= cnt_val) {\n                                    cnt_val = $2 + 1;\n                                  }\n                                  is_value = 1;\n                                }\n  |  bit_opt_stmt status_stmt { if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"bit\");\n                                   YYABORT;\n                                 }\n                                 ((struct lys_type_bit *)actual)->flags |= $2;\n                              }\n  |  bit_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"bit\", NODE)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n  |  bit_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"bit\", NODE)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n\nposition_value_arg: position_value_arg_str { $$ = $1;\n                                             backup_type = actual_type;\n                                             actual_type = POSITION_KEYWORD;\n                                           }\n\nposition_stmt: POSITION_KEYWORD sep position_value_arg stmtend { $$ = $3; }\n\nposition_value_arg_str: non_negative_integer_value optsep { $$ = $1; }\n  |  string_1 { /* convert it to uint32_t */\n                unsigned long val;\n                char *endptr = NULL;\n                errno = 0;\n\n                val = strtoul(s, &endptr, 10);\n                if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"position\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n                $$ = (uint32_t) val;\n              }\n\nerror_message_arg: string { backup_type = actual_type;\n                            actual_type = ERROR_MESSAGE_KEYWORD;\n                          }\n\nerror_message_stmt: ERROR_MESSAGE_KEYWORD sep error_message_arg stmtend\n\nerror_app_tag_arg: string { backup_type = actual_type;\n                            actual_type = ERROR_APP_TAG_KEYWORD;\n                          }\n\nerror_app_tag_stmt: ERROR_APP_TAG_KEYWORD sep error_app_tag_arg stmtend\n\nunits_arg: string { backup_type = actual_type;\n                    actual_type = UNITS_KEYWORD;\n                  }\n\nunits_stmt: UNITS_KEYWORD sep units_arg stmtend\n\ndefault_arg: string { backup_type = actual_type;\n                      actual_type = DEFAULT_KEYWORD;\n                    }\n\ndefault_stmt: DEFAULT_KEYWORD sep default_arg stmtend\n\ngrouping_arg_str: identifier_arg_str { $$.token = actual_type;\n                                       $$.actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       data_node = actual;\n                                       actual_type = GROUPING_KEYWORD;\n                                     }\n\ngrouping_stmt: GROUPING_KEYWORD sep grouping_arg_str grouping_end\n               { LOGDBG(LY_LDGYANG, \"finished parsing grouping statement \\\"%s\\\"\", data_node->name);\n                 actual_type = $3.token;\n                 actual = $3.actual;\n                 data_node = $3.actual;\n               }\n\ngrouping_end: ';'\n  |  '{' stmtsep\n         grouping_opt_stmt\n     '}'\n\ngrouping_opt_stmt: @EMPTYDIR@ { $$.grouping = actual; }\n  |  grouping_opt_stmt status_stmt { if ($1.grouping->flags & LYS_STATUS_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.grouping, \"status\", \"grouping\");\n                                       YYABORT;\n                                     }\n                                     $1.grouping->flags |= $2;\n                                   }\n  |  grouping_opt_stmt description_stmt { if (yang_read_description(trg, $1.grouping, s, \"grouping\", NODE_PRINT)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                        }\n  |  grouping_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.grouping, s, \"grouping\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  |  grouping_opt_stmt grouping_stmt stmtsep\n  |  grouping_opt_stmt typedef_stmt stmtsep\n  |  grouping_opt_stmt data_def_stmt stmtsep\n  |  grouping_opt_stmt action_stmt stmtsep\n  |  grouping_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.grouping, \"notification\");\n                                                     YYABORT;\n                                                   }\n                                                 }\n\ndata_def_stmt: container_stmt\n  |  leaf_stmt\n  |  leaf_list_stmt\n  |  list_stmt\n  |  choice_stmt\n  |  anyxml_stmt\n  |  anydata_stmt\n  |  uses_stmt\n  ;\n\ncontainer_arg_str: identifier_arg_str { $$.token = actual_type;\n                                        $$.actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = CONTAINER_KEYWORD;\n                                      }\n\ncontainer_stmt: CONTAINER_KEYWORD sep container_arg_str container_end\n                { LOGDBG(LY_LDGYANG, \"finished parsing container statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                  data_node = $3.actual;\n                }\n\ncontainer_end: ';'\n  |  '{' stmtsep\n         container_opt_stmt\n      '}' { void *tmp;\n\n            if ($3.container->iffeature_size) {\n              tmp = realloc($3.container->iffeature, $3.container->iffeature_size * sizeof *$3.container->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.container->iffeature = tmp;\n            }\n\n            if ($3.container->must_size) {\n              tmp = realloc($3.container->must, $3.container->must_size * sizeof *$3.container->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.container->must = tmp;\n            }\n          }\n\ncontainer_opt_stmt: @EMPTYDIR@ { $$.container = actual; }\n  |  container_opt_stmt when_stmt stmtsep\n  |  container_opt_stmt if_feature_stmt stmtsep\n  |  container_opt_stmt must_stmt stmtsep\n  |  container_opt_stmt presence_stmt { if (yang_read_presence(trg, $1.container, s)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  |  container_opt_stmt config_stmt { if ($1.container->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.container, \"config\", \"container\");\n                                        YYABORT;\n                                      }\n                                      $1.container->flags |= $2;\n                                    }\n  |  container_opt_stmt status_stmt { if ($1.container->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.container, \"status\", \"container\");\n                                        YYABORT;\n                                      }\n                                      $1.container->flags |= $2;\n                                    }\n  |  container_opt_stmt description_stmt { if (yang_read_description(trg, $1.container, s, \"container\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  container_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.container, s, \"container\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  container_opt_stmt grouping_stmt stmtsep\n  |  container_opt_stmt action_stmt stmtsep\n  |  container_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                      LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.container, \"notification\");\n                                                      YYABORT;\n                                                    }\n                                                  }\n  |  container_opt_stmt typedef_stmt stmtsep\n  |  container_opt_stmt data_def_stmt stmtsep\n\nleaf_stmt: LEAF_KEYWORD sep leaf_arg_str\n           '{' stmtsep\n               leaf_opt_stmt\n            '}' { void *tmp;\n\n                  if (!($6.node.flag & LYS_TYPE_DEF)) {\n                    LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaf, \"type\", \"leaf\");\n                    YYABORT;\n                  }\n                  if ($6.node.ptr_leaf->dflt && ($6.node.ptr_leaf->flags & LYS_MAND_TRUE)) {\n                    /* RFC 6020, 7.6.4 - default statement must not with mandatory true */\n                    LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaf, \"mandatory\", \"leaf\");\n                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $6.node.ptr_leaf, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    YYABORT;\n                  }\n\n                  if ($6.node.ptr_leaf->iffeature_size) {\n                    tmp = realloc($6.node.ptr_leaf->iffeature, $6.node.ptr_leaf->iffeature_size * sizeof *$6.node.ptr_leaf->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_leaf->iffeature = tmp;\n                  }\n\n                  if ($6.node.ptr_leaf->must_size) {\n                    tmp = realloc($6.node.ptr_leaf->must, $6.node.ptr_leaf->must_size * sizeof *$6.node.ptr_leaf->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_leaf->must = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing leaf statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                  data_node = $3.actual;\n                }\n\nleaf_arg_str: identifier_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LEAF_KEYWORD;\n                                 }\n\nleaf_opt_stmt: @EMPTYDIR@ { $$.node.ptr_leaf = actual;\n                            $$.node.flag = 0;\n                          }\n  |  leaf_opt_stmt when_stmt stmtsep\n  |  leaf_opt_stmt if_feature_stmt stmtsep\n  |  leaf_opt_stmt type_stmt stmtsep { $1.node.flag |= LYS_TYPE_DEF;\n                                       $$ = $1;\n                                     }\n  |  leaf_opt_stmt units_stmt { if (yang_read_units(trg, $1.node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                  YYABORT;\n                                }\n                                s = NULL;\n                              }\n  |  leaf_opt_stmt must_stmt stmtsep\n  |  leaf_opt_stmt default_stmt { if (yang_read_default(trg, $1.node.ptr_leaf, s, LEAF_KEYWORD)) {\n                                    YYABORT;\n                                  }\n                                  s = NULL;\n                                }\n  |  leaf_opt_stmt config_stmt { if ($1.node.ptr_leaf->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaf, \"config\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_leaf->flags |= $2;\n                               }\n  |  leaf_opt_stmt mandatory_stmt { if ($1.node.ptr_leaf->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaf, \"mandatory\", \"leaf\");\n                                      YYABORT;\n                                    }\n                                    $1.node.ptr_leaf->flags |= $2;\n                                  }\n  |  leaf_opt_stmt status_stmt { if ($1.node.ptr_leaf->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaf, \"status\", \"leaf\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_leaf->flags |= $2;\n                               }\n  |  leaf_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  leaf_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\nleaf_list_arg_str: identifier_arg_str { $$.token = actual_type;\n                                        $$.actual = actual;\n                                        if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {\n                                          YYABORT;\n                                        }\n                                        data_node = actual;\n                                        s = NULL;\n                                        actual_type = LEAF_LIST_KEYWORD;\n                                      }\n\n  leaf_list_stmt: LEAF_LIST_KEYWORD sep leaf_list_arg_str\n                  '{' stmtsep\n                      leaf_list_opt_stmt\n                  '}' { void *tmp;\n\n                        if ($6.node.ptr_leaflist->flags & LYS_CONFIG_R) {\n                          /* RFC 6020, 7.7.5 - ignore ordering when the list represents state data\n                           * ignore oredering MASK - 0x7F\n                           */\n                          $6.node.ptr_leaflist->flags &= 0x7F;\n                        }\n                        if (!($6.node.flag & LYS_TYPE_DEF)) {\n                          LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaflist, \"type\", \"leaf-list\");\n                          YYABORT;\n                        }\n                        if ($6.node.ptr_leaflist->dflt_size && $6.node.ptr_leaflist->min) {\n                          LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, $6.node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                          LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $6.node.ptr_leaflist,\n                                 \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                          YYABORT;\n                        }\n\n                        if ($6.node.ptr_leaflist->iffeature_size) {\n                          tmp = realloc($6.node.ptr_leaflist->iffeature, $6.node.ptr_leaflist->iffeature_size * sizeof *$6.node.ptr_leaflist->iffeature);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          $6.node.ptr_leaflist->iffeature = tmp;\n                        }\n\n                        if ($6.node.ptr_leaflist->must_size) {\n                          tmp = realloc($6.node.ptr_leaflist->must, $6.node.ptr_leaflist->must_size * sizeof *$6.node.ptr_leaflist->must);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          $6.node.ptr_leaflist->must = tmp;\n                        }\n\n                        if ($6.node.ptr_leaflist->dflt_size) {\n                          tmp = realloc($6.node.ptr_leaflist->dflt, $6.node.ptr_leaflist->dflt_size * sizeof *$6.node.ptr_leaflist->dflt);\n                          if (!tmp) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                          $6.node.ptr_leaflist->dflt = tmp;\n                        }\n\n                        LOGDBG(LY_LDGYANG, \"finished parsing leaf-list statement \\\"%s\\\"\", data_node->name);\n                        actual_type = $3.token;\n                        actual = $3.actual;\n                        data_node = $3.actual;\n                      }\n\nleaf_list_opt_stmt: @EMPTYDIR@ { $$.node.ptr_leaflist = actual;\n                                 $$.node.flag = 0;\n                               }\n  |  leaf_list_opt_stmt when_stmt stmtsep\n  |  leaf_list_opt_stmt if_feature_stmt stmtsep\n  |  leaf_list_opt_stmt type_stmt stmtsep { $1.node.flag |= LYS_TYPE_DEF;\n                                            $$ = $1;\n                                          }\n  |  leaf_list_opt_stmt default_stmt { if (trg->version < 2) {\n                                         free(s);\n                                         LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.node.ptr_leaflist, \"default\");\n                                         YYABORT;\n                                       }\n                                       YANG_ADDELEM($1.node.ptr_leaflist->dflt,\n                                                    $1.node.ptr_leaflist->dflt_size, \"defaults\");\n                                       (*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);\n                                       s = NULL;\n                                       actual = $1.node.ptr_leaflist;\n                                     }\n  |  leaf_list_opt_stmt units_stmt { if (yang_read_units(trg, $1.node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n  |  leaf_list_opt_stmt must_stmt stmtsep\n  |  leaf_list_opt_stmt config_stmt { if ($1.node.ptr_leaflist->flags & LYS_CONFIG_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"config\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      $1.node.ptr_leaflist->flags |= $2;\n                                    }\n  |  leaf_list_opt_stmt min_elements_stmt { if ($1.node.flag & LYS_MIN_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"min-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            $1.node.ptr_leaflist->min = $2;\n                                            $1.node.flag |= LYS_MIN_ELEMENTS;\n                                            $$ = $1;\n                                            if ($1.node.ptr_leaflist->max && ($1.node.ptr_leaflist->min > $1.node.ptr_leaflist->max)) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"min-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n  |  leaf_list_opt_stmt max_elements_stmt { if ($1.node.flag & LYS_MAX_ELEMENTS) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"max-elements\", \"leaf-list\");\n                                              YYABORT;\n                                            }\n                                            $1.node.ptr_leaflist->max = $2;\n                                            $1.node.flag |= LYS_MAX_ELEMENTS;\n                                            $$ = $1;\n                                            if ($1.node.ptr_leaflist->min > $1.node.ptr_leaflist->max) {\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"max-elements\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_leaflist, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                              YYABORT;\n                                            }\n                                          }\n  |  leaf_list_opt_stmt ordered_by_stmt { if ($1.node.flag & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"ordered by\", \"leaf-list\");\n                                            YYABORT;\n                                          }\n                                          if ($2 & LYS_USERORDERED) {\n                                            $1.node.ptr_leaflist->flags |= LYS_USERORDERED;\n                                          }\n                                          $1.node.flag |= $2;\n                                          $$ = $1;\n                                        }\n  |  leaf_list_opt_stmt status_stmt { if ($1.node.ptr_leaflist->flags & LYS_STATUS_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_leaflist, \"status\", \"leaf-list\");\n                                        YYABORT;\n                                      }\n                                      $1.node.ptr_leaflist->flags |= $2;\n                                    }\n  |  leaf_list_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                         }\n  |  leaf_list_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n\nlist_arg_str: identifier_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = LIST_KEYWORD;\n                                 }\n\nlist_stmt: LIST_KEYWORD sep list_arg_str\n           '{' stmtsep\n               list_opt_stmt\n            '}' { void *tmp;\n\n                  if ($6.node.ptr_list->iffeature_size) {\n                    tmp = realloc($6.node.ptr_list->iffeature, $6.node.ptr_list->iffeature_size * sizeof *$6.node.ptr_list->iffeature);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->iffeature = tmp;\n                  }\n\n                  if ($6.node.ptr_list->must_size) {\n                    tmp = realloc($6.node.ptr_list->must, $6.node.ptr_list->must_size * sizeof *$6.node.ptr_list->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->must = tmp;\n                  }\n\n                  if ($6.node.ptr_list->tpdf_size) {\n                    tmp = realloc($6.node.ptr_list->tpdf, $6.node.ptr_list->tpdf_size * sizeof *$6.node.ptr_list->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->tpdf = tmp;\n                  }\n\n                  if ($6.node.ptr_list->unique_size) {\n                    tmp = realloc($6.node.ptr_list->unique, $6.node.ptr_list->unique_size * sizeof *$6.node.ptr_list->unique);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    $6.node.ptr_list->unique = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing list statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $3.token;\n                  actual = $3.actual;\n                  data_node = $3.actual;\n                }\n\nlist_opt_stmt: @EMPTYDIR@ { $$.node.ptr_list = actual;\n                            $$.node.flag = 0;\n                          }\n  |  list_opt_stmt when_stmt stmtsep\n  |  list_opt_stmt if_feature_stmt stmtsep\n  |  list_opt_stmt must_stmt stmtsep\n  |  list_opt_stmt key_stmt { if ($1.node.ptr_list->keys) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"key\", \"list\");\n                                  free(s);\n                                  YYABORT;\n                              }\n                              $1.node.ptr_list->keys = (struct lys_node_leaf **)s;\n                              $$ = $1;\n                              s = NULL;\n                            }\n  |  list_opt_stmt unique_stmt { YANG_ADDELEM($1.node.ptr_list->unique, $1.node.ptr_list->unique_size, \"uniques\");\n                                 ((struct lys_unique *)actual)->expr = (const char **)s;\n                                 $$ = $1;\n                                 s = NULL;\n                                 actual = $1.node.ptr_list;\n                               }\n  |  list_opt_stmt config_stmt { if ($1.node.ptr_list->flags & LYS_CONFIG_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"config\", \"list\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_list->flags |= $2;\n                               }\n  |  list_opt_stmt min_elements_stmt { if ($1.node.flag & LYS_MIN_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"min-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       $1.node.ptr_list->min = $2;\n                                       $1.node.flag |= LYS_MIN_ELEMENTS;\n                                       $$ = $1;\n                                       if ($1.node.ptr_list->max && ($1.node.ptr_list->min > $1.node.ptr_list->max)) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n  |  list_opt_stmt max_elements_stmt { if ($1.node.flag & LYS_MAX_ELEMENTS) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"max-elements\", \"list\");\n                                         YYABORT;\n                                       }\n                                       $1.node.ptr_list->max = $2;\n                                       $1.node.flag |= LYS_MAX_ELEMENTS;\n                                       $$ = $1;\n                                       if ($1.node.ptr_list->min > $1.node.ptr_list->max) {\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"min-elements\");\n                                         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $1.node.ptr_list, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                                         YYABORT;\n                                       }\n                                     }\n  |  list_opt_stmt ordered_by_stmt { if ($1.node.flag & LYS_ORDERED_MASK) {\n                                       LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"ordered by\", \"list\");\n                                       YYABORT;\n                                     }\n                                     if ($2 & LYS_USERORDERED) {\n                                       $1.node.ptr_list->flags |= LYS_USERORDERED;\n                                     }\n                                     $1.node.flag |= $2;\n                                     $$ = $1;\n                                   }\n  |  list_opt_stmt status_stmt { if ($1.node.ptr_list->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_list, \"status\", \"list\");\n                                   YYABORT;\n                                 }\n                                 $1.node.ptr_list->flags |= $2;\n                               }\n  |  list_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  list_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_list, s, \"list\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  list_opt_stmt typedef_stmt stmtsep\n  |  list_opt_stmt grouping_stmt stmtsep\n  |  list_opt_stmt action_stmt stmtsep\n  |  list_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                 LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.node.ptr_list, \"notification\");\n                                                 YYABORT;\n                                               }\n                                             }\n  |  list_opt_stmt data_def_stmt stmtsep\n\nchoice_arg_str: identifier_arg_str { $$.token = actual_type;\n                                     $$.actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = CHOICE_KEYWORD;\n                                   }\n\nchoice_stmt: CHOICE_KEYWORD sep choice_arg_str choice_end\n             { LOGDBG(LY_LDGYANG, \"finished parsing choice statement \\\"%s\\\"\", data_node->name);\n               actual_type = $3.token;\n               actual = $3.actual;\n               data_node = $3.actual;\n             }\n\nchoice_end: ';'\n  |  '{' stmtsep\n         choice_opt_stmt\n     '}' { struct lys_iffeature *tmp;\n\n           if (($3.node.ptr_choice->flags & LYS_MAND_TRUE) && $3.node.ptr_choice->dflt) {\n              LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, $3.node.ptr_choice, \"default\", \"choice\");\n              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, $3.node.ptr_choice, \"The \\\"default\\\" statement is forbidden on choices with \\\"mandatory\\\".\");\n              YYABORT;\n            }\n\n           if ($3.node.ptr_choice->iffeature_size) {\n             tmp = realloc($3.node.ptr_choice->iffeature, $3.node.ptr_choice->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.node.ptr_choice->iffeature = tmp;\n           }\n         }\n\nchoice_opt_stmt: @EMPTYDIR@ { $$.node.ptr_choice = actual;\n                              $$.node.flag = 0;\n                            }\n  |  choice_opt_stmt when_stmt stmtsep\n  |  choice_opt_stmt if_feature_stmt stmtsep\n  |  choice_opt_stmt default_stmt { if ($1.node.flag & LYS_CHOICE_DEFAULT) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"default\", \"choice\");\n                                      free(s);\n                                      YYABORT;\n                                    }\n                                    $1.node.ptr_choice->dflt = (struct lys_node *) s;\n                                    s = NULL;\n                                    $$ = $1;\n                                    $$.node.flag |= LYS_CHOICE_DEFAULT;\n                                  }\n  |  choice_opt_stmt config_stmt { if ($1.node.ptr_choice->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"config\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_choice->flags |= $2;\n                                   $$ = $1;\n                                 }\n|  choice_opt_stmt mandatory_stmt { if ($1.node.ptr_choice->flags & LYS_MAND_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"mandatory\", \"choice\");\n                                      YYABORT;\n                                    }\n                                    $1.node.ptr_choice->flags |= $2;\n                                    $$ = $1;\n                                  }\n  |  choice_opt_stmt status_stmt { if ($1.node.ptr_choice->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_choice, \"status\", \"choice\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_choice->flags |= $2;\n                                   $$ = $1;\n                                 }\n  |  choice_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                        $$ = $1;\n                                      }\n  |  choice_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_choice, s, \"choice\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                      $$ = $1;\n                                    }\n  |  choice_opt_stmt short_case_case_stmt stmtsep\n\nshort_case_case_stmt:  short_case_stmt\n  |  case_stmt\n\nshort_case_stmt: container_stmt\n  |  leaf_stmt\n  |  leaf_list_stmt\n  |  list_stmt\n  |  anyxml_stmt\n  |  anydata_stmt\n  |  choice_stmt { if (trg->version < 2 ) {\n                     LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"choice\");\n                     YYABORT;\n                   }\n                 }\n\ncase_arg_str: identifier_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {\n                                     YYABORT;\n                                   }\n                                   data_node = actual;\n                                   s = NULL;\n                                   actual_type = CASE_KEYWORD;\n                                 }\n\ncase_stmt: CASE_KEYWORD sep case_arg_str case_end\n           { LOGDBG(LY_LDGYANG, \"finished parsing case statement \\\"%s\\\"\", data_node->name);\n             actual_type = $3.token;\n             actual = $3.actual;\n             data_node = $3.actual;\n           }\n\ncase_end: ';'\n  |  '{' stmtsep\n         case_opt_stmt\n      '}' { struct lys_iffeature *tmp;\n\n           if ($3.cs->iffeature_size) {\n             tmp = realloc($3.cs->iffeature, $3.cs->iffeature_size * sizeof *tmp);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.cs->iffeature = tmp;\n           }\n          }\n\ncase_opt_stmt: @EMPTYDIR@ { $$.cs = actual; }\n  |  case_opt_stmt when_stmt stmtsep\n  |  case_opt_stmt if_feature_stmt stmtsep\n  |  case_opt_stmt status_stmt { if ($1.cs->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.cs, \"status\", \"case\");\n                                   YYABORT;\n                                 }\n                                 $1.cs->flags |= $2;\n                               }\n  |  case_opt_stmt description_stmt { if (yang_read_description(trg, $1.cs, s, \"case\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  case_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.cs, s, \"case\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  case_opt_stmt data_def_stmt stmtsep\n\n\nanyxml_arg_str: identifier_arg_str { $$.token = actual_type;\n                                     $$.actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ANYXML_KEYWORD;\n                                   }\n\nanyxml_stmt: ANYXML_KEYWORD sep anyxml_arg_str anyxml_end\n             { LOGDBG(LY_LDGYANG, \"finished parsing anyxml statement \\\"%s\\\"\", data_node->name);\n               actual_type = $3.token;\n               actual = $3.actual;\n               data_node = $3.actual;\n             }\n\nanydata_arg_str: identifier_arg_str { $$.token = actual_type;\n                                      $$.actual = actual;\n                                      if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {\n                                        YYABORT;\n                                      }\n                                      data_node = actual;\n                                      s = NULL;\n                                      actual_type = ANYDATA_KEYWORD;\n                                    }\n\nanydata_stmt: ANYDATA_KEYWORD sep anydata_arg_str anyxml_end\n              { LOGDBG(LY_LDGYANG, \"finished parsing anydata statement \\\"%s\\\"\", data_node->name);\n                actual_type = $3.token;\n                actual = $3.actual;\n                data_node = $3.actual;\n              }\n\nanyxml_end: ';'\n  |  '{' stmtsep\n         anyxml_opt_stmt\n     '}' { void *tmp;\n\n           if ($3.node.ptr_anydata->iffeature_size) {\n             tmp = realloc($3.node.ptr_anydata->iffeature, $3.node.ptr_anydata->iffeature_size * sizeof *$3.node.ptr_anydata->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.node.ptr_anydata->iffeature = tmp;\n           }\n\n           if ($3.node.ptr_anydata->must_size) {\n             tmp = realloc($3.node.ptr_anydata->must, $3.node.ptr_anydata->must_size * sizeof *$3.node.ptr_anydata->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.node.ptr_anydata->must = tmp;\n           }\n         }\n\nanyxml_opt_stmt: @EMPTYDIR@ { $$.node.ptr_anydata = actual;\n                              $$.node.flag = actual_type;\n                            }\n  |  anyxml_opt_stmt when_stmt stmtsep\n  |  anyxml_opt_stmt if_feature_stmt stmtsep\n  |  anyxml_opt_stmt must_stmt stmtsep\n  |  anyxml_opt_stmt config_stmt { if ($1.node.ptr_anydata->flags & LYS_CONFIG_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_anydata, \"config\",\n                                            ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_anydata->flags |= $2;\n                                 }\n  |  anyxml_opt_stmt mandatory_stmt { if ($1.node.ptr_anydata->flags & LYS_MAND_MASK) {\n                                        LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_anydata, \"mandatory\",\n                                               ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                        YYABORT;\n                                      }\n                                      $1.node.ptr_anydata->flags |= $2;\n                                    }\n  |  anyxml_opt_stmt status_stmt { if ($1.node.ptr_anydata->flags & LYS_STATUS_MASK) {\n                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_anydata, \"status\",\n                                            ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");\n                                     YYABORT;\n                                   }\n                                   $1.node.ptr_anydata->flags |= $2;\n                                 }\n  |  anyxml_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_anydata, s, ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                          YYABORT;\n                                        }\n                                        s = NULL;\n                                      }\n  |  anyxml_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_anydata, s, ($1.node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n\nuses_arg_str: identifier_ref_arg_str { $$.token = actual_type;\n                                       $$.actual = actual;\n                                       if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {\n                                         YYABORT;\n                                       }\n                                       data_node = actual;\n                                       s = NULL;\n                                       actual_type = USES_KEYWORD;\n                                     }\n\nuses_stmt: USES_KEYWORD sep uses_arg_str uses_end\n           { LOGDBG(LY_LDGYANG, \"finished parsing uses statement \\\"%s\\\"\", data_node->name);\n             actual_type = $3.token;\n             actual = $3.actual;\n             data_node = $3.actual;\n           }\n\nuses_end: ';'\n  |  '{' stmtsep\n         uses_opt_stmt\n     '}' { void *tmp;\n\n           if ($3.uses->iffeature_size) {\n             tmp = realloc($3.uses->iffeature, $3.uses->iffeature_size * sizeof *$3.uses->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.uses->iffeature = tmp;\n           }\n\n           if ($3.uses->refine_size) {\n             tmp = realloc($3.uses->refine, $3.uses->refine_size * sizeof *$3.uses->refine);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.uses->refine = tmp;\n           }\n\n           if ($3.uses->augment_size) {\n             tmp = realloc($3.uses->augment, $3.uses->augment_size * sizeof *$3.uses->augment);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.uses->augment = tmp;\n           }\n         }\n\nuses_opt_stmt: @EMPTYDIR@ { $$.uses = actual; }\n  |  uses_opt_stmt when_stmt stmtsep\n  |  uses_opt_stmt if_feature_stmt stmtsep\n  |  uses_opt_stmt status_stmt { if ($1.uses->flags & LYS_STATUS_MASK) {\n                                   LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.uses, \"status\", \"uses\");\n                                   YYABORT;\n                                 }\n                                 $1.uses->flags |= $2;\n                               }\n  |  uses_opt_stmt description_stmt { if (yang_read_description(trg, $1.uses, s, \"uses\", NODE_PRINT)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  uses_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.uses, s, \"uses\", NODE_PRINT)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n  |  uses_opt_stmt refine_stmt stmtsep\n  |  uses_opt_stmt uses_augment_stmt stmtsep\n\nrefine_args_str: descendant_schema_nodeid optsep\n  | string_1\n\nrefine_arg_str: refine_args_str { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,\n                                               ((struct lys_node_uses *)actual)->refine_size, \"refines\");\n                                  ((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);\n                                  free(s);\n                                  s = NULL;\n                                  if (!((struct lys_refine *)actual)->target_name) {\n                                    YYABORT;\n                                  }\n                                  actual_type = REFINE_KEYWORD;\n                                }\n\nrefine_stmt: REFINE_KEYWORD sep refine_arg_str refine_end\n             { actual_type = $3.token;\n               actual = $3.actual;\n             }\n\nrefine_end: ';'\n  |  '{' stmtsep\n         refine_body_opt_stmts\n     '}' { void *tmp;\n\n           if ($3.refine->iffeature_size) {\n             tmp = realloc($3.refine->iffeature, $3.refine->iffeature_size * sizeof *$3.refine->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.refine->iffeature = tmp;\n           }\n\n           if ($3.refine->must_size) {\n             tmp = realloc($3.refine->must, $3.refine->must_size * sizeof *$3.refine->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.refine->must = tmp;\n           }\n\n           if ($3.refine->dflt_size) {\n             tmp = realloc($3.refine->dflt, $3.refine->dflt_size * sizeof *$3.refine->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.refine->dflt = tmp;\n           }\n         }\n\nrefine_body_opt_stmts: @EMPTYDIR@ { $$.refine = actual;\n                                    actual_type = REFINE_KEYWORD;\n                                  }\n  |  refine_body_opt_stmts must_stmt stmtsep { actual = $1.refine;\n                                               actual_type = REFINE_KEYWORD;\n                                               if ($1.refine->target_type) {\n                                                 if ($1.refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {\n                                                   $1.refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"must\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 $1.refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;\n                                               }\n                                             }\n  |  refine_body_opt_stmts if_feature_stmt\n     stmtsep { /* leaf, leaf-list, list, container or anyxml */\n               /* check possibility of statements combination */\n               if ($1.refine->target_type) {\n                 if ($1.refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {\n                   $1.refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);\n                 } else {\n                   free(s);\n                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"refine\");\n                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                   YYABORT;\n                 }\n               } else {\n                 $1.refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;\n               }\n             }\n  |  refine_body_opt_stmts presence_stmt { if ($1.refine->target_type) {\n                                             if ($1.refine->target_type & LYS_CONTAINER) {\n                                               if ($1.refine->mod.presence) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                                 free(s);\n                                                 YYABORT;\n                                               }\n                                               $1.refine->target_type = LYS_CONTAINER;\n                                               $1.refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                             } else {\n                                               free(s);\n                                               LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"presence\", \"refine\");\n                                               LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                               YYABORT;\n                                             }\n                                           } else {\n                                             $1.refine->target_type = LYS_CONTAINER;\n                                             $1.refine->mod.presence = lydict_insert_zc(trg->ctx, s);\n                                           }\n                                           s = NULL;\n                                           $$ = $1;\n                                         }\n  |  refine_body_opt_stmts default_stmt { int i;\n\n                                          if ($1.refine->dflt_size) {\n                                            if (trg->version < 2) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              YYABORT;\n                                            }\n                                            if ($1.refine->target_type & LYS_LEAFLIST) {\n                                              $1.refine->target_type = LYS_LEAFLIST;\n                                            } else {\n                                              free(s);\n                                              LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                              LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                              YYABORT;\n                                            }\n                                          } else {\n                                            if ($1.refine->target_type) {\n                                              if (trg->version < 2 && ($1.refine->target_type & (LYS_LEAF | LYS_CHOICE))) {\n                                                $1.refine->target_type &= (LYS_LEAF | LYS_CHOICE);\n                                              } if (trg->version > 1 && ($1.refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {\n                                                /* YANG 1.1 */\n                                                $1.refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);\n                                              } else {\n                                                free(s);\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              if (trg->version < 2) {\n                                                $1.refine->target_type = LYS_LEAF | LYS_CHOICE;\n                                              } else {\n                                                /* YANG 1.1 */\n                                                $1.refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;\n                                              }\n                                            }\n                                          }\n                                          /* check for duplicity */\n                                          for (i = 0; i < $1.refine->dflt_size; ++i) {\n                                              if (ly_strequal($1.refine->dflt[i], s, 0)) {\n                                                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"default\");\n                                                  LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", s);\n                                                  YYABORT;\n                                              }\n                                          }\n                                          YANG_ADDELEM($1.refine->dflt, $1.refine->dflt_size, \"defaults\");\n                                          *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                          actual = $1.refine;\n                                          s = NULL;\n                                          $$ = $1;\n                                        }\n  |  refine_body_opt_stmts config_stmt { if ($1.refine->target_type) {\n                                           if ($1.refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {\n                                             $1.refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);\n                                             if ($1.refine->flags & LYS_CONFIG_MASK) {\n                                               LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                               YYABORT;\n                                             }\n                                             $1.refine->flags |= $2;\n                                           } else {\n                                             LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"config\", \"refine\");\n                                             LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                             YYABORT;\n                                           }\n                                         } else {\n                                           $1.refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;\n                                           $1.refine->flags |= $2;\n                                         }\n                                         $$ = $1;\n                                       }\n  |  refine_body_opt_stmts mandatory_stmt { if ($1.refine->target_type) {\n                                              if ($1.refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {\n                                                $1.refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);\n                                                if ($1.refine->flags & LYS_MAND_MASK) {\n                                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                  YYABORT;\n                                                }\n                                                $1.refine->flags |= $2;\n                                              } else {\n                                                LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");\n                                                LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                YYABORT;\n                                              }\n                                            } else {\n                                              $1.refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;\n                                              $1.refine->flags |= $2;\n                                            }\n                                            $$ = $1;\n                                          }\n  |  refine_body_opt_stmts min_elements_stmt { if ($1.refine->target_type) {\n                                                 if ($1.refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   $1.refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ($1.refine->flags & LYS_RFN_MINSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   $1.refine->flags |= LYS_RFN_MINSET;\n                                                   $1.refine->mod.list.min = $2;\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 $1.refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 $1.refine->flags |= LYS_RFN_MINSET;\n                                                 $1.refine->mod.list.min = $2;\n                                               }\n                                               $$ = $1;\n                                             }\n  |  refine_body_opt_stmts max_elements_stmt { if ($1.refine->target_type) {\n                                                 if ($1.refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {\n                                                   $1.refine->target_type &= (LYS_LIST | LYS_LEAFLIST);\n                                                   if ($1.refine->flags & LYS_RFN_MAXSET) {\n                                                     LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                     YYABORT;\n                                                   }\n                                                   $1.refine->flags |= LYS_RFN_MAXSET;\n                                                   $1.refine->mod.list.max = $2;\n                                                 } else {\n                                                   LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");\n                                                   LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");\n                                                   YYABORT;\n                                                 }\n                                               } else {\n                                                 $1.refine->target_type = LYS_LIST | LYS_LEAFLIST;\n                                                 $1.refine->flags |= LYS_RFN_MAXSET;\n                                                 $1.refine->mod.list.max = $2;\n                                               }\n                                               $$ = $1;\n                                             }\n  |  refine_body_opt_stmts description_stmt { if (yang_read_description(trg, $1.refine, s, \"refine\", NODE)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n  |  refine_body_opt_stmts reference_stmt { if (yang_read_reference(trg, $1.refine, s, \"refine\", NODE)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n\nuses_augment_arg_str: descendant_schema_nodeid optsep\n  |  string_1\n  ;\n\nuses_augment_arg: uses_augment_arg_str { void *parent;\n\n                                         $$.token = actual_type;\n                                         $$.actual = actual;\n                                         parent = actual;\n                                         YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,\n                                                      ((struct lys_node_uses *)actual)->augment_size, \"augments\");\n                                         if (yang_read_augment(trg, parent, actual, s)) {\n                                           YYABORT;\n                                         }\n                                         data_node = actual;\n                                         s = NULL;\n                                         actual_type = AUGMENT_KEYWORD;\n                                       }\n\nuses_augment_stmt: AUGMENT_KEYWORD sep uses_augment_arg\n                   '{' stmtsep\n                       augment_opt_stmt\n                   '}' { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                         actual_type = $3.token;\n                         actual = $3.actual;\n                         data_node = $3.actual;\n                       }\n\naugment_arg_str: absolute_schema_nodeids optsep\n  |  string_1\n\naugment_arg: augment_arg_str { $$.token = actual_type;\n                               $$.actual = actual;\n                               YANG_ADDELEM(trg->augment, trg->augment_size, \"augments\");\n                               if (yang_read_augment(trg, NULL, actual, s)) {\n                                 YYABORT;\n                               }\n                               data_node = actual;\n                               s = NULL;\n                               actual_type = AUGMENT_KEYWORD;\n                             }\n\naugment_stmt: AUGMENT_KEYWORD sep augment_arg\n              '{' stmtsep\n                  augment_opt_stmt\n              '}' { LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);\n                    actual_type = $3.token;\n                    actual = $3.actual;\n                    data_node = $3.actual;\n                  }\n\naugment_opt_stmt: @EMPTYDIR@ { $$.augment = actual; }\n  |  augment_opt_stmt when_stmt stmtsep\n  |  augment_opt_stmt if_feature_stmt stmtsep\n  |  augment_opt_stmt status_stmt { if ($1.augment->flags & LYS_STATUS_MASK) {\n                                      LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.augment, \"status\", \"augment\");\n                                      YYABORT;\n                                    }\n                                    $1.augment->flags |= $2;\n                                  }\n  |  augment_opt_stmt description_stmt { if (yang_read_description(trg, $1.augment, s, \"augment\", NODE_PRINT)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                       }\n  |  augment_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.augment, s, \"augment\", NODE_PRINT)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                     }\n  |  augment_opt_stmt data_def_stmt stmtsep\n  |  augment_opt_stmt action_stmt stmtsep\n  |  augment_opt_stmt notification_stmt stmtsep { if (trg->version < 2) {\n                                                    LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, $1.augment, \"notification\");\n                                                    YYABORT;\n                                                  }\n                                                }\n  |  augment_opt_stmt case_stmt stmtsep\n\naction_arg_str: identifier_arg_str { if (param->module->version != 2) {\n                                       LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"action\");\n                                       free(s);\n                                       YYABORT;\n                                     }\n                                     $$.token = actual_type;\n                                     $$.actual = actual;\n                                     if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {\n                                       YYABORT;\n                                     }\n                                     data_node = actual;\n                                     s = NULL;\n                                     actual_type = ACTION_KEYWORD;\n                                   }\n\naction_stmt: ACTION_KEYWORD sep action_arg_str rpc_end\n             { LOGDBG(LY_LDGYANG, \"finished parsing action statement \\\"%s\\\"\", data_node->name);\n               actual_type = $3.token;\n               actual = $3.actual;\n               data_node = $3.actual;\n             }\n\nrpc_arg_str: identifier_arg_str { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = RPC_KEYWORD;\n                                }\n\nrpc_stmt: RPC_KEYWORD sep rpc_arg_str rpc_end\n          { LOGDBG(LY_LDGYANG, \"finished parsing rpc statement \\\"%s\\\"\", data_node->name);\n            actual_type = $3.token;\n            actual = $3.actual;\n            data_node = $3.actual;\n          }\n\nrpc_end: ';'\n  |  '{' stmtsep\n         rpc_opt_stmt\n      '}' { void *tmp;\n\n            if ($3.node.ptr_rpc->iffeature_size) {\n              tmp = realloc($3.node.ptr_rpc->iffeature, $3.node.ptr_rpc->iffeature_size * sizeof *$3.node.ptr_rpc->iffeature);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.node.ptr_rpc->iffeature = tmp;\n            }\n\n            if ($3.node.ptr_rpc->tpdf_size) {\n              tmp = realloc($3.node.ptr_rpc->tpdf, $3.node.ptr_rpc->tpdf_size * sizeof *$3.node.ptr_rpc->tpdf);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.node.ptr_rpc->tpdf = tmp;\n            }\n          }\n\n\nrpc_opt_stmt: @EMPTYDIR@ { $$.node.ptr_rpc = actual;\n                           $$.node.flag = 0;\n                         }\n  |  rpc_opt_stmt if_feature_stmt stmtsep\n  |  rpc_opt_stmt status_stmt { if ($1.node.ptr_rpc->flags & LYS_STATUS_MASK) {\n                                  LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_rpc, \"status\", \"rpc\");\n                                  YYABORT;\n                                }\n                                $1.node.ptr_rpc->flags |= $2;\n                             }\n  |  rpc_opt_stmt description_stmt { if (yang_read_description(trg, $1.node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                       YYABORT;\n                                     }\n                                     s = NULL;\n                                   }\n  |  rpc_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                 }\n  |  rpc_opt_stmt typedef_stmt stmtsep\n  |  rpc_opt_stmt grouping_stmt stmtsep\n  |  rpc_opt_stmt input_stmt stmtsep { if ($1.node.flag & LYS_RPC_INPUT) {\n                                         LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_rpc, \"input\", \"rpc\");\n                                         YYABORT;\n                                       }\n                                       $1.node.flag |= LYS_RPC_INPUT;\n                                       $$ = $1;\n                                     }\n  |  rpc_opt_stmt output_stmt stmtsep { if ($1.node.flag & LYS_RPC_OUTPUT) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.node.ptr_rpc, \"output\", \"rpc\");\n                                          YYABORT;\n                                        }\n                                        $1.node.flag |= LYS_RPC_OUTPUT;\n                                        $$ = $1;\n                                      }\n\ninput_arg: INPUT_KEYWORD optsep { $$.token = actual_type;\n                                  $$.actual = actual;\n                                  s = strdup(\"input\");\n                                  if (!s) {\n                                    LOGMEM(trg->ctx);\n                                    YYABORT;\n                                  }\n                                  if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {\n                                    YYABORT;\n                                  }\n                                  data_node = actual;\n                                  s = NULL;\n                                  actual_type = INPUT_KEYWORD;\n                                }\n\ninput_stmt: input_arg\n            '{' stmtsep\n                input_output_opt_stmt\n            '}' { void *tmp;\n                  struct lys_node_inout *input = actual;\n\n                  if (input->must_size) {\n                    tmp = realloc(input->must, input->must_size * sizeof *input->must);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->must = tmp;\n                  }\n\n                  if (input->tpdf_size) {\n                    tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);\n                    if (!tmp) {\n                      LOGMEM(trg->ctx);\n                      YYABORT;\n                    }\n                    input->tpdf = tmp;\n                  }\n\n                  LOGDBG(LY_LDGYANG, \"finished parsing input statement \\\"%s\\\"\", data_node->name);\n                  actual_type = $1.token;\n                  actual = $1.actual;\n                  data_node = $1.actual;\n                }\n\ninput_output_opt_stmt: @EMPTYDIR@\n  |  input_output_opt_stmt must_stmt stmtsep\n  |  input_output_opt_stmt typedef_stmt stmtsep\n  |  input_output_opt_stmt grouping_stmt stmtsep\n  |  input_output_opt_stmt data_def_stmt stmtsep\n\noutput_arg: OUTPUT_KEYWORD optsep { $$.token = actual_type;\n                                    $$.actual = actual;\n                                    s = strdup(\"output\");\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {\n                                      YYABORT;\n                                    }\n                                    data_node = actual;\n                                    s = NULL;\n                                    actual_type = OUTPUT_KEYWORD;\n                                  }\n\noutput_stmt: output_arg\n             '{' stmtsep\n                 input_output_opt_stmt\n             '}' { void *tmp;\n                   struct lys_node_inout *output = actual;\n\n                   if (output->must_size) {\n                     tmp = realloc(output->must, output->must_size * sizeof *output->must);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->must = tmp;\n                   }\n\n                   if (output->tpdf_size) {\n                     tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);\n                     if (!tmp) {\n                       LOGMEM(trg->ctx);\n                       YYABORT;\n                     }\n                     output->tpdf = tmp;\n                   }\n\n                   LOGDBG(LY_LDGYANG, \"finished parsing output statement \\\"%s\\\"\", data_node->name);\n                   actual_type = $1.token;\n                   actual = $1.actual;\n                   data_node = $1.actual;\n                 }\n\nnotification_arg_str: identifier_arg_str { $$.token = actual_type;\n                                           $$.actual = actual;\n                                           if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {\n                                             YYABORT;\n                                           }\n                                           data_node = actual;\n                                           actual_type = NOTIFICATION_KEYWORD;\n                                         }\n\nnotification_stmt: NOTIFICATION_KEYWORD sep notification_arg_str notification_end\n                   { LOGDBG(LY_LDGYANG, \"finished parsing notification statement \\\"%s\\\"\", data_node->name);\n                     actual_type = $3.token;\n                     actual = $3.actual;\n                     data_node = $3.actual;\n                   }\n\nnotification_end: ';'\n  |  '{' stmtsep\n         notification_opt_stmt\n      '}' { void *tmp;\n\n            if ($3.notif->must_size) {\n              tmp = realloc($3.notif->must, $3.notif->must_size * sizeof *$3.notif->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3.notif->must = tmp;\n            }\n\n           if ($3.notif->iffeature_size) {\n             tmp = realloc($3.notif->iffeature, $3.notif->iffeature_size * sizeof *$3.notif->iffeature);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.notif->iffeature = tmp;\n           }\n\n           if ($3.notif->tpdf_size) {\n             tmp = realloc($3.notif->tpdf, $3.notif->tpdf_size * sizeof *$3.notif->tpdf);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3.notif->tpdf = tmp;\n           }\n          }\n\nnotification_opt_stmt: @EMPTYDIR@ { $$.notif = actual; }\n  |  notification_opt_stmt must_stmt stmtsep\n  |  notification_opt_stmt if_feature_stmt stmtsep\n  |  notification_opt_stmt status_stmt { if ($1.notif->flags & LYS_STATUS_MASK) {\n                                           LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, $1.notif, \"status\", \"notification\");\n                                           YYABORT;\n                                         }\n                                         $1.notif->flags |= $2;\n                                       }\n  |  notification_opt_stmt description_stmt { if (yang_read_description(trg, $1.notif, s, \"notification\", NODE_PRINT)) {\n                                                YYABORT;\n                                              }\n                                              s = NULL;\n                                            }\n  |  notification_opt_stmt reference_stmt { if (yang_read_reference(trg, $1.notif, s, \"notification\", NODE_PRINT)) {\n                                              YYABORT;\n                                            }\n                                            s = NULL;\n                                          }\n  |  notification_opt_stmt typedef_stmt stmtsep\n  |  notification_opt_stmt grouping_stmt stmtsep\n  |  notification_opt_stmt data_def_stmt stmtsep\n\ndeviation_arg: deviation_arg_str { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   YANG_ADDELEM(trg->deviation, trg->deviation_size, \"deviations\");\n                                   ((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);\n                                   free(s);\n                                   if (!((struct lys_deviation *)actual)->target_name) {\n                                     YYABORT;\n                                   }\n                                   s = NULL;\n                                   actual_type = DEVIATION_KEYWORD;\n                                 }\n\ndeviation_stmt: DEVIATION_KEYWORD sep deviation_arg\n                '{' stmtsep\n                    deviation_opt_stmt\n                '}' { void *tmp;\n\n                      if ($6->deviate_size) {\n                        tmp = realloc($6->deviate, $6->deviate_size * sizeof *$6->deviate);\n                        if (!tmp) {\n                          LOGINT(trg->ctx);\n                          YYABORT;\n                        }\n                        $6->deviate = tmp;\n                      } else {\n                        LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"deviate\", \"deviation\");\n                        YYABORT;\n                      }\n                      actual_type = $3.token;\n                      actual = $3.actual;\n                    }\n\ndeviation_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviation_opt_stmt description_stmt { if (yang_read_description(trg, $1, s, \"deviation\", NODE)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           $$ = $1;\n                                         }\n  |  deviation_opt_stmt reference_stmt { if (yang_read_reference(trg, $1, s, \"deviation\", NODE)) {\n                                           YYABORT;\n                                         }\n                                         s = NULL;\n                                         $$ = $1;\n                                       }\n  |  deviation_opt_stmt DEVIATE_KEYWORD sep deviate_body_stmt stmtsep\n\ndeviation_arg_str: absolute_schema_nodeids optsep\n  | string_1\n\ndeviate_body_stmt: deviate_not_supported_stmt\n  |  deviate_stmts\n\n\ndeviate_not_supported: NOT_SUPPORTED_KEYWORD { $$.token = actual_type;\n                                               $$.actual = actual;\n                                               if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {\n                                                 YYABORT;\n                                               }\n                                               actual_type = NOT_SUPPORTED_KEYWORD;\n                                             }\n\ndeviate_not_supported_stmt: deviate_not_supported optsep deviate_not_supported_end\n                            { actual_type = $1.token;\n                              actual = $1.actual;\n                            }\n\ndeviate_not_supported_end: ';'\n  | '{' stmtsep '}'\n\ndeviate_stmts: deviate_add_stmt\n  |  deviate_replace_stmt\n  |  deviate_delete_stmt\n\ndeviate_add: ADD_KEYWORD { $$.token = actual_type;\n                           $$.actual = actual;\n                           if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {\n                             YYABORT;\n                           }\n                           actual_type = ADD_KEYWORD;\n                         }\n\ndeviate_add_stmt: deviate_add optsep deviate_add_end\n                  { actual_type = $1.token;\n                    actual = $1.actual;\n                  }\n\ndeviate_add_end: ';'\n  |  '{' stmtsep\n         deviate_add_opt_stmt\n     '}' { void *tmp;\n\n           if ($3->must_size) {\n             tmp = realloc($3->must, $3->must_size * sizeof *$3->must);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->must = tmp;\n           }\n\n           if ($3->unique_size) {\n             tmp = realloc($3->unique, $3->unique_size * sizeof *$3->unique);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->unique = tmp;\n           }\n\n           if ($3->dflt_size) {\n             tmp = realloc($3->dflt, $3->dflt_size * sizeof *$3->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->dflt = tmp;\n           }\n         }\n\ndeviate_add_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviate_add_opt_stmt units_stmt { if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {\n                                         YYABORT;\n                                       }\n                                       s = NULL;\n                                       $$ = $1;\n                                     }\n  |  deviate_add_opt_stmt must_stmt stmtsep\n  |  deviate_add_opt_stmt unique_stmt { YANG_ADDELEM($1->unique, $1->unique_size, \"uniques\");\n                                        ((struct lys_unique *)actual)->expr = (const char **)s;\n                                        s = NULL;\n                                        actual = $1;\n                                        $$= $1;\n                                      }\n  |  deviate_add_opt_stmt default_stmt { YANG_ADDELEM($1->dflt, $1->dflt_size, \"defaults\");\n                                         *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                         s = NULL;\n                                         actual = $1;\n                                         $$ = $1;\n                                       }\n  |  deviate_add_opt_stmt config_stmt { if ($1->flags & LYS_CONFIG_MASK) {\n                                          LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                          YYABORT;\n                                        }\n                                        $1->flags = $2;\n                                        $$ = $1;\n                                      }\n  |  deviate_add_opt_stmt mandatory_stmt { if ($1->flags & LYS_MAND_MASK) {\n                                             LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                             YYABORT;\n                                           }\n                                           $1->flags = $2;\n                                           $$ = $1;\n                                         }\n  |  deviate_add_opt_stmt min_elements_stmt { if ($1->min_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              $1->min = $2;\n                                              $1->min_set = 1;\n                                              $$ =  $1;\n                                            }\n  |  deviate_add_opt_stmt max_elements_stmt { if ($1->max_set) {\n                                                LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                YYABORT;\n                                              }\n                                              $1->max = $2;\n                                              $1->max_set = 1;\n                                              $$ =  $1;\n                                            }\n\ndeviate_delete: DELETE_KEYWORD { $$.token = actual_type;\n                                 $$.actual = actual;\n                                 if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {\n                                   YYABORT;\n                                 }\n                                 actual_type = DELETE_KEYWORD;\n                               }\n\ndeviate_delete_stmt: deviate_delete optsep deviate_delete_end\n                     { actual_type = $1.token;\n                       actual = $1.actual;\n                     }\n\ndeviate_delete_end: ';'\n  |  '{' stmtsep\n         deviate_delete_opt_stmt\n      '}' { void *tmp;\n\n            if ($3->must_size) {\n              tmp = realloc($3->must, $3->must_size * sizeof *$3->must);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3->must = tmp;\n            }\n\n            if ($3->unique_size) {\n              tmp = realloc($3->unique, $3->unique_size * sizeof *$3->unique);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3->unique = tmp;\n            }\n\n            if ($3->dflt_size) {\n              tmp = realloc($3->dflt, $3->dflt_size * sizeof *$3->dflt);\n              if (!tmp) {\n                LOGMEM(trg->ctx);\n                YYABORT;\n              }\n              $3->dflt = tmp;\n            }\n          }\n\ndeviate_delete_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviate_delete_opt_stmt units_stmt { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                            YYABORT;\n                                          }\n                                          s = NULL;\n                                          $$ = $1;\n                                        }\n  |  deviate_delete_opt_stmt must_stmt stmtsep\n  |  deviate_delete_opt_stmt unique_stmt { YANG_ADDELEM($1->unique, $1->unique_size, \"uniques\");\n                                           ((struct lys_unique *)actual)->expr = (const char **)s;\n                                           s = NULL;\n                                           actual = $1;\n                                           $$ = $1;\n                                         }\n  |  deviate_delete_opt_stmt default_stmt { YANG_ADDELEM($1->dflt, $1->dflt_size, \"defaults\");\n                                            *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                            s = NULL;\n                                            actual = $1;\n                                            $$ = $1;\n                                          }\n\ndeviate_replace: REPLACE_KEYWORD { $$.token = actual_type;\n                                   $$.actual = actual;\n                                   if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {\n                                     YYABORT;\n                                   }\n                                   actual_type = REPLACE_KEYWORD;\n                                 }\n\ndeviate_replace_stmt: deviate_replace optsep deviate_replace_end\n                      { actual_type = $1.token;\n                        actual = $1.actual;\n                      }\n\ndeviate_replace_end: ';'\n  |  '{' stmtsep\n         deviate_replace_opt_stmt\n     '}' { void *tmp;\n\n           if ($3->dflt_size) {\n             tmp = realloc($3->dflt, $3->dflt_size * sizeof *$3->dflt);\n             if (!tmp) {\n               LOGMEM(trg->ctx);\n               YYABORT;\n             }\n             $3->dflt = tmp;\n           }\n         }\n\ndeviate_replace_opt_stmt: @EMPTYDIR@ { $$ = actual; }\n  |  deviate_replace_opt_stmt type_stmt stmtsep\n  |  deviate_replace_opt_stmt units_stmt { if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {\n                                             YYABORT;\n                                           }\n                                           s = NULL;\n                                           $$ = $1;\n                                         }\n  |  deviate_replace_opt_stmt default_stmt { YANG_ADDELEM($1->dflt, $1->dflt_size, \"defaults\");\n                                             *((const char **)actual) = lydict_insert_zc(trg->ctx, s);\n                                             s = NULL;\n                                             actual = $1;\n                                             $$ = $1;\n                                           }\n  |  deviate_replace_opt_stmt config_stmt { if ($1->flags & LYS_CONFIG_MASK) {\n                                              LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");\n                                              YYABORT;\n                                            }\n                                            $1->flags = $2;\n                                            $$ = $1;\n                                          }\n  |  deviate_replace_opt_stmt mandatory_stmt { if ($1->flags & LYS_MAND_MASK) {\n                                                 LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");\n                                                 YYABORT;\n                                               }\n                                               $1->flags = $2;\n                                               $$ = $1;\n                                             }\n  |  deviate_replace_opt_stmt min_elements_stmt { if ($1->min_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  $1->min = $2;\n                                                  $1->min_set = 1;\n                                                  $$ =  $1;\n                                                }\n  |  deviate_replace_opt_stmt max_elements_stmt { if ($1->max_set) {\n                                                    LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");\n                                                    YYABORT;\n                                                  }\n                                                  $1->max = $2;\n                                                  $1->max_set = 1;\n                                                  $$ =  $1;\n                                                }\n\nwhen_arg_str: string  { $$.token = actual_type;\n                        $$.actual = actual;\n                        if (!(actual = yang_read_when(trg, actual, actual_type, s))) {\n                          YYABORT;\n                        }\n                        s = NULL;\n                        actual_type = WHEN_KEYWORD;\n                      }\n\nwhen_stmt: WHEN_KEYWORD sep when_arg_str when_end\n           { actual_type = $3.token;\n             actual = $3.actual;\n           }\n\nwhen_end: ';'\n  |  '{' stmtsep\n         when_opt_stmt\n     '}'\n\nwhen_opt_stmt: @EMPTYDIR@\n  |  when_opt_stmt description_stmt { if (yang_read_description(trg, actual, s, \"when\", NODE)) {\n                                        YYABORT;\n                                      }\n                                      s = NULL;\n                                    }\n  |  when_opt_stmt reference_stmt { if (yang_read_reference(trg, actual, s, \"when\", NODE)) {\n                                      YYABORT;\n                                    }\n                                    s = NULL;\n                                  }\n\nconfig_arg: config_arg_str { $$ = $1;\n                             backup_type = actual_type;\n                             actual_type = CONFIG_KEYWORD;\n                           }\n\nconfig_stmt: CONFIG_KEYWORD sep config_arg stmtend { $$ = $3; }\n\nconfig_arg_str: TRUE_KEYWORD optsep { $$ = LYS_CONFIG_W | LYS_CONFIG_SET; }\n  |  FALSE_KEYWORD optsep { $$ = LYS_CONFIG_R | LYS_CONFIG_SET; }\n  |  string_1 { if (!strcmp(s, \"true\")) {\n                  $$ = LYS_CONFIG_W | LYS_CONFIG_SET;\n                } else if (!strcmp(s, \"false\")) {\n                  $$ = LYS_CONFIG_R | LYS_CONFIG_SET;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"config\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\nmandatory_arg: mandatory_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = MANDATORY_KEYWORD;\n                                 }\n\nmandatory_stmt: MANDATORY_KEYWORD sep mandatory_arg stmtend { $$ = $3; }\n\nmandatory_arg_str: TRUE_KEYWORD optsep { $$ = LYS_MAND_TRUE; }\n  |  FALSE_KEYWORD optsep { $$ = LYS_MAND_FALSE; }\n  |  string_1 { if (!strcmp(s, \"true\")) {\n                  $$ = LYS_MAND_TRUE;\n                } else if (!strcmp(s, \"false\")) {\n                  $$ = LYS_MAND_FALSE;\n                } else {\n                  LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"mandatory\");\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s = NULL;\n              }\n\npresence_arg: string { backup_type = actual_type;\n                       actual_type = PRESENCE_KEYWORD;\n                     }\n\npresence_stmt: PRESENCE_KEYWORD sep presence_arg stmtend\n\nmin_value_arg: min_value_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = MIN_ELEMENTS_KEYWORD;\n                                 }\n\nmin_elements_stmt: MIN_ELEMENTS_KEYWORD sep min_value_arg stmtend { $$ = $3; }\n\nmin_value_arg_str: non_negative_integer_value optsep { $$ = $1; }\n  |  string_1 { if (strlen(s) == 1 && s[0] == '0') {\n                  $$ = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"min-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  $$ = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\nmax_value_arg: max_value_arg_str { $$ = $1;\n                                   backup_type = actual_type;\n                                   actual_type = MAX_ELEMENTS_KEYWORD;\n                                 }\n\nmax_elements_stmt: MAX_ELEMENTS_KEYWORD sep max_value_arg stmtend { $$ = $3; }\n\nmax_value_arg_str: UNBOUNDED_KEYWORD optsep { $$ = 0; }\n  |  positive_integer_value optsep { $$ = $1; }\n  |  string_1 { if (!strcmp(s, \"unbounded\")) {\n                  $$ = 0;\n                } else {\n                  /* convert it to uint32_t */\n                  uint64_t val;\n                  char *endptr = NULL;\n                  errno = 0;\n\n                  val = strtoul(s, &endptr, 10);\n                  if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                      LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"max-elements\");\n                      free(s);\n                      YYABORT;\n                  }\n                  $$ = (uint32_t) val;\n                }\n                free(s);\n                s = NULL;\n              }\n\nordered_by_arg: ordered_by_arg_str { $$ = $1;\n                                     backup_type = actual_type;\n                                     actual_type = ORDERED_BY_KEYWORD;\n                                   }\n\nordered_by_stmt: ORDERED_BY_KEYWORD sep ordered_by_arg stmtend { $$ = $3; }\n\nordered_by_arg_str: USER_KEYWORD optsep { $$ = LYS_USERORDERED; }\n  |  SYSTEM_KEYWORD optsep { $$ = LYS_SYSTEMORDERED; }\n  |  string_1 { if (!strcmp(s, \"user\")) {\n                  $$ = LYS_USERORDERED;\n                } else if (!strcmp(s, \"system\")) {\n                  $$ = LYS_SYSTEMORDERED;\n                } else {\n                  free(s);\n                  YYABORT;\n                }\n                free(s);\n                s=NULL;\n              }\n\nmust_agr_str: string { $$.token = actual_type;\n                       $$.actual = actual;\n                       switch (actual_type) {\n                       case CONTAINER_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_container *)actual)->must,\n                                     ((struct lys_node_container *)actual)->must_size, \"musts\");\n                         break;\n                       case ANYDATA_KEYWORD:\n                       case ANYXML_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,\n                                     ((struct lys_node_anydata *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,\n                                     ((struct lys_node_leaf *)actual)->must_size, \"musts\");\n                         break;\n                       case LEAF_LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,\n                                     ((struct lys_node_leaflist *)actual)->must_size, \"musts\");\n                         break;\n                       case LIST_KEYWORD:\n                         YANG_ADDELEM(((struct lys_node_list *)actual)->must,\n                                     ((struct lys_node_list *)actual)->must_size, \"musts\");\n                         break;\n                       case REFINE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_refine *)actual)->must,\n                                     ((struct lys_refine *)actual)->must_size, \"musts\");\n                         break;\n                       case ADD_KEYWORD:\n                       case DELETE_KEYWORD:\n                         YANG_ADDELEM(((struct lys_deviate *)actual)->must,\n                                      ((struct lys_deviate *)actual)->must_size, \"musts\");\n                         break;\n                       case NOTIFICATION_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_notif *)actual)->must,\n                                     ((struct lys_node_notif *)actual)->must_size, \"musts\");\n                         break;\n                       case INPUT_KEYWORD:\n                       case OUTPUT_KEYWORD:\n                         if (trg->version < 2) {\n                           free(s);\n                           LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");\n                           YYABORT;\n                         }\n                         YANG_ADDELEM(((struct lys_node_inout *)actual)->must,\n                                     ((struct lys_node_inout *)actual)->must_size, \"musts\");\n                         break;\n                       case EXTENSION_INSTANCE:\n                         /* must is already allocated */\n                         break;\n                       default:\n                         free(s);\n                         LOGINT(trg->ctx);\n                         YYABORT;\n                       }\n                       ((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);\n                       free(s);\n                       if (!((struct lys_restr *)actual)->expr) {\n                         YYABORT;\n                       }\n                       s = NULL;\n                       actual_type = MUST_KEYWORD;\n                     }\n\nmust_stmt: MUST_KEYWORD sep must_agr_str must_end\n           { actual_type = $3.token;\n             actual = $3.actual;\n           }\n\nmust_end: ';'\n  |  '{' stmtsep\n         message_opt_stmt\n     '}'\n\nunique_arg: unique_arg_str { backup_type = actual_type;\n                             actual_type = UNIQUE_KEYWORD;\n                           }\n\nunique_stmt: UNIQUE_KEYWORD sep unique_arg stmtend\n\nunique_arg_str: descendant_schema_nodeid optsep\n  |  string_1\n\nkey_arg: key_arg_str { backup_type = actual_type;\n                       actual_type = KEY_KEYWORD;\n                     }\n\nkey_stmt: KEY_KEYWORD sep key_arg stmtend;\n\nkey_arg_str: node_identifier { s = strdup(yyget_text(scanner));\n                               if (!s) {\n                                 LOGMEM(trg->ctx);\n                                 YYABORT;\n                               }\n                             }\n             optsep\n  |  string_1\n  ;\n\nrange_arg_str: string { $$.token = actual_type;\n                        $$.actual = actual;\n                        if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {\n                          YYABORT;\n                        }\n                        actual_type = RANGE_KEYWORD;\n                        s = NULL;\n                      }\n\nabsolute_schema_nodeid: '/' node_identifier { if (s) {\n                                                s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                strcat(s,\"/\");\n                                                strcat(s, yyget_text(scanner));\n                                              } else {\n                                                s = malloc(yyget_leng(scanner) + 2);\n                                                if (!s) {\n                                                  LOGMEM(trg->ctx);\n                                                  YYABORT;\n                                                }\n                                                s[0]='/';\n                                                memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);\n                                              }\n                                            }\n\nabsolute_schema_nodeids: absolute_schema_nodeid absolute_schema_nodeid_opt;\n\nabsolute_schema_nodeid_opt: @EMPTYDIR@\n  |  absolute_schema_nodeid_opt absolute_schema_nodeid\n  ;\n\ndescendant_schema_nodeid: node_identifier { if (s) {\n                                              s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                              strcat(s, yyget_text(scanner));\n                                            } else {\n                                              s = strdup(yyget_text(scanner));\n                                              if (!s) {\n                                                LOGMEM(trg->ctx);\n                                                YYABORT;\n                                              }\n                                            }\n                                          }\n                          absolute_schema_nodeid_opt;\n\npath_arg_str: { tmp_s = yyget_text(scanner); } absolute_paths { s = strdup(tmp_s);\n                                                                if (!s) {\n                                                                  LOGMEM(trg->ctx);\n                                                                  YYABORT;\n                                                                }\n                                                                s[strlen(s) - 1] = '\\0';\n                                                             }\n  |  { tmp_s = yyget_text(scanner); } relative_path { s = strdup(tmp_s);\n                                                      if (!s) {\n                                                        LOGMEM(trg->ctx);\n                                                        YYABORT;\n                                                      }\n                                                      s[strlen(s) - 1] = '\\0';\n                                                    }\n  |  string_1\n  ;\n\nabsolute_path: '/' node_identifier path_predicate\n\nabsolute_paths: absolute_path absolute_path_opt\n\nabsolute_path_opt: @EMPTYDIR@\n  |  absolute_path_opt absolute_path;\n\nrelative_path: relative_path_part1 relative_path_part1_opt descendant_path\n\nrelative_path_part1: DOUBLEDOT '/';\n\nrelative_path_part1_opt: @EMPTYDIR@\n  |  relative_path_part1_opt relative_path_part1;\n\ndescendant_path: node_identifier descendant_path_opt\n\ndescendant_path_opt: @EMPTYDIR@\n  |  path_predicate absolute_paths;\n\npath_predicate: @EMPTYDIR@\n  | path_predicate '[' whitespace_opt path_equality_expr ']'\n\npath_equality_expr: node_identifier whitespace_opt '=' whitespace_opt path_key_expr\n\npath_key_expr: current_function_invocation whitespace_opt '/' whitespace_opt\n                     rel_path_keyexpr\n\nrel_path_keyexpr: rel_path_keyexpr_part1 rel_path_keyexpr_part1_opt\n                    node_identifier rel_path_keyexpr_part2\n\nrel_path_keyexpr_part1: DOUBLEDOT whitespace_opt '/' whitespace_opt;\n\nrel_path_keyexpr_part1_opt: @EMPTYDIR@\n  |  rel_path_keyexpr_part1_opt rel_path_keyexpr_part1;\n\nrel_path_keyexpr_part2: @EMPTYDIR@\n  | rel_path_keyexpr_part2 whitespace_opt '/' whitespace_opt node_identifier;\n\ncurrent_function_invocation: CURRENT_KEYWORD whitespace_opt '(' whitespace_opt ')'\n\npositive_integer_value: NON_NEGATIVE_INTEGER { /* convert it to uint32_t */\n                                                unsigned long val;\n\n                                                val = strtoul(yyget_text(scanner), NULL, 10);\n                                                if (val > UINT32_MAX) {\n                                                    LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Converted number is very long.\");\n                                                    YYABORT;\n                                                }\n                                                $$ = (uint32_t) val;\n                                             }\n\nnon_negative_integer_value: ZERO { $$ = 0; }\n  |  positive_integer_value { $$ = $1; }\n  ;\n\ninteger_value: ZERO { $$ = 0; }\n  |  integer_value_convert { /* convert it to int32_t */\n                             int64_t val;\n\n                             val = strtoll(yyget_text(scanner), NULL, 10);\n                             if (val < INT32_MIN || val > INT32_MAX) {\n                                 LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                                        \"The number is not in the correct range (INT32_MIN..INT32_MAX): \\\"%d\\\"\",val);\n                                 YYABORT;\n                             }\n                             $$ = (int32_t) val;\n                           }\n\ninteger_value_convert: INTEGER\n  |  NON_NEGATIVE_INTEGER\n\nprefix_arg_str: string_1\n  |  identifiers optsep;\n\nidentifier_arg_str: identifiers optsep\n  |  string_1 { if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                    free(s);\n                    YYABORT;\n                }\n              }\n\nnode_identifier: identifier\n  |  IDENTIFIERPREFIX\n  ;\n\nidentifier_ref_arg_str: identifiers optsep\n  | identifiers_ref optsep\n  | string_1 { char *tmp;\n\n               if ((tmp = strchr(s, ':'))) {\n                 *tmp = '\\0';\n                 /* check prefix */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n                 *tmp = ':';\n               } else {\n                 /* check identifier */\n                 if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {\n                   free(s);\n                   YYABORT;\n                 }\n               }\n             }\n\nstmtend: semicolom stmtsep { s = $1; }\n  | curly_bracket_open stmtsep curly_bracket_close stmtsep { s = $1; }\n\n\nsemicolom: ';' { actual_type = backup_type;\n                 backup_type = NODE;\n                 $$ = s;\n                 s = NULL;\n               }\n\ncurly_bracket_close: '}' { actual_type = backup_type;\n                           backup_type = NODE;\n                         }\n\ncurly_bracket_open: '{' { $$ = s;\n                          s = NULL;\n                        }\n\n\nstmtsep: @EMPTYDIR@\n  | stmtsep sep_stmt\n  | stmtsep unknown_statement\n  ;\n\nunknown_statement: identifiers_ref string_opt unknown_statement_end\n                   { actual_type = $2.token;\n                     actual = $2.actual;\n                   }\n\nstring_opt: string_opt_part1 string_opt_part2 { $$.token = actual_type;\n                                                $$.actual = actual;\n                                                if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, $1, s,\n                                                                             actual_type, backup_type, is_ext_instance))) {\n                                                  YYABORT;\n                                                }\n                                                s = NULL;\n                                                actual_type = EXTENSION_INSTANCE;\n                                              }\n\nstring_opt_part1: optsep { $$ = s; s = NULL; }\n\nstring_opt_part2: @EMPTYDIR@\n  |  string\n\nunknown_string: @EMPTYDIR@\n  |  sep unknown_string_part1\n\nunknown_string_part1: @EMPTYDIR@\n  |  strings optsep\n  |  STRING optsep unknown_string_part2\n\nunknown_string_part2: @EMPTYDIR@\n  |  unknown_string_part2 '+' optsep STRING optsep\n\nunknown_statement_end: ';'\n  |  '{' optsep unknown_statement2_opt '}'\n\nunknown_statement2_opt: @EMPTYDIR@\n  |  unknown_statement2_opt unknown_statement2 optsep\n\n/* unknown_statement2 read yang statement or extension; yang statement is parsed later */\n\nunknown_statement2: unknown_statement\n  |  unknown_statement2_yang_stmt unknown_string unknown_statement2_end\n     {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length = 0, old_length = 0;\n        char *tmp_value;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen($1);\n        old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;\n        tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_substmt = tmp_value;\n        tmp_value += old_length - 2;\n        memcpy(tmp_value, $1, length);\n        tmp_value[length] = ' ';\n        tmp_value[length + 1] = '\\0';\n        tmp_value[length + 2] = '\\0';\n      }\n  |  unknown_statement2_module_stmt unknown_string unknown_statement2_end\n     {  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;\n        int32_t length;\n        char *tmp_value, **array;\n        int i = 0;\n\n        if (!substmt) {\n          substmt = calloc(1, sizeof *substmt);\n          if (!substmt) {\n            LOGMEM(trg->ctx);\n            YYABORT;\n          }\n          ((struct lys_ext_instance *)actual)->parent = substmt;\n        }\n        length = strlen($1);\n        if (!substmt->ext_modules) {\n          array = malloc(2 * sizeof *substmt->ext_modules);\n        } else {\n          for (i = 0; substmt->ext_modules[i]; ++i);\n          array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);\n        }\n        if (!array) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        substmt->ext_modules = array;\n        array[i + 1] = NULL;\n        tmp_value = malloc(length + 2);\n        if (!tmp_value) {\n          LOGMEM(trg->ctx);\n          YYABORT;\n        }\n        array[i] = tmp_value;\n        memcpy(tmp_value, $1, length);\n        tmp_value[length] = '\\0';\n        tmp_value[length + 1] = '\\0';\n      }\n\nunknown_statement2_end: ';'\n  |  '{' optsep unknown_statement3_opt '}'\n\nunknown_statement2_yang_stmt: yang_stmt { $$ = yyget_text(scanner); }\n\nunknown_statement2_module_stmt: MODULE_KEYWORD { $$ = yyget_text(scanner); }\n\nunknown_statement3_opt: @EMPTYDIR@\n  |  unknown_statement3_opt node_identifier unknown_string unknown_statement3_opt_end;\n\nunknown_statement3_opt_end: ';' optsep\n  |  '{' optsep unknown_statement3_opt '}' optsep\n\nsep_stmt: WHITESPACE\n  | EOL\n  ;\n\noptsep: @EMPTYDIR@\n  | optsep sep_stmt\n  ;\n\nsep: sep_stmt optsep;\n\nwhitespace_opt: @EMPTYDIR@\n  | WHITESPACE\n  ;\n\nstring: strings { s = strdup(yyget_text(scanner));\n                  if (!s) {\n                    LOGMEM(trg->ctx);\n                    YYABORT;\n                  }\n                }\n        optsep\n  |  string_1\n\nstrings: STRINGS\n  |  REVISION_DATE\n  |  identifier\n  |  IDENTIFIERPREFIX\n  |  ZERO\n  |  INTEGER\n  |  NON_NEGATIVE_INTEGER\n\nidentifier: MODULE_KEYWORD\n  |  identifier1\n  |  yang_stmt\n\nidentifier1: IDENTIFIER\n  |  CURRENT_KEYWORD\n  |  DEPRECATED_KEYWORD\n  |  FALSE_KEYWORD\n  |  NOT_SUPPORTED_KEYWORD\n  |  OBSOLETE_KEYWORD\n  |  SYSTEM_KEYWORD\n  |  TRUE_KEYWORD\n  |  UNBOUNDED_KEYWORD\n  |  USER_KEYWORD\n\n\nyang_stmt: ANYXML_KEYWORD\n  |  ARGUMENT_KEYWORD\n  |  AUGMENT_KEYWORD\n  |  BASE_KEYWORD\n  |  BELONGS_TO_KEYWORD\n  |  BIT_KEYWORD\n  |  CASE_KEYWORD\n  |  CHOICE_KEYWORD\n  |  CONFIG_KEYWORD\n  |  CONTACT_KEYWORD\n  |  CONTAINER_KEYWORD\n  |  DEFAULT_KEYWORD\n  |  DESCRIPTION_KEYWORD\n  |  ENUM_KEYWORD\n  |  ERROR_APP_TAG_KEYWORD\n  |  ERROR_MESSAGE_KEYWORD\n  |  EXTENSION_KEYWORD\n  |  DEVIATION_KEYWORD\n  |  DEVIATE_KEYWORD\n  |  FEATURE_KEYWORD\n  |  FRACTION_DIGITS_KEYWORD\n  |  GROUPING_KEYWORD\n  |  IDENTITY_KEYWORD\n  |  IF_FEATURE_KEYWORD\n  |  IMPORT_KEYWORD\n  |  INCLUDE_KEYWORD\n  |  INPUT_KEYWORD\n  |  KEY_KEYWORD\n  |  LEAF_KEYWORD\n  |  LEAF_LIST_KEYWORD\n  |  LENGTH_KEYWORD\n  |  LIST_KEYWORD\n  |  MANDATORY_KEYWORD\n  |  MAX_ELEMENTS_KEYWORD\n  |  MIN_ELEMENTS_KEYWORD\n  |  MUST_KEYWORD\n  |  NAMESPACE_KEYWORD\n  |  NOTIFICATION_KEYWORD\n  |  ORDERED_BY_KEYWORD\n  |  ORGANIZATION_KEYWORD\n  |  OUTPUT_KEYWORD\n  |  PATH_KEYWORD\n  |  PATTERN_KEYWORD\n  |  POSITION_KEYWORD\n  |  PREFIX_KEYWORD\n  |  PRESENCE_KEYWORD\n  |  RANGE_KEYWORD\n  |  REFERENCE_KEYWORD\n  |  REFINE_KEYWORD\n  |  REQUIRE_INSTANCE_KEYWORD\n  |  REVISION_KEYWORD\n  |  REVISION_DATE_KEYWORD\n  |  RPC_KEYWORD\n  |  STATUS_KEYWORD\n  |  SUBMODULE_KEYWORD\n  |  TYPE_KEYWORD\n  |  TYPEDEF_KEYWORD\n  |  UNIQUE_KEYWORD\n  |  UNITS_KEYWORD\n  |  USES_KEYWORD\n  |  VALUE_KEYWORD\n  |  WHEN_KEYWORD\n  |  YANG_VERSION_KEYWORD\n  |  YIN_ELEMENT_KEYWORD\n  |  ADD_KEYWORD\n  |  DELETE_KEYWORD\n  |  REPLACE_KEYWORD\n  |  ACTION_KEYWORD\n  |  MODIFIER_KEYWORD\n  |  ANYDATA_KEYWORD\n\nidentifiers: identifier { s = strdup(yyget_text(scanner));\n                          if (!s) {\n                            LOGMEM(trg->ctx);\n                            YYABORT;\n                          }\n                        }\n\nidentifiers_ref: IDENTIFIERPREFIX { s = strdup(yyget_text(scanner));\n                                    if (!s) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                  }\n\ntype_ext_alloc: @EMPTYDIR@ { struct lys_type **type;\n\n                             type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                            \"type\", LY_STMT_TYPE);\n                             if (!type) {\n                               YYABORT;\n                             }\n                             /* allocate type structure */\n                             (*type) = calloc(1, sizeof **type);\n                             if (!*type) {\n                               LOGMEM(trg->ctx);\n                               YYABORT;\n                             }\n\n                             /* HACK for unres */\n                             (*type)->parent = (struct lys_tpdf *)ext_instance;\n                             $$ = actual = *type;\n                             is_ext_instance = 0;\n                            }\n\ntypedef_ext_alloc: @EMPTYDIR@ { struct lys_tpdf **tpdf;\n\n                                tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                               \"typedef\", LY_STMT_TYPEDEF);\n                                if (!tpdf) {\n                                  YYABORT;\n                                }\n                                /* allocate typedef structure */\n                                (*tpdf) = calloc(1, sizeof **tpdf);\n                                if (!*tpdf) {\n                                  LOGMEM(trg->ctx);\n                                  YYABORT;\n                                }\n\n                                $$ = actual = *tpdf;\n                                is_ext_instance = 0;\n                              }\n\niffeature_ext_alloc: @EMPTYDIR@ { struct lys_iffeature **iffeature;\n\n                                 iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                          \"if-feature\", LY_STMT_IFFEATURE);\n                                 if (!iffeature) {\n                                   YYABORT;\n                                 }\n                                 /* allocate typedef structure */\n                                 (*iffeature) = calloc(1, sizeof **iffeature);\n                                 if (!*iffeature) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 $$ = actual = *iffeature;\n                               }\n\nrestriction_ext_alloc: @EMPTYDIR@ { struct lys_restr **restr;\n                                    LY_STMT stmt;\n\n                                    s = yyget_text(scanner);\n                                    if (!strcmp(s, \"must\")) {\n                                      stmt = LY_STMT_MUST;\n                                    } else if (!strcmp(s, \"pattern\")) {\n                                      stmt = LY_STMT_PATTERN;\n                                    } else if (!strcmp(s, \"range\")) {\n                                      stmt = LY_STMT_RANGE;\n                                    } else {\n                                      stmt = LY_STMT_LENGTH;\n                                    }\n                                    restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);\n                                    if (!restr) {\n                                      YYABORT;\n                                    }\n                                    /* allocate structure for must */\n                                    (*restr) = calloc(1, sizeof(struct lys_restr));\n                                    if (!*restr) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    $$ = actual = *restr;\n                                    s = NULL;\n                                  }\n\nwhen_ext_alloc: @EMPTYDIR@ { actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, \"when\", LY_STMT_WHEN);\n                             if (!actual) {\n                               YYABORT;\n                             }\n                             $$ = actual;\n                           }\n\nrevision_ext_alloc: @EMPTYDIR@ { struct lys_revision **rev;\n                                 int i;\n\n                                 rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,\n                                                                                                   \"revision\", LY_STMT_REVISION);\n                                 if (!rev) {\n                                   YYABORT;\n                                 }\n                                 rev[i] = calloc(1, sizeof **rev);\n                                 if (!rev[i]) {\n                                   LOGMEM(trg->ctx);\n                                   YYABORT;\n                                 }\n                                 actual = rev[i];\n                                 $$.revision = rev;\n                                 $$.index = i;\n                               }\n\ndatadef_ext_check: @EMPTYDIR@ { LY_STMT stmt;\n\n                                s = yyget_text(scanner);\n                                if (!strcmp(s, \"action\")) {\n                                  stmt = LY_STMT_ACTION;\n                                } else if (!strcmp(s, \"anydata\")) {\n                                  stmt = LY_STMT_ANYDATA;\n                                } else if (!strcmp(s, \"anyxml\")) {\n                                  stmt = LY_STMT_ANYXML;\n                                } else if (!strcmp(s, \"case\")) {\n                                  stmt = LY_STMT_CASE;\n                                } else if (!strcmp(s, \"choice\")) {\n                                  stmt = LY_STMT_CHOICE;\n                                } else if (!strcmp(s, \"container\")) {\n                                  stmt = LY_STMT_CONTAINER;\n                                } else if (!strcmp(s, \"grouping\")) {\n                                  stmt = LY_STMT_GROUPING;\n                                } else if (!strcmp(s, \"input\")) {\n                                  stmt = LY_STMT_INPUT;\n                                } else if (!strcmp(s, \"leaf\")) {\n                                  stmt = LY_STMT_LEAF;\n                                } else if (!strcmp(s, \"leaf-list\")) {\n                                  stmt = LY_STMT_LEAFLIST;\n                                } else if (!strcmp(s, \"list\")) {\n                                  stmt = LY_STMT_LIST;\n                                } else if (!strcmp(s, \"notification\")) {\n                                  stmt = LY_STMT_NOTIFICATION;\n                                } else if (!strcmp(s, \"output\")) {\n                                  stmt = LY_STMT_OUTPUT;\n                                } else {\n                                  stmt = LY_STMT_USES;\n                                }\n                                if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {\n                                  YYABORT;\n                                }\n                                actual = NULL;\n                                s = NULL;\n                                is_ext_instance = 0;\n                              }\n\nnot_supported_ext_check: not_supported_ext { LOGERR(trg->ctx, ly_errno, \"Extension's substatement \\\"%s\\\" not supported.\", yyget_text(scanner)); }\n\nnot_supported_ext: YANG_VERSION_KEYWORD\n  |  YIN_ELEMENT_KEYWORD\n  |  BIT_KEYWORD\n  |  ENUM_KEYWORD\n  |  AUGMENT_KEYWORD\n  |  DEVIATION_KEYWORD\n  |  DEVIATE_KEYWORD\n  |  EXTENSION_KEYWORD\n  |  FEATURE_KEYWORD\n  |  IDENTITY_KEYWORD\n  |  IMPORT_KEYWORD\n  |  INCLUDE_KEYWORD\n  |  SUBMODULE_EXT_KEYWORD\n\ndatadef_ext_stmt: action_stmt\n  |  anydata_stmt\n  |  anyxml_stmt\n  |  case_stmt\n  |  choice_stmt\n  |  container_stmt\n  |  grouping_stmt\n  |  input_stmt\n  |  leaf_stmt\n  |  leaf_list_stmt\n  |  list_stmt\n  |  notification_stmt\n  |  output_stmt\n  |  uses_stmt\n\nrestriction_ext_stmt: must_stmt\n  |  pattern_stmt\n  |  range_stmt\n  |  length_stmt\n\next_substatements: @EMPTYDIR@ { actual_type = EXTENSION_INSTANCE;\n                                actual = ext_instance;\n                                if (!is_ext_instance) {\n                                  LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n                                  YYABORT;\n                                }\n                                $$ = 0;\n                              }\n  |  ext_substatements belongs_to_stmt stmtsep\n  |  ext_substatements prefix_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", ext_name, &s,\n                                                                  0, LY_STMT_PREFIX)) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements description_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"description\", ext_name, &s,\n                                                                       0, LY_STMT_DESCRIPTION)) {\n                                            YYABORT;\n                                          }\n                                        }\n  |  ext_substatements reference_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"reference\", ext_name, &s,\n                                                                     0, LY_STMT_REFERENCE)) {\n                                          YYABORT;\n                                        }\n                                      }\n  |  ext_substatements units_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"units\", ext_name, &s,\n                                                                     0, LY_STMT_UNITS)) {\n                                      YYABORT;\n                                    }\n                                  }\n  |  ext_substatements base_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"base\", ext_name, &s,\n                                                                0, LY_STMT_BASE)) {\n                                     YYABORT;\n                                   }\n                                 }\n  |  ext_substatements contact_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"contact\", ext_name, &s,\n                                                                     0, LY_STMT_CONTACT)) {\n                                        YYABORT;\n                                      }\n                                    }\n  |  ext_substatements default_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"default\", ext_name, &s,\n                                                                     0, LY_STMT_DEFAULT)) {\n                                        YYABORT;\n                                      }\n                                    }\n  |  ext_substatements error_message_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"error-message\", ext_name, &s,\n                                                                         0, LY_STMT_ERRMSG)) {\n                                              YYABORT;\n                                            }\n                                          }\n  |  ext_substatements error_app_tag_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"error-app-tag\", ext_name, &s,\n                                                                         0, LY_STMT_ERRTAG)) {\n                                              YYABORT;\n                                            }\n                                          }\n  |  ext_substatements key_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"key\", ext_name, &s,\n                                                               0, LY_STMT_KEY)) {\n                                    YYABORT;\n                                  }\n                                }\n  |  ext_substatements namespace_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"namespace\", ext_name, &s,\n                                                                     0, LY_STMT_NAMESPACE)) {\n                                          YYABORT;\n                                        }\n                                      }\n  |  ext_substatements organization_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"organization\", ext_name, &s,\n                                                                        0, LY_STMT_ORGANIZATION)) {\n                                             YYABORT;\n                                           }\n                                         }\n  |  ext_substatements path_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"path\", ext_name, &s,\n                                                                0, LY_STMT_PATH)) {\n                                     YYABORT;\n                                   }\n                                 }\n  |  ext_substatements presence_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"presence\", ext_name, &s,\n                                                                    0, LY_STMT_PRESENCE)) {\n                                         YYABORT;\n                                       }\n                                     }\n  |  ext_substatements revision_date_stmt { if (yang_read_extcomplex_str(trg, ext_instance, \"revision-date\", ext_name, &s,\n                                                                         0, LY_STMT_REVISIONDATE)) {\n                                              YYABORT;\n                                            }\n                                          }\n  |  ext_substatements type_ext_alloc type_stmt stmtsep\n     { struct lys_type *type = $2;\n\n       if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {\n         yang_type_free(trg->ctx, type);\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n  |  ext_substatements typedef_ext_alloc typedef_stmt stmtsep\n     { struct lys_tpdf *tpdf = $2;\n\n       if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {\n         yang_type_free(trg->ctx, &tpdf->type);\n       }\n       if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {\n         YYABORT;\n       }\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {\n         yang_type_free(trg->ctx, &tpdf->type);\n         YYABORT;\n       }\n       /* check default value*/\n       if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {\n         YYABORT;\n       }\n       actual = ext_instance;\n       is_ext_instance = 1;\n     }\n  |  ext_substatements status_stmt { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"status\", LY_STMT_STATUS,\n                                                                    $2, LYS_STATUS_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements config_stmt { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"config\", LY_STMT_CONFIG,\n                                                                    $2, LYS_CONFIG_MASK)) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements mandatory_stmt { if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"mandatory\", LY_STMT_MANDATORY,\n                                                                       $2, LYS_MAND_MASK)) {\n                                          YYABORT;\n                                        }\n                                      }\n  |  ext_substatements ordered_by_stmt { if ($1 & LYS_ORDERED_MASK) {\n                                            LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"ordered by\", ext_name);\n                                            YYABORT;\n                                         }\n                                         if ($2 & LYS_USERORDERED) {\n                                           if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"ordered-by\", LY_STMT_ORDEREDBY,\n                                                                          $2, LYS_USERORDERED)) {\n                                             YYABORT;\n                                           }\n                                         }\n                                         $1 |= $2;\n                                         $$ = $1;\n                                       }\n  |  ext_substatements require_instance_stmt { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"require-instance\",\n                                                                              LY_STMT_REQINSTANCE, $2)) {\n                                                 YYABORT;\n                                               }\n                                             }\n  |  ext_substatements modifier_stmt { if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"modifier\", LY_STMT_MODIFIER, 0)) {\n                                         YYABORT;\n                                       }\n                                     }\n  |  ext_substatements fraction_digits_stmt\n     { /* range check */\n       if ($2 < 1 || $2 > 18) {\n         LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", $2, \"fraction-digits\");\n         YYABORT;\n       }\n       if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"fraction-digits\", LY_STMT_DIGITS, $2)) {\n         YYABORT;\n       }\n     }\n  |  ext_substatements min_elements_stmt { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"min-elements\", LY_STMT_MIN);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = $2;\n                                         }\n  |  ext_substatements max_elements_stmt { uint32_t **val;\n\n                                           val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                  \"max-elements\", LY_STMT_MAX);\n                                           if (!val) {\n                                             YYABORT;\n                                           }\n                                           /* store the value */\n                                           *val = malloc(sizeof(uint32_t));\n                                           if (!*val) {\n                                             LOGMEM(trg->ctx);\n                                             YYABORT;\n                                           }\n                                           **val = $2;\n                                         }\n  |  ext_substatements position_stmt { uint32_t **val;\n\n                                       val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                              \"position\", LY_STMT_POSITION);\n                                       if (!val) {\n                                         YYABORT;\n                                       }\n                                       /* store the value */\n                                       *val = malloc(sizeof(uint32_t));\n                                       if (!*val) {\n                                         LOGMEM(trg->ctx);\n                                         YYABORT;\n                                       }\n                                       **val = $2;\n                                     }\n  |  ext_substatements value_stmt { int32_t **val;\n\n                                    val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                          \"value\", LY_STMT_VALUE);\n                                    if (!val) {\n                                      YYABORT;\n                                    }\n                                    /* store the value */\n                                    *val = malloc(sizeof(int32_t));\n                                    if (!*val) {\n                                      LOGMEM(trg->ctx);\n                                      YYABORT;\n                                    }\n                                    **val = $2;\n                                  }\n  |  ext_substatements unique_stmt { struct lys_unique **unique;\n                                     int rc;\n\n                                     unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,\n                                                                                                        \"unique\", LY_STMT_UNIQUE);\n                                     if (!unique) {\n                                       YYABORT;\n                                     }\n                                     *unique = calloc(1, sizeof(struct lys_unique));\n                                     if (!*unique) {\n                                       LOGMEM(trg->ctx);\n                                       YYABORT;\n                                     }\n                                     rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);\n                                     free(s);\n                                     s = NULL;\n                                     if (rc) {\n                                       YYABORT;\n                                     }\n                                   }\n  |  ext_substatements iffeature_ext_alloc if_feature_stmt stmtsep\n     { struct lys_iffeature *iffeature;\n\n       iffeature = $2;\n       s = (char *)iffeature->features;\n       iffeature->features = NULL;\n       if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {\n         YYABORT;\n       }\n       if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {\n         YYABORT;\n       }\n       s = NULL;\n       actual = ext_instance;\n     }\n  |  ext_substatements argument_stmt stmtsep\n  |  ext_substatements restriction_ext_alloc restriction_ext_stmt stmtsep\n     { if (yang_check_ext_instance(trg, &((struct lys_restr *)$2)->ext, ((struct lys_restr *)$2)->ext_size, $2, param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n  |  ext_substatements when_ext_alloc when_stmt stmtsep\n     { if (yang_check_ext_instance(trg, &(*(struct lys_when **)$2)->ext, (*(struct lys_when **)$2)->ext_size,\n                                   *(struct lys_when **)$2, param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n  |  ext_substatements revision_ext_alloc revision_stmt stmtsep\n     { int i;\n\n       for (i = 0; i < $2.index; ++i) {\n         if (!strcmp($2.revision[i]->date, $2.revision[$2.index]->date)) {\n           LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\", $2.revision[i]->date);\n           break;\n         }\n       }\n       if (yang_check_ext_instance(trg, &$2.revision[$2.index]->ext, $2.revision[$2.index]->ext_size,\n                                   &$2.revision[$2.index], param->unres)) {\n         YYABORT;\n       }\n       actual = ext_instance;\n     }\n  |  ext_substatements datadef_ext_check datadef_ext_stmt stmtsep { actual = ext_instance;\n                                                                    is_ext_instance = 1;\n                                                                  }\n  |  ext_substatements not_supported_ext_check unknown_string unknown_statement3_opt_end\n\n%%\n\nvoid\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }\n}\n"], "filenames": ["src/parser_yang.c", "src/parser_yang.h", "src/parser_yang_bis.c", "src/yang.y.in"], "buggy_code_start_loc": [4766, 177, 3438, 616], "buggy_code_end_loc": [4866, 178, 8586, 4619], "fixing_code_start_loc": [4766, 177, 3438, 616], "fixing_code_end_loc": [4868, 178, 8586, 4619], "type": "CWE-415", "message": "A double-free is present in libyang before v1.0-r1 in the function yyparse() when an empty description is used. Applications that use libyang to parse untrusted input yang files may be vulnerable to this flaw, which would cause a crash or potentially code execution.", "other": {"cve": {"id": "CVE-2019-20393", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-22T22:15:10.237", "lastModified": "2020-01-23T21:19:00.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A double-free is present in libyang before v1.0-r1 in the function yyparse() when an empty description is used. Applications that use libyang to parse untrusted input yang files may be vulnerable to this flaw, which would cause a crash or potentially code execution."}, {"lang": "es", "value": "Una doble liberaci\u00f3n est\u00e1 presente en libyang versiones anteriores a v1.0-r1, en la funci\u00f3n yyparse() cuando es usada una descripci\u00f3n vac\u00eda. Las aplicaciones que usan libyang para analizar archivos de entrada yang no confiables pueden ser vulnerables a este fallo, lo que podr\u00eda causar un bloqueo o potencialmente una ejecuci\u00f3n de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r1:*:*:*:*:*:*", "matchCriteriaId": "65E91322-5F67-43C2-8112-5ECAEC2A3C12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r2:*:*:*:*:*:*", "matchCriteriaId": "80A88DE4-93F8-40C3-AA52-A5F353F028AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r1:*:*:*:*:*:*", "matchCriteriaId": "05C120CA-50EF-4B6D-92C9-ED736219DB07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r2:*:*:*:*:*:*", "matchCriteriaId": "99D1FA55-3F56-4E09-B41E-B05C199B96B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r1:*:*:*:*:*:*", "matchCriteriaId": "35D48EC4-58D2-49C6-8049-920787733587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r2:*:*:*:*:*:*", "matchCriteriaId": "B57F3953-49D6-413C-A4AE-03125935FC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.14:r1:*:*:*:*:*:*", "matchCriteriaId": "DD62411F-A524-4E80-B540-780EA39CB6A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.15:r1:*:*:*:*:*:*", "matchCriteriaId": "FEF091B1-978A-4881-B1FC-6848CD1A7BBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r1:*:*:*:*:*:*", "matchCriteriaId": "0C50D690-9A4D-4B78-BF4E-A4D9B4074216"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r2:*:*:*:*:*:*", "matchCriteriaId": "124A5D30-7451-4516-9AA2-963AE62DD679"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r3:*:*:*:*:*:*", "matchCriteriaId": "C260D13B-82E9-4596-9116-61073B42D661"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1793930", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/commit/d9feacc4a590d35dbc1af21caf9080008b4450ed", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/compare/v0.16-r3...v1.0-r1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/issues/742", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CESNET/libyang/commit/d9feacc4a590d35dbc1af21caf9080008b4450ed"}}