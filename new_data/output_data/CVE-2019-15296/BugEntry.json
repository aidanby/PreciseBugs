{"buggy_code": ["/*\n** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding\n** Copyright (C) 2003-2005 M. Bakker, Nero AG, http://www.nero.com\n**  \n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU General Public License as published by\n** the Free Software Foundation; either version 2 of the License, or\n** (at your option) any later version.\n** \n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n** \n** You should have received a copy of the GNU General Public License\n** along with this program; if not, write to the Free Software \n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n**\n** Any non-GPL usage of this software or parts of this software is strictly\n** forbidden.\n**\n** The \"appropriate copyright message\" mentioned in section 2c of the GPLv2\n** must read: \"Code from FAAD2 is copyright (c) Nero AG, www.nero.com\"\n**\n** Commercial non-GPL licensing of this software is possible.\n** For more info contact Nero AG through Mpeg4AAClicense@nero.com.\n**\n** $Id: bits.c,v 1.44 2007/11/01 12:33:29 menno Exp $\n**/\n\n#include \"common.h\"\n#include \"structs.h\"\n\n#include <stdlib.h>\n#include \"bits.h\"\n\n/* initialize buffer, call once before first getbits or showbits */\nvoid faad_initbits(bitfile *ld, const void *_buffer, const uint32_t buffer_size)\n{\n    uint32_t tmp;\n\n    if (ld == NULL)\n        return;\n\n    // useless\n    //memset(ld, 0, sizeof(bitfile));\n\n    if (buffer_size == 0 || _buffer == NULL)\n    {\n        ld->error = 1;\n        return;\n    }\n\n    ld->buffer = _buffer;\n\n    ld->buffer_size = buffer_size;\n    ld->bytes_left  = buffer_size;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)ld->buffer);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)ld->buffer, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)ld->buffer + 1);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)ld->buffer + 1, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->start = (uint32_t*)ld->buffer;\n    ld->tail = ((uint32_t*)ld->buffer + 2);\n\n    ld->bits_left = 32;\n\n    ld->error = 0;\n}\n\nvoid faad_endbits(bitfile *ld)\n{\n    // void\n}\n\nuint32_t faad_get_processed_bits(bitfile *ld)\n{\n    return (uint32_t)(8 * (4*(ld->tail - ld->start) - 4) - (ld->bits_left));\n}\n\nuint8_t faad_byte_align(bitfile *ld)\n{\n    int remainder = (32 - ld->bits_left) & 0x7;\n\n    if (remainder)\n    {\n        faad_flushbits(ld, 8 - remainder);\n        return (uint8_t)(8 - remainder);\n    }\n    return 0;\n}\n\nvoid faad_flushbits_ex(bitfile *ld, uint32_t bits)\n{\n    uint32_t tmp;\n\n    ld->bufa = ld->bufb;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(ld->tail);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(ld->tail, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->tail++;\n    ld->bits_left += (32 - bits);\n    //ld->bytes_left -= 4;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}\n\n/* rewind to beginning */\nvoid faad_rewindbits(bitfile *ld)\n{\n    uint32_t tmp;\n\n    ld->bytes_left = ld->buffer_size;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)&ld->start[0]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)&ld->start[0], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)&ld->start[1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)&ld->start[1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32;\n    ld->tail = &ld->start[2];\n}\n\n/* reset to a certain point */\nvoid faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}\n\nuint8_t *faad_getbitbuffer(bitfile *ld, uint32_t bits\n                       DEBUGDEC)\n{\n    int i;\n    unsigned int temp;\n    int bytes = bits >> 3;\n    int remainder = bits & 0x7;\n\n    uint8_t *buffer = (uint8_t*)faad_malloc((bytes+1)*sizeof(uint8_t));\n\n    for (i = 0; i < bytes; i++)\n    {\n        buffer[i] = (uint8_t)faad_getbits(ld, 8 DEBUGVAR(print,var,dbg));\n    }\n\n    if (remainder)\n    {\n        temp = faad_getbits(ld, remainder DEBUGVAR(print,var,dbg)) << (8-remainder);\n\n        buffer[bytes] = (uint8_t)temp;\n    }\n\n    return buffer;\n}\n\n#ifdef DRM\n/* return the original data buffer */\nvoid *faad_origbitbuffer(bitfile *ld)\n{\n    return (void*)ld->start;\n}\n\n/* return the original data buffer size */\nuint32_t faad_origbitbuffer_size(bitfile *ld)\n{\n    return ld->buffer_size;\n}\n#endif\n\n/* reversed bit reading routines, used for RVLC and HCR */\nvoid faad_initbits_rev(bitfile *ld, void *buffer,\n                       uint32_t bits_in_buffer)\n{\n    uint32_t tmp;\n    int32_t index;\n\n    ld->buffer_size = bit2byte(bits_in_buffer);\n\n    index = (bits_in_buffer+31)/32 - 1;\n\n    ld->start = (uint32_t*)buffer + index - 2;\n\n    tmp = getdword((uint32_t*)buffer + index);\n    ld->bufa = tmp;\n\n    tmp = getdword((uint32_t*)buffer + index - 1);\n    ld->bufb = tmp;\n\n    ld->tail = (uint32_t*)buffer + index;\n\n    ld->bits_left = bits_in_buffer % 32;\n    if (ld->bits_left == 0)\n        ld->bits_left = 32;\n\n    ld->bytes_left = ld->buffer_size;\n    ld->error = 0;\n}\n\n/* EOF */\n", "/*\n** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding\n** Copyright (C) 2003-2005 M. Bakker, Nero AG, http://www.nero.com\n**  \n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU General Public License as published by\n** the Free Software Foundation; either version 2 of the License, or\n** (at your option) any later version.\n** \n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n** \n** You should have received a copy of the GNU General Public License\n** along with this program; if not, write to the Free Software \n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n**\n** Any non-GPL usage of this software or parts of this software is strictly\n** forbidden.\n**\n** The \"appropriate copyright message\" mentioned in section 2c of the GPLv2\n** must read: \"Code from FAAD2 is copyright (c) Nero AG, www.nero.com\"\n**\n** Commercial non-GPL licensing of this software is possible.\n** For more info contact Nero AG through Mpeg4AAClicense@nero.com.\n**\n** $Id: syntax.c,v 1.93 2009/01/26 23:51:15 menno Exp $\n**/\n\n/*\n   Reads the AAC bitstream as defined in 14496-3 (MPEG-4 Audio)\n*/\n\n#include \"common.h\"\n#include \"structs.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"syntax.h\"\n#include \"specrec.h\"\n#include \"huffman.h\"\n#include \"bits.h\"\n#include \"pulse.h\"\n#include \"analysis.h\"\n#include \"drc.h\"\n#ifdef ERROR_RESILIENCE\n#include \"rvlc.h\"\n#endif\n#ifdef SBR_DEC\n#include \"sbr_syntax.h\"\n#endif\n#include \"mp4.h\"\n\n\n/* static function declarations */\nstatic void decode_sce_lfe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele);\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele);\nstatic uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                          uint8_t channel, uint8_t *tag);\nstatic uint8_t channel_pair_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                    uint8_t channel, uint8_t *tag);\n#ifdef COUPLING_DEC\nstatic uint8_t coupling_channel_element(NeAACDecStruct *hDecoder, bitfile *ld);\n#endif\nstatic uint16_t data_stream_element(NeAACDecStruct *hDecoder, bitfile *ld);\nstatic uint8_t program_config_element(program_config *pce, bitfile *ld);\nstatic uint8_t fill_element(NeAACDecStruct *hDecoder, bitfile *ld, drc_info *drc\n#ifdef SBR_DEC\n                            ,uint8_t sbr_ele\n#endif\n                            );\nstatic uint8_t individual_channel_stream(NeAACDecStruct *hDecoder, element *ele,\n                                         bitfile *ld, ic_stream *ics, uint8_t scal_flag,\n                                         int16_t *spec_data);\nstatic uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                        uint8_t common_window);\nstatic uint8_t section_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld);\nstatic uint8_t scale_factor_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld);\n#ifdef SSR_DEC\nstatic void gain_control_data(bitfile *ld, ic_stream *ics);\n#endif\nstatic uint8_t spectral_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                             int16_t *spectral_data);\nstatic uint16_t extension_payload(bitfile *ld, drc_info *drc, uint16_t count);\nstatic uint8_t pulse_data(ic_stream *ics, pulse_info *pul, bitfile *ld);\nstatic void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld);\n#ifdef LTP_DEC\nstatic uint8_t ltp_data(NeAACDecStruct *hDecoder, ic_stream *ics, ltp_info *ltp, bitfile *ld);\n#endif\nstatic uint8_t adts_fixed_header(adts_header *adts, bitfile *ld);\nstatic void adts_variable_header(adts_header *adts, bitfile *ld);\nstatic void adts_error_check(adts_header *adts, bitfile *ld);\nstatic uint8_t dynamic_range_info(bitfile *ld, drc_info *drc);\nstatic uint8_t excluded_channels(bitfile *ld, drc_info *drc);\nstatic uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,\n                         bitfile *ld, ic_stream *ics, uint8_t scal_flag);\n#ifdef DRM\nstatic int8_t DRM_aac_scalable_main_header(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                           bitfile *ld, uint8_t this_layer_stereo);\n#endif\n\n\n/* Table 4.4.1 */\nint8_t GASpecificConfig(bitfile *ld, mp4AudioSpecificConfig *mp4ASC,\n                        program_config *pce_out)\n{\n    program_config pce;\n\n    /* 1024 or 960 */\n    mp4ASC->frameLengthFlag = faad_get1bit(ld\n        DEBUGVAR(1,138,\"GASpecificConfig(): FrameLengthFlag\"));\n#ifndef ALLOW_SMALL_FRAMELENGTH\n    if (mp4ASC->frameLengthFlag == 1)\n        return -3;\n#endif\n\n    mp4ASC->dependsOnCoreCoder = faad_get1bit(ld\n        DEBUGVAR(1,139,\"GASpecificConfig(): DependsOnCoreCoder\"));\n    if (mp4ASC->dependsOnCoreCoder == 1)\n    {\n        mp4ASC->coreCoderDelay = (uint16_t)faad_getbits(ld, 14\n            DEBUGVAR(1,140,\"GASpecificConfig(): CoreCoderDelay\"));\n    }\n\n    mp4ASC->extensionFlag = faad_get1bit(ld DEBUGVAR(1,141,\"GASpecificConfig(): ExtensionFlag\"));\n    if (mp4ASC->channelsConfiguration == 0)\n    {\n        if (program_config_element(&pce, ld))\n            return -3;\n        //mp4ASC->channelsConfiguration = pce.channels;\n\n        if (pce_out != NULL)\n            memcpy(pce_out, &pce, sizeof(program_config));\n\n        /*\n        if (pce.num_valid_cc_elements)\n            return -3;\n        */\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (mp4ASC->extensionFlag == 1)\n    {\n        /* Error resilience not supported yet */\n        if (mp4ASC->objectTypeIndex >= ER_OBJECT_START)\n        {\n            mp4ASC->aacSectionDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,144,\"GASpecificConfig(): aacSectionDataResilienceFlag\"));\n            mp4ASC->aacScalefactorDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,145,\"GASpecificConfig(): aacScalefactorDataResilienceFlag\"));\n            mp4ASC->aacSpectralDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,146,\"GASpecificConfig(): aacSpectralDataResilienceFlag\"));\n        }\n        /* 1 bit: extensionFlag3 */\n        faad_getbits(ld, 1);\n\t}\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.2 */\n/* An MPEG-4 Audio decoder is only required to follow the Program\n   Configuration Element in GASpecificConfig(). The decoder shall ignore\n   any Program Configuration Elements that may occur in raw data blocks.\n   PCEs transmitted in raw data blocks cannot be used to convey decoder\n   configuration information.\n*/\nstatic uint8_t program_config_element(program_config *pce, bitfile *ld)\n{\n    uint8_t i;\n\n    memset(pce, 0, sizeof(program_config));\n\n    pce->channels = 0;\n\n    pce->element_instance_tag = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,10,\"program_config_element(): element_instance_tag\"));\n\n    pce->object_type = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,11,\"program_config_element(): object_type\"));\n    pce->sf_index = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,12,\"program_config_element(): sf_index\"));\n    pce->num_front_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,13,\"program_config_element(): num_front_channel_elements\"));\n    pce->num_side_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,14,\"program_config_element(): num_side_channel_elements\"));\n    pce->num_back_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,15,\"program_config_element(): num_back_channel_elements\"));\n    pce->num_lfe_channel_elements = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,16,\"program_config_element(): num_lfe_channel_elements\"));\n    pce->num_assoc_data_elements = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,17,\"program_config_element(): num_assoc_data_elements\"));\n    pce->num_valid_cc_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,18,\"program_config_element(): num_valid_cc_elements\"));\n\n    pce->mono_mixdown_present = faad_get1bit(ld\n        DEBUGVAR(1,19,\"program_config_element(): mono_mixdown_present\"));\n    if (pce->mono_mixdown_present == 1)\n    {\n        pce->mono_mixdown_element_number = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,20,\"program_config_element(): mono_mixdown_element_number\"));\n    }\n\n    pce->stereo_mixdown_present = faad_get1bit(ld\n        DEBUGVAR(1,21,\"program_config_element(): stereo_mixdown_present\"));\n    if (pce->stereo_mixdown_present == 1)\n    {\n        pce->stereo_mixdown_element_number = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,22,\"program_config_element(): stereo_mixdown_element_number\"));\n    }\n\n    pce->matrix_mixdown_idx_present = faad_get1bit(ld\n        DEBUGVAR(1,23,\"program_config_element(): matrix_mixdown_idx_present\"));\n    if (pce->matrix_mixdown_idx_present == 1)\n    {\n        pce->matrix_mixdown_idx = (uint8_t)faad_getbits(ld, 2\n            DEBUGVAR(1,24,\"program_config_element(): matrix_mixdown_idx\"));\n        pce->pseudo_surround_enable = faad_get1bit(ld\n            DEBUGVAR(1,25,\"program_config_element(): pseudo_surround_enable\"));\n    }\n\n    for (i = 0; i < pce->num_front_channel_elements; i++)\n    {\n        pce->front_element_is_cpe[i] = faad_get1bit(ld\n            DEBUGVAR(1,26,\"program_config_element(): front_element_is_cpe\"));\n        pce->front_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,27,\"program_config_element(): front_element_tag_select\"));\n\n        if (pce->front_element_is_cpe[i] & 1)\n        {\n            pce->cpe_channel[pce->front_element_tag_select[i]] = pce->channels;\n            pce->num_front_channels += 2;\n            pce->channels += 2;\n        } else {\n            pce->sce_channel[pce->front_element_tag_select[i]] = pce->channels;\n            pce->num_front_channels++;\n            pce->channels++;\n        }\n    }\n\n    for (i = 0; i < pce->num_side_channel_elements; i++)\n    {\n        pce->side_element_is_cpe[i] = faad_get1bit(ld\n            DEBUGVAR(1,28,\"program_config_element(): side_element_is_cpe\"));\n        pce->side_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,29,\"program_config_element(): side_element_tag_select\"));\n\n        if (pce->side_element_is_cpe[i] & 1)\n        {\n            pce->cpe_channel[pce->side_element_tag_select[i]] = pce->channels;\n            pce->num_side_channels += 2;\n            pce->channels += 2;\n        } else {\n            pce->sce_channel[pce->side_element_tag_select[i]] = pce->channels;\n            pce->num_side_channels++;\n            pce->channels++;\n        }\n    }\n\n    for (i = 0; i < pce->num_back_channel_elements; i++)\n    {\n        pce->back_element_is_cpe[i] = faad_get1bit(ld\n            DEBUGVAR(1,30,\"program_config_element(): back_element_is_cpe\"));\n        pce->back_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,31,\"program_config_element(): back_element_tag_select\"));\n\n        if (pce->back_element_is_cpe[i] & 1)\n        {\n            pce->cpe_channel[pce->back_element_tag_select[i]] = pce->channels;\n            pce->channels += 2;\n            pce->num_back_channels += 2;\n        } else {\n            pce->sce_channel[pce->back_element_tag_select[i]] = pce->channels;\n            pce->num_back_channels++;\n            pce->channels++;\n        }\n    }\n\n    for (i = 0; i < pce->num_lfe_channel_elements; i++)\n    {\n        pce->lfe_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,32,\"program_config_element(): lfe_element_tag_select\"));\n\n        pce->sce_channel[pce->lfe_element_tag_select[i]] = pce->channels;\n        pce->num_lfe_channels++;\n        pce->channels++;\n    }\n\n    for (i = 0; i < pce->num_assoc_data_elements; i++)\n        pce->assoc_data_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,33,\"program_config_element(): assoc_data_element_tag_select\"));\n\n    for (i = 0; i < pce->num_valid_cc_elements; i++)\n    {\n        pce->cc_element_is_ind_sw[i] = faad_get1bit(ld\n            DEBUGVAR(1,34,\"program_config_element(): cc_element_is_ind_sw\"));\n        pce->valid_cc_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,35,\"program_config_element(): valid_cc_element_tag_select\"));\n    }\n\n    faad_byte_align(ld);\n\n    pce->comment_field_bytes = (uint8_t)faad_getbits(ld, 8\n        DEBUGVAR(1,36,\"program_config_element(): comment_field_bytes\"));\n\n    for (i = 0; i < pce->comment_field_bytes; i++)\n    {\n        pce->comment_field_data[i] = (uint8_t)faad_getbits(ld, 8\n            DEBUGVAR(1,37,\"program_config_element(): comment_field_data\"));\n    }\n    pce->comment_field_data[i] = 0;\n\n    if (pce->channels > MAX_CHANNELS)\n        return 22;\n\n    return 0;\n}\n\nstatic void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}\n\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);\n\n    /* map output channel position to internal data channels */\n    if (hDecoder->pce_set)\n    {\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels;\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    }\n\n    hDecoder->fr_channels += 2;\n    hDecoder->fr_ch_ele++;\n}\n\nvoid raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}\n\n/* Table 4.4.4 and */\n/* Table 4.4.9 */\nstatic uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                          uint8_t channel, uint8_t *tag)\n{\n    uint8_t retval = 0;\n    element sce = {0};\n    ic_stream *ics = &(sce.ics1);\n    ALIGN int16_t spec_data[1024] = {0};\n\n    sce.element_instance_tag = (uint8_t)faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,38,\"single_lfe_channel_element(): element_instance_tag\"));\n\n    *tag = sce.element_instance_tag;\n    sce.channel = channel;\n    sce.paired_channel = -1;\n\n    retval = individual_channel_stream(hDecoder, &sce, ld, ics, 0, spec_data);\n    if (retval > 0)\n        return retval;\n\n    /* IS not allowed in single channel */\n    if (ics->is_used)\n        return 32;\n\n#ifdef SBR_DEC\n    /* check if next bitstream element is a fill element */\n    /* if so, read it now so SBR decoding can be done in case of a file with SBR */\n    if (faad_showbits(ld, LEN_SE_ID) == ID_FIL)\n    {\n        faad_flushbits(ld, LEN_SE_ID);\n\n        /* one sbr_info describes a channel_element not a channel! */\n        if ((retval = fill_element(hDecoder, ld, hDecoder->drc, hDecoder->fr_ch_ele)) > 0)\n        {\n            return retval;\n        }\n    }\n#endif\n\n    /* noiseless coding is done, spectral reconstruction is done now */\n    retval = reconstruct_single_channel(hDecoder, ics, &sce, spec_data);\n    if (retval > 0)\n        return retval;\n\n    return 0;\n}\n\n/* Table 4.4.5 */\nstatic uint8_t channel_pair_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                    uint8_t channels, uint8_t *tag)\n{\n    ALIGN int16_t spec_data1[1024] = {0};\n    ALIGN int16_t spec_data2[1024] = {0};\n    element cpe = {0};\n    ic_stream *ics1 = &(cpe.ics1);\n    ic_stream *ics2 = &(cpe.ics2);\n    uint8_t result;\n\n    cpe.channel        = channels;\n    cpe.paired_channel = channels+1;\n\n    cpe.element_instance_tag = (uint8_t)faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,39,\"channel_pair_element(): element_instance_tag\"));\n    *tag = cpe.element_instance_tag;\n\n    if ((cpe.common_window = faad_get1bit(ld\n        DEBUGVAR(1,40,\"channel_pair_element(): common_window\"))) & 1)\n    {\n        /* both channels have common ics information */\n        if ((result = ics_info(hDecoder, ics1, ld, cpe.common_window)) > 0)\n            return result;\n\n        ics1->ms_mask_present = (uint8_t)faad_getbits(ld, 2\n            DEBUGVAR(1,41,\"channel_pair_element(): ms_mask_present\"));\n        if (ics1->ms_mask_present == 3)\n        {\n            /* bitstream error */\n            return 32;\n        }\n        if (ics1->ms_mask_present == 1)\n        {\n            uint8_t g, sfb;\n            for (g = 0; g < ics1->num_window_groups; g++)\n            {\n                for (sfb = 0; sfb < ics1->max_sfb; sfb++)\n                {\n                    ics1->ms_used[g][sfb] = faad_get1bit(ld\n                        DEBUGVAR(1,42,\"channel_pair_element(): faad_get1bit\"));\n                }\n            }\n        }\n\n#ifdef ERROR_RESILIENCE\n        if ((hDecoder->object_type >= ER_OBJECT_START) && (ics1->predictor_data_present))\n        {\n            if ((\n#ifdef LTP_DEC\n                ics1->ltp.data_present =\n#endif\n                faad_get1bit(ld DEBUGVAR(1,50,\"channel_pair_element(): ltp.data_present\"))) & 1)\n            {\n#ifdef LTP_DEC\n                if ((result = ltp_data(hDecoder, ics1, &(ics1->ltp), ld)) > 0)\n                {\n                    return result;\n                }\n#else\n                return 26;\n#endif\n            }\n        }\n#endif\n\n        memcpy(ics2, ics1, sizeof(ic_stream));\n    } else {\n        ics1->ms_mask_present = 0;\n    }\n\n    if ((result = individual_channel_stream(hDecoder, &cpe, ld, ics1,\n        0, spec_data1)) > 0)\n    {\n        return result;\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (cpe.common_window && (hDecoder->object_type >= ER_OBJECT_START) &&\n        (ics1->predictor_data_present))\n    {\n        if ((\n#ifdef LTP_DEC\n            ics1->ltp2.data_present =\n#endif\n            faad_get1bit(ld DEBUGVAR(1,50,\"channel_pair_element(): ltp.data_present\"))) & 1)\n        {\n#ifdef LTP_DEC\n            if ((result = ltp_data(hDecoder, ics1, &(ics1->ltp2), ld)) > 0)\n            {\n                return result;\n            }\n#else\n            return 26;\n#endif\n        }\n    }\n#endif\n\n    if ((result = individual_channel_stream(hDecoder, &cpe, ld, ics2,\n        0, spec_data2)) > 0)\n    {\n        return result;\n    }\n\n#ifdef SBR_DEC\n    /* check if next bitstream element is a fill element */\n    /* if so, read it now so SBR decoding can be done in case of a file with SBR */\n    if (faad_showbits(ld, LEN_SE_ID) == ID_FIL)\n    {\n        faad_flushbits(ld, LEN_SE_ID);\n\n        /* one sbr_info describes a channel_element not a channel! */\n        if ((result = fill_element(hDecoder, ld, hDecoder->drc, hDecoder->fr_ch_ele)) > 0)\n        {\n            return result;\n        }\n    }\n#endif\n\n    /* noiseless coding is done, spectral reconstruction is done now */\n    if ((result = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe,\n        spec_data1, spec_data2)) > 0)\n    {\n        return result;\n    }\n\n    return 0;\n}\n\n/* Table 4.4.6 */\nstatic uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                        uint8_t common_window)\n{\n    uint8_t retval = 0;\n    uint8_t ics_reserved_bit;\n\n    ics_reserved_bit = faad_get1bit(ld\n        DEBUGVAR(1,43,\"ics_info(): ics_reserved_bit\"));\n    if (ics_reserved_bit != 0)\n        return 32;\n    ics->window_sequence = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,44,\"ics_info(): window_sequence\"));\n    ics->window_shape = faad_get1bit(ld\n        DEBUGVAR(1,45,\"ics_info(): window_shape\"));\n\n#ifdef LD_DEC\n    /* No block switching in LD */\n    if ((hDecoder->object_type == LD) && (ics->window_sequence != ONLY_LONG_SEQUENCE))\n        return 32;\n#endif\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,46,\"ics_info(): max_sfb (short)\"));\n        ics->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,47,\"ics_info(): scale_factor_grouping\"));\n    } else {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,48,\"ics_info(): max_sfb (long)\"));\n    }\n\n    /* get the grouping information */\n    if ((retval = window_grouping_info(hDecoder, ics)) > 0)\n        return retval;\n\n\n    /* should be an error */\n    /* check the range of max_sfb */\n    if (ics->max_sfb > ics->num_swb)\n        return 16;\n\n    if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)\n    {\n        if ((ics->predictor_data_present = faad_get1bit(ld\n            DEBUGVAR(1,49,\"ics_info(): predictor_data_present\"))) & 1)\n        {\n            if (hDecoder->object_type == MAIN) /* MPEG2 style AAC predictor */\n            {\n                uint8_t sfb;\n\n                uint8_t limit = min(ics->max_sfb, max_pred_sfb(hDecoder->sf_index));\n#ifdef MAIN_DEC\n                ics->pred.limit = limit;\n#endif\n\n                if ((\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset =\n#endif\n                    faad_get1bit(ld DEBUGVAR(1,53,\"ics_info(): pred.predictor_reset\"))) & 1)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset_group_number =\n#endif\n                        (uint8_t)faad_getbits(ld, 5 DEBUGVAR(1,54,\"ics_info(): pred.predictor_reset_group_number\"));\n                }\n\n                for (sfb = 0; sfb < limit; sfb++)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.prediction_used[sfb] =\n#endif\n                        faad_get1bit(ld DEBUGVAR(1,55,\"ics_info(): pred.prediction_used\"));\n                }\n            }\n#ifdef LTP_DEC\n            else { /* Long Term Prediction */\n                if (hDecoder->object_type < ER_OBJECT_START)\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)\n                        {\n                            return retval;\n                        }\n                    }\n                    if (common_window)\n                    {\n                        if ((ics->ltp2.data_present = faad_get1bit(ld\n                            DEBUGVAR(1,51,\"ics_info(): ltp2.data_present\"))) & 1)\n                        {\n                            if ((retval = ltp_data(hDecoder, ics, &(ics->ltp2), ld)) > 0)\n                            {\n                                return retval;\n                            }\n                        }\n                    }\n                }\n#ifdef ERROR_RESILIENCE\n                if (!common_window && (hDecoder->object_type >= ER_OBJECT_START))\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        ltp_data(hDecoder, ics, &(ics->ltp), ld);\n                    }\n                }\n#endif\n            }\n#endif\n        }\n    }\n\n    return retval;\n}\n\n/* Table 4.4.7 */\nstatic uint8_t pulse_data(ic_stream *ics, pulse_info *pul, bitfile *ld)\n{\n    uint8_t i;\n\n    pul->number_pulse = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,56,\"pulse_data(): number_pulse\"));\n    pul->pulse_start_sfb = (uint8_t)faad_getbits(ld, 6\n        DEBUGVAR(1,57,\"pulse_data(): pulse_start_sfb\"));\n\n    /* check the range of pulse_start_sfb */\n    if (pul->pulse_start_sfb > ics->num_swb)\n        return 16;\n\n    for (i = 0; i < pul->number_pulse+1; i++)\n    {\n        pul->pulse_offset[i] = (uint8_t)faad_getbits(ld, 5\n            DEBUGVAR(1,58,\"pulse_data(): pulse_offset\"));\n#if 0\n        printf(\"%d\\n\", pul->pulse_offset[i]);\n#endif\n        pul->pulse_amp[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,59,\"pulse_data(): pulse_amp\"));\n#if 0\n        printf(\"%d\\n\", pul->pulse_amp[i]);\n#endif\n    }\n\n    return 0;\n}\n\n#ifdef COUPLING_DEC\n/* Table 4.4.8: Currently just for skipping the bits... */\nstatic uint8_t coupling_channel_element(NeAACDecStruct *hDecoder, bitfile *ld)\n{\n    uint8_t c, result = 0;\n    uint8_t ind_sw_cce_flag = 0;\n    uint8_t num_gain_element_lists = 0;\n    uint8_t num_coupled_elements = 0;\n\n    element el_empty = {0};\n    ic_stream ics_empty = {0};\n    int16_t sh_data[1024];\n\n    c = faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,900,\"coupling_channel_element(): element_instance_tag\"));\n\n    ind_sw_cce_flag = faad_get1bit(ld\n        DEBUGVAR(1,901,\"coupling_channel_element(): ind_sw_cce_flag\"));\n    num_coupled_elements = faad_getbits(ld, 3\n        DEBUGVAR(1,902,\"coupling_channel_element(): num_coupled_elements\"));\n\n    for (c = 0; c < num_coupled_elements + 1; c++)\n    {\n        uint8_t cc_target_is_cpe, cc_target_tag_select;\n\n        num_gain_element_lists++;\n\n        cc_target_is_cpe = faad_get1bit(ld\n            DEBUGVAR(1,903,\"coupling_channel_element(): cc_target_is_cpe\"));\n        cc_target_tag_select = faad_getbits(ld, 4\n            DEBUGVAR(1,904,\"coupling_channel_element(): cc_target_tag_select\"));\n\n        if (cc_target_is_cpe)\n        {\n            uint8_t cc_l = faad_get1bit(ld\n                DEBUGVAR(1,905,\"coupling_channel_element(): cc_l\"));\n            uint8_t cc_r = faad_get1bit(ld\n                DEBUGVAR(1,906,\"coupling_channel_element(): cc_r\"));\n\n            if (cc_l && cc_r)\n                num_gain_element_lists++;\n        }\n    }\n\n    faad_get1bit(ld\n        DEBUGVAR(1,907,\"coupling_channel_element(): cc_domain\"));\n    faad_get1bit(ld\n        DEBUGVAR(1,908,\"coupling_channel_element(): gain_element_sign\"));\n    faad_getbits(ld, 2\n        DEBUGVAR(1,909,\"coupling_channel_element(): gain_element_scale\"));\n\n    if ((result = individual_channel_stream(hDecoder, &el_empty, ld, &ics_empty,\n        0, sh_data)) > 0)\n    {\n        return result;\n    }\n\n    /* IS not allowed in single channel */\n    if (ics->is_used)\n        return 32;\n\n    for (c = 1; c < num_gain_element_lists; c++)\n    {\n        uint8_t cge;\n\n        if (ind_sw_cce_flag)\n        {\n            cge = 1;\n        } else {\n            cge = faad_get1bit(ld\n                DEBUGVAR(1,910,\"coupling_channel_element(): common_gain_element_present\"));\n        }\n\n        if (cge)\n        {\n            huffman_scale_factor(ld);\n        } else {\n            uint8_t g, sfb;\n\n            for (g = 0; g < ics_empty.num_window_groups; g++)\n            {\n                for (sfb = 0; sfb < ics_empty.max_sfb; sfb++)\n                {\n                    if (ics_empty.sfb_cb[g][sfb] != ZERO_HCB)\n                        huffman_scale_factor(ld);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n#endif\n\n/* Table 4.4.10 */\nstatic uint16_t data_stream_element(NeAACDecStruct *hDecoder, bitfile *ld)\n{\n    uint8_t byte_aligned;\n    uint16_t i, count;\n\n    /* element_instance_tag = */ faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,60,\"data_stream_element(): element_instance_tag\"));\n    byte_aligned = faad_get1bit(ld\n        DEBUGVAR(1,61,\"data_stream_element(): byte_aligned\"));\n    count = (uint16_t)faad_getbits(ld, 8\n        DEBUGVAR(1,62,\"data_stream_element(): count\"));\n    if (count == 255)\n    {\n        count += (uint16_t)faad_getbits(ld, 8\n            DEBUGVAR(1,63,\"data_stream_element(): extra count\"));\n    }\n    if (byte_aligned)\n        faad_byte_align(ld);\n\n    for (i = 0; i < count; i++)\n    {\n        faad_getbits(ld, LEN_BYTE\n            DEBUGVAR(1,64,\"data_stream_element(): data_stream_byte\"));\n    }\n\n    return count;\n}\n\n/* Table 4.4.11 */\nstatic uint8_t fill_element(NeAACDecStruct *hDecoder, bitfile *ld, drc_info *drc\n#ifdef SBR_DEC\n                            ,uint8_t sbr_ele\n#endif\n                            )\n{\n    uint16_t count;\n#ifdef SBR_DEC\n    uint8_t bs_extension_type;\n#endif\n\n    count = (uint16_t)faad_getbits(ld, 4\n        DEBUGVAR(1,65,\"fill_element(): count\"));\n    if (count == 15)\n    {\n        count += (uint16_t)faad_getbits(ld, 8\n            DEBUGVAR(1,66,\"fill_element(): extra count\")) - 1;\n    }\n\n    if (count > 0)\n    {\n#ifdef SBR_DEC\n        bs_extension_type = (uint8_t)faad_showbits(ld, 4);\n\n        if ((bs_extension_type == EXT_SBR_DATA) ||\n            (bs_extension_type == EXT_SBR_DATA_CRC))\n        {\n            if (sbr_ele == INVALID_SBR_ELEMENT)\n                return 24;\n\n            if (!hDecoder->sbr[sbr_ele])\n            {\n                hDecoder->sbr[sbr_ele] = sbrDecodeInit(hDecoder->frameLength,\n                    hDecoder->element_id[sbr_ele], 2*get_sample_rate(hDecoder->sf_index),\n                    hDecoder->downSampledSBR\n#ifdef DRM\n                    , 0\n#endif\n                    );\n            }\n\n            hDecoder->sbr_present_flag = 1;\n\n            /* parse the SBR data */\n            hDecoder->sbr[sbr_ele]->ret = sbr_extension_data(ld, hDecoder->sbr[sbr_ele], count,\n                hDecoder->postSeekResetFlag);\n\n#if 0\n            if (hDecoder->sbr[sbr_ele]->ret > 0)\n            {\n                printf(\"%s\\n\", NeAACDecGetErrorMessage(hDecoder->sbr[sbr_ele]->ret));\n            }\n#endif\n\n#if (defined(PS_DEC) || defined(DRM_PS))\n            if (hDecoder->sbr[sbr_ele]->ps_used)\n            {\n                hDecoder->ps_used[sbr_ele] = 1;\n\n                /* set element independent flag to 1 as well */\n                hDecoder->ps_used_global = 1;\n            }\n#endif\n        } else {\n#endif\n#ifndef DRM\n            while (count > 0)\n            {\n                count -= extension_payload(ld, drc, count);\n            }\n#else\n            return 30;\n#endif\n#ifdef SBR_DEC\n        }\n#endif\n    }\n\n    return 0;\n}\n\n/* Table 4.4.12 */\n#ifdef SSR_DEC\nstatic void gain_control_data(bitfile *ld, ic_stream *ics)\n{\n    uint8_t bd, wd, ad;\n    ssr_info *ssr = &(ics->ssr);\n\n    ssr->max_band = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,1000,\"gain_control_data(): max_band\"));\n\n    if (ics->window_sequence == ONLY_LONG_SEQUENCE)\n    {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 1; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n                    ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 5\n                        DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                }\n            }\n        }\n    } else if (ics->window_sequence == LONG_START_SEQUENCE) {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 2; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n                    if (wd == 0)\n                    {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    } else {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 2\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    }\n                }\n            }\n        }\n    } else if (ics->window_sequence == EIGHT_SHORT_SEQUENCE) {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 8; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n                    ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 2\n                        DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                }\n            }\n        }\n    } else if (ics->window_sequence == LONG_STOP_SEQUENCE) {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 2; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n\n                    if (wd == 0)\n                    {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    } else {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 5\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    }\n                }\n            }\n        }\n    }\n}\n#endif\n\n#ifdef DRM\n/* Table 4.4.13 ASME */\nvoid DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                                   bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t retval = 0;\n    uint8_t channels = hDecoder->fr_channels = 0;\n    uint8_t ch;\n    uint8_t this_layer_stereo = (hDecoder->channelConfiguration > 1) ? 1 : 0;\n    element cpe = {0};\n    ic_stream *ics1 = &(cpe.ics1);\n    ic_stream *ics2 = &(cpe.ics2);\n    int16_t *spec_data;\n    ALIGN int16_t spec_data1[1024] = {0};\n    ALIGN int16_t spec_data2[1024] = {0};\n\n    hDecoder->fr_ch_ele = 0;\n\n    hInfo->error = DRM_aac_scalable_main_header(hDecoder, ics1, ics2, ld, this_layer_stereo);\n    if (hInfo->error > 0)\n        return;\n\n    cpe.common_window = 1;\n    if (this_layer_stereo)\n    {\n        hDecoder->element_id[0] = ID_CPE;\n        if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else {\n        hDecoder->element_id[0] = ID_SCE;\n    }\n\n    if (this_layer_stereo)\n    {\n        cpe.channel        = 0;\n        cpe.paired_channel = 1;\n    }\n\n\n    /* Stereo2 / Mono1 */\n    ics1->tns_data_present = faad_get1bit(ld);\n\n#if defined(LTP_DEC)\n    ics1->ltp.data_present = faad_get1bit(ld);\n#elif defined (DRM)\n    if(faad_get1bit(ld)) {\n         hInfo->error = 26;\n         return;\n    }\n#else\n    faad_get1bit(ld);\n#endif    \n\n    hInfo->error = side_info(hDecoder, &cpe, ld, ics1, 1);\n    if (hInfo->error > 0)\n        return;\n    if (this_layer_stereo)\n    {\n        /* Stereo3 */\n        ics2->tns_data_present = faad_get1bit(ld);\n#ifdef LTP_DEC\n        ics1->ltp.data_present =\n#endif\n            faad_get1bit(ld);\n        hInfo->error = side_info(hDecoder, &cpe, ld, ics2, 1);\n        if (hInfo->error > 0)\n            return;\n    }\n    /* Stereo4 / Mono2 */\n    if (ics1->tns_data_present)\n        tns_data(ics1, &(ics1->tns), ld);\n    if (this_layer_stereo)\n    {\n        /* Stereo5 */\n        if (ics2->tns_data_present)\n            tns_data(ics2, &(ics2->tns), ld);\n    }\n\n#ifdef DRM\n    /* CRC check */\n    if (hDecoder->object_type == DRM_ER_LC)\n    {\n        if ((hInfo->error = (uint8_t)faad_check_CRC(ld, (uint16_t)faad_get_processed_bits(ld) - 8)) > 0)\n            return;\n    }\n#endif\n\n    /* Stereo6 / Mono3 */\n    /* error resilient spectral data decoding */\n    if ((hInfo->error = reordered_spectral_data(hDecoder, ics1, ld, spec_data1)) > 0)\n    {\n        return;\n    }\n    if (this_layer_stereo)\n    {\n        /* Stereo7 */\n        /* error resilient spectral data decoding */\n        if ((hInfo->error = reordered_spectral_data(hDecoder, ics2, ld, spec_data2)) > 0)\n        {\n            return;\n        }\n    }\n\n\n#ifdef DRM\n#ifdef SBR_DEC\n    /* In case of DRM we need to read the SBR info before channel reconstruction */\n    if ((hDecoder->sbr_present_flag == 1) && (hDecoder->object_type == DRM_ER_LC))\n    {\n        bitfile ld_sbr = {0};\n        uint32_t i;\n        uint16_t count = 0;\n        uint8_t *revbuffer;\n        uint8_t *prevbufstart;\n        uint8_t *pbufend;\n\n        /* all forward bitreading should be finished at this point */\n        uint32_t bitsconsumed = faad_get_processed_bits(ld);\n        uint32_t buffer_size = faad_origbitbuffer_size(ld);\n        uint8_t *buffer = (uint8_t*)faad_origbitbuffer(ld);\n\n        if (bitsconsumed + 8 > buffer_size*8)\n        {\n            hInfo->error = 14;\n            return;\n        }\n\n        if (!hDecoder->sbr[0])\n        {\n            hDecoder->sbr[0] = sbrDecodeInit(hDecoder->frameLength, hDecoder->element_id[0],\n                2*get_sample_rate(hDecoder->sf_index), 0 /* ds SBR */, 1);\n        }\n\n        /* Reverse bit reading of SBR data in DRM audio frame */\n        revbuffer = (uint8_t*)faad_malloc(buffer_size*sizeof(uint8_t));\n        prevbufstart = revbuffer;\n        pbufend = &buffer[buffer_size - 1];\n        for (i = 0; i < buffer_size; i++)\n            *prevbufstart++ = tabFlipbits[*pbufend--];\n\n        /* Set SBR data */\n        /* consider 8 bits from AAC-CRC */\n        /* SBR buffer size is original buffer size minus AAC buffer size */\n        count = (uint16_t)bit2byte(buffer_size*8 - bitsconsumed);\n        faad_initbits(&ld_sbr, revbuffer, count);\n\n        hDecoder->sbr[0]->sample_rate = get_sample_rate(hDecoder->sf_index);\n        hDecoder->sbr[0]->sample_rate *= 2;\n\n        faad_getbits(&ld_sbr, 8); /* Skip 8-bit CRC */\n\n        hDecoder->sbr[0]->ret = sbr_extension_data(&ld_sbr, hDecoder->sbr[0], count, hDecoder->postSeekResetFlag);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->sbr[0]->ps_used)\n        {\n            hDecoder->ps_used[0] = 1;\n            hDecoder->ps_used_global = 1;\n        }\n#endif\n\n        if (ld_sbr.error)\n        {\n            hDecoder->sbr[0]->ret = 1;\n        }\n\n        /* check CRC */\n        /* no need to check it if there was already an error */\n        if (hDecoder->sbr[0]->ret == 0)\n            hDecoder->sbr[0]->ret = (uint8_t)faad_check_CRC(&ld_sbr, (uint16_t)faad_get_processed_bits(&ld_sbr) - 8);\n\n        /* SBR data was corrupted, disable it until the next header */\n        if (hDecoder->sbr[0]->ret != 0)\n        {\n            hDecoder->sbr[0]->header_count = 0;\n        }\n\n        faad_endbits(&ld_sbr);\n\n        if (revbuffer)\n            faad_free(revbuffer);\n    }\n#endif\n#endif\n\n    if (this_layer_stereo)\n    {\n        hInfo->error = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe, spec_data1, spec_data2);\n        if (hInfo->error > 0)\n            return;\n    } else {\n        hInfo->error = reconstruct_single_channel(hDecoder, ics1, &cpe, spec_data1);\n        if (hInfo->error > 0)\n            return;\n    }\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n\n    return;\n}\n\n/* Table 4.4.15 */\nstatic int8_t DRM_aac_scalable_main_header(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                           bitfile *ld, uint8_t this_layer_stereo)\n{\n    uint8_t retval = 0;\n    uint8_t ch;\n    ic_stream *ics;\n    uint8_t ics_reserved_bit;\n\n    ics_reserved_bit = faad_get1bit(ld\n        DEBUGVAR(1,300,\"aac_scalable_main_header(): ics_reserved_bits\"));\n    if (ics_reserved_bit != 0)\n        return 32;\n    ics1->window_sequence = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,301,\"aac_scalable_main_header(): window_sequence\"));\n    ics1->window_shape = faad_get1bit(ld\n        DEBUGVAR(1,302,\"aac_scalable_main_header(): window_shape\"));\n\n    if (ics1->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        ics1->max_sfb = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,303,\"aac_scalable_main_header(): max_sfb (short)\"));\n        ics1->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,304,\"aac_scalable_main_header(): scale_factor_grouping\"));\n    } else {\n        ics1->max_sfb = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,305,\"aac_scalable_main_header(): max_sfb (long)\"));\n    }\n\n    /* get the grouping information */\n    if ((retval = window_grouping_info(hDecoder, ics1)) > 0)\n        return retval;\n\n    /* should be an error */\n    /* check the range of max_sfb */\n    if (ics1->max_sfb > ics1->num_swb)\n        return 16;\n\n    if (this_layer_stereo)\n    {\n        ics1->ms_mask_present = (uint8_t)faad_getbits(ld, 2\n            DEBUGVAR(1,306,\"aac_scalable_main_header(): ms_mask_present\"));\n        if (ics1->ms_mask_present == 3)\n        {\n            /* bitstream error */\n            return 32;\n        }\n        if (ics1->ms_mask_present == 1)\n        {\n            uint8_t g, sfb;\n            for (g = 0; g < ics1->num_window_groups; g++)\n            {\n                for (sfb = 0; sfb < ics1->max_sfb; sfb++)\n                {\n                    ics1->ms_used[g][sfb] = faad_get1bit(ld\n                        DEBUGVAR(1,307,\"aac_scalable_main_header(): faad_get1bit\"));\n                }\n            }\n        }\n\n        memcpy(ics2, ics1, sizeof(ic_stream));\n    } else {\n        ics1->ms_mask_present = 0;\n    }\n\n    return 0;\n}\n#endif\n\nstatic uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,\n                         bitfile *ld, ic_stream *ics, uint8_t scal_flag)\n{\n    uint8_t result;\n\n    ics->global_gain = (uint8_t)faad_getbits(ld, 8\n        DEBUGVAR(1,67,\"individual_channel_stream(): global_gain\"));\n\n    if (!ele->common_window && !scal_flag)\n    {\n        if ((result = ics_info(hDecoder, ics, ld, ele->common_window)) > 0)\n            return result;\n    }\n\n    if ((result = section_data(hDecoder, ics, ld)) > 0)\n        return result;\n\n    if ((result = scale_factor_data(hDecoder, ics, ld)) > 0)\n        return result;\n\n    if (!scal_flag)\n    {\n        /**\n         **  NOTE: It could be that pulse data is available in scalable AAC too,\n         **        as said in Amendment 1, this could be only the case for ER AAC,\n         **        though. (have to check this out later)\n         **/\n        /* get pulse data */\n        if ((ics->pulse_data_present = faad_get1bit(ld\n            DEBUGVAR(1,68,\"individual_channel_stream(): pulse_data_present\"))) & 1)\n        {\n            if ((result = pulse_data(ics, &(ics->pul), ld)) > 0)\n                return result;\n        }\n\n        /* get tns data */\n        if ((ics->tns_data_present = faad_get1bit(ld\n            DEBUGVAR(1,69,\"individual_channel_stream(): tns_data_present\"))) & 1)\n        {\n#ifdef ERROR_RESILIENCE\n            if (hDecoder->object_type < ER_OBJECT_START)\n#endif\n                tns_data(ics, &(ics->tns), ld);\n        }\n\n        /* get gain control data */\n        if ((ics->gain_control_data_present = faad_get1bit(ld\n            DEBUGVAR(1,70,\"individual_channel_stream(): gain_control_data_present\"))) & 1)\n        {\n#ifdef SSR_DEC\n            if (hDecoder->object_type != SSR)\n                return 1;\n            else\n                gain_control_data(ld, ics);\n#else\n            return 1;\n#endif\n        }\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->aacSpectralDataResilienceFlag)\n    {\n        ics->length_of_reordered_spectral_data = (uint16_t)faad_getbits(ld, 14\n            DEBUGVAR(1,147,\"individual_channel_stream(): length_of_reordered_spectral_data\"));\n\n        if (hDecoder->channelConfiguration == 2)\n        {\n            if (ics->length_of_reordered_spectral_data > 6144)\n                ics->length_of_reordered_spectral_data = 6144;\n        } else {\n            if (ics->length_of_reordered_spectral_data > 12288)\n                ics->length_of_reordered_spectral_data = 12288;\n        }\n\n        ics->length_of_longest_codeword = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,148,\"individual_channel_stream(): length_of_longest_codeword\"));\n        if (ics->length_of_longest_codeword >= 49)\n            ics->length_of_longest_codeword = 49;\n    }\n\n    /* RVLC spectral data is put here */\n    if (hDecoder->aacScalefactorDataResilienceFlag)\n    {\n        if ((result = rvlc_decode_scale_factors(ics, ld)) > 0)\n            return result;\n    }\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.24 */\nstatic uint8_t individual_channel_stream(NeAACDecStruct *hDecoder, element *ele,\n                                         bitfile *ld, ic_stream *ics, uint8_t scal_flag,\n                                         int16_t *spec_data)\n{\n    uint8_t result;\n\n    result = side_info(hDecoder, ele, ld, ics, scal_flag);\n    if (result > 0)\n        return result;\n\n    if (hDecoder->object_type >= ER_OBJECT_START) \n    {\n        if (ics->tns_data_present)\n            tns_data(ics, &(ics->tns), ld);\n    }\n\n#ifdef DRM\n    /* CRC check */\n    if (hDecoder->object_type == DRM_ER_LC)\n    {\n        if ((result = (uint8_t)faad_check_CRC(ld, (uint16_t)faad_get_processed_bits(ld) - 8)) > 0)\n            return result;\n    }\n#endif\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->aacSpectralDataResilienceFlag)\n    {\n        /* error resilient spectral data decoding */\n        if ((result = reordered_spectral_data(hDecoder, ics, ld, spec_data)) > 0)\n        {\n            return result;\n        }\n    } else {\n#endif\n        /* decode the spectral data */\n        if ((result = spectral_data(hDecoder, ics, ld, spec_data)) > 0)\n        {\n            return result;\n        }\n#ifdef ERROR_RESILIENCE\n    }\n#endif\n\n    /* pulse coding reconstruction */\n    if (ics->pulse_data_present)\n    {\n        if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)\n        {\n            if ((result = pulse_decode(ics, spec_data, hDecoder->frameLength)) > 0)\n                return result;\n        } else {\n            return 2; /* pulse coding not allowed for short blocks */\n        }\n    }\n\n    return 0;\n}\n\n/* Table 4.4.25 */\nstatic uint8_t section_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld)\n{\n    uint8_t g;\n    uint8_t sect_esc_val, sect_bits;\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n        sect_bits = 3;\n    else\n        sect_bits = 5;\n    sect_esc_val = (1<<sect_bits) - 1;\n\n#if 0\n    printf(\"\\ntotal sfb %d\\n\", ics->max_sfb);\n    printf(\"   sect    top     cb\\n\");\n#endif\n\n    for (g = 0; g < ics->num_window_groups; g++)\n    {\n        uint8_t k = 0;\n        uint8_t i = 0;\n\n        while (k < ics->max_sfb)\n        {\n#ifdef ERROR_RESILIENCE\n            uint8_t vcb11 = 0;\n#endif\n            uint8_t sfb;\n            uint8_t sect_len_incr;\n            uint16_t sect_len = 0;\n            uint8_t sect_cb_bits = 4;\n\n            /* if \"faad_getbits\" detects error and returns \"0\", \"k\" is never\n               incremented and we cannot leave the while loop */\n            if (ld->error != 0)\n                return 14;\n\n#ifdef ERROR_RESILIENCE\n            if (hDecoder->aacSectionDataResilienceFlag)\n                sect_cb_bits = 5;\n#endif\n\n            ics->sect_cb[g][i] = (uint8_t)faad_getbits(ld, sect_cb_bits\n                DEBUGVAR(1,71,\"section_data(): sect_cb\"));\n\n            if (ics->sect_cb[g][i] == 12)\n                return 32;\n\n#if 0\n            printf(\"%d\\n\", ics->sect_cb[g][i]);\n#endif\n\n#ifndef DRM\n            if (ics->sect_cb[g][i] == NOISE_HCB)\n                ics->noise_used = 1;\n#else\n            /* PNS not allowed in DRM */\n            if (ics->sect_cb[g][i] == NOISE_HCB)\n                return 29;\n#endif\n            if (ics->sect_cb[g][i] == INTENSITY_HCB2 || ics->sect_cb[g][i] == INTENSITY_HCB)\n                ics->is_used = 1;\n\n#ifdef ERROR_RESILIENCE\n            if (hDecoder->aacSectionDataResilienceFlag)\n            {\n                if ((ics->sect_cb[g][i] == 11) ||\n                    ((ics->sect_cb[g][i] >= 16) && (ics->sect_cb[g][i] <= 32)))\n                {\n                    vcb11 = 1;\n                }\n            }\n            if (vcb11)\n            {\n                sect_len_incr = 1;\n            } else {\n#endif\n                sect_len_incr = (uint8_t)faad_getbits(ld, sect_bits\n                    DEBUGVAR(1,72,\"section_data(): sect_len_incr\"));\n#ifdef ERROR_RESILIENCE\n            }\n#endif\n            while ((sect_len_incr == sect_esc_val) /* &&\n                (k+sect_len < ics->max_sfb)*/)\n            {\n                sect_len += sect_len_incr;\n                sect_len_incr = (uint8_t)faad_getbits(ld, sect_bits\n                    DEBUGVAR(1,72,\"section_data(): sect_len_incr\"));\n            }\n\n            sect_len += sect_len_incr;\n\n            ics->sect_start[g][i] = k;\n            ics->sect_end[g][i] = k + sect_len;\n\n#if 0\n            printf(\"%d\\n\", ics->sect_start[g][i]);\n#endif\n#if 0\n            printf(\"%d\\n\", ics->sect_end[g][i]);\n#endif\n\n            if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n            {\n                if (k + sect_len > 8*15)\n                    return 15;\n                if (i >= 8*15)\n                    return 15;\n            } else {\n                if (k + sect_len > MAX_SFB)\n                    return 15;\n                if (i >= MAX_SFB)\n                    return 15;\n            }\n\n            for (sfb = k; sfb < k + sect_len; sfb++)\n            {\n                ics->sfb_cb[g][sfb] = ics->sect_cb[g][i];\n#if 0\n                printf(\"%d\\n\", ics->sfb_cb[g][sfb]);\n#endif\n            }\n\n#if 0\n            printf(\" %6d %6d %6d\\n\",\n                i,\n                ics->sect_end[g][i],\n                ics->sect_cb[g][i]);\n#endif\n\n            k += sect_len;\n            i++;\n        }\n        ics->num_sec[g] = i;\n\n        /* the sum of all sect_len_incr elements for a given window\n         * group shall equal max_sfb */\n        if (k != ics->max_sfb)\n        {\n            return 32;\n        }\n#if 0\n        printf(\"%d\\n\", ics->num_sec[g]);\n#endif\n    }\n\n#if 0\n    printf(\"\\n\");\n#endif\n\n    return 0;\n}\n\n/*\n *  decode_scale_factors()\n *   decodes the scalefactors from the bitstream\n */\n/*\n * All scalefactors (and also the stereo positions and pns energies) are\n * transmitted using Huffman coded DPCM relative to the previous active\n * scalefactor (respectively previous stereo position or previous pns energy,\n * see subclause 4.6.2 and 4.6.3). The first active scalefactor is\n * differentially coded relative to the global gain.\n */\nstatic uint8_t decode_scale_factors(ic_stream *ics, bitfile *ld)\n{\n    uint8_t g, sfb;\n    int16_t t;\n    int8_t noise_pcm_flag = 1;\n\n    int16_t scale_factor = ics->global_gain;\n    int16_t is_position = 0;\n    int16_t noise_energy = ics->global_gain - 90;\n\n    for (g = 0; g < ics->num_window_groups; g++)\n    {\n        for (sfb = 0; sfb < ics->max_sfb; sfb++)\n        {\n            switch (ics->sfb_cb[g][sfb])\n            {\n            case ZERO_HCB: /* zero book */\n                ics->scale_factors[g][sfb] = 0;\n//#define SF_PRINT\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n                break;\n            case INTENSITY_HCB: /* intensity books */\n            case INTENSITY_HCB2:\n\n                /* decode intensity position */\n                t = huffman_scale_factor(ld);\n                is_position += (t - 60);\n                ics->scale_factors[g][sfb] = is_position;\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n\n                break;\n            case NOISE_HCB: /* noise books */\n\n#ifndef DRM\n                /* decode noise energy */\n                if (noise_pcm_flag)\n                {\n                    noise_pcm_flag = 0;\n                    t = (int16_t)faad_getbits(ld, 9\n                        DEBUGVAR(1,73,\"scale_factor_data(): first noise\")) - 256;\n                } else {\n                    t = huffman_scale_factor(ld);\n                    t -= 60;\n                }\n                noise_energy += t;\n                ics->scale_factors[g][sfb] = noise_energy;\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n#else\n                /* PNS not allowed in DRM */\n                return 29;\n#endif\n\n                break;\n            default: /* spectral books */\n\n                /* ics->scale_factors[g][sfb] must be between 0 and 255 */\n\n                ics->scale_factors[g][sfb] = 0;\n\n                /* decode scale factor */\n                t = huffman_scale_factor(ld);\n                scale_factor += (t - 60);\n                if (scale_factor < 0 || scale_factor > 255)\n                    return 4;\n                ics->scale_factors[g][sfb] = scale_factor;\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/* Table 4.4.26 */\nstatic uint8_t scale_factor_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld)\n{\n    uint8_t ret = 0;\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n#ifdef ERROR_RESILIENCE\n    if (!hDecoder->aacScalefactorDataResilienceFlag)\n    {\n#endif\n        ret = decode_scale_factors(ics, ld);\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* In ER AAC the parameters for RVLC are seperated from the actual\n           data that holds the scale_factors.\n           Strangely enough, 2 parameters for HCR are put inbetween them.\n        */\n        ret = rvlc_scale_factor_data(ics, ld);\n    }\n#endif\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->scalefac_cycles += count;\n#endif\n\n    return ret;\n}\n\n/* Table 4.4.27 */\nstatic void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld)\n{\n    uint8_t w, filt, i, start_coef_bits, coef_bits;\n    uint8_t n_filt_bits = 2;\n    uint8_t length_bits = 6;\n    uint8_t order_bits = 5;\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        n_filt_bits = 1;\n        length_bits = 4;\n        order_bits = 3;\n    }\n\n    for (w = 0; w < ics->num_windows; w++)\n    {\n        tns->n_filt[w] = (uint8_t)faad_getbits(ld, n_filt_bits\n            DEBUGVAR(1,74,\"tns_data(): n_filt\"));\n#if 0\n        printf(\"%d\\n\", tns->n_filt[w]);\n#endif\n\n        if (tns->n_filt[w])\n        {\n            if ((tns->coef_res[w] = faad_get1bit(ld\n                DEBUGVAR(1,75,\"tns_data(): coef_res\"))) & 1)\n            {\n                start_coef_bits = 4;\n            } else {\n                start_coef_bits = 3;\n            }\n#if 0\n            printf(\"%d\\n\", tns->coef_res[w]);\n#endif\n        }\n\n        for (filt = 0; filt < tns->n_filt[w]; filt++)\n        {\n            tns->length[w][filt] = (uint8_t)faad_getbits(ld, length_bits\n                DEBUGVAR(1,76,\"tns_data(): length\"));\n#if 0\n            printf(\"%d\\n\", tns->length[w][filt]);\n#endif\n            tns->order[w][filt]  = (uint8_t)faad_getbits(ld, order_bits\n                DEBUGVAR(1,77,\"tns_data(): order\"));\n#if 0\n            printf(\"%d\\n\", tns->order[w][filt]);\n#endif\n            if (tns->order[w][filt])\n            {\n                tns->direction[w][filt] = faad_get1bit(ld\n                    DEBUGVAR(1,78,\"tns_data(): direction\"));\n#if 0\n                printf(\"%d\\n\", tns->direction[w][filt]);\n#endif\n                tns->coef_compress[w][filt] = faad_get1bit(ld\n                    DEBUGVAR(1,79,\"tns_data(): coef_compress\"));\n#if 0\n                printf(\"%d\\n\", tns->coef_compress[w][filt]);\n#endif\n\n                coef_bits = start_coef_bits - tns->coef_compress[w][filt];\n                for (i = 0; i < tns->order[w][filt]; i++)\n                {\n                    tns->coef[w][filt][i] = (uint8_t)faad_getbits(ld, coef_bits\n                        DEBUGVAR(1,80,\"tns_data(): coef\"));\n#if 0\n                    printf(\"%d\\n\", tns->coef[w][filt][i]);\n#endif\n                }\n            }\n        }\n    }\n}\n\n#ifdef LTP_DEC\n/* Table 4.4.28 */\nstatic uint8_t ltp_data(NeAACDecStruct *hDecoder, ic_stream *ics, ltp_info *ltp, bitfile *ld)\n{\n    uint8_t sfb, w;\n\n    ltp->lag = 0;\n\n#ifdef LD_DEC\n    if (hDecoder->object_type == LD)\n    {\n        ltp->lag_update = (uint8_t)faad_getbits(ld, 1\n            DEBUGVAR(1,142,\"ltp_data(): lag_update\"));\n\n        if (ltp->lag_update)\n        {\n            ltp->lag = (uint16_t)faad_getbits(ld, 10\n                DEBUGVAR(1,81,\"ltp_data(): lag\"));\n        }\n    } else {\n#endif\n        ltp->lag = (uint16_t)faad_getbits(ld, 11\n            DEBUGVAR(1,81,\"ltp_data(): lag\"));\n#ifdef LD_DEC\n    }\n#endif\n\n    /* Check length of lag */\n    if (ltp->lag > (hDecoder->frameLength << 1))\n        return 18;\n\n    ltp->coef = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,82,\"ltp_data(): coef\"));\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        for (w = 0; w < ics->num_windows; w++)\n        {\n            if ((ltp->short_used[w] = faad_get1bit(ld\n                DEBUGVAR(1,83,\"ltp_data(): short_used\"))) & 1)\n            {\n                ltp->short_lag_present[w] = faad_get1bit(ld\n                    DEBUGVAR(1,84,\"ltp_data(): short_lag_present\"));\n                if (ltp->short_lag_present[w])\n                {\n                    ltp->short_lag[w] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,85,\"ltp_data(): short_lag\"));\n                }\n            }\n        }\n    } else {\n        ltp->last_band = (ics->max_sfb < MAX_LTP_SFB ? ics->max_sfb : MAX_LTP_SFB);\n\n        for (sfb = 0; sfb < ltp->last_band; sfb++)\n        {\n            ltp->long_used[sfb] = faad_get1bit(ld\n                DEBUGVAR(1,86,\"ltp_data(): long_used\"));\n        }\n    }\n\n    return 0;\n}\n#endif\n\n/* Table 4.4.29 */\nstatic uint8_t spectral_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                             int16_t *spectral_data)\n{\n    int8_t i;\n    uint8_t g;\n    uint16_t inc, k, p = 0;\n    uint8_t groups = 0;\n    uint8_t sect_cb;\n    uint8_t result;\n    uint16_t nshort = hDecoder->frameLength/8;\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n    for(g = 0; g < ics->num_window_groups; g++)\n    {\n        p = groups*nshort;\n\n        for (i = 0; i < ics->num_sec[g]; i++)\n        {\n            sect_cb = ics->sect_cb[g][i];\n\n            inc = (sect_cb >= FIRST_PAIR_HCB) ? 2 : 4;\n\n            switch (sect_cb)\n            {\n            case ZERO_HCB:\n            case NOISE_HCB:\n            case INTENSITY_HCB:\n            case INTENSITY_HCB2:\n//#define SD_PRINT\n#ifdef SD_PRINT\n                {\n                    int j;\n                    for (j = ics->sect_sfb_offset[g][ics->sect_start[g][i]]; j < ics->sect_sfb_offset[g][ics->sect_end[g][i]]; j++)\n                    {\n                        printf(\"%d\\n\", 0);\n                    }\n                }\n#endif\n//#define SFBO_PRINT\n#ifdef SFBO_PRINT\n                printf(\"%d\\n\", ics->sect_sfb_offset[g][ics->sect_start[g][i]]);\n#endif\n                p += (ics->sect_sfb_offset[g][ics->sect_end[g][i]] -\n                    ics->sect_sfb_offset[g][ics->sect_start[g][i]]);\n                break;\n            default:\n#ifdef SFBO_PRINT\n                printf(\"%d\\n\", ics->sect_sfb_offset[g][ics->sect_start[g][i]]);\n#endif\n                for (k = ics->sect_sfb_offset[g][ics->sect_start[g][i]];\n                     k < ics->sect_sfb_offset[g][ics->sect_end[g][i]]; k += inc)\n                {\n                    if ((result = huffman_spectral_data(sect_cb, ld, &spectral_data[p])) > 0)\n                        return result;\n#ifdef SD_PRINT\n                    {\n                        int j;\n                        for (j = p; j < p+inc; j++)\n                        {\n                            printf(\"%d\\n\", spectral_data[j]);\n                        }\n                    }\n#endif\n                    p += inc;\n                }\n                break;\n            }\n        }\n        groups += ics->window_group_length[g];\n    }\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->spectral_cycles += count;\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.30 */\nstatic uint16_t extension_payload(bitfile *ld, drc_info *drc, uint16_t count)\n{\n    uint16_t i, n, dataElementLength;\n    uint8_t dataElementLengthPart;\n    uint8_t align = 4, data_element_version, loopCounter;\n\n    uint8_t extension_type = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,87,\"extension_payload(): extension_type\"));\n\n    switch (extension_type)\n    {\n    case EXT_DYNAMIC_RANGE:\n        drc->present = 1;\n        n = dynamic_range_info(ld, drc);\n        return n;\n    case EXT_FILL_DATA:\n        /* fill_nibble = */ faad_getbits(ld, 4\n            DEBUGVAR(1,136,\"extension_payload(): fill_nibble\")); /* must be \ufffd0000\ufffd */\n        for (i = 0; i < count-1; i++)\n        {\n            /* fill_byte[i] = */ faad_getbits(ld, 8\n                DEBUGVAR(1,88,\"extension_payload(): fill_byte\")); /* must be \ufffd10100101\ufffd */\n        }\n        return count;\n    case EXT_DATA_ELEMENT:\n        data_element_version = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,400,\"extension_payload(): data_element_version\"));\n        switch (data_element_version)\n        {\n        case ANC_DATA:\n            loopCounter = 0;\n            dataElementLength = 0;\n            do {\n                dataElementLengthPart = (uint8_t)faad_getbits(ld, 8\n                    DEBUGVAR(1,401,\"extension_payload(): dataElementLengthPart\"));\n                dataElementLength += dataElementLengthPart;\n                loopCounter++;\n            } while (dataElementLengthPart == 255);\n\n            for (i = 0; i < dataElementLength; i++)\n            {\n                /* data_element_byte[i] = */ faad_getbits(ld, 8\n                    DEBUGVAR(1,402,\"extension_payload(): data_element_byte\"));\n                return (dataElementLength+loopCounter+1);\n            }\n        default:\n            align = 0;\n        }\n    case EXT_FIL:\n    default:\n        faad_getbits(ld, align\n            DEBUGVAR(1,88,\"extension_payload(): fill_nibble\"));\n        for (i = 0; i < count-1; i++)\n        {\n            /* other_bits[i] = */ faad_getbits(ld, 8\n               DEBUGVAR(1,89,\"extension_payload(): fill_bit\"));\n        }\n        return count;\n    }\n}\n\n/* Table 4.4.31 */\nstatic uint8_t dynamic_range_info(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 1;\n    uint8_t band_incr;\n\n    drc->num_bands = 1;\n\n    if (faad_get1bit(ld\n        DEBUGVAR(1,90,\"dynamic_range_info(): has instance_tag\")) & 1)\n    {\n        drc->pce_instance_tag = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,91,\"dynamic_range_info(): pce_instance_tag\"));\n        /* drc->drc_tag_reserved_bits = */ faad_getbits(ld, 4\n            DEBUGVAR(1,92,\"dynamic_range_info(): drc_tag_reserved_bits\"));\n        n++;\n    }\n\n    drc->excluded_chns_present = faad_get1bit(ld\n        DEBUGVAR(1,93,\"dynamic_range_info(): excluded_chns_present\"));\n    if (drc->excluded_chns_present == 1)\n    {\n        n += excluded_channels(ld, drc);\n    }\n\n    if (faad_get1bit(ld\n        DEBUGVAR(1,94,\"dynamic_range_info(): has bands data\")) & 1)\n    {\n        band_incr = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,95,\"dynamic_range_info(): band_incr\"));\n        /* drc->drc_bands_reserved_bits = */ faad_getbits(ld, 4\n            DEBUGVAR(1,96,\"dynamic_range_info(): drc_bands_reserved_bits\"));\n        n++;\n        drc->num_bands += band_incr;\n\n        for (i = 0; i < drc->num_bands; i++)\n        {\n            drc->band_top[i] = (uint8_t)faad_getbits(ld, 8\n                DEBUGVAR(1,97,\"dynamic_range_info(): band_top\"));\n            n++;\n        }\n    }\n\n    if (faad_get1bit(ld\n        DEBUGVAR(1,98,\"dynamic_range_info(): has prog_ref_level\")) & 1)\n    {\n        drc->prog_ref_level = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,99,\"dynamic_range_info(): prog_ref_level\"));\n        /* drc->prog_ref_level_reserved_bits = */ faad_get1bit(ld\n            DEBUGVAR(1,100,\"dynamic_range_info(): prog_ref_level_reserved_bits\"));\n        n++;\n    }\n\n    for (i = 0; i < drc->num_bands; i++)\n    {\n        drc->dyn_rng_sgn[i] = faad_get1bit(ld\n            DEBUGVAR(1,101,\"dynamic_range_info(): dyn_rng_sgn\"));\n        drc->dyn_rng_ctl[i] = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,102,\"dynamic_range_info(): dyn_rng_ctl\"));\n        n++;\n    }\n\n    return n;\n}\n\n/* Table 4.4.32 */\nstatic uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n\n    return n;\n}\n\n/* Annex A: Audio Interchange Formats */\n\n/* Table 1.A.2 */\nvoid get_adif_header(adif_header *adif, bitfile *ld)\n{\n    uint8_t i;\n\n    /* adif_id[0] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,106,\"get_adif_header(): adif_id[0]\"));\n    /* adif_id[1] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,107,\"get_adif_header(): adif_id[1]\"));\n    /* adif_id[2] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,108,\"get_adif_header(): adif_id[2]\"));\n    /* adif_id[3] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,109,\"get_adif_header(): adif_id[3]\"));\n    adif->copyright_id_present = faad_get1bit(ld\n        DEBUGVAR(1,110,\"get_adif_header(): copyright_id_present\"));\n    if(adif->copyright_id_present)\n    {\n        for (i = 0; i < 72/8; i++)\n        {\n            adif->copyright_id[i] = (int8_t)faad_getbits(ld, 8\n                DEBUGVAR(1,111,\"get_adif_header(): copyright_id\"));\n        }\n        adif->copyright_id[i] = 0;\n    }\n    adif->original_copy  = faad_get1bit(ld\n        DEBUGVAR(1,112,\"get_adif_header(): original_copy\"));\n    adif->home = faad_get1bit(ld\n        DEBUGVAR(1,113,\"get_adif_header(): home\"));\n    adif->bitstream_type = faad_get1bit(ld\n        DEBUGVAR(1,114,\"get_adif_header(): bitstream_type\"));\n    adif->bitrate = faad_getbits(ld, 23\n        DEBUGVAR(1,115,\"get_adif_header(): bitrate\"));\n    adif->num_program_config_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,116,\"get_adif_header(): num_program_config_elements\"));\n\n    for (i = 0; i < adif->num_program_config_elements + 1; i++)\n    {\n        if(adif->bitstream_type == 0)\n        {\n            adif->adif_buffer_fullness = faad_getbits(ld, 20\n                DEBUGVAR(1,117,\"get_adif_header(): adif_buffer_fullness\"));\n        } else {\n            adif->adif_buffer_fullness = 0;\n        }\n\n        program_config_element(&adif->pce[i], ld);\n    }\n}\n\n/* Table 1.A.5 */\nuint8_t adts_frame(adts_header *adts, bitfile *ld)\n{\n    /* faad_byte_align(ld); */\n    if (adts_fixed_header(adts, ld))\n        return 5;\n    adts_variable_header(adts, ld);\n    adts_error_check(adts, ld);\n\n    return 0;\n}\n\n/* Table 1.A.6 */\nstatic uint8_t adts_fixed_header(adts_header *adts, bitfile *ld)\n{\n    uint16_t i;\n    uint8_t sync_err = 1;\n\n    /* try to recover from sync errors */\n    for (i = 0; i < 768; i++)\n    {\n        adts->syncword = (uint16_t)faad_showbits(ld, 12);\n        if (adts->syncword != 0xFFF)\n        {\n            faad_getbits(ld, 8\n                DEBUGVAR(0,0,\"\"));\n        } else {\n            sync_err = 0;\n            faad_getbits(ld, 12\n                DEBUGVAR(1,118,\"adts_fixed_header(): syncword\"));\n            break;\n        }\n    }\n    if (sync_err)\n        return 5;\n\n    adts->id = faad_get1bit(ld\n        DEBUGVAR(1,119,\"adts_fixed_header(): id\"));\n    adts->layer = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,120,\"adts_fixed_header(): layer\"));\n    adts->protection_absent = faad_get1bit(ld\n        DEBUGVAR(1,121,\"adts_fixed_header(): protection_absent\"));\n    adts->profile = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,122,\"adts_fixed_header(): profile\"));\n    adts->sf_index = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,123,\"adts_fixed_header(): sf_index\"));\n    adts->private_bit = faad_get1bit(ld\n        DEBUGVAR(1,124,\"adts_fixed_header(): private_bit\"));\n    adts->channel_configuration = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,125,\"adts_fixed_header(): channel_configuration\"));\n    adts->original = faad_get1bit(ld\n        DEBUGVAR(1,126,\"adts_fixed_header(): original\"));\n    adts->home = faad_get1bit(ld\n        DEBUGVAR(1,127,\"adts_fixed_header(): home\"));\n\n    if (adts->old_format == 1)\n    {\n        /* Removed in corrigendum 14496-3:2002 */\n        if (adts->id == 0)\n        {\n            adts->emphasis = (uint8_t)faad_getbits(ld, 2\n                DEBUGVAR(1,128,\"adts_fixed_header(): emphasis\"));\n        }\n    }\n\n    return 0;\n}\n\n/* Table 1.A.7 */\nstatic void adts_variable_header(adts_header *adts, bitfile *ld)\n{\n    adts->copyright_identification_bit = faad_get1bit(ld\n        DEBUGVAR(1,129,\"adts_variable_header(): copyright_identification_bit\"));\n    adts->copyright_identification_start = faad_get1bit(ld\n        DEBUGVAR(1,130,\"adts_variable_header(): copyright_identification_start\"));\n    adts->aac_frame_length = (uint16_t)faad_getbits(ld, 13\n        DEBUGVAR(1,131,\"adts_variable_header(): aac_frame_length\"));\n    adts->adts_buffer_fullness = (uint16_t)faad_getbits(ld, 11\n        DEBUGVAR(1,132,\"adts_variable_header(): adts_buffer_fullness\"));\n    adts->no_raw_data_blocks_in_frame = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,133,\"adts_variable_header(): no_raw_data_blocks_in_frame\"));\n}\n\n/* Table 1.A.8 */\nstatic void adts_error_check(adts_header *adts, bitfile *ld)\n{\n    if (adts->protection_absent == 0)\n    {\n        adts->crc_check = (uint16_t)faad_getbits(ld, 16\n            DEBUGVAR(1,134,\"adts_error_check(): crc_check\"));\n    }\n}\n\n/* LATM parsing functions */\n\nstatic uint32_t latm_get_value(bitfile *ld)\n{\n    uint32_t l, value;\n    uint8_t bytesForValue;\n\n    bytesForValue = (uint8_t)faad_getbits(ld, 2);\n    value = 0;\n    for(l=0; l<bytesForValue; l++)\n        value = (value << 8) | (uint8_t)faad_getbits(ld, 8);\n\n    return value;\n}\n\n\nstatic uint32_t latmParsePayload(latm_header *latm, bitfile *ld)\n{\n    //assuming there's only one program with a single layer and 1 subFrame,\n    //allStreamsSametimeframing is set,\n    uint32_t framelen;\n    uint8_t tmp;\n\n    //this should be the payload length field for the current configuration\n    framelen = 0;\n    if(latm->framelen_type==0)\n    {\n        do\n        {\n            tmp = (uint8_t)faad_getbits(ld, 8);\n            framelen += tmp;\n        } while(tmp==0xff);\n    }\n    else if(latm->framelen_type==1)\n        framelen=latm->frameLength;\n\n    return framelen;\n}\n\n\nstatic uint32_t latmAudioMuxElement(latm_header *latm, bitfile *ld)\n{\n    uint32_t ascLen, asc_bits=0;\n    uint32_t x1, y1, m, n, i;\n    program_config pce;\n    mp4AudioSpecificConfig mp4ASC;\n\n    latm->useSameStreamMux = (uint8_t)faad_getbits(ld, 1);\n    if(!latm->useSameStreamMux)\n    {\n        //parseSameStreamMuxConfig\n        latm->version = (uint8_t) faad_getbits(ld, 1);\n        if(latm->version)\n            latm->versionA = (uint8_t) faad_getbits(ld, 1);\n        if(latm->versionA)\n        {\n            //dunno the payload format for versionA\n            fprintf(stderr, \"versionA not supported\\n\");\n            return 0;\n        }\n        if(latm->version) //read taraBufferFullness\n            latm_get_value(ld);\n        latm->allStreamsSameTimeFraming = (uint8_t)faad_getbits(ld, 1);\n        latm->numSubFrames = (uint8_t)faad_getbits(ld, 6) + 1;\n        latm->numPrograms = (uint8_t)faad_getbits(ld, 4) + 1;\n        latm->numLayers = faad_getbits(ld, 3) + 1;\n        if(latm->numPrograms>1 || !latm->allStreamsSameTimeFraming || latm->numSubFrames>1 || latm->numLayers>1)\n        {\n            fprintf(stderr, \"\\r\\nUnsupported LATM configuration: %d programs/ %d subframes, %d layers, allstreams: %d\\n\",\n                latm->numPrograms, latm->numSubFrames, latm->numLayers, latm->allStreamsSameTimeFraming);\n            return 0;\n        }\n        ascLen = 0;\n        if(latm->version)\n            ascLen = latm_get_value(ld);\n\n        x1 = faad_get_processed_bits(ld);\n        if(AudioSpecificConfigFromBitfile(ld, &mp4ASC, &pce, 0, 1) < 0)\n            return 0;\n\n        //horrid hack to unread the ASC bits and store them in latm->ASC\n        //the correct code would rely on an ideal faad_ungetbits()\n        y1 = faad_get_processed_bits(ld);\n        if((y1-x1) <= MAX_ASC_BYTES*8)\n        {\n            faad_rewindbits(ld);\n            m = x1;\n            while(m>0)\n            {\n                n = min(m, 32);\n                faad_getbits(ld, n);\n                m -= n;\n            }\n\n            i = 0;\n            m = latm->ASCbits = y1 - x1;\n            while(m > 0)\n            {\n                n = min(m, 8);\n                latm->ASC[i++] = (uint8_t) faad_getbits(ld, n);\n                m -= n;\n            }\n        }\n\n        asc_bits = y1-x1;\n\n        if(ascLen>asc_bits)\n            faad_getbits(ld, ascLen-asc_bits);\n\n        latm->framelen_type = (uint8_t) faad_getbits(ld, 3);\n        if(latm->framelen_type == 0)\n        {\n            latm->frameLength = 0;\n            faad_getbits(ld, 8); //buffer fullness for frame_len_type==0, useless\n        }\n        else if(latm->framelen_type == 1)\n        {\n            latm->frameLength = faad_getbits(ld, 9);\n            if(latm->frameLength==0)\n            {\n                fprintf(stderr, \"Invalid frameLength: 0\\r\\n\");\n                return 0;\n            }\n            latm->frameLength = (latm->frameLength+20)*8;\n        }\n        else\n        {   //hellish CELP or HCVX stuff, discard\n            fprintf(stderr, \"Unsupported CELP/HCVX framelentype: %d\\n\", latm->framelen_type);\n            return 0;\n        }\n\n        latm->otherDataLenBits = 0;\n        if(faad_getbits(ld, 1))\n        {   //other data present\n            int esc, tmp;\n            if(latm->version)\n                latm->otherDataLenBits = latm_get_value(ld);\n            else do\n            {\n                esc = faad_getbits(ld, 1);\n                tmp = faad_getbits(ld, 8);\n                latm->otherDataLenBits = (latm->otherDataLenBits << 8) + tmp;\n            } while(esc);\n        }\n        if(faad_getbits(ld, 1)) //crc\n            faad_getbits(ld, 8);\n        latm->inited = 1;\n      }\n\n      //read payload\n      if(latm->inited)\n          return latmParsePayload(latm, ld);\n      else\n          return 0;\n}\n\n\nuint32_t faad_latm_frame(latm_header *latm, bitfile *ld)\n{\n    uint16_t len;\n    uint32_t initpos, endpos, firstpos, ret;\n\n    firstpos = faad_get_processed_bits(ld);\n    while (ld->bytes_left)\n    {\n        faad_byte_align(ld);\n        if(faad_showbits(ld, 11) != 0x2B7)\n        {\n            faad_getbits(ld, 8);\n            continue;\n        }\n        faad_getbits(ld, 11);\n        len = faad_getbits(ld, 13);\n        if(!len)\n            continue;\n        initpos = faad_get_processed_bits(ld);\n        ret = latmAudioMuxElement(latm, ld);\n        endpos = faad_get_processed_bits(ld);\n        if(ret>0)\n            return (len*8)-(endpos-initpos);\n        //faad_getbits(ld, initpos-endpos); //go back to initpos, but is valid a getbits(-N) ? \n    }\n    return -1U;\n}\n"], "fixing_code": ["/*\n** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding\n** Copyright (C) 2003-2005 M. Bakker, Nero AG, http://www.nero.com\n**  \n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU General Public License as published by\n** the Free Software Foundation; either version 2 of the License, or\n** (at your option) any later version.\n** \n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n** \n** You should have received a copy of the GNU General Public License\n** along with this program; if not, write to the Free Software \n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n**\n** Any non-GPL usage of this software or parts of this software is strictly\n** forbidden.\n**\n** The \"appropriate copyright message\" mentioned in section 2c of the GPLv2\n** must read: \"Code from FAAD2 is copyright (c) Nero AG, www.nero.com\"\n**\n** Commercial non-GPL licensing of this software is possible.\n** For more info contact Nero AG through Mpeg4AAClicense@nero.com.\n**\n** $Id: bits.c,v 1.44 2007/11/01 12:33:29 menno Exp $\n**/\n\n#include \"common.h\"\n#include \"structs.h\"\n\n#include <stdlib.h>\n#include \"bits.h\"\n\n/* initialize buffer, call once before first getbits or showbits */\nvoid faad_initbits(bitfile *ld, const void *_buffer, const uint32_t buffer_size)\n{\n    uint32_t tmp;\n\n    if (ld == NULL)\n        return;\n\n    // useless\n    //memset(ld, 0, sizeof(bitfile));\n\n    if (buffer_size == 0 || _buffer == NULL)\n    {\n        ld->error = 1;\n        return;\n    }\n\n    ld->buffer = _buffer;\n\n    ld->buffer_size = buffer_size;\n    ld->bytes_left  = buffer_size;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)ld->buffer);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)ld->buffer, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)ld->buffer + 1);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)ld->buffer + 1, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->start = (uint32_t*)ld->buffer;\n    ld->tail = ((uint32_t*)ld->buffer + 2);\n\n    ld->bits_left = 32;\n\n    ld->error = 0;\n}\n\nvoid faad_endbits(bitfile *ld)\n{\n    // void\n}\n\nuint32_t faad_get_processed_bits(bitfile *ld)\n{\n    return (uint32_t)(8 * (4*(ld->tail - ld->start) - 4) - (ld->bits_left));\n}\n\nuint8_t faad_byte_align(bitfile *ld)\n{\n    int remainder = (32 - ld->bits_left) & 0x7;\n\n    if (remainder)\n    {\n        faad_flushbits(ld, 8 - remainder);\n        return (uint8_t)(8 - remainder);\n    }\n    return 0;\n}\n\nvoid faad_flushbits_ex(bitfile *ld, uint32_t bits)\n{\n    uint32_t tmp;\n\n    ld->bufa = ld->bufb;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(ld->tail);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(ld->tail, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->tail++;\n    ld->bits_left += (32 - bits);\n    //ld->bytes_left -= 4;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}\n\n/* rewind to beginning */\nvoid faad_rewindbits(bitfile *ld)\n{\n    uint32_t tmp;\n\n    ld->bytes_left = ld->buffer_size;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)&ld->start[0]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)&ld->start[0], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)&ld->start[1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)&ld->start[1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32;\n    ld->tail = &ld->start[2];\n}\n\n/* reset to a certain point */\nvoid faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    if (ld->buffer_size < words * 4)\n        ld->bytes_left = 0;\n    else\n        ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}\n\nuint8_t *faad_getbitbuffer(bitfile *ld, uint32_t bits\n                       DEBUGDEC)\n{\n    int i;\n    unsigned int temp;\n    int bytes = bits >> 3;\n    int remainder = bits & 0x7;\n\n    uint8_t *buffer = (uint8_t*)faad_malloc((bytes+1)*sizeof(uint8_t));\n\n    for (i = 0; i < bytes; i++)\n    {\n        buffer[i] = (uint8_t)faad_getbits(ld, 8 DEBUGVAR(print,var,dbg));\n    }\n\n    if (remainder)\n    {\n        temp = faad_getbits(ld, remainder DEBUGVAR(print,var,dbg)) << (8-remainder);\n\n        buffer[bytes] = (uint8_t)temp;\n    }\n\n    return buffer;\n}\n\n#ifdef DRM\n/* return the original data buffer */\nvoid *faad_origbitbuffer(bitfile *ld)\n{\n    return (void*)ld->start;\n}\n\n/* return the original data buffer size */\nuint32_t faad_origbitbuffer_size(bitfile *ld)\n{\n    return ld->buffer_size;\n}\n#endif\n\n/* reversed bit reading routines, used for RVLC and HCR */\nvoid faad_initbits_rev(bitfile *ld, void *buffer,\n                       uint32_t bits_in_buffer)\n{\n    uint32_t tmp;\n    int32_t index;\n\n    ld->buffer_size = bit2byte(bits_in_buffer);\n\n    index = (bits_in_buffer+31)/32 - 1;\n\n    ld->start = (uint32_t*)buffer + index - 2;\n\n    tmp = getdword((uint32_t*)buffer + index);\n    ld->bufa = tmp;\n\n    tmp = getdword((uint32_t*)buffer + index - 1);\n    ld->bufb = tmp;\n\n    ld->tail = (uint32_t*)buffer + index;\n\n    ld->bits_left = bits_in_buffer % 32;\n    if (ld->bits_left == 0)\n        ld->bits_left = 32;\n\n    ld->bytes_left = ld->buffer_size;\n    ld->error = 0;\n}\n\n/* EOF */\n", "/*\n** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding\n** Copyright (C) 2003-2005 M. Bakker, Nero AG, http://www.nero.com\n**  \n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU General Public License as published by\n** the Free Software Foundation; either version 2 of the License, or\n** (at your option) any later version.\n** \n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n** \n** You should have received a copy of the GNU General Public License\n** along with this program; if not, write to the Free Software \n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n**\n** Any non-GPL usage of this software or parts of this software is strictly\n** forbidden.\n**\n** The \"appropriate copyright message\" mentioned in section 2c of the GPLv2\n** must read: \"Code from FAAD2 is copyright (c) Nero AG, www.nero.com\"\n**\n** Commercial non-GPL licensing of this software is possible.\n** For more info contact Nero AG through Mpeg4AAClicense@nero.com.\n**\n** $Id: syntax.c,v 1.93 2009/01/26 23:51:15 menno Exp $\n**/\n\n/*\n   Reads the AAC bitstream as defined in 14496-3 (MPEG-4 Audio)\n*/\n\n#include \"common.h\"\n#include \"structs.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"syntax.h\"\n#include \"specrec.h\"\n#include \"huffman.h\"\n#include \"bits.h\"\n#include \"pulse.h\"\n#include \"analysis.h\"\n#include \"drc.h\"\n#ifdef ERROR_RESILIENCE\n#include \"rvlc.h\"\n#endif\n#ifdef SBR_DEC\n#include \"sbr_syntax.h\"\n#endif\n#include \"mp4.h\"\n\n\n/* static function declarations */\nstatic void decode_sce_lfe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele);\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele);\nstatic uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                          uint8_t channel, uint8_t *tag);\nstatic uint8_t channel_pair_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                    uint8_t channel, uint8_t *tag);\n#ifdef COUPLING_DEC\nstatic uint8_t coupling_channel_element(NeAACDecStruct *hDecoder, bitfile *ld);\n#endif\nstatic uint16_t data_stream_element(NeAACDecStruct *hDecoder, bitfile *ld);\nstatic uint8_t program_config_element(program_config *pce, bitfile *ld);\nstatic uint8_t fill_element(NeAACDecStruct *hDecoder, bitfile *ld, drc_info *drc\n#ifdef SBR_DEC\n                            ,uint8_t sbr_ele\n#endif\n                            );\nstatic uint8_t individual_channel_stream(NeAACDecStruct *hDecoder, element *ele,\n                                         bitfile *ld, ic_stream *ics, uint8_t scal_flag,\n                                         int16_t *spec_data);\nstatic uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                        uint8_t common_window);\nstatic uint8_t section_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld);\nstatic uint8_t scale_factor_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld);\n#ifdef SSR_DEC\nstatic void gain_control_data(bitfile *ld, ic_stream *ics);\n#endif\nstatic uint8_t spectral_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                             int16_t *spectral_data);\nstatic uint16_t extension_payload(bitfile *ld, drc_info *drc, uint16_t count);\nstatic uint8_t pulse_data(ic_stream *ics, pulse_info *pul, bitfile *ld);\nstatic void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld);\n#ifdef LTP_DEC\nstatic uint8_t ltp_data(NeAACDecStruct *hDecoder, ic_stream *ics, ltp_info *ltp, bitfile *ld);\n#endif\nstatic uint8_t adts_fixed_header(adts_header *adts, bitfile *ld);\nstatic void adts_variable_header(adts_header *adts, bitfile *ld);\nstatic void adts_error_check(adts_header *adts, bitfile *ld);\nstatic uint8_t dynamic_range_info(bitfile *ld, drc_info *drc);\nstatic uint8_t excluded_channels(bitfile *ld, drc_info *drc);\nstatic uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,\n                         bitfile *ld, ic_stream *ics, uint8_t scal_flag);\n#ifdef DRM\nstatic int8_t DRM_aac_scalable_main_header(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                           bitfile *ld, uint8_t this_layer_stereo);\n#endif\n\n\n/* Table 4.4.1 */\nint8_t GASpecificConfig(bitfile *ld, mp4AudioSpecificConfig *mp4ASC,\n                        program_config *pce_out)\n{\n    program_config pce;\n\n    /* 1024 or 960 */\n    mp4ASC->frameLengthFlag = faad_get1bit(ld\n        DEBUGVAR(1,138,\"GASpecificConfig(): FrameLengthFlag\"));\n#ifndef ALLOW_SMALL_FRAMELENGTH\n    if (mp4ASC->frameLengthFlag == 1)\n        return -3;\n#endif\n\n    mp4ASC->dependsOnCoreCoder = faad_get1bit(ld\n        DEBUGVAR(1,139,\"GASpecificConfig(): DependsOnCoreCoder\"));\n    if (mp4ASC->dependsOnCoreCoder == 1)\n    {\n        mp4ASC->coreCoderDelay = (uint16_t)faad_getbits(ld, 14\n            DEBUGVAR(1,140,\"GASpecificConfig(): CoreCoderDelay\"));\n    }\n\n    mp4ASC->extensionFlag = faad_get1bit(ld DEBUGVAR(1,141,\"GASpecificConfig(): ExtensionFlag\"));\n    if (mp4ASC->channelsConfiguration == 0)\n    {\n        if (program_config_element(&pce, ld))\n            return -3;\n        //mp4ASC->channelsConfiguration = pce.channels;\n\n        if (pce_out != NULL)\n            memcpy(pce_out, &pce, sizeof(program_config));\n\n        /*\n        if (pce.num_valid_cc_elements)\n            return -3;\n        */\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (mp4ASC->extensionFlag == 1)\n    {\n        /* Error resilience not supported yet */\n        if (mp4ASC->objectTypeIndex >= ER_OBJECT_START)\n        {\n            mp4ASC->aacSectionDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,144,\"GASpecificConfig(): aacSectionDataResilienceFlag\"));\n            mp4ASC->aacScalefactorDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,145,\"GASpecificConfig(): aacScalefactorDataResilienceFlag\"));\n            mp4ASC->aacSpectralDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,146,\"GASpecificConfig(): aacSpectralDataResilienceFlag\"));\n        }\n        /* 1 bit: extensionFlag3 */\n        faad_getbits(ld, 1);\n\t}\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.2 */\n/* An MPEG-4 Audio decoder is only required to follow the Program\n   Configuration Element in GASpecificConfig(). The decoder shall ignore\n   any Program Configuration Elements that may occur in raw data blocks.\n   PCEs transmitted in raw data blocks cannot be used to convey decoder\n   configuration information.\n*/\nstatic uint8_t program_config_element(program_config *pce, bitfile *ld)\n{\n    uint8_t i;\n\n    memset(pce, 0, sizeof(program_config));\n\n    pce->channels = 0;\n\n    pce->element_instance_tag = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,10,\"program_config_element(): element_instance_tag\"));\n\n    pce->object_type = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,11,\"program_config_element(): object_type\"));\n    pce->sf_index = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,12,\"program_config_element(): sf_index\"));\n    pce->num_front_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,13,\"program_config_element(): num_front_channel_elements\"));\n    pce->num_side_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,14,\"program_config_element(): num_side_channel_elements\"));\n    pce->num_back_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,15,\"program_config_element(): num_back_channel_elements\"));\n    pce->num_lfe_channel_elements = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,16,\"program_config_element(): num_lfe_channel_elements\"));\n    pce->num_assoc_data_elements = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,17,\"program_config_element(): num_assoc_data_elements\"));\n    pce->num_valid_cc_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,18,\"program_config_element(): num_valid_cc_elements\"));\n\n    pce->mono_mixdown_present = faad_get1bit(ld\n        DEBUGVAR(1,19,\"program_config_element(): mono_mixdown_present\"));\n    if (pce->mono_mixdown_present == 1)\n    {\n        pce->mono_mixdown_element_number = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,20,\"program_config_element(): mono_mixdown_element_number\"));\n    }\n\n    pce->stereo_mixdown_present = faad_get1bit(ld\n        DEBUGVAR(1,21,\"program_config_element(): stereo_mixdown_present\"));\n    if (pce->stereo_mixdown_present == 1)\n    {\n        pce->stereo_mixdown_element_number = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,22,\"program_config_element(): stereo_mixdown_element_number\"));\n    }\n\n    pce->matrix_mixdown_idx_present = faad_get1bit(ld\n        DEBUGVAR(1,23,\"program_config_element(): matrix_mixdown_idx_present\"));\n    if (pce->matrix_mixdown_idx_present == 1)\n    {\n        pce->matrix_mixdown_idx = (uint8_t)faad_getbits(ld, 2\n            DEBUGVAR(1,24,\"program_config_element(): matrix_mixdown_idx\"));\n        pce->pseudo_surround_enable = faad_get1bit(ld\n            DEBUGVAR(1,25,\"program_config_element(): pseudo_surround_enable\"));\n    }\n\n    for (i = 0; i < pce->num_front_channel_elements; i++)\n    {\n        pce->front_element_is_cpe[i] = faad_get1bit(ld\n            DEBUGVAR(1,26,\"program_config_element(): front_element_is_cpe\"));\n        pce->front_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,27,\"program_config_element(): front_element_tag_select\"));\n\n        if (pce->front_element_is_cpe[i] & 1)\n        {\n            pce->cpe_channel[pce->front_element_tag_select[i]] = pce->channels;\n            pce->num_front_channels += 2;\n            pce->channels += 2;\n        } else {\n            pce->sce_channel[pce->front_element_tag_select[i]] = pce->channels;\n            pce->num_front_channels++;\n            pce->channels++;\n        }\n    }\n\n    for (i = 0; i < pce->num_side_channel_elements; i++)\n    {\n        pce->side_element_is_cpe[i] = faad_get1bit(ld\n            DEBUGVAR(1,28,\"program_config_element(): side_element_is_cpe\"));\n        pce->side_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,29,\"program_config_element(): side_element_tag_select\"));\n\n        if (pce->side_element_is_cpe[i] & 1)\n        {\n            pce->cpe_channel[pce->side_element_tag_select[i]] = pce->channels;\n            pce->num_side_channels += 2;\n            pce->channels += 2;\n        } else {\n            pce->sce_channel[pce->side_element_tag_select[i]] = pce->channels;\n            pce->num_side_channels++;\n            pce->channels++;\n        }\n    }\n\n    for (i = 0; i < pce->num_back_channel_elements; i++)\n    {\n        pce->back_element_is_cpe[i] = faad_get1bit(ld\n            DEBUGVAR(1,30,\"program_config_element(): back_element_is_cpe\"));\n        pce->back_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,31,\"program_config_element(): back_element_tag_select\"));\n\n        if (pce->back_element_is_cpe[i] & 1)\n        {\n            pce->cpe_channel[pce->back_element_tag_select[i]] = pce->channels;\n            pce->channels += 2;\n            pce->num_back_channels += 2;\n        } else {\n            pce->sce_channel[pce->back_element_tag_select[i]] = pce->channels;\n            pce->num_back_channels++;\n            pce->channels++;\n        }\n    }\n\n    for (i = 0; i < pce->num_lfe_channel_elements; i++)\n    {\n        pce->lfe_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,32,\"program_config_element(): lfe_element_tag_select\"));\n\n        pce->sce_channel[pce->lfe_element_tag_select[i]] = pce->channels;\n        pce->num_lfe_channels++;\n        pce->channels++;\n    }\n\n    for (i = 0; i < pce->num_assoc_data_elements; i++)\n        pce->assoc_data_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,33,\"program_config_element(): assoc_data_element_tag_select\"));\n\n    for (i = 0; i < pce->num_valid_cc_elements; i++)\n    {\n        pce->cc_element_is_ind_sw[i] = faad_get1bit(ld\n            DEBUGVAR(1,34,\"program_config_element(): cc_element_is_ind_sw\"));\n        pce->valid_cc_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,35,\"program_config_element(): valid_cc_element_tag_select\"));\n    }\n\n    faad_byte_align(ld);\n\n    pce->comment_field_bytes = (uint8_t)faad_getbits(ld, 8\n        DEBUGVAR(1,36,\"program_config_element(): comment_field_bytes\"));\n\n    for (i = 0; i < pce->comment_field_bytes; i++)\n    {\n        pce->comment_field_data[i] = (uint8_t)faad_getbits(ld, 8\n            DEBUGVAR(1,37,\"program_config_element(): comment_field_data\"));\n    }\n    pce->comment_field_data[i] = 0;\n\n    if (pce->channels > MAX_CHANNELS)\n        return 22;\n\n    return 0;\n}\n\nstatic void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}\n\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);\n\n    /* map output channel position to internal data channels */\n    if (hDecoder->pce_set)\n    {\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels;\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    }\n\n    hDecoder->fr_channels += 2;\n    hDecoder->fr_ch_ele++;\n}\n\nvoid raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}\n\n/* Table 4.4.4 and */\n/* Table 4.4.9 */\nstatic uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                          uint8_t channel, uint8_t *tag)\n{\n    uint8_t retval = 0;\n    element sce = {0};\n    ic_stream *ics = &(sce.ics1);\n    ALIGN int16_t spec_data[1024] = {0};\n\n    sce.element_instance_tag = (uint8_t)faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,38,\"single_lfe_channel_element(): element_instance_tag\"));\n\n    *tag = sce.element_instance_tag;\n    sce.channel = channel;\n    sce.paired_channel = -1;\n\n    retval = individual_channel_stream(hDecoder, &sce, ld, ics, 0, spec_data);\n    if (retval > 0)\n        return retval;\n\n    /* IS not allowed in single channel */\n    if (ics->is_used)\n        return 32;\n\n#ifdef SBR_DEC\n    /* check if next bitstream element is a fill element */\n    /* if so, read it now so SBR decoding can be done in case of a file with SBR */\n    if (faad_showbits(ld, LEN_SE_ID) == ID_FIL)\n    {\n        faad_flushbits(ld, LEN_SE_ID);\n\n        /* one sbr_info describes a channel_element not a channel! */\n        if ((retval = fill_element(hDecoder, ld, hDecoder->drc, hDecoder->fr_ch_ele)) > 0)\n        {\n            return retval;\n        }\n    }\n#endif\n\n    /* noiseless coding is done, spectral reconstruction is done now */\n    retval = reconstruct_single_channel(hDecoder, ics, &sce, spec_data);\n    if (retval > 0)\n        return retval;\n\n    return 0;\n}\n\n/* Table 4.4.5 */\nstatic uint8_t channel_pair_element(NeAACDecStruct *hDecoder, bitfile *ld,\n                                    uint8_t channels, uint8_t *tag)\n{\n    ALIGN int16_t spec_data1[1024] = {0};\n    ALIGN int16_t spec_data2[1024] = {0};\n    element cpe = {0};\n    ic_stream *ics1 = &(cpe.ics1);\n    ic_stream *ics2 = &(cpe.ics2);\n    uint8_t result;\n\n    cpe.channel        = channels;\n    cpe.paired_channel = channels+1;\n\n    cpe.element_instance_tag = (uint8_t)faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,39,\"channel_pair_element(): element_instance_tag\"));\n    *tag = cpe.element_instance_tag;\n\n    if ((cpe.common_window = faad_get1bit(ld\n        DEBUGVAR(1,40,\"channel_pair_element(): common_window\"))) & 1)\n    {\n        /* both channels have common ics information */\n        if ((result = ics_info(hDecoder, ics1, ld, cpe.common_window)) > 0)\n            return result;\n\n        ics1->ms_mask_present = (uint8_t)faad_getbits(ld, 2\n            DEBUGVAR(1,41,\"channel_pair_element(): ms_mask_present\"));\n        if (ics1->ms_mask_present == 3)\n        {\n            /* bitstream error */\n            return 32;\n        }\n        if (ics1->ms_mask_present == 1)\n        {\n            uint8_t g, sfb;\n            for (g = 0; g < ics1->num_window_groups; g++)\n            {\n                for (sfb = 0; sfb < ics1->max_sfb; sfb++)\n                {\n                    ics1->ms_used[g][sfb] = faad_get1bit(ld\n                        DEBUGVAR(1,42,\"channel_pair_element(): faad_get1bit\"));\n                }\n            }\n        }\n\n#ifdef ERROR_RESILIENCE\n        if ((hDecoder->object_type >= ER_OBJECT_START) && (ics1->predictor_data_present))\n        {\n            if ((\n#ifdef LTP_DEC\n                ics1->ltp.data_present =\n#endif\n                faad_get1bit(ld DEBUGVAR(1,50,\"channel_pair_element(): ltp.data_present\"))) & 1)\n            {\n#ifdef LTP_DEC\n                if ((result = ltp_data(hDecoder, ics1, &(ics1->ltp), ld)) > 0)\n                {\n                    return result;\n                }\n#else\n                return 26;\n#endif\n            }\n        }\n#endif\n\n        memcpy(ics2, ics1, sizeof(ic_stream));\n    } else {\n        ics1->ms_mask_present = 0;\n    }\n\n    if ((result = individual_channel_stream(hDecoder, &cpe, ld, ics1,\n        0, spec_data1)) > 0)\n    {\n        return result;\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (cpe.common_window && (hDecoder->object_type >= ER_OBJECT_START) &&\n        (ics1->predictor_data_present))\n    {\n        if ((\n#ifdef LTP_DEC\n            ics1->ltp2.data_present =\n#endif\n            faad_get1bit(ld DEBUGVAR(1,50,\"channel_pair_element(): ltp.data_present\"))) & 1)\n        {\n#ifdef LTP_DEC\n            if ((result = ltp_data(hDecoder, ics1, &(ics1->ltp2), ld)) > 0)\n            {\n                return result;\n            }\n#else\n            return 26;\n#endif\n        }\n    }\n#endif\n\n    if ((result = individual_channel_stream(hDecoder, &cpe, ld, ics2,\n        0, spec_data2)) > 0)\n    {\n        return result;\n    }\n\n#ifdef SBR_DEC\n    /* check if next bitstream element is a fill element */\n    /* if so, read it now so SBR decoding can be done in case of a file with SBR */\n    if (faad_showbits(ld, LEN_SE_ID) == ID_FIL)\n    {\n        faad_flushbits(ld, LEN_SE_ID);\n\n        /* one sbr_info describes a channel_element not a channel! */\n        if ((result = fill_element(hDecoder, ld, hDecoder->drc, hDecoder->fr_ch_ele)) > 0)\n        {\n            return result;\n        }\n    }\n#endif\n\n    /* noiseless coding is done, spectral reconstruction is done now */\n    if ((result = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe,\n        spec_data1, spec_data2)) > 0)\n    {\n        return result;\n    }\n\n    return 0;\n}\n\n/* Table 4.4.6 */\nstatic uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                        uint8_t common_window)\n{\n    uint8_t retval = 0;\n    uint8_t ics_reserved_bit;\n\n    ics_reserved_bit = faad_get1bit(ld\n        DEBUGVAR(1,43,\"ics_info(): ics_reserved_bit\"));\n    if (ics_reserved_bit != 0)\n        return 32;\n    ics->window_sequence = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,44,\"ics_info(): window_sequence\"));\n    ics->window_shape = faad_get1bit(ld\n        DEBUGVAR(1,45,\"ics_info(): window_shape\"));\n\n#ifdef LD_DEC\n    /* No block switching in LD */\n    if ((hDecoder->object_type == LD) && (ics->window_sequence != ONLY_LONG_SEQUENCE))\n        return 32;\n#endif\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,46,\"ics_info(): max_sfb (short)\"));\n        ics->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,47,\"ics_info(): scale_factor_grouping\"));\n    } else {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,48,\"ics_info(): max_sfb (long)\"));\n    }\n\n    /* get the grouping information */\n    if ((retval = window_grouping_info(hDecoder, ics)) > 0)\n        return retval;\n\n\n    /* should be an error */\n    /* check the range of max_sfb */\n    if (ics->max_sfb > ics->num_swb)\n        return 16;\n\n    if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)\n    {\n        if ((ics->predictor_data_present = faad_get1bit(ld\n            DEBUGVAR(1,49,\"ics_info(): predictor_data_present\"))) & 1)\n        {\n            if (hDecoder->object_type == MAIN) /* MPEG2 style AAC predictor */\n            {\n                uint8_t sfb;\n\n                uint8_t limit = min(ics->max_sfb, max_pred_sfb(hDecoder->sf_index));\n#ifdef MAIN_DEC\n                ics->pred.limit = limit;\n#endif\n\n                if ((\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset =\n#endif\n                    faad_get1bit(ld DEBUGVAR(1,53,\"ics_info(): pred.predictor_reset\"))) & 1)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset_group_number =\n#endif\n                        (uint8_t)faad_getbits(ld, 5 DEBUGVAR(1,54,\"ics_info(): pred.predictor_reset_group_number\"));\n                }\n\n                for (sfb = 0; sfb < limit; sfb++)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.prediction_used[sfb] =\n#endif\n                        faad_get1bit(ld DEBUGVAR(1,55,\"ics_info(): pred.prediction_used\"));\n                }\n            }\n#ifdef LTP_DEC\n            else { /* Long Term Prediction */\n                if (hDecoder->object_type < ER_OBJECT_START)\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)\n                        {\n                            return retval;\n                        }\n                    }\n                    if (common_window)\n                    {\n                        if ((ics->ltp2.data_present = faad_get1bit(ld\n                            DEBUGVAR(1,51,\"ics_info(): ltp2.data_present\"))) & 1)\n                        {\n                            if ((retval = ltp_data(hDecoder, ics, &(ics->ltp2), ld)) > 0)\n                            {\n                                return retval;\n                            }\n                        }\n                    }\n                }\n#ifdef ERROR_RESILIENCE\n                if (!common_window && (hDecoder->object_type >= ER_OBJECT_START))\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        ltp_data(hDecoder, ics, &(ics->ltp), ld);\n                    }\n                }\n#endif\n            }\n#endif\n        }\n    }\n\n    return retval;\n}\n\n/* Table 4.4.7 */\nstatic uint8_t pulse_data(ic_stream *ics, pulse_info *pul, bitfile *ld)\n{\n    uint8_t i;\n\n    pul->number_pulse = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,56,\"pulse_data(): number_pulse\"));\n    pul->pulse_start_sfb = (uint8_t)faad_getbits(ld, 6\n        DEBUGVAR(1,57,\"pulse_data(): pulse_start_sfb\"));\n\n    /* check the range of pulse_start_sfb */\n    if (pul->pulse_start_sfb > ics->num_swb)\n        return 16;\n\n    for (i = 0; i < pul->number_pulse+1; i++)\n    {\n        pul->pulse_offset[i] = (uint8_t)faad_getbits(ld, 5\n            DEBUGVAR(1,58,\"pulse_data(): pulse_offset\"));\n#if 0\n        printf(\"%d\\n\", pul->pulse_offset[i]);\n#endif\n        pul->pulse_amp[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,59,\"pulse_data(): pulse_amp\"));\n#if 0\n        printf(\"%d\\n\", pul->pulse_amp[i]);\n#endif\n    }\n\n    return 0;\n}\n\n#ifdef COUPLING_DEC\n/* Table 4.4.8: Currently just for skipping the bits... */\nstatic uint8_t coupling_channel_element(NeAACDecStruct *hDecoder, bitfile *ld)\n{\n    uint8_t c, result = 0;\n    uint8_t ind_sw_cce_flag = 0;\n    uint8_t num_gain_element_lists = 0;\n    uint8_t num_coupled_elements = 0;\n\n    element el_empty = {0};\n    ic_stream ics_empty = {0};\n    int16_t sh_data[1024];\n\n    c = faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,900,\"coupling_channel_element(): element_instance_tag\"));\n\n    ind_sw_cce_flag = faad_get1bit(ld\n        DEBUGVAR(1,901,\"coupling_channel_element(): ind_sw_cce_flag\"));\n    num_coupled_elements = faad_getbits(ld, 3\n        DEBUGVAR(1,902,\"coupling_channel_element(): num_coupled_elements\"));\n\n    for (c = 0; c < num_coupled_elements + 1; c++)\n    {\n        uint8_t cc_target_is_cpe, cc_target_tag_select;\n\n        num_gain_element_lists++;\n\n        cc_target_is_cpe = faad_get1bit(ld\n            DEBUGVAR(1,903,\"coupling_channel_element(): cc_target_is_cpe\"));\n        cc_target_tag_select = faad_getbits(ld, 4\n            DEBUGVAR(1,904,\"coupling_channel_element(): cc_target_tag_select\"));\n\n        if (cc_target_is_cpe)\n        {\n            uint8_t cc_l = faad_get1bit(ld\n                DEBUGVAR(1,905,\"coupling_channel_element(): cc_l\"));\n            uint8_t cc_r = faad_get1bit(ld\n                DEBUGVAR(1,906,\"coupling_channel_element(): cc_r\"));\n\n            if (cc_l && cc_r)\n                num_gain_element_lists++;\n        }\n    }\n\n    faad_get1bit(ld\n        DEBUGVAR(1,907,\"coupling_channel_element(): cc_domain\"));\n    faad_get1bit(ld\n        DEBUGVAR(1,908,\"coupling_channel_element(): gain_element_sign\"));\n    faad_getbits(ld, 2\n        DEBUGVAR(1,909,\"coupling_channel_element(): gain_element_scale\"));\n\n    if ((result = individual_channel_stream(hDecoder, &el_empty, ld, &ics_empty,\n        0, sh_data)) > 0)\n    {\n        return result;\n    }\n\n    /* IS not allowed in single channel */\n    if (ics->is_used)\n        return 32;\n\n    for (c = 1; c < num_gain_element_lists; c++)\n    {\n        uint8_t cge;\n\n        if (ind_sw_cce_flag)\n        {\n            cge = 1;\n        } else {\n            cge = faad_get1bit(ld\n                DEBUGVAR(1,910,\"coupling_channel_element(): common_gain_element_present\"));\n        }\n\n        if (cge)\n        {\n            huffman_scale_factor(ld);\n        } else {\n            uint8_t g, sfb;\n\n            for (g = 0; g < ics_empty.num_window_groups; g++)\n            {\n                for (sfb = 0; sfb < ics_empty.max_sfb; sfb++)\n                {\n                    if (ics_empty.sfb_cb[g][sfb] != ZERO_HCB)\n                        huffman_scale_factor(ld);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n#endif\n\n/* Table 4.4.10 */\nstatic uint16_t data_stream_element(NeAACDecStruct *hDecoder, bitfile *ld)\n{\n    uint8_t byte_aligned;\n    uint16_t i, count;\n\n    /* element_instance_tag = */ faad_getbits(ld, LEN_TAG\n        DEBUGVAR(1,60,\"data_stream_element(): element_instance_tag\"));\n    byte_aligned = faad_get1bit(ld\n        DEBUGVAR(1,61,\"data_stream_element(): byte_aligned\"));\n    count = (uint16_t)faad_getbits(ld, 8\n        DEBUGVAR(1,62,\"data_stream_element(): count\"));\n    if (count == 255)\n    {\n        count += (uint16_t)faad_getbits(ld, 8\n            DEBUGVAR(1,63,\"data_stream_element(): extra count\"));\n    }\n    if (byte_aligned)\n        faad_byte_align(ld);\n\n    for (i = 0; i < count; i++)\n    {\n        faad_getbits(ld, LEN_BYTE\n            DEBUGVAR(1,64,\"data_stream_element(): data_stream_byte\"));\n    }\n\n    return count;\n}\n\n/* Table 4.4.11 */\nstatic uint8_t fill_element(NeAACDecStruct *hDecoder, bitfile *ld, drc_info *drc\n#ifdef SBR_DEC\n                            ,uint8_t sbr_ele\n#endif\n                            )\n{\n    uint16_t count;\n#ifdef SBR_DEC\n    uint8_t bs_extension_type;\n#endif\n\n    count = (uint16_t)faad_getbits(ld, 4\n        DEBUGVAR(1,65,\"fill_element(): count\"));\n    if (count == 15)\n    {\n        count += (uint16_t)faad_getbits(ld, 8\n            DEBUGVAR(1,66,\"fill_element(): extra count\")) - 1;\n    }\n\n    if (count > 0)\n    {\n#ifdef SBR_DEC\n        bs_extension_type = (uint8_t)faad_showbits(ld, 4);\n\n        if ((bs_extension_type == EXT_SBR_DATA) ||\n            (bs_extension_type == EXT_SBR_DATA_CRC))\n        {\n            if (sbr_ele == INVALID_SBR_ELEMENT)\n                return 24;\n\n            if (!hDecoder->sbr[sbr_ele])\n            {\n                hDecoder->sbr[sbr_ele] = sbrDecodeInit(hDecoder->frameLength,\n                    hDecoder->element_id[sbr_ele], 2*get_sample_rate(hDecoder->sf_index),\n                    hDecoder->downSampledSBR\n#ifdef DRM\n                    , 0\n#endif\n                    );\n            }\n\n            hDecoder->sbr_present_flag = 1;\n\n            /* parse the SBR data */\n            hDecoder->sbr[sbr_ele]->ret = sbr_extension_data(ld, hDecoder->sbr[sbr_ele], count,\n                hDecoder->postSeekResetFlag);\n\n#if 0\n            if (hDecoder->sbr[sbr_ele]->ret > 0)\n            {\n                printf(\"%s\\n\", NeAACDecGetErrorMessage(hDecoder->sbr[sbr_ele]->ret));\n            }\n#endif\n\n#if (defined(PS_DEC) || defined(DRM_PS))\n            if (hDecoder->sbr[sbr_ele]->ps_used)\n            {\n                hDecoder->ps_used[sbr_ele] = 1;\n\n                /* set element independent flag to 1 as well */\n                hDecoder->ps_used_global = 1;\n            }\n#endif\n        } else {\n#endif\n#ifndef DRM\n            while (count > 0)\n            {\n                count -= extension_payload(ld, drc, count);\n            }\n#else\n            return 30;\n#endif\n#ifdef SBR_DEC\n        }\n#endif\n    }\n\n    return 0;\n}\n\n/* Table 4.4.12 */\n#ifdef SSR_DEC\nstatic void gain_control_data(bitfile *ld, ic_stream *ics)\n{\n    uint8_t bd, wd, ad;\n    ssr_info *ssr = &(ics->ssr);\n\n    ssr->max_band = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,1000,\"gain_control_data(): max_band\"));\n\n    if (ics->window_sequence == ONLY_LONG_SEQUENCE)\n    {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 1; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n                    ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 5\n                        DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                }\n            }\n        }\n    } else if (ics->window_sequence == LONG_START_SEQUENCE) {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 2; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n                    if (wd == 0)\n                    {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    } else {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 2\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    }\n                }\n            }\n        }\n    } else if (ics->window_sequence == EIGHT_SHORT_SEQUENCE) {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 8; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n                    ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 2\n                        DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                }\n            }\n        }\n    } else if (ics->window_sequence == LONG_STOP_SEQUENCE) {\n        for (bd = 1; bd <= ssr->max_band; bd++)\n        {\n            for (wd = 0; wd < 2; wd++)\n            {\n                ssr->adjust_num[bd][wd] = (uint8_t)faad_getbits(ld, 3\n                    DEBUGVAR(1,1001,\"gain_control_data(): adjust_num\"));\n\n                for (ad = 0; ad < ssr->adjust_num[bd][wd]; ad++)\n                {\n                    ssr->alevcode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,1002,\"gain_control_data(): alevcode\"));\n\n                    if (wd == 0)\n                    {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 4\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    } else {\n                        ssr->aloccode[bd][wd][ad] = (uint8_t)faad_getbits(ld, 5\n                            DEBUGVAR(1,1003,\"gain_control_data(): aloccode\"));\n                    }\n                }\n            }\n        }\n    }\n}\n#endif\n\n#ifdef DRM\n/* Table 4.4.13 ASME */\nvoid DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                                   bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t retval = 0;\n    uint8_t channels = hDecoder->fr_channels = 0;\n    uint8_t ch;\n    uint8_t this_layer_stereo = (hDecoder->channelConfiguration > 1) ? 1 : 0;\n    element cpe = {0};\n    ic_stream *ics1 = &(cpe.ics1);\n    ic_stream *ics2 = &(cpe.ics2);\n    int16_t *spec_data;\n    ALIGN int16_t spec_data1[1024] = {0};\n    ALIGN int16_t spec_data2[1024] = {0};\n\n    hDecoder->fr_ch_ele = 0;\n\n    hInfo->error = DRM_aac_scalable_main_header(hDecoder, ics1, ics2, ld, this_layer_stereo);\n    if (hInfo->error > 0)\n        return;\n\n    cpe.common_window = 1;\n    if (this_layer_stereo)\n    {\n        hDecoder->element_id[0] = ID_CPE;\n        if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else {\n        hDecoder->element_id[0] = ID_SCE;\n    }\n\n    if (this_layer_stereo)\n    {\n        cpe.channel        = 0;\n        cpe.paired_channel = 1;\n    }\n\n\n    /* Stereo2 / Mono1 */\n    ics1->tns_data_present = faad_get1bit(ld);\n\n#if defined(LTP_DEC)\n    ics1->ltp.data_present = faad_get1bit(ld);\n#elif defined (DRM)\n    if(faad_get1bit(ld)) {\n         hInfo->error = 26;\n         return;\n    }\n#else\n    faad_get1bit(ld);\n#endif    \n\n    hInfo->error = side_info(hDecoder, &cpe, ld, ics1, 1);\n    if (hInfo->error > 0)\n        return;\n    if (this_layer_stereo)\n    {\n        /* Stereo3 */\n        ics2->tns_data_present = faad_get1bit(ld);\n#ifdef LTP_DEC\n        ics1->ltp.data_present =\n#endif\n            faad_get1bit(ld);\n        hInfo->error = side_info(hDecoder, &cpe, ld, ics2, 1);\n        if (hInfo->error > 0)\n            return;\n    }\n    /* Stereo4 / Mono2 */\n    if (ics1->tns_data_present)\n        tns_data(ics1, &(ics1->tns), ld);\n    if (this_layer_stereo)\n    {\n        /* Stereo5 */\n        if (ics2->tns_data_present)\n            tns_data(ics2, &(ics2->tns), ld);\n    }\n\n#ifdef DRM\n    /* CRC check */\n    if (hDecoder->object_type == DRM_ER_LC)\n    {\n        if ((hInfo->error = (uint8_t)faad_check_CRC(ld, (uint16_t)faad_get_processed_bits(ld) - 8)) > 0)\n            return;\n    }\n#endif\n\n    /* Stereo6 / Mono3 */\n    /* error resilient spectral data decoding */\n    if ((hInfo->error = reordered_spectral_data(hDecoder, ics1, ld, spec_data1)) > 0)\n    {\n        return;\n    }\n    if (this_layer_stereo)\n    {\n        /* Stereo7 */\n        /* error resilient spectral data decoding */\n        if ((hInfo->error = reordered_spectral_data(hDecoder, ics2, ld, spec_data2)) > 0)\n        {\n            return;\n        }\n    }\n\n\n#ifdef DRM\n#ifdef SBR_DEC\n    /* In case of DRM we need to read the SBR info before channel reconstruction */\n    if ((hDecoder->sbr_present_flag == 1) && (hDecoder->object_type == DRM_ER_LC))\n    {\n        bitfile ld_sbr = {0};\n        uint32_t i;\n        uint16_t count = 0;\n        uint8_t *revbuffer;\n        uint8_t *prevbufstart;\n        uint8_t *pbufend;\n\n        /* all forward bitreading should be finished at this point */\n        uint32_t bitsconsumed = faad_get_processed_bits(ld);\n        uint32_t buffer_size = faad_origbitbuffer_size(ld);\n        uint8_t *buffer = (uint8_t*)faad_origbitbuffer(ld);\n\n        if (bitsconsumed + 8 > buffer_size*8)\n        {\n            hInfo->error = 14;\n            return;\n        }\n\n        if (!hDecoder->sbr[0])\n        {\n            hDecoder->sbr[0] = sbrDecodeInit(hDecoder->frameLength, hDecoder->element_id[0],\n                2*get_sample_rate(hDecoder->sf_index), 0 /* ds SBR */, 1);\n        }\n\n        /* Reverse bit reading of SBR data in DRM audio frame */\n        revbuffer = (uint8_t*)faad_malloc(buffer_size*sizeof(uint8_t));\n        prevbufstart = revbuffer;\n        pbufend = &buffer[buffer_size - 1];\n        for (i = 0; i < buffer_size; i++)\n            *prevbufstart++ = tabFlipbits[*pbufend--];\n\n        /* Set SBR data */\n        /* consider 8 bits from AAC-CRC */\n        /* SBR buffer size is original buffer size minus AAC buffer size */\n        count = (uint16_t)bit2byte(buffer_size*8 - bitsconsumed);\n        faad_initbits(&ld_sbr, revbuffer, count);\n\n        hDecoder->sbr[0]->sample_rate = get_sample_rate(hDecoder->sf_index);\n        hDecoder->sbr[0]->sample_rate *= 2;\n\n        faad_getbits(&ld_sbr, 8); /* Skip 8-bit CRC */\n\n        hDecoder->sbr[0]->ret = sbr_extension_data(&ld_sbr, hDecoder->sbr[0], count, hDecoder->postSeekResetFlag);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->sbr[0]->ps_used)\n        {\n            hDecoder->ps_used[0] = 1;\n            hDecoder->ps_used_global = 1;\n        }\n#endif\n\n        if (ld_sbr.error)\n        {\n            hDecoder->sbr[0]->ret = 1;\n        }\n\n        /* check CRC */\n        /* no need to check it if there was already an error */\n        if (hDecoder->sbr[0]->ret == 0)\n            hDecoder->sbr[0]->ret = (uint8_t)faad_check_CRC(&ld_sbr, (uint16_t)faad_get_processed_bits(&ld_sbr) - 8);\n\n        /* SBR data was corrupted, disable it until the next header */\n        if (hDecoder->sbr[0]->ret != 0)\n        {\n            hDecoder->sbr[0]->header_count = 0;\n        }\n\n        faad_endbits(&ld_sbr);\n\n        if (revbuffer)\n            faad_free(revbuffer);\n    }\n#endif\n#endif\n\n    if (this_layer_stereo)\n    {\n        hInfo->error = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe, spec_data1, spec_data2);\n        if (hInfo->error > 0)\n            return;\n    } else {\n        hInfo->error = reconstruct_single_channel(hDecoder, ics1, &cpe, spec_data1);\n        if (hInfo->error > 0)\n            return;\n    }\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n\n    return;\n}\n\n/* Table 4.4.15 */\nstatic int8_t DRM_aac_scalable_main_header(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                           bitfile *ld, uint8_t this_layer_stereo)\n{\n    uint8_t retval = 0;\n    uint8_t ch;\n    ic_stream *ics;\n    uint8_t ics_reserved_bit;\n\n    ics_reserved_bit = faad_get1bit(ld\n        DEBUGVAR(1,300,\"aac_scalable_main_header(): ics_reserved_bits\"));\n    if (ics_reserved_bit != 0)\n        return 32;\n    ics1->window_sequence = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,301,\"aac_scalable_main_header(): window_sequence\"));\n    ics1->window_shape = faad_get1bit(ld\n        DEBUGVAR(1,302,\"aac_scalable_main_header(): window_shape\"));\n\n    if (ics1->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        ics1->max_sfb = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,303,\"aac_scalable_main_header(): max_sfb (short)\"));\n        ics1->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,304,\"aac_scalable_main_header(): scale_factor_grouping\"));\n    } else {\n        ics1->max_sfb = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,305,\"aac_scalable_main_header(): max_sfb (long)\"));\n    }\n\n    /* get the grouping information */\n    if ((retval = window_grouping_info(hDecoder, ics1)) > 0)\n        return retval;\n\n    /* should be an error */\n    /* check the range of max_sfb */\n    if (ics1->max_sfb > ics1->num_swb)\n        return 16;\n\n    if (this_layer_stereo)\n    {\n        ics1->ms_mask_present = (uint8_t)faad_getbits(ld, 2\n            DEBUGVAR(1,306,\"aac_scalable_main_header(): ms_mask_present\"));\n        if (ics1->ms_mask_present == 3)\n        {\n            /* bitstream error */\n            return 32;\n        }\n        if (ics1->ms_mask_present == 1)\n        {\n            uint8_t g, sfb;\n            for (g = 0; g < ics1->num_window_groups; g++)\n            {\n                for (sfb = 0; sfb < ics1->max_sfb; sfb++)\n                {\n                    ics1->ms_used[g][sfb] = faad_get1bit(ld\n                        DEBUGVAR(1,307,\"aac_scalable_main_header(): faad_get1bit\"));\n                }\n            }\n        }\n\n        memcpy(ics2, ics1, sizeof(ic_stream));\n    } else {\n        ics1->ms_mask_present = 0;\n    }\n\n    return 0;\n}\n#endif\n\nstatic uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,\n                         bitfile *ld, ic_stream *ics, uint8_t scal_flag)\n{\n    uint8_t result;\n\n    ics->global_gain = (uint8_t)faad_getbits(ld, 8\n        DEBUGVAR(1,67,\"individual_channel_stream(): global_gain\"));\n\n    if (!ele->common_window && !scal_flag)\n    {\n        if ((result = ics_info(hDecoder, ics, ld, ele->common_window)) > 0)\n            return result;\n    }\n\n    if ((result = section_data(hDecoder, ics, ld)) > 0)\n        return result;\n\n    if ((result = scale_factor_data(hDecoder, ics, ld)) > 0)\n        return result;\n\n    if (!scal_flag)\n    {\n        /**\n         **  NOTE: It could be that pulse data is available in scalable AAC too,\n         **        as said in Amendment 1, this could be only the case for ER AAC,\n         **        though. (have to check this out later)\n         **/\n        /* get pulse data */\n        if ((ics->pulse_data_present = faad_get1bit(ld\n            DEBUGVAR(1,68,\"individual_channel_stream(): pulse_data_present\"))) & 1)\n        {\n            if ((result = pulse_data(ics, &(ics->pul), ld)) > 0)\n                return result;\n        }\n\n        /* get tns data */\n        if ((ics->tns_data_present = faad_get1bit(ld\n            DEBUGVAR(1,69,\"individual_channel_stream(): tns_data_present\"))) & 1)\n        {\n#ifdef ERROR_RESILIENCE\n            if (hDecoder->object_type < ER_OBJECT_START)\n#endif\n                tns_data(ics, &(ics->tns), ld);\n        }\n\n        /* get gain control data */\n        if ((ics->gain_control_data_present = faad_get1bit(ld\n            DEBUGVAR(1,70,\"individual_channel_stream(): gain_control_data_present\"))) & 1)\n        {\n#ifdef SSR_DEC\n            if (hDecoder->object_type != SSR)\n                return 1;\n            else\n                gain_control_data(ld, ics);\n#else\n            return 1;\n#endif\n        }\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->aacSpectralDataResilienceFlag)\n    {\n        ics->length_of_reordered_spectral_data = (uint16_t)faad_getbits(ld, 14\n            DEBUGVAR(1,147,\"individual_channel_stream(): length_of_reordered_spectral_data\"));\n\n        if (hDecoder->channelConfiguration == 2)\n        {\n            if (ics->length_of_reordered_spectral_data > 6144)\n                ics->length_of_reordered_spectral_data = 6144;\n        } else {\n            if (ics->length_of_reordered_spectral_data > 12288)\n                ics->length_of_reordered_spectral_data = 12288;\n        }\n\n        ics->length_of_longest_codeword = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,148,\"individual_channel_stream(): length_of_longest_codeword\"));\n        if (ics->length_of_longest_codeword >= 49)\n            ics->length_of_longest_codeword = 49;\n    }\n\n    /* RVLC spectral data is put here */\n    if (hDecoder->aacScalefactorDataResilienceFlag)\n    {\n        if ((result = rvlc_decode_scale_factors(ics, ld)) > 0)\n            return result;\n    }\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.24 */\nstatic uint8_t individual_channel_stream(NeAACDecStruct *hDecoder, element *ele,\n                                         bitfile *ld, ic_stream *ics, uint8_t scal_flag,\n                                         int16_t *spec_data)\n{\n    uint8_t result;\n\n    result = side_info(hDecoder, ele, ld, ics, scal_flag);\n    if (result > 0)\n        return result;\n\n    if (hDecoder->object_type >= ER_OBJECT_START) \n    {\n        if (ics->tns_data_present)\n            tns_data(ics, &(ics->tns), ld);\n    }\n\n#ifdef DRM\n    /* CRC check */\n    if (hDecoder->object_type == DRM_ER_LC)\n    {\n        if ((result = (uint8_t)faad_check_CRC(ld, (uint16_t)faad_get_processed_bits(ld) - 8)) > 0)\n            return result;\n    }\n#endif\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->aacSpectralDataResilienceFlag)\n    {\n        /* error resilient spectral data decoding */\n        if ((result = reordered_spectral_data(hDecoder, ics, ld, spec_data)) > 0)\n        {\n            return result;\n        }\n    } else {\n#endif\n        /* decode the spectral data */\n        if ((result = spectral_data(hDecoder, ics, ld, spec_data)) > 0)\n        {\n            return result;\n        }\n#ifdef ERROR_RESILIENCE\n    }\n#endif\n\n    /* pulse coding reconstruction */\n    if (ics->pulse_data_present)\n    {\n        if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)\n        {\n            if ((result = pulse_decode(ics, spec_data, hDecoder->frameLength)) > 0)\n                return result;\n        } else {\n            return 2; /* pulse coding not allowed for short blocks */\n        }\n    }\n\n    return 0;\n}\n\n/* Table 4.4.25 */\nstatic uint8_t section_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld)\n{\n    uint8_t g;\n    uint8_t sect_esc_val, sect_bits;\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n        sect_bits = 3;\n    else\n        sect_bits = 5;\n    sect_esc_val = (1<<sect_bits) - 1;\n\n#if 0\n    printf(\"\\ntotal sfb %d\\n\", ics->max_sfb);\n    printf(\"   sect    top     cb\\n\");\n#endif\n\n    for (g = 0; g < ics->num_window_groups; g++)\n    {\n        uint8_t k = 0;\n        uint8_t i = 0;\n\n        while (k < ics->max_sfb)\n        {\n#ifdef ERROR_RESILIENCE\n            uint8_t vcb11 = 0;\n#endif\n            uint8_t sfb;\n            uint8_t sect_len_incr;\n            uint16_t sect_len = 0;\n            uint8_t sect_cb_bits = 4;\n\n            /* if \"faad_getbits\" detects error and returns \"0\", \"k\" is never\n               incremented and we cannot leave the while loop */\n            if (ld->error != 0)\n                return 14;\n\n#ifdef ERROR_RESILIENCE\n            if (hDecoder->aacSectionDataResilienceFlag)\n                sect_cb_bits = 5;\n#endif\n\n            ics->sect_cb[g][i] = (uint8_t)faad_getbits(ld, sect_cb_bits\n                DEBUGVAR(1,71,\"section_data(): sect_cb\"));\n\n            if (ics->sect_cb[g][i] == 12)\n                return 32;\n\n#if 0\n            printf(\"%d\\n\", ics->sect_cb[g][i]);\n#endif\n\n#ifndef DRM\n            if (ics->sect_cb[g][i] == NOISE_HCB)\n                ics->noise_used = 1;\n#else\n            /* PNS not allowed in DRM */\n            if (ics->sect_cb[g][i] == NOISE_HCB)\n                return 29;\n#endif\n            if (ics->sect_cb[g][i] == INTENSITY_HCB2 || ics->sect_cb[g][i] == INTENSITY_HCB)\n                ics->is_used = 1;\n\n#ifdef ERROR_RESILIENCE\n            if (hDecoder->aacSectionDataResilienceFlag)\n            {\n                if ((ics->sect_cb[g][i] == 11) ||\n                    ((ics->sect_cb[g][i] >= 16) && (ics->sect_cb[g][i] <= 32)))\n                {\n                    vcb11 = 1;\n                }\n            }\n            if (vcb11)\n            {\n                sect_len_incr = 1;\n            } else {\n#endif\n                sect_len_incr = (uint8_t)faad_getbits(ld, sect_bits\n                    DEBUGVAR(1,72,\"section_data(): sect_len_incr\"));\n#ifdef ERROR_RESILIENCE\n            }\n#endif\n            while ((sect_len_incr == sect_esc_val) /* &&\n                (k+sect_len < ics->max_sfb)*/)\n            {\n                sect_len += sect_len_incr;\n                sect_len_incr = (uint8_t)faad_getbits(ld, sect_bits\n                    DEBUGVAR(1,72,\"section_data(): sect_len_incr\"));\n            }\n\n            sect_len += sect_len_incr;\n\n            ics->sect_start[g][i] = k;\n            ics->sect_end[g][i] = k + sect_len;\n\n#if 0\n            printf(\"%d\\n\", ics->sect_start[g][i]);\n#endif\n#if 0\n            printf(\"%d\\n\", ics->sect_end[g][i]);\n#endif\n\n            if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n            {\n                if (k + sect_len > 8*15)\n                    return 15;\n                if (i >= 8*15)\n                    return 15;\n            } else {\n                if (k + sect_len > MAX_SFB)\n                    return 15;\n                if (i >= MAX_SFB)\n                    return 15;\n            }\n\n            for (sfb = k; sfb < k + sect_len; sfb++)\n            {\n                ics->sfb_cb[g][sfb] = ics->sect_cb[g][i];\n#if 0\n                printf(\"%d\\n\", ics->sfb_cb[g][sfb]);\n#endif\n            }\n\n#if 0\n            printf(\" %6d %6d %6d\\n\",\n                i,\n                ics->sect_end[g][i],\n                ics->sect_cb[g][i]);\n#endif\n\n            k += sect_len;\n            i++;\n        }\n        ics->num_sec[g] = i;\n\n        /* the sum of all sect_len_incr elements for a given window\n         * group shall equal max_sfb */\n        if (k != ics->max_sfb)\n        {\n            return 32;\n        }\n#if 0\n        printf(\"%d\\n\", ics->num_sec[g]);\n#endif\n    }\n\n#if 0\n    printf(\"\\n\");\n#endif\n\n    return 0;\n}\n\n/*\n *  decode_scale_factors()\n *   decodes the scalefactors from the bitstream\n */\n/*\n * All scalefactors (and also the stereo positions and pns energies) are\n * transmitted using Huffman coded DPCM relative to the previous active\n * scalefactor (respectively previous stereo position or previous pns energy,\n * see subclause 4.6.2 and 4.6.3). The first active scalefactor is\n * differentially coded relative to the global gain.\n */\nstatic uint8_t decode_scale_factors(ic_stream *ics, bitfile *ld)\n{\n    uint8_t g, sfb;\n    int16_t t;\n    int8_t noise_pcm_flag = 1;\n\n    int16_t scale_factor = ics->global_gain;\n    int16_t is_position = 0;\n    int16_t noise_energy = ics->global_gain - 90;\n\n    for (g = 0; g < ics->num_window_groups; g++)\n    {\n        for (sfb = 0; sfb < ics->max_sfb; sfb++)\n        {\n            switch (ics->sfb_cb[g][sfb])\n            {\n            case ZERO_HCB: /* zero book */\n                ics->scale_factors[g][sfb] = 0;\n//#define SF_PRINT\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n                break;\n            case INTENSITY_HCB: /* intensity books */\n            case INTENSITY_HCB2:\n\n                /* decode intensity position */\n                t = huffman_scale_factor(ld);\n                is_position += (t - 60);\n                ics->scale_factors[g][sfb] = is_position;\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n\n                break;\n            case NOISE_HCB: /* noise books */\n\n#ifndef DRM\n                /* decode noise energy */\n                if (noise_pcm_flag)\n                {\n                    noise_pcm_flag = 0;\n                    t = (int16_t)faad_getbits(ld, 9\n                        DEBUGVAR(1,73,\"scale_factor_data(): first noise\")) - 256;\n                } else {\n                    t = huffman_scale_factor(ld);\n                    t -= 60;\n                }\n                noise_energy += t;\n                ics->scale_factors[g][sfb] = noise_energy;\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n#else\n                /* PNS not allowed in DRM */\n                return 29;\n#endif\n\n                break;\n            default: /* spectral books */\n\n                /* ics->scale_factors[g][sfb] must be between 0 and 255 */\n\n                ics->scale_factors[g][sfb] = 0;\n\n                /* decode scale factor */\n                t = huffman_scale_factor(ld);\n                scale_factor += (t - 60);\n                if (scale_factor < 0 || scale_factor > 255)\n                    return 4;\n                ics->scale_factors[g][sfb] = scale_factor;\n#ifdef SF_PRINT\n                printf(\"%d\\n\", ics->scale_factors[g][sfb]);\n#endif\n\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/* Table 4.4.26 */\nstatic uint8_t scale_factor_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld)\n{\n    uint8_t ret = 0;\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n#ifdef ERROR_RESILIENCE\n    if (!hDecoder->aacScalefactorDataResilienceFlag)\n    {\n#endif\n        ret = decode_scale_factors(ics, ld);\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* In ER AAC the parameters for RVLC are seperated from the actual\n           data that holds the scale_factors.\n           Strangely enough, 2 parameters for HCR are put inbetween them.\n        */\n        ret = rvlc_scale_factor_data(ics, ld);\n    }\n#endif\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->scalefac_cycles += count;\n#endif\n\n    return ret;\n}\n\n/* Table 4.4.27 */\nstatic void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld)\n{\n    uint8_t w, filt, i, start_coef_bits, coef_bits;\n    uint8_t n_filt_bits = 2;\n    uint8_t length_bits = 6;\n    uint8_t order_bits = 5;\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        n_filt_bits = 1;\n        length_bits = 4;\n        order_bits = 3;\n    }\n\n    for (w = 0; w < ics->num_windows; w++)\n    {\n        tns->n_filt[w] = (uint8_t)faad_getbits(ld, n_filt_bits\n            DEBUGVAR(1,74,\"tns_data(): n_filt\"));\n#if 0\n        printf(\"%d\\n\", tns->n_filt[w]);\n#endif\n\n        if (tns->n_filt[w])\n        {\n            if ((tns->coef_res[w] = faad_get1bit(ld\n                DEBUGVAR(1,75,\"tns_data(): coef_res\"))) & 1)\n            {\n                start_coef_bits = 4;\n            } else {\n                start_coef_bits = 3;\n            }\n#if 0\n            printf(\"%d\\n\", tns->coef_res[w]);\n#endif\n        }\n\n        for (filt = 0; filt < tns->n_filt[w]; filt++)\n        {\n            tns->length[w][filt] = (uint8_t)faad_getbits(ld, length_bits\n                DEBUGVAR(1,76,\"tns_data(): length\"));\n#if 0\n            printf(\"%d\\n\", tns->length[w][filt]);\n#endif\n            tns->order[w][filt]  = (uint8_t)faad_getbits(ld, order_bits\n                DEBUGVAR(1,77,\"tns_data(): order\"));\n#if 0\n            printf(\"%d\\n\", tns->order[w][filt]);\n#endif\n            if (tns->order[w][filt])\n            {\n                tns->direction[w][filt] = faad_get1bit(ld\n                    DEBUGVAR(1,78,\"tns_data(): direction\"));\n#if 0\n                printf(\"%d\\n\", tns->direction[w][filt]);\n#endif\n                tns->coef_compress[w][filt] = faad_get1bit(ld\n                    DEBUGVAR(1,79,\"tns_data(): coef_compress\"));\n#if 0\n                printf(\"%d\\n\", tns->coef_compress[w][filt]);\n#endif\n\n                coef_bits = start_coef_bits - tns->coef_compress[w][filt];\n                for (i = 0; i < tns->order[w][filt]; i++)\n                {\n                    tns->coef[w][filt][i] = (uint8_t)faad_getbits(ld, coef_bits\n                        DEBUGVAR(1,80,\"tns_data(): coef\"));\n#if 0\n                    printf(\"%d\\n\", tns->coef[w][filt][i]);\n#endif\n                }\n            }\n        }\n    }\n}\n\n#ifdef LTP_DEC\n/* Table 4.4.28 */\nstatic uint8_t ltp_data(NeAACDecStruct *hDecoder, ic_stream *ics, ltp_info *ltp, bitfile *ld)\n{\n    uint8_t sfb, w;\n\n    ltp->lag = 0;\n\n#ifdef LD_DEC\n    if (hDecoder->object_type == LD)\n    {\n        ltp->lag_update = (uint8_t)faad_getbits(ld, 1\n            DEBUGVAR(1,142,\"ltp_data(): lag_update\"));\n\n        if (ltp->lag_update)\n        {\n            ltp->lag = (uint16_t)faad_getbits(ld, 10\n                DEBUGVAR(1,81,\"ltp_data(): lag\"));\n        }\n    } else {\n#endif\n        ltp->lag = (uint16_t)faad_getbits(ld, 11\n            DEBUGVAR(1,81,\"ltp_data(): lag\"));\n#ifdef LD_DEC\n    }\n#endif\n\n    /* Check length of lag */\n    if (ltp->lag > (hDecoder->frameLength << 1))\n        return 18;\n\n    ltp->coef = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,82,\"ltp_data(): coef\"));\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        for (w = 0; w < ics->num_windows; w++)\n        {\n            if ((ltp->short_used[w] = faad_get1bit(ld\n                DEBUGVAR(1,83,\"ltp_data(): short_used\"))) & 1)\n            {\n                ltp->short_lag_present[w] = faad_get1bit(ld\n                    DEBUGVAR(1,84,\"ltp_data(): short_lag_present\"));\n                if (ltp->short_lag_present[w])\n                {\n                    ltp->short_lag[w] = (uint8_t)faad_getbits(ld, 4\n                        DEBUGVAR(1,85,\"ltp_data(): short_lag\"));\n                }\n            }\n        }\n    } else {\n        ltp->last_band = (ics->max_sfb < MAX_LTP_SFB ? ics->max_sfb : MAX_LTP_SFB);\n\n        for (sfb = 0; sfb < ltp->last_band; sfb++)\n        {\n            ltp->long_used[sfb] = faad_get1bit(ld\n                DEBUGVAR(1,86,\"ltp_data(): long_used\"));\n        }\n    }\n\n    return 0;\n}\n#endif\n\n/* Table 4.4.29 */\nstatic uint8_t spectral_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                             int16_t *spectral_data)\n{\n    int8_t i;\n    uint8_t g;\n    uint16_t inc, k, p = 0;\n    uint8_t groups = 0;\n    uint8_t sect_cb;\n    uint8_t result;\n    uint16_t nshort = hDecoder->frameLength/8;\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n    for(g = 0; g < ics->num_window_groups; g++)\n    {\n        p = groups*nshort;\n\n        for (i = 0; i < ics->num_sec[g]; i++)\n        {\n            sect_cb = ics->sect_cb[g][i];\n\n            inc = (sect_cb >= FIRST_PAIR_HCB) ? 2 : 4;\n\n            switch (sect_cb)\n            {\n            case ZERO_HCB:\n            case NOISE_HCB:\n            case INTENSITY_HCB:\n            case INTENSITY_HCB2:\n//#define SD_PRINT\n#ifdef SD_PRINT\n                {\n                    int j;\n                    for (j = ics->sect_sfb_offset[g][ics->sect_start[g][i]]; j < ics->sect_sfb_offset[g][ics->sect_end[g][i]]; j++)\n                    {\n                        printf(\"%d\\n\", 0);\n                    }\n                }\n#endif\n//#define SFBO_PRINT\n#ifdef SFBO_PRINT\n                printf(\"%d\\n\", ics->sect_sfb_offset[g][ics->sect_start[g][i]]);\n#endif\n                p += (ics->sect_sfb_offset[g][ics->sect_end[g][i]] -\n                    ics->sect_sfb_offset[g][ics->sect_start[g][i]]);\n                break;\n            default:\n#ifdef SFBO_PRINT\n                printf(\"%d\\n\", ics->sect_sfb_offset[g][ics->sect_start[g][i]]);\n#endif\n                for (k = ics->sect_sfb_offset[g][ics->sect_start[g][i]];\n                     k < ics->sect_sfb_offset[g][ics->sect_end[g][i]]; k += inc)\n                {\n                    if ((result = huffman_spectral_data(sect_cb, ld, &spectral_data[p])) > 0)\n                        return result;\n#ifdef SD_PRINT\n                    {\n                        int j;\n                        for (j = p; j < p+inc; j++)\n                        {\n                            printf(\"%d\\n\", spectral_data[j]);\n                        }\n                    }\n#endif\n                    p += inc;\n                }\n                break;\n            }\n        }\n        groups += ics->window_group_length[g];\n    }\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->spectral_cycles += count;\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.30 */\nstatic uint16_t extension_payload(bitfile *ld, drc_info *drc, uint16_t count)\n{\n    uint16_t i, n, dataElementLength;\n    uint8_t dataElementLengthPart;\n    uint8_t align = 4, data_element_version, loopCounter;\n\n    uint8_t extension_type = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,87,\"extension_payload(): extension_type\"));\n\n    switch (extension_type)\n    {\n    case EXT_DYNAMIC_RANGE:\n        drc->present = 1;\n        n = dynamic_range_info(ld, drc);\n        return n;\n    case EXT_FILL_DATA:\n        /* fill_nibble = */ faad_getbits(ld, 4\n            DEBUGVAR(1,136,\"extension_payload(): fill_nibble\")); /* must be \ufffd0000\ufffd */\n        for (i = 0; i < count-1; i++)\n        {\n            /* fill_byte[i] = */ faad_getbits(ld, 8\n                DEBUGVAR(1,88,\"extension_payload(): fill_byte\")); /* must be \ufffd10100101\ufffd */\n        }\n        return count;\n    case EXT_DATA_ELEMENT:\n        data_element_version = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,400,\"extension_payload(): data_element_version\"));\n        switch (data_element_version)\n        {\n        case ANC_DATA:\n            loopCounter = 0;\n            dataElementLength = 0;\n            do {\n                dataElementLengthPart = (uint8_t)faad_getbits(ld, 8\n                    DEBUGVAR(1,401,\"extension_payload(): dataElementLengthPart\"));\n                dataElementLength += dataElementLengthPart;\n                loopCounter++;\n            } while (dataElementLengthPart == 255);\n\n            for (i = 0; i < dataElementLength; i++)\n            {\n                /* data_element_byte[i] = */ faad_getbits(ld, 8\n                    DEBUGVAR(1,402,\"extension_payload(): data_element_byte\"));\n                return (dataElementLength+loopCounter+1);\n            }\n        default:\n            align = 0;\n        }\n    case EXT_FIL:\n    default:\n        faad_getbits(ld, align\n            DEBUGVAR(1,88,\"extension_payload(): fill_nibble\"));\n        for (i = 0; i < count-1; i++)\n        {\n            /* other_bits[i] = */ faad_getbits(ld, 8\n               DEBUGVAR(1,89,\"extension_payload(): fill_bit\"));\n        }\n        return count;\n    }\n}\n\n/* Table 4.4.31 */\nstatic uint8_t dynamic_range_info(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 1;\n    uint8_t band_incr;\n\n    drc->num_bands = 1;\n\n    if (faad_get1bit(ld\n        DEBUGVAR(1,90,\"dynamic_range_info(): has instance_tag\")) & 1)\n    {\n        drc->pce_instance_tag = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,91,\"dynamic_range_info(): pce_instance_tag\"));\n        /* drc->drc_tag_reserved_bits = */ faad_getbits(ld, 4\n            DEBUGVAR(1,92,\"dynamic_range_info(): drc_tag_reserved_bits\"));\n        n++;\n    }\n\n    drc->excluded_chns_present = faad_get1bit(ld\n        DEBUGVAR(1,93,\"dynamic_range_info(): excluded_chns_present\"));\n    if (drc->excluded_chns_present == 1)\n    {\n        n += excluded_channels(ld, drc);\n    }\n\n    if (faad_get1bit(ld\n        DEBUGVAR(1,94,\"dynamic_range_info(): has bands data\")) & 1)\n    {\n        band_incr = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,95,\"dynamic_range_info(): band_incr\"));\n        /* drc->drc_bands_reserved_bits = */ faad_getbits(ld, 4\n            DEBUGVAR(1,96,\"dynamic_range_info(): drc_bands_reserved_bits\"));\n        n++;\n        drc->num_bands += band_incr;\n\n        for (i = 0; i < drc->num_bands; i++)\n        {\n            drc->band_top[i] = (uint8_t)faad_getbits(ld, 8\n                DEBUGVAR(1,97,\"dynamic_range_info(): band_top\"));\n            n++;\n        }\n    }\n\n    if (faad_get1bit(ld\n        DEBUGVAR(1,98,\"dynamic_range_info(): has prog_ref_level\")) & 1)\n    {\n        drc->prog_ref_level = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,99,\"dynamic_range_info(): prog_ref_level\"));\n        /* drc->prog_ref_level_reserved_bits = */ faad_get1bit(ld\n            DEBUGVAR(1,100,\"dynamic_range_info(): prog_ref_level_reserved_bits\"));\n        n++;\n    }\n\n    for (i = 0; i < drc->num_bands; i++)\n    {\n        drc->dyn_rng_sgn[i] = faad_get1bit(ld\n            DEBUGVAR(1,101,\"dynamic_range_info(): dyn_rng_sgn\"));\n        drc->dyn_rng_ctl[i] = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,102,\"dynamic_range_info(): dyn_rng_ctl\"));\n        n++;\n    }\n\n    return n;\n}\n\n/* Table 4.4.32 */\nstatic uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        if (i >= MAX_CHANNELS - num_excl_chan - 7)\n            return n;\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n\n    return n;\n}\n\n/* Annex A: Audio Interchange Formats */\n\n/* Table 1.A.2 */\nvoid get_adif_header(adif_header *adif, bitfile *ld)\n{\n    uint8_t i;\n\n    /* adif_id[0] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,106,\"get_adif_header(): adif_id[0]\"));\n    /* adif_id[1] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,107,\"get_adif_header(): adif_id[1]\"));\n    /* adif_id[2] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,108,\"get_adif_header(): adif_id[2]\"));\n    /* adif_id[3] = */ faad_getbits(ld, 8\n        DEBUGVAR(1,109,\"get_adif_header(): adif_id[3]\"));\n    adif->copyright_id_present = faad_get1bit(ld\n        DEBUGVAR(1,110,\"get_adif_header(): copyright_id_present\"));\n    if(adif->copyright_id_present)\n    {\n        for (i = 0; i < 72/8; i++)\n        {\n            adif->copyright_id[i] = (int8_t)faad_getbits(ld, 8\n                DEBUGVAR(1,111,\"get_adif_header(): copyright_id\"));\n        }\n        adif->copyright_id[i] = 0;\n    }\n    adif->original_copy  = faad_get1bit(ld\n        DEBUGVAR(1,112,\"get_adif_header(): original_copy\"));\n    adif->home = faad_get1bit(ld\n        DEBUGVAR(1,113,\"get_adif_header(): home\"));\n    adif->bitstream_type = faad_get1bit(ld\n        DEBUGVAR(1,114,\"get_adif_header(): bitstream_type\"));\n    adif->bitrate = faad_getbits(ld, 23\n        DEBUGVAR(1,115,\"get_adif_header(): bitrate\"));\n    adif->num_program_config_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,116,\"get_adif_header(): num_program_config_elements\"));\n\n    for (i = 0; i < adif->num_program_config_elements + 1; i++)\n    {\n        if(adif->bitstream_type == 0)\n        {\n            adif->adif_buffer_fullness = faad_getbits(ld, 20\n                DEBUGVAR(1,117,\"get_adif_header(): adif_buffer_fullness\"));\n        } else {\n            adif->adif_buffer_fullness = 0;\n        }\n\n        program_config_element(&adif->pce[i], ld);\n    }\n}\n\n/* Table 1.A.5 */\nuint8_t adts_frame(adts_header *adts, bitfile *ld)\n{\n    /* faad_byte_align(ld); */\n    if (adts_fixed_header(adts, ld))\n        return 5;\n    adts_variable_header(adts, ld);\n    adts_error_check(adts, ld);\n\n    return 0;\n}\n\n/* Table 1.A.6 */\nstatic uint8_t adts_fixed_header(adts_header *adts, bitfile *ld)\n{\n    uint16_t i;\n    uint8_t sync_err = 1;\n\n    /* try to recover from sync errors */\n    for (i = 0; i < 768; i++)\n    {\n        adts->syncword = (uint16_t)faad_showbits(ld, 12);\n        if (adts->syncword != 0xFFF)\n        {\n            faad_getbits(ld, 8\n                DEBUGVAR(0,0,\"\"));\n        } else {\n            sync_err = 0;\n            faad_getbits(ld, 12\n                DEBUGVAR(1,118,\"adts_fixed_header(): syncword\"));\n            break;\n        }\n    }\n    if (sync_err)\n        return 5;\n\n    adts->id = faad_get1bit(ld\n        DEBUGVAR(1,119,\"adts_fixed_header(): id\"));\n    adts->layer = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,120,\"adts_fixed_header(): layer\"));\n    adts->protection_absent = faad_get1bit(ld\n        DEBUGVAR(1,121,\"adts_fixed_header(): protection_absent\"));\n    adts->profile = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,122,\"adts_fixed_header(): profile\"));\n    adts->sf_index = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,123,\"adts_fixed_header(): sf_index\"));\n    adts->private_bit = faad_get1bit(ld\n        DEBUGVAR(1,124,\"adts_fixed_header(): private_bit\"));\n    adts->channel_configuration = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,125,\"adts_fixed_header(): channel_configuration\"));\n    adts->original = faad_get1bit(ld\n        DEBUGVAR(1,126,\"adts_fixed_header(): original\"));\n    adts->home = faad_get1bit(ld\n        DEBUGVAR(1,127,\"adts_fixed_header(): home\"));\n\n    if (adts->old_format == 1)\n    {\n        /* Removed in corrigendum 14496-3:2002 */\n        if (adts->id == 0)\n        {\n            adts->emphasis = (uint8_t)faad_getbits(ld, 2\n                DEBUGVAR(1,128,\"adts_fixed_header(): emphasis\"));\n        }\n    }\n\n    return 0;\n}\n\n/* Table 1.A.7 */\nstatic void adts_variable_header(adts_header *adts, bitfile *ld)\n{\n    adts->copyright_identification_bit = faad_get1bit(ld\n        DEBUGVAR(1,129,\"adts_variable_header(): copyright_identification_bit\"));\n    adts->copyright_identification_start = faad_get1bit(ld\n        DEBUGVAR(1,130,\"adts_variable_header(): copyright_identification_start\"));\n    adts->aac_frame_length = (uint16_t)faad_getbits(ld, 13\n        DEBUGVAR(1,131,\"adts_variable_header(): aac_frame_length\"));\n    adts->adts_buffer_fullness = (uint16_t)faad_getbits(ld, 11\n        DEBUGVAR(1,132,\"adts_variable_header(): adts_buffer_fullness\"));\n    adts->no_raw_data_blocks_in_frame = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,133,\"adts_variable_header(): no_raw_data_blocks_in_frame\"));\n}\n\n/* Table 1.A.8 */\nstatic void adts_error_check(adts_header *adts, bitfile *ld)\n{\n    if (adts->protection_absent == 0)\n    {\n        adts->crc_check = (uint16_t)faad_getbits(ld, 16\n            DEBUGVAR(1,134,\"adts_error_check(): crc_check\"));\n    }\n}\n\n/* LATM parsing functions */\n\nstatic uint32_t latm_get_value(bitfile *ld)\n{\n    uint32_t l, value;\n    uint8_t bytesForValue;\n\n    bytesForValue = (uint8_t)faad_getbits(ld, 2);\n    value = 0;\n    for(l=0; l<bytesForValue; l++)\n        value = (value << 8) | (uint8_t)faad_getbits(ld, 8);\n\n    return value;\n}\n\n\nstatic uint32_t latmParsePayload(latm_header *latm, bitfile *ld)\n{\n    //assuming there's only one program with a single layer and 1 subFrame,\n    //allStreamsSametimeframing is set,\n    uint32_t framelen;\n    uint8_t tmp;\n\n    //this should be the payload length field for the current configuration\n    framelen = 0;\n    if(latm->framelen_type==0)\n    {\n        do\n        {\n            tmp = (uint8_t)faad_getbits(ld, 8);\n            framelen += tmp;\n        } while(tmp==0xff);\n    }\n    else if(latm->framelen_type==1)\n        framelen=latm->frameLength;\n\n    return framelen;\n}\n\n\nstatic uint32_t latmAudioMuxElement(latm_header *latm, bitfile *ld)\n{\n    uint32_t ascLen, asc_bits=0;\n    uint32_t x1, y1, m, n, i;\n    program_config pce;\n    mp4AudioSpecificConfig mp4ASC;\n\n    latm->useSameStreamMux = (uint8_t)faad_getbits(ld, 1);\n    if(!latm->useSameStreamMux)\n    {\n        //parseSameStreamMuxConfig\n        latm->version = (uint8_t) faad_getbits(ld, 1);\n        if(latm->version)\n            latm->versionA = (uint8_t) faad_getbits(ld, 1);\n        if(latm->versionA)\n        {\n            //dunno the payload format for versionA\n            fprintf(stderr, \"versionA not supported\\n\");\n            return 0;\n        }\n        if(latm->version) //read taraBufferFullness\n            latm_get_value(ld);\n        latm->allStreamsSameTimeFraming = (uint8_t)faad_getbits(ld, 1);\n        latm->numSubFrames = (uint8_t)faad_getbits(ld, 6) + 1;\n        latm->numPrograms = (uint8_t)faad_getbits(ld, 4) + 1;\n        latm->numLayers = faad_getbits(ld, 3) + 1;\n        if(latm->numPrograms>1 || !latm->allStreamsSameTimeFraming || latm->numSubFrames>1 || latm->numLayers>1)\n        {\n            fprintf(stderr, \"\\r\\nUnsupported LATM configuration: %d programs/ %d subframes, %d layers, allstreams: %d\\n\",\n                latm->numPrograms, latm->numSubFrames, latm->numLayers, latm->allStreamsSameTimeFraming);\n            return 0;\n        }\n        ascLen = 0;\n        if(latm->version)\n            ascLen = latm_get_value(ld);\n\n        x1 = faad_get_processed_bits(ld);\n        if(AudioSpecificConfigFromBitfile(ld, &mp4ASC, &pce, 0, 1) < 0)\n            return 0;\n\n        //horrid hack to unread the ASC bits and store them in latm->ASC\n        //the correct code would rely on an ideal faad_ungetbits()\n        y1 = faad_get_processed_bits(ld);\n        if((y1-x1) <= MAX_ASC_BYTES*8)\n        {\n            faad_rewindbits(ld);\n            m = x1;\n            while(m>0)\n            {\n                n = min(m, 32);\n                faad_getbits(ld, n);\n                m -= n;\n            }\n\n            i = 0;\n            m = latm->ASCbits = y1 - x1;\n            while(m > 0)\n            {\n                n = min(m, 8);\n                latm->ASC[i++] = (uint8_t) faad_getbits(ld, n);\n                m -= n;\n            }\n        }\n\n        asc_bits = y1-x1;\n\n        if(ascLen>asc_bits)\n            faad_getbits(ld, ascLen-asc_bits);\n\n        latm->framelen_type = (uint8_t) faad_getbits(ld, 3);\n        if(latm->framelen_type == 0)\n        {\n            latm->frameLength = 0;\n            faad_getbits(ld, 8); //buffer fullness for frame_len_type==0, useless\n        }\n        else if(latm->framelen_type == 1)\n        {\n            latm->frameLength = faad_getbits(ld, 9);\n            if(latm->frameLength==0)\n            {\n                fprintf(stderr, \"Invalid frameLength: 0\\r\\n\");\n                return 0;\n            }\n            latm->frameLength = (latm->frameLength+20)*8;\n        }\n        else\n        {   //hellish CELP or HCVX stuff, discard\n            fprintf(stderr, \"Unsupported CELP/HCVX framelentype: %d\\n\", latm->framelen_type);\n            return 0;\n        }\n\n        latm->otherDataLenBits = 0;\n        if(faad_getbits(ld, 1))\n        {   //other data present\n            int esc, tmp;\n            if(latm->version)\n                latm->otherDataLenBits = latm_get_value(ld);\n            else do\n            {\n                esc = faad_getbits(ld, 1);\n                tmp = faad_getbits(ld, 8);\n                latm->otherDataLenBits = (latm->otherDataLenBits << 8) + tmp;\n            } while(esc);\n        }\n        if(faad_getbits(ld, 1)) //crc\n            faad_getbits(ld, 8);\n        latm->inited = 1;\n      }\n\n      //read payload\n      if(latm->inited)\n          return latmParsePayload(latm, ld);\n      else\n          return 0;\n}\n\n\nuint32_t faad_latm_frame(latm_header *latm, bitfile *ld)\n{\n    uint16_t len;\n    uint32_t initpos, endpos, firstpos, ret;\n\n    firstpos = faad_get_processed_bits(ld);\n    while (ld->bytes_left)\n    {\n        faad_byte_align(ld);\n        if(faad_showbits(ld, 11) != 0x2B7)\n        {\n            faad_getbits(ld, 8);\n            continue;\n        }\n        faad_getbits(ld, 11);\n        len = faad_getbits(ld, 13);\n        if(!len)\n            continue;\n        initpos = faad_get_processed_bits(ld);\n        ret = latmAudioMuxElement(latm, ld);\n        endpos = faad_get_processed_bits(ld);\n        if(ret>0)\n            return (len*8)-(endpos-initpos);\n        //faad_getbits(ld, initpos-endpos); //go back to initpos, but is valid a getbits(-N) ? \n    }\n    return -1U;\n}\n"], "filenames": ["libfaad/bits.c", "libfaad/syntax.c"], "buggy_code_start_loc": [170, 2306], "buggy_code_end_loc": [171, 2306], "fixing_code_start_loc": [170, 2307], "fixing_code_end_loc": [174, 2309], "type": "CWE-119", "message": "An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left).", "other": {"cve": {"id": "CVE-2019-15296", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-21T07:15:10.830", "lastModified": "2020-06-15T18:15:13.473", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left)."}, {"lang": "es", "value": "Permisos inapropiados en el instalador para Intel\u00ae Remote Displays SDK versiones anteriores a 2.0.1 R2, pueden permitir a un usuario autenticado activar potencialmente la escalada de privilegios por medio del acceso local."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiocoding:freeware_advanced_audio_decoder_2:2.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "BED01953-4703-4DDA-A93A-DE055A5C651D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00033.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Sep/28", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202006-17", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4522", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174"}}