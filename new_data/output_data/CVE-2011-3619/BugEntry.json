{"buggy_code": ["/*\n * AppArmor security module\n *\n * This file contains AppArmor LSM hooks.\n *\n * Copyright (C) 1998-2008 Novell/SUSE\n * Copyright 2009-2010 Canonical Ltd.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2 of the\n * License.\n */\n\n#include <linux/security.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/sysctl.h>\n#include <linux/audit.h>\n#include <linux/user_namespace.h>\n#include <net/sock.h>\n\n#include \"include/apparmor.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include \"include/capability.h\"\n#include \"include/context.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/procattr.h\"\n\n/* Flag indicating whether initialization completed */\nint apparmor_initialized __initdata;\n\n/*\n * LSM hook functions\n */\n\n/*\n * free the associated aa_task_cxt and put its profiles\n */\nstatic void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred->security);\n\tcred->security = NULL;\n}\n\n/*\n * allocate the apparmor part of blank credentials\n */\nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcred->security = cxt;\n\treturn 0;\n}\n\n/*\n * prepare new aa_task_cxt for modification by prepare_cred block\n */\nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\taa_dup_task_context(cxt, old->security);\n\tnew->security = cxt;\n\treturn 0;\n}\n\n/*\n * transfer the apparmor data to a blank set of creds\n */\nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct aa_task_cxt *old_cxt = old->security;\n\tstruct aa_task_cxt *new_cxt = new->security;\n\n\taa_dup_task_context(new_cxt, old_cxt);\n}\n\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\tint error = cap_ptrace_access_check(child, mode);\n\tif (error)\n\t\treturn error;\n\n\treturn aa_ptrace(current, child, mode);\n}\n\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\tint error = cap_ptrace_traceme(parent);\n\tif (error)\n\t\treturn error;\n\n\treturn aa_ptrace(parent, current, PTRACE_MODE_ATTACH);\n}\n\n/* Derived from security/commoncap.c:cap_capget */\nstatic int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_profile *profile;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tprofile = aa_cred_profile(cred);\n\n\t*effective = cred->cap_effective;\n\t*inheritable = cred->cap_inheritable;\n\t*permitted = cred->cap_permitted;\n\n\tif (!unconfined(profile)) {\n\t\t*effective = cap_intersect(*effective, profile->caps.allow);\n\t\t*permitted = cap_intersect(*permitted, profile->caps.allow);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int apparmor_capable(struct task_struct *task, const struct cred *cred,\n\t\t\t    struct user_namespace *ns, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\t/* cap_capable returns 0 on success, else -EPERM */\n\tint error = cap_capable(task, cred, ns, cap, audit);\n\tif (!error) {\n\t\tprofile = aa_cred_profile(cred);\n\t\tif (!unconfined(profile))\n\t\t\terror = aa_capable(task, profile, cap, audit);\n\t}\n\treturn error;\n}\n\n/**\n * common_perm - basic common permission check wrapper fn for paths\n * @op: operation being checked\n * @path: path to check permission of  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm(int op, struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tprofile = __aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_perm(op, profile, path, 0, mask, cond);\n\n\treturn error;\n}\n\n/**\n * common_perm_dir_dentry - common permission wrapper when path is dir, dentry\n * @op: operation being checked\n * @dir: directory of the dentry  (NOT NULL)\n * @dentry: dentry to check  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_dir_dentry(int op, struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { dir->mnt, dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}\n\n/**\n * common_perm_mnt_dentry - common permission wrapper when mnt, dentry\n * @op: operation being checked\n * @mnt: mount point of dentry (NOT NULL)\n * @dentry: dentry to check  (NOT NULL)\n * @mask: requested permissions mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_mnt_dentry(int op, struct vfsmount *mnt,\n\t\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct path path = { mnt, dentry };\n\tstruct path_cond cond = { dentry->d_inode->i_uid,\n\t\t\t\t  dentry->d_inode->i_mode\n\t};\n\n\treturn common_perm(op, &path, mask, &cond);\n}\n\n/**\n * common_perm_rm - common permission wrapper for operations doing rm\n * @op: operation being checked\n * @dir: directory that the dentry is in  (NOT NULL)\n * @dentry: dentry being rm'd  (NOT NULL)\n * @mask: requested permission mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_rm(int op, struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path_cond cond = { };\n\n\tif (!inode || !dir->mnt || !mediated_filesystem(inode))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\n/**\n * common_perm_create - common permission wrapper for operations doing create\n * @op: operation being checked\n * @dir: directory that dentry will be created in  (NOT NULL)\n * @dentry: dentry to create   (NOT NULL)\n * @mask: request permission mask\n * @mode: created file mode\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_create(int op, struct path *dir, struct dentry *dentry,\n\t\t\t      u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!dir->mnt || !mediated_filesystem(dir->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\nstatic int apparmor_path_unlink(struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mkdir(struct path *dir, struct dentry *dentry,\n\t\t\t       int mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}\n\nstatic int apparmor_path_rmdir(struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mknod(struct path *dir, struct dentry *dentry,\n\t\t\t       int mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}\n\nstatic int apparmor_path_truncate(struct path *path)\n{\n\tstruct path_cond cond = { path->dentry->d_inode->i_uid,\n\t\t\t\t  path->dentry->d_inode->i_mode\n\t};\n\n\tif (!path->mnt || !mediated_filesystem(path->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm(OP_TRUNC, path, MAY_WRITE | AA_MAY_META_WRITE,\n\t\t\t   &cond);\n}\n\nstatic int apparmor_path_symlink(struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}\n\nstatic int apparmor_path_link(struct dentry *old_dentry, struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry->d_inode))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_link(profile, old_dentry, new_dir, new_dentry);\n\treturn error;\n}\n\nstatic int apparmor_path_rename(struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tstruct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry->d_inode))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile)) {\n\t\tstruct path old_path = { old_dir->mnt, old_dentry };\n\t\tstruct path new_path = { new_dir->mnt, new_dentry };\n\t\tstruct path_cond cond = { old_dentry->d_inode->i_uid,\n\t\t\t\t\t  old_dentry->d_inode->i_mode\n\t\t};\n\n\t\terror = aa_path_perm(OP_RENAME_SRC, profile, &old_path, 0,\n\t\t\t\t     MAY_READ | AA_MAY_META_READ | MAY_WRITE |\n\t\t\t\t     AA_MAY_META_WRITE | AA_MAY_DELETE,\n\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, profile, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_META_WRITE |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\treturn error;\n}\n\nstatic int apparmor_path_chmod(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t       mode_t mode)\n{\n\tif (!mediated_filesystem(dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm_mnt_dentry(OP_CHMOD, mnt, dentry, AA_MAY_CHMOD);\n}\n\nstatic int apparmor_path_chown(struct path *path, uid_t uid, gid_t gid)\n{\n\tstruct path_cond cond =  { path->dentry->d_inode->i_uid,\n\t\t\t\t   path->dentry->d_inode->i_mode\n\t};\n\n\tif (!mediated_filesystem(path->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm(OP_CHOWN, path, AA_MAY_CHOWN, &cond);\n}\n\nstatic int apparmor_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tif (!mediated_filesystem(dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm_mnt_dentry(OP_GETATTR, mnt, dentry,\n\t\t\t\t      AA_MAY_META_READ);\n}\n\nstatic int apparmor_dentry_open(struct file *file, const struct cred *cred)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(file->f_path.dentry->d_inode))\n\t\treturn 0;\n\n\t/* If in exec, permission is handled by bprm hooks.\n\t * Cache permissions granted by the previous exec check, with\n\t * implicit read and executable mmap which are required to\n\t * actually execute the image.\n\t */\n\tif (current->in_execve) {\n\t\tfcxt->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tprofile = aa_cred_profile(cred);\n\tif (!unconfined(profile)) {\n\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\tstruct path_cond cond = { inode->i_uid, inode->i_mode };\n\n\t\terror = aa_path_perm(OP_OPEN, profile, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t/* todo cache full allowed permissions set and state */\n\t\tfcxt->allow = aa_map_file_to_perms(file);\n\t}\n\n\treturn error;\n}\n\nstatic int apparmor_file_alloc_security(struct file *file)\n{\n\t/* freed by apparmor_file_free_security */\n\tfile->f_security = aa_alloc_file_context(GFP_KERNEL);\n\tif (!file->f_security)\n\t\treturn -ENOMEM;\n\treturn 0;\n\n}\n\nstatic void apparmor_file_free_security(struct file *file)\n{\n\tstruct aa_file_cxt *cxt = file->f_security;\n\n\taa_free_file_context(cxt);\n}\n\nstatic int common_file_perm(int op, struct file *file, u32 mask)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile, *fprofile = aa_cred_profile(file->f_cred);\n\tint error = 0;\n\n\tBUG_ON(!fprofile);\n\n\tif (!file->f_path.mnt ||\n\t    !mediated_filesystem(file->f_path.dentry->d_inode))\n\t\treturn 0;\n\n\tprofile = __aa_current_profile();\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(fprofile) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tif (!unconfined(profile) && !unconfined(fprofile) &&\n\t    ((fprofile != profile) || (mask & ~fcxt->allow)))\n\t\terror = aa_file_perm(op, profile, file, mask);\n\n\treturn error;\n}\n\nstatic int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask);\n}\n\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask);\n}\n\nstatic int common_mmap(int op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tstruct dentry *dentry;\n\tint mask = 0;\n\n\tif (!file || !file->f_security)\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\tdentry = file->f_path.dentry;\n\treturn common_file_perm(op, file, mask);\n}\n\nstatic int apparmor_file_mmap(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long addr, unsigned long addr_only)\n{\n\tint rc = 0;\n\n\t/* do DAC check */\n\trc = cap_file_mmap(file, reqprot, prot, flags, addr, addr_only);\n\tif (rc || addr_only)\n\t\treturn rc;\n\n\treturn common_mmap(OP_FMMAP, file, prot, flags);\n}\n\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\n}\n\nstatic int apparmor_getprocattr(struct task_struct *task, char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\tstruct aa_profile *profile;\n\t/* released below */\n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_cxt *cxt = cred->security;\n\tprofile = aa_cred_profile(cred);\n\n\tif (strcmp(name, \"current\") == 0)\n\t\terror = aa_getprocattr(aa_newest_version(cxt->profile),\n\t\t\t\t       value);\n\telse if (strcmp(name, \"prev\") == 0  && cxt->previous)\n\t\terror = aa_getprocattr(aa_newest_version(cxt->previous),\n\t\t\t\t       value);\n\telse if (strcmp(name, \"exec\") == 0 && cxt->onexec)\n\t\terror = aa_getprocattr(aa_newest_version(cxt->onexec),\n\t\t\t\t       value);\n\telse\n\t\terror = -EINVAL;\n\n\tput_cred(cred);\n\n\treturn error;\n}\n\nstatic int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}\n\nstatic int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile = aa_current_profile();\n\tint error = 0;\n\n\tif (!unconfined(profile))\n\t\terror = aa_task_setrlimit(profile, task, resource, new_rlim);\n\n\treturn error;\n}\n\nstatic struct security_operations apparmor_ops = {\n\t.name =\t\t\t\t\"apparmor\",\n\n\t.ptrace_access_check =\t\tapparmor_ptrace_access_check,\n\t.ptrace_traceme =\t\tapparmor_ptrace_traceme,\n\t.capget =\t\t\tapparmor_capget,\n\t.capable =\t\t\tapparmor_capable,\n\n\t.path_link =\t\t\tapparmor_path_link,\n\t.path_unlink =\t\t\tapparmor_path_unlink,\n\t.path_symlink =\t\t\tapparmor_path_symlink,\n\t.path_mkdir =\t\t\tapparmor_path_mkdir,\n\t.path_rmdir =\t\t\tapparmor_path_rmdir,\n\t.path_mknod =\t\t\tapparmor_path_mknod,\n\t.path_rename =\t\t\tapparmor_path_rename,\n\t.path_chmod =\t\t\tapparmor_path_chmod,\n\t.path_chown =\t\t\tapparmor_path_chown,\n\t.path_truncate =\t\tapparmor_path_truncate,\n\t.dentry_open =\t\t\tapparmor_dentry_open,\n\t.inode_getattr =                apparmor_inode_getattr,\n\n\t.file_permission =\t\tapparmor_file_permission,\n\t.file_alloc_security =\t\tapparmor_file_alloc_security,\n\t.file_free_security =\t\tapparmor_file_free_security,\n\t.file_mmap =\t\t\tapparmor_file_mmap,\n\t.file_mprotect =\t\tapparmor_file_mprotect,\n\t.file_lock =\t\t\tapparmor_file_lock,\n\n\t.getprocattr =\t\t\tapparmor_getprocattr,\n\t.setprocattr =\t\t\tapparmor_setprocattr,\n\n\t.cred_alloc_blank =\t\tapparmor_cred_alloc_blank,\n\t.cred_free =\t\t\tapparmor_cred_free,\n\t.cred_prepare =\t\t\tapparmor_cred_prepare,\n\t.cred_transfer =\t\tapparmor_cred_transfer,\n\n\t.bprm_set_creds =\t\tapparmor_bprm_set_creds,\n\t.bprm_committing_creds =\tapparmor_bprm_committing_creds,\n\t.bprm_committed_creds =\t\tapparmor_bprm_committed_creds,\n\t.bprm_secureexec =\t\tapparmor_bprm_secureexec,\n\n\t.task_setrlimit =\t\tapparmor_task_setrlimit,\n};\n\n/*\n * AppArmor sysfs module parameters\n */\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\n#define param_check_aabool(name, p) __param_check(name, p, int)\nstatic struct kernel_param_ops param_ops_aabool = {\n\t.set = param_set_aabool,\n\t.get = param_get_aabool\n};\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\n#define param_check_aauint(name, p) __param_check(name, p, int)\nstatic struct kernel_param_ops param_ops_aauint = {\n\t.set = param_set_aauint,\n\t.get = param_get_aauint\n};\n\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\n#define param_check_aalockpolicy(name, p) __param_check(name, p, int)\nstatic struct kernel_param_ops param_ops_aalockpolicy = {\n\t.set = param_set_aalockpolicy,\n\t.get = param_get_aalockpolicy\n};\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, struct kernel_param *kp);\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, struct kernel_param *kp);\n\n/* Flag values, also controllable via /sys/module/apparmor/parameters\n * We define special types as we want to do additional mediation.\n */\n\n/* AppArmor global enforcement switch - complain, enforce, kill */\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nmodule_param_call(mode, param_set_mode, param_get_mode,\n\t\t  &aa_g_profile_mode, S_IRUSR | S_IWUSR);\n\n/* Debug mode */\nint aa_g_debug;\nmodule_param_named(debug, aa_g_debug, aabool, S_IRUSR | S_IWUSR);\n\n/* Audit mode */\nenum audit_mode aa_g_audit;\nmodule_param_call(audit, param_set_audit, param_get_audit,\n\t\t  &aa_g_audit, S_IRUSR | S_IWUSR);\n\n/* Determines if audit header is included in audited messages.  This\n * provides more context if the audit daemon is not running\n */\nint aa_g_audit_header = 1;\nmodule_param_named(audit_header, aa_g_audit_header, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* lock out loading/removal of policy\n * TODO: add in at boot loading of policy, which is the only way to\n *       load policy, if lock_policy is set\n */\nint aa_g_lock_policy;\nmodule_param_named(lock_policy, aa_g_lock_policy, aalockpolicy,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Syscall logging mode */\nint aa_g_logsyscall;\nmodule_param_named(logsyscall, aa_g_logsyscall, aabool, S_IRUSR | S_IWUSR);\n\n/* Maximum pathname length before accesses will start getting rejected */\nunsigned int aa_g_path_max = 2 * PATH_MAX;\nmodule_param_named(path_max, aa_g_path_max, aauint, S_IRUSR | S_IWUSR);\n\n/* Determines how paranoid loading of policy is and how much verification\n * on the loaded policy is done.\n */\nint aa_g_paranoid_load = 1;\nmodule_param_named(paranoid_load, aa_g_paranoid_load, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Boot time disable flag */\nstatic unsigned int apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\nmodule_param_named(enabled, apparmor_enabled, aabool, S_IRUSR);\n\nstatic int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = strict_strtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n\n__setup(\"apparmor=\", apparmor_enabled_setup);\n\n/* set global flag turning off the ability to load policy */\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (aa_g_lock_policy)\n\t\treturn -EACCES;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_uint(val, kp);\n}\n\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}\n\nstatic int param_get_audit(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\n\t\tif (strcmp(val, audit_mode_names[i]) == 0) {\n\t\t\taa_g_audit = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int param_get_mode(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", profile_mode_names[aa_g_profile_mode]);\n}\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < APPARMOR_NAMES_MAX_INDEX; i++) {\n\t\tif (strcmp(val, profile_mode_names[i]) == 0) {\n\t\t\taa_g_profile_mode = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n/*\n * AppArmor init functions\n */\n\n/**\n * set_init_cxt - set a task context and profile on the first task.\n *\n * TODO: allow setting an alternate profile than unconfined\n */\nstatic int __init set_init_cxt(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_cxt *cxt;\n\n\tcxt = aa_alloc_task_context(GFP_KERNEL);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcxt->profile = aa_get_profile(root_ns->unconfined);\n\tcred->security = cxt;\n\n\treturn 0;\n}\n\nstatic int __init apparmor_init(void)\n{\n\tint error;\n\n\tif (!apparmor_enabled || !security_module_enable(&apparmor_ops)) {\n\t\taa_info_message(\"AppArmor disabled by boot time parameter\");\n\t\tapparmor_enabled = 0;\n\t\treturn 0;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = set_init_cxt();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\tgoto register_security_out;\n\t}\n\n\terror = register_security(&apparmor_ops);\n\tif (error) {\n\t\tAA_ERROR(\"Unable to register AppArmor\\n\");\n\t\tgoto set_init_cxt_out;\n\t}\n\n\t/* Report that AppArmor successfully initialized */\n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nset_init_cxt_out:\n\taa_free_task_context(current->real_cred->security);\n\nregister_security_out:\n\taa_free_root_ns();\n\nalloc_out:\n\taa_destroy_aafs();\n\n\tapparmor_enabled = 0;\n\treturn error;\n}\n\nsecurity_initcall(apparmor_init);\n"], "fixing_code": ["/*\n * AppArmor security module\n *\n * This file contains AppArmor LSM hooks.\n *\n * Copyright (C) 1998-2008 Novell/SUSE\n * Copyright 2009-2010 Canonical Ltd.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2 of the\n * License.\n */\n\n#include <linux/security.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/sysctl.h>\n#include <linux/audit.h>\n#include <linux/user_namespace.h>\n#include <net/sock.h>\n\n#include \"include/apparmor.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include \"include/capability.h\"\n#include \"include/context.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/procattr.h\"\n\n/* Flag indicating whether initialization completed */\nint apparmor_initialized __initdata;\n\n/*\n * LSM hook functions\n */\n\n/*\n * free the associated aa_task_cxt and put its profiles\n */\nstatic void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred->security);\n\tcred->security = NULL;\n}\n\n/*\n * allocate the apparmor part of blank credentials\n */\nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcred->security = cxt;\n\treturn 0;\n}\n\n/*\n * prepare new aa_task_cxt for modification by prepare_cred block\n */\nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\taa_dup_task_context(cxt, old->security);\n\tnew->security = cxt;\n\treturn 0;\n}\n\n/*\n * transfer the apparmor data to a blank set of creds\n */\nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct aa_task_cxt *old_cxt = old->security;\n\tstruct aa_task_cxt *new_cxt = new->security;\n\n\taa_dup_task_context(new_cxt, old_cxt);\n}\n\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\tint error = cap_ptrace_access_check(child, mode);\n\tif (error)\n\t\treturn error;\n\n\treturn aa_ptrace(current, child, mode);\n}\n\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\tint error = cap_ptrace_traceme(parent);\n\tif (error)\n\t\treturn error;\n\n\treturn aa_ptrace(parent, current, PTRACE_MODE_ATTACH);\n}\n\n/* Derived from security/commoncap.c:cap_capget */\nstatic int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_profile *profile;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tprofile = aa_cred_profile(cred);\n\n\t*effective = cred->cap_effective;\n\t*inheritable = cred->cap_inheritable;\n\t*permitted = cred->cap_permitted;\n\n\tif (!unconfined(profile)) {\n\t\t*effective = cap_intersect(*effective, profile->caps.allow);\n\t\t*permitted = cap_intersect(*permitted, profile->caps.allow);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int apparmor_capable(struct task_struct *task, const struct cred *cred,\n\t\t\t    struct user_namespace *ns, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\t/* cap_capable returns 0 on success, else -EPERM */\n\tint error = cap_capable(task, cred, ns, cap, audit);\n\tif (!error) {\n\t\tprofile = aa_cred_profile(cred);\n\t\tif (!unconfined(profile))\n\t\t\terror = aa_capable(task, profile, cap, audit);\n\t}\n\treturn error;\n}\n\n/**\n * common_perm - basic common permission check wrapper fn for paths\n * @op: operation being checked\n * @path: path to check permission of  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm(int op, struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tprofile = __aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_perm(op, profile, path, 0, mask, cond);\n\n\treturn error;\n}\n\n/**\n * common_perm_dir_dentry - common permission wrapper when path is dir, dentry\n * @op: operation being checked\n * @dir: directory of the dentry  (NOT NULL)\n * @dentry: dentry to check  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_dir_dentry(int op, struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { dir->mnt, dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}\n\n/**\n * common_perm_mnt_dentry - common permission wrapper when mnt, dentry\n * @op: operation being checked\n * @mnt: mount point of dentry (NOT NULL)\n * @dentry: dentry to check  (NOT NULL)\n * @mask: requested permissions mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_mnt_dentry(int op, struct vfsmount *mnt,\n\t\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct path path = { mnt, dentry };\n\tstruct path_cond cond = { dentry->d_inode->i_uid,\n\t\t\t\t  dentry->d_inode->i_mode\n\t};\n\n\treturn common_perm(op, &path, mask, &cond);\n}\n\n/**\n * common_perm_rm - common permission wrapper for operations doing rm\n * @op: operation being checked\n * @dir: directory that the dentry is in  (NOT NULL)\n * @dentry: dentry being rm'd  (NOT NULL)\n * @mask: requested permission mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_rm(int op, struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path_cond cond = { };\n\n\tif (!inode || !dir->mnt || !mediated_filesystem(inode))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\n/**\n * common_perm_create - common permission wrapper for operations doing create\n * @op: operation being checked\n * @dir: directory that dentry will be created in  (NOT NULL)\n * @dentry: dentry to create   (NOT NULL)\n * @mask: request permission mask\n * @mode: created file mode\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_create(int op, struct path *dir, struct dentry *dentry,\n\t\t\t      u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!dir->mnt || !mediated_filesystem(dir->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\nstatic int apparmor_path_unlink(struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mkdir(struct path *dir, struct dentry *dentry,\n\t\t\t       int mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}\n\nstatic int apparmor_path_rmdir(struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mknod(struct path *dir, struct dentry *dentry,\n\t\t\t       int mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}\n\nstatic int apparmor_path_truncate(struct path *path)\n{\n\tstruct path_cond cond = { path->dentry->d_inode->i_uid,\n\t\t\t\t  path->dentry->d_inode->i_mode\n\t};\n\n\tif (!path->mnt || !mediated_filesystem(path->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm(OP_TRUNC, path, MAY_WRITE | AA_MAY_META_WRITE,\n\t\t\t   &cond);\n}\n\nstatic int apparmor_path_symlink(struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}\n\nstatic int apparmor_path_link(struct dentry *old_dentry, struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry->d_inode))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_link(profile, old_dentry, new_dir, new_dentry);\n\treturn error;\n}\n\nstatic int apparmor_path_rename(struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tstruct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry->d_inode))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile)) {\n\t\tstruct path old_path = { old_dir->mnt, old_dentry };\n\t\tstruct path new_path = { new_dir->mnt, new_dentry };\n\t\tstruct path_cond cond = { old_dentry->d_inode->i_uid,\n\t\t\t\t\t  old_dentry->d_inode->i_mode\n\t\t};\n\n\t\terror = aa_path_perm(OP_RENAME_SRC, profile, &old_path, 0,\n\t\t\t\t     MAY_READ | AA_MAY_META_READ | MAY_WRITE |\n\t\t\t\t     AA_MAY_META_WRITE | AA_MAY_DELETE,\n\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, profile, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_META_WRITE |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\treturn error;\n}\n\nstatic int apparmor_path_chmod(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t       mode_t mode)\n{\n\tif (!mediated_filesystem(dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm_mnt_dentry(OP_CHMOD, mnt, dentry, AA_MAY_CHMOD);\n}\n\nstatic int apparmor_path_chown(struct path *path, uid_t uid, gid_t gid)\n{\n\tstruct path_cond cond =  { path->dentry->d_inode->i_uid,\n\t\t\t\t   path->dentry->d_inode->i_mode\n\t};\n\n\tif (!mediated_filesystem(path->dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm(OP_CHOWN, path, AA_MAY_CHOWN, &cond);\n}\n\nstatic int apparmor_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tif (!mediated_filesystem(dentry->d_inode))\n\t\treturn 0;\n\n\treturn common_perm_mnt_dentry(OP_GETATTR, mnt, dentry,\n\t\t\t\t      AA_MAY_META_READ);\n}\n\nstatic int apparmor_dentry_open(struct file *file, const struct cred *cred)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(file->f_path.dentry->d_inode))\n\t\treturn 0;\n\n\t/* If in exec, permission is handled by bprm hooks.\n\t * Cache permissions granted by the previous exec check, with\n\t * implicit read and executable mmap which are required to\n\t * actually execute the image.\n\t */\n\tif (current->in_execve) {\n\t\tfcxt->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tprofile = aa_cred_profile(cred);\n\tif (!unconfined(profile)) {\n\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\tstruct path_cond cond = { inode->i_uid, inode->i_mode };\n\n\t\terror = aa_path_perm(OP_OPEN, profile, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t/* todo cache full allowed permissions set and state */\n\t\tfcxt->allow = aa_map_file_to_perms(file);\n\t}\n\n\treturn error;\n}\n\nstatic int apparmor_file_alloc_security(struct file *file)\n{\n\t/* freed by apparmor_file_free_security */\n\tfile->f_security = aa_alloc_file_context(GFP_KERNEL);\n\tif (!file->f_security)\n\t\treturn -ENOMEM;\n\treturn 0;\n\n}\n\nstatic void apparmor_file_free_security(struct file *file)\n{\n\tstruct aa_file_cxt *cxt = file->f_security;\n\n\taa_free_file_context(cxt);\n}\n\nstatic int common_file_perm(int op, struct file *file, u32 mask)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile, *fprofile = aa_cred_profile(file->f_cred);\n\tint error = 0;\n\n\tBUG_ON(!fprofile);\n\n\tif (!file->f_path.mnt ||\n\t    !mediated_filesystem(file->f_path.dentry->d_inode))\n\t\treturn 0;\n\n\tprofile = __aa_current_profile();\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(fprofile) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tif (!unconfined(profile) && !unconfined(fprofile) &&\n\t    ((fprofile != profile) || (mask & ~fcxt->allow)))\n\t\terror = aa_file_perm(op, profile, file, mask);\n\n\treturn error;\n}\n\nstatic int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask);\n}\n\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask);\n}\n\nstatic int common_mmap(int op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tstruct dentry *dentry;\n\tint mask = 0;\n\n\tif (!file || !file->f_security)\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\tdentry = file->f_path.dentry;\n\treturn common_file_perm(op, file, mask);\n}\n\nstatic int apparmor_file_mmap(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long addr, unsigned long addr_only)\n{\n\tint rc = 0;\n\n\t/* do DAC check */\n\trc = cap_file_mmap(file, reqprot, prot, flags, addr, addr_only);\n\tif (rc || addr_only)\n\t\treturn rc;\n\n\treturn common_mmap(OP_FMMAP, file, prot, flags);\n}\n\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\n}\n\nstatic int apparmor_getprocattr(struct task_struct *task, char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\tstruct aa_profile *profile;\n\t/* released below */\n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_cxt *cxt = cred->security;\n\tprofile = aa_cred_profile(cred);\n\n\tif (strcmp(name, \"current\") == 0)\n\t\terror = aa_getprocattr(aa_newest_version(cxt->profile),\n\t\t\t\t       value);\n\telse if (strcmp(name, \"prev\") == 0  && cxt->previous)\n\t\terror = aa_getprocattr(aa_newest_version(cxt->previous),\n\t\t\t\t       value);\n\telse if (strcmp(name, \"exec\") == 0 && cxt->onexec)\n\t\terror = aa_getprocattr(aa_newest_version(cxt->onexec),\n\t\t\t\t       value);\n\telse\n\t\terror = -EINVAL;\n\n\tput_cred(cred);\n\n\treturn error;\n}\n\nstatic int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED,\n\t\t\t\t\t__aa_current_profile(), GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}\n\nstatic int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile = aa_current_profile();\n\tint error = 0;\n\n\tif (!unconfined(profile))\n\t\terror = aa_task_setrlimit(profile, task, resource, new_rlim);\n\n\treturn error;\n}\n\nstatic struct security_operations apparmor_ops = {\n\t.name =\t\t\t\t\"apparmor\",\n\n\t.ptrace_access_check =\t\tapparmor_ptrace_access_check,\n\t.ptrace_traceme =\t\tapparmor_ptrace_traceme,\n\t.capget =\t\t\tapparmor_capget,\n\t.capable =\t\t\tapparmor_capable,\n\n\t.path_link =\t\t\tapparmor_path_link,\n\t.path_unlink =\t\t\tapparmor_path_unlink,\n\t.path_symlink =\t\t\tapparmor_path_symlink,\n\t.path_mkdir =\t\t\tapparmor_path_mkdir,\n\t.path_rmdir =\t\t\tapparmor_path_rmdir,\n\t.path_mknod =\t\t\tapparmor_path_mknod,\n\t.path_rename =\t\t\tapparmor_path_rename,\n\t.path_chmod =\t\t\tapparmor_path_chmod,\n\t.path_chown =\t\t\tapparmor_path_chown,\n\t.path_truncate =\t\tapparmor_path_truncate,\n\t.dentry_open =\t\t\tapparmor_dentry_open,\n\t.inode_getattr =                apparmor_inode_getattr,\n\n\t.file_permission =\t\tapparmor_file_permission,\n\t.file_alloc_security =\t\tapparmor_file_alloc_security,\n\t.file_free_security =\t\tapparmor_file_free_security,\n\t.file_mmap =\t\t\tapparmor_file_mmap,\n\t.file_mprotect =\t\tapparmor_file_mprotect,\n\t.file_lock =\t\t\tapparmor_file_lock,\n\n\t.getprocattr =\t\t\tapparmor_getprocattr,\n\t.setprocattr =\t\t\tapparmor_setprocattr,\n\n\t.cred_alloc_blank =\t\tapparmor_cred_alloc_blank,\n\t.cred_free =\t\t\tapparmor_cred_free,\n\t.cred_prepare =\t\t\tapparmor_cred_prepare,\n\t.cred_transfer =\t\tapparmor_cred_transfer,\n\n\t.bprm_set_creds =\t\tapparmor_bprm_set_creds,\n\t.bprm_committing_creds =\tapparmor_bprm_committing_creds,\n\t.bprm_committed_creds =\t\tapparmor_bprm_committed_creds,\n\t.bprm_secureexec =\t\tapparmor_bprm_secureexec,\n\n\t.task_setrlimit =\t\tapparmor_task_setrlimit,\n};\n\n/*\n * AppArmor sysfs module parameters\n */\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\n#define param_check_aabool(name, p) __param_check(name, p, int)\nstatic struct kernel_param_ops param_ops_aabool = {\n\t.set = param_set_aabool,\n\t.get = param_get_aabool\n};\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\n#define param_check_aauint(name, p) __param_check(name, p, int)\nstatic struct kernel_param_ops param_ops_aauint = {\n\t.set = param_set_aauint,\n\t.get = param_get_aauint\n};\n\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\n#define param_check_aalockpolicy(name, p) __param_check(name, p, int)\nstatic struct kernel_param_ops param_ops_aalockpolicy = {\n\t.set = param_set_aalockpolicy,\n\t.get = param_get_aalockpolicy\n};\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, struct kernel_param *kp);\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, struct kernel_param *kp);\n\n/* Flag values, also controllable via /sys/module/apparmor/parameters\n * We define special types as we want to do additional mediation.\n */\n\n/* AppArmor global enforcement switch - complain, enforce, kill */\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nmodule_param_call(mode, param_set_mode, param_get_mode,\n\t\t  &aa_g_profile_mode, S_IRUSR | S_IWUSR);\n\n/* Debug mode */\nint aa_g_debug;\nmodule_param_named(debug, aa_g_debug, aabool, S_IRUSR | S_IWUSR);\n\n/* Audit mode */\nenum audit_mode aa_g_audit;\nmodule_param_call(audit, param_set_audit, param_get_audit,\n\t\t  &aa_g_audit, S_IRUSR | S_IWUSR);\n\n/* Determines if audit header is included in audited messages.  This\n * provides more context if the audit daemon is not running\n */\nint aa_g_audit_header = 1;\nmodule_param_named(audit_header, aa_g_audit_header, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* lock out loading/removal of policy\n * TODO: add in at boot loading of policy, which is the only way to\n *       load policy, if lock_policy is set\n */\nint aa_g_lock_policy;\nmodule_param_named(lock_policy, aa_g_lock_policy, aalockpolicy,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Syscall logging mode */\nint aa_g_logsyscall;\nmodule_param_named(logsyscall, aa_g_logsyscall, aabool, S_IRUSR | S_IWUSR);\n\n/* Maximum pathname length before accesses will start getting rejected */\nunsigned int aa_g_path_max = 2 * PATH_MAX;\nmodule_param_named(path_max, aa_g_path_max, aauint, S_IRUSR | S_IWUSR);\n\n/* Determines how paranoid loading of policy is and how much verification\n * on the loaded policy is done.\n */\nint aa_g_paranoid_load = 1;\nmodule_param_named(paranoid_load, aa_g_paranoid_load, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Boot time disable flag */\nstatic unsigned int apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\nmodule_param_named(enabled, apparmor_enabled, aabool, S_IRUSR);\n\nstatic int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = strict_strtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n\n__setup(\"apparmor=\", apparmor_enabled_setup);\n\n/* set global flag turning off the ability to load policy */\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (aa_g_lock_policy)\n\t\treturn -EACCES;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_uint(val, kp);\n}\n\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}\n\nstatic int param_get_audit(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\n\t\tif (strcmp(val, audit_mode_names[i]) == 0) {\n\t\t\taa_g_audit = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int param_get_mode(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", profile_mode_names[aa_g_profile_mode]);\n}\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < APPARMOR_NAMES_MAX_INDEX; i++) {\n\t\tif (strcmp(val, profile_mode_names[i]) == 0) {\n\t\t\taa_g_profile_mode = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n/*\n * AppArmor init functions\n */\n\n/**\n * set_init_cxt - set a task context and profile on the first task.\n *\n * TODO: allow setting an alternate profile than unconfined\n */\nstatic int __init set_init_cxt(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_cxt *cxt;\n\n\tcxt = aa_alloc_task_context(GFP_KERNEL);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcxt->profile = aa_get_profile(root_ns->unconfined);\n\tcred->security = cxt;\n\n\treturn 0;\n}\n\nstatic int __init apparmor_init(void)\n{\n\tint error;\n\n\tif (!apparmor_enabled || !security_module_enable(&apparmor_ops)) {\n\t\taa_info_message(\"AppArmor disabled by boot time parameter\");\n\t\tapparmor_enabled = 0;\n\t\treturn 0;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = set_init_cxt();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\tgoto register_security_out;\n\t}\n\n\terror = register_security(&apparmor_ops);\n\tif (error) {\n\t\tAA_ERROR(\"Unable to register AppArmor\\n\");\n\t\tgoto set_init_cxt_out;\n\t}\n\n\t/* Report that AppArmor successfully initialized */\n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nset_init_cxt_out:\n\taa_free_task_context(current->real_cred->security);\n\nregister_security_out:\n\taa_free_root_ns();\n\nalloc_out:\n\taa_destroy_aafs();\n\n\tapparmor_enabled = 0;\n\treturn error;\n}\n\nsecurity_initcall(apparmor_init);\n"], "filenames": ["security/apparmor/lsm.c"], "buggy_code_start_loc": [596], "buggy_code_end_loc": [597], "fixing_code_start_loc": [596], "fixing_code_end_loc": [598], "type": "CWE-20", "message": "The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 3.0 does not properly handle invalid parameters, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by writing to a /proc/#####/attr/current file.", "other": {"cve": {"id": "CVE-2011-3619", "sourceIdentifier": "secalert@redhat.com", "published": "2013-06-08T13:05:55.190", "lastModified": "2023-02-13T04:32:40.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 3.0 does not properly handle invalid parameters, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by writing to a /proc/#####/attr/current file."}, {"lang": "es", "value": "La funci\u00f3n apparmor_setprocattr en security/apparmor/lsm.c de los kernel Linux anteriores a v3.0 no maneja adecuadamente los par\u00e1metros inv\u00e1lidos, permitiendo que usuarios locales provoquen una denegaci\u00f3n de servicio (referencia a puntero NULL y OOPS) o probablemente ocasionar otro impacto no especificado mediante la escritura en un fichero de /proc/#####/attr/current."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:rc7:*:*:*:*:*:*", "versionEndIncluding": "3.0", "matchCriteriaId": "C06621EF-286A-4BE7-BC41-8394E7CE429E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v3.0/ChangeLog-3.0", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a5b2c5b2ad5853591a6cac6134cd0f599a720865", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/10/17/6", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865"}}