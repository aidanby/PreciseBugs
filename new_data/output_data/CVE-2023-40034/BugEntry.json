{"buggy_code": ["// Copyright 2022 Woodpecker Authors\n// Copyright 2021 Informatyka Boguslawski sp. z o.o. sp.k., http://www.ib.pl/\n// Copyright 2018 Drone.IO Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file has been modified by Informatyka Boguslawski sp. z o.o. sp.k.\n\npackage api\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/rs/zerolog/log\"\n\n\t\"github.com/woodpecker-ci/woodpecker/server\"\n\t\"github.com/woodpecker-ci/woodpecker/server/forge/types\"\n\t\"github.com/woodpecker-ci/woodpecker/server/model\"\n\t\"github.com/woodpecker-ci/woodpecker/server/pipeline\"\n\t\"github.com/woodpecker-ci/woodpecker/server/store\"\n\t\"github.com/woodpecker-ci/woodpecker/shared/token\"\n)\n\nvar skipRe = regexp.MustCompile(`\\[(?i:ci *skip|skip *ci)\\]`)\n\n// GetQueueInfo\n//\n//\t@Summary\tGet pipeline queue information\n//\t@Description\tTODO: link the InfoT response object - this is blocked, until the `swaggo/swag` tool dependency is v1.18.12 or newer\n//\t@Router\t\t/queue/info [get]\n//\t@Produce\tjson\n//\t@Success\t200\t{object} map[string]string\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc GetQueueInfo(c *gin.Context) {\n\tc.IndentedJSON(http.StatusOK,\n\t\tserver.Config.Services.Queue.Info(c),\n\t)\n}\n\n// PauseQueue\n//\n//\t@Summary\tPause a pipeline queue\n//\t@Router\t\t/queue/pause [post]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc PauseQueue(c *gin.Context) {\n\tserver.Config.Services.Queue.Pause()\n\tc.Status(http.StatusOK)\n}\n\n// ResumeQueue\n//\n//\t@Summary\tResume a pipeline queue\n//\t@Router\t\t/queue/resume [post]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc ResumeQueue(c *gin.Context) {\n\tserver.Config.Services.Queue.Resume()\n\tc.Status(http.StatusOK)\n}\n\n// BlockTilQueueHasRunningItem\n//\n//\t@Summary\tBlock til pipeline queue has a running item\n//\t@Router\t\t/queue/norunningpipelines [get]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc BlockTilQueueHasRunningItem(c *gin.Context) {\n\tfor {\n\t\tinfo := server.Config.Services.Queue.Info(c)\n\t\tif info.Stats.Running == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tc.Status(http.StatusOK)\n}\n\n// PostHook\n//\n//\t@Summary\tIncoming webhook from forge\n//\t@Router\t\t/hook [post]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tSystem\n//\t@Param\t\thook\tbody\tobject\ttrue\t\"the webhook payload; forge is automatically detected\"\nfunc PostHook(c *gin.Context) {\n\t_store := store.FromContext(c)\n\tforge := server.Config.Services.Forge\n\n\ttmpRepo, tmpBuild, err := forge.Hook(c, c.Request)\n\tif err != nil {\n\t\tif errors.Is(err, &types.ErrIgnoreEvent{}) {\n\t\t\tmsg := fmt.Sprintf(\"forge driver: %s\", err)\n\t\t\tlog.Debug().Err(err).Msg(msg)\n\t\t\tc.String(http.StatusOK, msg)\n\t\t\treturn\n\t\t}\n\n\t\tmsg := \"failure to parse hook\"\n\t\tlog.Debug().Err(err).Msg(msg)\n\t\tc.String(http.StatusBadRequest, msg)\n\t\treturn\n\t}\n\n\tif tmpBuild == nil {\n\t\tmsg := \"ignoring hook: hook parsing resulted in empty pipeline\"\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusOK, msg)\n\t\treturn\n\t}\n\tif tmpRepo == nil {\n\t\tmsg := \"failure to ascertain repo from hook\"\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusBadRequest, msg)\n\t\treturn\n\t}\n\n\t// skip the tmpBuild if any case-insensitive combination of the words \"skip\" and \"ci\"\n\t// wrapped in square brackets appear in the commit message\n\tskipMatch := skipRe.FindString(tmpBuild.Message)\n\tif len(skipMatch) > 0 {\n\t\tmsg := fmt.Sprintf(\"ignoring hook: %s found in %s\", skipMatch, tmpBuild.Commit)\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\trepo, err := _store.GetRepoNameFallback(tmpRepo.ForgeRemoteID, tmpRepo.FullName)\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"failure to get repo %s from store\", tmpRepo.FullName)\n\t\tlog.Error().Err(err).Msg(msg)\n\t\tc.String(http.StatusNotFound, msg)\n\t\treturn\n\t}\n\tif !repo.IsActive {\n\t\tmsg := fmt.Sprintf(\"ignoring hook: repo %s is inactive\", tmpRepo.FullName)\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\toldFullName := repo.FullName\n\tif oldFullName != tmpRepo.FullName {\n\t\t// create a redirection\n\t\terr = _store.CreateRedirection(&model.Redirection{RepoID: repo.ID, FullName: repo.FullName})\n\t\tif err != nil {\n\t\t\t_ = c.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\trepo.Update(tmpRepo)\n\terr = _store.UpdateRepo(repo)\n\tif err != nil {\n\t\tc.String(http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// get the token and verify the hook is authorized\n\tparsed, err := token.ParseRequest(c.Request, func(_ *token.Token) (string, error) {\n\t\treturn repo.Hash, nil\n\t})\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"failure to parse token from hook for %s\", repo.FullName)\n\t\tlog.Error().Err(err).Msg(msg)\n\t\tc.String(http.StatusBadRequest, msg)\n\t\treturn\n\t}\n\tverifiedKey := parsed.Text == oldFullName\n\tif !verifiedKey {\n\t\tverifiedKey, err = _store.HasRedirectionForRepo(repo.ID, repo.FullName)\n\t\tif err != nil {\n\t\t\tmsg := \"failure to verify token from hook. Could not check for redirections of the repo\"\n\t\t\tlog.Error().Err(err).Msg(msg)\n\t\t\tc.String(http.StatusInternalServerError, msg)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif !verifiedKey {\n\t\tmsg := fmt.Sprintf(\"failure to verify token from hook. Expected %s, got %s\", repo.FullName, parsed.Text)\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusForbidden, msg)\n\t\treturn\n\t}\n\n\tif repo.UserID == 0 {\n\t\tmsg := fmt.Sprintf(\"ignoring hook. repo %s has no owner.\", repo.FullName)\n\t\tlog.Warn().Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\tif tmpBuild.Event == model.EventPull && !repo.AllowPull {\n\t\tmsg := \"ignoring hook: pull requests are disabled for this repo in woodpecker\"\n\t\tlog.Debug().Str(\"repo\", repo.FullName).Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\tpl, err := pipeline.Create(c, _store, repo, tmpBuild)\n\tif err != nil {\n\t\thandlePipelineErr(c, err)\n\t} else {\n\t\tc.JSON(http.StatusOK, pl)\n\t}\n}\n"], "fixing_code": ["// Copyright 2022 Woodpecker Authors\n// Copyright 2021 Informatyka Boguslawski sp. z o.o. sp.k., http://www.ib.pl/\n// Copyright 2018 Drone.IO Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// This file has been modified by Informatyka Boguslawski sp. z o.o. sp.k.\n\npackage api\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/rs/zerolog/log\"\n\n\t\"github.com/woodpecker-ci/woodpecker/server\"\n\t\"github.com/woodpecker-ci/woodpecker/server/forge/types\"\n\t\"github.com/woodpecker-ci/woodpecker/server/model\"\n\t\"github.com/woodpecker-ci/woodpecker/server/pipeline\"\n\t\"github.com/woodpecker-ci/woodpecker/server/store\"\n\t\"github.com/woodpecker-ci/woodpecker/shared/token\"\n)\n\nvar skipRe = regexp.MustCompile(`\\[(?i:ci *skip|skip *ci)\\]`)\n\n// GetQueueInfo\n//\n//\t@Summary\tGet pipeline queue information\n//\t@Description\tTODO: link the InfoT response object - this is blocked, until the `swaggo/swag` tool dependency is v1.18.12 or newer\n//\t@Router\t\t/queue/info [get]\n//\t@Produce\tjson\n//\t@Success\t200\t{object} map[string]string\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc GetQueueInfo(c *gin.Context) {\n\tc.IndentedJSON(http.StatusOK,\n\t\tserver.Config.Services.Queue.Info(c),\n\t)\n}\n\n// PauseQueue\n//\n//\t@Summary\tPause a pipeline queue\n//\t@Router\t\t/queue/pause [post]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc PauseQueue(c *gin.Context) {\n\tserver.Config.Services.Queue.Pause()\n\tc.Status(http.StatusOK)\n}\n\n// ResumeQueue\n//\n//\t@Summary\tResume a pipeline queue\n//\t@Router\t\t/queue/resume [post]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc ResumeQueue(c *gin.Context) {\n\tserver.Config.Services.Queue.Resume()\n\tc.Status(http.StatusOK)\n}\n\n// BlockTilQueueHasRunningItem\n//\n//\t@Summary\tBlock til pipeline queue has a running item\n//\t@Router\t\t/queue/norunningpipelines [get]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tPipeline queues\n//\t@Param\t\tAuthorization\theader\tstring\ttrue\t\"Insert your personal access token\"\tdefault(Bearer <personal access token>)\nfunc BlockTilQueueHasRunningItem(c *gin.Context) {\n\tfor {\n\t\tinfo := server.Config.Services.Queue.Info(c)\n\t\tif info.Stats.Running == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tc.Status(http.StatusOK)\n}\n\n// PostHook\n//\n//\t@Summary\tIncoming webhook from forge\n//\t@Router\t\t/hook [post]\n//\t@Produce\tplain\n//\t@Success\t200\n//\t@Tags\t\tSystem\n//\t@Param\t\thook\tbody\tobject\ttrue\t\"the webhook payload; forge is automatically detected\"\nfunc PostHook(c *gin.Context) {\n\t_store := store.FromContext(c)\n\tforge := server.Config.Services.Forge\n\n\t//\n\t// 1. Parse webhook\n\t//\n\n\ttmpRepo, tmpBuild, err := forge.Hook(c, c.Request)\n\tif err != nil {\n\t\tif errors.Is(err, &types.ErrIgnoreEvent{}) {\n\t\t\tmsg := fmt.Sprintf(\"forge driver: %s\", err)\n\t\t\tlog.Debug().Err(err).Msg(msg)\n\t\t\tc.String(http.StatusOK, msg)\n\t\t\treturn\n\t\t}\n\n\t\tmsg := \"failure to parse hook\"\n\t\tlog.Debug().Err(err).Msg(msg)\n\t\tc.String(http.StatusBadRequest, msg)\n\t\treturn\n\t}\n\n\tif tmpBuild == nil {\n\t\tmsg := \"ignoring hook: hook parsing resulted in empty pipeline\"\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusOK, msg)\n\t\treturn\n\t}\n\tif tmpRepo == nil {\n\t\tmsg := \"failure to ascertain repo from hook\"\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusBadRequest, msg)\n\t\treturn\n\t}\n\n\t//\n\t// Skip if commit message contains skip-ci\n\t// TODO: move into global pipeline conditions logic\n\t//\n\n\t// skip the tmpBuild if any case-insensitive combination of the words \"skip\" and \"ci\"\n\t// wrapped in square brackets appear in the commit message\n\tskipMatch := skipRe.FindString(tmpBuild.Message)\n\tif len(skipMatch) > 0 {\n\t\tmsg := fmt.Sprintf(\"ignoring hook: %s found in %s\", skipMatch, tmpBuild.Commit)\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\t//\n\t// 2. Get related repo from store and take repo renaming into account\n\t//\n\n\trepo, err := _store.GetRepoNameFallback(tmpRepo.ForgeRemoteID, tmpRepo.FullName)\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"failure to get repo %s from store\", tmpRepo.FullName)\n\t\tlog.Error().Err(err).Msg(msg)\n\t\tc.String(http.StatusNotFound, msg)\n\t\treturn\n\t}\n\tif !repo.IsActive {\n\t\tmsg := fmt.Sprintf(\"ignoring hook: repo %s is inactive\", tmpRepo.FullName)\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\toldFullName := repo.FullName\n\n\tif repo.UserID == 0 {\n\t\tmsg := fmt.Sprintf(\"ignoring hook. repo %s has no owner.\", repo.FullName)\n\t\tlog.Warn().Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\t//\n\t// 3. Check if the webhook is a valid and authorized one\n\t//\n\n\t// get the token and verify the hook is authorized\n\tparsed, err := token.ParseRequest(c.Request, func(_ *token.Token) (string, error) {\n\t\treturn repo.Hash, nil\n\t})\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"failure to parse token from hook for %s\", repo.FullName)\n\t\tlog.Error().Err(err).Msg(msg)\n\t\tc.String(http.StatusBadRequest, msg)\n\t\treturn\n\t}\n\tverifiedKey := parsed.Text == oldFullName\n\tif !verifiedKey {\n\t\tverifiedKey, err = _store.HasRedirectionForRepo(repo.ID, repo.FullName)\n\t\tif err != nil {\n\t\t\tmsg := \"failure to verify token from hook. Could not check for redirections of the repo\"\n\t\t\tlog.Error().Err(err).Msg(msg)\n\t\t\tc.String(http.StatusInternalServerError, msg)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif !verifiedKey {\n\t\tmsg := fmt.Sprintf(\"failure to verify token from hook. Expected %s, got %s\", repo.FullName, parsed.Text)\n\t\tlog.Debug().Msg(msg)\n\t\tc.String(http.StatusForbidden, msg)\n\t\treturn\n\t}\n\n\t//\n\t// 4. Update repo\n\t//\n\n\tif oldFullName != tmpRepo.FullName {\n\t\t// create a redirection\n\t\terr = _store.CreateRedirection(&model.Redirection{RepoID: repo.ID, FullName: repo.FullName})\n\t\tif err != nil {\n\t\t\t_ = c.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\trepo.Update(tmpRepo)\n\terr = _store.UpdateRepo(repo)\n\tif err != nil {\n\t\tc.String(http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t//\n\t// 5. Check if pull requests are allowed for this repo\n\t//\n\n\tif tmpBuild.Event == model.EventPull && !repo.AllowPull {\n\t\tmsg := \"ignoring hook: pull requests are disabled for this repo in woodpecker\"\n\t\tlog.Debug().Str(\"repo\", repo.FullName).Msg(msg)\n\t\tc.String(http.StatusNoContent, msg)\n\t\treturn\n\t}\n\n\t//\n\t// 6. Finally create a pipeline\n\t//\n\n\tpl, err := pipeline.Create(c, _store, repo, tmpBuild)\n\tif err != nil {\n\t\thandlePipelineErr(c, err)\n\t} else {\n\t\tc.JSON(http.StatusOK, pl)\n\t}\n}\n"], "filenames": ["server/api/hook.go"], "buggy_code_start_loc": [110], "buggy_code_end_loc": [221], "fixing_code_start_loc": [111], "fixing_code_end_loc": [251], "type": "NVD-CWE-noinfo", "message": "Woodpecker is a community fork of the Drone CI system. In affected versions an attacker can post malformed webhook data witch lead to an update of the repository data that can e.g. allow the takeover of an repo. This is only critical if the CI is configured for public usage and connected to a forge witch is also in public usage. This issue has been addressed in version 1.0.2. Users are advised to upgrade. Users unable to upgrade should secure the CI system by making it inaccessible to untrusted entities, for example, by placing it behind a firewall.", "other": {"cve": {"id": "CVE-2023-40034", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-16T21:15:10.087", "lastModified": "2023-08-25T17:43:47.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Woodpecker is a community fork of the Drone CI system. In affected versions an attacker can post malformed webhook data witch lead to an update of the repository data that can e.g. allow the takeover of an repo. This is only critical if the CI is configured for public usage and connected to a forge witch is also in public usage. This issue has been addressed in version 1.0.2. Users are advised to upgrade. Users unable to upgrade should secure the CI system by making it inaccessible to untrusted entities, for example, by placing it behind a firewall."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:woodpecker-ci:woodpecker:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.0.2", "matchCriteriaId": "1EFD3D08-B24D-4822-9C72-C4FA7DF5CE84"}]}]}], "references": [{"url": "https://github.com/woodpecker-ci/woodpecker/commit/6e4c2f84cc84661d58cf1c0e5c421a46070bb105", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/woodpecker-ci/woodpecker/pull/2221", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/woodpecker-ci/woodpecker/pull/2222", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/woodpecker-ci/woodpecker/security/advisories/GHSA-4gcf-5m39-98mc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/woodpecker-ci/woodpecker/commit/6e4c2f84cc84661d58cf1c0e5c421a46070bb105"}}