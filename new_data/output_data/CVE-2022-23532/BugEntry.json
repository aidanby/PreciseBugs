{"buggy_code": ["package apoc.export.csv;\n\nimport apoc.ApocConfig;\nimport apoc.Pools;\nimport apoc.export.cypher.ExportFileManager;\nimport apoc.export.cypher.FileManagerFactory;\nimport apoc.export.util.ExportConfig;\nimport apoc.export.util.ExportUtils;\nimport apoc.export.util.NodesAndRelsSubGraph;\nimport apoc.export.util.ProgressReporter;\nimport apoc.result.ProgressInfo;\nimport apoc.util.Util;\nimport org.neo4j.cypher.export.DatabaseSubGraph;\nimport org.neo4j.cypher.export.SubGraph;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Node;\nimport org.neo4j.graphdb.Relationship;\nimport org.neo4j.graphdb.Result;\nimport org.neo4j.graphdb.Transaction;\nimport org.neo4j.procedure.Context;\nimport org.neo4j.procedure.Description;\nimport org.neo4j.procedure.Name;\nimport org.neo4j.procedure.Procedure;\nimport org.neo4j.procedure.TerminationGuard;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\n/**\n * @author mh\n * @since 22.05.16\n */\npublic class ExportCSV {\n    @Context\n    public Transaction tx;\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public TerminationGuard terminationGuard;\n\n    @Context\n    public ApocConfig apocConfig;\n\n    @Context\n    public Pools pools;\n\n    public ExportCSV() {\n    }\n\n    @Procedure\n    @Description(\"apoc.export.csv.all(file,config) - exports whole database as csv to the provided file\")\n    public Stream<ProgressInfo> all(@Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        String source = String.format(\"database: nodes(%d), rels(%d)\", Util.nodeCount(tx), Util.relCount(tx));\n        return exportCsv(fileName, source, new DatabaseSubGraph(tx), new ExportConfig(config));\n    }\n\n    @Procedure\n    @Description(\"apoc.export.csv.data(nodes,rels,file,config) - exports given nodes and relationships as csv to the provided file\")\n    public Stream<ProgressInfo> data(@Name(\"nodes\") List<Node> nodes, @Name(\"rels\") List<Relationship> rels, @Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        ExportConfig exportConfig = new ExportConfig(config);\n        preventBulkImport(exportConfig);\n        String source = String.format(\"data: nodes(%d), rels(%d)\", nodes.size(), rels.size());\n        return exportCsv(fileName, source, new NodesAndRelsSubGraph(tx, nodes, rels), exportConfig);\n    }\n    @Procedure\n    @Description(\"apoc.export.csv.graph(graph,file,config) - exports given graph object as csv to the provided file\")\n    public Stream<ProgressInfo> graph(@Name(\"graph\") Map<String,Object> graph, @Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        Collection<Node> nodes = (Collection<Node>) graph.get(\"nodes\");\n        Collection<Relationship> rels = (Collection<Relationship>) graph.get(\"relationships\");\n        String source = String.format(\"graph: nodes(%d), rels(%d)\", nodes.size(), rels.size());\n        return exportCsv(fileName, source, new NodesAndRelsSubGraph(tx, nodes, rels), new ExportConfig(config));\n    }\n\n    @Procedure\n    @Description(\"apoc.export.csv.query(query,file,{config,...,params:{params}}) - exports results from the cypher statement as csv to the provided file\")\n    public Stream<ProgressInfo> query(@Name(\"query\") String query, @Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        ExportConfig exportConfig = new ExportConfig(config);\n        preventBulkImport(exportConfig);\n        Map<String,Object> params = config == null ? Collections.emptyMap() : (Map<String,Object>)config.getOrDefault(\"params\", Collections.emptyMap());\n        Result result = tx.execute(query,params);\n\n        String source = String.format(\"statement: cols(%d)\", result.columns().size());\n        return exportCsv(fileName, source,result, exportConfig);\n    }\n\n    private void preventBulkImport(ExportConfig config) {\n        if (config.isBulkImport()) {\n            throw new RuntimeException(\"You can use the `bulkImport` only with apoc.export.all and apoc.export.csv.graph\");\n        }\n    }\n\n    private Stream<ProgressInfo> exportCsv(@Name(\"file\") String fileName, String source, Object data, ExportConfig exportConfig) throws Exception {\n        apocConfig.checkWriteAllowed(exportConfig, fileName);\n        final String format = \"csv\";\n        ProgressInfo progressInfo = new ProgressInfo(fileName, source, format);\n        progressInfo.batchSize = exportConfig.getBatchSize();\n        ProgressReporter reporter = new ProgressReporter(null, null, progressInfo);\n        CsvFormat exporter = new CsvFormat(db);\n\n        ExportFileManager cypherFileManager = FileManagerFactory\n                .createFileManager(fileName, exportConfig.isBulkImport(), exportConfig);\n\n        if (exportConfig.streamStatements()) {\n            return ExportUtils.getProgressInfoStream(db, pools.getDefaultExecutorService(), terminationGuard, format, exportConfig, reporter, cypherFileManager,\n                    (reporterWithConsumer) -> dump(data, exportConfig, reporterWithConsumer, cypherFileManager, exporter));\n        } else {\n            dump(data, exportConfig, reporter, cypherFileManager, exporter);\n            return reporter.stream();\n        }\n    }\n\n    private void dump(Object data, ExportConfig c, ProgressReporter reporter, ExportFileManager printWriter, CsvFormat exporter) {\n        if (data instanceof SubGraph)\n            exporter.dump((SubGraph)data,printWriter,reporter,c);\n        if (data instanceof Result)\n            exporter.dump((Result)data,printWriter,reporter,c);\n    }\n}\n", "package apoc.util;\n\nimport apoc.ApocConfig;\nimport apoc.export.util.CountingInputStream;\nimport apoc.export.util.CountingReader;\nimport apoc.export.util.ExportConfig;\nimport apoc.util.hdfs.HDFSUtils;\nimport apoc.util.s3.S3URLConnection;\nimport apoc.util.s3.S3UploadUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.configuration.GraphDatabaseSettings;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLStreamHandler;\nimport java.net.URLStreamHandlerFactory;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport static apoc.ApocConfig.APOC_IMPORT_FILE_ALLOW__READ__FROM__FILESYSTEM;\nimport static apoc.ApocConfig.apocConfig;\nimport static apoc.util.Util.ERROR_BYTES_OR_STRING;\nimport static apoc.util.Util.REDIRECT_LIMIT;\nimport static apoc.util.Util.readHttpInputStream;\n\n/**\n * @author mh\n * @since 22.05.16\n */\npublic class FileUtils {\n\n    public enum SupportedProtocols {\n        http(true, null),\n        https(true, null),\n        ftp(true, null),\n        s3(Util.classExists(\"com.amazonaws.services.s3.AmazonS3\"),\n                \"apoc.util.s3.S3UrlStreamHandlerFactory\"),\n        gs(Util.classExists(\"com.google.cloud.storage.Storage\"),\n                \"apoc.util.google.cloud.GCStorageURLStreamHandlerFactory\"),\n        hdfs(Util.classExists(\"org.apache.hadoop.fs.FileSystem\"),\n                \"org.apache.hadoop.fs.FsUrlStreamHandlerFactory\"),\n        file(true, null);\n\n        private final boolean enabled;\n\n        private final String urlStreamHandlerClassName;\n\n        SupportedProtocols(boolean enabled, String urlStreamHandlerClassName) {\n            this.enabled = enabled;\n            this.urlStreamHandlerClassName = urlStreamHandlerClassName;\n        }\n\n        public StreamConnection getStreamConnection(String urlAddress, Map<String, Object> headers, String payload) throws IOException {\n            switch (this) {\n                case s3:\n                    return FileUtils.openS3InputStream(urlAddress);\n                case hdfs:\n                    return FileUtils.openHdfsInputStream(urlAddress);\n                case ftp:\n                case http:\n                case https:\n                case gs:\n                    return readHttpInputStream(urlAddress, headers, payload, REDIRECT_LIMIT);\n                default:\n                    try {\n                        return new StreamConnection.FileStreamConnection(URI.create(urlAddress));\n                    } catch (IllegalArgumentException iae) {\n                        try {\n                            return new StreamConnection.FileStreamConnection(new URL(urlAddress).getFile());\n                        } catch (MalformedURLException mue) {\n                            if (mue.getMessage().contains(\"no protocol\")) {\n                                return new StreamConnection.FileStreamConnection(urlAddress);\n                            }\n                            throw mue;\n                        }\n                    }\n            }\n        }\n\n        public OutputStream getOutputStream(String fileName, ExportConfig config) {\n            if (fileName == null) return null;\n            final CompressionAlgo compressionAlgo = CompressionAlgo.valueOf(config.getCompressionAlgo());\n            final OutputStream outputStream;\n            try {\n                switch (this) {\n                    case s3:\n                        outputStream = S3UploadUtils.writeFile(fileName);\n                        break;\n                    case hdfs:\n                        outputStream = HDFSUtils.writeFile(fileName);\n                        break;\n                    default:\n                        final Path path = resolvePath(fileName);\n                        outputStream = new FileOutputStream(path.toFile());\n                }\n                return new BufferedOutputStream(compressionAlgo.getOutputStream(outputStream));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean isEnabled() {\n            return enabled;\n        }\n\n        public URLStreamHandler createURLStreamHandler() {\n            return Optional.ofNullable(urlStreamHandlerClassName)\n                    .map(Util::createInstanceOrNull)\n                    .map(urlStreamHandlerFactory -> ((URLStreamHandlerFactory) urlStreamHandlerFactory).createURLStreamHandler(this.name()))\n                    .orElse(null);\n        }\n\n        public static SupportedProtocols from(String source) {\n            try {\n                final URL url = new URL(source);\n                return from(url);\n            } catch (MalformedURLException e) {\n                if (!e.getMessage().contains(\"no protocol\")) {\n                    try {\n                        // in case new URL(source) throw e.g. unknown protocol: hdfs, because of missing jar, \n                        // we retrieve the related enum and throw the associated MissingDependencyException(..)\n                        // otherwise we return unknown protocol: yyyyy\n                        return SupportedProtocols.valueOf(new URI(source).getScheme());\n                    } catch (Exception ignored) {}\n                    throw new RuntimeException(e);\n                }\n                return SupportedProtocols.file;\n            }\n        }\n\n        public static SupportedProtocols from(URL url) {\n            return SupportedProtocols.of(url.getProtocol());\n        }\n\n        public static SupportedProtocols of(String name) {\n            try {\n                return SupportedProtocols.valueOf(name);\n            } catch (Exception e) {\n                return file;\n            }\n        }\n\n    }\n\n    public static final String ERROR_READ_FROM_FS_NOT_ALLOWED = \"Import file %s not enabled, please set \" + APOC_IMPORT_FILE_ALLOW__READ__FROM__FILESYSTEM + \"=true in your neo4j.conf\";\n    public static final String ACCESS_OUTSIDE_DIR_ERROR = \"You're providing a directory outside the import directory \" +\n            \"defined into `dbms.directories.import`\";\n\n    public static CountingReader readerFor(Object input) throws IOException {\n        return readerFor(input, null, null, CompressionAlgo.NONE.name());\n    }\n\n    public static CountingReader readerFor(Object input, String compressionAlgo) throws IOException {\n        return readerFor(input, null, null, compressionAlgo);\n    }\n\n    public static CountingReader readerFor(Object input, Map<String, Object> headers, String payload, String compressionAlgo) throws IOException {\n        return inputStreamFor(input, headers, payload, compressionAlgo).asReader();\n    }\n\n    public static CountingInputStream inputStreamFor(Object input, Map<String, Object> headers, String payload, String compressionAlgo) throws IOException {\n        if (input == null) return null;\n        if (input instanceof String) {\n            String fileName = (String) input;\n            apocConfig().checkReadAllowed(fileName);\n            fileName = changeFileUrlIfImportDirectoryConstrained(fileName);\n            return Util.openInputStream(fileName, headers, payload, compressionAlgo);\n        } else if (input instanceof byte[]) {\n            return getInputStreamFromBinary((byte[]) input, compressionAlgo);\n        } else {\n            throw new RuntimeException(ERROR_BYTES_OR_STRING);\n        }\n    }\n    \n    public static String changeFileUrlIfImportDirectoryConstrained(String url) throws IOException {\n        if (isFile(url) && isImportUsingNeo4jConfig()) {\n            if (!apocConfig().getBoolean(APOC_IMPORT_FILE_ALLOW__READ__FROM__FILESYSTEM)) {\n                throw new RuntimeException(String.format(ERROR_READ_FROM_FS_NOT_ALLOWED, url));\n            }\n            final Path resolvedPath = resolvePath(url);\n            return resolvedPath\n                    .normalize()\n                    .toUri()\n                    .toString();\n        }\n        return url;\n    }\n\n    private static Path resolvePath(String url) throws IOException {\n        Path urlPath = getPath(url);\n        final Path resolvedPath;\n        if (apocConfig().isImportFolderConfigured() && isImportUsingNeo4jConfig()) {\n            Path basePath = Paths.get(apocConfig().getImportDir());\n            urlPath = relativizeIfSamePrefix(urlPath, basePath);\n            resolvedPath = basePath.resolve(urlPath).toAbsolutePath().normalize();\n            if (!pathStartsWithOther(resolvedPath, basePath)) {\n                throw new IOException(ACCESS_OUTSIDE_DIR_ERROR);\n            }\n        } else {\n            resolvedPath = urlPath;\n        }\n        return resolvedPath;\n    }\n\n    private static Path relativizeIfSamePrefix(Path urlPath, Path basePath) {\n        if (FilenameUtils.getPrefixLength(urlPath.toString()) > 0 && !urlPath.startsWith(basePath.toAbsolutePath())) {\n            // if the import folder is configured to be used as root folder we consider\n            // it as root directory in order to reproduce the same LOAD CSV behaviour\n            urlPath = urlPath.getRoot().relativize(urlPath);\n        }\n        return urlPath;\n    }\n\n    private static Path getPath(String url) {\n        Path urlPath;\n        URL toURL = null;\n        try {\n            final URI uri = URI.create(url.trim());\n            toURL = uri.toURL();\n            urlPath = Paths.get(uri);\n        } catch (Exception e) {\n            if (toURL != null) {\n                urlPath = Paths.get(StringUtils.isBlank(toURL.getFile()) ? toURL.getHost() : toURL.getFile());\n            } else {\n                urlPath = Paths.get(url);\n            }\n        }\n        return urlPath;\n    }\n\n    private static boolean pathStartsWithOther(Path resolvedPath, Path basePath) throws IOException {\n        try {\n            return resolvedPath.toRealPath().startsWith(basePath.toRealPath());\n        } catch (Exception e) {\n            if (e instanceof NoSuchFileException) { // If we're about to creating a file this exception has been thrown\n                return resolvedPath.normalize().startsWith(basePath);\n            }\n            return false;\n        }\n    }\n\n    public static boolean isFile(String fileName) {\n        return SupportedProtocols.from(fileName) == SupportedProtocols.file;\n    }\n\n    public static OutputStream getOutputStream(String fileName) {\n        return getOutputStream(fileName, ExportConfig.EMPTY);\n    }\n\n    public static OutputStream getOutputStream(String fileName, ExportConfig config) {\n        if (fileName.equals(\"-\")) {\n            return null;\n        }\n        return SupportedProtocols.from(fileName).getOutputStream(fileName, config);\n    }\n\n    public static boolean isImportUsingNeo4jConfig() {\n        return apocConfig().getBoolean(ApocConfig.APOC_IMPORT_FILE_USE_NEO4J_CONFIG);\n    }\n\n    public static StreamConnection openS3InputStream(String urlAddress) throws IOException {\n        if (!SupportedProtocols.s3.isEnabled()) {\n            throw new MissingDependencyException(\"Cannot find the S3 jars in the plugins folder. \\n\" +\n                    \"Please put these files into the plugins folder :\\n\\n\" +\n                    \"aws-java-sdk-core-x.y.z.jar\\n\" +\n                    \"aws-java-sdk-s3-x.y.z.jar\\n\" +\n                    \"httpclient-x.y.z.jar\\n\" +\n                    \"httpcore-x.y.z.jar\\n\" +\n                    \"joda-time-x.y.z.jar\\n\" +\n                    \"\\nSee the documentation: https://neo4j-contrib.github.io/neo4j-apoc-procedures/#_loading_data_from_web_apis_json_xml_csv\");\n        }\n        return S3URLConnection.openS3InputStream(new URL(urlAddress));\n    }\n\n    public static StreamConnection openHdfsInputStream(String urlAddress) throws IOException {\n        if (!SupportedProtocols.hdfs.isEnabled()) {\n            throw new MissingDependencyException(\"Cannot find the HDFS/Hadoop jars in the plugins folder. \\n\" +\n                    \"\\nPlease, see the documentation: https://neo4j.com/labs/apoc/4.4/import/web-apis/\");\n        }\n        return HDFSUtils.readFile(new URL(urlAddress));\n    }\n\n    /**\n     * @return a File pointing to Neo4j's log directory, if it exists and is readable, null otherwise.\n     */\n    public static File getLogDirectory() {\n        String neo4jHome = apocConfig().getString(\"dbms.directories.neo4j_home\", \"\");\n        String logDir = apocConfig().getString(\"dbms.directories.logs\", \"\");\n\n        File logs = logDir.isEmpty() ? new File(neo4jHome, \"logs\") : new File(logDir);\n\n        if (logs.exists() && logs.canRead() && logs.isDirectory()) {\n            return logs;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return a File representing the metrics directory that is listable and readable, or null if metrics don't exist,\n     * aren't enabled, or aren't readable.\n     */\n    public static File getMetricsDirectory() {\n        String neo4jHome = apocConfig().getString(GraphDatabaseSettings.neo4j_home.name());\n        String metricsSetting = apocConfig().getString(\"dbms.directories.metrics\", neo4jHome + File.separator + \"metrics\");\n\n        File metricsDir = metricsSetting.isEmpty() ? new File(neo4jHome, \"metrics\") : new File(metricsSetting);\n\n        if (metricsDir.exists() && metricsDir.canRead() && metricsDir.isDirectory() ) {\n            return metricsDir;\n        }\n\n        return null;\n    }\n\n    // This is the list of dbms.directories.* valid configuration items for neo4j.\n    // https://neo4j.com/docs/operations-manual/current/reference/configuration-settings/\n    // Usually these reside under the same root but because they're separately configurable, in the worst case\n    // every one is on a different device.\n    //\n    // More likely, they'll be largely similar metrics.\n    public static final List<String> NEO4J_DIRECTORY_CONFIGURATION_SETTING_NAMES = Arrays.asList(\n//            \"dbms.directories.certificates\",  // not in 4.x version\n            \"dbms.directories.data\",\n            \"dbms.directories.import\",\n            \"dbms.directories.lib\",\n            \"dbms.directories.logs\",\n//            \"dbms.directories.metrics\",  // metrics is only in EE\n            \"dbms.directories.plugins\",\n            \"dbms.directories.run\",\n            \"dbms.directories.tx_log\",\n            \"dbms.directories.neo4j_home\"\n    );\n\n    public static void closeReaderSafely(CountingReader reader) {\n        if (reader != null) {\n            try { reader.close(); } catch (IOException ignored) { }\n        }\n    }\n\n    public static Path getPathFromUrlString(String urlDir) {\n        return Paths.get(URI.create(urlDir));\n    }\n\n    public static CountingInputStream getInputStreamFromBinary(byte[] urlOrBinary, String compressionAlgo) {\n        return CompressionAlgo.valueOf(compressionAlgo).toInputStream(urlOrBinary);\n    }\n\n    public static CountingReader getReaderFromBinary(byte[] urlOrBinary, String compressionAlgo) {\n        try {\n            return getInputStreamFromBinary(urlOrBinary, compressionAlgo).asReader();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "package apoc.export;\n\nimport apoc.ApocConfig;\nimport apoc.ApocSettings;\nimport apoc.export.csv.ExportCSV;\nimport apoc.export.cypher.ExportCypher;\nimport apoc.export.graphml.ExportGraphML;\nimport apoc.export.json.ExportJson;\nimport apoc.util.FileUtils;\nimport apoc.util.TestUtil;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.junit.experimental.runners.Enclosed;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.neo4j.configuration.GraphDatabaseSettings;\nimport org.neo4j.graphdb.Result;\nimport org.neo4j.test.rule.DbmsRule;\nimport org.neo4j.test.rule.ImpermanentDbmsRule;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n@RunWith(Enclosed.class)\npublic class ExportCoreSecurityTest {\n\n    private static final File directory = new File(\"target/import\");\n    private static final List<String> APOC_EXPORT_PROCEDURE_NAME = Arrays.asList(\"csv\", \"json\", \"graphml\", \"cypher\");\n\n    static {\n        directory.mkdirs();\n    }\n\n    @ClassRule\n    public static DbmsRule db = new ImpermanentDbmsRule()\n            .withSetting(GraphDatabaseSettings.load_csv_file_url_root, directory.toPath().toAbsolutePath())\n            .withSetting(ApocSettings.apoc_export_file_enabled, false);\n\n    @BeforeClass\n    public static void setUp() throws Exception {\n        TestUtil.registerProcedure(db, ExportCSV.class, ExportJson.class, ExportGraphML.class, ExportCypher.class);\n    }\n\n    @Before\n    public void before() {\n        ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n    }\n\n    @After\n    public void after() {\n        ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n    }\n\n    private static Collection<String[]> data(Map<String, List<String>> apocProcedureArguments) {\n        return APOC_EXPORT_PROCEDURE_NAME\n                .stream()\n                .flatMap(method -> apocProcedureArguments\n                        .entrySet()\n                        .stream()\n                        .flatMap(e -> e.getValue()\n                                .stream()\n                                .map(a -> new String[]{method, e.getKey(), a})))\n                .collect(Collectors.toList());\n    }\n\n    @RunWith(Parameterized.class)\n    public static class TestIllegalFSAccess {\n        private final String apocProcedure;\n\n        public TestIllegalFSAccess(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final Map<String, List<String>> APOC_PROCEDURE_ARGUMENTS = Map.of(\n                \"query\", List.of(\n                        \"\\\"RETURN 'hello' as key\\\", './hello', {}\",\n                        \"\\\"RETURN 'hello' as key\\\", './hello', {stream:true}\",\n                        \"\\\"RETURN 'hello' as key\\\", '  ', {}\"\n                ),\n                \"all\", List.of(\n                        \"'./hello', {}\",\n                        \"'./hello', {stream:true}\",\n                        \"'  ', {}\"\n                ),\n                \"data\", List.of(\n                        \"[], [], './hello', {}\",\n                        \"[], [], './hello', {stream:true}\",\n                        \"[], [], '  ', {}\"\n                ),\n                \"graph\", List.of(\n                        \"{nodes: [], relationships: []}, './hello', {}\",\n                        \"{nodes: [], relationships: []}, './hello', {stream:true}\",\n                        \"{nodes: [], relationships: []}, '  ', {}\"\n                )\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(APOC_PROCEDURE_ARGUMENTS);\n        }\n\n        @Test\n        public void testIllegalFSAccessExport() {\n            final String message = apocProcedure + \" should throw an exception\";\n            try {\n                db.executeTransactionally(\"CALL \" + apocProcedure, Map.of(),\n                        Result::resultAsString);\n                fail(message);\n            } catch (Exception e) {\n                assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n            }\n        }\n\n    }\n\n    @RunWith(Parameterized.class)\n    public static class TestIllegalExternalFSAccess {\n        private final String apocProcedure;\n\n        public TestIllegalExternalFSAccess(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\", List.of(\n                        \"\\\"RETURN 'hello' as key\\\", '../hello', {}\",\n                        \"\\\"RETURN 'hello' as key\\\", 'file:../hello', {}\"\n                ),\n                \"all\", List.of(\n                        \"'../hello', {}\",\n                        \"'file:../hello', {}\"\n                ),\n                \"data\", List.of(\n                        \"[], [], '../hello', {}\",\n                        \"[], [], 'file:../hello', {}\"\n                ),\n                \"graph\", List.of(\n                        \"{nodes: [], relationships: []}, '../hello', {}\",\n                        \"{nodes: [], relationships: []}, 'file:../hello', {}\"\n                )\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testIllegalExternalFSAccessExport() {\n            final String message = apocProcedure + \" should throw an exception\";\n            try {\n                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, true);\n                db.executeTransactionally(\"CALL \" + apocProcedure, Map.of(),\n                        Result::resultAsString);\n                fail(message);\n            } catch (Exception e) {\n                assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n            } finally {\n                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n            }\n        }\n    }\n\n    public static class TestCypherSchema {\n        private final String apocProcedure = \"apoc.export.cypher.schema(%s)\";\n        private final String message = apocProcedure + \" should throw an exception\";\n\n        @Test\n        public void testIllegalFSAccessExportCypherSchema() {\n            try {\n                db.executeTransactionally(String.format(\"CALL \" + apocProcedure, \"'./hello', {}\"), Map.of(),\n                        Result::resultAsString);\n                fail(message);\n            } catch (Exception e) {\n                assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n            }\n        }\n\n        @Test\n        public void testIllegalExternalFSAccessExportCypherSchema() {\n            try {\n                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, true);\n                db.executeTransactionally(String.format(\"CALL \" + apocProcedure, \"'../hello', {}\"), Map.of(),\n                        Result::resultAsString);\n                fail(message);\n            } catch (Exception e) {\n                assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n            } finally {\n                ApocConfig.apocConfig().setProperty(ApocSettings.apoc_export_file_enabled, false);\n            }\n        }\n    }\n\n    private static void assertError(Exception e, String errorMessage, Class<? extends Exception> exceptionType, String apocProcedure) {\n        final Throwable rootCause = ExceptionUtils.getRootCause(e);\n        assertTrue(apocProcedure + \" should throw an instance of \" + exceptionType.getSimpleName(), exceptionType.isInstance(rootCause));\n        assertEquals(apocProcedure + \" should throw the following message\", errorMessage, rootCause.getMessage());\n    }\n\n}", "package apoc.export.csv;\n\nimport apoc.ApocSettings;\nimport apoc.graph.Graphs;\nimport apoc.util.BinaryTestUtil;\nimport apoc.util.CompressionAlgo;\nimport apoc.meta.Meta;\nimport apoc.util.CompressionConfig;\nimport apoc.util.TestUtil;\nimport apoc.util.Util;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.neo4j.configuration.GraphDatabaseSettings;\nimport org.neo4j.graphdb.Result;\nimport org.neo4j.internal.helpers.collection.Iterators;\nimport org.neo4j.test.rule.DbmsRule;\nimport org.neo4j.test.rule.ImpermanentDbmsRule;\n\nimport java.io.File;\nimport java.nio.charset.Charset;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.function.Consumer;\n\nimport static apoc.util.BinaryTestUtil.getDecompressedData;\nimport static apoc.util.CompressionAlgo.DEFLATE;\nimport static apoc.util.CompressionAlgo.GZIP;\nimport static apoc.util.CompressionAlgo.NONE;\nimport static apoc.util.MapUtil.map;\nimport static apoc.util.TestUtil.testResult;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static junit.framework.TestCase.assertTrue;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\n/**\n * @author mh\n * @since 22.05.16\n */\npublic class ExportCsvTest {\n\n    private static final String EXPECTED_QUERY_NODES = String.format(\"\\\"u\\\"%n\" +\n            \"\\\"{\\\"\\\"id\\\"\\\":0,\\\"\\\"labels\\\"\\\":[\\\"\\\"User\\\"\\\",\\\"\\\"User1\\\"\\\"],\\\"\\\"properties\\\"\\\":{\\\"\\\"name\\\"\\\":\\\"\\\"foo\\\"\\\",\\\"\\\"male\\\"\\\":true,\\\"\\\"age\\\"\\\":42,\\\"\\\"kids\\\"\\\":[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]}}\\\"%n\" +\n            \"\\\"{\\\"\\\"id\\\"\\\":1,\\\"\\\"labels\\\"\\\":[\\\"\\\"User\\\"\\\"],\\\"\\\"properties\\\"\\\":{\\\"\\\"name\\\"\\\":\\\"\\\"bar\\\"\\\",\\\"\\\"age\\\"\\\":42}}\\\"%n\" +\n            \"\\\"{\\\"\\\"id\\\"\\\":2,\\\"\\\"labels\\\"\\\":[\\\"\\\"User\\\"\\\"],\\\"\\\"properties\\\"\\\":{\\\"\\\"age\\\"\\\":12}}\\\"%n\");\n    private static final String EXPECTED_QUERY = String.format(\"\\\"u.age\\\",\\\"u.name\\\",\\\"u.male\\\",\\\"u.kids\\\",\\\"labels(u)\\\"%n\" +\n            \"\\\"42\\\",\\\"foo\\\",\\\"true\\\",\\\"[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]\\\",\\\"[\\\"\\\"User1\\\"\\\",\\\"\\\"User\\\"\\\"]\\\"%n\" +\n            \"\\\"42\\\",\\\"bar\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"User\\\"\\\"]\\\"%n\" +\n            \"\\\"12\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"User\\\"\\\"]\\\"%n\");\n    private static final String EXPECTED_QUERY_WITHOUT_QUOTES = String.format(\"u.age,u.name,u.male,u.kids,labels(u)%n\" +\n            \"42,foo,true,[\\\"a\\\",\\\"b\\\",\\\"c\\\"],[\\\"User1\\\",\\\"User\\\"]%n\" +\n            \"42,bar,,,[\\\"User\\\"]%n\" +\n            \"12,,,,[\\\"User\\\"]%n\");\n    private static final String EXPECTED_QUERY_QUOTES_NONE = String.format(\"a.name,a.city,a.street,labels(a)%n\" +\n            \"Andrea,Milano,Via Garibaldi, 7,[\\\"Address1\\\",\\\"Address\\\"]%n\" +\n            \"Bar Sport,,,[\\\"Address\\\"]%n\" +\n            \",,via Benni,[\\\"Address\\\"]%n\");\n    private static final String EXPECTED_QUERY_QUOTES_ALWAYS = String.format(\"\\\"a.name\\\",\\\"a.city\\\",\\\"a.street\\\",\\\"labels(a)\\\"%n\" +\n            \"\\\"Andrea\\\",\\\"Milano\\\",\\\"Via Garibaldi, 7\\\",\\\"[\\\"\\\"Address1\\\"\\\",\\\"\\\"Address\\\"\\\"]\\\"%n\" +\n            \"\\\"Bar Sport\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"Address\\\"\\\"]\\\"%n\" +\n            \"\\\"\\\",\\\"\\\",\\\"via Benni\\\",\\\"[\\\"\\\"Address\\\"\\\"]\\\"%n\");\n    private static final String EXPECTED_QUERY_QUOTES_NEEDED = String.format(\"a.name,a.city,a.street,labels(a)%n\" +\n            \"Andrea,Milano,\\\"Via Garibaldi, 7\\\",\\\"[\\\"Address1\\\",\\\"Address\\\"]\\\"%n\" +\n            \"Bar Sport,,,\\\"[\\\"Address\\\"]\\\"%n\" +\n            \",,via Benni,\\\"[\\\"Address\\\"]\\\"%n\");\n    private static final String EXPECTED = String.format(\"\\\"_id\\\",\\\"_labels\\\",\\\"age\\\",\\\"city\\\",\\\"kids\\\",\\\"male\\\",\\\"name\\\",\\\"street\\\",\\\"_start\\\",\\\"_end\\\",\\\"_type\\\"%n\" +\n            \"\\\"0\\\",\\\":User:User1\\\",\\\"42\\\",\\\"\\\",\\\"[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]\\\",\\\"true\\\",\\\"foo\\\",\\\"\\\",,,%n\" +\n            \"\\\"1\\\",\\\":User\\\",\\\"42\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"bar\\\",\\\"\\\",,,%n\" +\n            \"\\\"2\\\",\\\":User\\\",\\\"12\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,%n\" +\n            \"\\\"3\\\",\\\":Address:Address1\\\",\\\"\\\",\\\"Milano\\\",\\\"\\\",\\\"\\\",\\\"Andrea\\\",\\\"Via Garibaldi, 7\\\",,,%n\" +\n            \"\\\"4\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Bar Sport\\\",\\\"\\\",,,%n\" +\n            \"\\\"5\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"via Benni\\\",,,%n\" +\n            \",,,,,,,,\\\"0\\\",\\\"1\\\",\\\"KNOWS\\\"%n\" +\n            \",,,,,,,,\\\"3\\\",\\\"4\\\",\\\"NEXT_DELIVERY\\\"%n\");\n\n    private static final String EXP_SAMPLE = \"\\\"_id\\\",\\\"_labels\\\",\\\"address\\\",\\\"age\\\",\\\"baz\\\",\\\"city\\\",\\\"foo\\\",\\\"kids\\\",\\\"last:Name\\\",\\\"male\\\",\\\"name\\\",\\\"street\\\",\\\"_start\\\",\\\"_end\\\",\\\"_type\\\",\\\"one\\\",\\\"three\\\"\\n\" +\n            \"\\\"0\\\",\\\":User:User1\\\",\\\"\\\",\\\"42\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]\\\",\\\"\\\",\\\"true\\\",\\\"foo\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"1\\\",\\\":User\\\",\\\"\\\",\\\"42\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"bar\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"2\\\",\\\":User\\\",\\\"\\\",\\\"12\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"3\\\",\\\":Address:Address1\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Milano\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Andrea\\\",\\\"Via Garibaldi, 7\\\",,,,,\\n\" +\n            \"\\\"4\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Bar Sport\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"5\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"via Benni\\\",,,,,\\n\" +\n            \"\\\"6\\\",\\\":Sample:User\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Galilei\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"7\\\",\\\":Sample:User\\\",\\\"Universe\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"8\\\",\\\":Sample:User\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"bar\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"9\\\",\\\":Sample:User\\\",\\\"\\\",\\\"\\\",\\\"baa\\\",\\\"\\\",\\\"true\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \",,,,,,,,,,,,\\\"0\\\",\\\"1\\\",\\\"KNOWS\\\",\\\"\\\",\\\"\\\"\\n\" +\n            \",,,,,,,,,,,,\\\"3\\\",\\\"4\\\",\\\"NEXT_DELIVERY\\\",\\\"\\\",\\\"\\\"\\n\" +\n            \",,,,,,,,,,,,\\\"8\\\",\\\"9\\\",\\\"KNOWS\\\",\\\"two\\\",\\\"four\\\"\\n\";\n\n    private static final String EXPECTED_NONE_QUOTES = String.format(\"_id,_labels,age,city,kids,male,name,street,_start,_end,_type%n\" +\n            \"0,:User:User1,42,,[\\\"a\\\",\\\"b\\\",\\\"c\\\"],true,foo,,,,%n\" +\n            \"1,:User,42,,,,bar,,,,%n\" +\n            \"2,:User,12,,,,,,,,%n\" +\n            \"3,:Address:Address1,,Milano,,,Andrea,Via Garibaldi, 7,,,%n\" +\n            \"4,:Address,,,,,Bar Sport,,,,%n\" +\n            \"5,:Address,,,,,,via Benni,,,%n\" +\n            \",,,,,,,,0,1,KNOWS%n\" +\n            \",,,,,,,,3,4,NEXT_DELIVERY%n\");\n    private static final String EXPECTED_NEEDED_QUOTES = String.format(\"_id,_labels,age,city,kids,male,name,street,_start,_end,_type%n\" +\n            \"0,:User:User1,42,,\\\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\\\",true,foo,,,,%n\" +\n            \"1,:User,42,,,,bar,,,,%n\" +\n            \"2,:User,12,,,,,,,,%n\" +\n            \"3,:Address:Address1,,Milano,,,Andrea,\\\"Via Garibaldi, 7\\\",,,%n\" +\n            \"4,:Address,,,,,Bar Sport,,,,%n\" +\n            \"5,:Address,,,,,,via Benni,,,%n\" +\n            \",,,,,,,,0,1,KNOWS%n\" +\n            \",,,,,,,,3,4,NEXT_DELIVERY%n\");\n\n    private static File directory = new File(\"target/import\");\n    static { //noinspection ResultOfMethodCallIgnored\n        directory.mkdirs();\n    }\n\n    @ClassRule\n    public static DbmsRule db = new ImpermanentDbmsRule()\n            .withSetting(GraphDatabaseSettings.load_csv_file_url_root, directory.toPath().toAbsolutePath())\n            .withSetting(ApocSettings.apoc_export_file_enabled, true)\n            .withSetting(ApocSettings.apoc_import_file_enabled, true);\n\n    @BeforeClass\n    public static void setUp() throws Exception {\n        TestUtil.registerProcedure(db, ExportCSV.class, Graphs.class, Meta.class, ImportCsv.class);\n        db.executeTransactionally(\"CREATE (f:User1:User {name:'foo',age:42,male:true,kids:['a','b','c']})-[:KNOWS]->(b:User {name:'bar',age:42}),(c:User {age:12})\");\n        db.executeTransactionally(\"CREATE (f:Address1:Address {name:'Andrea', city: 'Milano', street:'Via Garibaldi, 7'})-[:NEXT_DELIVERY]->(a:Address {name: 'Bar Sport'}), (b:Address {street: 'via Benni'})\");\n    }\n\n    private String readFile(String fileName) {\n        return readFile(fileName, UTF_8, CompressionAlgo.NONE);\n    }\n    \n    private String readFile(String fileName, Charset charset, CompressionAlgo compression) {\n        return BinaryTestUtil.readFileToString(new File(directory, fileName), charset, compression);\n    }\n\n    @Test\n    public void testExportInvalidQuoteValue() throws Exception {\n        try {\n            String fileName = \"all.csv\";\n            TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: 'Invalid'})\",\n                    map(\"file\", fileName),\n                    (r) -> assertResults(fileName, r, \"database\"));\n            fail();\n        } catch (RuntimeException e) {\n            final String expectedMessage = \"Failed to invoke procedure `apoc.export.csv.all`: Caused by: java.lang.RuntimeException: The string value of the field quote is not valid\";\n            assertEquals(expectedMessage, e.getMessage());\n        }\n    }\n    \n    @Test\n    public void testExportAllCsvCompressed() {\n        final CompressionAlgo compressionAlgo = DEFLATE;\n        String fileName = \"all.csv.zz\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file, $config)\",\n                map(\"file\", fileName, \"config\", map(\"compression\", compressionAlgo.name())),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED, readFile(fileName, UTF_8, compressionAlgo));\n    }\n    \n    @Test\n    public void testCsvRoundTrip() {\n        db.executeTransactionally(\"CREATE (f:Roundtrip {name:'foo',age:42,male:true,kids:['a','b','c']}),(b:Roundtrip {name:'bar',age:42}),(c:Roundtrip {age:12})\");\n        \n        String fileName = \"separatedFiles.csv.gzip\";\n        final Map<String, Object> params = map(\"file\", fileName, \"query\", \"MATCH (u:Roundtrip) return u.name as name\", \n                \"config\", map(CompressionConfig.COMPRESSION, GZIP.name()));\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query, $file, $config)\", params,\n                (r) -> assertEquals(fileName, r.get(\"file\")));\n\n        final String deleteQuery = \"MATCH (n:Roundtrip) DETACH DELETE n\";\n        db.executeTransactionally(deleteQuery);\n\n        TestUtil.testCall(db, \"CALL apoc.import.csv([{fileName: $file, labels: ['Roundtrip']}], [], $config) \", params, \n                r -> assertEquals(3L, r.get(\"nodes\")));\n\n        TestUtil.testResult(db, \"MATCH (n:Roundtrip) return n.name as name\", r -> {\n            final Set<String> actual = Iterators.asSet(r.columnAs(\"name\"));\n            assertEquals(Set.of(\"foo\", \"bar\", \"\"), actual);\n        });\n\n        db.executeTransactionally(deleteQuery);\n    }\n\n    @Test\n    public void testExportAllCsv() throws Exception {\n        String fileName = \"all.csv\";\n        testExportCsvAllCommon(fileName);\n    }\n\n    @Test\n    public void testExportAllCsvWithDotInName() {\n        String fileName = \"all.with.dot.filename.csv\";\n        testExportCsvAllCommon(fileName);\n    }\n\n    @Test\n    public void testExportAllCsvWithoutExtension() {\n        String fileName = \"all\";\n        testExportCsvAllCommon(fileName);\n    }\n\n    private void testExportCsvAllCommon(String fileName) {\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,null)\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED, readFile(fileName));\n    }\n\n    @Test\n    public void testExportAllCsvWithSample() throws IOException {\n        db.executeTransactionally(\"CREATE (:User:Sample {`last:Name`:'Galilei'}), (:User:Sample {address:'Universe'}),\\n\" +\n                \"(:User:Sample {foo:'bar'})-[:KNOWS {one: 'two', three: 'four'}]->(:User:Sample {baz:'baa', foo: true})\");\n        String fileName = \"all.csv\";\n        final long totalNodes = 10L;\n        final long totalRels = 3L;\n        final long totalProps = 19L;\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file, null)\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\", totalNodes, totalRels, totalProps, true));\n        assertEquals(EXP_SAMPLE, readFile(fileName));\n\n        // quotes: 'none' to simplify header testing\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file, {sampling: true, samplingConfig: {sample: 1}, quotes: 'none'})\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\", totalNodes, totalRels, totalProps, false));\n        \n        final String[] s = Files.lines(new File(directory, fileName).toPath()).findFirst().get().split(\",\");\n        assertTrue(s.length < 17);\n        assertTrue(Arrays.asList(s).containsAll(List.of(\"_id\", \"_labels\", \"_start\", \"_end\", \"_type\")));\n        \n        db.executeTransactionally(\"MATCH (n:Sample) DETACH DELETE n\");\n    }\n\n    @Test\n    public void testExportAllCsvWithQuotes() throws Exception {\n        String fileName = \"all.csv\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: true})\",\n                map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED, readFile(fileName));\n    }\n\n    @Test\n    public void testExportAllCsvWithoutQuotes() throws Exception {\n        String fileName = \"all.csv\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: 'none'})\",\n                map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED_NONE_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportAllCsvNeededQuotes() throws Exception {\n        String fileName = \"all.csv\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: 'ifNeeded'})\",\n                map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED_NEEDED_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportGraphCsv() throws Exception {\n        String fileName = \"graph.csv\";\n        TestUtil.testCall(db, \"CALL apoc.graph.fromDB('test',{}) yield graph \" +\n                        \"CALL apoc.export.csv.graph(graph, $file,{quotes: 'none'}) \" +\n                        \"YIELD nodes, relationships, properties, file, source,format, time \" +\n                        \"RETURN *\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"graph\"));\n        assertEquals(EXPECTED_NONE_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportGraphCsvWithoutQuotes() throws Exception {\n        String fileName = \"graph.csv\";\n        TestUtil.testCall(db, \"CALL apoc.graph.fromDB('test',{}) yield graph \" +\n                        \"CALL apoc.export.csv.graph(graph, $file,null) \" +\n                        \"YIELD nodes, relationships, properties, file, source,format, time \" +\n                        \"RETURN *\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"graph\"));\n        assertEquals(EXPECTED, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryCsv() throws Exception {\n        String fileName = \"query.csv\";\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,null)\",\n                map(\"file\", fileName, \"query\", query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(5)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryCsvWithoutQuotes() throws Exception {\n        String fileName = \"query.csv\";\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,{quotes: false})\",\n                map(\"file\", fileName, \"query\", query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(5)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY_WITHOUT_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryNodesCsv() throws Exception {\n        String fileName = \"query_nodes.csv\";\n        String query = \"MATCH (u:User) return u\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,null)\",\n                map(\"file\", fileName, \"query\", query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(1)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY_NODES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryNodesCsvParams() throws Exception {\n        String fileName = \"query_nodes.csv\";\n        String query = \"MATCH (u:User) WHERE u.age > $age return u\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,{params:{age:10}})\", map(\"file\", fileName,\"query\",query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(1)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY_NODES, readFile(fileName));\n    }\n\n    private void assertResults(String fileName, Map<String, Object> r, final String source) {\n        assertResults(fileName, r, source, 6L, 2L, 12L, true);\n    }\n\n    private void assertResults(String fileName, Map<String, Object> r, final String source, \n                               Long expectedNodes, Long expectedRelationships, Long expectedProperties, boolean assertPropEquality) {\n        assertEquals(expectedNodes, r.get(\"nodes\"));\n        assertEquals(expectedRelationships, r.get(\"relationships\"));\n        if (assertPropEquality) {\n            assertEquals(expectedProperties, r.get(\"properties\"));\n        } else {\n            assertTrue((Long) r.get(\"properties\") < expectedProperties);\n        }\n        final String expectedSource = source + \": nodes(\" + expectedNodes + \"), rels(\" + expectedRelationships + \")\";\n        assertEquals(expectedSource, r.get(\"source\"));\n        assertCsvCommon(fileName, r);\n    }\n\n    private void assertCsvCommon(String fileName, Map<String, Object> r) {\n        assertEquals(fileName, r.get(\"file\"));\n        assertEquals(\"csv\", r.get(\"format\"));\n        assertTrue(\"Should get time greater than 0\",((long) r.get(\"time\")) >= 0);\n    }\n\n    @Test public void testExportAllCsvStreaming() throws Exception {\n        String statement = \"CALL apoc.export.csv.all(null,{stream:true,batchSize:2,useOptimizations:{unwindBatchSize:2}})\";\n        assertExportStreaming(statement, NONE);\n    }\n    \n    @Test\n    public void testExportAllCsvStreamingCompressed() throws Exception {\n        final CompressionAlgo algo = GZIP;\n        String statement = \"CALL apoc.export.csv.all(null, {compression: '\" + algo.name() + \"',stream:true,batchSize:2,useOptimizations:{unwindBatchSize:2}})\";\n        assertExportStreaming(statement, algo);\n    }\n\n    private void assertExportStreaming(String statement, CompressionAlgo algo) {\n        StringBuilder sb=new StringBuilder();\n        testResult(db, statement, (res) -> {\n            Map<String, Object> r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(1L, r.get(\"batches\"));\n            assertEquals(2L, r.get(\"nodes\"));\n            assertEquals(2L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(6L, r.get(\"properties\"));\n            assertNull(\"Should get file\", r.get(\"file\"));\n            assertEquals(\"csv\", r.get(\"format\"));\n            assertTrue(\"Should get time greater than 0\", ((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(2L, r.get(\"batches\"));\n            assertEquals(4L, r.get(\"nodes\"));\n            assertEquals(4L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(10L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\", ((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(3L, r.get(\"batches\"));\n            assertEquals(6L, r.get(\"nodes\"));\n            assertEquals(6L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(12L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\", ((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(4L, r.get(\"batches\"));\n            assertEquals(6L, r.get(\"nodes\"));\n            assertEquals(8L, r.get(\"rows\"));\n            assertEquals(2L, r.get(\"relationships\"));\n            assertEquals(12L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\",((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            res.close();\n        });\n        assertEquals(EXPECTED, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreaming() throws Exception {\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchUsers(sb));\n        assertEquals(EXPECTED_QUERY, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreamingWithoutQuotes() throws Exception {\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: false, stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchUsers(sb));\n\n        assertEquals(EXPECTED_QUERY_WITHOUT_QUOTES, sb.toString());\n    }\n\n    private Consumer<Result> getAndCheckStreamingMetadataQueryMatchUsers(StringBuilder sb)\n    {\n        return (res) -> {\n            Map<String, Object> r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(1L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(2L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(10L, r.get(\"properties\"));\n            assertNull(\"Should get file\", r.get(\"file\"));\n            assertEquals(\"csv\", r.get(\"format\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\")); r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(2L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(3L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(15L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\"));\n        };\n    }\n\n    @Test public void testCypherCsvStreamingWithAlwaysQuotes() throws Exception {\n        String query = \"MATCH (a:Address) return a.name, a.city, a.street, labels(a)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: 'always', stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchAddress(sb));\n\n        assertEquals(EXPECTED_QUERY_QUOTES_ALWAYS, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreamingWithNeededQuotes() throws Exception {\n        String query = \"MATCH (a:Address) return a.name, a.city, a.street, labels(a)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: 'ifNeeded', stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchAddress(sb));\n\n        assertEquals(EXPECTED_QUERY_QUOTES_NEEDED, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreamingWithNoneQuotes() throws Exception {\n        String query = \"MATCH (a:Address) return a.name, a.city, a.street, labels(a)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: 'none', stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchAddress(sb));\n\n        assertEquals(EXPECTED_QUERY_QUOTES_NONE, sb.toString());\n    }\n\n    @Test\n    public void testExportQueryCsvIssue1188() throws Exception {\n        String copyright = \"\\n\" +\n                \"(c) 2018 Hovsepian, Albanese, et al. \\\"\\\"ASCB(r),\\\"\\\" \\\"\\\"The American Society for Cell Biology(r),\\\"\\\" and \\\"\\\"Molecular Biology of the Cell(r)\\\"\\\" are registered trademarks of The American Society for Cell Biology.\\n\" +\n                \"2018\\n\" +\n                \"\\n\" +\n                \"This article is distributed by The American Society for Cell Biology under license from the author(s). Two months after publication it is available to the public under an Attribution-Noncommercial-Share Alike 3.0 Unported Creative Commons License.\\n\" +\n                \"\\n\";\n        String pk = \"5921569\";\n        db.executeTransactionally(\"CREATE (n:Document{pk:$pk, copyright: $copyright})\", map(\"copyright\", copyright, \"pk\", pk));\n        String query = \"MATCH (n:Document{pk:'5921569'}) return n.pk as pk, n.copyright as copyright\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query, null, $config)\", map(\"query\", query,\n                \"config\", map(\"stream\", true)),\n                (r) -> {\n                    List<String[]> csv = CsvTestUtil.toCollection(r.get(\"data\").toString());\n                    assertEquals(2, csv.size());\n                    assertArrayEquals(new String[]{\"pk\",\"copyright\"}, csv.get(0));\n                    assertArrayEquals(new String[]{\"5921569\",copyright}, csv.get(1));\n                });\n        db.executeTransactionally(\"MATCH (d:Document) DETACH DELETE d\");\n\n    }\n\n    @Test\n    public void testExportWgsPoint() {\n        db.executeTransactionally(\"CREATE (p:Position {place: point({latitude: 12.78, longitude: 56.7, height: 1.1})})\");\n\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query, null, {quotes: 'none', stream: true}) YIELD data RETURN data\",\n                map(\"query\", \"MATCH (p:Position) RETURN p.place as place\"),\n                (r) -> {\n                    String data = (String) r.get(\"data\");\n                    Map<String, Object> place = Util.fromJson(data.split(System.lineSeparator())[1], Map.class);\n                    assertEquals(12.78D, (double) place.get(\"latitude\"), 0);\n                    assertEquals(56.7D, (double) place.get(\"longitude\"), 0);\n                    assertEquals(1.1D, (double) place.get(\"height\"), 0);\n                });\n        db.executeTransactionally(\"MATCH (n:Position) DETACH DELETE n\");\n    }\n\n    private Consumer<Result> getAndCheckStreamingMetadataQueryMatchAddress(StringBuilder sb)\n    {\n        return (res) -> {\n            Map<String, Object> r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(1L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(2L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(8L, r.get(\"properties\"));\n            assertNull(\"Should get file\", r.get(\"file\"));\n            assertEquals(\"csv\", r.get(\"format\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\"));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(2L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(3L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(12L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\"));\n        };\n    }\n\n}\n"], "fixing_code": ["package apoc.export.csv;\n\nimport apoc.ApocConfig;\nimport apoc.Pools;\nimport apoc.export.cypher.ExportFileManager;\nimport apoc.export.cypher.FileManagerFactory;\nimport apoc.export.util.ExportConfig;\nimport apoc.export.util.ExportUtils;\nimport apoc.export.util.NodesAndRelsSubGraph;\nimport apoc.export.util.ProgressReporter;\nimport apoc.result.ProgressInfo;\nimport apoc.util.Util;\nimport org.neo4j.cypher.export.DatabaseSubGraph;\nimport org.neo4j.cypher.export.SubGraph;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Node;\nimport org.neo4j.graphdb.Relationship;\nimport org.neo4j.graphdb.Result;\nimport org.neo4j.graphdb.Transaction;\nimport org.neo4j.procedure.Context;\nimport org.neo4j.procedure.Description;\nimport org.neo4j.procedure.Name;\nimport org.neo4j.procedure.Procedure;\nimport org.neo4j.procedure.TerminationGuard;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\n/**\n * @author mh\n * @since 22.05.16\n */\npublic class ExportCSV {\n    @Context\n    public Transaction tx;\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public TerminationGuard terminationGuard;\n\n    @Context\n    public ApocConfig apocConfig;\n\n    @Context\n    public Pools pools;\n\n    public ExportCSV() {\n    }\n\n    @Procedure\n    @Description(\"apoc.export.csv.all(file,config) - exports whole database as csv to the provided file\")\n    public Stream<ProgressInfo> all(@Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        String source = String.format(\"database: nodes(%d), rels(%d)\", Util.nodeCount(tx), Util.relCount(tx));\n        return exportCsv(fileName, source, new DatabaseSubGraph(tx), new ExportConfig(config));\n    }\n\n    @Procedure\n    @Description(\"apoc.export.csv.data(nodes,rels,file,config) - exports given nodes and relationships as csv to the provided file\")\n    public Stream<ProgressInfo> data(@Name(\"nodes\") List<Node> nodes, @Name(\"rels\") List<Relationship> rels, @Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        ExportConfig exportConfig = new ExportConfig(config);\n        preventBulkImport(exportConfig);\n        String source = String.format(\"data: nodes(%d), rels(%d)\", nodes.size(), rels.size());\n        return exportCsv(fileName, source, new NodesAndRelsSubGraph(tx, nodes, rels), exportConfig);\n    }\n    @Procedure\n    @Description(\"apoc.export.csv.graph(graph,file,config) - exports given graph object as csv to the provided file\")\n    public Stream<ProgressInfo> graph(@Name(\"graph\") Map<String,Object> graph, @Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        Collection<Node> nodes = (Collection<Node>) graph.get(\"nodes\");\n        Collection<Relationship> rels = (Collection<Relationship>) graph.get(\"relationships\");\n        String source = String.format(\"graph: nodes(%d), rels(%d)\", nodes.size(), rels.size());\n        return exportCsv(fileName, source, new NodesAndRelsSubGraph(tx, nodes, rels), new ExportConfig(config));\n    }\n\n    @Procedure\n    @Description(\"apoc.export.csv.query(query,file,{config,...,params:{params}}) - exports results from the cypher statement as csv to the provided file\")\n    public Stream<ProgressInfo> query(@Name(\"query\") String query, @Name(\"file\") String fileName, @Name(\"config\") Map<String, Object> config) throws Exception {\n        ExportConfig exportConfig = new ExportConfig(config);\n        preventBulkImport(exportConfig);\n        Map<String,Object> params = config == null ? Collections.emptyMap() : (Map<String,Object>)config.getOrDefault(\"params\", Collections.emptyMap());\n        Result result = tx.execute(query,params);\n\n        String source = String.format(\"statement: cols(%d)\", result.columns().size());\n        return exportCsv(fileName, source,result, exportConfig);\n    }\n\n    private void preventBulkImport(ExportConfig config) {\n        if (config.isBulkImport()) {\n            throw new RuntimeException(\"You can use the `bulkImport` only with apoc.export.all and apoc.export.csv.graph\");\n        }\n    }\n\n    private Stream<ProgressInfo> exportCsv(@Name(\"file\") String fileName, String source, Object data, ExportConfig exportConfig) throws Exception {\n        apocConfig.checkWriteAllowed(exportConfig, fileName);\n        final String format = \"csv\";\n        ProgressInfo progressInfo = new ProgressInfo(fileName, source, format);\n        progressInfo.batchSize = exportConfig.getBatchSize();\n        ProgressReporter reporter = new ProgressReporter(null, null, progressInfo);\n        CsvFormat exporter = new CsvFormat(db);\n\n        ExportFileManager cypherFileManager = FileManagerFactory\n                .createFileManager(fileName, exportConfig.isBulkImport(), exportConfig);\n\n        if (exportConfig.streamStatements()) {\n            return ExportUtils.getProgressInfoStream(db, pools.getDefaultExecutorService(), terminationGuard, format, exportConfig, reporter, cypherFileManager,\n                    (reporterWithConsumer) -> dump(data, exportConfig, reporterWithConsumer, cypherFileManager, exporter));\n        } else {\n            dump(data, exportConfig, reporter, cypherFileManager, exporter);\n            return reporter.stream();\n        }\n    }\n\n    private void dump(Object data, ExportConfig c, ProgressReporter reporter, ExportFileManager printWriter, CsvFormat exporter) {\n        if (data instanceof SubGraph)\n            exporter.dump((SubGraph) data, printWriter, reporter, c);\n        if (data instanceof Result)\n            exporter.dump((Result) data, printWriter, reporter, c);\n    }\n}\n", "package apoc.util;\n\nimport apoc.ApocConfig;\nimport apoc.export.util.CountingInputStream;\nimport apoc.export.util.CountingReader;\nimport apoc.export.util.ExportConfig;\nimport apoc.util.hdfs.HDFSUtils;\nimport apoc.util.s3.S3URLConnection;\nimport apoc.util.s3.S3UploadUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.configuration.GraphDatabaseSettings;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLStreamHandler;\nimport java.net.URLStreamHandlerFactory;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport static apoc.ApocConfig.APOC_IMPORT_FILE_ALLOW__READ__FROM__FILESYSTEM;\nimport static apoc.ApocConfig.apocConfig;\nimport static apoc.util.Util.ERROR_BYTES_OR_STRING;\nimport static apoc.util.Util.REDIRECT_LIMIT;\nimport static apoc.util.Util.readHttpInputStream;\n\n/**\n * @author mh\n * @since 22.05.16\n */\npublic class FileUtils {\n\n    public enum SupportedProtocols {\n        http(true, null),\n        https(true, null),\n        ftp(true, null),\n        s3(Util.classExists(\"com.amazonaws.services.s3.AmazonS3\"),\n                \"apoc.util.s3.S3UrlStreamHandlerFactory\"),\n        gs(Util.classExists(\"com.google.cloud.storage.Storage\"),\n                \"apoc.util.google.cloud.GCStorageURLStreamHandlerFactory\"),\n        hdfs(Util.classExists(\"org.apache.hadoop.fs.FileSystem\"),\n                \"org.apache.hadoop.fs.FsUrlStreamHandlerFactory\"),\n        file(true, null);\n\n        private final boolean enabled;\n\n        private final String urlStreamHandlerClassName;\n\n        SupportedProtocols(boolean enabled, String urlStreamHandlerClassName) {\n            this.enabled = enabled;\n            this.urlStreamHandlerClassName = urlStreamHandlerClassName;\n        }\n\n        public StreamConnection getStreamConnection(String urlAddress, Map<String, Object> headers, String payload) throws IOException {\n            switch (this) {\n                case s3:\n                    return FileUtils.openS3InputStream(urlAddress);\n                case hdfs:\n                    return FileUtils.openHdfsInputStream(urlAddress);\n                case ftp:\n                case http:\n                case https:\n                case gs:\n                    return readHttpInputStream(urlAddress, headers, payload, REDIRECT_LIMIT);\n                default:\n                    try {\n                        return new StreamConnection.FileStreamConnection(URI.create(urlAddress));\n                    } catch (IllegalArgumentException iae) {\n                        try {\n                            return new StreamConnection.FileStreamConnection(new URL(urlAddress).getFile());\n                        } catch (MalformedURLException mue) {\n                            if (mue.getMessage().contains(\"no protocol\")) {\n                                return new StreamConnection.FileStreamConnection(urlAddress);\n                            }\n                            throw mue;\n                        }\n                    }\n            }\n        }\n\n        public OutputStream getOutputStream(String fileName, ExportConfig config) {\n            if (fileName == null) return null;\n            final CompressionAlgo compressionAlgo = CompressionAlgo.valueOf(config.getCompressionAlgo());\n            final OutputStream outputStream;\n            try {\n                switch (this) {\n                    case s3:\n                        outputStream = S3UploadUtils.writeFile(fileName);\n                        break;\n                    case hdfs:\n                        outputStream = HDFSUtils.writeFile(fileName);\n                        break;\n                    default:\n                        final Path path = resolvePath(fileName);\n                        outputStream = new FileOutputStream(path.toFile());\n                }\n                return new BufferedOutputStream(compressionAlgo.getOutputStream(outputStream));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean isEnabled() {\n            return enabled;\n        }\n\n        public URLStreamHandler createURLStreamHandler() {\n            return Optional.ofNullable(urlStreamHandlerClassName)\n                    .map(Util::createInstanceOrNull)\n                    .map(urlStreamHandlerFactory -> ((URLStreamHandlerFactory) urlStreamHandlerFactory).createURLStreamHandler(this.name()))\n                    .orElse(null);\n        }\n\n        public static SupportedProtocols from(String source) {\n            try {\n                final URL url = new URL(source);\n                return from(url);\n            } catch (MalformedURLException e) {\n                if (!e.getMessage().contains(\"no protocol\")) {\n                    try {\n                        // in case new URL(source) throw e.g. unknown protocol: hdfs, because of missing jar, \n                        // we retrieve the related enum and throw the associated MissingDependencyException(..)\n                        // otherwise we return unknown protocol: yyyyy\n                        return SupportedProtocols.valueOf(new URI(source).getScheme());\n                    } catch (Exception ignored) {}\n                    throw new RuntimeException(e);\n                }\n                return SupportedProtocols.file;\n            }\n        }\n\n        public static SupportedProtocols from(URL url) {\n            return SupportedProtocols.of(url.getProtocol());\n        }\n\n        public static SupportedProtocols of(String name) {\n            try {\n                return SupportedProtocols.valueOf(name);\n            } catch (Exception e) {\n                return file;\n            }\n        }\n\n    }\n\n    public static final String ERROR_READ_FROM_FS_NOT_ALLOWED = \"Import file %s not enabled, please set \" + APOC_IMPORT_FILE_ALLOW__READ__FROM__FILESYSTEM + \"=true in your neo4j.conf\";\n    public static final String ACCESS_OUTSIDE_DIR_ERROR = \"You're providing a directory outside the import directory \" +\n            \"defined into `dbms.directories.import`\";\n\n    public static CountingReader readerFor(Object input) throws IOException {\n        return readerFor(input, null, null, CompressionAlgo.NONE.name());\n    }\n\n    public static CountingReader readerFor(Object input, String compressionAlgo) throws IOException {\n        return readerFor(input, null, null, compressionAlgo);\n    }\n\n    public static CountingReader readerFor(Object input, Map<String, Object> headers, String payload, String compressionAlgo) throws IOException {\n        return inputStreamFor(input, headers, payload, compressionAlgo).asReader();\n    }\n\n    public static CountingInputStream inputStreamFor(Object input, Map<String, Object> headers, String payload, String compressionAlgo) throws IOException {\n        if (input == null) return null;\n        if (input instanceof String) {\n            String fileName = (String) input;\n            apocConfig().checkReadAllowed(fileName);\n            fileName = changeFileUrlIfImportDirectoryConstrained(fileName);\n            return Util.openInputStream(fileName, headers, payload, compressionAlgo);\n        } else if (input instanceof byte[]) {\n            return getInputStreamFromBinary((byte[]) input, compressionAlgo);\n        } else {\n            throw new RuntimeException(ERROR_BYTES_OR_STRING);\n        }\n    }\n    \n    public static String changeFileUrlIfImportDirectoryConstrained(String url) throws IOException {\n        if (isFile(url) && isImportUsingNeo4jConfig()) {\n            if (!apocConfig().getBoolean(APOC_IMPORT_FILE_ALLOW__READ__FROM__FILESYSTEM)) {\n                throw new RuntimeException(String.format(ERROR_READ_FROM_FS_NOT_ALLOWED, url));\n            }\n            final Path resolvedPath = resolvePath(url);\n            return resolvedPath\n                    .normalize()\n                    .toUri()\n                    .toString();\n        }\n        return url;\n    }\n\n    private static Path resolvePath(String url) throws IOException {\n        Path urlPath = getPath(url);\n        final Path resolvedPath;\n        if (apocConfig().isImportFolderConfigured() && isImportUsingNeo4jConfig()) {\n            Path basePath = Paths.get(apocConfig().getImportDir());\n            urlPath = relativizeIfSamePrefix(urlPath, basePath);\n            resolvedPath = basePath.resolve(urlPath).toAbsolutePath().normalize();\n            if (!pathStartsWithOther(resolvedPath, basePath)) {\n                throw new IOException(ACCESS_OUTSIDE_DIR_ERROR);\n            }\n        } else {\n            resolvedPath = urlPath;\n        }\n        return resolvedPath;\n    }\n\n    private static Path relativizeIfSamePrefix(Path urlPath, Path basePath) {\n        if (FilenameUtils.getPrefixLength(urlPath.toString()) > 0 && !urlPath.startsWith(basePath.toAbsolutePath())) {\n            // if the import folder is configured to be used as root folder we consider\n            // it as root directory in order to reproduce the same LOAD CSV behaviour\n            urlPath = urlPath.getRoot().relativize(urlPath);\n        }\n        return urlPath;\n    }\n\n    private static Path getPath(String url) {\n        Path urlPath;\n        URL toURL = null;\n        try {\n            final URI uri = URI.create(url.trim()).normalize();\n            toURL = uri.toURL();\n            urlPath = Paths.get(uri);\n        } catch (Exception e) {\n            if (toURL != null) {\n                urlPath = Paths.get(StringUtils.isBlank(toURL.getFile()) ? toURL.getHost() : toURL.getFile());\n            } else {\n                urlPath = Paths.get(url);\n            }\n        }\n        return urlPath;\n    }\n\n    private static boolean pathStartsWithOther(Path resolvedPath, Path basePath) throws IOException {\n        try {\n            return resolvedPath.toFile().getCanonicalFile().toPath().startsWith(basePath.toRealPath());\n        } catch (Exception e) {\n            if (e instanceof NoSuchFileException) { // If we're about to create a file this exception has been thrown\n                return resolvedPath.toFile().getCanonicalFile().toPath().startsWith(basePath);\n            }\n            return false;\n        }\n    }\n\n    public static boolean isFile(String fileName) {\n        return SupportedProtocols.from(fileName) == SupportedProtocols.file;\n    }\n\n    public static OutputStream getOutputStream(String fileName) {\n        return getOutputStream(fileName, ExportConfig.EMPTY);\n    }\n\n    public static OutputStream getOutputStream(String fileName, ExportConfig config) {\n        if (fileName.equals(\"-\")) {\n            return null;\n        }\n        return SupportedProtocols.from(fileName).getOutputStream(fileName, config);\n    }\n\n    public static boolean isImportUsingNeo4jConfig() {\n        return apocConfig().getBoolean(ApocConfig.APOC_IMPORT_FILE_USE_NEO4J_CONFIG);\n    }\n\n    public static StreamConnection openS3InputStream(String urlAddress) throws IOException {\n        if (!SupportedProtocols.s3.isEnabled()) {\n            throw new MissingDependencyException(\"Cannot find the S3 jars in the plugins folder. \\n\" +\n                    \"Please put these files into the plugins folder :\\n\\n\" +\n                    \"aws-java-sdk-core-x.y.z.jar\\n\" +\n                    \"aws-java-sdk-s3-x.y.z.jar\\n\" +\n                    \"httpclient-x.y.z.jar\\n\" +\n                    \"httpcore-x.y.z.jar\\n\" +\n                    \"joda-time-x.y.z.jar\\n\" +\n                    \"\\nSee the documentation: https://neo4j-contrib.github.io/neo4j-apoc-procedures/#_loading_data_from_web_apis_json_xml_csv\");\n        }\n        return S3URLConnection.openS3InputStream(new URL(urlAddress));\n    }\n\n    public static StreamConnection openHdfsInputStream(String urlAddress) throws IOException {\n        if (!SupportedProtocols.hdfs.isEnabled()) {\n            throw new MissingDependencyException(\"Cannot find the HDFS/Hadoop jars in the plugins folder. \\n\" +\n                    \"\\nPlease, see the documentation: https://neo4j.com/labs/apoc/4.4/import/web-apis/\");\n        }\n        return HDFSUtils.readFile(new URL(urlAddress));\n    }\n\n    /**\n     * @return a File pointing to Neo4j's log directory, if it exists and is readable, null otherwise.\n     */\n    public static File getLogDirectory() {\n        String neo4jHome = apocConfig().getString(\"dbms.directories.neo4j_home\", \"\");\n        String logDir = apocConfig().getString(\"dbms.directories.logs\", \"\");\n\n        File logs = logDir.isEmpty() ? new File(neo4jHome, \"logs\") : new File(logDir);\n\n        if (logs.exists() && logs.canRead() && logs.isDirectory()) {\n            return logs;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return a File representing the metrics directory that is listable and readable, or null if metrics don't exist,\n     * aren't enabled, or aren't readable.\n     */\n    public static File getMetricsDirectory() {\n        String neo4jHome = apocConfig().getString(GraphDatabaseSettings.neo4j_home.name());\n        String metricsSetting = apocConfig().getString(\"dbms.directories.metrics\", neo4jHome + File.separator + \"metrics\");\n\n        File metricsDir = metricsSetting.isEmpty() ? new File(neo4jHome, \"metrics\") : new File(metricsSetting);\n\n        if (metricsDir.exists() && metricsDir.canRead() && metricsDir.isDirectory() ) {\n            return metricsDir;\n        }\n\n        return null;\n    }\n\n    // This is the list of dbms.directories.* valid configuration items for neo4j.\n    // https://neo4j.com/docs/operations-manual/current/reference/configuration-settings/\n    // Usually these reside under the same root but because they're separately configurable, in the worst case\n    // every one is on a different device.\n    //\n    // More likely, they'll be largely similar metrics.\n    public static final List<String> NEO4J_DIRECTORY_CONFIGURATION_SETTING_NAMES = Arrays.asList(\n//            \"dbms.directories.certificates\",  // not in 4.x version\n            \"dbms.directories.data\",\n            \"dbms.directories.import\",\n            \"dbms.directories.lib\",\n            \"dbms.directories.logs\",\n//            \"dbms.directories.metrics\",  // metrics is only in EE\n            \"dbms.directories.plugins\",\n            \"dbms.directories.run\",\n            \"dbms.directories.tx_log\",\n            \"dbms.directories.neo4j_home\"\n    );\n\n    public static void closeReaderSafely(CountingReader reader) {\n        if (reader != null) {\n            try { reader.close(); } catch (IOException ignored) { }\n        }\n    }\n\n    public static Path getPathFromUrlString(String urlDir) {\n        return Paths.get(URI.create(urlDir));\n    }\n\n    public static CountingInputStream getInputStreamFromBinary(byte[] urlOrBinary, String compressionAlgo) {\n        return CompressionAlgo.valueOf(compressionAlgo).toInputStream(urlOrBinary);\n    }\n\n    public static CountingReader getReaderFromBinary(byte[] urlOrBinary, String compressionAlgo) {\n        try {\n            return getInputStreamFromBinary(urlOrBinary, compressionAlgo).asReader();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "package apoc.export;\n\nimport apoc.ApocConfig;\nimport apoc.ApocSettings;\nimport apoc.export.csv.ExportCSV;\nimport apoc.export.cypher.ExportCypher;\nimport apoc.export.graphml.ExportGraphML;\nimport apoc.export.json.ExportJson;\nimport apoc.util.FileUtils;\nimport apoc.util.TestUtil;\nimport junit.framework.TestCase;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.junit.experimental.runners.Enclosed;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.neo4j.configuration.GraphDatabaseSettings;\nimport org.neo4j.graphdb.QueryExecutionException;\nimport org.neo4j.graphdb.Result;\nimport org.neo4j.test.rule.DbmsRule;\nimport org.neo4j.test.rule.ImpermanentDbmsRule;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n@RunWith(Enclosed.class)\npublic class ExportCoreSecurityTest {\n\n    private static final File directory = new File(\"target/import\");\n    private static final File directoryWithSamePrefix = new File(\"target/imported\");\n    private static final File subDirectory = new File(\"target/import/tests\");\n    private static final List<String> APOC_EXPORT_PROCEDURE_NAME = Arrays.asList(\"csv\", \"json\", \"graphml\", \"cypher\");\n\n    static {\n        //noinspection ResultOfMethodCallIgnored\n        directory.mkdirs();\n        //noinspection ResultOfMethodCallIgnored\n        subDirectory.mkdirs();\n        //noinspection ResultOfMethodCallIgnored\n        directoryWithSamePrefix.mkdirs();\n    }\n\n    @ClassRule\n    public static DbmsRule db = new ImpermanentDbmsRule()\n            .withSetting(GraphDatabaseSettings.load_csv_file_url_root, directory.toPath().toAbsolutePath())\n            .withSetting(ApocSettings.apoc_export_file_enabled, false);\n\n    @BeforeClass\n    public static void setUp() throws Exception {\n        TestUtil.registerProcedure(db, ExportCSV.class, ExportJson.class, ExportGraphML.class, ExportCypher.class);\n        setFileExport(false);\n    }\n\n    private static void setFileExport(boolean allowed) {\n        ApocConfig.apocConfig().setProperty(ApocConfig.APOC_EXPORT_FILE_ENABLED, allowed);\n    }\n\n    private static Collection<String[]> data(Map<String, List<String>> apocProcedureArguments) {\n        return APOC_EXPORT_PROCEDURE_NAME\n                .stream()\n                .flatMap(method -> apocProcedureArguments\n                        .entrySet()\n                        .stream()\n                        .flatMap(e -> e.getValue()\n                                .stream()\n                                .map(a -> new String[]{method, e.getKey(), a})))\n                .collect(Collectors.toList());\n    }\n\n    @RunWith(Parameterized.class)\n    public static class TestIllegalFSAccess {\n        private final String apocProcedure;\n\n        public TestIllegalFSAccess(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final Map<String, List<String>> APOC_PROCEDURE_ARGUMENTS = Map.of(\n                \"query\", List.of(\n                        \"\\\"RETURN 'hello' as key\\\", './hello', {}\",\n                        \"\\\"RETURN 'hello' as key\\\", './hello', {stream:true}\",\n                        \"\\\"RETURN 'hello' as key\\\", '  ', {}\"\n                ),\n                \"all\", List.of(\n                        \"'./hello', {}\",\n                        \"'./hello', {stream:true}\",\n                        \"'  ', {}\"\n                ),\n                \"data\", List.of(\n                        \"[], [], './hello', {}\",\n                        \"[], [], './hello', {stream:true}\",\n                        \"[], [], '  ', {}\"\n                ),\n                \"graph\", List.of(\n                        \"{nodes: [], relationships: []}, './hello', {}\",\n                        \"{nodes: [], relationships: []}, './hello', {stream:true}\",\n                        \"{nodes: [], relationships: []}, '  ', {}\"\n                )\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(APOC_PROCEDURE_ARGUMENTS);\n        }\n\n        @Test\n        public void testIllegalFSAccessExport() {\n            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n            );\n\n            assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n        }\n    }\n\n    @RunWith(Parameterized.class)\n    public static class TestIllegalExternalFSAccess {\n        private final String apocProcedure;\n\n        public TestIllegalExternalFSAccess(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\", List.of(\n                        \"\\\"RETURN 'hello' as key\\\", '../hello', {}\",\n                        \"\\\"RETURN 'hello' as key\\\", 'file:../hello', {}\"\n                ),\n                \"all\", List.of(\n                        \"'../hello', {}\",\n                        \"'file:../hello', {}\"\n                ),\n                \"data\", List.of(\n                        \"[], [], '../hello', {}\",\n                        \"[], [], 'file:../hello', {}\"\n                ),\n                \"graph\", List.of(\n                        \"{nodes: [], relationships: []}, '../hello', {}\",\n                        \"{nodes: [], relationships: []}, 'file:../hello', {}\"\n                )\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testIllegalExternalFSAccessExport() {\n            final String message = apocProcedure + \" should throw an exception\";\n            try {\n                setFileExport(true);\n                db.executeTransactionally(\"CALL \" + apocProcedure, Map.of(),\n                        Result::resultAsString);\n                fail(message);\n            } catch (Exception e) {\n                assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n            } finally {\n                setFileExport(false);\n            }\n        }\n    }\n\n    @RunWith(Parameterized.class)\n    public static class TestPathTraversalAccess {\n        private final String apocProcedure;\n\n        public TestPathTraversalAccess(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final String case1 = \"'file:///%2e%2e%2f%2f%2e%2e%2f%2f%2e%2e%2f%2f%2e%2e%2f%2fapoc/test.txt'\";\n        private static final String case2 = \"'file:///%2e%2e%2f%2ftest.txt'\";\n        private static final String case3 = \"'../test.txt'\";\n        private static final String case4 = \"'tests/../../test.txt'\";\n        private static final String case5 = \"'tests/..//..//test.txt'\";\n\n        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5);\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\",  cases.stream().map(\n                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"all\", cases.stream().map(\n                        filePath -> filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"data\", cases.stream().map(\n                        filePath -> \"[], [], \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"graph\", cases.stream().map(\n                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n                ).collect(Collectors.toList())\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testPathTraversal() {\n            setFileExport(true);\n\n            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n            );\n\n            assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n            setFileExport(false);\n        }\n    }\n\n    /**\n     * All of these will resolve to a local path after normalization which will point to\n     * a non-existing directory in our import folder: /apoc. Causing them to error that is\n     * not found. They all attempt to exit the import folder back to the apoc folder:\n     * Directory Layout: .../apoc/core/target/import\n     */\n    @RunWith(Parameterized.class)\n    public static class TestPathTraversalIsNormalised {\n        private final String apocProcedure;\n\n        public TestPathTraversalIsNormalised(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final String case1 = \"'file://%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f/apoc/test.txt'\";\n        private static final String case2 = \"'file://../../../../apoc/test.txt'\";\n        private static final String case3 = \"'file:///..//..//..//..//apoc//core//..//test.txt'\";\n        private static final String case4 = \"'file:///..//..//..//..//apoc/test.txt'\";\n        private static final String case5 = \"'file://\" + directory.getAbsolutePath() + \"//..//..//..//..//apoc/test.txt'\";\n        private static final String case6 = \"'file:///%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f/apoc/test.txt'\";\n\n        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5, case6);\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\", cases.stream().map(\n                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"all\", cases.stream().map(\n                        filePath -> filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"data\", cases.stream().map(\n                        filePath -> \"[], [], \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"graph\", cases.stream().map(\n                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n                ).collect(Collectors.toList())\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testPathTraversal() {\n            setFileExport(true);\n\n            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n            );\n\n            TestCase.assertTrue(e.getMessage().contains(\"apoc/test.txt (No such file or directory)\"));\n            setFileExport(false);\n        }\n    }\n\n    /**\n     * These tests normalize the path to be within the import directory and make the file there.\n     * Some attempt to exit the directory.\n     * They result in a file name test.txt being created (and deleted after).\n     */\n    @RunWith(Parameterized.class)\n    public static class TestPathTraversalIsNormalisedWithinDirectory {\n        private final String apocProcedure;\n\n        public TestPathTraversalIsNormalisedWithinDirectory(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final String case1 = \"'file:///..//..//..//..//apoc//..//..//..//..//test.txt'\";\n        private static final String case2 = \"'file:///..//..//..//..//apoc//..//test.txt'\";\n        private static final String case3 = \"'file:///../import/../import//..//test.txt'\";\n        private static final String case4 = \"'file://test.txt'\";\n        private static final String case5 = \"'file://tests/../test.txt'\";\n        private static final String case6 = \"'file:///tests//..//test.txt'\";\n        private static final String case7 = \"'test.txt'\";\n        private static final String case8 = \"'file:///..//..//..//..//test.txt'\";\n\n        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5, case6, case7, case8);\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\", cases.stream().map(\n                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"all\", cases.stream().map(\n                        filePath -> filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"data\", cases.stream().map(\n                        filePath -> \"[], [], \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"graph\", cases.stream().map(\n                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n                ).collect(Collectors.toList())\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testPathTraversal() {\n            setFileExport(true);\n\n            TestUtil.testCall(db, \"CALL \" + apocProcedure,\n                    (r) -> assertTrue(((String) r.get(\"file\")).contains(\"test.txt\"))\n            );\n\n            File f = new File(directory.getAbsolutePath() + \"/test.txt\");\n            TestCase.assertTrue(f.exists());\n            TestCase.assertTrue(f.delete());\n        }\n    }\n\n    /*\n     * These test cases attempt to access a directory with the same prefix as the import directory. This is design to\n     * test \"directoryName.startsWith\" logic which is a common path traversal bug.\n     *\n     * All these tests should fail because they access a directory which isn't the configured directory\n     */\n    @RunWith(Parameterized.class)\n    public static class TestPathTraversalIsWithSimilarDirectoryName {\n        private final String apocProcedure;\n\n        public TestPathTraversalIsWithSimilarDirectoryName(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final String case1 = \"'../imported/test.txt'\";\n        private static final String case2 = \"'tests/../../imported/test.txt'\";\n\n        private static final List<String> cases = Arrays.asList(case1, case2);\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\", cases.stream().map(\n                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"all\", cases.stream().map(\n                        filePath -> filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"data\", cases.stream().map(\n                        filePath -> \"[], [], \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"graph\", cases.stream().map(\n                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n                ).collect(Collectors.toList())\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testPathTraversal() {\n            setFileExport(true);\n\n            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n                    () -> TestUtil.testCall(db, \"CALL \" + apocProcedure, (r) -> {})\n            );\n\n            assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n\n            setFileExport(false);\n        }\n    }\n\n\n    /**\n     * These tests normalize the path to be within the import directory and step into a subdirectory\n     * to make the file there.\n     * Some attempt to exit the directory.\n     * They result in a file name test.txt in the directory /tests being created (and deleted after).\n     */\n    @RunWith(Parameterized.class)\n    public static class TestPathTraversAllowedWithinDirectory {\n        private final String apocProcedure;\n\n        public TestPathTraversAllowedWithinDirectory(String exportMethod, String exportMethodType, String exportMethodArguments) {\n            this.apocProcedure = \"apoc.export.\" + exportMethod + \".\" + exportMethodType + \"(\" + exportMethodArguments + \")\";\n        }\n\n        private static final String case1 = \"'file:///../import/../import//..//tests/test.txt'\";\n        private static final String case2 = \"'file:///..//..//..//..//apoc//..//tests/test.txt'\";\n        private static final String case3 = \"'file:///../import/../import//..//tests/../tests/test.txt'\";\n        private static final String case4 = \"'file:///tests/test.txt'\";\n        private static final String case5 = \"'tests/test.txt'\";\n\n        private static final List<String> cases = Arrays.asList(case1, case2, case3, case4, case5);\n\n        private static final Map<String, List<String>> METHOD_ARGUMENTS = Map.of(\n                \"query\", cases.stream().map(\n                        filePath -> \"\\\"RETURN 1\\\", \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"all\", cases.stream().map(\n                        filePath -> filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"data\", cases.stream().map(\n                        filePath -> \"[], [], \" + filePath + \", {}\"\n                ).collect(Collectors.toList()),\n                \"graph\", cases.stream().map(\n                        filePath -> \"{nodes: [], relationships: []}, \" + filePath + \", {}\"\n                ).collect(Collectors.toList())\n        );\n\n        @Parameterized.Parameters\n        public static Collection<String[]> data() {\n            return ExportCoreSecurityTest.data(METHOD_ARGUMENTS);\n        }\n\n        @Test\n        public void testPathTraversal() {\n            setFileExport(true);\n\n            TestUtil.testCall(db, \"CALL \" + apocProcedure,\n                    (r) -> assertTrue(((String) r.get(\"file\")).contains(\"tests/test.txt\"))\n            );\n\n            File f = new File(subDirectory.getAbsolutePath() + \"/test.txt\");\n            TestCase.assertTrue(f.exists());\n            TestCase.assertTrue(f.delete());\n        }\n    }\n\n    public static class TestCypherSchema {\n        private final String apocProcedure = \"apoc.export.cypher.schema(%s)\";\n\n        @Test\n        public void testIllegalFSAccessExportCypherSchema() {\n            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n                    () -> TestUtil.testCall(db, String.format(\"CALL \" + apocProcedure, \"'./hello', {}\"), (r) -> {})\n            );\n            assertError(e, ApocConfig.EXPORT_TO_FILE_ERROR, RuntimeException.class, apocProcedure);\n        }\n\n        @Test\n        public void testIllegalExternalFSAccessExportCypherSchema() {\n            setFileExport(true);\n            QueryExecutionException e = Assert.assertThrows(QueryExecutionException.class,\n                    () -> TestUtil.testCall(db, String.format(\"CALL \" + apocProcedure, \"'../hello', {}\"), (r) -> {})\n            );\n            assertError(e, FileUtils.ACCESS_OUTSIDE_DIR_ERROR, IOException.class, apocProcedure);\n            setFileExport(false);\n        }\n    }\n\n    private static void assertError(Exception e, String errorMessage, Class<? extends Exception> exceptionType, String apocProcedure) {\n        final Throwable rootCause = ExceptionUtils.getRootCause(e);\n        assertTrue(apocProcedure + \" should throw an instance of \" + exceptionType.getSimpleName(), exceptionType.isInstance(rootCause));\n        assertEquals(apocProcedure + \" should throw the following message\", errorMessage, rootCause.getMessage());\n    }\n\n}", "package apoc.export.csv;\n\nimport apoc.ApocSettings;\nimport apoc.graph.Graphs;\nimport apoc.util.BinaryTestUtil;\nimport apoc.util.CompressionAlgo;\nimport apoc.meta.Meta;\nimport apoc.util.CompressionConfig;\nimport apoc.util.TestUtil;\nimport apoc.util.Util;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.neo4j.configuration.GraphDatabaseSettings;\nimport org.neo4j.graphdb.Result;\nimport org.neo4j.internal.helpers.collection.Iterators;\nimport org.neo4j.test.rule.DbmsRule;\nimport org.neo4j.test.rule.ImpermanentDbmsRule;\n\nimport java.io.File;\nimport java.nio.charset.Charset;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.function.Consumer;\n\nimport static apoc.util.BinaryTestUtil.getDecompressedData;\nimport static apoc.util.CompressionAlgo.DEFLATE;\nimport static apoc.util.CompressionAlgo.GZIP;\nimport static apoc.util.CompressionAlgo.NONE;\nimport static apoc.util.MapUtil.map;\nimport static apoc.util.TestUtil.testResult;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static junit.framework.TestCase.assertTrue;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\n/**\n * @author mh\n * @since 22.05.16\n */\npublic class ExportCsvTest {\n\n    private static final String EXPECTED_QUERY_NODES = String.format(\"\\\"u\\\"%n\" +\n            \"\\\"{\\\"\\\"id\\\"\\\":0,\\\"\\\"labels\\\"\\\":[\\\"\\\"User\\\"\\\",\\\"\\\"User1\\\"\\\"],\\\"\\\"properties\\\"\\\":{\\\"\\\"name\\\"\\\":\\\"\\\"foo\\\"\\\",\\\"\\\"male\\\"\\\":true,\\\"\\\"age\\\"\\\":42,\\\"\\\"kids\\\"\\\":[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]}}\\\"%n\" +\n            \"\\\"{\\\"\\\"id\\\"\\\":1,\\\"\\\"labels\\\"\\\":[\\\"\\\"User\\\"\\\"],\\\"\\\"properties\\\"\\\":{\\\"\\\"name\\\"\\\":\\\"\\\"bar\\\"\\\",\\\"\\\"age\\\"\\\":42}}\\\"%n\" +\n            \"\\\"{\\\"\\\"id\\\"\\\":2,\\\"\\\"labels\\\"\\\":[\\\"\\\"User\\\"\\\"],\\\"\\\"properties\\\"\\\":{\\\"\\\"age\\\"\\\":12}}\\\"%n\");\n    private static final String EXPECTED_QUERY = String.format(\"\\\"u.age\\\",\\\"u.name\\\",\\\"u.male\\\",\\\"u.kids\\\",\\\"labels(u)\\\"%n\" +\n            \"\\\"42\\\",\\\"foo\\\",\\\"true\\\",\\\"[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]\\\",\\\"[\\\"\\\"User1\\\"\\\",\\\"\\\"User\\\"\\\"]\\\"%n\" +\n            \"\\\"42\\\",\\\"bar\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"User\\\"\\\"]\\\"%n\" +\n            \"\\\"12\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"User\\\"\\\"]\\\"%n\");\n    private static final String EXPECTED_QUERY_WITHOUT_QUOTES = String.format(\"u.age,u.name,u.male,u.kids,labels(u)%n\" +\n            \"42,foo,true,[\\\"a\\\",\\\"b\\\",\\\"c\\\"],[\\\"User1\\\",\\\"User\\\"]%n\" +\n            \"42,bar,,,[\\\"User\\\"]%n\" +\n            \"12,,,,[\\\"User\\\"]%n\");\n    private static final String EXPECTED_QUERY_QUOTES_NONE = String.format(\"a.name,a.city,a.street,labels(a)%n\" +\n            \"Andrea,Milano,Via Garibaldi, 7,[\\\"Address1\\\",\\\"Address\\\"]%n\" +\n            \"Bar Sport,,,[\\\"Address\\\"]%n\" +\n            \",,via Benni,[\\\"Address\\\"]%n\");\n    private static final String EXPECTED_QUERY_QUOTES_ALWAYS = String.format(\"\\\"a.name\\\",\\\"a.city\\\",\\\"a.street\\\",\\\"labels(a)\\\"%n\" +\n            \"\\\"Andrea\\\",\\\"Milano\\\",\\\"Via Garibaldi, 7\\\",\\\"[\\\"\\\"Address1\\\"\\\",\\\"\\\"Address\\\"\\\"]\\\"%n\" +\n            \"\\\"Bar Sport\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"Address\\\"\\\"]\\\"%n\" +\n            \"\\\"\\\",\\\"\\\",\\\"via Benni\\\",\\\"[\\\"\\\"Address\\\"\\\"]\\\"%n\");\n    private static final String EXPECTED_QUERY_QUOTES_NEEDED = String.format(\"a.name,a.city,a.street,labels(a)%n\" +\n            \"Andrea,Milano,\\\"Via Garibaldi, 7\\\",\\\"[\\\"Address1\\\",\\\"Address\\\"]\\\"%n\" +\n            \"Bar Sport,,,\\\"[\\\"Address\\\"]\\\"%n\" +\n            \",,via Benni,\\\"[\\\"Address\\\"]\\\"%n\");\n    private static final String EXPECTED = String.format(\"\\\"_id\\\",\\\"_labels\\\",\\\"age\\\",\\\"city\\\",\\\"kids\\\",\\\"male\\\",\\\"name\\\",\\\"street\\\",\\\"_start\\\",\\\"_end\\\",\\\"_type\\\"%n\" +\n            \"\\\"0\\\",\\\":User:User1\\\",\\\"42\\\",\\\"\\\",\\\"[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]\\\",\\\"true\\\",\\\"foo\\\",\\\"\\\",,,%n\" +\n            \"\\\"1\\\",\\\":User\\\",\\\"42\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"bar\\\",\\\"\\\",,,%n\" +\n            \"\\\"2\\\",\\\":User\\\",\\\"12\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,%n\" +\n            \"\\\"3\\\",\\\":Address:Address1\\\",\\\"\\\",\\\"Milano\\\",\\\"\\\",\\\"\\\",\\\"Andrea\\\",\\\"Via Garibaldi, 7\\\",,,%n\" +\n            \"\\\"4\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Bar Sport\\\",\\\"\\\",,,%n\" +\n            \"\\\"5\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"via Benni\\\",,,%n\" +\n            \",,,,,,,,\\\"0\\\",\\\"1\\\",\\\"KNOWS\\\"%n\" +\n            \",,,,,,,,\\\"3\\\",\\\"4\\\",\\\"NEXT_DELIVERY\\\"%n\");\n\n    private static final String EXP_SAMPLE = \"\\\"_id\\\",\\\"_labels\\\",\\\"address\\\",\\\"age\\\",\\\"baz\\\",\\\"city\\\",\\\"foo\\\",\\\"kids\\\",\\\"last:Name\\\",\\\"male\\\",\\\"name\\\",\\\"street\\\",\\\"_start\\\",\\\"_end\\\",\\\"_type\\\",\\\"one\\\",\\\"three\\\"\\n\" +\n            \"\\\"0\\\",\\\":User:User1\\\",\\\"\\\",\\\"42\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"[\\\"\\\"a\\\"\\\",\\\"\\\"b\\\"\\\",\\\"\\\"c\\\"\\\"]\\\",\\\"\\\",\\\"true\\\",\\\"foo\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"1\\\",\\\":User\\\",\\\"\\\",\\\"42\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"bar\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"2\\\",\\\":User\\\",\\\"\\\",\\\"12\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"3\\\",\\\":Address:Address1\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Milano\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Andrea\\\",\\\"Via Garibaldi, 7\\\",,,,,\\n\" +\n            \"\\\"4\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Bar Sport\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"5\\\",\\\":Address\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"via Benni\\\",,,,,\\n\" +\n            \"\\\"6\\\",\\\":Sample:User\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"Galilei\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"7\\\",\\\":Sample:User\\\",\\\"Universe\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"8\\\",\\\":Sample:User\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"bar\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \"\\\"9\\\",\\\":Sample:User\\\",\\\"\\\",\\\"\\\",\\\"baa\\\",\\\"\\\",\\\"true\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",,,,,\\n\" +\n            \",,,,,,,,,,,,\\\"0\\\",\\\"1\\\",\\\"KNOWS\\\",\\\"\\\",\\\"\\\"\\n\" +\n            \",,,,,,,,,,,,\\\"3\\\",\\\"4\\\",\\\"NEXT_DELIVERY\\\",\\\"\\\",\\\"\\\"\\n\" +\n            \",,,,,,,,,,,,\\\"8\\\",\\\"9\\\",\\\"KNOWS\\\",\\\"two\\\",\\\"four\\\"\\n\";\n\n    private static final String EXPECTED_NONE_QUOTES = String.format(\"_id,_labels,age,city,kids,male,name,street,_start,_end,_type%n\" +\n            \"0,:User:User1,42,,[\\\"a\\\",\\\"b\\\",\\\"c\\\"],true,foo,,,,%n\" +\n            \"1,:User,42,,,,bar,,,,%n\" +\n            \"2,:User,12,,,,,,,,%n\" +\n            \"3,:Address:Address1,,Milano,,,Andrea,Via Garibaldi, 7,,,%n\" +\n            \"4,:Address,,,,,Bar Sport,,,,%n\" +\n            \"5,:Address,,,,,,via Benni,,,%n\" +\n            \",,,,,,,,0,1,KNOWS%n\" +\n            \",,,,,,,,3,4,NEXT_DELIVERY%n\");\n    private static final String EXPECTED_NEEDED_QUOTES = String.format(\"_id,_labels,age,city,kids,male,name,street,_start,_end,_type%n\" +\n            \"0,:User:User1,42,,\\\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\\\",true,foo,,,,%n\" +\n            \"1,:User,42,,,,bar,,,,%n\" +\n            \"2,:User,12,,,,,,,,%n\" +\n            \"3,:Address:Address1,,Milano,,,Andrea,\\\"Via Garibaldi, 7\\\",,,%n\" +\n            \"4,:Address,,,,,Bar Sport,,,,%n\" +\n            \"5,:Address,,,,,,via Benni,,,%n\" +\n            \",,,,,,,,0,1,KNOWS%n\" +\n            \",,,,,,,,3,4,NEXT_DELIVERY%n\");\n\n    private static final File directory = new File(\"target/import\");\n    static {\n        //noinspection ResultOfMethodCallIgnored\n        directory.mkdirs();\n    }\n\n    @ClassRule\n    public static DbmsRule db = new ImpermanentDbmsRule()\n            .withSetting(GraphDatabaseSettings.load_csv_file_url_root, directory.toPath().toAbsolutePath())\n            .withSetting(ApocSettings.apoc_export_file_enabled, true)\n            .withSetting(ApocSettings.apoc_import_file_enabled, true);\n\n    @BeforeClass\n    public static void setUp() throws Exception {\n        TestUtil.registerProcedure(db, ExportCSV.class, Graphs.class, Meta.class, ImportCsv.class);\n        db.executeTransactionally(\"CREATE (f:User1:User {name:'foo',age:42,male:true,kids:['a','b','c']})-[:KNOWS]->(b:User {name:'bar',age:42}),(c:User {age:12})\");\n        db.executeTransactionally(\"CREATE (f:Address1:Address {name:'Andrea', city: 'Milano', street:'Via Garibaldi, 7'})-[:NEXT_DELIVERY]->(a:Address {name: 'Bar Sport'}), (b:Address {street: 'via Benni'})\");\n    }\n\n    private String readFile(String fileName) {\n        return readFile(fileName, UTF_8, CompressionAlgo.NONE);\n    }\n    \n    private String readFile(String fileName, Charset charset, CompressionAlgo compression) {\n        return BinaryTestUtil.readFileToString(new File(directory, fileName), charset, compression);\n    }\n\n    @Test\n    public void testExportInvalidQuoteValue() throws Exception {\n        try {\n            String fileName = \"all.csv\";\n            TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: 'Invalid'})\",\n                    map(\"file\", fileName),\n                    (r) -> assertResults(fileName, r, \"database\"));\n            fail();\n        } catch (RuntimeException e) {\n            final String expectedMessage = \"Failed to invoke procedure `apoc.export.csv.all`: Caused by: java.lang.RuntimeException: The string value of the field quote is not valid\";\n            assertEquals(expectedMessage, e.getMessage());\n        }\n    }\n    \n    @Test\n    public void testExportAllCsvCompressed() {\n        final CompressionAlgo compressionAlgo = DEFLATE;\n        String fileName = \"all.csv.zz\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file, $config)\",\n                map(\"file\", fileName, \"config\", map(\"compression\", compressionAlgo.name())),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED, readFile(fileName, UTF_8, compressionAlgo));\n    }\n    \n    @Test\n    public void testCsvRoundTrip() {\n        db.executeTransactionally(\"CREATE (f:Roundtrip {name:'foo',age:42,male:true,kids:['a','b','c']}),(b:Roundtrip {name:'bar',age:42}),(c:Roundtrip {age:12})\");\n        \n        String fileName = \"separatedFiles.csv.gzip\";\n        final Map<String, Object> params = map(\"file\", fileName, \"query\", \"MATCH (u:Roundtrip) return u.name as name\", \n                \"config\", map(CompressionConfig.COMPRESSION, GZIP.name()));\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query, $file, $config)\", params,\n                (r) -> assertEquals(fileName, r.get(\"file\")));\n\n        final String deleteQuery = \"MATCH (n:Roundtrip) DETACH DELETE n\";\n        db.executeTransactionally(deleteQuery);\n\n        TestUtil.testCall(db, \"CALL apoc.import.csv([{fileName: $file, labels: ['Roundtrip']}], [], $config) \", params, \n                r -> assertEquals(3L, r.get(\"nodes\")));\n\n        TestUtil.testResult(db, \"MATCH (n:Roundtrip) return n.name as name\", r -> {\n            final Set<String> actual = Iterators.asSet(r.columnAs(\"name\"));\n            assertEquals(Set.of(\"foo\", \"bar\", \"\"), actual);\n        });\n\n        db.executeTransactionally(deleteQuery);\n    }\n\n    @Test\n    public void testExportAllCsv() throws Exception {\n        String fileName = \"all.csv\";\n        testExportCsvAllCommon(fileName);\n    }\n\n    @Test\n    public void testExportAllCsvWithDotInName() {\n        String fileName = \"all.with.dot.filename.csv\";\n        testExportCsvAllCommon(fileName);\n    }\n\n    @Test\n    public void testExportAllCsvWithoutExtension() {\n        String fileName = \"all\";\n        testExportCsvAllCommon(fileName);\n    }\n\n    private void testExportCsvAllCommon(String fileName) {\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,null)\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED, readFile(fileName));\n    }\n\n    @Test\n    public void testExportAllCsvWithSample() throws IOException {\n        db.executeTransactionally(\"CREATE (:User:Sample {`last:Name`:'Galilei'}), (:User:Sample {address:'Universe'}),\\n\" +\n                \"(:User:Sample {foo:'bar'})-[:KNOWS {one: 'two', three: 'four'}]->(:User:Sample {baz:'baa', foo: true})\");\n        String fileName = \"all.csv\";\n        final long totalNodes = 10L;\n        final long totalRels = 3L;\n        final long totalProps = 19L;\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file, null)\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\", totalNodes, totalRels, totalProps, true));\n        assertEquals(EXP_SAMPLE, readFile(fileName));\n\n        // quotes: 'none' to simplify header testing\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file, {sampling: true, samplingConfig: {sample: 1}, quotes: 'none'})\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\", totalNodes, totalRels, totalProps, false));\n        \n        final String[] s = Files.lines(new File(directory, fileName).toPath()).findFirst().get().split(\",\");\n        assertTrue(s.length < 17);\n        assertTrue(Arrays.asList(s).containsAll(List.of(\"_id\", \"_labels\", \"_start\", \"_end\", \"_type\")));\n        \n        db.executeTransactionally(\"MATCH (n:Sample) DETACH DELETE n\");\n    }\n\n    @Test\n    public void testExportAllCsvWithQuotes() throws Exception {\n        String fileName = \"all.csv\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: true})\",\n                map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED, readFile(fileName));\n    }\n\n    @Test\n    public void testExportAllCsvWithoutQuotes() throws Exception {\n        String fileName = \"all.csv\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: 'none'})\",\n                map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED_NONE_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportAllCsvNeededQuotes() throws Exception {\n        String fileName = \"all.csv\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.all($file,{quotes: 'ifNeeded'})\",\n                map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"database\"));\n        assertEquals(EXPECTED_NEEDED_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportGraphCsv() throws Exception {\n        String fileName = \"graph.csv\";\n        TestUtil.testCall(db, \"CALL apoc.graph.fromDB('test',{}) yield graph \" +\n                        \"CALL apoc.export.csv.graph(graph, $file,{quotes: 'none'}) \" +\n                        \"YIELD nodes, relationships, properties, file, source,format, time \" +\n                        \"RETURN *\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"graph\"));\n        assertEquals(EXPECTED_NONE_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportGraphCsvWithoutQuotes() throws Exception {\n        String fileName = \"graph.csv\";\n        TestUtil.testCall(db, \"CALL apoc.graph.fromDB('test',{}) yield graph \" +\n                        \"CALL apoc.export.csv.graph(graph, $file,null) \" +\n                        \"YIELD nodes, relationships, properties, file, source,format, time \" +\n                        \"RETURN *\", map(\"file\", fileName),\n                (r) -> assertResults(fileName, r, \"graph\"));\n        assertEquals(EXPECTED, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryCsv() throws Exception {\n        String fileName = \"query.csv\";\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,null)\",\n                map(\"file\", fileName, \"query\", query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(5)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryCsvWithoutQuotes() throws Exception {\n        String fileName = \"query.csv\";\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,{quotes: false})\",\n                map(\"file\", fileName, \"query\", query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(5)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY_WITHOUT_QUOTES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryNodesCsv() throws Exception {\n        String fileName = \"query_nodes.csv\";\n        String query = \"MATCH (u:User) return u\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,null)\",\n                map(\"file\", fileName, \"query\", query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(1)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY_NODES, readFile(fileName));\n    }\n\n    @Test\n    public void testExportQueryNodesCsvParams() throws Exception {\n        String fileName = \"query_nodes.csv\";\n        String query = \"MATCH (u:User) WHERE u.age > $age return u\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query,$file,{params:{age:10}})\", map(\"file\", fileName,\"query\",query),\n                (r) -> {\n                    assertTrue(\"Should get statement\",r.get(\"source\").toString().contains(\"statement: cols(1)\"));\n                    assertEquals(fileName, r.get(\"file\"));\n                    assertEquals(\"csv\", r.get(\"format\"));\n\n                });\n        assertEquals(EXPECTED_QUERY_NODES, readFile(fileName));\n    }\n\n    private void assertResults(String fileName, Map<String, Object> r, final String source) {\n        assertResults(fileName, r, source, 6L, 2L, 12L, true);\n    }\n\n    private void assertResults(String fileName, Map<String, Object> r, final String source, \n                               Long expectedNodes, Long expectedRelationships, Long expectedProperties, boolean assertPropEquality) {\n        assertEquals(expectedNodes, r.get(\"nodes\"));\n        assertEquals(expectedRelationships, r.get(\"relationships\"));\n        if (assertPropEquality) {\n            assertEquals(expectedProperties, r.get(\"properties\"));\n        } else {\n            assertTrue((Long) r.get(\"properties\") < expectedProperties);\n        }\n        final String expectedSource = source + \": nodes(\" + expectedNodes + \"), rels(\" + expectedRelationships + \")\";\n        assertEquals(expectedSource, r.get(\"source\"));\n        assertCsvCommon(fileName, r);\n    }\n\n    private void assertCsvCommon(String fileName, Map<String, Object> r) {\n        assertEquals(fileName, r.get(\"file\"));\n        assertEquals(\"csv\", r.get(\"format\"));\n        assertTrue(\"Should get time greater than 0\",((long) r.get(\"time\")) >= 0);\n    }\n\n    @Test public void testExportAllCsvStreaming() throws Exception {\n        String statement = \"CALL apoc.export.csv.all(null,{stream:true,batchSize:2,useOptimizations:{unwindBatchSize:2}})\";\n        assertExportStreaming(statement, NONE);\n    }\n    \n    @Test\n    public void testExportAllCsvStreamingCompressed() throws Exception {\n        final CompressionAlgo algo = GZIP;\n        String statement = \"CALL apoc.export.csv.all(null, {compression: '\" + algo.name() + \"',stream:true,batchSize:2,useOptimizations:{unwindBatchSize:2}})\";\n        assertExportStreaming(statement, algo);\n    }\n\n    private void assertExportStreaming(String statement, CompressionAlgo algo) {\n        StringBuilder sb=new StringBuilder();\n        testResult(db, statement, (res) -> {\n            Map<String, Object> r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(1L, r.get(\"batches\"));\n            assertEquals(2L, r.get(\"nodes\"));\n            assertEquals(2L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(6L, r.get(\"properties\"));\n            assertNull(\"Should get file\", r.get(\"file\"));\n            assertEquals(\"csv\", r.get(\"format\"));\n            assertTrue(\"Should get time greater than 0\", ((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(2L, r.get(\"batches\"));\n            assertEquals(4L, r.get(\"nodes\"));\n            assertEquals(4L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(10L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\", ((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(3L, r.get(\"batches\"));\n            assertEquals(6L, r.get(\"nodes\"));\n            assertEquals(6L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(12L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\", ((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(4L, r.get(\"batches\"));\n            assertEquals(6L, r.get(\"nodes\"));\n            assertEquals(8L, r.get(\"rows\"));\n            assertEquals(2L, r.get(\"relationships\"));\n            assertEquals(12L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\",((long) r.get(\"time\")) >= 0);\n            sb.append(getDecompressedData(algo, r.get(\"data\")));\n            res.close();\n        });\n        assertEquals(EXPECTED, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreaming() throws Exception {\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchUsers(sb));\n        assertEquals(EXPECTED_QUERY, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreamingWithoutQuotes() throws Exception {\n        String query = \"MATCH (u:User) return u.age, u.name, u.male, u.kids, labels(u)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: false, stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchUsers(sb));\n\n        assertEquals(EXPECTED_QUERY_WITHOUT_QUOTES, sb.toString());\n    }\n\n    private Consumer<Result> getAndCheckStreamingMetadataQueryMatchUsers(StringBuilder sb)\n    {\n        return (res) -> {\n            Map<String, Object> r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(1L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(2L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(10L, r.get(\"properties\"));\n            assertNull(\"Should get file\", r.get(\"file\"));\n            assertEquals(\"csv\", r.get(\"format\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\")); r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(2L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(3L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(15L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\"));\n        };\n    }\n\n    @Test public void testCypherCsvStreamingWithAlwaysQuotes() throws Exception {\n        String query = \"MATCH (a:Address) return a.name, a.city, a.street, labels(a)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: 'always', stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchAddress(sb));\n\n        assertEquals(EXPECTED_QUERY_QUOTES_ALWAYS, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreamingWithNeededQuotes() throws Exception {\n        String query = \"MATCH (a:Address) return a.name, a.city, a.street, labels(a)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: 'ifNeeded', stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchAddress(sb));\n\n        assertEquals(EXPECTED_QUERY_QUOTES_NEEDED, sb.toString());\n    }\n\n    @Test public void testCypherCsvStreamingWithNoneQuotes() throws Exception {\n        String query = \"MATCH (a:Address) return a.name, a.city, a.street, labels(a)\";\n        StringBuilder sb = new StringBuilder();\n        testResult(db, \"CALL apoc.export.csv.query($query,null,{quotes: 'none', stream:true,batchSize:2, useOptimizations:{unwindBatchSize:2}})\", map(\"query\",query),\n                getAndCheckStreamingMetadataQueryMatchAddress(sb));\n\n        assertEquals(EXPECTED_QUERY_QUOTES_NONE, sb.toString());\n    }\n\n    @Test\n    public void testExportQueryCsvIssue1188() throws Exception {\n        String copyright = \"\\n\" +\n                \"(c) 2018 Hovsepian, Albanese, et al. \\\"\\\"ASCB(r),\\\"\\\" \\\"\\\"The American Society for Cell Biology(r),\\\"\\\" and \\\"\\\"Molecular Biology of the Cell(r)\\\"\\\" are registered trademarks of The American Society for Cell Biology.\\n\" +\n                \"2018\\n\" +\n                \"\\n\" +\n                \"This article is distributed by The American Society for Cell Biology under license from the author(s). Two months after publication it is available to the public under an Attribution-Noncommercial-Share Alike 3.0 Unported Creative Commons License.\\n\" +\n                \"\\n\";\n        String pk = \"5921569\";\n        db.executeTransactionally(\"CREATE (n:Document{pk:$pk, copyright: $copyright})\", map(\"copyright\", copyright, \"pk\", pk));\n        String query = \"MATCH (n:Document{pk:'5921569'}) return n.pk as pk, n.copyright as copyright\";\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query, null, $config)\", map(\"query\", query,\n                \"config\", map(\"stream\", true)),\n                (r) -> {\n                    List<String[]> csv = CsvTestUtil.toCollection(r.get(\"data\").toString());\n                    assertEquals(2, csv.size());\n                    assertArrayEquals(new String[]{\"pk\",\"copyright\"}, csv.get(0));\n                    assertArrayEquals(new String[]{\"5921569\",copyright}, csv.get(1));\n                });\n        db.executeTransactionally(\"MATCH (d:Document) DETACH DELETE d\");\n\n    }\n\n    @Test\n    public void testExportWgsPoint() {\n        db.executeTransactionally(\"CREATE (p:Position {place: point({latitude: 12.78, longitude: 56.7, height: 1.1})})\");\n\n        TestUtil.testCall(db, \"CALL apoc.export.csv.query($query, null, {quotes: 'none', stream: true}) YIELD data RETURN data\",\n                map(\"query\", \"MATCH (p:Position) RETURN p.place as place\"),\n                (r) -> {\n                    String data = (String) r.get(\"data\");\n                    Map<String, Object> place = Util.fromJson(data.split(System.lineSeparator())[1], Map.class);\n                    assertEquals(12.78D, (double) place.get(\"latitude\"), 0);\n                    assertEquals(56.7D, (double) place.get(\"longitude\"), 0);\n                    assertEquals(1.1D, (double) place.get(\"height\"), 0);\n                });\n        db.executeTransactionally(\"MATCH (n:Position) DETACH DELETE n\");\n    }\n\n    private Consumer<Result> getAndCheckStreamingMetadataQueryMatchAddress(StringBuilder sb)\n    {\n        return (res) -> {\n            Map<String, Object> r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(1L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(2L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(8L, r.get(\"properties\"));\n            assertNull(\"Should get file\", r.get(\"file\"));\n            assertEquals(\"csv\", r.get(\"format\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\"));\n            r = res.next();\n            assertEquals(2L, r.get(\"batchSize\"));\n            assertEquals(2L, r.get(\"batches\"));\n            assertEquals(0L, r.get(\"nodes\"));\n            assertEquals(3L, r.get(\"rows\"));\n            assertEquals(0L, r.get(\"relationships\"));\n            assertEquals(12L, r.get(\"properties\"));\n            assertTrue(\"Should get time greater than 0\",\n                    ((long) r.get(\"time\")) >= 0);\n            sb.append(r.get(\"data\"));\n        };\n    }\n\n}\n"], "filenames": ["core/src/main/java/apoc/export/csv/ExportCSV.java", "core/src/main/java/apoc/util/FileUtils.java", "core/src/test/java/apoc/export/ExportCoreSecurityTest.java", "core/src/test/java/apoc/export/csv/ExportCsvTest.java"], "buggy_code_start_loc": [119, 230, 10, 117], "buggy_code_end_loc": [122, 249, 204, 119], "fixing_code_start_loc": [119, 230, 11, 117], "fixing_code_end_loc": [122, 249, 468, 120], "type": "CWE-22", "message": "APOC (Awesome Procedures on Cypher) is an add-on library for Neo4j that provides hundreds of procedures and functions. A path traversal vulnerability found in the apoc.export.* procedures of apoc plugins in Neo4j Graph database. The issue allows a malicious actor to potentially break out of the expected directory. The vulnerability is such that files could only be created but not overwritten. For the vulnerability to be exploited, an attacker would need access to execute an arbitrary query, either by having access to an authenticated Neo4j client, or a Cypher injection vulnerability in an application. The minimum versions containing patch for this vulnerability are 4.4.0.12 and 4.3.0.12 and 5.3.1. As a workaround, you can control the allowlist of the procedures that can be used in your system, and/or turn off local file access by setting apoc.export.file.enabled=false.", "other": {"cve": {"id": "CVE-2022-23532", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-14T01:15:11.490", "lastModified": "2023-01-24T01:13:03.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "APOC (Awesome Procedures on Cypher) is an add-on library for Neo4j that provides hundreds of procedures and functions. A path traversal vulnerability found in the apoc.export.* procedures of apoc plugins in Neo4j Graph database. The issue allows a malicious actor to potentially break out of the expected directory. The vulnerability is such that files could only be created but not overwritten. For the vulnerability to be exploited, an attacker would need access to execute an arbitrary query, either by having access to an authenticated Neo4j client, or a Cypher injection vulnerability in an application. The minimum versions containing patch for this vulnerability are 4.4.0.12 and 4.3.0.12 and 5.3.1. As a workaround, you can control the allowlist of the procedures that can be used in your system, and/or turn off local file access by setting apoc.export.file.enabled=false."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neo4j:awesome_procedures_on_cyper:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.0.12", "matchCriteriaId": "4171A5D3-34F9-481D-A80B-508FED95B146"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neo4j:awesome_procedures_on_cyper:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4.0.0", "versionEndExcluding": "4.4.0.12", "matchCriteriaId": "76C867E7-C654-4EB5-B028-782BA2144330"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neo4j:awesome_procedures_on_cyper:5.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "FDAE0B98-CA77-4755-96C0-9C002EAA71EC"}]}]}], "references": [{"url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/security/advisories/GHSA-5v8v-gwmw-qw97", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/01e63ed2d187cd2a8aa1d78bf831ef0fdd69b522"}}