{"buggy_code": ["/*\n * Copyright (c) 2011-2014 Yubico AB\n * Copyright (c) 2011 Tollef Fog Heen <tfheen@err.no>\n * All rights reserved.\n *\n * Author : Fredrik Thulin <fredrik@yubico.com>\n * Author : Tollef Fog Heen <tfheen@err.no>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <glob.h>\n#include <unistd.h>\n\n#include \"util.h\"\n\n#if HAVE_CR\n/* for yubikey_hex_decode and yubikey_hex_p */\n#include <yubikey.h>\n#include <ykpbkdf2.h>\n\n#include <ykstatus.h>\n#include <ykdef.h>\n#endif /* HAVE_CR */\n\nint\nget_user_cfgfile_path(const char *common_path, const char *filename, const struct passwd *user, char **fn)\n{\n  /* Getting file from user home directory, e.g. ~/.yubico/challenge, or\n   * from a system wide directory.\n   *\n   * Format is hex(challenge):hex(response):slot num\n   */\n  char *userfile;\n  size_t len;\n\n  if (common_path != NULL) {\n    len = strlen(common_path) + 1 + strlen(filename) + 1;\n    if ((userfile = malloc(len)) == NULL) {\n      return 0;\n    }\n    snprintf(userfile, len, \"%s/%s\", common_path, filename);\n    *fn = userfile;\n    return 1;\n  }\n\n  /* No common path provided. Construct path to user's ~/.yubico/filename */\n\n  len = strlen(user->pw_dir) + 9 + strlen(filename) + 1;\n  if ((userfile = malloc(len)) == NULL) {\n    return 0;\n  }\n  snprintf(userfile, len, \"%s/.yubico/%s\", user->pw_dir, filename);\n  *fn = userfile;\n  return 1;\n}\n\n\n/*\n * This function will look for users name with valid user token id.\n *\n * Returns one of AUTH_FOUND, AUTH_NOT_FOUND, AUTH_NO_TOKENS, AUTH_ERROR.\n *\n * File format is as follows:\n * <user-name>:<token_id>:<token_id>\n * <user-name>:<token_id>\n *\n */\nint\ncheck_user_token (const char *authfile,\n\t\t  const char *username,\n\t\t  const char *otp_id,\n\t\t  int verbose,\n                  FILE *debug_file)\n{\n  char buf[1024];\n  char *s_user, *s_token;\n  int retval = AUTH_ERROR;\n  int fd;\n  struct stat st;\n  FILE *opwfile;\n\n  fd = open(authfile, O_RDONLY, 0);\n  if (fd < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot open file: %s (%s)\", authfile, strerror(errno));\n      return retval;\n  }\n\n  if (fstat(fd, &st) < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot stat file: %s (%s)\", authfile, strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  if (!S_ISREG(st.st_mode)) {\n      if(verbose)\n\t  D (debug_file, \"%s is not a regular file\", authfile);\n      close(fd);\n      return retval;\n  }\n\n  opwfile = fdopen(fd, \"r\");\n  if (opwfile == NULL) {\n      if(verbose)\n\t  D (debug_file, \"fdopen: %s\", strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  retval = AUTH_NO_TOKENS;\n  while (fgets (buf, 1024, opwfile))\n    {\n      char *saveptr = NULL;\n      if (buf[strlen (buf) - 1] == '\\n')\n\tbuf[strlen (buf) - 1] = '\\0';\n      if (buf[0] == '#') {\n          /* This is a comment and we may skip it. */\n          if(verbose)\n              D (debug_file, \"Skipping comment line: %s\", buf);\n          continue;\n      }\n      if(verbose)\n\t  D (debug_file, \"Authorization line: %s\", buf);\n      s_user = strtok_r (buf, \":\", &saveptr);\n      if (s_user && strcmp (username, s_user) == 0)\n\t{\n\t  if(verbose)\n\t      D (debug_file, \"Matched user: %s\", s_user);\n      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */\n\t  do\n\t    {\n\t      s_token = strtok_r (NULL, \":\", &saveptr);\n\t      if(verbose)\n\t\t  D (debug_file, \"Authorization token: %s\", s_token);\n\t      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)\n\t\t{\n\t\t  if(verbose)\n\t\t      D (debug_file, \"Match user/token as %s/%s\", username, otp_id);\n\t\t  return AUTH_FOUND;\n\t\t}\n\t    }\n\t  while (s_token != NULL);\n\t}\n    }\n\n  fclose (opwfile);\n\n  return retval;\n}\n\n#if HAVE_CR\n/* Fill buf with len bytes of random data */\nint generate_random(void *buf, int len)\n{\n\tFILE *u;\n\tint res;\n\n\tu = fopen(\"/dev/urandom\", \"r\");\n\tif (!u) {\n\t\treturn -1;\n\t}\n\n\tres = fread(buf, 1, (size_t) len, u);\n\tfclose(u);\n\n\treturn (res != len);\n}\n\nint\ncheck_firmware_version(YK_KEY *yk, bool verbose, bool quiet, FILE *debug_file)\n{\n\tYK_STATUS *st = ykds_alloc();\n\n\tif (!yk_get_status(yk, st)) {\n\t\tfree(st);\n\t\treturn 0;\n\t}\n\n\tif (verbose) {\n\t\tD(debug_file, \"YubiKey Firmware version: %d.%d.%d\\n\",\n\t\t       ykds_version_major(st),\n\t\t       ykds_version_minor(st),\n\t\t       ykds_version_build(st));\n\t}\n\n\tif (ykds_version_major(st) < 2 ||\n\t    (ykds_version_major(st) == 2\n         && ykds_version_minor(st) < 2)) {\n\t\tif (! quiet)\n\t\t\tfprintf(stderr, \"Challenge-response not supported before YubiKey 2.2.\\n\");\n\t\tfree(st);\n\t\treturn 0;\n\t}\n\n\tfree(st);\n\treturn 1;\n}\n\nint\ninit_yubikey(YK_KEY **yk)\n{\n\tif (!yk_init())\n\t\treturn 0;\n\n\tif (!(*yk = yk_open_first_key()))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint challenge_response(YK_KEY *yk, int slot,\n\t\t       char *challenge, unsigned int len,\n\t\t       bool hmac, bool may_block, bool verbose,\n\t\t       char *response, unsigned int res_size, unsigned int *res_len)\n{\n\tint yk_cmd;\n\n  if(hmac == true) {\n    *res_len = 20;\n  } else {\n    *res_len = 16;\n  }\n\tif (res_size < *res_len) {\n\t  return 0;\n  }\n\n\tmemset(response, 0, res_size);\n\n\tif (verbose) {\n\t\tfprintf(stderr, \"Sending %u bytes %s challenge to slot %i\\n\", len, (hmac == true)?\"HMAC\":\"Yubico\", slot);\n\t\t//_yk_hexdump(challenge, len);\n\t}\n\n\tswitch(slot) {\n\tcase 1:\n\t\tyk_cmd = (hmac == true) ? SLOT_CHAL_HMAC1 : SLOT_CHAL_OTP1;\n\t\tbreak;\n\tcase 2:\n\t\tyk_cmd = (hmac == true) ? SLOT_CHAL_HMAC2 : SLOT_CHAL_OTP2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n  if(! yk_challenge_response(yk, yk_cmd, may_block, len,\n        (unsigned char*)challenge, res_size, (unsigned char*)response)) {\n    return 0;\n  }\n\n\n\treturn 1;\n}\n\nint\ncheck_user_challenge_file(const char *chalresp_path, const struct passwd *user, FILE *debug_file)\n{\n  /*\n   * This function will look for users challenge files.\n   *\n   * Returns one of AUTH_FOUND, AUTH_NOT_FOUND, AUTH_ERROR\n   */\n  size_t len;\n  int r;\n  int ret = AUTH_NOT_FOUND;\n  char *userfile = NULL;\n  char *userfile_pattern = NULL;\n  glob_t userfile_glob;\n  const char *filename = NULL;\n\n  if (! chalresp_path) {\n    filename = \"challenge\";\n  } else {\n    filename = user->pw_name;\n  }\n\n  /* check for userfile challenge files */\n  r = get_user_cfgfile_path(chalresp_path, filename, user, &userfile);\n  if (!r) {\n    D (debug_file, \"Failed to get user cfgfile path\");\n    ret = AUTH_ERROR;\n    goto out;\n  }\n\n  if (!access(userfile, F_OK)) {\n    ret = AUTH_FOUND;\n    goto out;\n  }\n\n  /* check for userfile-* challenge files */\n  len = strlen(userfile) + 2 + 1;\n  if ((userfile_pattern = malloc(len)) == NULL) {\n    D (debug_file, \"Failed to allocate memory for userfile pattern: %s\", strerror(errno));\n    ret = AUTH_ERROR;\n    goto out;\n  }\n  snprintf(userfile_pattern, len, \"%s-*\", userfile);\n\n  r = glob(userfile_pattern, 0, NULL, &userfile_glob);\n  globfree(&userfile_glob);\n  switch (r) {\n    case GLOB_NOMATCH:\n      /* No matches found, so continue */\n      break;\n    case 0:\n      ret = AUTH_FOUND;\n      goto out;\n    default:\n      D (debug_file, \"Error while checking for %s challenge files: %s\", userfile_pattern, strerror(errno));\n      ret = AUTH_ERROR;\n      goto out;\n  }\n\nout:\n  free(userfile_pattern);\n  free(userfile);\n  return ret;\n}\n\nint\nget_user_challenge_file(YK_KEY *yk, const char *chalresp_path, const struct passwd *user, char **fn, FILE *debug_file)\n{\n  /* Getting file from user home directory, i.e. ~/.yubico/challenge, or\n   * from a system wide directory.\n   */\n\n  /* The challenge to use is located in a file in the user's home directory,\n   * which therefor can't be encrypted. If an encrypted home directory is used,\n   * the option chalresp_path can be used to point to a system-wide directory.\n   */\n\n  const char *filename = NULL; /* not including directory */\n  char *ptr = NULL;\n  unsigned int serial = 0;\n  int ret;\n\n  if (! yk_get_serial(yk, 0, 0, &serial)) {\n    D (debug_file, \"Failed to read serial number (serial-api-visible disabled?).\");\n    if (! chalresp_path)\n      filename = \"challenge\";\n    else\n      filename = user->pw_name;\n  } else {\n    /* We have serial number */\n    /* 0xffffffff == 4294967295 == 10 digits */\n    size_t len = strlen(chalresp_path == NULL ? \"challenge\" : user->pw_name) + 1 + 10 + 1;\n    if ((ptr = malloc(len)) != NULL) {\n      int res = snprintf(ptr, len, \"%s-%u\", chalresp_path == NULL ? \"challenge\" : user->pw_name, serial);\n      filename = ptr;\n      if (res < 0 || (unsigned long)res > len) {\n\t/* Not enough space, strangely enough. */\n\tfree(ptr);\n\tfilename = NULL;\n      }\n    }\n  }\n\n  if (filename == NULL)\n    return 0;\n\n  ret = get_user_cfgfile_path (chalresp_path, filename, user, fn);\n  if(ptr) {\n    free(ptr);\n  }\n  return ret;\n}\n\nint\nload_chalresp_state(FILE *f, CR_STATE *state, bool verbose, FILE *debug_file)\n{\n  /*\n   * Load the current challenge and expected response information from a file handle.\n   *\n   * Format is hex(challenge):hex(response):slot num\n   */\n  char challenge_hex[CR_CHALLENGE_SIZE * 2 + 1], response_hex[CR_RESPONSE_SIZE * 2 + 1];\n  char salt_hex[CR_SALT_SIZE * 2 + 1];\n  unsigned int iterations;\n  int slot;\n  int r;\n\n  if (! f)\n    goto out;\n\n  /* XXX not ideal with hard coded lengths in this scan string.\n   * 126 corresponds to twice the size of CR_CHALLENGE_SIZE,\n   * 40 is twice the size of CR_RESPONSE_SIZE\n   * (twice because we hex encode the challenge and response)\n   */\n  r = fscanf(f, \"v2:%126[0-9a-z]:%40[0-9a-z]:%64[0-9a-z]:%d:%d\", challenge_hex, response_hex, salt_hex, &iterations, &slot);\n  if(r == 5) {\n    if (! yubikey_hex_p(salt_hex)) {\n      D(debug_file, \"Invalid salt hex input : %s\", salt_hex);\n      goto out;\n    }\n\n    if(verbose) {\n      D(debug_file, \"Challenge: %s, hashed response: %s, salt: %s, iterations: %d, slot: %d\",\n            challenge_hex, response_hex, salt_hex, iterations, slot);\n    }\n\n    yubikey_hex_decode(state->salt, salt_hex, sizeof(state->salt));\n    state->salt_len = strlen(salt_hex) / 2;\n  } else {\n    rewind(f);\n    r = fscanf(f, \"v1:%126[0-9a-z]:%40[0-9a-z]:%d\", challenge_hex, response_hex, &slot);\n    if (r != 3) {\n      D(debug_file, \"Could not parse contents of chalresp_state file (%i)\", r);\n      goto out;\n    }\n\n    if (verbose) {\n      D(debug_file, \"Challenge: %s, expected response: %s, slot: %d\", challenge_hex, response_hex, slot);\n    }\n\n    iterations = CR_DEFAULT_ITERATIONS;\n  }\n\n  state->iterations = iterations;\n\n\n  if (! yubikey_hex_p(challenge_hex)) {\n    D(debug_file, \"Invalid challenge hex input : %s\", challenge_hex);\n    goto out;\n  }\n\n  if (! yubikey_hex_p(response_hex)) {\n    D(debug_file, \"Invalid expected response hex input : %s\", response_hex);\n    goto out;\n  }\n\n  if (slot != 1 && slot != 2) {\n    D(debug_file, \"Invalid slot input : %i\", slot);\n    goto out;\n  }\n\n  yubikey_hex_decode(state->challenge, challenge_hex, sizeof(state->challenge));\n  state->challenge_len = strlen(challenge_hex) / 2;\n\n  yubikey_hex_decode(state->response, response_hex, sizeof(state->response));\n  state->response_len = strlen(response_hex) / 2;\n\n  state->slot = slot;\n\n  return 1;\n\n out:\n  return 0;\n}\n\nint\nwrite_chalresp_state(FILE *f, CR_STATE *state)\n{\n  char challenge_hex[CR_CHALLENGE_SIZE * 2 + 1], response_hex[CR_RESPONSE_SIZE * 2 + 1];\n  char salt_hex[CR_SALT_SIZE * 2 + 1], hashed_hex[CR_RESPONSE_SIZE * 2 + 1];\n  unsigned char salt[CR_SALT_SIZE], hash[CR_RESPONSE_SIZE];\n  YK_PRF_METHOD prf_method = {20, yk_hmac_sha1};\n  unsigned int iterations = CR_DEFAULT_ITERATIONS;\n  int fd;\n\n  memset(challenge_hex, 0, sizeof(challenge_hex));\n  memset(response_hex, 0, sizeof(response_hex));\n  memset(salt_hex, 0, sizeof(salt_hex));\n  memset(hashed_hex, 0, sizeof(hashed_hex));\n\n  yubikey_hex_encode(challenge_hex, (char *)state->challenge, state->challenge_len);\n  yubikey_hex_encode(response_hex, (char *)state->response, state->response_len);\n\n  if(state->iterations > 0) {\n    iterations = state->iterations;\n  }\n\n  generate_random(salt, CR_SALT_SIZE);\n  yk_pbkdf2(response_hex, salt, CR_SALT_SIZE, iterations,\n      hash, CR_RESPONSE_SIZE, &prf_method);\n\n  yubikey_hex_encode(hashed_hex, (char *)hash, CR_RESPONSE_SIZE);\n  yubikey_hex_encode(salt_hex, (char *)salt, CR_SALT_SIZE);\n\n  rewind(f);\n\n  fd = fileno(f);\n  if (fd == -1)\n    goto out;\n\n  if (ftruncate(fd, 0))\n    goto out;\n\n  fprintf(f, \"v2:%s:%s:%s:%u:%d\\n\", challenge_hex, hashed_hex, salt_hex, iterations, state->slot);\n\n  if (fflush(f) < 0)\n    goto out;\n\n  if (fsync(fd) < 0)\n    goto out;\n\n  return 1;\n out:\n  return 0;\n}\n#endif /* HAVE_CR */\n\nsize_t filter_result_len(const char *filter, const char *user, char *output) {\n  const char *part = NULL;\n  size_t result = 0;\n  do\n    {\n      size_t len;\n      part = strstr(filter, \"%u\");\n      if(part)\n        len = part - filter;\n      else\n        len = strlen(filter);\n      if (output)\n        {\n          strncpy(output, filter, len);\n          output += len;\n        }\n      result += len;\n      filter += len + 2;\n      if(part)\n        {\n          if(output)\n            {\n              strncpy(output, user, strlen(user));\n              output += strlen(user);\n            }\n          result += strlen(user);\n        }\n    }\n  while(part);\n\n  if(output)\n    *output = '\\0';\n  return(result + 1);\n}\n\nchar *filter_printf(const char *filter, const char *user) {\n  char *result = malloc(filter_result_len(filter, user, NULL));\n  filter_result_len(filter, user, result);\n  return result;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2011-2014 Yubico AB\n * Copyright (c) 2011 Tollef Fog Heen <tfheen@err.no>\n * All rights reserved.\n *\n * Author : Fredrik Thulin <fredrik@yubico.com>\n * Author : Tollef Fog Heen <tfheen@err.no>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <glob.h>\n#include <unistd.h>\n\n#include \"util.h\"\n\n#if HAVE_CR\n/* for yubikey_hex_decode and yubikey_hex_p */\n#include <yubikey.h>\n#include <ykpbkdf2.h>\n\n#include <ykstatus.h>\n#include <ykdef.h>\n#endif /* HAVE_CR */\n\nint\nget_user_cfgfile_path(const char *common_path, const char *filename, const struct passwd *user, char **fn)\n{\n  /* Getting file from user home directory, e.g. ~/.yubico/challenge, or\n   * from a system wide directory.\n   *\n   * Format is hex(challenge):hex(response):slot num\n   */\n  char *userfile;\n  size_t len;\n\n  if (common_path != NULL) {\n    len = strlen(common_path) + 1 + strlen(filename) + 1;\n    if ((userfile = malloc(len)) == NULL) {\n      return 0;\n    }\n    snprintf(userfile, len, \"%s/%s\", common_path, filename);\n    *fn = userfile;\n    return 1;\n  }\n\n  /* No common path provided. Construct path to user's ~/.yubico/filename */\n\n  len = strlen(user->pw_dir) + 9 + strlen(filename) + 1;\n  if ((userfile = malloc(len)) == NULL) {\n    return 0;\n  }\n  snprintf(userfile, len, \"%s/.yubico/%s\", user->pw_dir, filename);\n  *fn = userfile;\n  return 1;\n}\n\n\n/*\n * This function will look for users name with valid user token id.\n *\n * Returns one of AUTH_FOUND, AUTH_NOT_FOUND, AUTH_NO_TOKENS, AUTH_ERROR.\n *\n * File format is as follows:\n * <user-name>:<token_id>:<token_id>\n * <user-name>:<token_id>\n *\n */\nint\ncheck_user_token (const char *authfile,\n\t\t  const char *username,\n\t\t  const char *otp_id,\n\t\t  int verbose,\n                  FILE *debug_file)\n{\n  char buf[1024];\n  char *s_user, *s_token;\n  int retval = AUTH_ERROR;\n  int fd;\n  struct stat st;\n  FILE *opwfile;\n\n  fd = open(authfile, O_RDONLY, 0);\n  if (fd < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot open file: %s (%s)\", authfile, strerror(errno));\n      return retval;\n  }\n\n  if (fstat(fd, &st) < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot stat file: %s (%s)\", authfile, strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  if (!S_ISREG(st.st_mode)) {\n      if(verbose)\n\t  D (debug_file, \"%s is not a regular file\", authfile);\n      close(fd);\n      return retval;\n  }\n\n  opwfile = fdopen(fd, \"r\");\n  if (opwfile == NULL) {\n      if(verbose)\n\t  D (debug_file, \"fdopen: %s\", strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  retval = AUTH_NO_TOKENS;\n  while (fgets (buf, 1024, opwfile))\n    {\n      char *saveptr = NULL;\n      if (buf[strlen (buf) - 1] == '\\n')\n\tbuf[strlen (buf) - 1] = '\\0';\n      if (buf[0] == '#') {\n          /* This is a comment and we may skip it. */\n          if(verbose)\n              D (debug_file, \"Skipping comment line: %s\", buf);\n          continue;\n      }\n      if(verbose)\n\t  D (debug_file, \"Authorization line: %s\", buf);\n      s_user = strtok_r (buf, \":\", &saveptr);\n      if (s_user && strcmp (username, s_user) == 0)\n\t{\n\t  if(verbose)\n\t      D (debug_file, \"Matched user: %s\", s_user);\n      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */\n\t  do\n\t    {\n\t      s_token = strtok_r (NULL, \":\", &saveptr);\n\t      if(verbose)\n\t\t  D (debug_file, \"Authorization token: %s\", s_token);\n\t      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)\n\t\t{\n\t\t  if(verbose)\n\t\t      D (debug_file, \"Match user/token as %s/%s\", username, otp_id);\n\n\t\t  fclose(opwfile);\n\t\t  return AUTH_FOUND;\n\t\t}\n\t    }\n\t  while (s_token != NULL);\n\t}\n    }\n\n  fclose (opwfile);\n\n  return retval;\n}\n\n#if HAVE_CR\n/* Fill buf with len bytes of random data */\nint generate_random(void *buf, int len)\n{\n\tFILE *u;\n\tint res;\n\n\tu = fopen(\"/dev/urandom\", \"r\");\n\tif (!u) {\n\t\treturn -1;\n\t}\n\n\tres = fread(buf, 1, (size_t) len, u);\n\tfclose(u);\n\n\treturn (res != len);\n}\n\nint\ncheck_firmware_version(YK_KEY *yk, bool verbose, bool quiet, FILE *debug_file)\n{\n\tYK_STATUS *st = ykds_alloc();\n\n\tif (!yk_get_status(yk, st)) {\n\t\tfree(st);\n\t\treturn 0;\n\t}\n\n\tif (verbose) {\n\t\tD(debug_file, \"YubiKey Firmware version: %d.%d.%d\\n\",\n\t\t       ykds_version_major(st),\n\t\t       ykds_version_minor(st),\n\t\t       ykds_version_build(st));\n\t}\n\n\tif (ykds_version_major(st) < 2 ||\n\t    (ykds_version_major(st) == 2\n         && ykds_version_minor(st) < 2)) {\n\t\tif (! quiet)\n\t\t\tfprintf(stderr, \"Challenge-response not supported before YubiKey 2.2.\\n\");\n\t\tfree(st);\n\t\treturn 0;\n\t}\n\n\tfree(st);\n\treturn 1;\n}\n\nint\ninit_yubikey(YK_KEY **yk)\n{\n\tif (!yk_init())\n\t\treturn 0;\n\n\tif (!(*yk = yk_open_first_key()))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint challenge_response(YK_KEY *yk, int slot,\n\t\t       char *challenge, unsigned int len,\n\t\t       bool hmac, bool may_block, bool verbose,\n\t\t       char *response, unsigned int res_size, unsigned int *res_len)\n{\n\tint yk_cmd;\n\n  if(hmac == true) {\n    *res_len = 20;\n  } else {\n    *res_len = 16;\n  }\n\tif (res_size < *res_len) {\n\t  return 0;\n  }\n\n\tmemset(response, 0, res_size);\n\n\tif (verbose) {\n\t\tfprintf(stderr, \"Sending %u bytes %s challenge to slot %i\\n\", len, (hmac == true)?\"HMAC\":\"Yubico\", slot);\n\t\t//_yk_hexdump(challenge, len);\n\t}\n\n\tswitch(slot) {\n\tcase 1:\n\t\tyk_cmd = (hmac == true) ? SLOT_CHAL_HMAC1 : SLOT_CHAL_OTP1;\n\t\tbreak;\n\tcase 2:\n\t\tyk_cmd = (hmac == true) ? SLOT_CHAL_HMAC2 : SLOT_CHAL_OTP2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n  if(! yk_challenge_response(yk, yk_cmd, may_block, len,\n        (unsigned char*)challenge, res_size, (unsigned char*)response)) {\n    return 0;\n  }\n\n\n\treturn 1;\n}\n\nint\ncheck_user_challenge_file(const char *chalresp_path, const struct passwd *user, FILE *debug_file)\n{\n  /*\n   * This function will look for users challenge files.\n   *\n   * Returns one of AUTH_FOUND, AUTH_NOT_FOUND, AUTH_ERROR\n   */\n  size_t len;\n  int r;\n  int ret = AUTH_NOT_FOUND;\n  char *userfile = NULL;\n  char *userfile_pattern = NULL;\n  glob_t userfile_glob;\n  const char *filename = NULL;\n\n  if (! chalresp_path) {\n    filename = \"challenge\";\n  } else {\n    filename = user->pw_name;\n  }\n\n  /* check for userfile challenge files */\n  r = get_user_cfgfile_path(chalresp_path, filename, user, &userfile);\n  if (!r) {\n    D (debug_file, \"Failed to get user cfgfile path\");\n    ret = AUTH_ERROR;\n    goto out;\n  }\n\n  if (!access(userfile, F_OK)) {\n    ret = AUTH_FOUND;\n    goto out;\n  }\n\n  /* check for userfile-* challenge files */\n  len = strlen(userfile) + 2 + 1;\n  if ((userfile_pattern = malloc(len)) == NULL) {\n    D (debug_file, \"Failed to allocate memory for userfile pattern: %s\", strerror(errno));\n    ret = AUTH_ERROR;\n    goto out;\n  }\n  snprintf(userfile_pattern, len, \"%s-*\", userfile);\n\n  r = glob(userfile_pattern, 0, NULL, &userfile_glob);\n  globfree(&userfile_glob);\n  switch (r) {\n    case GLOB_NOMATCH:\n      /* No matches found, so continue */\n      break;\n    case 0:\n      ret = AUTH_FOUND;\n      goto out;\n    default:\n      D (debug_file, \"Error while checking for %s challenge files: %s\", userfile_pattern, strerror(errno));\n      ret = AUTH_ERROR;\n      goto out;\n  }\n\nout:\n  free(userfile_pattern);\n  free(userfile);\n  return ret;\n}\n\nint\nget_user_challenge_file(YK_KEY *yk, const char *chalresp_path, const struct passwd *user, char **fn, FILE *debug_file)\n{\n  /* Getting file from user home directory, i.e. ~/.yubico/challenge, or\n   * from a system wide directory.\n   */\n\n  /* The challenge to use is located in a file in the user's home directory,\n   * which therefor can't be encrypted. If an encrypted home directory is used,\n   * the option chalresp_path can be used to point to a system-wide directory.\n   */\n\n  const char *filename = NULL; /* not including directory */\n  char *ptr = NULL;\n  unsigned int serial = 0;\n  int ret;\n\n  if (! yk_get_serial(yk, 0, 0, &serial)) {\n    D (debug_file, \"Failed to read serial number (serial-api-visible disabled?).\");\n    if (! chalresp_path)\n      filename = \"challenge\";\n    else\n      filename = user->pw_name;\n  } else {\n    /* We have serial number */\n    /* 0xffffffff == 4294967295 == 10 digits */\n    size_t len = strlen(chalresp_path == NULL ? \"challenge\" : user->pw_name) + 1 + 10 + 1;\n    if ((ptr = malloc(len)) != NULL) {\n      int res = snprintf(ptr, len, \"%s-%u\", chalresp_path == NULL ? \"challenge\" : user->pw_name, serial);\n      filename = ptr;\n      if (res < 0 || (unsigned long)res > len) {\n\t/* Not enough space, strangely enough. */\n\tfree(ptr);\n\tfilename = NULL;\n      }\n    }\n  }\n\n  if (filename == NULL)\n    return 0;\n\n  ret = get_user_cfgfile_path (chalresp_path, filename, user, fn);\n  if(ptr) {\n    free(ptr);\n  }\n  return ret;\n}\n\nint\nload_chalresp_state(FILE *f, CR_STATE *state, bool verbose, FILE *debug_file)\n{\n  /*\n   * Load the current challenge and expected response information from a file handle.\n   *\n   * Format is hex(challenge):hex(response):slot num\n   */\n  char challenge_hex[CR_CHALLENGE_SIZE * 2 + 1], response_hex[CR_RESPONSE_SIZE * 2 + 1];\n  char salt_hex[CR_SALT_SIZE * 2 + 1];\n  unsigned int iterations;\n  int slot;\n  int r;\n\n  if (! f)\n    goto out;\n\n  /* XXX not ideal with hard coded lengths in this scan string.\n   * 126 corresponds to twice the size of CR_CHALLENGE_SIZE,\n   * 40 is twice the size of CR_RESPONSE_SIZE\n   * (twice because we hex encode the challenge and response)\n   */\n  r = fscanf(f, \"v2:%126[0-9a-z]:%40[0-9a-z]:%64[0-9a-z]:%d:%d\", challenge_hex, response_hex, salt_hex, &iterations, &slot);\n  if(r == 5) {\n    if (! yubikey_hex_p(salt_hex)) {\n      D(debug_file, \"Invalid salt hex input : %s\", salt_hex);\n      goto out;\n    }\n\n    if(verbose) {\n      D(debug_file, \"Challenge: %s, hashed response: %s, salt: %s, iterations: %d, slot: %d\",\n            challenge_hex, response_hex, salt_hex, iterations, slot);\n    }\n\n    yubikey_hex_decode(state->salt, salt_hex, sizeof(state->salt));\n    state->salt_len = strlen(salt_hex) / 2;\n  } else {\n    rewind(f);\n    r = fscanf(f, \"v1:%126[0-9a-z]:%40[0-9a-z]:%d\", challenge_hex, response_hex, &slot);\n    if (r != 3) {\n      D(debug_file, \"Could not parse contents of chalresp_state file (%i)\", r);\n      goto out;\n    }\n\n    if (verbose) {\n      D(debug_file, \"Challenge: %s, expected response: %s, slot: %d\", challenge_hex, response_hex, slot);\n    }\n\n    iterations = CR_DEFAULT_ITERATIONS;\n  }\n\n  state->iterations = iterations;\n\n\n  if (! yubikey_hex_p(challenge_hex)) {\n    D(debug_file, \"Invalid challenge hex input : %s\", challenge_hex);\n    goto out;\n  }\n\n  if (! yubikey_hex_p(response_hex)) {\n    D(debug_file, \"Invalid expected response hex input : %s\", response_hex);\n    goto out;\n  }\n\n  if (slot != 1 && slot != 2) {\n    D(debug_file, \"Invalid slot input : %i\", slot);\n    goto out;\n  }\n\n  yubikey_hex_decode(state->challenge, challenge_hex, sizeof(state->challenge));\n  state->challenge_len = strlen(challenge_hex) / 2;\n\n  yubikey_hex_decode(state->response, response_hex, sizeof(state->response));\n  state->response_len = strlen(response_hex) / 2;\n\n  state->slot = slot;\n\n  return 1;\n\n out:\n  return 0;\n}\n\nint\nwrite_chalresp_state(FILE *f, CR_STATE *state)\n{\n  char challenge_hex[CR_CHALLENGE_SIZE * 2 + 1], response_hex[CR_RESPONSE_SIZE * 2 + 1];\n  char salt_hex[CR_SALT_SIZE * 2 + 1], hashed_hex[CR_RESPONSE_SIZE * 2 + 1];\n  unsigned char salt[CR_SALT_SIZE], hash[CR_RESPONSE_SIZE];\n  YK_PRF_METHOD prf_method = {20, yk_hmac_sha1};\n  unsigned int iterations = CR_DEFAULT_ITERATIONS;\n  int fd;\n\n  memset(challenge_hex, 0, sizeof(challenge_hex));\n  memset(response_hex, 0, sizeof(response_hex));\n  memset(salt_hex, 0, sizeof(salt_hex));\n  memset(hashed_hex, 0, sizeof(hashed_hex));\n\n  yubikey_hex_encode(challenge_hex, (char *)state->challenge, state->challenge_len);\n  yubikey_hex_encode(response_hex, (char *)state->response, state->response_len);\n\n  if(state->iterations > 0) {\n    iterations = state->iterations;\n  }\n\n  generate_random(salt, CR_SALT_SIZE);\n  yk_pbkdf2(response_hex, salt, CR_SALT_SIZE, iterations,\n      hash, CR_RESPONSE_SIZE, &prf_method);\n\n  yubikey_hex_encode(hashed_hex, (char *)hash, CR_RESPONSE_SIZE);\n  yubikey_hex_encode(salt_hex, (char *)salt, CR_SALT_SIZE);\n\n  rewind(f);\n\n  fd = fileno(f);\n  if (fd == -1)\n    goto out;\n\n  if (ftruncate(fd, 0))\n    goto out;\n\n  fprintf(f, \"v2:%s:%s:%s:%u:%d\\n\", challenge_hex, hashed_hex, salt_hex, iterations, state->slot);\n\n  if (fflush(f) < 0)\n    goto out;\n\n  if (fsync(fd) < 0)\n    goto out;\n\n  return 1;\n out:\n  return 0;\n}\n#endif /* HAVE_CR */\n\nsize_t filter_result_len(const char *filter, const char *user, char *output) {\n  const char *part = NULL;\n  size_t result = 0;\n  do\n    {\n      size_t len;\n      part = strstr(filter, \"%u\");\n      if(part)\n        len = part - filter;\n      else\n        len = strlen(filter);\n      if (output)\n        {\n          strncpy(output, filter, len);\n          output += len;\n        }\n      result += len;\n      filter += len + 2;\n      if(part)\n        {\n          if(output)\n            {\n              strncpy(output, user, strlen(user));\n              output += strlen(user);\n            }\n          result += strlen(user);\n        }\n    }\n  while(part);\n\n  if(output)\n    *output = '\\0';\n  return(result + 1);\n}\n\nchar *filter_printf(const char *filter, const char *user) {\n  char *result = malloc(filter_result_len(filter, user, NULL));\n  filter_result_len(filter, user, result);\n  return result;\n}\n"], "filenames": ["util.c"], "buggy_code_start_loc": [169], "buggy_code_end_loc": [169], "fixing_code_start_loc": [170], "fixing_code_end_loc": [172], "type": "CWE-200", "message": "In check_user_token in util.c in the Yubico PAM module (aka pam_yubico) 2.18 through 2.25, successful logins can leak file descriptors to the auth mapping file, which can lead to information disclosure (serial number of a device) and/or DoS (reaching the maximum number of file descriptors).", "other": {"cve": {"id": "CVE-2018-9275", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-04T18:29:02.497", "lastModified": "2018-05-21T15:33:02.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In check_user_token in util.c in the Yubico PAM module (aka pam_yubico) 2.18 through 2.25, successful logins can leak file descriptors to the auth mapping file, which can lead to information disclosure (serial number of a device) and/or DoS (reaching the maximum number of file descriptors)."}, {"lang": "es", "value": "En check_user_token en util.c en el m\u00f3dulo Yubico PAM (tambi\u00e9n conocido como pam_yubico), de la versi\u00f3n 2.18 hasta la 2.25, los inicios de sesi\u00f3n exitosos pueden filtrar descriptores de archivo al archivo de mapeo auth. Esto puede conducir a una divulgaci\u00f3n de informaci\u00f3n (n\u00famero de serie de un dispositivo) y/o una denegaci\u00f3n de servicio (alcance del n\u00famero m\u00e1ximo de descriptores de archivo)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yubico:yubico_pam:*:*:*:*:*:yubico:*:*", "versionStartIncluding": "2.18", "versionEndIncluding": "2.25", "matchCriteriaId": "2D66C6C0-64A8-44DF-A65E-1F17F4C98839"}]}]}], "references": [{"url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1088027", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/Yubico/yubico-pam/commit/0f6ceabab0a8849b47f67d727aa526c2656089ba", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/Yubico/yubico-pam/issues/136", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Yubico/yubico-pam/commit/0f6ceabab0a8849b47f67d727aa526c2656089ba"}}