{"buggy_code": ["<%#\n Copyright 2013-2022 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= entityAbsolutePackage %>.repository;\n\nimport java.util.function.BiFunction;\n<%_ if (fieldsContainBigDecimal) { _%>\nimport java.math.BigDecimal;\n<%_} if (fieldsContainInstant) { _%>\nimport java.time.Instant;\n<%_ } if (fieldsContainLocalDate) { _%>\nimport java.time.LocalDate;\n<%_ } if (fieldsContainZonedDateTime) { _%>\nimport java.time.ZonedDateTime;\n<%_ } if (fieldsContainDuration) { _%>\nimport java.time.Duration;\n<%_ } if (fieldsContainUUID) { _%>\nimport java.util.UUID;\n<%_ } _%>\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport org.springframework.data.domain.Pageable;\nimport io.r2dbc.spi.Row;\nimport io.r2dbc.spi.RowMetadata;\nimport static org.springframework.data.relational.core.query.Criteria.where;\n<%_ if (containsBagRelationships) { _%>\nimport static org.springframework.data.relational.core.query.Query.query;\n<%_ } _%>\nimport org.springframework.data.r2dbc.convert.R2dbcConverter;\nimport org.springframework.data.r2dbc.core.R2dbcEntityOperations;\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\nimport org.springframework.data.r2dbc.repository.support.SimpleR2dbcRepository;\nimport org.springframework.data.relational.core.query.Criteria;\nimport org.springframework.data.relational.core.sql.Column;\nimport org.springframework.data.relational.core.sql.Expression;\nimport org.springframework.data.relational.core.sql.Select;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectFromAndJoin<% if (reactiveEagerRelations.length > 0) { %>Condition<% } %>;\nimport org.springframework.data.relational.core.sql.Table;\nimport org.springframework.data.relational.repository.support.MappingRelationalEntityInformation;\nimport org.springframework.r2dbc.core.DatabaseClient;\nimport org.springframework.r2dbc.core.RowsFetchSpec;\n\nimport <%= entityAbsolutePackage %>.domain.<%= persistClass %>;\n<% relationships.forEach(function(rel) {\n  if (rel.relationshipManyToMany && rel.ownerSide) { _%>\nimport <%= rel.otherEntity.entityAbsolutePackage %>.domain.<%= rel.otherEntity.persistClass %>;\n  <%_ } _%>\n<%_ }); _%>\n<%_ Object.keys(uniqueEnums).forEach(function(element) { _%>\n\nimport <%= entityAbsolutePackage %>.domain.enumeration.<%= element %>;\n<%_ }); _%>\n\n<%_ [...reactiveOtherEntities, entity].forEach(otherEntity => { _%>\nimport <%= otherEntity.entityAbsolutePackage %>.repository.rowmapper.<%= otherEntity.entityClass %>RowMapper;\n  <%_ if (otherEntity.entityPackage !== entityPackage) { _%>\nimport <%= otherEntity.entityAbsolutePackage %>.repository.<%= otherEntity.entityClass %>SqlHelper;\n  <%_ } _%>\n<%_ }); _%>\n<%_ if (packageName !== entityAbsolutePackage) { _%>\nimport <%= packageName %>.repository.EntityManager;\n<%_ } _%>\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\n/**\n * Spring Data <%= officialDatabaseType %> reactive custom repository implementation for the <%= persistClass %> entity.\n */\n@SuppressWarnings(\"unused\")\nclass <%= entityClass %>RepositoryInternalImpl extends SimpleR2dbcRepository<<%= persistClass %>, <%= primaryKey.type %>> implements <%= entityClass %>RepositoryInternal {\n    private final DatabaseClient db;\n    private final R2dbcEntityTemplate r2dbcEntityTemplate;\n    private final EntityManager entityManager;\n\n<%_ reactiveUniqueEntityTypes.forEach(function(element) { _%>\n    private final <%= element %>RowMapper <%= element.toLowerCase() %>Mapper;\n<%_ }); _%>\n\n    private final static Table entityTable = Table.aliased(\"<%= entityTableName %>\", EntityManager.ENTITY_ALIAS);\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n    private final static Table <%= rel.relationshipName %>Table = Table.aliased(\"<%= rel.otherEntityTableName %>\", \"<%= _generateSqlSafeName(rel.relationshipName) %>\");\n<%_ }); _%>\n\n<%_ relationships.forEach(function(rel) {\n  if (rel.shouldWriteJoinTable) {\n_%>\n    private final static EntityManager.LinkTable <%= rel.relationshipName %>Link = new EntityManager.LinkTable(\"<%= rel.joinTable.name %>\", \"<%= entity.entityTableName %>_<%= getColumnName(entity.primaryKey.name) %>\", \"<%= rel.joinColumnNames[0] %>\");\n<%_ }\n}); _%>\n\n    public <%= entityClass %>RepositoryInternalImpl(R2dbcEntityTemplate template, EntityManager entityManager<%_\n            reactiveUniqueEntityTypes.forEach(function(element) { _%>, <%= element %>RowMapper <%= element.toLowerCase() %>Mapper<%_ }); _%>, R2dbcEntityOperations entityOperations,\n        R2dbcConverter converter) {\n        super(new MappingRelationalEntityInformation(converter.getMappingContext().getRequiredPersistentEntity(<%= persistClass %>.class)), entityOperations, converter);\n        this.db = template.getDatabaseClient();\n        this.r2dbcEntityTemplate = template;\n        this.entityManager = entityManager;\n<%_ reactiveUniqueEntityTypes.forEach(function(element) { _%>\n        this.<%= element.toLowerCase() %>Mapper = <%= element.toLowerCase() %>Mapper;\n<%_ }); _%>\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllBy(Pageable pageable) {\n        return findAllBy(pageable, null);\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllBy(Pageable pageable, Criteria criteria) {\n        return createQuery(pageable, criteria).all();\n    }\n\n    RowsFetchSpec<<%= persistClass %>> createQuery(Pageable pageable, Criteria criteria) {\n        List<Expression> columns = <%= entityClass %>SqlHelper.getColumns(entityTable, EntityManager.ENTITY_ALIAS);\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n        columns.addAll(<%= rel.otherEntityNameCapitalized %>SqlHelper.getColumns(<%= rel.relationshipName %>Table, \"<%= rel.relationshipName %>\"));\n<%_ }); _%>\n        SelectFromAndJoin<% if (reactiveEagerRelations.length > 0) { %>Condition<% } %> selectFrom = Select.builder().select(columns).from(entityTable)\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n            .leftOuterJoin(<%= rel.relationshipName %>Table).on(Column.create(\"<%= rel.joinColumnNames[0] %>\", entityTable)).equals(Column.create(\"<%= rel.otherEntity.primaryKey.fields[0].columnName %>\", <%= rel.relationshipName %>Table ))\n<%_ }); _%>;\n\n        String select = entityManager.createSelect(selectFrom, <%= persistClass %>.class, pageable, criteria);\n        return db.sql(select).map(this::process);\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAll() {\n        return findAllBy(null, null);\n    }\n\n    @Override\n    public Mono<<%= persistClass %>> findById(<%= primaryKey.type %> id) {\n        return createQuery(null, where(EntityManager.ENTITY_ALIAS + \".<%= primaryKey.fields[0].columnName %>\").is(id)).one();\n    }\n\n<%_ if (implementsEagerLoadApis) { _%>\n\n    @Override\n    public Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id) {\n        return findById(id);\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllWithEagerRelationships() {\n        return findAll();\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable page) {\n        return findAllBy(page);\n    }\n\n<%_ } _%>\n    private <%= persistClass %> process(Row row, RowMetadata metadata) {\n        <%= persistClass %> entity = <%= entityClass.toLowerCase() %>Mapper.apply(row, \"e\");\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n        entity.set<%= rel.relationshipNameCapitalized %>(<%= rel.otherEntityNameCapitalized.toLowerCase() %>Mapper.apply(row, \"<%= rel.relationshipName %>\"));\n<%_ }); _%>\n        return entity;\n    }\n\n    @Override\n    public <S extends <%= persistClass %>> Mono<S> save(S entity) {\n<%_ if (isUsingMapsId) { _%>\n        if (entity.get<%= primaryKey.nameCapitalized %>() == null && entity.get<%= mapsIdAssoc.relationshipNameCapitalized %>() != null) {\n            entity.set<%= primaryKey.nameCapitalized %>(entity.get<%= mapsIdAssoc.relationshipNameCapitalized %>().get<%= mapsIdAssoc.otherEntity.primaryKey.nameCapitalized %>());\n            return entityManager.insert(entity);\n        }\n<%_ } _%>\n        return super.save(entity)<% if (containsBagRelationships) { %>.flatMap((S e) -> updateRelations(e))<% } %>;\n    }\n\n<%_ if (containsBagRelationships) { _%>\n    protected <S extends <%= persistClass %>> Mono<S> updateRelations(S entity) {\n  <%_ relationships.filter(function(rel) {\n    return (rel.relationshipManyToMany && rel.ownerSide);\n   }).forEach(function(rel, idx) { _%>\n    <%_ if (idx === 0) { _%>\n        Mono<Void> result = entityManager.updateLinkTable(<%= rel.relationshipName %>Link, entity.get<%= primaryKey.nameCapitalized %>(), entity.get<%= rel.relationshipNameCapitalizedPlural %>().stream().map(<%= asEntity(rel.otherEntityNameCapitalized) %>::get<%= rel.otherEntity.primaryKey.nameCapitalized %>)).then();\n    <%_ } else { _%>\n        result = result.and(entityManager.updateLinkTable(<%= rel.relationshipName %>Link, entity.get<%= primaryKey.nameCapitalized %>(), entity.get<%= rel.relationshipNameCapitalizedPlural %>().stream().map(<%= asEntity(rel.otherEntityNameCapitalized) %>::get<%= rel.otherEntity.primaryKey.nameCapitalized %>)));\n    <%_ } _%>\n  <%_ }); _%>\n        return result.thenReturn(entity);\n    }\n\n    @Override\n    public Mono<Void> deleteById(<%= primaryKey.type %> entityId) {\n        return deleteRelations(entityId)\n            .then(super.deleteById(entityId));\n    }\n\n    protected Mono<Void> deleteRelations(<%= primaryKey.type %> entityId) {\n  <%_ relationships.filter(function(rel) {\n      return (rel.relationshipManyToMany && rel.ownerSide);\n    }).forEach(function(rel, idx) { _%>\n    <%_ if (idx === 0) { _%>\n        return entityManager.deleteFromLinkTable(<%= rel.relationshipName %>Link, entityId)\n    <%_} else { _%>\n            .and(entityManager.deleteFromLinkTable(<%= rel.relationshipName %>Link, entityId))\n    <%_ } _%>\n  <%_ }); %>;\n        }\n<%_ } _%>\n}\n", "<%#\n Copyright 2013-2022 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= entityAbsolutePackage %>.repository;\n\nimport <%= entityAbsolutePackage %>.domain.<%= persistClass %>;\n<%_ if (databaseTypeCassandra) { _%>\nimport org.springframework.data.cassandra.repository.ReactiveCassandraRepository;\n<%_ } _%>\n<%_ if (databaseTypeNeo4j) { _%>\nimport org.springframework.data.neo4j.repository.ReactiveNeo4jRepository;\nimport org.springframework.data.neo4j.repository.query.Query;\n<%_ } _%>\n<%_ if (!paginationNo || implementsEagerLoadApis || databaseTypeSql) { _%>\nimport org.springframework.data.domain.Pageable;\n<%_ } _%>\n<%_ if (databaseTypeSql) { _%>\nimport org.springframework.data.r2dbc.repository.Query;\nimport org.springframework.data.repository.reactive.ReactiveCrudRepository;\nimport org.springframework.data.relational.core.query.Criteria;\n<%_ } _%>\n<%_ if (databaseTypeMongodb) { _%>\n  <%_ if (implementsEagerLoadApis) { _%>\nimport org.springframework.data.mongodb.repository.Query;\n  <%_ } _%>\nimport org.springframework.data.mongodb.repository.ReactiveMongoRepository;\n<%_ } _%>\nimport org.springframework.stereotype.Repository;\n<%_ if (databaseTypeSql || !paginationNo || implementsEagerLoadApis) { _%>\nimport reactor.core.publisher.Flux;\n<%_ } _%>\n<%_ if (implementsEagerLoadApis || databaseTypeSql) { _%>\nimport reactor.core.publisher.Mono;\n<%_ } _%>\n<%_ if (primaryKey.typeUUID) { _%>\n\nimport java.util.UUID;\n<%_ } _%>\n\n/**\n * Spring Data <%= officialDatabaseType %> reactive repository for the <%= persistClass %> entity.\n */\n@SuppressWarnings(\"unused\")\n@Repository\npublic interface <%= entityClass %>Repository extends <% if (databaseTypeSql) { %>ReactiveCrud<% } if (databaseTypeMongodb) { %>ReactiveMongo<% } if (databaseTypeNeo4j) { %>ReactiveNeo4j<% } if (databaseTypeCassandra) { %>ReactiveCassandra<% } %>Repository<<%= persistClass %>, <%= primaryKey.type %>><% if (databaseTypeSql) { %>, <%= entityClass %>RepositoryInternal<% } %> {\n\n<%_ if (!paginationNo) { _%>\n    Flux<<%= persistClass %>> findAllBy(Pageable pageable);\n<%_ } _%>\n<%_ if (implementsEagerLoadApis) { _%>\n  <%_ if (databaseTypeMongodb) { _%>\n\n    @Query(\"<%= (databaseTypeMongodb) ? '{}' : '#{#n1ql.selectEntity} WHERE #{#n1ql.filter}' %>\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable pageable);\n\n    @Query(\"<%= (databaseTypeMongodb) ? '{}' : '#{#n1ql.selectEntity} WHERE #{#n1ql.filter}' %>\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    @Query(\"<%- (databaseTypeMongodb) ? \"{'id': ?0}\" : \"#{#n1ql.selectEntity} USE KEYS $1 WHERE #{#n1ql.filter}\" %>\")\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n  <%_ } _%>\n  <%_ if (databaseTypeNeo4j) { _%>\n    @Query(\"MATCH (n:<%= persistClass %>)<-[]-(m) RETURN n,m\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable pageable);\n\n    @Query(\"MATCH (n:<%= persistClass %>)<-[]-(m) RETURN n,m\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    @Query(\"MATCH (e:<%= persistClass %> {id: $id}) RETURN e\")\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n  <%_ } _%>\n<%_ } _%>\n<%_ if (databaseTypeSql) { _%>\n  <%_ if (implementsEagerLoadApis) { _%>\n\n    @Override\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n\n    @Override\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    @Override\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable page);\n\n  <%_ } _%>\n\n  <%_ for (const relationship of relationships) {\n    let relationshipName = relationship.relationshipName;\n    let ownerSide = relationship.ownerSide; _%>\n    <%_ if (relationship.relationshipManyToOne || (relationship.relationshipOneToOne && ownerSide)) { _%>\n\n    @Query(\"SELECT * FROM <%= entityTableName %> entity WHERE entity.<%= relationship.joinColumnNames[0] %> = :id\")\n    Flux<<%= persistClass %>> findBy<%= relationship.relationshipNameCapitalized %>(<%= primaryKey.type %> id);\n\n    @Query(\"SELECT * FROM <%= entityTableName %> entity WHERE entity.<%= relationship.joinColumnNames[0] %> IS NULL\")\n    Flux<<%= persistClass %>> findAllWhere<%= relationship.relationshipNameCapitalized %>IsNull();\n    <%_ } else if (relationship.shouldWriteJoinTable) { _%>\n\n    @Query(\"SELECT entity.* FROM <%= entityTableName %> entity JOIN <%= relationship.joinTable.name %> joinTable ON entity.<%= primaryKey.fields[0].columnName %> = joinTable.<%= relationship.joinColumnNames[0] %> WHERE joinTable.<%= relationship.joinColumnNames[0] %> = :id\")\n    Flux<<%= persistClass %>> findBy<%= relationship.relationshipNameCapitalized %>(<%= primaryKey.type %> id);\n    <%_ } else if (relationship.relationshipOneToOne && !ownerSide) {\n        let otherEntityRelationshipName = relationship.otherEntityRelationshipName;\n        let otherEntityTableName = relationship.otherEntityTableName;\n      _%>\n\n    @Query(\"SELECT * FROM <%= entityTableName %> entity WHERE entity.<%= primaryKey.fields[0].columnName  %> not in (select <%= relationship.joinColumnNames[0]%> from <%= otherEntityTableName %>)\")\n    Flux<<%= persistClass %>> findAllWhere<%= relationship.relationshipNameCapitalized %>IsNull();\n    <%_ } _%>\n  <%_ } _%>\n\n    @Override\n    <S extends <%= persistClass %>> Mono<S> save(S entity);\n\n    @Override\n    Flux<<%= persistClass %>> findAll();\n\n    @Override\n    Mono<<%= persistClass %>> findById(<%= primaryKey.type %> id);\n\n    @Override\n    Mono<Void> deleteById(<%= primaryKey.type %> id);\n}\n\ninterface <%= entityClass %>RepositoryInternal {\n    <S extends <%= persistClass %>> Mono<S> save(S entity);\n\n    Flux<<%= persistClass %>> findAllBy(Pageable pageable);\n\n    Flux<<%= persistClass %>> findAll();\n\n    Mono<<%= persistClass %>> findById(<%= primaryKey.type %> id);\n\n    Flux<<%= persistClass %>> findAllBy(Pageable pageable, Criteria criteria);\n\n  <%_ if (implementsEagerLoadApis) { _%>\n\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable page);\n\n    Mono<Void> deleteById(<%= primaryKey.type %> id);\n  <%_ } _%>\n<%_ } _%>\n}\n", "<%#\n Copyright 2013-2022 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= packageName %>.repository;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.stream.Stream;\n\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.r2dbc.convert.R2dbcConverter;\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\nimport org.springframework.data.r2dbc.core.StatementMapper;\nimport org.springframework.data.r2dbc.mapping.OutboundRow;\nimport org.springframework.data.r2dbc.query.UpdateMapper;\nimport org.springframework.data.relational.core.query.Criteria;\nimport org.springframework.data.relational.core.mapping.RelationalPersistentEntity;\nimport org.springframework.data.relational.core.sql.Conditions;\nimport org.springframework.data.relational.core.sql.OrderByField;\nimport org.springframework.data.relational.core.sql.Select;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectFromAndJoin;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectFromAndJoinCondition;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectOrdered;\nimport org.springframework.data.relational.core.sql.SqlIdentifier;\nimport org.springframework.data.relational.core.sql.Table;\nimport org.springframework.data.relational.core.sql.render.SqlRenderer;\nimport org.springframework.r2dbc.core.Parameter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.Assert;\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\n/**\n * Helper class to create SQL selects based on the entity, paging parameters and criteria.\n *\n */\n@Component\npublic class EntityManager {\n    public final static String ENTITY_ALIAS = \"e\";\n    public final static String ALIAS_PREFIX = \"e_\";\n\n    public static class LinkTable {\n        final String tableName;\n        final String idColumn;\n        final String referenceColumn;\n\n        public LinkTable(String tableName, String idColumn, String referenceColumn) {\n            Assert.notNull(tableName, \"tableName is null\");\n            Assert.notNull(idColumn, \"idColumn is null\");\n            Assert.notNull(referenceColumn, \"referenceColumn is null\");\n            this.tableName = tableName;\n            this.idColumn = idColumn;\n            this.referenceColumn = referenceColumn;\n        }\n    }\n\n    private final SqlRenderer sqlRenderer;\n    private final UpdateMapper updateMapper;\n    private final R2dbcEntityTemplate r2dbcEntityTemplate;\n    private final StatementMapper statementMapper;\n\n    public EntityManager(SqlRenderer sqlRenderer, UpdateMapper updateMapper, R2dbcEntityTemplate r2dbcEntityTemplate) {\n        this.sqlRenderer = sqlRenderer;\n        this.updateMapper = updateMapper;\n        this.r2dbcEntityTemplate = r2dbcEntityTemplate;\n        this.statementMapper = r2dbcEntityTemplate.getDataAccessStrategy().getStatementMapper();\n    }\n\n    /**\n     * Creates an SQL select statement from the given fragment and pagination parameters.\n     * @param selectFrom a representation of a select statement.\n     * @param entityType the entity type which holds the table name.\n     * @param pageable page parameter, or null, if everything needs to be returned\n     * @return sql select statement\n     */\n    public String createSelect(SelectFromAndJoin selectFrom, Class<?> entityType, Pageable pageable, Criteria criteria) {\n        if (pageable != null) {\n            if (criteria != null) {\n                return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()).where(Conditions.just(criteria.toString())), entityType, pageable.getSort());\n            } else {\n                return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()), entityType, pageable.getSort());\n            }\n        } else {\n            if (criteria != null) {\n                return createSelectImpl(selectFrom.where(Conditions.just(criteria.toString())), entityType, null);\n            } else {\n                return createSelectImpl(selectFrom, entityType, null);\n            }\n        }\n    }\n\n    /**\n     * Creates an SQL select statement from the given fragment and pagination parameters.\n     * @param selectFrom a representation of a select statement.\n     * @param entityType the entity type which holds the table name.\n     * @param pageable page parameter, or null, if everything needs to be returned\n     * @return sql select statement\n     */\n    public String createSelect(SelectFromAndJoinCondition selectFrom, Class<?> entityType, Pageable pageable, Criteria criteria) {\n        if (pageable != null) {\n            if (criteria != null) {\n                return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()).where(Conditions.just(criteria.toString())), entityType, pageable.getSort());\n            } else {\n                return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()), entityType, pageable.getSort());\n            }\n        } else {\n            if (criteria != null) {\n                return createSelectImpl(selectFrom.where(Conditions.just(criteria.toString())), entityType, null);\n            } else {\n                return createSelectImpl(selectFrom, entityType, null);\n            }\n        }\n    }\n\n    private String createSelectImpl(SelectOrdered selectFrom, Class<?> entityType, Sort sortParameter) {\n        if (sortParameter != null && sortParameter.isSorted()) {\n            RelationalPersistentEntity<?> entity = getPersistentEntity(entityType);\n            if (entity != null) {\n                Sort sort = updateMapper.getMappedObject(sortParameter, entity);\n                selectFrom = selectFrom.orderBy(createOrderByFields(Table.create(entity.getTableName()).as(EntityManager.ENTITY_ALIAS), sort));\n            }\n        }\n        return createSelect(selectFrom.build());\n    }\n\n    private RelationalPersistentEntity<?> getPersistentEntity(Class<?> entityType) {\n        return r2dbcEntityTemplate.getConverter().getMappingContext().getPersistentEntity(entityType);\n    }\n\n    /**\n     * Delete all the entity with the given type, and return the number of deletions.\n     * @param entityType the entity type which holds the table name.\n     * @return the number of deleted entity\n     */\n    public Mono<Integer> deleteAll(Class<?> entityType) {\n        return r2dbcEntityTemplate.delete(entityType).all();\n    }\n\n    /**\n     * Delete all the rows from the given table, and return the number of deletions.\n     * @param tableName the name of the table to delete.\n     * @return the number of deleted rows.\n     */\n    public Mono<Integer> deleteAll(String tableName) {\n        StatementMapper.DeleteSpec delete = statementMapper.createDelete(tableName);\n        return r2dbcEntityTemplate.getDatabaseClient().sql(statementMapper.getMappedObject(delete)).fetch().rowsUpdated();\n    }\n\n    /**\n     * Generate an actual SQL from the given {@link Select}.\n     * @param select a representation of a select statement.\n     * @return the generated SQL select.\n     */\n    public String createSelect(Select select) {\n        return sqlRenderer.render(select);\n    }\n\n    /**\n     * Inserts the given entity into the database - and sets the id, if it's an autoincrement field.\n     * @param <S> the type of the persisted entity.\n     * @param entity the entity to be inserted into the database.\n     * @return the persisted entity.\n     */\n    public <S> Mono<S> insert(S entity) {\n        return r2dbcEntityTemplate.insert(entity);\n    }\n\n    /**\n     * Updates the table, which links the entity with the referred entities.\n     * @param table describes the link table, it contains a table name, the column name for the id, and for the referred entity id.\n     * @param entityId the id of the entity, for which the links are created.\n     * @param referencedIds the id of the referred entities.\n     * @return the number of inserted rows.\n     */\n    public Mono<Integer> updateLinkTable(LinkTable table, Object entityId, Stream<?> referencedIds) {\n        return deleteFromLinkTable(table, entityId)\n                .then(\n                    Flux.fromStream(referencedIds)\n                        .flatMap((Object referenceId) -> {\n                            StatementMapper.InsertSpec insert = r2dbcEntityTemplate\n                                .getDataAccessStrategy()\n                                .getStatementMapper()\n                                .createInsert(table.tableName)\n                                .withColumn(table.idColumn, Parameter.from(entityId))\n                                .withColumn(table.referenceColumn, Parameter.from(referenceId));\n\n                            return r2dbcEntityTemplate\n                                .getDatabaseClient()\n                                .sql(statementMapper.getMappedObject(insert))\n                                .fetch()\n                                .rowsUpdated();\n                            })\n                        .collectList()\n                        .map((List<Integer> updates) -> updates.stream().reduce(Integer::sum).orElse(0)));\n    }\n\n    public Mono<Void> deleteFromLinkTable(LinkTable table, Object entityId) {\n        Assert.notNull(entityId, \"entityId is null\");\n        StatementMapper.DeleteSpec deleteSpec = r2dbcEntityTemplate.getDataAccessStrategy().getStatementMapper()\n            .createDelete(table.tableName)\n            .withCriteria(Criteria.from(Criteria.where(table.idColumn).is(entityId)));\n        return r2dbcEntityTemplate.getDatabaseClient().sql(statementMapper.getMappedObject(deleteSpec)).then();\n    }\n\n    private static Collection<? extends OrderByField> createOrderByFields(Table table, Sort sortToUse) {\n\n        List<OrderByField> fields = new ArrayList<>();\n\n        for (Sort.Order order : sortToUse) {\n\n            String propertyName = order.getProperty();\n            OrderByField orderByField = OrderByField.from(table.column(propertyName).as(EntityManager.ALIAS_PREFIX + propertyName));\n\n            fields.add(order.isAscending() ? orderByField.asc() : orderByField.desc());\n        }\n\n        return fields;\n    }\n\n}\n"], "fixing_code": ["<%#\n Copyright 2013-2022 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= entityAbsolutePackage %>.repository;\n\nimport java.util.function.BiFunction;\n<%_ if (fieldsContainBigDecimal) { _%>\nimport java.math.BigDecimal;\n<%_} if (fieldsContainInstant) { _%>\nimport java.time.Instant;\n<%_ } if (fieldsContainLocalDate) { _%>\nimport java.time.LocalDate;\n<%_ } if (fieldsContainZonedDateTime) { _%>\nimport java.time.ZonedDateTime;\n<%_ } if (fieldsContainDuration) { _%>\nimport java.time.Duration;\n<%_ } if (fieldsContainUUID) { _%>\nimport java.util.UUID;\n<%_ } _%>\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport org.springframework.data.domain.Pageable;\nimport io.r2dbc.spi.Row;\nimport io.r2dbc.spi.RowMetadata;\nimport static org.springframework.data.relational.core.query.Criteria.where;\n<%_ if (containsBagRelationships) { _%>\nimport static org.springframework.data.relational.core.query.Query.query;\n<%_ } _%>\nimport org.springframework.data.r2dbc.convert.R2dbcConverter;\nimport org.springframework.data.r2dbc.core.R2dbcEntityOperations;\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\nimport org.springframework.data.r2dbc.repository.support.SimpleR2dbcRepository;\nimport org.springframework.data.relational.core.query.Criteria;\nimport org.springframework.data.relational.core.sql.Column;\nimport org.springframework.data.relational.core.sql.Comparison;\nimport org.springframework.data.relational.core.sql.Condition;\nimport org.springframework.data.relational.core.sql.Conditions;\nimport org.springframework.data.relational.core.sql.Expression;\nimport org.springframework.data.relational.core.sql.Select;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectFromAndJoin<% if (reactiveEagerRelations.length > 0) { %>Condition<% } %>;\nimport org.springframework.data.relational.core.sql.Table;\nimport org.springframework.data.relational.repository.support.MappingRelationalEntityInformation;\nimport org.springframework.r2dbc.core.DatabaseClient;\nimport org.springframework.r2dbc.core.RowsFetchSpec;\n\nimport <%= entityAbsolutePackage %>.domain.<%= persistClass %>;\n<% relationships.forEach(function(rel) {\n  if (rel.relationshipManyToMany && rel.ownerSide) { _%>\nimport <%= rel.otherEntity.entityAbsolutePackage %>.domain.<%= rel.otherEntity.persistClass %>;\n  <%_ } _%>\n<%_ }); _%>\n<%_ Object.keys(uniqueEnums).forEach(function(element) { _%>\n\nimport <%= entityAbsolutePackage %>.domain.enumeration.<%= element %>;\n<%_ }); _%>\n\n<%_ [...reactiveOtherEntities, entity].forEach(otherEntity => { _%>\nimport <%= otherEntity.entityAbsolutePackage %>.repository.rowmapper.<%= otherEntity.entityClass %>RowMapper;\n  <%_ if (otherEntity.entityPackage !== entityPackage) { _%>\nimport <%= otherEntity.entityAbsolutePackage %>.repository.<%= otherEntity.entityClass %>SqlHelper;\n  <%_ } _%>\n<%_ }); _%>\n<%_ if (packageName !== entityAbsolutePackage) { _%>\nimport <%= packageName %>.repository.EntityManager;\n<%_ } _%>\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\n/**\n * Spring Data <%= officialDatabaseType %> reactive custom repository implementation for the <%= persistClass %> entity.\n */\n@SuppressWarnings(\"unused\")\nclass <%= entityClass %>RepositoryInternalImpl extends SimpleR2dbcRepository<<%= persistClass %>, <%= primaryKey.type %>> implements <%= entityClass %>RepositoryInternal {\n    private final DatabaseClient db;\n    private final R2dbcEntityTemplate r2dbcEntityTemplate;\n    private final EntityManager entityManager;\n\n<%_ reactiveUniqueEntityTypes.forEach(function(element) { _%>\n    private final <%= element %>RowMapper <%= element.toLowerCase() %>Mapper;\n<%_ }); _%>\n\n    private final static Table entityTable = Table.aliased(\"<%= entityTableName %>\", EntityManager.ENTITY_ALIAS);\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n    private final static Table <%= rel.relationshipName %>Table = Table.aliased(\"<%= rel.otherEntityTableName %>\", \"<%= _generateSqlSafeName(rel.relationshipName) %>\");\n<%_ }); _%>\n\n<%_ relationships.forEach(function(rel) {\n  if (rel.shouldWriteJoinTable) {\n_%>\n    private final static EntityManager.LinkTable <%= rel.relationshipName %>Link = new EntityManager.LinkTable(\"<%= rel.joinTable.name %>\", \"<%= entity.entityTableName %>_<%= getColumnName(entity.primaryKey.name) %>\", \"<%= rel.joinColumnNames[0] %>\");\n<%_ }\n}); _%>\n\n    public <%= entityClass %>RepositoryInternalImpl(R2dbcEntityTemplate template, EntityManager entityManager<%_\n            reactiveUniqueEntityTypes.forEach(function(element) { _%>, <%= element %>RowMapper <%= element.toLowerCase() %>Mapper<%_ }); _%>, R2dbcEntityOperations entityOperations,\n        R2dbcConverter converter) {\n        super(new MappingRelationalEntityInformation(converter.getMappingContext().getRequiredPersistentEntity(<%= persistClass %>.class)), entityOperations, converter);\n        this.db = template.getDatabaseClient();\n        this.r2dbcEntityTemplate = template;\n        this.entityManager = entityManager;\n<%_ reactiveUniqueEntityTypes.forEach(function(element) { _%>\n        this.<%= element.toLowerCase() %>Mapper = <%= element.toLowerCase() %>Mapper;\n<%_ }); _%>\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllBy(Pageable pageable) {\n        return createQuery(pageable, null).all();\n    }\n\n    RowsFetchSpec<<%= persistClass %>> createQuery(Pageable pageable, Condition whereClause) {\n        List<Expression> columns = <%= entityClass %>SqlHelper.getColumns(entityTable, EntityManager.ENTITY_ALIAS);\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n        columns.addAll(<%= rel.otherEntityNameCapitalized %>SqlHelper.getColumns(<%= rel.relationshipName %>Table, \"<%= rel.relationshipName %>\"));\n<%_ }); _%>\n        SelectFromAndJoin<% if (reactiveEagerRelations.length > 0) { %>Condition<% } %> selectFrom = Select.builder().select(columns).from(entityTable)\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n            .leftOuterJoin(<%= rel.relationshipName %>Table).on(Column.create(\"<%= rel.joinColumnNames[0] %>\", entityTable)).equals(Column.create(\"<%= rel.otherEntity.primaryKey.fields[0].columnName %>\", <%= rel.relationshipName %>Table ))\n<%_ }); _%>;\n        // we do not support Criteria here for now as of https://github.com/jhipster/generator-jhipster/issues/18269\n        String select = entityManager.createSelect(selectFrom, <%= persistClass %>.class, pageable, whereClause);\n        return db.sql(select).map(this::process);\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAll() {\n        return findAllBy(null);\n    }\n\n    @Override\n    public Mono<<%= persistClass %>> findById(<%= primaryKey.type %> id) {\n        Comparison whereClause = Conditions.isEqual(entityTable.column(\"<%= primaryKey.fields[0].columnName %>\"), Conditions.just(id.toString()));\n        return createQuery(null, whereClause).one();\n    }\n\n<%_ if (implementsEagerLoadApis) { _%>\n\n    @Override\n    public Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id) {\n        return findById(id);\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllWithEagerRelationships() {\n        return findAll();\n    }\n\n    @Override\n    public Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable page) {\n        return findAllBy(page);\n    }\n\n<%_ } _%>\n    private <%= persistClass %> process(Row row, RowMetadata metadata) {\n        <%= persistClass %> entity = <%= entityClass.toLowerCase() %>Mapper.apply(row, \"e\");\n<%_ reactiveEagerRelations.forEach(function(rel) { _%>\n        entity.set<%= rel.relationshipNameCapitalized %>(<%= rel.otherEntityNameCapitalized.toLowerCase() %>Mapper.apply(row, \"<%= rel.relationshipName %>\"));\n<%_ }); _%>\n        return entity;\n    }\n\n    @Override\n    public <S extends <%= persistClass %>> Mono<S> save(S entity) {\n<%_ if (isUsingMapsId) { _%>\n        if (entity.get<%= primaryKey.nameCapitalized %>() == null && entity.get<%= mapsIdAssoc.relationshipNameCapitalized %>() != null) {\n            entity.set<%= primaryKey.nameCapitalized %>(entity.get<%= mapsIdAssoc.relationshipNameCapitalized %>().get<%= mapsIdAssoc.otherEntity.primaryKey.nameCapitalized %>());\n            return entityManager.insert(entity);\n        }\n<%_ } _%>\n        return super.save(entity)<% if (containsBagRelationships) { %>.flatMap((S e) -> updateRelations(e))<% } %>;\n    }\n\n<%_ if (containsBagRelationships) { _%>\n    protected <S extends <%= persistClass %>> Mono<S> updateRelations(S entity) {\n  <%_ relationships.filter(function(rel) {\n    return (rel.relationshipManyToMany && rel.ownerSide);\n   }).forEach(function(rel, idx) { _%>\n    <%_ if (idx === 0) { _%>\n        Mono<Void> result = entityManager.updateLinkTable(<%= rel.relationshipName %>Link, entity.get<%= primaryKey.nameCapitalized %>(), entity.get<%= rel.relationshipNameCapitalizedPlural %>().stream().map(<%= asEntity(rel.otherEntityNameCapitalized) %>::get<%= rel.otherEntity.primaryKey.nameCapitalized %>)).then();\n    <%_ } else { _%>\n        result = result.and(entityManager.updateLinkTable(<%= rel.relationshipName %>Link, entity.get<%= primaryKey.nameCapitalized %>(), entity.get<%= rel.relationshipNameCapitalizedPlural %>().stream().map(<%= asEntity(rel.otherEntityNameCapitalized) %>::get<%= rel.otherEntity.primaryKey.nameCapitalized %>)));\n    <%_ } _%>\n  <%_ }); _%>\n        return result.thenReturn(entity);\n    }\n\n    @Override\n    public Mono<Void> deleteById(<%= primaryKey.type %> entityId) {\n        return deleteRelations(entityId)\n            .then(super.deleteById(entityId));\n    }\n\n    protected Mono<Void> deleteRelations(<%= primaryKey.type %> entityId) {\n  <%_ relationships.filter(function(rel) {\n      return (rel.relationshipManyToMany && rel.ownerSide);\n    }).forEach(function(rel, idx) { _%>\n    <%_ if (idx === 0) { _%>\n        return entityManager.deleteFromLinkTable(<%= rel.relationshipName %>Link, entityId)\n    <%_} else { _%>\n            .and(entityManager.deleteFromLinkTable(<%= rel.relationshipName %>Link, entityId))\n    <%_ } _%>\n  <%_ }); %>;\n        }\n<%_ } _%>\n}\n", "<%#\n Copyright 2013-2022 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= entityAbsolutePackage %>.repository;\n\nimport <%= entityAbsolutePackage %>.domain.<%= persistClass %>;\n<%_ if (databaseTypeCassandra) { _%>\nimport org.springframework.data.cassandra.repository.ReactiveCassandraRepository;\n<%_ } _%>\n<%_ if (databaseTypeNeo4j) { _%>\nimport org.springframework.data.neo4j.repository.ReactiveNeo4jRepository;\nimport org.springframework.data.neo4j.repository.query.Query;\n<%_ } _%>\n<%_ if (!paginationNo || implementsEagerLoadApis || databaseTypeSql) { _%>\nimport org.springframework.data.domain.Pageable;\n<%_ } _%>\n<%_ if (databaseTypeSql) { _%>\nimport org.springframework.data.r2dbc.repository.Query;\nimport org.springframework.data.repository.reactive.ReactiveCrudRepository;\nimport org.springframework.data.relational.core.query.Criteria;\n<%_ } _%>\n<%_ if (databaseTypeMongodb) { _%>\n  <%_ if (implementsEagerLoadApis) { _%>\nimport org.springframework.data.mongodb.repository.Query;\n  <%_ } _%>\nimport org.springframework.data.mongodb.repository.ReactiveMongoRepository;\n<%_ } _%>\nimport org.springframework.stereotype.Repository;\n<%_ if (databaseTypeSql || !paginationNo || implementsEagerLoadApis) { _%>\nimport reactor.core.publisher.Flux;\n<%_ } _%>\n<%_ if (implementsEagerLoadApis || databaseTypeSql) { _%>\nimport reactor.core.publisher.Mono;\n<%_ } _%>\n<%_ if (primaryKey.typeUUID) { _%>\n\nimport java.util.UUID;\n<%_ } _%>\n\n/**\n * Spring Data <%= officialDatabaseType %> reactive repository for the <%= persistClass %> entity.\n */\n@SuppressWarnings(\"unused\")\n@Repository\npublic interface <%= entityClass %>Repository extends <% if (databaseTypeSql) { %>ReactiveCrud<% } if (databaseTypeMongodb) { %>ReactiveMongo<% } if (databaseTypeNeo4j) { %>ReactiveNeo4j<% } if (databaseTypeCassandra) { %>ReactiveCassandra<% } %>Repository<<%= persistClass %>, <%= primaryKey.type %>><% if (databaseTypeSql) { %>, <%= entityClass %>RepositoryInternal<% } %> {\n\n<%_ if (!paginationNo) { _%>\n    Flux<<%= persistClass %>> findAllBy(Pageable pageable);\n<%_ } _%>\n<%_ if (implementsEagerLoadApis) { _%>\n  <%_ if (databaseTypeMongodb) { _%>\n\n    @Query(\"<%= (databaseTypeMongodb) ? '{}' : '#{#n1ql.selectEntity} WHERE #{#n1ql.filter}' %>\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable pageable);\n\n    @Query(\"<%= (databaseTypeMongodb) ? '{}' : '#{#n1ql.selectEntity} WHERE #{#n1ql.filter}' %>\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    @Query(\"<%- (databaseTypeMongodb) ? \"{'id': ?0}\" : \"#{#n1ql.selectEntity} USE KEYS $1 WHERE #{#n1ql.filter}\" %>\")\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n  <%_ } _%>\n  <%_ if (databaseTypeNeo4j) { _%>\n    @Query(\"MATCH (n:<%= persistClass %>)<-[]-(m) RETURN n,m\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable pageable);\n\n    @Query(\"MATCH (n:<%= persistClass %>)<-[]-(m) RETURN n,m\")\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    @Query(\"MATCH (e:<%= persistClass %> {id: $id}) RETURN e\")\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n  <%_ } _%>\n<%_ } _%>\n<%_ if (databaseTypeSql) { _%>\n  <%_ if (implementsEagerLoadApis) { _%>\n\n    @Override\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n\n    @Override\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    @Override\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable page);\n\n  <%_ } _%>\n\n  <%_ for (const relationship of relationships) {\n    let relationshipName = relationship.relationshipName;\n    let ownerSide = relationship.ownerSide; _%>\n    <%_ if (relationship.relationshipManyToOne || (relationship.relationshipOneToOne && ownerSide)) { _%>\n\n    @Query(\"SELECT * FROM <%= entityTableName %> entity WHERE entity.<%= relationship.joinColumnNames[0] %> = :id\")\n    Flux<<%= persistClass %>> findBy<%= relationship.relationshipNameCapitalized %>(<%= primaryKey.type %> id);\n\n    @Query(\"SELECT * FROM <%= entityTableName %> entity WHERE entity.<%= relationship.joinColumnNames[0] %> IS NULL\")\n    Flux<<%= persistClass %>> findAllWhere<%= relationship.relationshipNameCapitalized %>IsNull();\n    <%_ } else if (relationship.shouldWriteJoinTable) { _%>\n\n    @Query(\"SELECT entity.* FROM <%= entityTableName %> entity JOIN <%= relationship.joinTable.name %> joinTable ON entity.<%= primaryKey.fields[0].columnName %> = joinTable.<%= relationship.joinColumnNames[0] %> WHERE joinTable.<%= relationship.joinColumnNames[0] %> = :id\")\n    Flux<<%= persistClass %>> findBy<%= relationship.relationshipNameCapitalized %>(<%= primaryKey.type %> id);\n    <%_ } else if (relationship.relationshipOneToOne && !ownerSide) {\n        let otherEntityRelationshipName = relationship.otherEntityRelationshipName;\n        let otherEntityTableName = relationship.otherEntityTableName;\n      _%>\n\n    @Query(\"SELECT * FROM <%= entityTableName %> entity WHERE entity.<%= primaryKey.fields[0].columnName  %> not in (select <%= relationship.joinColumnNames[0]%> from <%= otherEntityTableName %>)\")\n    Flux<<%= persistClass %>> findAllWhere<%= relationship.relationshipNameCapitalized %>IsNull();\n    <%_ } _%>\n  <%_ } _%>\n\n    @Override\n    <S extends <%= persistClass %>> Mono<S> save(S entity);\n\n    @Override\n    Flux<<%= persistClass %>> findAll();\n\n    @Override\n    Mono<<%= persistClass %>> findById(<%= primaryKey.type %> id);\n\n    @Override\n    Mono<Void> deleteById(<%= primaryKey.type %> id);\n}\n\ninterface <%= entityClass %>RepositoryInternal {\n    <S extends <%= persistClass %>> Mono<S> save(S entity);\n\n    Flux<<%= persistClass %>> findAllBy(Pageable pageable);\n\n    Flux<<%= persistClass %>> findAll();\n\n    Mono<<%= persistClass %>> findById(<%= primaryKey.type %> id);\n    // this is not supported at the moment because of https://github.com/jhipster/generator-jhipster/issues/18269\n    // Flux<<%= persistClass %>> findAllBy(Pageable pageable, Criteria criteria);\n\n  <%_ if (implementsEagerLoadApis) { _%>\n\n    Mono<<%= persistClass %>> findOneWithEagerRelationships(<%= primaryKey.type %> id);\n\n    Flux<<%= persistClass %>> findAllWithEagerRelationships();\n\n    Flux<<%= persistClass %>> findAllWithEagerRelationships(Pageable page);\n\n    Mono<Void> deleteById(<%= primaryKey.type %> id);\n  <%_ } _%>\n<%_ } _%>\n}\n", "<%#\n Copyright 2013-2022 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= packageName %>.repository;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.stream.Stream;\n\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.r2dbc.convert.R2dbcConverter;\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\nimport org.springframework.data.r2dbc.core.StatementMapper;\nimport org.springframework.data.r2dbc.mapping.OutboundRow;\nimport org.springframework.data.r2dbc.query.UpdateMapper;\nimport org.springframework.data.relational.core.query.Criteria;\nimport org.springframework.data.relational.core.sql.Condition;\nimport org.springframework.data.relational.core.mapping.RelationalPersistentEntity;\nimport org.springframework.data.relational.core.sql.Conditions;\nimport org.springframework.data.relational.core.sql.OrderByField;\nimport org.springframework.data.relational.core.sql.Select;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectFromAndJoin;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectFromAndJoinCondition;\nimport org.springframework.data.relational.core.sql.SelectBuilder.SelectOrdered;\nimport org.springframework.data.relational.core.sql.SqlIdentifier;\nimport org.springframework.data.relational.core.sql.Table;\nimport org.springframework.data.relational.core.sql.render.SqlRenderer;\nimport org.springframework.r2dbc.core.Parameter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.Assert;\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\n/**\n * Helper class to create SQL selects based on the entity, paging parameters and criteria.\n *\n */\n@Component\npublic class EntityManager {\n    public final static String ENTITY_ALIAS = \"e\";\n    public final static String ALIAS_PREFIX = \"e_\";\n\n    public static class LinkTable {\n        final String tableName;\n        final String idColumn;\n        final String referenceColumn;\n\n        public LinkTable(String tableName, String idColumn, String referenceColumn) {\n            Assert.notNull(tableName, \"tableName is null\");\n            Assert.notNull(idColumn, \"idColumn is null\");\n            Assert.notNull(referenceColumn, \"referenceColumn is null\");\n            this.tableName = tableName;\n            this.idColumn = idColumn;\n            this.referenceColumn = referenceColumn;\n        }\n    }\n\n    private final SqlRenderer sqlRenderer;\n    private final UpdateMapper updateMapper;\n    private final R2dbcEntityTemplate r2dbcEntityTemplate;\n    private final StatementMapper statementMapper;\n\n    public EntityManager(SqlRenderer sqlRenderer, UpdateMapper updateMapper, R2dbcEntityTemplate r2dbcEntityTemplate) {\n        this.sqlRenderer = sqlRenderer;\n        this.updateMapper = updateMapper;\n        this.r2dbcEntityTemplate = r2dbcEntityTemplate;\n        this.statementMapper = r2dbcEntityTemplate.getDataAccessStrategy().getStatementMapper();\n    }\n\n    /**\n     * Creates an SQL select statement from the given fragment and pagination parameters.\n     * @param selectFrom a representation of a select statement.\n     * @param entityType the entity type which holds the table name.\n     * @param pageable page parameter, or null, if everything needs to be returned\n     * @return sql select statement\n     */\n    public String createSelect(SelectFromAndJoin selectFrom, Class<?> entityType, Pageable pageable) {\n        if (pageable != null) {\n            return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()), entityType, pageable.getSort());\n        } else {\n            return createSelectImpl(selectFrom, entityType, null);\n        }\n    }\n\n    /**\n     * Creates an SQL select statement from the given fragment and pagination parameters.\n     * @param selectFrom a representation of a select statement.\n     * @param entityType the entity type which holds the table name.\n     * @param pageable page parameter, or null, if everything needs to be returned\n     * @return sql select statement\n     */\n    public String createSelect(SelectFromAndJoinCondition selectFrom, Class<?> entityType, Pageable pageable, Condition where) {\n        if (pageable != null) {\n            return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()), entityType, pageable.getSort());\n        } else {\n            return createSelectImpl(selectFrom.where(where), entityType, null);\n        }\n    }\n\n    public String createSelect(SelectFromAndJoin selectFrom, Class<?> entityType, Pageable pageable, Condition where) {\n        if (pageable != null) {\n            return createSelectImpl(selectFrom.limitOffset(pageable.getPageSize(), pageable.getOffset()).where(where), entityType, pageable.getSort());\n        } else {\n            return createSelectImpl(selectFrom.where(where), entityType, null);\n        }\n    }\n\n    private String createSelectImpl(SelectOrdered selectFrom, Class<?> entityType, Sort sortParameter) {\n        if (sortParameter != null && sortParameter.isSorted()) {\n            RelationalPersistentEntity<?> entity = getPersistentEntity(entityType);\n            if (entity != null) {\n                Sort sort = updateMapper.getMappedObject(sortParameter, entity);\n                selectFrom = selectFrom.orderBy(createOrderByFields(Table.create(entity.getTableName()).as(EntityManager.ENTITY_ALIAS), sort));\n            }\n        }\n        return createSelect(selectFrom.build());\n    }\n\n    private RelationalPersistentEntity<?> getPersistentEntity(Class<?> entityType) {\n        return r2dbcEntityTemplate.getConverter().getMappingContext().getPersistentEntity(entityType);\n    }\n\n    /**\n     * Delete all the entity with the given type, and return the number of deletions.\n     * @param entityType the entity type which holds the table name.\n     * @return the number of deleted entity\n     */\n    public Mono<Integer> deleteAll(Class<?> entityType) {\n        return r2dbcEntityTemplate.delete(entityType).all();\n    }\n\n    /**\n     * Delete all the rows from the given table, and return the number of deletions.\n     * @param tableName the name of the table to delete.\n     * @return the number of deleted rows.\n     */\n    public Mono<Integer> deleteAll(String tableName) {\n        StatementMapper.DeleteSpec delete = statementMapper.createDelete(tableName);\n        return r2dbcEntityTemplate.getDatabaseClient().sql(statementMapper.getMappedObject(delete)).fetch().rowsUpdated();\n    }\n\n    /**\n     * Generate an actual SQL from the given {@link Select}.\n     * @param select a representation of a select statement.\n     * @return the generated SQL select.\n     */\n    public String createSelect(Select select) {\n        return sqlRenderer.render(select);\n    }\n\n    /**\n     * Inserts the given entity into the database - and sets the id, if it's an autoincrement field.\n     * @param <S> the type of the persisted entity.\n     * @param entity the entity to be inserted into the database.\n     * @return the persisted entity.\n     */\n    public <S> Mono<S> insert(S entity) {\n        return r2dbcEntityTemplate.insert(entity);\n    }\n\n    /**\n     * Updates the table, which links the entity with the referred entities.\n     * @param table describes the link table, it contains a table name, the column name for the id, and for the referred entity id.\n     * @param entityId the id of the entity, for which the links are created.\n     * @param referencedIds the id of the referred entities.\n     * @return the number of inserted rows.\n     */\n    public Mono<Integer> updateLinkTable(LinkTable table, Object entityId, Stream<?> referencedIds) {\n        return deleteFromLinkTable(table, entityId)\n                .then(\n                    Flux.fromStream(referencedIds)\n                        .flatMap((Object referenceId) -> {\n                            StatementMapper.InsertSpec insert = r2dbcEntityTemplate\n                                .getDataAccessStrategy()\n                                .getStatementMapper()\n                                .createInsert(table.tableName)\n                                .withColumn(table.idColumn, Parameter.from(entityId))\n                                .withColumn(table.referenceColumn, Parameter.from(referenceId));\n\n                            return r2dbcEntityTemplate\n                                .getDatabaseClient()\n                                .sql(statementMapper.getMappedObject(insert))\n                                .fetch()\n                                .rowsUpdated();\n                            })\n                        .collectList()\n                        .map((List<Integer> updates) -> updates.stream().reduce(Integer::sum).orElse(0)));\n    }\n\n    public Mono<Void> deleteFromLinkTable(LinkTable table, Object entityId) {\n        Assert.notNull(entityId, \"entityId is null\");\n        StatementMapper.DeleteSpec deleteSpec = r2dbcEntityTemplate.getDataAccessStrategy().getStatementMapper()\n            .createDelete(table.tableName)\n            .withCriteria(Criteria.from(Criteria.where(table.idColumn).is(entityId)));\n        return r2dbcEntityTemplate.getDatabaseClient().sql(statementMapper.getMappedObject(deleteSpec)).then();\n    }\n\n    private static Collection<? extends OrderByField> createOrderByFields(Table table, Sort sortToUse) {\n\n        List<OrderByField> fields = new ArrayList<>();\n\n        for (Sort.Order order : sortToUse) {\n\n            String propertyName = order.getProperty();\n            OrderByField orderByField = OrderByField.from(table.column(propertyName).as(EntityManager.ALIAS_PREFIX + propertyName));\n\n            fields.add(order.isAscending() ? orderByField.asc() : orderByField.desc());\n        }\n\n        return fields;\n    }\n\n}\n"], "filenames": ["generators/entity-server/templates/src/main/java/package/repository/EntityRepositoryInternalImpl_reactive.java.ejs", "generators/entity-server/templates/src/main/java/package/repository/EntityRepository_reactive.java.ejs", "generators/server/templates/src/main/java/package/repository/EntityManager.java.ejs"], "buggy_code_start_loc": [52, 147, 35], "buggy_code_end_loc": [154, 149, 132], "fixing_code_start_loc": [53, 147, 36], "fixing_code_end_loc": [153, 149, 125], "type": "CWE-89", "message": "JHipster is a development platform to quickly generate, develop, & deploy modern web applications & microservice architectures. SQL Injection vulnerability in entities for applications generated with the option \"reactive with Spring WebFlux\" enabled and an SQL database using r2dbc. Applications created without \"reactive with Spring WebFlux\" and applications with NoSQL databases are not affected. Users who have generated a microservice Gateway using the affected version may be impacted as Gateways are reactive by default. Currently, SQL injection is possible in the findAllBy(Pageable pageable, Criteria criteria) method of an entity repository class generated in these applications as the where clause using Criteria for queries are not sanitized and user input is passed on as it is by the criteria. This issue has been patched in v7.8.1. Users unable to upgrade should be careful when combining criterias and conditions as the root of the issue lies in the `EntityManager.java` class when creating the where clause via `Conditions.just(criteria.toString())`. `just` accepts the literal string provided. Criteria's `toString` method returns a plain string and this combination is vulnerable to sql injection as the string is not sanitized and will contain whatever used passed as input using any plain SQL.", "other": {"cve": {"id": "CVE-2022-24815", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-11T20:15:20.217", "lastModified": "2022-04-19T17:34:41.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JHipster is a development platform to quickly generate, develop, & deploy modern web applications & microservice architectures. SQL Injection vulnerability in entities for applications generated with the option \"reactive with Spring WebFlux\" enabled and an SQL database using r2dbc. Applications created without \"reactive with Spring WebFlux\" and applications with NoSQL databases are not affected. Users who have generated a microservice Gateway using the affected version may be impacted as Gateways are reactive by default. Currently, SQL injection is possible in the findAllBy(Pageable pageable, Criteria criteria) method of an entity repository class generated in these applications as the where clause using Criteria for queries are not sanitized and user input is passed on as it is by the criteria. This issue has been patched in v7.8.1. Users unable to upgrade should be careful when combining criterias and conditions as the root of the issue lies in the `EntityManager.java` class when creating the where clause via `Conditions.just(criteria.toString())`. `just` accepts the literal string provided. Criteria's `toString` method returns a plain string and this combination is vulnerable to sql injection as the string is not sanitized and will contain whatever used passed as input using any plain SQL."}, {"lang": "es", "value": "JHipster es una plataforma de desarrollo para generar, desarrollar y desplegar r\u00e1pidamente aplicaciones web modernas y arquitecturas de microservicios. Vulnerabilidad de inyecci\u00f3n SQL en entidades para aplicaciones generadas con la opci\u00f3n \"reactiva con Spring WebFlux\" habilitada y una base de datos SQL usando r2dbc. Las aplicaciones creadas sin \"reactivo con Spring WebFlux\" y las aplicaciones con bases de datos NoSQL no est\u00e1n afectadas. Los usuarios que hayan generado un microservicio Gateway usando la versi\u00f3n afectada pueden verse afectados ya que los Gateways son reactivos por defecto. Actualmente, la inyecci\u00f3n SQL es posible en el m\u00e9todo findAllBy(Pageable pageable, Criteria criteria) de una clase de repositorio de entidades generada en estas aplicaciones, ya que la cl\u00e1usula where que usa Criteria para las consultas no est\u00e1 saneada y la entrada del usuario es pasada tal cual por los criterios. Este problema ha sido parcheado en versi\u00f3n 7.8.1. Los usuarios que no puedan actualizar deber\u00e1n tener cuidado cuando combinen criterios y condiciones, ya que la ra\u00edz del problema es encontrada en la clase \"EntityManager.java' cuando es creada la cl\u00e1usula where por medio de \"Conditions.just(criteria.toString())\". La clase \"just\" acepta la cadena literal proporcionada. El m\u00e9todo \"toString\" de Criteria devuelve una cadena simple y esta combinaci\u00f3n es vulnerable a una inyecci\u00f3n de sql, ya que la cadena no est\u00e1 saneada y contendr\u00e1 lo que haya sido pasado como entrada usando cualquier SQL simple"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jhipster:generator-jhipster:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.8.1", "matchCriteriaId": "056A57BE-F484-4FE0-B0A0-A4ADB5DCEBE0"}]}]}], "references": [{"url": "https://github.com/jhipster/generator-jhipster/commit/c220a210fd7742c53eea72bd5fadbb96220faa98", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jhipster/generator-jhipster/issues/18269", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/jhipster/generator-jhipster/security/advisories/GHSA-qjmq-8hjr-qcv6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jhipster/generator-jhipster/commit/c220a210fd7742c53eea72bd5fadbb96220faa98"}}