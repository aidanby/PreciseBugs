{"buggy_code": ["\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_yank_zy()\n  new\n  \" this was reading before the start of the line\n  exe \"norm o\\<C-T>\\<Esc>\\<C-V>zy\"\n  bwipe!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_block_with_substitute()\n  \" this was reading beyond the end of the line\n  new\n  norm a0)\n  sil! norm \u0016 O\n  s/)\n  sil! norm \u001d\n  bwipe!\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\" this was causing an ml_get error\nfunc Test_visual_exchange_windows()\n  enew!\n  new\n  call setline(1, ['foo', 'bar'])\n  exe \"normal G\\<C-V>gg\\<C-W>\\<C-X>OO\\<Esc>\"\n  bwipe!\n  bwipe!\nendfunc\n\n\" this was leaving the end of the Visual area beyond the end of a line\nfunc Test_visual_ex_copy_line()\n  new\n  call setline(1, [\"aaa\", \"bbbbbbbbbxbb\"])\n  /x\n  exe \"normal ggvjfxO\"\n  t0\n  normal gNU\n  bwipe!\nendfunc\n\n\" This was leaving the end of the Visual area beyond the end of a line.\n\" Set 'undolevels' to start a new undo block.\nfunc Test_visual_undo_deletes_last_line()\n  new\n  call setline(1, [\"aaa\", \"ccc\", \"dyd\"])\n  set undolevels=100\n  exe \"normal obbbbbbbbbxbb\\<Esc>\"\n  set undolevels=100\n  /y\n  exe \"normal ggvjfxO\"\n  undo\n  normal gNU\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste()\n  new\n\n  \" v_p overwrites unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vp\n  call assert_equal('f', @\")\n  call assert_equal('f', @-)\n  call assert_equal('bazooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('bazooxxf', getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste_clipboard()\n  CheckFeature clipboard_working\n\n  if has('gui')\n    \" auto select feature breaks tests\n    set guioptions-=a\n  endif\n\n  \" v_P does not overwrite unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxfoo', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfoo', getline(1))\n  normal $vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfobaz', getline(1))\n\n  \" Test for unnamed clipboard\n  set clipboard=unnamed\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  call setreg('*', 'baz')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('baz', @*)\n  call assert_equal('bazxxx', getline(1))\n\n  \" Test for unnamedplus clipboard\n  if has('unnamedplus')\n    set clipboard=unnamedplus\n    call setline(1, ['xxxx'])\n    call setreg('\"', 'foo')\n    call setreg('-', 'bar')\n    call setreg('+', 'baz')\n    normal gg0vP\n    call assert_equal('foo', @\")\n    call assert_equal('bar', @-)\n    call assert_equal('baz', @+)\n    call assert_equal('bazxxx', getline(1))\n  endif\n\n  set clipboard&\n  if has('gui')\n    set guioptions&\n  endif\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Trigger WinScrolled for \"curwin\" if needed.\n */\n    void\nmay_trigger_winscrolled(void)\n{\n    win_T\t    *wp = curwin;\n    static int\t    recursive = FALSE;\n    char_u\t    winid[NUMBUFLEN];\n\n    if (recursive || !has_winscrolled())\n\treturn;\n\n    if (wp->w_last_topline != wp->w_topline\n\t    || wp->w_last_leftcol != wp->w_leftcol\n\t    || wp->w_last_width != wp->w_width\n\t    || wp->w_last_height != wp->w_height)\n    {\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\", wp->w_id);\n\n\trecursive = TRUE;\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE, wp->w_buffer);\n\trecursive = FALSE;\n\n\t// an autocmd may close the window, \"wp\" may be invalid now\n\tif (win_valid_any_tab(wp))\n\t{\n\t    wp->w_last_topline = wp->w_topline;\n\t    wp->w_last_leftcol = wp->w_leftcol;\n\t    wp->w_last_width = wp->w_width;\n\t    wp->w_last_height = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n#ifdef FEAT_CMDWIN\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n#endif\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n    vim_free(wp->w_lcs_chars.leadmultispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "fixing_code": ["\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_yank_zy()\n  new\n  \" this was reading before the start of the line\n  exe \"norm o\\<C-T>\\<Esc>\\<C-V>zy\"\n  bwipe!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_block_with_substitute()\n  \" this was reading beyond the end of the line\n  new\n  norm a0)\n  sil! norm \u0016 O\n  s/)\n  sil! norm \u001d\n  bwipe!\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\" this was causing an ml_get error\nfunc Test_visual_exchange_windows()\n  enew!\n  new\n  call setline(1, ['foo', 'bar'])\n  exe \"normal G\\<C-V>gg\\<C-W>\\<C-X>OO\\<Esc>\"\n  bwipe!\n  bwipe!\nendfunc\n\n\" this was leaving the end of the Visual area beyond the end of a line\nfunc Test_visual_ex_copy_line()\n  new\n  call setline(1, [\"aaa\", \"bbbbbbbbbxbb\"])\n  /x\n  exe \"normal ggvjfxO\"\n  t0\n  normal gNU\n  bwipe!\nendfunc\n\n\" This was leaving the end of the Visual area beyond the end of a line.\n\" Set 'undolevels' to start a new undo block.\nfunc Test_visual_undo_deletes_last_line()\n  new\n  call setline(1, [\"aaa\", \"ccc\", \"dyd\"])\n  set undolevels=100\n  exe \"normal obbbbbbbbbxbb\\<Esc>\"\n  set undolevels=100\n  /y\n  exe \"normal ggvjfxO\"\n  undo\n  normal gNU\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste()\n  new\n\n  \" v_p overwrites unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vp\n  call assert_equal('f', @\")\n  call assert_equal('f', @-)\n  call assert_equal('bazooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('bazooxxf', getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste_clipboard()\n  CheckFeature clipboard_working\n\n  if has('gui')\n    \" auto select feature breaks tests\n    set guioptions-=a\n  endif\n\n  \" v_P does not overwrite unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxfoo', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfoo', getline(1))\n  normal $vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfobaz', getline(1))\n\n  \" Test for unnamed clipboard\n  set clipboard=unnamed\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  call setreg('*', 'baz')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('baz', @*)\n  call assert_equal('bazxxx', getline(1))\n\n  \" Test for unnamedplus clipboard\n  if has('unnamedplus')\n    set clipboard=unnamedplus\n    call setline(1, ['xxxx'])\n    call setreg('\"', 'foo')\n    call setreg('-', 'bar')\n    call setreg('+', 'baz')\n    normal gg0vP\n    call assert_equal('foo', @\")\n    call assert_equal('bar', @-)\n    call assert_equal('baz', @+)\n    call assert_equal('bazxxx', getline(1))\n  endif\n\n  set clipboard&\n  if has('gui')\n    set guioptions&\n  endif\n  bwipe!\nendfunc\n\nfunc Test_visual_area_adjusted_when_hiding()\n  \" The Visual area ended after the end of the line after :hide\n  call setline(1, 'xxx')\n  vsplit Xfile\n  call setline(1, 'xxxxxxxx')\n  norm! \u0016$o\n  hid\n  norm! zW\n  bwipe!\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    reset_VIsual_and_resel();\t// stop Visual mode\n\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Trigger WinScrolled for \"curwin\" if needed.\n */\n    void\nmay_trigger_winscrolled(void)\n{\n    win_T\t    *wp = curwin;\n    static int\t    recursive = FALSE;\n    char_u\t    winid[NUMBUFLEN];\n\n    if (recursive || !has_winscrolled())\n\treturn;\n\n    if (wp->w_last_topline != wp->w_topline\n\t    || wp->w_last_leftcol != wp->w_leftcol\n\t    || wp->w_last_width != wp->w_width\n\t    || wp->w_last_height != wp->w_height)\n    {\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\", wp->w_id);\n\n\trecursive = TRUE;\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE, wp->w_buffer);\n\trecursive = FALSE;\n\n\t// an autocmd may close the window, \"wp\" may be invalid now\n\tif (win_valid_any_tab(wp))\n\t{\n\t    wp->w_last_topline = wp->w_topline;\n\t    wp->w_last_leftcol = wp->w_leftcol;\n\t    wp->w_last_width = wp->w_width;\n\t    wp->w_last_height = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n#ifdef FEAT_CMDWIN\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n#endif\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n    vim_free(wp->w_lcs_chars.leadmultispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "filenames": ["src/testdir/test_visual.vim", "src/version.c", "src/window.c"], "buggy_code_start_loc": [1472, 737, 2596], "buggy_code_end_loc": [1472, 737, 2596], "fixing_code_start_loc": [1473, 738, 2597], "fixing_code_end_loc": [1485, 740, 2599], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.", "other": {"cve": {"id": "CVE-2022-2284", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-02T15:15:07.987", "lastModified": "2023-05-03T12:15:52.427", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0."}, {"lang": "es", "value": "Un Desbordamiento del B\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio de GitHub vim/vim versiones anteriores a 9.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0017", "matchCriteriaId": "12C11532-F883-4314-B560-5375833E1EA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/3d51ce18ab1be4f9f6061568a4e7fabf00b21794", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/571d25ce-8d53-4fa0-b620-27f2a8a14874", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/3d51ce18ab1be4f9f6061568a4e7fabf00b21794"}}