{"buggy_code": ["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements. See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership. The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"CookieManager.h\"\n\n#include <UrlMon.h>\n#include <wininet.h>\n\n#include \"errorcodes.h\"\n#include \"logging.h\"\n\n#include \"BrowserCookie.h\"\n#include \"HookProcessor.h\"\n#include \"messages.h\"\n#include \"StringUtilities.h\"\n\n#define TICKS_PER_SECOND 10000000\n#define UNIX_TIME_OFFSET_SECONDS 11644473600L\n\nnamespace webdriver {\n\nstruct CookieSendMessageInfo {\n  HWND window_handle;\n  unsigned int message;\n};\n\nCookieManager::CookieManager(void) {\n  this->window_handle_ = NULL;\n}\n\nCookieManager::~CookieManager(void) {\n}\n\nvoid CookieManager::Initialize(HWND window_handle) {\n  LOG(TRACE) << \"Entering CookieManager::Initialize\";\n  this->window_handle_ = window_handle;\n}\n\nbool CookieManager::IsAdvancedCookiesApi() {\n  FARPROC address = NULL;\n  HMODULE wininet_handle = ::GetModuleHandle(L\"wininet\");\n  if (wininet_handle) {\n    address = ::GetProcAddress(wininet_handle, \"InternetGetCookieEx2\");\n  }\n  return address != NULL;\n}\n\nint CookieManager::SetCookie(const std::string& url, \n                             const BrowserCookie& cookie) {\n  std::string full_data = url + \"|\" + cookie.ToString();\n  WPARAM set_flags = 0;\n  if (cookie.is_httponly()) {\n    set_flags = INTERNET_COOKIE_HTTPONLY;\n  }\n\n  HookSettings hook_settings;\n  hook_settings.hook_procedure_name = \"CookieWndProc\";\n  hook_settings.hook_procedure_type = WH_CALLWNDPROC;\n  hook_settings.window_handle = this->window_handle_;\n  hook_settings.communication_type = OneWay;\n\n  HookProcessor hook;\n  if (!hook.CanSetWindowsHook(this->window_handle_)) {\n    LOG(WARN) << \"Cannot set cookie because driver and browser are not the \"\n              << \"same bit-ness.\";\n    return EUNHANDLEDERROR;\n  }\n  hook.Initialize(hook_settings);\n  hook.PushData(StringUtilities::ToWString(full_data));\n  ::SendMessage(this->window_handle_, WD_SET_COOKIE, set_flags, NULL);\n  int status = HookProcessor::GetDataBufferSize();\n  if (status != 0) {\n    LOG(WARN) << \"Setting cookie encountered error \" << status;\n    return EINVALIDCOOKIEDOMAIN;\n  }\n  return WD_SUCCESS;\n}\n\nint CookieManager::GetCookies(const std::string& url,\n                              std::vector<BrowserCookie>* all_cookies) {\n  LOG(TRACE) << \"Entering CookieManager::GetCookies\";\n  std::wstring wide_url = StringUtilities::ToWString(url);\n  CComPtr<IUri> parsed_url;\n  ::CreateUri(wide_url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &parsed_url);\n  DWORD url_scheme = 0;\n  parsed_url->GetScheme(&url_scheme);\n  bool is_secure_url = URL_SCHEME_HTTPS == url_scheme;\n\n  HookSettings hook_settings;\n  hook_settings.hook_procedure_name = \"CookieWndProc\";\n  hook_settings.hook_procedure_type = WH_CALLWNDPROC;\n  hook_settings.window_handle = this->window_handle_;\n  hook_settings.communication_type = TwoWay;\n\n  HookProcessor hook;\n  if (!hook.CanSetWindowsHook(this->window_handle_)) {\n    LOG(WARN) << \"Cannot get cookies because driver and browser are not the \"\n              << \"same bit-ness.\";\n    return EUNHANDLEDERROR;\n  }\n  hook.Initialize(hook_settings);\n\n  bool supports_advanced_api = this->IsAdvancedCookiesApi();\n  if (supports_advanced_api) {\n    // The version of WinINet installed supports the InternetGetCookieEx2\n    // API, which gets all cookies (session and persistent) at once.\n    std::wstring raw_cookie_data =\n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_ALL_COOKIES,\n                                   &hook);\n    std::string all_cookies_list = StringUtilities::ToString(raw_cookie_data);\n    std::map<std::string, BrowserCookie> cookies;\n    this->ParseCookieList(all_cookies_list,\n                          is_secure_url,\n                          &cookies);\n    std::map<std::string, BrowserCookie>::const_iterator cookie_iterator;\n    for (cookie_iterator = cookies.begin();\n         cookie_iterator != cookies.end();\n         ++cookie_iterator) {\n      all_cookies->push_back(cookie_iterator->second);\n    }\n  } else {\n    // Get all cookies for the current URL visible to JavaScript.\n    std::wstring scriptable_cookie_string = \n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_SCRIPTABLE_COOKIES,\n                                   &hook);\n    std::map<std::string, std::string> scriptable_cookies;\n    this->ParseCookieString(scriptable_cookie_string, &scriptable_cookies);\n\n    // Get all cookies for the insecure version of the current URL,\n    // which will include HttpOnly cookies.\n    std::wstring insecure_cookie_string = \n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_HTTPONLY_COOKIES,\n                                   &hook);\n    std::map<std::string, std::string> insecure_cookies;  \n    this->ParseCookieString(insecure_cookie_string, &insecure_cookies);\n\n    // Get all cookies for the current secure URL. This will include\n    // HttpOnly cookies.\n    std::wstring secure_cookie_string = \n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_SECURE_COOKIES,\n                                   &hook);\n    std::map<std::string, std::string> secure_cookies;  \n    this->ParseCookieString(secure_cookie_string, &secure_cookies);\n\n    // Get all of the persistent cookie files in the cache for the \n    // URL currently being browsed.\n    std::wstring file_list =\n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_COOKIE_CACHE_FILES,\n                                   &hook);\n    std::vector<std::wstring> files;\n    StringUtilities::Split(file_list, L\"|\", &files);\n\n    // Parse the persistent cookie files to produce a list of\n    // cookies.\n    std::map<std::string, BrowserCookie> persistent_cookies;\n    std::vector<std::wstring>::const_iterator file_iterator;\n    for (file_iterator = files.begin();\n         file_iterator != files.end();\n         ++file_iterator) {\n      std::string cookie_file_contents = this->ReadCookieFile(*file_iterator);\n      this->ParseCookieList(cookie_file_contents,\n                            is_secure_url,\n                            &persistent_cookies);\n    }\n\n    // Loop through the entire list of cookies, including HttpOnly and secure\n    // cookies. If the cookie exists as a persistent cookie, use its data from\n    // the cache. If the cookie is found in the list of cookies visible to \n    // JavaScript, set the HttpOnly property of the cookie to false. If the\n    // cookie is found in the list of cookies set on the insecure version of\n    // the URL, set the Secure property of the cookie to false.\n    std::map<std::string, std::string>::const_iterator it = secure_cookies.begin();\n    for (; it != secure_cookies.end(); ++it) {\n      BrowserCookie browser_cookie;\n      if (persistent_cookies.find(it->first) != persistent_cookies.end()) {\n        browser_cookie = persistent_cookies[it->first];\n      } else {\n        browser_cookie.set_name(it->first);\n        browser_cookie.set_value(it->second);\n        browser_cookie.set_is_httponly(scriptable_cookies.find(it->first) == scriptable_cookies.end());\n        browser_cookie.set_is_secure(insecure_cookies.find(it->first) == insecure_cookies.end());\n      }\n      all_cookies->push_back(browser_cookie);\n    }\n  }\n  return WD_SUCCESS;\n}\n\nbool CookieManager::DeleteCookie(const std::string& url,\n                                 const BrowserCookie& cookie) {\n  std::wstring wide_url = StringUtilities::ToWString(url);\n  CComPtr<IUri> uri_pointer;\n  ::CreateUri(wide_url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n\n  CComBSTR host_bstr;\n  uri_pointer->GetHost(&host_bstr);\n  std::wstring wide_domain = host_bstr;\n  \n  CComBSTR path_bstr;\n  uri_pointer->GetPath(&path_bstr);\n  std::wstring wide_path = path_bstr;\n\n  std::string domain = StringUtilities::ToString(wide_domain);\n  std::string path = StringUtilities::ToString(wide_path);\n\n  // N.B., We can hard-code the value and expiration time, since\n  // we are deleting the cookie. So the value will be \"deleted\",\n  // and the expiration time will be 1000 milliseconds after the\n  // zero date (or Thu 1 Jan 1970 00:00:01 GMT).\n  BrowserCookie recursive_cookie = cookie.Copy();\n  recursive_cookie.set_domain(domain);\n  recursive_cookie.set_path(path);\n  recursive_cookie.set_value(\"deleted\");\n  recursive_cookie.set_expiration_time(1000);\n  return this->RecursivelyDeleteCookie(url, recursive_cookie);\n}\n\nbool CookieManager::RecursivelyDeleteCookie(const std::string& url,\n                                            const BrowserCookie& cookie) {\n  // TODO: Optimize this path from the recursive to only\n  // call setting the cookie as often as needed.\n  BrowserCookie recursive_cookie = cookie.Copy();\n  recursive_cookie.set_domain(\".\" + cookie.domain());\n  return this->RecurseCookiePath(url, recursive_cookie);\n}\n\nbool CookieManager::RecurseCookiePath(const std::string& url,\n                                      const BrowserCookie& cookie) {\n  size_t number_of_characters = 0;\n  size_t slash_index = cookie.path().find_last_of('/');\n  size_t final_index = cookie.path().size() - 1;\n  if (slash_index == final_index) {\n    number_of_characters = slash_index;\n  }\n  else {\n    number_of_characters = slash_index + 1;\n  }\n\n  if (slash_index != std::string::npos) {\n    BrowserCookie path_cookie = cookie.Copy();\n    path_cookie.set_path(cookie.path().substr(0, number_of_characters));\n    bool deleted = this->RecurseCookiePath(url, path_cookie);\n  }\n  return this->RecurseCookieDomain(url, cookie);\n}\n\nbool CookieManager::RecurseCookieDomain(const std::string& url,\n                                        const BrowserCookie& cookie) {\n  int status = this->SetCookie(url, cookie);\n\n  size_t dot_index = cookie.domain().find_first_of('.');\n  if (dot_index == 0) {\n    BrowserCookie first_dot_cookie = cookie.Copy();\n    first_dot_cookie.set_domain(cookie.domain().substr(1));\n    return this->RecurseCookieDomain(url, first_dot_cookie);\n  } else if (dot_index != std::string::npos) {\n    BrowserCookie no_dot_cookie = cookie.Copy();\n    no_dot_cookie.set_domain(cookie.domain().substr(dot_index));\n    return this->RecurseCookieDomain(url, no_dot_cookie);\n  }\n\n  BrowserCookie no_domain_cookie = cookie.Copy();\n  no_domain_cookie.set_domain(\"\");\n  status = this->SetCookie(url, no_domain_cookie);\n  return status == WD_SUCCESS;\n}\n\nstd::string CookieManager::ReadCookieFile(const std::wstring& file_name) {\n  LOG(TRACE) << \"Entering CookieManager::ReadCookieFile\";\n  HANDLE file_handle = ::CreateFile(file_name.c_str(),\n                                    GENERIC_READ,\n                                    FILE_SHARE_READ | FILE_SHARE_WRITE,\n                                    NULL,\n                                    OPEN_EXISTING,\n                                    0,\n                                    NULL);\n  // Read the cookie file. Hopefully, we will never have a 2GB cookie file.\n  DWORD file_size_high = 0;\n  DWORD file_size_low = ::GetFileSize(file_handle, &file_size_high);\n  std::vector<char> file_content(file_size_low + 1);\n  DWORD bytes_read = 0;\n  ::ReadFile(file_handle, &file_content[0], file_size_low, &bytes_read, NULL);\n  ::CloseHandle(file_handle);\n\n  // Null-terminate and convert to a string for easier manipulation.\n  file_content[bytes_read - 1] = '\\0';\n  std::string cookie_file_contents = &file_content[0];\n  return cookie_file_contents;\n}\n\nvoid CookieManager::ParseCookieList(const std::string& cookie_file_contents,\n                                    const bool include_secure_cookies,\n                                    std::map<std::string, BrowserCookie>* cookies) {\n  LOG(TRACE) << \"Entering CookieManager::ParseCookieList\";\n\n  // Each cookie in the file is a record structure separated by\n  // a line containing a single asterisk ('*'). Split the file \n  // content on this delimiter, and parse each record.\n  std::vector<std::string> persistent_cookie_strings;\n  StringUtilities::Split(cookie_file_contents,\n                         \"\\n*\\n\",\n                         &persistent_cookie_strings);\n  std::vector<std::string>::const_iterator cookie_string_iterator;\n  for (cookie_string_iterator = persistent_cookie_strings.begin();\n       cookie_string_iterator != persistent_cookie_strings.end();\n       ++cookie_string_iterator) {\n    BrowserCookie persistent_cookie = \n        this->ParseSingleCookie(*cookie_string_iterator);\n    if (include_secure_cookies || !persistent_cookie.is_secure()) {\n      // Omit the cookie if it's 'secure' flag is set and we are *not*\n      // browsing using SSL.\n      cookies->insert(\n          std::pair<std::string, BrowserCookie>(persistent_cookie.name(),\n          persistent_cookie));\n    }\n  }\n}\n\nBrowserCookie CookieManager::ParseSingleCookie(const std::string& cookie) {\n  LOG(TRACE) << \"Entering CookieManager::ParsePersistentCookieInfo\";\n  // Cookies represented by a structured string record type.\n  // This structure is modeled after how some versions of IE\n  // stored perisitent cookeis as files on disk. Each cookie\n  // is represented by 8 lines in the file separated by line\n  // feed (0xA) characters, with the following format:\n  //\n  //     cookie_name\n  //     cookie_value\n  //     cookie.domain.value/cookie/path/value/\n  //     <integer representing cookie flags>\n  //     <unsigned long representing the low 32 bits of expiration time>\n  //     <unsigned long representing the high 32 bits of expiration time>\n  //     <unsigned long representing the low 32 bits of last-modified time>\n  //     <unsigned long representing the high 32 bits of last-modified time>\n  //\n  // Read each of these lines and set the appropriate values\n  // in the resulting cookie object.\n  std::vector<std::string> cookie_parts;\n  StringUtilities::Split(cookie, \"\\n\", &cookie_parts);\n\n  BrowserCookie cookie_to_return;\n  cookie_to_return.set_name(cookie_parts[0]);\n  cookie_to_return.set_value(cookie_parts[1]);\n\n  size_t position = cookie_parts[2].find_first_of(\"/\");\n  cookie_to_return.set_domain(cookie_parts[2].substr(0, position));\n  cookie_to_return.set_path(cookie_parts[2].substr(position));\n\n  int flags = atoi(cookie_parts[3].c_str());\n  cookie_to_return.set_is_secure(INTERNET_COOKIE_IS_SECURE == (INTERNET_COOKIE_IS_SECURE & flags));\n  cookie_to_return.set_is_httponly(INTERNET_COOKIE_HTTPONLY == (INTERNET_COOKIE_HTTPONLY & flags));\n\n  if (cookie_parts[4].size() > 0 && cookie_parts[5].size() > 0) {\n    unsigned long expiry_time_low = strtoul(cookie_parts[4].c_str(), NULL, 10);\n    unsigned long expiry_time_high = strtoul(cookie_parts[5].c_str(), NULL, 10);\n    unsigned long long expiration_time = (expiry_time_high * static_cast<long long>(pow(2.0, 32))) + expiry_time_low;\n\n    // Cookie expiration time is stored in the file as the number\n    // of 100-nanosecond ticks since 1 January 1601 12:00:00 AM GMT.\n    // We need the number of seconds since 1 January 1970 12:00:00 AM GMT.\n    // This is the conversion.\n    unsigned long cookie_expiration_time = static_cast<unsigned long>((expiration_time / TICKS_PER_SECOND) - UNIX_TIME_OFFSET_SECONDS);\n    cookie_to_return.set_expiration_time(cookie_expiration_time);\n  }\n  return cookie_to_return;\n}\n\nvoid CookieManager::ParseCookieString(const std::wstring& cookie_string,\n                                      std::map<std::string, std::string>* cookies) {\n  LOG(TRACE) << \"Entering CookieManager::ParseCookieString\";\n  std::wstring cookie_string_copy = cookie_string;\n  while (cookie_string_copy.size() > 0) {\n    size_t cookie_delimiter_pos = cookie_string_copy.find(L\"; \");\n    std::wstring cookie = cookie_string_copy.substr(0, cookie_delimiter_pos);\n    if (cookie_delimiter_pos == std::wstring::npos) {\n      cookie_string_copy = L\"\";\n    } else {\n      cookie_string_copy = cookie_string_copy.substr(cookie_delimiter_pos + 2);\n    }\n    size_t cookie_separator_pos(cookie.find_first_of(L\"=\"));\n    std::string cookie_name(StringUtilities::ToString(cookie.substr(0, cookie_separator_pos)));\n    std::string cookie_value(StringUtilities::ToString(cookie.substr(cookie_separator_pos + 1)));\n    cookies->insert(std::pair<std::string, std::string>(cookie_name, cookie_value));\n  }\n}\n\nstd::wstring CookieManager::SendGetCookieMessage(const std::wstring& url, \n                                                 const unsigned int message,\n                                                 HookProcessor* hook) {\n  LOG(TRACE) << \"Entering CookieManager::SendGetCookieMessage\";\n  hook->PushData(url);\n\n  // Since the named pipe server has to wait for the named pipe client\n  // injected into the browser to connect to it before reading the data,\n  // and since SendMessage is synchronous, we need to send the message\n  // from a different thread to avoid a deadlock.\n  CookieSendMessageInfo info;\n  info.window_handle = this->window_handle_;\n  info.message = message;\n  unsigned int thread_id = 0;\n  HANDLE thread_handle = reinterpret_cast<HANDLE>(_beginthreadex(NULL,\n                                                  0,\n                                                  &CookieManager::ThreadProc,\n                                                  reinterpret_cast<void*>(&info),\n                                                  0,\n                                                  &thread_id));\n  if (thread_handle != NULL) {\n    ::CloseHandle(thread_handle);\n  } else {\n    LOGERR(DEBUG) << \"Unable to create thread\";\n  }\n  std::vector<char> buffer(0);\n  int bytes = hook->PullData(&buffer);\n  std::wstring cookies = reinterpret_cast<const wchar_t*>(&buffer[0]);\n  return cookies;\n}\n\nunsigned int WINAPI CookieManager::ThreadProc(LPVOID lpParameter) {\n  LOG(TRACE) << \"Entering CookieManager::ThreadProc\";\n\n  CookieSendMessageInfo* info = reinterpret_cast<CookieSendMessageInfo*>(lpParameter);\n  DWORD process_id = ::GetCurrentProcessId();\n  LRESULT result = ::SendMessage(info->window_handle,\n                                 info->message,\n                                 process_id,\n                                 NULL);\n  return 0;\n}\n\n} // namespace webdriver\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// In order to run the IE driver against versions of IE that do not include\n// a version of WinINet.dll that supports the InternetGetCookiesEx2 API,\n// we must access the API in a way that does not import it into our DLL.\n// To that end, we duplicate the INTERNET_COOKIE2 structure here, and will\n// call the API (if it exists) via GetModuleHandle and GetProcAddress.\ntypedef struct {\n  PWSTR pwszName;\n  PWSTR pwszValue;\n  PWSTR pwszDomain;\n  PWSTR pwszPath;\n  DWORD dwFlags;\n  FILETIME ftExpires;\n  BOOL fExpiresSet;\n} INTERNETCOOKIE2;\n\ntypedef void* (__stdcall *InternetFreeCookiesProc)(INTERNETCOOKIE2*, DWORD);\ntypedef DWORD(__stdcall *InternetGetCookieEx2Proc)(PCWSTR, PCWSTR, DWORD, INTERNETCOOKIE2**, PDWORD);\n\nLRESULT CALLBACK CookieWndProc(int nCode, WPARAM wParam, LPARAM lParam) {\n  CWPSTRUCT* call_window_proc_struct = reinterpret_cast<CWPSTRUCT*>(lParam);\n  if (WM_COPYDATA == call_window_proc_struct->message) {\n    COPYDATASTRUCT* data = reinterpret_cast<COPYDATASTRUCT*>(call_window_proc_struct->lParam);\n    webdriver::HookProcessor::CopyDataToBuffer(data->cbData, data->lpData);\n  } else if (WD_GET_ALL_COOKIES == call_window_proc_struct->message) {\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    DWORD scheme = 0;\n    uri_pointer->GetScheme(&scheme);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n    \n    std::wstring parsed_uri = scheme_bstr;\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n    parsed_uri.append(path_bstr);\n\n    InternetGetCookieEx2Proc get_cookie_proc = NULL;\n    InternetFreeCookiesProc free_cookies_proc = NULL;\n    HMODULE wininet_handle = ::GetModuleHandle(L\"wininet\");\n    if (wininet_handle) {\n      get_cookie_proc = reinterpret_cast<InternetGetCookieEx2Proc>(::GetProcAddress(wininet_handle, \"InternetGetCookieEx2\"));\n      free_cookies_proc = reinterpret_cast<InternetFreeCookiesProc>(::GetProcAddress(wininet_handle, \"InternetFreeCookies\"));\n    }\n\n    DWORD cookie_count = 0;\n    INTERNETCOOKIE2* cookie_pointer = NULL;\n    DWORD success = 1;\n    if (get_cookie_proc) {\n      success = get_cookie_proc(parsed_uri.c_str(),\n                                NULL,\n                                INTERNET_COOKIE_NON_SCRIPT,\n                                &cookie_pointer,\n                                &cookie_count);\n    }\n\n    if (success == 0) {\n      // Mimic the format of the old persistent cookie files for ease of\n      // transmission back to the driver and parsing.\n      std::wstring all_cookies = L\"\";\n      for (DWORD cookie_index = 0; cookie_index < cookie_count; ++cookie_index) {\n        if (all_cookies.size() > 0) {\n          all_cookies.append(L\"\\n*\\n\");\n        }\n        INTERNETCOOKIE2* current_cookie = cookie_pointer + cookie_index;\n        std::wstring cookie_name = current_cookie->pwszName;\n        std::wstring cookie_value = L\"\";\n        if (current_cookie->pwszValue) {\n          cookie_value = current_cookie->pwszValue;\n        }\n        std::wstring cookie_domain = L\"\";\n        if (current_cookie->pwszDomain) {\n          cookie_domain = current_cookie->pwszDomain;\n        }\n        std::wstring cookie_path = L\"\";\n        if (current_cookie->pwszPath) {\n          cookie_path = current_cookie->pwszPath;\n        }\n        DWORD flags = current_cookie->dwFlags;\n        FILETIME expires = current_cookie->ftExpires;\n        all_cookies.append(cookie_name).append(L\"\\n\");\n        all_cookies.append(cookie_value).append(L\"\\n\");\n        all_cookies.append(cookie_domain).append(L\"/\").append(cookie_path).append(L\"\\n\");\n        all_cookies.append(std::to_wstring(flags)).append(L\"\\n\");\n        // If the expiration time is set, add it to the string for the cookie.\n        // If not, append empty fields to the record so subsequent parsing\n        // of the string will still work.\n        if (current_cookie->fExpiresSet) {\n          all_cookies.append(std::to_wstring(expires.dwLowDateTime)).append(L\"\\n\");\n          all_cookies.append(std::to_wstring(expires.dwHighDateTime)).append(L\"\\n\");\n        } else {\n          all_cookies.append(L\"\\n\\n\");\n        }\n      }\n      free_cookies_proc(cookie_pointer, cookie_count);\n      webdriver::HookProcessor::CopyWStringToBuffer(all_cookies);\n    } else {\n      webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));\n    }\n    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n  } else if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||\n             WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message ||\n             WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n\n    DWORD get_cookie_flags = 0;\n    if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||\n      WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {\n      get_cookie_flags = INTERNET_COOKIE_HTTPONLY;\n    }\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    DWORD scheme = 0;\n    uri_pointer->GetScheme(&scheme);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n\n    // Get only the cookies for the base URL, omitting port, if there is one.\n    // N.B., we only return cookies secure cookies when browsing a site using\n    // SSL. The browser won't see cookies with the 'secure' flag for sites\n    // visited using plain http.\n    std::wstring parsed_uri = L\"http\";\n    if ((WD_GET_SECURE_COOKIES == call_window_proc_struct->message ||\n         WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message) &&\n        URL_SCHEME_HTTPS == scheme) {\n      parsed_uri.append(L\"s\");\n    }\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n    parsed_uri.append(path_bstr);\n\n    // Call InternetGetCookieEx once to get the size of the buffer needed,\n    // then call again with the appropriately sized buffer allocated.\n    DWORD buffer_size = 0;\n    BOOL success = ::InternetGetCookieEx(parsed_uri.c_str(),\n                                         NULL,\n                                         NULL,\n                                         &buffer_size,\n                                         get_cookie_flags,\n                                         NULL);\n    if (success) {\n      webdriver::HookProcessor::SetDataBufferSize(buffer_size);\n      ::InternetGetCookieEx(parsed_uri.c_str(),\n                            NULL,\n                            reinterpret_cast<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),\n                            &buffer_size,\n                            get_cookie_flags,\n                            NULL);\n\n      webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n    } else {\n      if (ERROR_NO_MORE_ITEMS == ::GetLastError()) {\n        webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));\n        webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n      }\n    }\n  } else if (WD_GET_COOKIE_CACHE_FILES == call_window_proc_struct->message) {\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n    std::wstring file_list = L\"\";\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n\n    // We need to remove the port to find the entry in the cache.\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n    std::wstring parsed_uri = host_bstr;\n    parsed_uri.append(path_bstr);\n\n    // A 2048-byte buffer should be large enough to handle cookie\n    // cache entries in all but the most extreme cases.\n    HANDLE cache_enum_handle = NULL;\n    DWORD entry_size = 2048;\n    LPINTERNET_CACHE_ENTRY_INFO entry = NULL;\n    std::vector<char> entry_buffer(entry_size);\n    entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);\n    cache_enum_handle = ::FindFirstUrlCacheEntry(L\"cookie:\",\n                                                 entry,\n                                                 &entry_size);\n    if (cache_enum_handle == NULL &&\n        ERROR_INSUFFICIENT_BUFFER == ::GetLastError()) {\n      entry_buffer.resize(entry_size);\n      entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);\n      cache_enum_handle = ::FindFirstUrlCacheEntry(L\"cookie:\",\n                                                   entry,\n                                                   &entry_size);\n    }\n    while (cache_enum_handle != NULL) {\n      if (COOKIE_CACHE_ENTRY == (entry->CacheEntryType & COOKIE_CACHE_ENTRY)) {\n        std::wstring name = entry->lpszSourceUrlName;\n        size_t name_separator_pos(name.find_first_of(L\"@\"));\n        std::wstring domain = name.substr(name_separator_pos + 1);\n        if (parsed_uri.find(domain) != std::wstring::npos) {\n          if (file_list.size() > 0) {\n            file_list.append(L\"|\");\n          }\n          file_list.append(entry->lpszLocalFileName);\n        }\n      }\n      BOOL success = ::FindNextUrlCacheEntry(cache_enum_handle,\n                                             entry,\n                                             &entry_size);\n      if (!success) {\n        DWORD error = ::GetLastError();\n        if (ERROR_INSUFFICIENT_BUFFER == error) {\n          entry_buffer.resize(entry_size);\n          BOOL other_success = ::FindNextUrlCacheEntry(cache_enum_handle,\n                                                       entry,\n                                                       &entry_size);\n        } else if (ERROR_NO_MORE_ITEMS == error) {\n          ::FindCloseUrlCache(cache_enum_handle);\n          cache_enum_handle = NULL;\n        }\n      }\n    }\n    webdriver::HookProcessor::CopyWStringToBuffer(file_list);\n    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n  } else if (WD_SET_COOKIE == call_window_proc_struct->message) {\n    DWORD set_cookie_flags = static_cast<DWORD>(call_window_proc_struct->wParam);\n    std::wstring cookie_data = webdriver::HookProcessor::CopyWStringFromBuffer();\n    size_t url_separator_pos = cookie_data.find_first_of(L\"|\");\n    std::wstring url = cookie_data.substr(0, url_separator_pos);\n    std::wstring cookie = cookie_data.substr(url_separator_pos + 1);\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    std::wstring parsed_uri = scheme_bstr;\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n\n    // Leverage the shared data buffer size to return the error code\n    // back to the driver, if necessary.\n    DWORD cookie_set = ::InternetSetCookieEx(parsed_uri.c_str(),\n                                             NULL,\n                                             cookie.c_str(),\n                                             set_cookie_flags,\n                                             NULL);\n    if (cookie_set) {\n      webdriver::HookProcessor::SetDataBufferSize(0);\n    } else {\n      DWORD error = ::GetLastError();\n      webdriver::HookProcessor::SetDataBufferSize(error);\n    }\n  }\n  return ::CallNextHookEx(NULL, nCode, wParam, lParam);\n}\n\n#ifdef __cplusplus\n}\n#endif\n"], "fixing_code": ["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements. See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership. The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"CookieManager.h\"\n\n#include <UrlMon.h>\n#include <wininet.h>\n\n#include \"errorcodes.h\"\n#include \"logging.h\"\n\n#include \"BrowserCookie.h\"\n#include \"HookProcessor.h\"\n#include \"messages.h\"\n#include \"StringUtilities.h\"\n\n#define TICKS_PER_SECOND 10000000\n#define UNIX_TIME_OFFSET_SECONDS 11644473600L\n\nnamespace webdriver {\n\nstruct CookieSendMessageInfo {\n  HWND window_handle;\n  unsigned int message;\n};\n\nCookieManager::CookieManager(void) {\n  this->window_handle_ = NULL;\n}\n\nCookieManager::~CookieManager(void) {\n}\n\nvoid CookieManager::Initialize(HWND window_handle) {\n  LOG(TRACE) << \"Entering CookieManager::Initialize\";\n  this->window_handle_ = window_handle;\n}\n\nbool CookieManager::IsAdvancedCookiesApi() {\n  FARPROC address = NULL;\n  HMODULE wininet_handle = ::GetModuleHandle(L\"wininet\");\n  if (wininet_handle) {\n    address = ::GetProcAddress(wininet_handle, \"InternetGetCookieEx2\");\n  }\n  return address != NULL;\n}\n\nint CookieManager::SetCookie(const std::string& url, \n                             const BrowserCookie& cookie) {\n  std::string full_data = url + \"|\" + cookie.ToString();\n  WPARAM set_flags = 0;\n  if (cookie.is_httponly()) {\n    set_flags = INTERNET_COOKIE_HTTPONLY;\n  }\n\n  HookSettings hook_settings;\n  hook_settings.hook_procedure_name = \"CookieWndProc\";\n  hook_settings.hook_procedure_type = WH_CALLWNDPROC;\n  hook_settings.window_handle = this->window_handle_;\n  hook_settings.communication_type = OneWay;\n\n  HookProcessor hook;\n  if (!hook.CanSetWindowsHook(this->window_handle_)) {\n    LOG(WARN) << \"Cannot set cookie because driver and browser are not the \"\n              << \"same bit-ness.\";\n    return EUNHANDLEDERROR;\n  }\n  hook.Initialize(hook_settings);\n  hook.PushData(StringUtilities::ToWString(full_data));\n  ::SendMessage(this->window_handle_, WD_SET_COOKIE, set_flags, NULL);\n  int status = HookProcessor::GetDataBufferSize();\n  if (status != 0) {\n    LOG(WARN) << \"Setting cookie encountered error \" << status;\n    return EINVALIDCOOKIEDOMAIN;\n  }\n  return WD_SUCCESS;\n}\n\nint CookieManager::GetCookies(const std::string& url,\n                              std::vector<BrowserCookie>* all_cookies) {\n  LOG(TRACE) << \"Entering CookieManager::GetCookies\";\n  std::wstring wide_url = StringUtilities::ToWString(url);\n  CComPtr<IUri> parsed_url;\n  ::CreateUri(wide_url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &parsed_url);\n  DWORD url_scheme = 0;\n  parsed_url->GetScheme(&url_scheme);\n  bool is_secure_url = URL_SCHEME_HTTPS == url_scheme;\n\n  HookSettings hook_settings;\n  hook_settings.hook_procedure_name = \"CookieWndProc\";\n  hook_settings.hook_procedure_type = WH_CALLWNDPROC;\n  hook_settings.window_handle = this->window_handle_;\n  hook_settings.communication_type = TwoWay;\n\n  HookProcessor hook;\n  if (!hook.CanSetWindowsHook(this->window_handle_)) {\n    LOG(WARN) << \"Cannot get cookies because driver and browser are not the \"\n              << \"same bit-ness.\";\n    return EUNHANDLEDERROR;\n  }\n  hook.Initialize(hook_settings);\n\n  bool supports_advanced_api = this->IsAdvancedCookiesApi();\n  if (supports_advanced_api) {\n    // The version of WinINet installed supports the InternetGetCookieEx2\n    // API, which gets all cookies (session and persistent) at once.\n    std::wstring raw_cookie_data =\n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_ALL_COOKIES,\n                                   &hook);\n    std::string all_cookies_list = StringUtilities::ToString(raw_cookie_data);\n    std::map<std::string, BrowserCookie> cookies;\n    this->ParseCookieList(all_cookies_list,\n                          is_secure_url,\n                          &cookies);\n    std::map<std::string, BrowserCookie>::const_iterator cookie_iterator;\n    for (cookie_iterator = cookies.begin();\n         cookie_iterator != cookies.end();\n         ++cookie_iterator) {\n      all_cookies->push_back(cookie_iterator->second);\n    }\n  } else {\n    // Get all cookies for the current URL visible to JavaScript.\n    std::wstring scriptable_cookie_string = \n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_SCRIPTABLE_COOKIES,\n                                   &hook);\n    std::map<std::string, std::string> scriptable_cookies;\n    this->ParseCookieString(scriptable_cookie_string, &scriptable_cookies);\n\n    // Get all cookies for the insecure version of the current URL,\n    // which will include HttpOnly cookies.\n    std::wstring insecure_cookie_string = \n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_HTTPONLY_COOKIES,\n                                   &hook);\n    std::map<std::string, std::string> insecure_cookies;  \n    this->ParseCookieString(insecure_cookie_string, &insecure_cookies);\n\n    // Get all cookies for the current secure URL. This will include\n    // HttpOnly cookies.\n    std::wstring secure_cookie_string = \n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_SECURE_COOKIES,\n                                   &hook);\n    std::map<std::string, std::string> secure_cookies;  \n    this->ParseCookieString(secure_cookie_string, &secure_cookies);\n\n    // Get all of the persistent cookie files in the cache for the \n    // URL currently being browsed.\n    std::wstring file_list =\n        this->SendGetCookieMessage(wide_url,\n                                   WD_GET_COOKIE_CACHE_FILES,\n                                   &hook);\n    std::vector<std::wstring> files;\n    StringUtilities::Split(file_list, L\"|\", &files);\n\n    // Parse the persistent cookie files to produce a list of\n    // cookies.\n    std::map<std::string, BrowserCookie> persistent_cookies;\n    std::vector<std::wstring>::const_iterator file_iterator;\n    for (file_iterator = files.begin();\n         file_iterator != files.end();\n         ++file_iterator) {\n      std::string cookie_file_contents = this->ReadCookieFile(*file_iterator);\n      this->ParseCookieList(cookie_file_contents,\n                            is_secure_url,\n                            &persistent_cookies);\n    }\n\n    // Loop through the entire list of cookies, including HttpOnly and secure\n    // cookies. If the cookie exists as a persistent cookie, use its data from\n    // the cache. If the cookie is found in the list of cookies visible to \n    // JavaScript, set the HttpOnly property of the cookie to false. If the\n    // cookie is found in the list of cookies set on the insecure version of\n    // the URL, set the Secure property of the cookie to false.\n    std::map<std::string, std::string>::const_iterator it = secure_cookies.begin();\n    for (; it != secure_cookies.end(); ++it) {\n      BrowserCookie browser_cookie;\n      if (persistent_cookies.find(it->first) != persistent_cookies.end()) {\n        browser_cookie = persistent_cookies[it->first];\n      } else {\n        browser_cookie.set_name(it->first);\n        browser_cookie.set_value(it->second);\n        browser_cookie.set_is_httponly(scriptable_cookies.find(it->first) == scriptable_cookies.end());\n        browser_cookie.set_is_secure(insecure_cookies.find(it->first) == insecure_cookies.end());\n      }\n      all_cookies->push_back(browser_cookie);\n    }\n  }\n  return WD_SUCCESS;\n}\n\nbool CookieManager::DeleteCookie(const std::string& url,\n                                 const BrowserCookie& cookie) {\n  std::wstring wide_url = StringUtilities::ToWString(url);\n  CComPtr<IUri> uri_pointer;\n  ::CreateUri(wide_url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n\n  CComBSTR host_bstr;\n  uri_pointer->GetHost(&host_bstr);\n  std::wstring wide_domain = host_bstr;\n  \n  CComBSTR path_bstr;\n  uri_pointer->GetPath(&path_bstr);\n  std::wstring wide_path = path_bstr;\n\n  std::string domain = StringUtilities::ToString(wide_domain);\n  std::string path = StringUtilities::ToString(wide_path);\n\n  // N.B., We can hard-code the value and expiration time, since\n  // we are deleting the cookie. So the value will be \"deleted\",\n  // and the expiration time will be 1000 milliseconds after the\n  // zero date (or Thu 1 Jan 1970 00:00:01 GMT).\n  BrowserCookie recursive_cookie = cookie.Copy();\n  recursive_cookie.set_domain(domain);\n  recursive_cookie.set_path(path);\n  recursive_cookie.set_value(\"deleted\");\n  recursive_cookie.set_expiration_time(1000);\n  return this->RecursivelyDeleteCookie(url, recursive_cookie);\n}\n\nbool CookieManager::RecursivelyDeleteCookie(const std::string& url,\n                                            const BrowserCookie& cookie) {\n  // TODO: Optimize this path from the recursive to only\n  // call setting the cookie as often as needed.\n  BrowserCookie recursive_cookie = cookie.Copy();\n  recursive_cookie.set_domain(\".\" + cookie.domain());\n  return this->RecurseCookiePath(url, recursive_cookie);\n}\n\nbool CookieManager::RecurseCookiePath(const std::string& url,\n                                      const BrowserCookie& cookie) {\n  size_t number_of_characters = 0;\n  size_t slash_index = cookie.path().find_last_of('/');\n  size_t final_index = cookie.path().size() - 1;\n  if (slash_index == final_index) {\n    number_of_characters = slash_index;\n  }\n  else {\n    number_of_characters = slash_index + 1;\n  }\n\n  if (slash_index != std::string::npos) {\n    BrowserCookie path_cookie = cookie.Copy();\n    path_cookie.set_path(cookie.path().substr(0, number_of_characters));\n    bool deleted = this->RecurseCookiePath(url, path_cookie);\n  }\n  return this->RecurseCookieDomain(url, cookie);\n}\n\nbool CookieManager::RecurseCookieDomain(const std::string& url,\n                                        const BrowserCookie& cookie) {\n  int status = this->SetCookie(url, cookie);\n\n  size_t dot_index = cookie.domain().find_first_of('.');\n  if (dot_index == 0) {\n    BrowserCookie first_dot_cookie = cookie.Copy();\n    first_dot_cookie.set_domain(cookie.domain().substr(1));\n    return this->RecurseCookieDomain(url, first_dot_cookie);\n  } else if (dot_index != std::string::npos) {\n    BrowserCookie no_dot_cookie = cookie.Copy();\n    no_dot_cookie.set_domain(cookie.domain().substr(dot_index));\n    return this->RecurseCookieDomain(url, no_dot_cookie);\n  }\n\n  BrowserCookie no_domain_cookie = cookie.Copy();\n  no_domain_cookie.set_domain(\"\");\n  status = this->SetCookie(url, no_domain_cookie);\n  return status == WD_SUCCESS;\n}\n\nstd::string CookieManager::ReadCookieFile(const std::wstring& file_name) {\n  LOG(TRACE) << \"Entering CookieManager::ReadCookieFile\";\n  HANDLE file_handle = ::CreateFile(file_name.c_str(),\n                                    GENERIC_READ,\n                                    FILE_SHARE_READ | FILE_SHARE_WRITE,\n                                    NULL,\n                                    OPEN_EXISTING,\n                                    0,\n                                    NULL);\n  // Read the cookie file. Hopefully, we will never have a 2GB cookie file.\n  DWORD file_size_high = 0;\n  DWORD file_size_low = ::GetFileSize(file_handle, &file_size_high);\n  std::vector<char> file_content(file_size_low + 1);\n  DWORD bytes_read = 0;\n  ::ReadFile(file_handle, &file_content[0], file_size_low, &bytes_read, NULL);\n  ::CloseHandle(file_handle);\n\n  // Null-terminate and convert to a string for easier manipulation.\n  file_content[bytes_read - 1] = '\\0';\n  std::string cookie_file_contents = &file_content[0];\n  return cookie_file_contents;\n}\n\nvoid CookieManager::ParseCookieList(const std::string& cookie_file_contents,\n                                    const bool include_secure_cookies,\n                                    std::map<std::string, BrowserCookie>* cookies) {\n  LOG(TRACE) << \"Entering CookieManager::ParseCookieList\";\n\n  // Each cookie in the file is a record structure separated by\n  // a line containing a single asterisk ('*'). Split the file \n  // content on this delimiter, and parse each record.\n  std::vector<std::string> persistent_cookie_strings;\n  StringUtilities::Split(cookie_file_contents,\n                         \"\\n*\\n\",\n                         &persistent_cookie_strings);\n  std::vector<std::string>::const_iterator cookie_string_iterator;\n  for (cookie_string_iterator = persistent_cookie_strings.begin();\n       cookie_string_iterator != persistent_cookie_strings.end();\n       ++cookie_string_iterator) {\n    BrowserCookie persistent_cookie = \n        this->ParseSingleCookie(*cookie_string_iterator);\n    if (include_secure_cookies || !persistent_cookie.is_secure()) {\n      // Omit the cookie if it's 'secure' flag is set and we are *not*\n      // browsing using SSL.\n      cookies->insert(\n          std::pair<std::string, BrowserCookie>(persistent_cookie.name(),\n          persistent_cookie));\n    }\n  }\n}\n\nBrowserCookie CookieManager::ParseSingleCookie(const std::string& cookie) {\n  LOG(TRACE) << \"Entering CookieManager::ParsePersistentCookieInfo\";\n  // Cookies represented by a structured string record type.\n  // This structure is modeled after how some versions of IE\n  // stored perisitent cookeis as files on disk. Each cookie\n  // is represented by 8 lines in the file separated by line\n  // feed (0xA) characters, with the following format:\n  //\n  //     cookie_name\n  //     cookie_value\n  //     cookie.domain.value/cookie/path/value/\n  //     <integer representing cookie flags>\n  //     <unsigned long representing the low 32 bits of expiration time>\n  //     <unsigned long representing the high 32 bits of expiration time>\n  //     <unsigned long representing the low 32 bits of last-modified time>\n  //     <unsigned long representing the high 32 bits of last-modified time>\n  //\n  // Read each of these lines and set the appropriate values\n  // in the resulting cookie object.\n  std::vector<std::string> cookie_parts;\n  StringUtilities::Split(cookie, \"\\n\", &cookie_parts);\n\n  BrowserCookie cookie_to_return;\n  cookie_to_return.set_name(cookie_parts[0]);\n  cookie_to_return.set_value(cookie_parts[1]);\n\n  size_t position = cookie_parts[2].find_first_of(\"/\");\n  cookie_to_return.set_domain(cookie_parts[2].substr(0, position));\n  cookie_to_return.set_path(cookie_parts[2].substr(position));\n\n  int flags = atoi(cookie_parts[3].c_str());\n  cookie_to_return.set_is_secure(INTERNET_COOKIE_IS_SECURE == (INTERNET_COOKIE_IS_SECURE & flags));\n  cookie_to_return.set_is_httponly(INTERNET_COOKIE_HTTPONLY == (INTERNET_COOKIE_HTTPONLY & flags));\n\n  if (cookie_parts[4].size() > 0 && cookie_parts[5].size() > 0) {\n    unsigned long expiry_time_low = strtoul(cookie_parts[4].c_str(), NULL, 10);\n    unsigned long expiry_time_high = strtoul(cookie_parts[5].c_str(), NULL, 10);\n    unsigned long long expiration_time = (expiry_time_high * static_cast<long long>(pow(2.0, 32))) + expiry_time_low;\n\n    // Cookie expiration time is stored in the file as the number\n    // of 100-nanosecond ticks since 1 January 1601 12:00:00 AM GMT.\n    // We need the number of seconds since 1 January 1970 12:00:00 AM GMT.\n    // This is the conversion.\n    unsigned long cookie_expiration_time = static_cast<unsigned long>((expiration_time / TICKS_PER_SECOND) - UNIX_TIME_OFFSET_SECONDS);\n    cookie_to_return.set_expiration_time(cookie_expiration_time);\n  }\n  return cookie_to_return;\n}\n\nvoid CookieManager::ParseCookieString(const std::wstring& cookie_string,\n                                      std::map<std::string, std::string>* cookies) {\n  LOG(TRACE) << \"Entering CookieManager::ParseCookieString\";\n  std::wstring cookie_string_copy = cookie_string;\n  while (cookie_string_copy.size() > 0) {\n    size_t cookie_delimiter_pos = cookie_string_copy.find(L\"; \");\n    std::wstring cookie = cookie_string_copy.substr(0, cookie_delimiter_pos);\n    if (cookie_delimiter_pos == std::wstring::npos) {\n      cookie_string_copy = L\"\";\n    } else {\n      cookie_string_copy = cookie_string_copy.substr(cookie_delimiter_pos + 2);\n    }\n    size_t cookie_separator_pos(cookie.find_first_of(L\"=\"));\n    std::string cookie_name(StringUtilities::ToString(cookie.substr(0, cookie_separator_pos)));\n    std::string cookie_value(StringUtilities::ToString(cookie.substr(cookie_separator_pos + 1)));\n    cookies->insert(std::pair<std::string, std::string>(cookie_name, cookie_value));\n  }\n}\n\nstd::wstring CookieManager::SendGetCookieMessage(const std::wstring& url, \n                                                 const unsigned int message,\n                                                 HookProcessor* hook) {\n  LOG(TRACE) << \"Entering CookieManager::SendGetCookieMessage\";\n  hook->PushData(url);\n\n  // Since the named pipe server has to wait for the named pipe client\n  // injected into the browser to connect to it before reading the data,\n  // and since SendMessage is synchronous, we need to send the message\n  // from a different thread to avoid a deadlock.\n  CookieSendMessageInfo info;\n  info.window_handle = this->window_handle_;\n  info.message = message;\n  unsigned int thread_id = 0;\n  HANDLE thread_handle = reinterpret_cast<HANDLE>(_beginthreadex(NULL,\n                                                  0,\n                                                  &CookieManager::ThreadProc,\n                                                  reinterpret_cast<void*>(&info),\n                                                  0,\n                                                  &thread_id));\n  if (thread_handle != NULL) {\n    ::CloseHandle(thread_handle);\n  } else {\n    LOGERR(DEBUG) << \"Unable to create thread\";\n  }\n  std::vector<char> buffer(0);\n  int bytes = hook->PullData(&buffer);\n  std::wstring cookies = reinterpret_cast<const wchar_t*>(&buffer[0]);\n  return cookies;\n}\n\nunsigned int WINAPI CookieManager::ThreadProc(LPVOID lpParameter) {\n  LOG(TRACE) << \"Entering CookieManager::ThreadProc\";\n\n  CookieSendMessageInfo* info = reinterpret_cast<CookieSendMessageInfo*>(lpParameter);\n  DWORD process_id = ::GetCurrentProcessId();\n  LRESULT result = ::SendMessage(info->window_handle,\n                                 info->message,\n                                 process_id,\n                                 NULL);\n  return 0;\n}\n\n} // namespace webdriver\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// In order to run the IE driver against versions of IE that do not include\n// a version of WinINet.dll that supports the InternetGetCookiesEx2 API,\n// we must access the API in a way that does not import it into our DLL.\n// To that end, we duplicate the INTERNET_COOKIE2 structure here, and will\n// call the API (if it exists) via GetModuleHandle and GetProcAddress.\ntypedef struct {\n  PWSTR pwszName;\n  PWSTR pwszValue;\n  PWSTR pwszDomain;\n  PWSTR pwszPath;\n  DWORD dwFlags;\n  FILETIME ftExpires;\n  BOOL fExpiresSet;\n} INTERNETCOOKIE2;\n\ntypedef void* (__stdcall *InternetFreeCookiesProc)(INTERNETCOOKIE2*, DWORD);\ntypedef DWORD(__stdcall *InternetGetCookieEx2Proc)(PCWSTR, PCWSTR, DWORD, INTERNETCOOKIE2**, PDWORD);\n\nLRESULT CALLBACK CookieWndProc(int nCode, WPARAM wParam, LPARAM lParam) {\n  CWPSTRUCT* call_window_proc_struct = reinterpret_cast<CWPSTRUCT*>(lParam);\n  if (WM_COPYDATA == call_window_proc_struct->message) {\n    COPYDATASTRUCT* data = reinterpret_cast<COPYDATASTRUCT*>(call_window_proc_struct->lParam);\n    webdriver::HookProcessor::CopyDataToBuffer(data->cbData, data->lpData);\n  } else if (WD_GET_ALL_COOKIES == call_window_proc_struct->message) {\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    DWORD scheme = 0;\n    uri_pointer->GetScheme(&scheme);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n    \n    std::wstring parsed_uri = scheme_bstr;\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n    parsed_uri.append(path_bstr);\n\n    InternetGetCookieEx2Proc get_cookie_proc = NULL;\n    InternetFreeCookiesProc free_cookies_proc = NULL;\n    HMODULE wininet_handle = ::GetModuleHandle(L\"wininet\");\n    if (wininet_handle) {\n      get_cookie_proc = reinterpret_cast<InternetGetCookieEx2Proc>(::GetProcAddress(wininet_handle, \"InternetGetCookieEx2\"));\n      free_cookies_proc = reinterpret_cast<InternetFreeCookiesProc>(::GetProcAddress(wininet_handle, \"InternetFreeCookies\"));\n    }\n\n    DWORD cookie_count = 0;\n    INTERNETCOOKIE2* cookie_pointer = NULL;\n    DWORD success = 1;\n    if (get_cookie_proc) {\n      success = get_cookie_proc(parsed_uri.c_str(),\n                                NULL,\n                                INTERNET_COOKIE_NON_SCRIPT,\n                                &cookie_pointer,\n                                &cookie_count);\n    }\n\n    if (success == 0) {\n      // Mimic the format of the old persistent cookie files for ease of\n      // transmission back to the driver and parsing.\n      std::wstring all_cookies = L\"\";\n      for (DWORD cookie_index = 0; cookie_index < cookie_count; ++cookie_index) {\n        if (all_cookies.size() > 0) {\n          all_cookies.append(L\"\\n*\\n\");\n        }\n        INTERNETCOOKIE2* current_cookie = cookie_pointer + cookie_index;\n        std::wstring cookie_name = L\"\";\n        if (current_cookie->pwszName) {\n          // Note that the spec appears to allow \"nameless\" cookies,\n          // which clients like Selenium may not support.\n          cookie_name = current_cookie->pwszName;\n        }\n        std::wstring cookie_value = L\"\";\n        if (current_cookie->pwszValue) {\n          cookie_value = current_cookie->pwszValue;\n        }\n\n        // TODO: The spec does not allow a cookie with an empty name\n        // and value. It's unclear what the driver could do in this\n        // case, but we should probably handle it somehow in the off\n        // chance it ever comes up.\n        std::wstring cookie_domain = L\"\";\n        if (current_cookie->pwszDomain) {\n          cookie_domain = current_cookie->pwszDomain;\n        }\n        std::wstring cookie_path = L\"\";\n        if (current_cookie->pwszPath) {\n          cookie_path = current_cookie->pwszPath;\n        }\n        DWORD flags = current_cookie->dwFlags;\n        FILETIME expires = current_cookie->ftExpires;\n        all_cookies.append(cookie_name).append(L\"\\n\");\n        all_cookies.append(cookie_value).append(L\"\\n\");\n        all_cookies.append(cookie_domain).append(L\"/\").append(cookie_path).append(L\"\\n\");\n        all_cookies.append(std::to_wstring(flags)).append(L\"\\n\");\n        // If the expiration time is set, add it to the string for the cookie.\n        // If not, append empty fields to the record so subsequent parsing\n        // of the string will still work.\n        if (current_cookie->fExpiresSet) {\n          all_cookies.append(std::to_wstring(expires.dwLowDateTime)).append(L\"\\n\");\n          all_cookies.append(std::to_wstring(expires.dwHighDateTime)).append(L\"\\n\");\n        } else {\n          all_cookies.append(L\"\\n\\n\");\n        }\n      }\n      free_cookies_proc(cookie_pointer, cookie_count);\n      webdriver::HookProcessor::CopyWStringToBuffer(all_cookies);\n    } else {\n      webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));\n    }\n    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n  } else if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||\n             WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message ||\n             WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n\n    DWORD get_cookie_flags = 0;\n    if (WD_GET_HTTPONLY_COOKIES == call_window_proc_struct->message ||\n      WD_GET_SECURE_COOKIES == call_window_proc_struct->message) {\n      get_cookie_flags = INTERNET_COOKIE_HTTPONLY;\n    }\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    DWORD scheme = 0;\n    uri_pointer->GetScheme(&scheme);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n\n    // Get only the cookies for the base URL, omitting port, if there is one.\n    // N.B., we only return cookies secure cookies when browsing a site using\n    // SSL. The browser won't see cookies with the 'secure' flag for sites\n    // visited using plain http.\n    std::wstring parsed_uri = L\"http\";\n    if ((WD_GET_SECURE_COOKIES == call_window_proc_struct->message ||\n         WD_GET_SCRIPTABLE_COOKIES == call_window_proc_struct->message) &&\n        URL_SCHEME_HTTPS == scheme) {\n      parsed_uri.append(L\"s\");\n    }\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n    parsed_uri.append(path_bstr);\n\n    // Call InternetGetCookieEx once to get the size of the buffer needed,\n    // then call again with the appropriately sized buffer allocated.\n    DWORD buffer_size = 0;\n    BOOL success = ::InternetGetCookieEx(parsed_uri.c_str(),\n                                         NULL,\n                                         NULL,\n                                         &buffer_size,\n                                         get_cookie_flags,\n                                         NULL);\n    if (success) {\n      webdriver::HookProcessor::SetDataBufferSize(buffer_size);\n      ::InternetGetCookieEx(parsed_uri.c_str(),\n                            NULL,\n                            reinterpret_cast<LPTSTR>(webdriver::HookProcessor::GetDataBufferAddress()),\n                            &buffer_size,\n                            get_cookie_flags,\n                            NULL);\n\n      webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n    } else {\n      if (ERROR_NO_MORE_ITEMS == ::GetLastError()) {\n        webdriver::HookProcessor::SetDataBufferSize(sizeof(wchar_t));\n        webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n      }\n    }\n  } else if (WD_GET_COOKIE_CACHE_FILES == call_window_proc_struct->message) {\n    int driver_process_id = static_cast<int>(call_window_proc_struct->wParam);\n    std::wstring file_list = L\"\";\n    std::wstring url = webdriver::HookProcessor::CopyWStringFromBuffer();\n\n    // We need to remove the port to find the entry in the cache.\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    CComBSTR path_bstr;\n    uri_pointer->GetPath(&path_bstr);\n    std::wstring parsed_uri = host_bstr;\n    parsed_uri.append(path_bstr);\n\n    // A 2048-byte buffer should be large enough to handle cookie\n    // cache entries in all but the most extreme cases.\n    HANDLE cache_enum_handle = NULL;\n    DWORD entry_size = 2048;\n    LPINTERNET_CACHE_ENTRY_INFO entry = NULL;\n    std::vector<char> entry_buffer(entry_size);\n    entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);\n    cache_enum_handle = ::FindFirstUrlCacheEntry(L\"cookie:\",\n                                                 entry,\n                                                 &entry_size);\n    if (cache_enum_handle == NULL &&\n        ERROR_INSUFFICIENT_BUFFER == ::GetLastError()) {\n      entry_buffer.resize(entry_size);\n      entry = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(&entry_buffer[0]);\n      cache_enum_handle = ::FindFirstUrlCacheEntry(L\"cookie:\",\n                                                   entry,\n                                                   &entry_size);\n    }\n    while (cache_enum_handle != NULL) {\n      if (COOKIE_CACHE_ENTRY == (entry->CacheEntryType & COOKIE_CACHE_ENTRY)) {\n        std::wstring name = entry->lpszSourceUrlName;\n        size_t name_separator_pos(name.find_first_of(L\"@\"));\n        std::wstring domain = name.substr(name_separator_pos + 1);\n        if (parsed_uri.find(domain) != std::wstring::npos) {\n          if (file_list.size() > 0) {\n            file_list.append(L\"|\");\n          }\n          file_list.append(entry->lpszLocalFileName);\n        }\n      }\n      BOOL success = ::FindNextUrlCacheEntry(cache_enum_handle,\n                                             entry,\n                                             &entry_size);\n      if (!success) {\n        DWORD error = ::GetLastError();\n        if (ERROR_INSUFFICIENT_BUFFER == error) {\n          entry_buffer.resize(entry_size);\n          BOOL other_success = ::FindNextUrlCacheEntry(cache_enum_handle,\n                                                       entry,\n                                                       &entry_size);\n        } else if (ERROR_NO_MORE_ITEMS == error) {\n          ::FindCloseUrlCache(cache_enum_handle);\n          cache_enum_handle = NULL;\n        }\n      }\n    }\n    webdriver::HookProcessor::CopyWStringToBuffer(file_list);\n    webdriver::HookProcessor::WriteBufferToPipe(driver_process_id);\n  } else if (WD_SET_COOKIE == call_window_proc_struct->message) {\n    DWORD set_cookie_flags = static_cast<DWORD>(call_window_proc_struct->wParam);\n    std::wstring cookie_data = webdriver::HookProcessor::CopyWStringFromBuffer();\n    size_t url_separator_pos = cookie_data.find_first_of(L\"|\");\n    std::wstring url = cookie_data.substr(0, url_separator_pos);\n    std::wstring cookie = cookie_data.substr(url_separator_pos + 1);\n\n    CComPtr<IUri> uri_pointer;\n    HRESULT hr = ::CreateUri(url.c_str(), Uri_CREATE_ALLOW_RELATIVE, 0, &uri_pointer);\n    CComBSTR scheme_bstr;\n    uri_pointer->GetSchemeName(&scheme_bstr);\n    CComBSTR host_bstr;\n    uri_pointer->GetHost(&host_bstr);\n    std::wstring parsed_uri = scheme_bstr;\n    parsed_uri.append(L\"://\");\n    parsed_uri.append(host_bstr);\n\n    // Leverage the shared data buffer size to return the error code\n    // back to the driver, if necessary.\n    DWORD cookie_set = ::InternetSetCookieEx(parsed_uri.c_str(),\n                                             NULL,\n                                             cookie.c_str(),\n                                             set_cookie_flags,\n                                             NULL);\n    if (cookie_set) {\n      webdriver::HookProcessor::SetDataBufferSize(0);\n    } else {\n      DWORD error = ::GetLastError();\n      webdriver::HookProcessor::SetDataBufferSize(error);\n    }\n  }\n  return ::CallNextHookEx(NULL, nCode, wParam, lParam);\n}\n\n#ifdef __cplusplus\n}\n#endif\n"], "filenames": ["cpp/iedriver/CookieManager.cpp"], "buggy_code_start_loc": [525], "buggy_code_end_loc": [529], "fixing_code_start_loc": [525], "fixing_code_end_loc": [540], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository seleniumhq/selenium prior to 4.14.0.", "other": {"cve": {"id": "CVE-2023-5590", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-15T23:15:44.857", "lastModified": "2023-10-19T11:07:40.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository seleniumhq/selenium prior to 4.14.0."}, {"lang": "es", "value": "Eliminaci\u00f3n de referencia del puntero NULL en el repositorio de GitHub seleniumhq/selenium anterior a 4.14.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:selenium:selenium:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.14.0", "matchCriteriaId": "D7F99E6A-73B9-4154-BCC9-93421E29945A"}]}]}], "references": [{"url": "https://github.com/seleniumhq/selenium/commit/023a0d52f106321838ab1c0997e76693f4dcbdf6", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/e268cd68-4f34-49bd-878b-82b96dcc0c99", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/seleniumhq/selenium/commit/023a0d52f106321838ab1c0997e76693f4dcbdf6"}}