{"buggy_code": ["--------------------------------------------------------------------------------\n\n## 14.0.0\n\nUnreleased.\n\n### Added\n\n### Changed\n\n--------------------------------------------------------------------------------\n\n## 13.0.0\n\nUnreleased.\n\n### Added\n\n* Configuration of mach ports vs signals on macOS is now done through a `Config`\n  instead of at compile time.\n  [#6807](https://github.com/bytecodealliance/wasmtime/pull/6807)\n\n* `Engine::detect_precompiled{,_file}` can be used to to determine whether some\n  bytes or a file look like a precompiled module or a component.\n  [#6832](https://github.com/bytecodealliance/wasmtime/pull/6832)\n  [#6937](https://github.com/bytecodealliance/wasmtime/pull/6937)\n\n* A new feature \"wmemcheck\" has been added to enable Valgrind-like detection of\n  use-after-free within a WebAssembly guest module.\n  [#6820](https://github.com/bytecodealliance/wasmtime/pull/6820)\n  [#6856](https://github.com/bytecodealliance/wasmtime/pull/6856)\n\n* The `wasmtime` CLI now supports executing components.\n  [#6836](https://github.com/bytecodealliance/wasmtime/pull/6836)\n\n* Support for WASI preview2's TCP sockets interface has been added.\n  [#6837](https://github.com/bytecodealliance/wasmtime/pull/6837)\n\n* Wasmtime's implementation of the wasi-nn proposal now supports named models.\n  [#6854](https://github.com/bytecodealliance/wasmtime/pull/6854)\n\n* The C API now supports configuring `native_unwind_info`,\n  `dynamic_memory_reserved_for_growth`, `target`, and Cranelift settings.\n  [#6896](https://github.com/bytecodealliance/wasmtime/pull/6896)\n  [#6934](https://github.com/bytecodealliance/wasmtime/pull/6934)\n\n* The `wasmtime` crate now has initial support for component model bindings\n  generation for the WIT `resource` type.\n  [#6886](https://github.com/bytecodealliance/wasmtime/pull/6886)\n\n* Cranelift's RISC-V backend now has a complete implementation of the\n  WebAssembly SIMD proposal. Many thanks to Afonso Bordado for all their\n  contributions!\n  [#6920](https://github.com/bytecodealliance/wasmtime/pull/6920)\n  [#6924](https://github.com/bytecodealliance/wasmtime/pull/6924)\n\n* The `bindgen!` macro in the `wasmtime` crate now supports conditional\n  configuration for which imports should be `async` and which should be\n  synchronous.\n  [#6942](https://github.com/bytecodealliance/wasmtime/pull/6942)\n\n### Changed\n\n* The pooling allocator was significantly refactored and the\n  `PoolingAllocationConfig` has some minor breaking API changes that reflect\n  those changes.\n\n  Previously, the pooling allocator had `count` slots, and each slot had `N`\n  memories and `M` tables. Every allocated instance would reserve those `N`\n  memories and `M` tables regardless whether it actually needed them all or\n  not. This could lead to some waste and over-allocation when a module used less\n  memories and tables than the pooling allocator's configured maximums.\n\n  After the refactors in this release, the pooling allocator doesn't have\n  one-size-fits-all slots anymore. Instead, memories and tables are in separate\n  pools that can be allocated from independently, and we allocate exactly as\n  many memories and tables as are necessary for the instance being allocated.\n\n  To preserve your old configuration with the new methods you can do the following:\n\n  ```rust\n  let mut config = PoolingAllocationConfig::default();\n\n  // If you used to have this old, no-longer-compiling configuration:\n  config.count(count);\n  config.instance_memories(n);\n  config.instance_tables(m);\n\n  // You can use these equivalent settings for the new config methods:\n  config.total_core_instances(count);\n  config.total_stacks(count); // If using the `async` feature.\n  config.total_memories(count * n);\n  config.max_memories_per_module(n);\n  config.total_tables(count * m);\n  config.max_tables_per_module(m);\n  ```\n\n  There are additionally a variety of methods to limit the maximum amount of\n  resources a single core Wasm or component instance can take from the pool:\n\n  * `PoolingAllocationConfig::max_memories_per_module`\n  * `PoolingAllocationConfig::max_tables_per_module`\n  * `PoolingAllocationConfig::max_memories_per_component`\n  * `PoolingAllocationConfig::max_tables_per_component`\n  * `PoolingAllocationConfig::max_core_instances_per_component`\n\n  These methods do not affect the size of the pre-allocated pool.\n  [#6835](https://github.com/bytecodealliance/wasmtime/pull/6835)\n\n* Builder methods for WASI contexts now use `&mut self` instead of `self`.\n  [#6770](https://github.com/bytecodealliance/wasmtime/pull/6770)\n\n* Native unwinding information is now properly disabled when it is configured to\n  be turned off.\n  [#6547](https://github.com/bytecodealliance/wasmtime/pull/6547)\n\n* Wasmtime's minimum supported Rust version (MSRV) is now 1.70.0. Wasmtime's\n  MSRV policy of supporting the last three releases of Rust (N-2) is now\n  additionally documented. More discussion can additionally be found on the PR\n  itself.\n  [#6900](https://github.com/bytecodealliance/wasmtime/pull/6900)\n\n* Wasmtime's support for DWARF debugging information has seen some fixes for\n  previously reported crashes.\n  [#6931](https://github.com/bytecodealliance/wasmtime/pull/6931)\n\n### Removed\n\n* Wasmtime's experimental implementation of wasi-crypto has been removed. More\n  discussion of this change can be found on\n  [#6732](https://github.com/bytecodealliance/wasmtime/pull/6732)\n  and\n  [#6816](https://github.com/bytecodealliance/wasmtime/pull/6816)\n\n* Support for `union` types in the component model has been removed.\n  [#6913](https://github.com/bytecodealliance/wasmtime/pull/6913)\n\n--------------------------------------------------------------------------------\n\n## 12.0.1\n\nReleased 2023-08-24\n\n### Fixed\n\n* Optimized the cranelift compilation on aarch64 for large wasm modules.\n  [#6804](https://github.com/bytecodealliance/wasmtime/pull/6804)\n\n--------------------------------------------------------------------------------\n\n## 12.0.0\n\nReleased 2023-08-21\n\n### Added\n\n* Wasmtime now supports having multiple different versions of itself being\n  linked into the same final executable by mangling some C symbols used by\n  Wasmtime.\n  [#6673](https://github.com/bytecodealliance/wasmtime/pull/6673)\n\n* The `perfmap` profiling option is now supported on any Unix platform instead\n  of just Linux.\n  [#6701](https://github.com/bytecodealliance/wasmtime/pull/6701)\n\n* The `wasmtime` CLI now supports `--env FOO` to inherit the value of the\n  environment variable `FOO` which avoids needing to do `--env FOO=$FOO` for\n  example.\n  [#6746](https://github.com/bytecodealliance/wasmtime/pull/6746)\n\n* Wasmtime now supports component model resources, although support has not yet\n  been added to `bindgen!`.\n  [#6691](https://github.com/bytecodealliance/wasmtime/pull/6691)\n\n* Wasmtime now supports configuration to enable the tail calls proposal.\n  Platform support now also includes AArch64 and RISC-V in addition to the\n  previous x86\\_64 support.\n  [#6723](https://github.com/bytecodealliance/wasmtime/pull/6723)\n  [#6749](https://github.com/bytecodealliance/wasmtime/pull/6749)\n  [#6774](https://github.com/bytecodealliance/wasmtime/pull/6774)\n\n* Wasmtime's implementation of WASI Preview 2 now supports streams/pollables\n  with host objects that are all backed by Rust `async`.\n  [#6556](https://github.com/bytecodealliance/wasmtime/pull/6556)\n\n* Support for core dumps has now been added to the `wasmtime` crate.\n  [#6513](https://github.com/bytecodealliance/wasmtime/pull/6513)\n\n* New `{Module,Component}::resources_required` APIs allow inspecting what will\n  be required when instantiating the module or component.\n  [#6789](https://github.com/bytecodealliance/wasmtime/pull/6789)\n\n### Fixed\n\n* Functions on instances defined through `component::Linker::func_new` are now\n  defined correctly.\n  [#6637](https://github.com/bytecodealliance/wasmtime/pull/6637)\n\n* The `async_stack_size` configuration option is no longer inspected when\n  `async_support` is disabled at runtime.\n  [#6771](https://github.com/bytecodealliance/wasmtime/pull/6771)\n\n* WASI Preview 1 APIs will now trap on misaligned or out-of-bounds pointers\n  instead of returning an error.\n  [#6776](https://github.com/bytecodealliance/wasmtime/pull/6776)\n\n### Changed\n\n* Empty types are no longer allowed in the component model.\n  [#6777](https://github.com/bytecodealliance/wasmtime/pull/6777)\n\n--------------------------------------------------------------------------------\n\n## 11.0.0\n\nReleased 2023-07-20\n\n### Changed\n\n* The WASI Preview 2 `WasiCtxBuilder` type has been refactored, and `WasiCtx` now has private\n  fields.\n  [#6652](https://github.com/bytecodealliance/wasmtime/pull/6652)\n\n* Component `bindgen!` now generates owned types by default instead of based on\n  how they're used\n  [#6648](https://github.com/bytecodealliance/wasmtime/pull/6648)\n\n* Wasmtime/Cranelift on x86-64 can now execute Wasm-SIMD on baseline SSE2, which\n  all x86-64 processors support (as part of the base x86-64 spec). Previously,\n  SSE4.2 extensions were required. This new work allows Wasm with SIMD\n  extensions to execute on processors produced back to 2003.\n  [#6625](https://github.com/bytecodealliance/wasmtime/pull/6625)\n\n\n### Fixed\n\n* Only export the top-level preview2 module from wasmtime-wasi when the\n  `preview2` feature is enabled.\n  [#6615](https://github.com/bytecodealliance/wasmtime/pull/6615)\n\n\n### Cranelift changes\n\n* Tail call implementation has begun in Cranelift\n  [#6641](https://github.com/bytecodealliance/wasmtime/pull/6641)\n  [#6666](https://github.com/bytecodealliance/wasmtime/pull/6666)\n  [#6650](https://github.com/bytecodealliance/wasmtime/pull/6650)\n  [#6635](https://github.com/bytecodealliance/wasmtime/pull/6635)\n  [#6608](https://github.com/bytecodealliance/wasmtime/pull/6608)\n  [#6586](https://github.com/bytecodealliance/wasmtime/pull/6586)\n\n* Work continues on SIMD support for the riscv64 backend\n  [#6657](https://github.com/bytecodealliance/wasmtime/pull/6657)\n  [#6643](https://github.com/bytecodealliance/wasmtime/pull/6643)\n  [#6601](https://github.com/bytecodealliance/wasmtime/pull/6601)\n  [#6609](https://github.com/bytecodealliance/wasmtime/pull/6609)\n  [#6602](https://github.com/bytecodealliance/wasmtime/pull/6602)\n  [#6598](https://github.com/bytecodealliance/wasmtime/pull/6598)\n  [#6599](https://github.com/bytecodealliance/wasmtime/pull/6599)\n  [#6587](https://github.com/bytecodealliance/wasmtime/pull/6587)\n  [#6568](https://github.com/bytecodealliance/wasmtime/pull/6568)\n  [#6515](https://github.com/bytecodealliance/wasmtime/pull/6515)\n\n* Fix `AuthenticatedRet` when stack bytes are popped in the aarch64 backend\n  [#6634](https://github.com/bytecodealliance/wasmtime/pull/6634)\n\n* The `fcvt_low_from_sint` instruction has been removed, as it its current\n  behavior can be recovered through a combination of `swiden_low` and\n  `fcvt_from_sint`\n  [#6565](https://github.com/bytecodealliance/wasmtime/pull/6565)\n\n--------------------------------------------------------------------------------\n\n## 10.0.1\n\nReleased 2023-06-21\n\n### Fixed\n\n* Only export the top-level preview2 module from wasmtime-wasi when the\n  `preview2` feature is enabled.\n  [#6615](https://github.com/bytecodealliance/wasmtime/pull/6615)\n\n--------------------------------------------------------------------------------\n\n## 10.0.0\n\nReleased 2023-06-20\n\n### Added\n\n* Expose the `Config::static_memory_forced` option through the C api\n  [#6413](https://github.com/bytecodealliance/wasmtime/pull/6413)\n\n* Basic guest-profiler documentation for the book\n  [#6394](https://github.com/bytecodealliance/wasmtime/pull/6394)\n\n* Merge the initial wasi-preview2 implementation\n  [#6391](https://github.com/bytecodealliance/wasmtime/pull/6391)\n\n* The wasi-preview2 component adapter has been pulled into the main wasmtime\n  repository. It is available for the first time as part of this release, but should be\n  treated as as a beta at this time. Patch releases will not be made for bug fixes.\n  [#6374](https://github.com/bytecodealliance/wasmtime/pull/6374)\n\n* A callback invoked when an epoch deadline is reached can now be configured via\n  the C API.\n  [#6359](https://github.com/bytecodealliance/wasmtime/pull/6359)\n\n* PR auto-assignment policies have been documented, to clarify the expectations of\n  reviewers.\n  [#6346](https://github.com/bytecodealliance/wasmtime/pull/6346)\n\n* Support for the function references has been added\n  [#5288](https://github.com/bytecodealliance/wasmtime/pull/5288)\n\n### Changed\n\n* An `epoch_deadline_callback` now returns an `UpdateDeadline` enum to allow\n  optionally yielding to the async executor after the callback runs.\n  [#6464](https://github.com/bytecodealliance/wasmtime/pull/6464)\n\n* The `--profile-guest` flag has now been folded into `--profile=guest`\n  [#6352](https://github.com/bytecodealliance/wasmtime/pull/6352)\n\n* Initializers are no longer tracked in the type information for globals, and\n  instead are provided when creating the global.\n  [#6349](https://github.com/bytecodealliance/wasmtime/pull/6349)\n\n* The \"raw\" representation of `funcref` and `externref` in the embedding API has\n  been updated from a `usize` to a `*mut u8` to be compatible with Rust's\n  proposed strict provenance rules. This change is additionally reflected into\n  the C API as well.\n  [#6338](https://github.com/bytecodealliance/wasmtime/pull/6338)\n\n### Fixed\n\n* Fixed a soundness issue with the component model and async\n  [#6509](https://github.com/bytecodealliance/wasmtime/pull/6509)\n\n* Opening directories with WASI on Windows with `NONBLOCK` in flags has been\n  fixed.\n  [#6348](https://github.com/bytecodealliance/wasmtime/pull/6348)\n\n### Cranelift changes\n\n* Performance improvements in regalloc2 have landed, and compilation time has\n  improved\n  [#6483](https://github.com/bytecodealliance/wasmtime/pull/6483)\n  [#6398](https://github.com/bytecodealliance/wasmtime/pull/6398)\n\n* Renamed `abi::Caller` to `abi::CallSite`\n  [#6414](https://github.com/bytecodealliance/wasmtime/pull/6414)\n\n* Work has begun on SIMD support for the riscv64 backend\n  [#6324](https://github.com/bytecodealliance/wasmtime/pull/6324)\n  [#6366](https://github.com/bytecodealliance/wasmtime/pull/6366)\n  [#6367](https://github.com/bytecodealliance/wasmtime/pull/6367)\n  [#6392](https://github.com/bytecodealliance/wasmtime/pull/6392)\n  [#6397](https://github.com/bytecodealliance/wasmtime/pull/6397)\n  [#6403](https://github.com/bytecodealliance/wasmtime/pull/6403)\n  [#6408](https://github.com/bytecodealliance/wasmtime/pull/6408)\n  [#6419](https://github.com/bytecodealliance/wasmtime/pull/6419)\n  [#6430](https://github.com/bytecodealliance/wasmtime/pull/6430)\n  [#6507](https://github.com/bytecodealliance/wasmtime/pull/6507)\n\n--------------------------------------------------------------------------------\n\n## 9.0.3\n\nReleased 2023-05-31.\n\n### Fixed\n\n* Fix Wasi rights system to work with wasi-testsuite, which exposed a corner case\n  that was missed by the fixes in the 9.0.2 release.\n  [#6479](https://github.com/bytecodealliance/wasmtime/pull/6479)\n\n--------------------------------------------------------------------------------\n\n## 9.0.2\n\nReleased 2023-05-26.\n\n### Fixed\n\n* Fix Wasi rights system to work with wasi-libc. This regression was\n  introduced in the 9.0.0 release.\n  [#6462](https://github.com/bytecodealliance/wasmtime/pull/6462)\n  [#6471](https://github.com/bytecodealliance/wasmtime/pull/6471)\n\n--------------------------------------------------------------------------------\n\n## 9.0.1\n\nReleased 2023-05-22.\n\n### Fixed\n\n* A panic which happened when enabling support for native platform profilers was\n  fixed.\n  [#6435](https://github.com/bytecodealliance/wasmtime/pull/6435)\n\n--------------------------------------------------------------------------------\n\n## 9.0.0\n\nReleased 2023-05-22.\n\n### Added\n\n* Initial integration of the Winch baseline compiler into Wasmtime is\n  implemented. Note that Winch still does not support much of WebAssembly, but\n  intrepid explorers may have an easier time playing around with it now.\n  [#6119](https://github.com/bytecodealliance/wasmtime/pull/6119)\n\n* The `wasmtime` CLI now has flags to limit memory, instances, and tables. For\n  example `--max-memory-size` or `--max-tables`. Additionally it has a new\n  `--trap-on-grow-failure` option to force a trap whenever a `memory.grow` would\n  otherwise fail which can be useful for debugging modules which may be\n  encountering OOM.\n  [#6149](https://github.com/bytecodealliance/wasmtime/pull/6149)\n\n* An initial implementation of the wasi-http proposal was added to Wasmtime in\n  the shape of a new `wasmtime-wasi-http` crate and a\n  `--wasi-modules=experimental-wasi-http` CLI flag.  Note that this is not\n  on-by-default and still in an experimental status at this time.\n  [#5929](https://github.com/bytecodealliance/wasmtime/pull/5929)\n\n* Wasmtime's `bindgen!` macro for components now has `interfaces` and\n  `with` options to configure use of interfaces defined externally in separate\n  crates.\n  [#6160](https://github.com/bytecodealliance/wasmtime/pull/6160)\n  [#6210](https://github.com/bytecodealliance/wasmtime/pull/6210)\n\n* Wasmtime's `bindgen!` macro emits trace events for arguments and results\n  when enabled.\n  [#6209](https://github.com/bytecodealliance/wasmtime/pull/6209)\n\n* A new `Engine::precompile_compatibility_hash` method has been added to assist\n  with hashing artifacts to be compatible with versions of Wasmtime.\n  [#5826](https://github.com/bytecodealliance/wasmtime/pull/5826)\n\n* Wasmtime's C API now has functions for enabling the WebAssembly relaxed-simd\n  proposal.\n  [#6292](https://github.com/bytecodealliance/wasmtime/pull/6292)\n\n* A new `--emit-clif` flag has been added to `wasmtime compile` to see the CLIF\n  corresponding to a WebAssembly module to be used for debugging.\n  [#6307](https://github.com/bytecodealliance/wasmtime/pull/6307)\n\n* Support for an in-process sampling-based profiler has been added to Wasmtime.\n  This is intended to be used in conjunction with epochs to enable relatively\n  simple implementations of profiling a guest module.\n  [#6282](https://github.com/bytecodealliance/wasmtime/pull/6282)\n\n### Changed\n\n* Overhauled the way that Wasmtime calls into Wasm and Wasm calls back out to\n  the host. Instead of chaining together trampolines to convert between calling\n  conventions, we now represent `funcref`s with multiple function pointers, one\n  per calling convention. This paves the way for supporting Wasm tail calls and\n  also results in ~10% speed ups to a variety of function call benchmarks,\n  however there are some slight compiled Wasm module code size regressions\n  (which can be alleviated by disabling optional `.eh_frame`\n  generation). Additionally, in the C API the `wasmtime_func_call_unchecked`\n  function gained one more parameter, which is the capacity of the\n  args-and-results\n  buffer.\n  [#6262](https://github.com/bytecodealliance/wasmtime/pull/6262)\n\n* The `wasmtime compile` command will now default to producing executables for\n  the native host and its CPU features instead of the baseline feature set of\n  the host's architecture.\n  [#6152](https://github.com/bytecodealliance/wasmtime/pull/6152)\n\n* The `ResourceLimiter` trait and its `async` equivalent now support returning\n  errors from growth to force a trap in the wasm module rather than reporting\n  -1 to the wasm module. Note that this is primarily intended for debugging.\n  [#6149](https://github.com/bytecodealliance/wasmtime/pull/6149)\n\n* The non-egraph-based optimization pipeline has been removed from Cranelift,\n  and the corresponding `Config::use_egraphs` option is also removed.\n  [#6167](https://github.com/bytecodealliance/wasmtime/pull/6167)\n\n* Generated types for WIT files now always generates owned types by default.\n  [#6189](https://github.com/bytecodealliance/wasmtime/pull/6189)\n\n* Wasmtime's baseline x86\\_64 CPU features required for SIMD support has been\n  lowered from SSE 4.2 to SSE 4.1.\n  [#6206](https://github.com/bytecodealliance/wasmtime/pull/6206)\n\n* The `fd_allocate` implementation in Wasmtime will now always fail with\n  `ENOTSUP`.\n  [#6217](https://github.com/bytecodealliance/wasmtime/pull/6217)\n\n* The \"rights\" system in WASI has been removed and rights are no longer\n  inspected in the implementation of any WASI functions.\n  [#6265](https://github.com/bytecodealliance/wasmtime/pull/6265)\n\n### Fixed\n\n* WASI can now open directories without `O_DIRECTORY`.\n  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163)\n\n* The `poll_oneoff` function has been fixed when handling non-regular files.\n  [#6258](https://github.com/bytecodealliance/wasmtime/pull/6258)\n\n* The behavior of `path_readlink` on too-small buffers has been fixed to\n  truncate.\n  [#6225](https://github.com/bytecodealliance/wasmtime/pull/6225)\n\n### Cranelift changes\n\n> Note: this section documents changes to Cranelift, a code generator backend\n> that Wasmtime uses. These changes are not always applicable to Wasmtime as a\n> WebAssembly runtime but may be interesting to other projects which embed or\n> use Cranelift.\n\n* New `{u,s}{add,sub,mul}_overflow` instructions have been added.\n  [#5784](https://github.com/bytecodealliance/wasmtime/pull/5784)\n\n* The `iadd_cout` and `isub_bout` instructions have been removed.\n  [#6198](https://github.com/bytecodealliance/wasmtime/pull/6198)\n\n* ISLE now supports binary and octal integer literals.\n  [#6234](https://github.com/bytecodealliance/wasmtime/pull/6234)\n\n* An implementation of SIMD for RISC-V has started.\n  [#6240](https://github.com/bytecodealliance/wasmtime/pull/6240)\n  [#6266](https://github.com/bytecodealliance/wasmtime/pull/6266)\n  [#6268](https://github.com/bytecodealliance/wasmtime/pull/6268)\n\n--------------------------------------------------------------------------------\n\n## 8.0.1\n\nReleased 2023-04-27.\n\n### Changed\n\n* Breaking: Files opened using Wasmtime's implementation of WASI on Windows now\n  cannot be deleted until the file handle is closed. This was already true for\n  open directories. The change was necessary for the bug fix in\n  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163).\n\n### Fixed\n\n* Fixed wasi-common's implementation of the `O_DIRECTORY` flag to match POSIX.\n  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163)\n\n* Undefined Behavior in Rust runtime functions\n  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n\n--------------------------------------------------------------------------------\n\n## 8.0.0\n\nReleased 2023-04-20\n\n### Added\n\n* Allow the MPL-2.0 and OpenSSL licenses in dependencies of wasmtime.\n  [#6136](https://github.com/bytecodealliance/wasmtime/pull/6136)\n\n* Add a bounds-checking optimization for dynamic memories and guard pages.\n  [#6031](https://github.com/bytecodealliance/wasmtime/pull/6031)\n\n* Add support for generating perf maps for simple perf profiling. Additionally,\n  the `--jitdump` and `--vtune` flags have been replaced with a single\n  `--profile` flags that accepts `perfmap`, `jitdump`, and `vtune` arguments.\n  [#6030](https://github.com/bytecodealliance/wasmtime/pull/6030)\n\n* Validate faulting addresses are valid to fault on. As a mitigation to CVEs\n  like `GHSA-ff4p-7xrq-q5r8`, check that the address involved in a fault is one\n  that could be contained in a `Store`, or print a scary message and abort\n  immediately.\n  [#6028](https://github.com/bytecodealliance/wasmtime/pull/6028)\n\n* Add the `--default-values-unknown-imports` option to define unknown function\n  imports as functions that return the default value for their result type.\n  [#6010](https://github.com/bytecodealliance/wasmtime/pull/6010)\n\n* Add `Clone` for `component::InstancePre`.\n  [#5996](https://github.com/bytecodealliance/wasmtime/issues/5996)\n\n* Add `--dynamic-memory-reserved-for-growth` cli flag.\n  [#5980](https://github.com/bytecodealliance/wasmtime/issues/5980)\n\n* Introduce the `wasmtime-explorer` crate for investigating the compilation of\n  wasm modules. This functionality is also exposed via the `wasmtime explore`\n  command.\n  [#5975](https://github.com/bytecodealliance/wasmtime/pull/5975)\n\n* Added support for the Relaxed SIMD proposal.\n  [#5892](https://github.com/bytecodealliance/wasmtime/pull/5892)\n\n* Cranelift gained many new machine-independent optimizations.\n  [#5909](https://github.com/bytecodealliance/wasmtime/pull/5909)\n  [#6032](https://github.com/bytecodealliance/wasmtime/pull/6032)\n  [#6033](https://github.com/bytecodealliance/wasmtime/pull/6033)\n  [#6034](https://github.com/bytecodealliance/wasmtime/pull/6034)\n  [#6037](https://github.com/bytecodealliance/wasmtime/pull/6037)\n  [#6052](https://github.com/bytecodealliance/wasmtime/pull/6052)\n  [#6053](https://github.com/bytecodealliance/wasmtime/pull/6053)\n  [#6072](https://github.com/bytecodealliance/wasmtime/pull/6072)\n  [#6095](https://github.com/bytecodealliance/wasmtime/pull/6095)\n  [#6130](https://github.com/bytecodealliance/wasmtime/pull/6130)\n\n### Changed\n\n* Derive `Copy` on `wasmtime::ValType`.\n  [#6138](https://github.com/bytecodealliance/wasmtime/pull/6138)\n\n* Make `StoreContextMut` accessible in the epoch deadline callback.\n  [#6075](https://github.com/bytecodealliance/wasmtime/pull/6075)\n\n* Take SIGFPE signals for divide traps on `x86_64`.\n  [#6026](https://github.com/bytecodealliance/wasmtime/pull/6026)\n\n* Use more specialized AVX instructions in the `x86_64` backend.\n  [#5924](https://github.com/bytecodealliance/wasmtime/pull/5924)\n  [#5930](https://github.com/bytecodealliance/wasmtime/pull/5930)\n  [#5931](https://github.com/bytecodealliance/wasmtime/pull/5931)\n  [#5982](https://github.com/bytecodealliance/wasmtime/pull/5982)\n  [#5986](https://github.com/bytecodealliance/wasmtime/pull/5986)\n  [#5999](https://github.com/bytecodealliance/wasmtime/pull/5999)\n  [#6023](https://github.com/bytecodealliance/wasmtime/pull/6023)\n  [#6025](https://github.com/bytecodealliance/wasmtime/pull/6025)\n  [#6060](https://github.com/bytecodealliance/wasmtime/pull/6060)\n  [#6086](https://github.com/bytecodealliance/wasmtime/pull/6086)\n  [#6092](https://github.com/bytecodealliance/wasmtime/pull/6092)\n\n* Generate more cache-friendly code for traps.\n  [#6011](https://github.com/bytecodealliance/wasmtime/pull/6011)\n\n### Fixed\n\n* Fixed suboptimal code generation in the `aarch64` backend.\n  [#5976](https://github.com/bytecodealliance/wasmtime/pull/5976)\n  [#5977](https://github.com/bytecodealliance/wasmtime/pull/5977)\n  [#5987](https://github.com/bytecodealliance/wasmtime/pull/5987)\n  [#5997](https://github.com/bytecodealliance/wasmtime/pull/5997)\n  [#6078](https://github.com/bytecodealliance/wasmtime/pull/6078)\n\n* Fixed suboptimal code generation in the `riscv64` backend.\n  [#5854](https://github.com/bytecodealliance/wasmtime/pull/5854)\n  [#5857](https://github.com/bytecodealliance/wasmtime/pull/5857)\n  [#5919](https://github.com/bytecodealliance/wasmtime/pull/5919)\n  [#5951](https://github.com/bytecodealliance/wasmtime/pull/5951)\n  [#5964](https://github.com/bytecodealliance/wasmtime/pull/5964)\n  [#6087](https://github.com/bytecodealliance/wasmtime/pull/6087)\n\n\n--------------------------------------------------------------------------------\n\n## 7.0.1\n\nReleased 2023-04-27.\n\n### Fixed\n\n* Undefined Behavior in Rust runtime functions\n  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n\n--------------------------------------------------------------------------------\n\n## 7.0.0\n\nReleased 2023-03-20\n\n### Added\n\n* An initial implementation of the wasi-threads proposal has been implemented\n  and landed in the Wasmtime CLI. This is available behind a\n  `--wasi-modules experimental-wasi-threads` flag.\n  [#5484](https://github.com/bytecodealliance/wasmtime/pull/5484)\n\n* Support for WASI sockets has been added to the C API.\n  [#5624](https://github.com/bytecodealliance/wasmtime/pull/5624)\n\n* Support for limiting `Store`-based resource usage, such as memory, tables,\n  etc, has been added to the C API.\n  [#5761](https://github.com/bytecodealliance/wasmtime/pull/5761)\n\n* A top level alias of `anyhow::Result` as `wasmtime::Result` has been added to\n  avoid the need to explicitly depend on `anyhow`.\n  [#5853](https://github.com/bytecodealliance/wasmtime/pull/5853)\n\n* Initial support for the WebAssembly core dump format has been added to the CLI\n  with a `--coredump-on-trap` flag.\n  [#5868](https://github.com/bytecodealliance/wasmtime/pull/5868)\n\n### Changed\n\n* The `S` type parameter on component-related methods has been removed.\n  [#5722](https://github.com/bytecodealliance/wasmtime/pull/5722)\n\n* Selection of a `world` to bindgen has been updated to select any `default\n  world` in a WIT package if there is only one.\n  [#5779](https://github.com/bytecodealliance/wasmtime/pull/5779)\n\n* WASI preopened file descriptors can now be closed.\n  [#5828](https://github.com/bytecodealliance/wasmtime/pull/5828)\n\n* The host traits generated by the `bindgen!` macro are now always named `Host`,\n  but are still scoped to each individual module.\n  [#5890](https://github.com/bytecodealliance/wasmtime/pull/5890)\n\n### Fixed\n\n* Components which have `type` imports are now supported better and error/panic\n  in fewer cases.\n  [#5777](https://github.com/bytecodealliance/wasmtime/pull/5777)\n\n* Types referred to by `wasmtime::component::Val` are now reexported under\n  `wasmtime::component`.\n  [#5790](https://github.com/bytecodealliance/wasmtime/pull/5790)\n\n* A panic due to a race between `memory.atomic.{wait32,wait64,notify}`\n  instructions has been fixed.\n  [#5871](https://github.com/bytecodealliance/wasmtime/pull/5871)\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 6.0.2\n\nReleased 2023-04-27.\n\n### Fixed\n\n* Undefined Behavior in Rust runtime functions\n  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n\n--------------------------------------------------------------------------------\n\n## 6.0.1\n\nReleased 2023-03-08.\n\n### Fixed\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 6.0.0\n\nReleased 2023-02-20\n\n### Added\n\n* Wasmtime's built-in cache can now be disabled after being enabled previously.\n  [#5542](https://github.com/bytecodealliance/wasmtime/pull/5542)\n\n* Older x86\\_64 CPUs, without SSE4.1 for example, are now supported when the\n  wasm SIMD proposal is disabled.\n  [#5567](https://github.com/bytecodealliance/wasmtime/pull/5567)\n\n* The Wasmtime C API now has `WASMTIME_VERSION_*` macros defined in its header\n  files.\n  [#5651](https://github.com/bytecodealliance/wasmtime/pull/5651)\n\n* The `wasmtime` CLI executable as part of Wasmtime's precompiled release\n  artifacts now has the `all-arch` feature enabled.\n  [#5657](https://github.com/bytecodealliance/wasmtime/pull/5657)\n\n### Changed\n\n* Equality of `wasmtime::component::Val::Float{32,64}` now considers NaNs as\n  equal for assistance when fuzzing.\n  [#5535](https://github.com/bytecodealliance/wasmtime/pull/5535)\n\n* WIT syntax supported by `wasmtime::component::bindgen!` has been updated in\n  addition to the generated code being updated.\n  [#5565](https://github.com/bytecodealliance/wasmtime/pull/5565)\n  [#5692](https://github.com/bytecodealliance/wasmtime/pull/5692)\n  [#5694](https://github.com/bytecodealliance/wasmtime/pull/5694)\n\n* Cranelift's egraph-based optimization framework is now enabled by default.\n  [#5587](https://github.com/bytecodealliance/wasmtime/pull/5587)\n\n* The old `PoolingAllocationStrategy` type has been removed in favor of a more\n  flexible configuration via a new option\n  `PoolingAllocationConfig::max_unused_warm_slots` which is more flexible and\n  subsumes the previous use cases for each strategy.\n  [#5661](https://github.com/bytecodealliance/wasmtime/pull/5661)\n\n* Creation of `InstancePre` through `Linker::instantiate_pre` no longer requires\n  a `Store` to be provided. Instead a `Store`-related argument is now required\n  on `Linker::define`-style APIs instead.\n  [#5683](https://github.com/bytecodealliance/wasmtime/pull/5683)\n\n### Fixed\n\n* Compilation for FreeBSD on x86\\_64 and AArch64 has been fixed.\n  [#5606](https://github.com/bytecodealliance/wasmtime/pull/5606)\n\n--------------------------------------------------------------------------------\n\n## 5.0.1\n\nReleased 2023-03-08.\n\n### Fixed\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 5.0.0\n\nReleased 2023-01-20\n\n### Added\n\n* A `wasmtime::component::bingen!` macro has been added for generating bindings\n  from `*.wit` files. Note that WIT is still heavily in development so this is\n  more of a preview of what will be as opposed to a finished feature.\n  [#5317](https://github.com/bytecodealliance/wasmtime/pull/5317)\n  [#5397](https://github.com/bytecodealliance/wasmtime/pull/5397)\n\n* The `wasmtime settings` CLI command now has a `--json` option for\n  machine-readable output.\n  [#5411](https://github.com/bytecodealliance/wasmtime/pull/5411)\n\n* Wiggle-generated bindings can now generate the trait for either `&mut self` or\n  `&self`.\n  [#5428](https://github.com/bytecodealliance/wasmtime/pull/5428)\n\n* The `wiggle` crate has more convenience APIs for working with guest data\n  that resides in shared memory.\n  [#5471](https://github.com/bytecodealliance/wasmtime/pull/5471)\n  [#5475](https://github.com/bytecodealliance/wasmtime/pull/5475)\n\n### Changed\n\n* Cranelift's egraph support has been rewritten and updated. This functionality\n  is still gated behind a flag and may become the default in the next release.\n  [#5382](https://github.com/bytecodealliance/wasmtime/pull/5382)\n\n* The implementation of codegen for WebAssembly linear memory has changed\n  significantly internally in Cranelift, moving more responsibility to the\n  Wasmtime embedding rather than Cranelift itself. This should have no\n  user-visible change, however.\n  [#5386](https://github.com/bytecodealliance/wasmtime/pull/5386)\n\n* The `Val::Float32` and `Val::Float64` variants for components now store `f32`\n  and `f64` instead of the bit representation.\n  [#5510](https://github.com/bytecodealliance/wasmtime/pull/5510)\n\n### Fixed\n\n* Handling of DWARF debugging information in components with multiple modules\n  has been fixed to ensure the right info is used for each module.\n  [#5358](https://github.com/bytecodealliance/wasmtime/pull/5358)\n\n--------------------------------------------------------------------------------\n\n## 4.0.1\n\nReleased 2023-03-08.\n\n### Fixed\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 4.0.0\n\nReleased 2022-12-20\n\n### Added\n\n* Dynamic memories are now supported with the pooling instance allocator which\n  can possibly reduce the number of page faults throughout execution at the cost\n  of slower to run code. Page faults are primarily reduced by avoiding\n  releasing memory back to the system, relying on bounds checks to keep the\n  memory inaccessible.\n  [#5208](https://github.com/bytecodealliance/wasmtime/pull/5208)\n\n* The `wiggle` generator now supports function-level control over `tracing`\n  calls.\n  [#5194](https://github.com/bytecodealliance/wasmtime/pull/5194)\n\n* Support has been added to `wiggle` to be compatible with shared memories.\n  [#5225](https://github.com/bytecodealliance/wasmtime/pull/5225)\n  [#5229](https://github.com/bytecodealliance/wasmtime/pull/5229)\n  [#5264](https://github.com/bytecodealliance/wasmtime/pull/5264)\n  [#5268](https://github.com/bytecodealliance/wasmtime/pull/5268)\n  [#5054](https://github.com/bytecodealliance/wasmtime/pull/5054)\n\n* The `wiggle` generator now supports a \"trappable error\" configuration to\n  improve error conversions to guest errors and ensure that no host errors are\n  forgotten or accidentally become traps. The `wasi-common` crate has been\n  updated to use this.\n  [#5276](https://github.com/bytecodealliance/wasmtime/pull/5276)\n  [#5279](https://github.com/bytecodealliance/wasmtime/pull/5279)\n\n* The `memory.atomic.{notify,wait32,wait64}` instructions are now all\n  implemented in Wasmtime.\n  [#5255](https://github.com/bytecodealliance/wasmtime/pull/5255)\n  [#5311](https://github.com/bytecodealliance/wasmtime/pull/5311)\n\n* A `wasm_config_parallel_compilation_set` configuration function has been added\n  to the C API.\n  [#5298](https://github.com/bytecodealliance/wasmtime/pull/5298)\n\n* The `wasmtime` CLI can have its input module piped into it from stdin now.\n  [#5342](https://github.com/bytecodealliance/wasmtime/pull/5342)\n\n* `WasmBacktrace::{capture,force_capture}` methods have been added to\n  programmatically capture a backtrace outside of a trapping context.\n  [#5341](https://github.com/bytecodealliance/wasmtime/pull/5341)\n\n### Changed\n\n* The `S` type parameter on `Func::typed` and `Instance::get_typed_func` has\n  been removed and no longer needs to be specified.\n  [#5275](https://github.com/bytecodealliance/wasmtime/pull/5275)\n\n* The `SharedMemory::data` method now returns `&[UnsafeCell<u8>]` instead of the\n  prior raw slice return.\n  [#5240](https://github.com/bytecodealliance/wasmtime/pull/5240)\n\n* Creation of a `WasiCtx` will no longer unconditionally acquire randomness from\n  the OS, instead using the `rand::thread_rng()` function in Rust which is only\n  periodically reseeded with randomness from the OS.\n  [#5244](https://github.com/bytecodealliance/wasmtime/pull/5244)\n\n* Codegen of dynamically-bounds-checked wasm memory accesses has been improved.\n  [#5190](https://github.com/bytecodealliance/wasmtime/pull/5190)\n\n* Wasmtime will now emit inline stack probes in generated functions for x86\\_64,\n  aarch64, and riscv64 architectures. This guarantees a process abort if an\n  engine was misconfigured to give wasm too much stack instead of optionally\n  allowing wasm to skip the guard page.\n  [#5350](https://github.com/bytecodealliance/wasmtime/pull/5350)\n  [#5353](https://github.com/bytecodealliance/wasmtime/pull/5353)\n\n### Fixed\n\n* Dropping a `Module` will now release kernel resources in-use by the pooling\n  allocator when enabled instead of waiting for a new instance to be\n  re-instantiated into prior slots.\n  [#5321](https://github.com/bytecodealliance/wasmtime/pull/5321)\n\n--------------------------------------------------------------------------------\n\n## 3.0.1\n\nReleased 2022-12-01.\n\n### Fixed\n\n* The instruction cache is now flushed for AArch64 Android.\n  [#5331](https://github.com/bytecodealliance/wasmtime/pull/5331)\n\n* Building for FreeBSD and Android has been fixed.\n  [#5323](https://github.com/bytecodealliance/wasmtime/pull/5323)\n\n--------------------------------------------------------------------------------\n\n## 3.0.0\n\nReleased 2022-11-21\n\n### Added\n\n* New `WasiCtx::{push_file, push_dir}` methods exist for embedders to add their\n  own objects.\n  [#5027](https://github.com/bytecodealliance/wasmtime/pull/5027)\n\n* Wasmtime's `component-model` support now supports `async` host functions and\n  embedding in the same manner as core wasm.\n  [#5055](https://github.com/bytecodealliance/wasmtime/pull/5055)\n\n* The `wasmtime` CLI executable now supports a `--max-wasm-stack` flag.\n  [#5156](https://github.com/bytecodealliance/wasmtime/pull/5156)\n\n* AOT compilation support has been implemented for components (aka the\n  `component-model` feature of the Wasmtime crate).\n  [#5160](https://github.com/bytecodealliance/wasmtime/pull/5160)\n\n* A new `wasi_config_set_stdin_bytes` function is available in the C API to set\n  the stdin of a WASI-using module from an in-memory slice.\n  [#5179](https://github.com/bytecodealliance/wasmtime/pull/5179)\n\n* When using the pooling allocator there are now options to reset memory with\n  `memset` instead of `madvisev` on Linux to keep pages resident in memory to\n  reduce page faults when reusing linear memory slots.\n  [#5207](https://github.com/bytecodealliance/wasmtime/pull/5207)\n\n### Changed\n\n* Consuming 0 fuel with 0 fuel left is now considered to succeed. Additionally a\n  store may not consume its last unit of fuel.\n  [#5013](https://github.com/bytecodealliance/wasmtime/pull/5013)\n\n* A number of variants in the `wasi_common::ErrorKind` enum have been removed.\n  [#5015](https://github.com/bytecodealliance/wasmtime/pull/5015)\n\n* Methods on `WasiDir` now error-by-default instead of requiring a definition by\n  default.\n  [#5019](https://github.com/bytecodealliance/wasmtime/pull/5019)\n\n* Bindings generated by the `wiggle` crate now always depend on the `wasmtime`\n  crate meaning crates like `wasi-common` no longer compile for platforms such\n  as `wasm32-unknown-emscripten`.\n  [#5137](https://github.com/bytecodealliance/wasmtime/pull/5137)\n\n* Error handling in the `wasmtime` crate's API has been changed to primarily\n  work with `anyhow::Error` for custom errors. The `Trap` type has been replaced\n  with a simple `enum Trap { ... }` and backtrace information is now stored as a\n  `WasmBacktrace` type inserted as context into an `anyhow::Error`.\n  Host-functions are expected to return `anyhow::Result<T>` instead of the prior\n  `Trap` error return from before. Additionally the old `Trap::i32_exit`\n  constructor is now a concrete `wasi_commont::I32Exit` type which can be tested\n  for with a `downcast_ref` on the error returned from Wasmtime.\n  [#5149](https://github.com/bytecodealliance/wasmtime/pull/5149)\n\n* Configuration of the pooling allocator is now done through a builder-style\n  `PoolingAllocationConfig` API instead of the prior enum-variant API.\n  [#5205](https://github.com/bytecodealliance/wasmtime/pull/5205)\n\n### Fixed\n\n* The instruction cache is now properly flushed for AArch64 on Windows.\n  [#4997](https://github.com/bytecodealliance/wasmtime/pull/4997)\n\n* Backtrace capturing with many sequences of wasm->host calls on the stack no\n  longer exhibit quadratic capturing behavior.\n  [#5049](https://github.com/bytecodealliance/wasmtime/pull/5049)\n\n--------------------------------------------------------------------------------\n\n## 2.0.2\n\nReleased 2022-11-10.\n\n### Fixed\n\n* [CVE-2022-39392] - modules may perform out-of-bounds reads/writes when the\n  pooling allocator was configured with `memory_pages: 0`.\n\n* [CVE-2022-39393] - data can be leaked between instances when using the pooling\n  allocator.\n\n* [CVE-2022-39394] - An incorrect Rust signature for the C API\n  `wasmtime_trap_code` function could lead to an out-of-bounds write of three\n  zero bytes.\n\n[CVE-2022-39392]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-44mr-8vmm-wjhg\n[CVE-2022-39393]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf\n[CVE-2022-39394]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-h84q-m8rr-3v9q\n\n--------------------------------------------------------------------------------\n\n## 2.0.1\n\nReleased 2022-10-27.\n\n### Fixed\n\n* A compilation error when building only the `wasmtime` crate on Windows with\n  only the default features enabled has been fixed.\n  [#5134](https://github.com/bytecodealliance/wasmtime/pull/5134)\n\n### Changed\n\n* The `rayon` dependency added to `cranelift-isle` in 2.0.0 has been removed to\n  improve the compile time of the `cranelift-codegen` crate.\n  [#5101](https://github.com/bytecodealliance/wasmtime/pull/5101)\n\n--------------------------------------------------------------------------------\n\n## 2.0.0\n\nReleased 2022-10-20\n\n### Added\n\n* Cranelift has gained support for forward-edge CFI on the AArch64 backend.\n  [#3693](https://github.com/bytecodealliance/wasmtime/pull/3693)\n\n* A `--disable-parallel-compilation` CLI flag is now implemented for `wasmtime`.\n  [#4911](https://github.com/bytecodealliance/wasmtime/pull/4911)\n\n* [Tier 3] support has been added for for RISC-V 64 with a new backend in\n  Cranelift for this architecture.\n  [#4271](https://github.com/bytecodealliance/wasmtime/pull/4271)\n\n* Basic [tier 3] support for Windows ARM64 has been added but features such as\n  traps don't work at this time.\n  [#4990](https://github.com/bytecodealliance/wasmtime/pull/4990)\n\n### Changed\n\n* The implementation of the `random_get` function in `wasi-common` is now faster\n  by using a userspace CSPRNG rather than the OS for randomness.\n  [#4917](https://github.com/bytecodealliance/wasmtime/pull/4917)\n\n* The AArch64 backend has completed its transition to ISLE.\n  [#4851](https://github.com/bytecodealliance/wasmtime/pull/4851)\n  [#4866](https://github.com/bytecodealliance/wasmtime/pull/4866)\n  [#4898](https://github.com/bytecodealliance/wasmtime/pull/4898)\n  [#4884](https://github.com/bytecodealliance/wasmtime/pull/4884)\n  [#4820](https://github.com/bytecodealliance/wasmtime/pull/4820)\n  [#4913](https://github.com/bytecodealliance/wasmtime/pull/4913)\n  [#4942](https://github.com/bytecodealliance/wasmtime/pull/4942)\n  [#4943](https://github.com/bytecodealliance/wasmtime/pull/4943)\n\n* The size of the `sigaltstack` allocated per-thread for signal handling has\n  been increased from 16k to 64k.\n  [#4964](https://github.com/bytecodealliance/wasmtime/pull/4964)\n\n\n[Tier 3]: https://docs.wasmtime.dev/stability-tiers.html\n\n--------------------------------------------------------------------------------\n\n## 1.0.2\n\nReleased 2022-11-10.\n\n### Fixed\n\n* [CVE-2022-39392] - modules may perform out-of-bounds reads/writes when the\n  pooling allocator was configured with `memory_pages: 0`.\n\n* [CVE-2022-39393] - data can be leaked between instances when using the pooling\n  allocator.\n\n* [CVE-2022-39394] - An incorrect Rust signature for the C API\n  `wasmtime_trap_code` function could lead to an out-of-bounds write of three\n  zero bytes.\n\n--------------------------------------------------------------------------------\n\n## 1.0.1\n\nReleased 2022-09-26\n\nThis is a patch release that incorporates a fix for a miscompilation of an\natomic-CAS operator on aarch64. The instruction is not usable from Wasmtime\nwith default settings, but may be used if the Wasm atomics extension is\nenabled. The bug may also be reachable via other uses of Cranelift. Thanks to\n@bjorn3 for reporting and debugging this issue!\n\n### Fixed\n\n* Fixed a miscompilation of `atomic_cas` on aarch64. The output register was\n  swapped with a temporary register in the register-allocator constraints.\n  [#4959](https://github.com/bytecodealliance/wasmtime/pull/4959)\n  [#4960](https://github.com/bytecodealliance/wasmtime/pull/4960)\n\n--------------------------------------------------------------------------------\n\n## 1.0.0\n\nReleased 2022-09-20\n\nThis release marks the official 1.0 release of Wasmtime and represents the\nculmination of the work amongst over 300 contributors. Wasmtime has been\nbattle-tested in production through multiple embeddings for quite some time now\nand we're confident in releasing a 1.0 version to signify the stability and\nquality of the Wasmtime engine.\n\nMore information about Wasmtime's 1.0 release is on the [Bytecode Alliance's\nblog][ba-blog] with separate posts on [Wasmtime's performance\nfeatures][ba-perf], [Wasmtime's security story][ba-security], and [the 1.0\nrelease announcement][ba-1.0].\n\nAs a reminder the 2.0 release of Wasmtime is scheduled for one month from now on\nOctober 20th. For more information see the [RFC on Wasmtime's 1.0\nrelease][rfc-1.0].\n\n[ba-blog]: https://bytecodealliance.org/articles/\n[ba-perf]: https://bytecodealliance.org/articles/wasmtime-10-performance\n[ba-security]: https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime\n[ba-1.0]: https://bytecodealliance.org/articles/wasmtime-1-0-fast-safe-and-now-production-ready.md\n[rfc-1.0]: https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-one-dot-oh.md\n\n### Added\n\n* An incremental compilation cache for Cranelift has been added which can be\n  enabled with `Config::enable_incremental_compilation`, and this option is\n  disabled by default for now. The incremental compilation cache has been\n  measured to improve compile times for cold uncached modules as well due to\n  some wasm modules having similar-enough functions internally.\n  [#4551](https://github.com/bytecodealliance/wasmtime/pull/4551)\n\n* Source tarballs are now available as part of Wasmtime's release artifacts.\n  [#4294](https://github.com/bytecodealliance/wasmtime/pull/4294)\n\n* WASI APIs that specify the REALTIME clock are now supported.\n  [#4777](https://github.com/bytecodealliance/wasmtime/pull/4777)\n\n* WASI's socket functions are now fully implemented.\n  [#4776](https://github.com/bytecodealliance/wasmtime/pull/4776)\n\n* The native call stack for async-executed wasm functions are no longer\n  automatically reset to zero after the stack is returned to the pool when using\n  the pooling allocator. A `Config::async_stack_zeroing` option has been added\n  to restore the old behavior of zero-on-return-to-pool.\n  [#4813](https://github.com/bytecodealliance/wasmtime/pull/4813)\n\n* Inline stack probing has been implemented for the Cranelift x64 backend.\n  [#4747](https://github.com/bytecodealliance/wasmtime/pull/4747)\n\n### Changed\n\n* Generating of native unwind information has moved from a\n  `Config::wasm_backtrace` option to a new `Config::native_unwind_info` option\n  and is enabled by default.\n  [#4643](https://github.com/bytecodealliance/wasmtime/pull/4643)\n\n* The `memory-init-cow` feature is now enabled by default in the C API.\n  [#4690](https://github.com/bytecodealliance/wasmtime/pull/4690)\n\n* Back-edge CFI is now enabled by default on AArch64 macOS.\n  [#4720](https://github.com/bytecodealliance/wasmtime/pull/4720)\n\n* WASI calls will no longer return NOTCAPABLE in preparation for the removal of\n  the rights system from WASI.\n  [#4666](https://github.com/bytecodealliance/wasmtime/pull/4666)\n\n### Internal\n\nThis section of the release notes shouldn't affect external users since no\npublic-facing APIs are affected, but serves as a place to document larger\nchanges internally within Wasmtime.\n\n* Differential fuzzing has been refactored and improved into one fuzzing target\n  which can execute against any of Wasmtime itself (configured differently),\n  wasmi, V8, or the spec interpreter. Fuzzing now executes each exported\n  function with fuzz-generated inputs and the contents of all of memory and each\n  exported global is compared after each execution. Additionally more\n  interesting shapes of modules are also possible to generate.\n  [#4515](https://github.com/bytecodealliance/wasmtime/pull/4515)\n  [#4735](https://github.com/bytecodealliance/wasmtime/pull/4735)\n  [#4737](https://github.com/bytecodealliance/wasmtime/pull/4737)\n  [#4739](https://github.com/bytecodealliance/wasmtime/pull/4739)\n  [#4774](https://github.com/bytecodealliance/wasmtime/pull/4774)\n  [#4773](https://github.com/bytecodealliance/wasmtime/pull/4773)\n  [#4845](https://github.com/bytecodealliance/wasmtime/pull/4845)\n  [#4672](https://github.com/bytecodealliance/wasmtime/pull/4672)\n  [#4674](https://github.com/bytecodealliance/wasmtime/pull/4674)\n\n* The x64 backend for Cranelift has been fully migrated to ISLE.\n  [#4619](https://github.com/bytecodealliance/wasmtime/pull/4619)\n  [#4625](https://github.com/bytecodealliance/wasmtime/pull/4625)\n  [#4645](https://github.com/bytecodealliance/wasmtime/pull/4645)\n  [#4650](https://github.com/bytecodealliance/wasmtime/pull/4650)\n  [#4684](https://github.com/bytecodealliance/wasmtime/pull/4684)\n  [#4704](https://github.com/bytecodealliance/wasmtime/pull/4704)\n  [#4718](https://github.com/bytecodealliance/wasmtime/pull/4718)\n  [#4726](https://github.com/bytecodealliance/wasmtime/pull/4726)\n  [#4722](https://github.com/bytecodealliance/wasmtime/pull/4722)\n  [#4729](https://github.com/bytecodealliance/wasmtime/pull/4729)\n  [#4730](https://github.com/bytecodealliance/wasmtime/pull/4730)\n  [#4741](https://github.com/bytecodealliance/wasmtime/pull/4741)\n  [#4763](https://github.com/bytecodealliance/wasmtime/pull/4763)\n  [#4772](https://github.com/bytecodealliance/wasmtime/pull/4772)\n  [#4780](https://github.com/bytecodealliance/wasmtime/pull/4780)\n  [#4787](https://github.com/bytecodealliance/wasmtime/pull/4787)\n  [#4793](https://github.com/bytecodealliance/wasmtime/pull/4793)\n  [#4809](https://github.com/bytecodealliance/wasmtime/pull/4809)\n\n* The AArch64 backend for Cranelift has seen significant progress in being\n  ported to ISLE.\n  [#4608](https://github.com/bytecodealliance/wasmtime/pull/4608)\n  [#4639](https://github.com/bytecodealliance/wasmtime/pull/4639)\n  [#4634](https://github.com/bytecodealliance/wasmtime/pull/4634)\n  [#4748](https://github.com/bytecodealliance/wasmtime/pull/4748)\n  [#4750](https://github.com/bytecodealliance/wasmtime/pull/4750)\n  [#4751](https://github.com/bytecodealliance/wasmtime/pull/4751)\n  [#4753](https://github.com/bytecodealliance/wasmtime/pull/4753)\n  [#4788](https://github.com/bytecodealliance/wasmtime/pull/4788)\n  [#4796](https://github.com/bytecodealliance/wasmtime/pull/4796)\n  [#4785](https://github.com/bytecodealliance/wasmtime/pull/4785)\n  [#4819](https://github.com/bytecodealliance/wasmtime/pull/4819)\n  [#4821](https://github.com/bytecodealliance/wasmtime/pull/4821)\n  [#4832](https://github.com/bytecodealliance/wasmtime/pull/4832)\n\n* The s390x backend has seen improvements and additions to fully support the\n  Cranelift backend for rustc.\n  [#4682](https://github.com/bytecodealliance/wasmtime/pull/4682)\n  [#4702](https://github.com/bytecodealliance/wasmtime/pull/4702)\n  [#4616](https://github.com/bytecodealliance/wasmtime/pull/4616)\n  [#4680](https://github.com/bytecodealliance/wasmtime/pull/4680)\n\n* Significant improvements have been made to Cranelift-based fuzzing with more\n  supported features and more instructions being fuzzed.\n  [#4589](https://github.com/bytecodealliance/wasmtime/pull/4589)\n  [#4591](https://github.com/bytecodealliance/wasmtime/pull/4591)\n  [#4665](https://github.com/bytecodealliance/wasmtime/pull/4665)\n  [#4670](https://github.com/bytecodealliance/wasmtime/pull/4670)\n  [#4590](https://github.com/bytecodealliance/wasmtime/pull/4590)\n  [#4375](https://github.com/bytecodealliance/wasmtime/pull/4375)\n  [#4519](https://github.com/bytecodealliance/wasmtime/pull/4519)\n  [#4696](https://github.com/bytecodealliance/wasmtime/pull/4696)\n  [#4700](https://github.com/bytecodealliance/wasmtime/pull/4700)\n  [#4703](https://github.com/bytecodealliance/wasmtime/pull/4703)\n  [#4602](https://github.com/bytecodealliance/wasmtime/pull/4602)\n  [#4713](https://github.com/bytecodealliance/wasmtime/pull/4713)\n  [#4738](https://github.com/bytecodealliance/wasmtime/pull/4738)\n  [#4667](https://github.com/bytecodealliance/wasmtime/pull/4667)\n  [#4782](https://github.com/bytecodealliance/wasmtime/pull/4782)\n  [#4783](https://github.com/bytecodealliance/wasmtime/pull/4783)\n  [#4800](https://github.com/bytecodealliance/wasmtime/pull/4800)\n\n* Optimization work on cranelift has continued across various dimensions for\n  some modest compile-time improvements.\n  [#4621](https://github.com/bytecodealliance/wasmtime/pull/4621)\n  [#4701](https://github.com/bytecodealliance/wasmtime/pull/4701)\n  [#4697](https://github.com/bytecodealliance/wasmtime/pull/4697)\n  [#4711](https://github.com/bytecodealliance/wasmtime/pull/4711)\n  [#4710](https://github.com/bytecodealliance/wasmtime/pull/4710)\n  [#4829](https://github.com/bytecodealliance/wasmtime/pull/4829)\n\n--------------------------------------------------------------------------------\n\n## 0.40.0\n\nReleased 2022-08-20\n\nThis was a relatively quiet release in terms of user-facing features where most\nof the work was around the internals of Wasmtime and Cranelift. Improvements\ninternally have been made along the lines of:\n\n* Many more instructions are now implemented with ISLE instead of handwritten\n  lowerings.\n* Many improvements to the cranelift-based fuzzing.\n* Many platform improvements for s390x including full SIMD support, running\n  `rustc_codegen_cranelift` with features like `i128`, supporting more\n  ABIs, etc.\n* Much more of the component model has been implemented and is now fuzzed.\n\nFinally this release is currently scheduled to be the last `0.*` release of\nWasmtime. The upcoming release of Wasmtime on September 20 is planned to be\nWasmtime's 1.0 release. More information about what 1.0 means for Wasmtime is\navailable in the [1.0 RFC]\n\n[1.0 RFC]: https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-one-dot-oh.md\n\n### Added\n\n* Stack walking has been reimplemented with frame pointers rather than with\n  native unwind information. This means that backtraces are feasible to capture\n  in performance-critical environments and in general stack walking is much\n  faster than before.\n  [#4431](https://github.com/bytecodealliance/wasmtime/pull/4431)\n\n* The WebAssembly `simd` proposal is now fully implemented for the s390x\n  backend.\n  [#4427](https://github.com/bytecodealliance/wasmtime/pull/4427)\n\n* Support for AArch64 has been added in the experimental native debuginfo\n  support that Wasmtime has.\n  [#4468](https://github.com/bytecodealliance/wasmtime/pull/4468)\n\n* Support building the C API of Wasmtime with CMake has been added.\n  [#4369](https://github.com/bytecodealliance/wasmtime/pull/4369)\n\n* Clarification was added to Wasmtime's documentation about \"tiers of support\"\n  for various features.\n  [#4479](https://github.com/bytecodealliance/wasmtime/pull/4479)\n\n### Fixed\n\n* Support for `filestat_get` has been improved for stdio streams in WASI.\n  [#4531](https://github.com/bytecodealliance/wasmtime/pull/4531)\n\n* Enabling the `vtune` feature no longer breaks builds on AArch64.\n  [#4533](https://github.com/bytecodealliance/wasmtime/pull/4533)\n\n--------------------------------------------------------------------------------\n\n## 0.39.1\n\nReleased 2022-07-20.\n\n### Fixed\n\n* An s390x-specific codegen bug in addition to a mistake introduced in the fix\n  of CVE-2022-31146 were fixed.\n  [#4490](https://github.com/bytecodealliance/wasmtime/pull/4490)\n\n--------------------------------------------------------------------------------\n\n## 0.39.0\n\nReleased 2022-07-20\n\n### Added\n\n* Initial support for shared memories and the `threads` WebAssembly proposal\n  has been added. Note that this feature is still experimental and not ready\n  for production use yet.\n  [#4187](https://github.com/bytecodealliance/wasmtime/pull/4187)\n\n* A new `Linker::define_unknown_imports_as_traps` method and\n  `--trap-unknown-imports` CLI flag have been added to conveniently support\n  running modules with imports that aren't dynamically called at runtime.\n  [#4312](https://github.com/bytecodealliance/wasmtime/pull/4312)\n\n* The VTune profiling strategy can now be selected through the C API.\n  [#4316](https://github.com/bytecodealliance/wasmtime/pull/4316)\n\n### Changed\n\n* Some methods on the `Config` structure now return `&mut Self` instead of\n  `Result<&mut Self>` since the validation is deferred until `Engine::new`:\n  `profiler`, `cranelift_flag_enable`, `cranelift_flag_set`, `max_wasm_stack`,\n  `async_stack_size`, and `strategy`.\n  [#4252](https://github.com/bytecodealliance/wasmtime/pull/4252)\n  [#4262](https://github.com/bytecodealliance/wasmtime/pull/4262)\n\n* Parallel compilation of WebAssembly modules is now enabled in the C API by\n  default.\n  [#4270](https://github.com/bytecodealliance/wasmtime/pull/4270)\n\n* Implicit Cargo features of the `wasmtime` introduced through `optional`\n  dependencies may have been removed since namespaced features are now used.\n  It's recommended to only used the set of named `[features]` for Wasmtime.\n  [#4293](https://github.com/bytecodealliance/wasmtime/pull/4293)\n\n* Register allocation has fixed a few issues related to excessive memory usage\n  at compile time.\n  [#4324](https://github.com/bytecodealliance/wasmtime/pull/4324)\n\n### Fixed\n\n* A refactor of `Config` was made to fix an issue that the order of calls to `Config`\n  matters now, which may lead to unexpected behavior.\n  [#4252](https://github.com/bytecodealliance/wasmtime/pull/4252)\n  [#4262](https://github.com/bytecodealliance/wasmtime/pull/4262)\n\n* Wasmtime has been fixed to work on SSE2-only x86\\_64 platforms when the\n  `simd` feature is disabled in `Config`.\n  [#4231](https://github.com/bytecodealliance/wasmtime/pull/4231)\n\n* Generation of platform-specific unwinding information is disabled if\n  `wasm_backtrace` and `wasm_reference_types` are both disabled.\n  [#4351](https://github.com/bytecodealliance/wasmtime/pull/4351)\n\n--------------------------------------------------------------------------------\n\n## 0.38.3\n\nReleased 2022-07-20.\n\n### Fixed.\n\n* An s390x-specific codegen bug in addition to a mistake introduced in the fix\n  of CVE-2022-31146 were fixed.\n  [#4491](https://github.com/bytecodealliance/wasmtime/pull/4491)\n\n--------------------------------------------------------------------------------\n\n## 0.38.2\n\nReleased 2022-07-20.\n\n### Fixed.\n\n* A miscompilation when handling constant divisors on AArch64 has been fixed.\n  [CVE-2022-31169](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7f6x-jwh5-m9r4)\n\n* A use-after-free possible with accidentally missing stack maps has been fixed.\n  [CVE-2022-31146](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-5fhj-g3p3-pq9g)\n\n--------------------------------------------------------------------------------\n\n## 0.38.1\n\nReleased 2022-06-27.\n\n### Fixed.\n\n* A register allocator bug was fixed that could affect direct users of\n  Cranelift who use struct-return (`sret`) arguments. The bug had to do with\n  the handling of physical register constraints in the function prologue. No\n  impact should be possible for users of Cranelift via the Wasm frontend,\n  including Wasmtime.\n  [regalloc2#60](https://github.com/bytecodealliance/regalloc2/pull/60)\n  [#4333](https://github.com/bytecodealliance/wasmtime/pull/4333)\n\n* Lowering bugs for the `i8x16.swizzle` and `select`-with-`v128`-inputs\n  instructions were fixed for the x86\\_64 code generator. Note that aarch64 and\n  s390x are unaffected.\n  [#4334](https://github.com/bytecodealliance/wasmtime/pull/4334)\n\n* A bug in the 8-bit lowering of integer division on x86-64 was fixed in\n  Cranelift that could cause a register allocator panic due to an undefined\n  value in a register. (The divide instruction does not take a register `rdx`\n  as a source when 8 bits but the metadata incorrectly claimed it did.) No\n  impact on Wasm/Wasmtime users, and impact on direct Cranelift embedders\n  limited to compilation panics.\n  [#4332](https://github.com/bytecodealliance/wasmtime/pull/4332)\n\n--------------------------------------------------------------------------------\n\n## 0.38.0\n\nReleased 2022-06-21\n\n### Added\n\n* Enabling or disabling NaN canonicalization in generated code is now exposed\n  through the C API.\n  [#4154](https://github.com/bytecodealliance/wasmtime/pull/4154)\n\n* A user-defined callback can now be invoked when an epoch interruption happens\n  via the `Store::epoch_deadline_callback` API.\n  [#4152](https://github.com/bytecodealliance/wasmtime/pull/4152)\n\n* Basic alias analysis with redundant-load elimintation and store-to-load\n  forwarding optimizations has been added to Cranelift.\n  [#4163](https://github.com/bytecodealliance/wasmtime/pull/4163)\n\n### Changed\n\n* Traps originating from epoch-based interruption are now exposed as\n  `TrapCode::Interrupt`.\n  [#4105](https://github.com/bytecodealliance/wasmtime/pull/4105)\n\n* Binary builds for AArch64 now require glibc 2.17 and for s390x require glibc\n  2.16. Previously glibc 2.28 was required.\n  [#4171](https://github.com/bytecodealliance/wasmtime/pull/4171)\n\n* The `wasmtime::ValRaw` now has all of its fields listed as private and instead\n  constructors/accessors are provided for getting at the internal data.\n  [#4186](https://github.com/bytecodealliance/wasmtime/pull/4186)\n\n* The `wasm-backtrace` Cargo feature has been removed in favor of a\n  `Config::wasm_backtrace` runtime configuration option. Additionally backtraces\n  are now only captured when an embedder-generated trap actually reaches a\n  WebAssembly call stack.\n  [#4183](https://github.com/bytecodealliance/wasmtime/pull/4183)\n\n* Usage of `*_unchecked` APIs for `Func` in the `wasmtime` crate and C API now\n  take a `usize` parameter indicating the number of `ValRaw` values behind\n  the associated pointer.\n  [#4192](https://github.com/bytecodealliance/wasmtime/pull/4192)\n\n### Fixed\n\n* An improvement was made to the spill-slot allocation in code generation to fix\n  an issue where some stack slots accidentally weren't reused. This issue was\n  introduced with the landing of regalloc2 in 0.37.0 and may have resulted in\n  larger-than-intended increases in stack frame sizes.\n  [#4222](https://github.com/bytecodealliance/wasmtime/pull/4222)\n\n--------------------------------------------------------------------------------\n\n## 0.37.0\n\nReleased 2022-05-20\n\n### Added\n\n* Updated Cranelift to use regalloc2, a new register allocator. This should\n  result in ~20% faster compile times, and for programs that suffered from\n  register-allocation pressure before, up to ~20% faster generated code.\n  [#3989](https://github.com/bytecodealliance/wasmtime/pull/3989)\n\n* Pre-built binaries for macOS M1 machines are now available as release\n  artifacts.\n  [#3983](https://github.com/bytecodealliance/wasmtime/pull/3983)\n\n* Copy-on-write images of memory can now be manually initialized for a `Module`\n  with an explicit method call, but it is still not required to call this method\n  and will automatically otherwise happen on the first instantiation.\n  [#3964](https://github.com/bytecodealliance/wasmtime/pull/3964)\n\n### Fixed\n\n* Using `InstancePre::instantiate` or `Linker::instantiate` will now panic as\n  intended when used with an async-configured `Store`.\n  [#3972](https://github.com/bytecodealliance/wasmtime/pull/3972)\n\n### Changed\n\n* The unsafe `ValRaw` type in the `wasmtime` crate now always stores its values\n  in little-endian format instead of the prior native-endian format. Users of\n  `ValRaw` are recommended to audit their existing code for usage to continue\n  working on big-endian platforms.\n  [#4035](https://github.com/bytecodealliance/wasmtime/pull/4035)\n\n### Removed\n\n* Support for `Config::paged_memory_initialization` and the `uffd` crate feature\n  have been removed from the `wasmtime` crate. Users should migrate to using\n  `Config::memory_init_cow` which is more portable and faster at this point.\n  [#4040](https://github.com/bytecodealliance/wasmtime/pull/4040)\n\n--------------------------------------------------------------------------------\n\n## 0.36.0\n\nReleased 2022-04-20\n\n### Added\n\n* Support for epoch-based interruption has been added to the C API.\n  [#3925](https://github.com/bytecodealliance/wasmtime/pull/3925)\n\n* Support for disabling libunwind-based backtraces of WebAssembly code at\n  compile time has been added.\n  [#3932](https://github.com/bytecodealliance/wasmtime/pull/3932)\n\n* Async support for call hooks has been added to optionally execute \"blocking\"\n  work whenever a wasm module is entered or exited relative to the host.\n  [#3876](https://github.com/bytecodealliance/wasmtime/pull/3876)\n\n### Fixed\n\n* Loading a `Module` will now check, at runtime, that the compilation settings\n  enabled in a `Config` are compatible with the native host. For example this\n  ensures that if avx2 is enabled that the host actually has avx2 support.\n  [#3899](https://github.com/bytecodealliance/wasmtime/pull/3899)\n\n### Removed\n\n* Support for `Config::interruptable` and `InterruptHandle` has been removed\n  from the `wasmtime` crate. Users should migrate to using epoch-based\n  interruption instead.\n  [#3925](https://github.com/bytecodealliance/wasmtime/pull/3925)\n\n* The module linking implementation of Wasmtime has been removed to make room\n  for the upcoming support for the component model.\n  [#3958](https://github.com/bytecodealliance/wasmtime/pull/3958)\n\n--------------------------------------------------------------------------------\n\n## 0.35.3\n\nReleased 2022-04-11.\n\n### Fixed\n\n* Backported a bugfix for an instruction lowering issue that could cause a\n  regalloc panic due to an undefined register in some cases. No miscompilation\n  was ever possible, but panics would result in a compilation failure.\n  [#4012](https://github.com/bytecodealliance/wasmtime/pull/4012)\n\n--------------------------------------------------------------------------------\n\n## 0.35.2\n\nReleased 2022-03-31.\n\n### Security Fixes\n\n* [CVE-2022-24791](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2):\n  Fixed a use after free with `externref`s and epoch interruption.\n\n## 0.35.1\n\nReleased 2022-03-09.\n\n### Fixed\n\n* Fixed a bug in the x86-64 lowering of the `uextend` opcode for narrow (`i8`,\n  `i16`) integer sources when the value is produced by one of several\n  arithmetic instructions.\n  [#3906](https://github.com/bytecodealliance/wasmtime/pull/3906)\n\n## 0.35.0\n\nReleased 2022-03-07.\n\n### Added\n\n* The `wasmtime_wasi::add_to_linker` function now allows providing\n  a context object of a custom type instead of `wasmtime_wasi::WasiCtx`,\n  as long as that type implements the required WASI snapshot traits.\n  This allows, for example, wrapping `WasiCtx` into a struct and providing\n  custom implementations for those traits to override the default behaviour.\n\n### Changed\n\n* WebAssembly tables of `funcref` values are now lazily initialized which can,\n  in some cases, greatly speed up instantiation of a module.\n  [#3733](https://github.com/bytecodealliance/wasmtime/pull/3733)\n\n* The `memfd` feature in 0.34.0, now renamed to `memory-init-cow`, has been\n  enabled by default. This means that, where applicable, WebAssembly linear\n  memories are now initialized with copy-on-write mappings. Support from this\n  has been expanded from Linux-only to include macOS and other Unix systems when\n  modules are loaded from precompiled `*.cwasm` files on disk.\n  [#3777](https://github.com/bytecodealliance/wasmtime/pull/3777)\n  [#3778](https://github.com/bytecodealliance/wasmtime/pull/3778)\n  [#3787](https://github.com/bytecodealliance/wasmtime/pull/3787)\n  [#3819](https://github.com/bytecodealliance/wasmtime/pull/3819)\n  [#3831](https://github.com/bytecodealliance/wasmtime/pull/3831)\n\n* Clarify that SSE 4.2 (and prior) is required for running WebAssembly code with\n  simd support enabled on x86\\_64.\n  [#3816](https://github.com/bytecodealliance/wasmtime/pull/3816)\n  [#3817](https://github.com/bytecodealliance/wasmtime/pull/3817)\n  [#3833](https://github.com/bytecodealliance/wasmtime/pull/3833)\n  [#3825](https://github.com/bytecodealliance/wasmtime/pull/3825)\n\n* Support for profiling with VTune is now enabled at compile time by default,\n  but it remains disabled at runtime by default.\n  [#3821](https://github.com/bytecodealliance/wasmtime/pull/3821)\n\n* The `ModuleLimits` type has been removed from the configuration of the pooling\n  allocator in favor of configuring the total size of an instance allocation\n  rather than each individual field.\n  [#3837](https://github.com/bytecodealliance/wasmtime/pull/3837)\n\n* The native stack size allowed for WebAssembly has been decreased from 1 MiB to\n  512 KiB on all platforms to better accomodate running wasm on the main thread\n  on Windows.\n  [#3861](https://github.com/bytecodealliance/wasmtime/pull/3861)\n\n* The `wasi-common` crate now supports doing polls for both read and write\n  interest on a file descriptor at the same time.\n  [#3866](https://github.com/bytecodealliance/wasmtime/pull/3866)\n\n### Fixed\n\n* The `Store::call_hook` callback is now invoked when entering host functions\n  defined with `*_unchecked` variants.\n  [#3881](https://github.com/bytecodealliance/wasmtime/pull/3881)\n\n### Removed\n\n* The incomplete and unmaintained ARM32 backend has been removed from Cranelift.\n  [#3799](https://github.com/bytecodealliance/wasmtime/pull/3799)\n\n--------------------------------------------------------------------------------\n\n## 0.34.2\n\nReleased 2022-03-31.\n\n### Security Fixes\n\n* [CVE-2022-24791](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2):\n  Fixed a use after free with `externref`s and epoch interruption.\n\n## 0.34.1\n\nReleased 2022-02-16.\n\n### Security Fixes\n\n* [CVE-2022-23636](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-88xq-w8cq-xfg7):\n  Fixed an invalid drop of a partially-initialized instance in the pooling instance\n  allocator.\n\n## 0.33.1\n\nReleased 2022-02-16.\n\n### Security Fixes\n\n* [CVE-2022-23636](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-88xq-w8cq-xfg7):\n  Fixed an invalid drop of a partially-initialized instance in the pooling instance\n  allocator.\n\n## 0.34.0\n\nReleased 2022-02-07.\n\n### Fixed\n\n* The `wasi-common` default implementation of some attributes of files has been\n  updated to ensure that `wasi-libc`'s `isatty` function works as intended.\n  [#3696](https://github.com/bytecodealliance/wasmtime/pull/3696)\n\n* A benign debug assertion related to `externref` and garbage-collection has\n  been fixed.\n  [#3734](https://github.com/bytecodealliance/wasmtime/pull/3734)\n\n### Added\n\n* Function names are now automatically demangled when informing profilers of\n  regions of JIT code to apply Rust-specific demangling rules if applicable.\n  [#3683](https://github.com/bytecodealliance/wasmtime/pull/3683)\n\n* Support for profiling JIT-generated trampolines with VTune has been added.\n  [#3687](https://github.com/bytecodealliance/wasmtime/pull/3687)\n\n* Wasmtime now supports a new method of async preemption dubbed \"epoch-based\n  interruption\" which is intended to be much more efficient than the current\n  fuel-based method of preemption.\n  [#3699](https://github.com/bytecodealliance/wasmtime/pull/3699)\n\n* On Linux Wasmtime will now by default use copy-on-write mappings to initialize\n  memories of wasm modules where possible, accelerating instantiation by\n  avoiding costly memory copies. When combined with the pooling allocator this\n  can also be used to speed up instance-reuse cases due to fewer syscalls to\n  change memory mappings being necessary.\n  [#3697](https://github.com/bytecodealliance/wasmtime/pull/3697)\n  [#3738](https://github.com/bytecodealliance/wasmtime/pull/3738)\n  [#3760](https://github.com/bytecodealliance/wasmtime/pull/3760)\n\n* Wasmtime now supports the recently-added `sock_accept` WASI function.\n  [#3711](https://github.com/bytecodealliance/wasmtime/pull/3711)\n\n* Cranelift now has support for specifying blocks as cold.\n  [#3698](https://github.com/bytecodealliance/wasmtime/pull/3698)\n\n### Changed\n\n* Many more instructions for the x64 backend have been migrated to ISLE,\n  additionally with refactorings to make incorrect lowerings harder to\n  accidentally write.\n  [#3653](https://github.com/bytecodealliance/wasmtime/pull/3653)\n  [#3659](https://github.com/bytecodealliance/wasmtime/pull/3659)\n  [#3681](https://github.com/bytecodealliance/wasmtime/pull/3681)\n  [#3686](https://github.com/bytecodealliance/wasmtime/pull/3686)\n  [#3688](https://github.com/bytecodealliance/wasmtime/pull/3688)\n  [#3690](https://github.com/bytecodealliance/wasmtime/pull/3690)\n  [#3752](https://github.com/bytecodealliance/wasmtime/pull/3752)\n\n* More instructions in the aarch64 backend are now lowered with ISLE.\n  [#3658](https://github.com/bytecodealliance/wasmtime/pull/3658)\n  [#3662](https://github.com/bytecodealliance/wasmtime/pull/3662)\n\n* The s390x backend's lowering rules are now almost entirely defined with ISLE.\n  [#3702](https://github.com/bytecodealliance/wasmtime/pull/3702)\n  [#3703](https://github.com/bytecodealliance/wasmtime/pull/3703)\n  [#3706](https://github.com/bytecodealliance/wasmtime/pull/3706)\n  [#3717](https://github.com/bytecodealliance/wasmtime/pull/3717)\n  [#3723](https://github.com/bytecodealliance/wasmtime/pull/3723)\n  [#3724](https://github.com/bytecodealliance/wasmtime/pull/3724)\n\n* Instantiation of modules in Wasmtime has been further optimized now that the\n  copy-on-write memory initialization removed the previously most-expensive part\n  of instantiating a module.\n  [#3727](https://github.com/bytecodealliance/wasmtime/pull/3727)\n  [#3739](https://github.com/bytecodealliance/wasmtime/pull/3739)\n  [#3741](https://github.com/bytecodealliance/wasmtime/pull/3741)\n  [#3742](https://github.com/bytecodealliance/wasmtime/pull/3742)\n\n--------------------------------------------------------------------------------\n\n## 0.33.0\n\nReleased 2022-01-05.\n\n### Added\n\n* Compiled wasm modules may now optionally omit debugging information about\n  mapping addresses to source locations, resulting in smaller binaries.\n  [#3598](https://github.com/bytecodealliance/wasmtime/pull/3598)\n\n* The WebAssembly SIMD proposal is now enabled by default.\n  [#3601](https://github.com/bytecodealliance/wasmtime/pull/3601)\n\n--------------------------------------------------------------------------------\n\n## 0.32.1\n\nReleased 2022-01-04.\n\n### Fixed\n\n* Cranelift: remove recently-added build dependency on `sha2` to allow usage in\n  some dependency-sensitive environments, by computing ISLE manifest hashes\n  with a different hash function.\n  [#3619](https://github.com/bytecodealliance/wasmtime/pull/3619)\n\n* Cranelift: fixed 8- and 16-bit behavior of popcount (bit population count)\n  instruction. Does not affect Wasm frontend.\n  [#3617](https://github.com/bytecodealliance/wasmtime/pull/3617)\n\n* Cranelift: fixed miscompilation of 8- and 16-bit bit-rotate instructions.\n  Does not affect Wasm frontend.\n  [#3610](https://github.com/bytecodealliance/wasmtime/pull/3610)\n\n--------------------------------------------------------------------------------\n\n## 0.32.0\n\nReleased 2021-12-13.\n\n### Added\n\n* A new configuration option has been added to force using a \"static\" memory\n  style to automatically limit growth of memories in some configurations.\n  [#3503](https://github.com/bytecodealliance/wasmtime/pull/3503)\n\n* The `InstancePre<T>` type now implements `Clone`.\n  [#3510](https://github.com/bytecodealliance/wasmtime/pull/3510)\n\n* Cranelift's instruction selection process has begun to be migrated towards the\n  ISLE compiler and definition language.\n  [#3506](https://github.com/bytecodealliance/wasmtime/pull/3506)\n\n* A `pooling-allocator` feature has been added, which is on-by-default, to\n  disable the pooling allocator at compile time.\n  [#3514](https://github.com/bytecodealliance/wasmtime/pull/3514)\n\n### Fixed\n\n* A possible panic when parsing a WebAssembly `name` section has been fixed.\n  [#3509](https://github.com/bytecodealliance/wasmtime/pull/3509)\n\n* Generating native DWARF information for some C-produced modules has been\n  fixed, notably those where there may be DWARF about dead code.\n  [#3498](https://github.com/bytecodealliance/wasmtime/pull/3498)\n\n* A number of SIMD code generation bugs have been fixed in the x64 backend\n  by migrating their lowerings to ISLE.\n\n--------------------------------------------------------------------------------\n\n## 0.31.0\n\nReleased 2021-10-29.\n\n### Added\n\n* New `Func::new_unchecked` and `Func::call_unchecked` APIs have been added with\n  accompanying functions in the C API to improve the performance of calls into\n  wasm and the host in the C API.\n  [#3350](https://github.com/bytecodealliance/wasmtime/pull/3350)\n\n* Release binaries are now available for the s390x-unknown-linux-gnu\n  architecture.\n  [#3372](https://github.com/bytecodealliance/wasmtime/pull/3372)\n\n* A new `ResourceLimiterAsync` trait is added which allows asynchronous blocking\n  of WebAssembly on instructions such as `memory.grow`.\n  [#3393](https://github.com/bytecodealliance/wasmtime/pull/3393)\n\n### Changed\n\n* The `Func::call` method now takes a slice to write the results into rather\n  than returning a boxed slice.\n  [#3319](https://github.com/bytecodealliance/wasmtime/pull/3319)\n\n* Trampolines are now covered when jitdump profiling is enabled.\n  [#3344](https://github.com/bytecodealliance/wasmtime/pull/3344)\n\n### Fixed\n\n* Debugging with GDB has been fixed on Windows.\n  [#3373](https://github.com/bytecodealliance/wasmtime/pull/3373)\n\n* Some quadradic behavior in Wasmtime's compilation of modules has been fixed.\n  [#3469](https://github.com/bytecodealliance/wasmtime/pull/3469)\n  [#3466](https://github.com/bytecodealliance/wasmtime/pull/3466)\n\n* Bounds-checks for wasm memory accesses in certain non-default configurations\n  have been fixed to correctly allow loads at the end of the address space.\n  [#3462](https://github.com/bytecodealliance/wasmtime/pull/3462)\n\n* When type-checking memories and tables for satisfying instance imports the\n  runtime size of the table/memory is now consulted instead of the object's\n  original type.\n  [#3450](https://github.com/bytecodealliance/wasmtime/pull/3450)\n\n### Removed\n\n* The Lightbeam backend has been removed, as per [RFC 14].\n  [#3390](https://github.com/bytecodealliance/wasmtime/pull/3390)\n\n[RFC 14]: https://github.com/bytecodealliance/rfcs/pull/14\n\n* Cranelift's old x86 backend has been removed, as per [RFC 12].\n  [#3309](https://github.com/bytecodealliance/wasmtime/pull/3009)\n\n[RFC 12]: https://github.com/bytecodealliance/rfcs/pull/12\n\n## 0.30.0\n\nReleased 2021-09-17.\n\n### Security Fixes\n\n* [CVE-2021-39216](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf):\n  Fixed a use after free passing `externref`s to Wasm in Wasmtime.\n\n* [CVE-2021-39218](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49):\n  Fixed an out-of-bounds read/write and invalid free with `externref`s and GC\n  safepoints in Wasmtime.\n\n* [CVE-2021-39219](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx):\n  Fixed a bug where using two different `Engine`s with the same `Linker`-define\n  functions caused unsafety without `unsafe` blocks.\n\n### Added\n\n* Added experimental support for the in-progress 64-bit memories Wasm proposal.\n\n* Added support to build Wasmtime without the compiler. This lets you run\n  pre-compiled Wasm modules, without the ability (or potential attack surface)\n  of compiling new Wasm modules. The compilation functionality is gated by the\n  on-by-default `cranelift` cargo feature.\n\n* Added support for NaN canonicalization with SIMD vectors.\n\n* Added support for differential fuzzing against V8's Wasm engine.\n\n* Added support for fuzzing against the Wasm spec interpreter.\n\n* Enabled SIMD fuzzing on oss-fuzz.\n\n### Changed\n\n* A variety of performance improvements to loading pre-compiled modules.\n\n* A variety of performance improvements to function calls, both through Rust and\n  the C API.\n\n* Leaf functions that do not use the stack no longer bump the frame pointer on\n  aarch64 and s390x.\n\n* Many updates and expanded instruction support to the in-progress CLIF\n  interpreter.\n\n* Expanded fuzzing of reference types and GC.\n\n### Fixed\n\n* A number of fixes to both aarch64 and x86_64 support for the Wasm SIMD\n  proposal and the underlying CLIF vector instructions.\n\n* Fixed a potential infinite loop in the SSA computation for\n  `cranelift-frontend`. This was not reachable from `cranelift-wasm` or\n  Wasmtime, but might have affected general Cranelift users.\n\n### Removed\n\n* The `wasmtime wasm2obj` subcommand has been removed. Generating raw object\n  files for linking natively is no longer supported. Use the `wasmtime compile`\n  subcommand to pre-compile a Wasm module and `wasmtime run` to run pre-compiled\n  Wasm modules.\n\n## 0.29.0\n\nReleased 2021-08-02.\n\n### Changed\n\n* Instance exports are now loaded lazily from instances instead of eagerly as\n  they were before. This is an internal-only change and is not a breaking\n  change.\n  [#2984](https://github.com/bytecodealliance/wasmtime/pull/2984)\n\n* All linear memories created by Wasmtime will now, by default, have guard pages\n  in front of them in addition to after them. This is intended to help mitigate\n  future bugs in Cranelift, should they arise.\n  [#2977](https://github.com/bytecodealliance/wasmtime/pull/2977)\n\n* Linear memories now correctly support a maximum size of 4GB. Previously, the\n  limit field was 32 bits, which did not properly support a full 4GB memory.\n  This update is also a necessary change in preparation for future memory64\n  support.\n  [#3013](https://github.com/bytecodealliance/wasmtime/pull/3013)\n  [#3134](https://github.com/bytecodealliance/wasmtime/pull/3134)\n\n* Injection counts of fuel into a `wasmtime::Store` now uses a u64 instead of a\n  u32.\n  [#3048](https://github.com/bytecodealliance/wasmtime/pull/3048)\n\n### Added\n\n* Support for `i128` has improved in the AArch64 backend.\n  [#2959](https://github.com/bytecodealliance/wasmtime/pull/2959)\n  [#2975](https://github.com/bytecodealliance/wasmtime/pull/2975)\n  [#2985](https://github.com/bytecodealliance/wasmtime/pull/2985)\n  [#2990](https://github.com/bytecodealliance/wasmtime/pull/2990)\n  [#3002](https://github.com/bytecodealliance/wasmtime/pull/3002)\n  [#3004](https://github.com/bytecodealliance/wasmtime/pull/3004)\n  [#3005](https://github.com/bytecodealliance/wasmtime/pull/3005)\n  [#3008](https://github.com/bytecodealliance/wasmtime/pull/3008)\n  [#3027](https://github.com/bytecodealliance/wasmtime/pull/3027)\n\n* The s390x backend now supports z14 and atomics.\n  [#2988](https://github.com/bytecodealliance/wasmtime/pull/2988)\n  [#2991](https://github.com/bytecodealliance/wasmtime/pull/2991)\n\n* The `wasmtime::Linker` type now implements `Clone`.\n  [#2993](https://github.com/bytecodealliance/wasmtime/pull/2993)\n\n* Support for the SIMD proposal on both x86\\_64 and AArch64 has improved. On\n  x86\\_64, all SIMD opcodes are now supported.\n  [#2997](https://github.com/bytecodealliance/wasmtime/pull/2997)\n  [#3035](https://github.com/bytecodealliance/wasmtime/pull/3035)\n  [#2982](https://github.com/bytecodealliance/wasmtime/pull/2982)\n  [#3084](https://github.com/bytecodealliance/wasmtime/pull/3084)\n  [#3082](https://github.com/bytecodealliance/wasmtime/pull/3082)\n  [#3107](https://github.com/bytecodealliance/wasmtime/pull/3107)\n  [#3105](https://github.com/bytecodealliance/wasmtime/pull/3105)\n  [#3114](https://github.com/bytecodealliance/wasmtime/pull/3114)\n  [#3070](https://github.com/bytecodealliance/wasmtime/pull/3070)\n  [#3126](https://github.com/bytecodealliance/wasmtime/pull/3126)\n\n* A `Trap` can now display its reason without also displaying the backtrace.\n  [#3033](https://github.com/bytecodealliance/wasmtime/pull/3033)\n\n* An initiall fuzzer for CLIF has been added.\n  [#3038](https://github.com/bytecodealliance/wasmtime/pull/3038)\n\n* High-level architecture documentation has been added for Wasmtime.\n  [#3019](https://github.com/bytecodealliance/wasmtime/pull/3019)\n\n* Support for multi-memory can now be configured in Wasmtime's C API.\n  [#3071](https://github.com/bytecodealliance/wasmtime/pull/3071)\n\n* The `wasmtime` crate now supports a `posix-signals-on-macos` feature to force\n  the usage of signals instead of mach ports to handle traps on macOS.\n  [#3063](https://github.com/bytecodealliance/wasmtime/pull/3063)\n\n* Wasmtime's C API now has a `wasmtime_trap_code` function to get the raw trap\n  code, if present, for a trap.\n  [#3086](https://github.com/bytecodealliance/wasmtime/pull/3086)\n\n* Wasmtime's C API now has a `wasmtime_linker_define_func` function to define a\n  store-independent function within a linker.\n  [#3122](https://github.com/bytecodealliance/wasmtime/pull/3122)\n\n* A `wasmtime::Linker::module_async` function was added as the asynchronous\n  counterpart to `wasmtime::Linker::module`.\n  [#3121](https://github.com/bytecodealliance/wasmtime/pull/3121)\n\n### Fixed\n\n* Compiling the `wasmtime` crate into a `dylib` crate type has been fixed.\n  [#3010](https://github.com/bytecodealliance/wasmtime/pull/3010)\n\n* The enter/exit hooks for WebAssembly are now executed for an instance's\n  `start` function, if present.\n  [#3001](https://github.com/bytecodealliance/wasmtime/pull/3001)\n\n* Some WASI functions in `wasi-common` have been fixed for big-endian platforms.\n  [#3016](https://github.com/bytecodealliance/wasmtime/pull/3016)\n\n* Wasmtime no longer erroneously assumes that all custom sections may contain\n  DWARF information, reducing instances of `Trap`'s `Display` implementation\n  providing misleading information to set an env var to get more information.\n  [#3083](https://github.com/bytecodealliance/wasmtime/pull/3083)\n\n* Some issues with parsing DWARF debug information have been fixed.\n  [#3116](https://github.com/bytecodealliance/wasmtime/pull/3116)\n\n## 0.28.0\n\nReleased 2021-06-09.\n\n### Changed\n\n* Breaking: Wasmtime's embedding API has been redesigned, as specified in [RFC\n  11]. Rust users can now enjoy easier times with `Send` and `Sync`, and all\n  users can now more clearly manage memory, especially in the C API. Language\n  embeddings have been updated to the new API as well.\n  [#2897](https://github.com/bytecodealliance/wasmtime/pull/2897)\n\n[RFC 11]: https://github.com/bytecodealliance/rfcs/pull/11\n\n### Added\n\n* A new `InstancePre` type, created with `Linker::instantiate_pre`, has been\n  added to perform type-checking of an instance once and reduce the work done\n  for each instantiation of a module:\n  [#2962](https://github.com/bytecodealliance/wasmtime/pull/2962)\n\n* Deserialization of a module can now optionally skip checking the wasmtime\n  version string:\n  [#2945](https://github.com/bytecodealliance/wasmtime/pull/2945)\n\n* A method has been exposed to frontload per-thread initialization costs if the\n  latency of every last wasm call is important:\n  [#2946](https://github.com/bytecodealliance/wasmtime/pull/2946)\n\n* Hooks have been added for entry/exit into wasm code to allow embeddings to\n  track time and other properties about execution in a wasm environment:\n  [#2952](https://github.com/bytecodealliance/wasmtime/pull/2952)\n\n* A [C++ embedding of Wasmtime has been written][cpp].\n\n[RFC 11]: https://github.com/bytecodealliance/rfcs/pull/11\n[cpp]: https://github.com/bytecodealliance/wasmtime-cpp\n\n### Fixed\n\n* Multiple returns on macOS AArch64 have been fixed:\n  [#2956](https://github.com/bytecodealliance/wasmtime/pull/2956)\n\n## 0.27.0\n\nReleased 2021-05-21.\n\n### Security Fixes\n\n* Fixed a security issue in Cranelift's x64 backend that could result in a heap\n  sandbox escape due to an incorrect sign-extension:\n  [#2913](https://github.com/bytecodealliance/wasmtime/issues/2913).\n\n### Added\n\n* Support for IBM z/Archiecture (`s390x`) machines in Cranelift and Wasmtime:\n  [#2836](https://github.com/bytecodealliance/wasmtime/pull/2836),\n  [#2837](https://github.com/bytecodealliance/wasmtime/pull/2837),\n  [#2838](https://github.com/bytecodealliance/wasmtime/pull/2838),\n  [#2843](https://github.com/bytecodealliance/wasmtime/pull/2843),\n  [#2854](https://github.com/bytecodealliance/wasmtime/pull/2854),\n  [#2870](https://github.com/bytecodealliance/wasmtime/pull/2870),\n  [#2871](https://github.com/bytecodealliance/wasmtime/pull/2871),\n  [#2872](https://github.com/bytecodealliance/wasmtime/pull/2872),\n  [#2874](https://github.com/bytecodealliance/wasmtime/pull/2874).\n\n* Improved async support in wasi-common runtime:\n  [#2832](https://github.com/bytecodealliance/wasmtime/pull/2832).\n\n* Added `Store::with_limits`, `StoreLimits`, and `ResourceLimiter` to the\n  Wasmtime API to help with enforcing resource limits at runtime. The\n  `ResourceLimiter` trait can be implemented by custom resource limiters to\n  decide if linear memories or tables can be grown.\n\n* Added `allow-unknown-exports` option for the run command:\n  [#2879](https://github.com/bytecodealliance/wasmtime/pull/2879).\n\n* Added API to notify that a `Store` has moved to a new thread:\n  [#2822](https://github.com/bytecodealliance/wasmtime/pull/2822).\n\n* Documented guidance around using Wasmtime in multithreaded contexts:\n  [#2812](https://github.com/bytecodealliance/wasmtime/pull/2812).\n  In the future, the Wasmtime API will change to allow some of its core types\n  to be Send/Sync; see the in-progress\n  [#2897](https://github.com/bytecodealliance/wasmtime/pull/2897) for details.\n\n* Support calls from native code to multiple-return-value functions:\n  [#2806](https://github.com/bytecodealliance/wasmtime/pull/2806).\n\n### Changed\n\n* Breaking: `Memory::new` has been changed to return `Result` as creating a\n  host memory object is now a fallible operation when the initial size of\n  the memory exceeds the store limits.\n\n### Fixed\n\n* Many instruction selection improvements on x64 and aarch64:\n  [#2819](https://github.com/bytecodealliance/wasmtime/pull/2819),\n  [#2828](https://github.com/bytecodealliance/wasmtime/pull/2828),\n  [#2823](https://github.com/bytecodealliance/wasmtime/pull/2823),\n  [#2862](https://github.com/bytecodealliance/wasmtime/pull/2862),\n  [#2886](https://github.com/bytecodealliance/wasmtime/pull/2886),\n  [#2889](https://github.com/bytecodealliance/wasmtime/pull/2889),\n  [#2905](https://github.com/bytecodealliance/wasmtime/pull/2905).\n\n* Improved performance of Wasmtime runtime substantially:\n  [#2811](https://github.com/bytecodealliance/wasmtime/pull/2811),\n  [#2818](https://github.com/bytecodealliance/wasmtime/pull/2818),\n  [#2821](https://github.com/bytecodealliance/wasmtime/pull/2821),\n  [#2847](https://github.com/bytecodealliance/wasmtime/pull/2847),\n  [#2900](https://github.com/bytecodealliance/wasmtime/pull/2900).\n\n* Fixed WASI issue with file metadata on Windows:\n  [#2884](https://github.com/bytecodealliance/wasmtime/pull/2884).\n\n* Fixed an issue with debug info and an underflowing (trapping) offset:\n  [#2866](https://github.com/bytecodealliance/wasmtime/pull/2866).\n\n* Fixed an issue with unwind information in the old x86 backend:\n  [#2845](https://github.com/bytecodealliance/wasmtime/pull/2845).\n\n* Fixed i32 spilling in x64 backend:\n  [#2840](https://github.com/bytecodealliance/wasmtime/pull/2840).\n\n## 0.26.0\n\nReleased 2021-04-05.\n\n### Added\n\n* Added the `wasmtime compile` command to support AOT compilation of Wasm\n  modules. This adds the `Engine::precompile_module` method. Also added the\n  `Config::target` method to change the compilation target of the\n  configuration. This can be used in conjunction with\n  `Engine::precompile_module` to target a different host triple than the\n  current one.\n  [#2791](https://github.com/bytecodealliance/wasmtime/pull/2791)\n\n* Support for macOS on aarch64 (Apple M1 Silicon), including Apple-specific\n  calling convention details and unwinding/exception handling using Mach ports.\n  [#2742](https://github.com/bytecodealliance/wasmtime/pull/2742),\n  [#2723](https://github.com/bytecodealliance/wasmtime/pull/2723)\n\n* A number of SIMD instruction implementations in the new x86-64 backend.\n  [#2771](https://github.com/bytecodealliance/wasmtime/pull/2771)\n\n* Added the `Config::cranelift_flag_enable` method to enable setting Cranelift\n  boolean flags or presets in a config.\n\n* Added CLI option `--cranelift-enable` to enable boolean settings and ISA presets.\n\n* Deduplicate function signatures in Wasm modules.\n  [#2772](https://github.com/bytecodealliance/wasmtime/pull/2772)\n\n* Optimize overheads of calling into Wasm functions.\n  [#2757](https://github.com/bytecodealliance/wasmtime/pull/2757),\n  [#2759](https://github.com/bytecodealliance/wasmtime/pull/2759)\n\n* Improvements related to Module Linking: compile fewer trampolines;\n\n  [#2774](https://github.com/bytecodealliance/wasmtime/pull/2774)\n\n* Re-export sibling crates from `wasmtime-wasi` to make embedding easier\n  without needing to match crate versions.\n  [#2776](https://github.com/bytecodealliance/wasmtime/pull/2776)\n\n### Changed\n\n* Switched the default compiler backend on x86-64 to Cranelift's new backend.\n  This should not have any user-visible effects other than possibly runtime\n  performance improvements. The old backend is still available with the\n  `old-x86-backend` feature flag to the `cranelift-codegen` or `wasmtime`\n  crates, or programmatically with `BackendVariant::Legacy`. We plan to\n  maintain the old backend for at least one more release and ensure it works on\n  CI.\n  [#2718](https://github.com/bytecodealliance/wasmtime/pull/2718)\n\n* Breaking: `Module::deserialize` has been removed in favor of `Module::new`.\n\n* Breaking: `Config::cranelift_clear_cpu_flags` was removed. Use `Config::target`\n  to clear the CPU flags for the host's target.\n\n* Breaking: `Config::cranelift_other_flag` was renamed to `Config::cranelift_flag_set`.\n\n* CLI changes:\n  * Wasmtime CLI options to enable WebAssembly features have been replaced with\n    a singular `--wasm-features` option. The previous options are still\n    supported, but are not displayed in help text.\n  * Breaking: the CLI option `--cranelift-flags` was changed to\n    `--cranelift-set`.\n  * Breaking: the CLI option `--enable-reference-types=false` has been changed\n    to `--wasm-features=-reference-types`.\n  * Breaking: the CLI option `--enable-multi-value=false` has been changed to\n    `--wasm-features=-multi-value`.\n  * Breaking: the CLI option `--enable-bulk-memory=false` has been changed to\n    `--wasm-features=-bulk-memory`.\n\n* Improved error-reporting in wiggle.\n  [#2760](https://github.com/bytecodealliance/wasmtime/pull/2760)\n\n* Make WASI sleeping fallible (some systems do not support sleep).\n  [#2756](https://github.com/bytecodealliance/wasmtime/pull/2756)\n\n* WASI: Support `poll_oneoff` with a sleep.\n  [#2753](https://github.com/bytecodealliance/wasmtime/pull/2753)\n\n* Allow a `StackMapSink` to be passed when defining functions with\n  `cranelift-module`.\n  [#2739](https://github.com/bytecodealliance/wasmtime/pull/2739)\n\n* Some refactoring in new x86-64 backend to prepare for VEX/EVEX (e.g.,\n  AVX-512) instruction encodings to be supported.\n  [#2799](https://github.com/bytecodealliance/wasmtime/pull/2799)\n\n### Fixed\n\n* Fixed a corner case in `srem` (signed remainder) in the new x86-64 backend:\n  `INT_MIN % -1` should return `0`, rather than trapping. This only occurred\n  when `avoid_div_traps == false` was set by the embedding.\n  [#2763](https://github.com/bytecodealliance/wasmtime/pull/2763)\n\n* Fixed a memory leak of the `Store` when an instance traps.\n  [#2803](https://github.com/bytecodealliance/wasmtime/pull/2803)\n\n* Some fuzzing-related fixes.\n  [#2788](https://github.com/bytecodealliance/wasmtime/pull/2788),\n  [#2770](https://github.com/bytecodealliance/wasmtime/pull/2770)\n\n* Fixed memory-initialization bug in uffd allocator that could copy into the\n  wrong destination under certain conditions. Does not affect the default\n  wasmtime instance allocator.\n  [#2801](https://github.com/bytecodealliance/wasmtime/pull/2801)\n\n* Fix printing of float values from the Wasmtime CLI.\n  [#2797](https://github.com/bytecodealliance/wasmtime/pull/2797)\n\n* Remove the ability for the `Linker` to instantiate modules with duplicate\n  import strings of different types.\n  [#2789](https://github.com/bytecodealliance/wasmtime/pull/2789)\n\n## 0.25.0\n\nReleased 2021-03-16.\n\n### Added\n\n* An implementation of a pooling instance allocator, optionally backed by\n  `userfaultfd` on Linux, was added to improve the performance of embeddings\n  that instantiate a large number of instances continuously.\n  [#2518](https://github.com/bytecodealliance/wasmtime/pull/2518)\n\n* Host functions can now be defined on `Config` to share the function across all\n  `Store` objects connected to an `Engine`. This can improve the time it takes\n  to instantiate instances in a short-lived `Store`.\n  [#2625](https://github.com/bytecodealliance/wasmtime/pull/2625)\n\n* The `Store` object now supports having typed values attached to it which can\n  be retrieved from host functions.\n  [#2625](https://github.com/bytecodealliance/wasmtime/pull/2625)\n\n* The `wiggle` code generator now supports `async` host functions.\n  [#2701](https://github.com/bytecodealliance/wasmtime/pull/2701)\n\n### Changed\n\n* The `Func::getN{,_async}` APIs have all been removed in favor of a new\n  `Func::typed` API which should be more compact in terms of API surface area as\n  well as more flexible in how it can be used.\n  [#2719](https://github.com/bytecodealliance/wasmtime/pull/2719)\n\n* `Engine::new` has been changed from returning `Engine` to returning\n  `anyhow::Result<Engine>`. Callers of `Engine::new` will need to be updated to\n  use the `?` operator on the return value or otherwise unwrap the result to get\n  the `Engine`.\n\n### Fixed\n\n* Interpretation of timestamps in `poll_oneoff` for WASI have been fixed to\n  correctly use nanoseconds instead of microseconds.\n  [#2717](https://github.com/bytecodealliance/wasmtime/pull/2717)\n\n## 0.24.0\n\nReleased 2021-03-04.\n\n### Added\n\n* Implement support for `async` functions in Wasmtime\n  [#2434](https://github.com/bytecodealliance/wasmtime/pull/2434)\n\n### Fixed\n\n* Fix preservation of the sigaltstack on macOS\n  [#2676](https://github.com/bytecodealliance/wasmtime/pull/2676)\n* Fix incorrect semver dependencies involving fs-set-times.\n  [#2705](https://github.com/bytecodealliance/wasmtime/pull/2705)\n* Fix some `i128` shift-related bugs in x64 backend.\n  [#2682](https://github.com/bytecodealliance/wasmtime/pull/2682)\n* Fix incomplete trap metadata due to multiple traps at one address\n  [#2685](https://github.com/bytecodealliance/wasmtime/pull/2685)\n\n## 0.23.0\n\nReleased 2021-02-16.\n\n### Added\n\n* Support for limiting WebAssembly execution with fuel was added, including\n  support in the C API.\n  [#2611](https://github.com/bytecodealliance/wasmtime/pull/2611)\n  [#2643](https://github.com/bytecodealliance/wasmtime/pull/2643)\n* Wasmtime now has more knobs for limiting memory and table allocations\n  [#2617](https://github.com/bytecodealliance/wasmtime/pull/2617)\n* Added a method to share `Config` across machines\n  [#2608](https://github.com/bytecodealliance/wasmtime/pull/2608)\n* Added a safe memory read/write API\n  [#2528](https://github.com/bytecodealliance/wasmtime/pull/2528)\n* Added support for the experimental wasi-crypto APIs\n  [#2597](https://github.com/bytecodealliance/wasmtime/pull/2597)\n* Added an instance limit to `Config`\n  [#2593](https://github.com/bytecodealliance/wasmtime/pull/2593)\n* Implemented module-linking's outer module aliases\n  [#2590](https://github.com/bytecodealliance/wasmtime/pull/2590)\n* Cranelift now supports 128-bit operations for the new x64 backend.\n  [#2539](https://github.com/bytecodealliance/wasmtime/pull/2539)\n* Cranelift now has detailed debug-info (DWARF) support in new backends (initially x64).\n  [#2565](https://github.com/bytecodealliance/wasmtime/pull/2565)\n* Cranelift now uses the `POPCNT`, `TZCNT`, and `LZCNT`, as well as SSE 4.1\n  rounding instructions on x64 when available.\n* Cranelift now uses the `CNT`, instruction on aarch64 when available.\n\n### Changed\n\n* A new WASI implementation built on the new\n  [`cap-std`](https://github.com/bytecodealliance/cap-std) crate was added,\n  replacing the previous implementation. This brings improved robustness,\n  portability, and performance.\n\n* `wasmtime_wasi::WasiCtxBuilder` moved to\n  `wasi_cap_std_sync::WasiCtxBuilder`.\n\n* The WebAssembly C API is updated, with a few minor API changes\n  [#2579](https://github.com/bytecodealliance/wasmtime/pull/2579)\n\n### Fixed\n\n* Fixed a panic in WASI `fd_readdir` on large directories\n  [#2620](https://github.com/bytecodealliance/wasmtime/pull/2620)\n* Fixed a memory leak with command modules\n  [#2017](https://github.com/bytecodealliance/wasmtime/pull/2017)\n\n--------------------------------------------------------------------------------\n\n## 0.22.0\n\nReleased 2021-01-07.\n\n### Added\n\n* Experimental support for [the module-linking\n  proposal](https://github.com/WebAssembly/module-linking) was\n  added. [#2094](https://github.com/bytecodealliance/wasmtime/pull/2094)\n\n* Added support for [the reference types\n  proposal](https://webassembly.github.io/reference-types) on the aarch64\n  architecture. [#2410](https://github.com/bytecodealliance/wasmtime/pull/2410)\n\n* Experimental support for [wasi-nn](https://github.com/WebAssembly/wasi-nn) was\n  added. [#2208](https://github.com/bytecodealliance/wasmtime/pull/2208)\n\n### Changed\n\n### Fixed\n\n* Fixed an issue where the `select` instruction didn't accept `v128` SIMD\n  operands. [#2391](https://github.com/bytecodealliance/wasmtime/pull/2391)\n\n* Fixed an issue where Wasmtime could potentially use the wrong stack map during\n  GCs, leading to a\n  panic. [#2396](https://github.com/bytecodealliance/wasmtime/pull/2396)\n\n* Fixed an issue where if a host-defined function erroneously returned a value\n  from a different store, that value would be\n  leaked. [#2424](https://github.com/bytecodealliance/wasmtime/pull/2424)\n\n* Fixed a bug where in certain cases if a module's instantiation failed, it\n  could leave trampolines in the store that referenced the no-longer-valid\n  instance. These trampolines could be reused in future instantiations, leading\n  to use after free bugs.\n  [#2408](https://github.com/bytecodealliance/wasmtime/pull/2408)\n\n* Fixed a miscompilation on aarch64 where certain instructions would read `SP`\n  instead of the zero register. This could only affect you if you explicitly\n  enabled the Wasm SIMD\n  proposal. [#2548](https://github.com/bytecodealliance/wasmtime/pull/2548)\n\n--------------------------------------------------------------------------------\n\n## 0.21.0\n\nReleased 2020-11-05.\n\n### Added\n\n* Experimental support for the multi-memory proposal was added.\n  [#2263](https://github.com/bytecodealliance/wasmtime/pull/2263)\n\n* The `Trap::trap_code` API enables learning what kind of trap was raised.\n  [#2309](https://github.com/bytecodealliance/wasmtime/pull/2309)\n\n### Changed\n\n* WebAssembly module validation is now parallelized.\n  [#2059](https://github.com/bytecodealliance/wasmtime/pull/2059)\n\n* Documentation is now available at docs.wasmtime.dev.\n  [#2317](https://github.com/bytecodealliance/wasmtime/pull/2317)\n\n* Windows now compiles like other platforms with a huge guard page instead of\n  having its own custom limit which made modules compile and run more slowly.\n  [#2326](https://github.com/bytecodealliance/wasmtime/pull/2326)\n\n* The size of the cache entry for serialized modules has been greatly reduced.\n  [#2321](https://github.com/bytecodealliance/wasmtime/pull/2321)\n  [#2322](https://github.com/bytecodealliance/wasmtime/pull/2322)\n  [#2324](https://github.com/bytecodealliance/wasmtime/pull/2324)\n  [#2325](https://github.com/bytecodealliance/wasmtime/pull/2325)\n\n* The `FuncType` API constructor and accessors are now iterator-based.\n  [#2365](https://github.com/bytecodealliance/wasmtime/pull/2365)\n\n### Fixed\n\n* A panic in compiling reference-types-using modules has been fixed.\n  [#2350](https://github.com/bytecodealliance/wasmtime/pull/2350)\n\n--------------------------------------------------------------------------------\n\n## 0.20.0\n\nReleased 2020-09-23.\n\n### Added\n\n* Support for explicitly serializing and deserializing compiled wasm modules has\n  been added.\n  [#2020](https://github.com/bytecodealliance/wasmtime/pull/2020)\n\n* A `wasmtime_store_gc` C API was added to run GC for `externref`.\n  [#2052](https://github.com/bytecodealliance/wasmtime/pull/2052)\n\n* Support for atomics in Cranelift has been added. Support is not fully\n  implemented in Wasmtime at this time, however.\n  [#2077](https://github.com/bytecodealliance/wasmtime/pull/2077)\n\n* The `Caller::get_export` function is now implemented for `Func` references as\n  well.\n  [#2108](https://github.com/bytecodealliance/wasmtime/pull/2108)\n\n### Fixed\n\n* Leaks in the C API have been fixed.\n  [#2040](https://github.com/bytecodealliance/wasmtime/pull/2040)\n\n* The `wasm_val_copy` C API has been fixed for reference types.\n  [#2041](https://github.com/bytecodealliance/wasmtime/pull/2041)\n\n* Fix a panic with `Func::new` and reference types when the store doesn't have\n  reference types enabled.\n  [#2039](https://github.com/bytecodealliance/wasmtime/pull/2039)\n\n--------------------------------------------------------------------------------\n\n## 0.19.0\n\nReleased 2020-07-14.\n\n### Added\n\n* The [WebAssembly reference-types proposal][reftypes] is now supported in\n  Wasmtime and the C API.\n  [#1832](https://github.com/bytecodealliance/wasmtime/pull/1832),\n  [#1882](https://github.com/bytecodealliance/wasmtime/pull/1882),\n  [#1894](https://github.com/bytecodealliance/wasmtime/pull/1894),\n  [#1901](https://github.com/bytecodealliance/wasmtime/pull/1901),\n  [#1923](https://github.com/bytecodealliance/wasmtime/pull/1923),\n  [#1969](https://github.com/bytecodealliance/wasmtime/pull/1969),\n  [#1973](https://github.com/bytecodealliance/wasmtime/pull/1973),\n  [#1982](https://github.com/bytecodealliance/wasmtime/pull/1982),\n  [#1984](https://github.com/bytecodealliance/wasmtime/pull/1984),\n  [#1991](https://github.com/bytecodealliance/wasmtime/pull/1991),\n  [#1996](https://github.com/bytecodealliance/wasmtime/pull/1996)\n\n* The [WebAssembly simd proposal's][simd] spec tests now pass in Wasmtime.\n  [#1765](https://github.com/bytecodealliance/wasmtime/pull/1765),\n  [#1876](https://github.com/bytecodealliance/wasmtime/pull/1876),\n  [#1941](https://github.com/bytecodealliance/wasmtime/pull/1941),\n  [#1957](https://github.com/bytecodealliance/wasmtime/pull/1957),\n  [#1990](https://github.com/bytecodealliance/wasmtime/pull/1990),\n  [#1994](https://github.com/bytecodealliance/wasmtime/pull/1994)\n\n* Wasmtime can now be compiled without the usage of threads for parallel\n  compilation, although this is still enabled by default.\n  [#1903](https://github.com/bytecodealliance/wasmtime/pull/1903)\n\n* The C API is [now\n  documented](https://bytecodealliance.github.io/wasmtime/c-api/).\n  [#1928](https://github.com/bytecodealliance/wasmtime/pull/1928),\n  [#1959](https://github.com/bytecodealliance/wasmtime/pull/1959),\n  [#1968](https://github.com/bytecodealliance/wasmtime/pull/1968)\n\n* A `wasmtime_linker_get_one_by_name` function was added to the C API.\n  [#1897](https://github.com/bytecodealliance/wasmtime/pull/1897)\n\n* A `wasmtime_trap_exit_status` function was added to the C API.\n  [#1912](https://github.com/bytecodealliance/wasmtime/pull/1912)\n\n* Compilation for the `aarch64-linux-android` target should now work, although\n  keep in mind this platform is not fully tested still.\n  [#2002](https://github.com/bytecodealliance/wasmtime/pull/2002)\n\n[reftypes]: https://github.com/WebAssembly/reference-types\n\n### Fixed\n\n* Runtime warnings when using Wasmtime on musl have been fixed.\n  [#1914](https://github.com/bytecodealliance/wasmtime/pull/1914)\n\n* A bug affecting Windows unwind information with functions that have spilled\n  floating point registers has been fixed.\n  [#1983](https://github.com/bytecodealliance/wasmtime/pull/1983)\n\n### Changed\n\n* Wasmtime's default branch and development now happens on the `main` branch\n  instead of `master`.\n  [#1924](https://github.com/bytecodealliance/wasmtime/pull/1924)\n\n### Removed\n\n* The \"host info\" support in the C API has been removed since it was never fully\n  or correctly implemented.\n  [#1922](https://github.com/bytecodealliance/wasmtime/pull/1922)\n\n* Support for the `*_same` functions in the C API has been removed in the same\n  vein as the host info APIs.\n  [#1926](https://github.com/bytecodealliance/wasmtime/pull/1926)\n\n--------------------------------------------------------------------------------\n\n## 0.18.0\n\nRelease 2020-06-09.\n\n### Added\n\nThe `WasmTy` trait is now implemented for `u32` and `u64`.\n\n  [#1808](https://github.com/bytecodealliance/wasmtime/pull/1808)\n\n--------------------------------------------------------------------------------\n\n## 0.17.0\n\nReleased 2020-06-01.\n\n### Added\n\n* The [Commands and Reactors ABI] is now supported in the Rust API. `Linker::module`\n  loads a module and automatically handles Commands and Reactors semantics.\n\n  [#1565](https://github.com/bytecodealliance/wasmtime/pull/1565)\n\n[Commands and Reactors ABI]: https://github.com/WebAssembly/WASI/blob/master/design/application-abi.md#current-unstable-abi\n\nThe `Table::grow` function now returns the previous table size, making it consistent\nwith the `table.grow` instruction.\n\n  [#1653](https://github.com/bytecodealliance/wasmtime/pull/1653)\n\nNew Wasmtime-specific C APIs for working with tables were added which provide more\ndetailed error information and which make growing a table more consistent with the\n`table.grow` instruction as well.\n\n  [#1654](https://github.com/bytecodealliance/wasmtime/pull/1654)\n\nThe C API now includes support for enabling logging in Wasmtime.\n\n  [#1737](https://github.com/bytecodealliance/wasmtime/pull/1737)\n\n### Changed\n\nThe WASI `proc_exit` function no longer exits the host process. It now unwinds the\ncallstack back to the wasm entrypoint, and the exit value is available from the\n`Trap::i32_exit_status` method.\n\n  [#1646](https://github.com/bytecodealliance/wasmtime/pull/1646)\n\nThe WebAssembly [multi-value](https://github.com/WebAssembly/multi-value/) proposal\nis now enabled by default.\n\n  [#1667](https://github.com/bytecodealliance/wasmtime/pull/1667)\n\nThe Rust API does not require a store provided during `Module::new` operation. The `Module` can be send accross threads and instantiate for a specific store. The `Instance::new` now requires the store.\n\n  [#1761](https://github.com/bytecodealliance/wasmtime/pull/1761)\n\n--------------------------------------------------------------------------------\n\n## 0.16.0\n\nReleased 2020-04-29.\n\n### Added\n\n* The `Instance` struct has new accessors, `get_func`, `get_table`,\n  `get_memory`, and `get_global` for quickly looking up exported\n  functions, tables, memories, and globals by name.\n  [#1524](https://github.com/bytecodealliance/wasmtime/pull/1524)\n\n* The C API has a number of new `wasmtime_*` functions which return error\n  objects to get detailed error information when an API fails.\n  [#1467](https://github.com/bytecodealliance/wasmtime/pull/1467)\n\n* Users now have fine-grained control over creation of instances of `Memory`\n  with a new `MemoryCreator` trait.\n  [#1400](https://github.com/bytecodealliance/wasmtime/pull/1400)\n\n* Go bindings for Wasmtime are [now available][go-bindings].\n  [#1481](https://github.com/bytecodealliance/wasmtime/pull/1481)\n\n* APIs for looking up values in a `Linker` have been added.\n  [#1480](https://github.com/bytecodealliance/wasmtime/pull/1480)\n\n* Preliminary support for AArch64, also known as ARM64.\n  [#1581](https://github.com/bytecodealliance/wasmtime/pull/1581)\n\n[go-bindings]: https://github.com/bytecodealliance/wasmtime-go\n\n### Changed\n\n* `Instance::exports` now returns `Export` objects which contain\n  the `name`s of the exports in addition to their `Extern` definitions,\n  so it's no longer necessary to use `Module::exports` to obtain the\n  export names.\n  [#1524](https://github.com/bytecodealliance/wasmtime/pull/1524)\n\n* The `Func::call` API has changed its error type from `Trap` to `anyhow::Error`\n  to distinguish between wasm traps and runtime violations (like the wrong\n  number of parameters).\n  [#1467](https://github.com/bytecodealliance/wasmtime/pull/1467)\n\n* A number of `wasmtime_linker_*` and `wasmtime_config_*` C APIs have new type\n  signatures which reflect returning errors.\n  [#1467](https://github.com/bytecodealliance/wasmtime/pull/1467)\n\n* Bindings for .NET have moved to\n  https://github.com/bytecodealliance/wasmtime-dotnet.\n  [#1477](https://github.com/bytecodealliance/wasmtime/pull/1477)\n\n* Passing too many imports to `Instance::new` is now considered an error.\n  [#1478](https://github.com/bytecodealliance/wasmtime/pull/1478)\n\n### Fixed\n\n* Spurious segfaults due to out-of-stack conditions when handling signals have\n  been fixed.\n  [#1315](https://github.com/bytecodealliance/wasmtime/pull/1315)\n\n--------------------------------------------------------------------------------\n\n## 0.15.0\n\nReleased 2020-03-31.\n\n### Fixed\n\nFull release produced for all artifacts to account for hiccups in 0.13.0 and\n0.14.0.\n\n--------------------------------------------------------------------------------\n\n## 0.14.0\n\n*This version ended up not getting a full release*\n\n### Fixed\n\nFix build errors in wasi-common on Windows.\n\n--------------------------------------------------------------------------------\n\n## 0.13.0\n\nReleased 2020-03-24.\n\n### Added\n\n* Lots of documentation of `wasmtime` has been updated. Be sure to check out the\n  [book](https://bytecodealliance.github.io/wasmtime/) and [API\n  documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/)!\n\n* All wasmtime example programs are now in a top-level `examples` directory and\n  are available in both C and Rust.\n  [#1286](https://github.com/bytecodealliance/wasmtime/pull/1286)\n\n* A `wasmtime::Linker` type was added to conveniently link link wasm modules\n  together and create instances that reference one another.\n  [#1384](https://github.com/bytecodealliance/wasmtime/pull/1384)\n\n* Wasmtime now has \"jitdump\" support enabled by default which allows [profiling\n  wasm code on linux][jitdump].\n  [#1310](https://github.com/bytecodealliance/wasmtime/pull/1310)\n\n* The `wasmtime::Caller` type now exists as a first-class way to access the\n  caller's exports, namely memory, when implementing host APIs. This can be the\n  first argument of functions defined with `Func::new` or `Func::wrap` which\n  allows easily implementing methods which take a pointer into wasm memory. Note\n  that this only works for accessing the caller's `Memory` for now and it must\n  be exported. This will eventually be replaced with a more general-purpose\n  mechanism like interface types.\n  [#1290](https://github.com/bytecodealliance/wasmtime/pull/1290)\n\n* The bulk memory proposal has been fully implemented.\n  [#1264](https://github.com/bytecodealliance/wasmtime/pull/1264)\n  [#976](https://github.com/bytecodealliance/wasmtime/pull/976)\n\n* Virtual file support has been added to `wasi-common`.\n  [#701](https://github.com/bytecodealliance/wasmtime/pull/701)\n\n* The C API has been enhanced with a Wasmtime-specific `wasmtime_wat2wasm` to\n  parse `*.wat` files via the C API.\n  [#1206](https://github.com/bytecodealliance/wasmtime/pull/1206)\n\n[jitdump]: https://bytecodealliance.github.io/wasmtime/examples-profiling.html\n\n### Changed\n\n* The `wast` and `wasm2obj` standalone binaries have been removed. They're\n  available via the `wasmtime wast` and `wasmtime wasm2obj` subcommands.\n  [#1372](https://github.com/bytecodealliance/wasmtime/pull/1372)\n\n* The `wasi-common` crate now uses the new `wiggle` crate to auto-generate a\n  trait which is implemented for the current wasi snapshot.\n  [#1202](https://github.com/bytecodealliance/wasmtime/pull/1202)\n\n* Wasmtime no longer has a dependency on a C++ compiler.\n  [#1365](https://github.com/bytecodealliance/wasmtime/pull/1365)\n\n* The `Func::wrapN` APIs have been consolidated into one `Func::wrap` API.\n  [#1363](https://github.com/bytecodealliance/wasmtime/pull/1363)\n\n* The `Callable` trait has been removed and now `Func::new` takes a closure\n  directly.\n  [#1363](https://github.com/bytecodealliance/wasmtime/pull/1363)\n\n* The Cranelift repository has been merged into the Wasmtime repository.\n\n* Support for interface types has been temporarily removed.\n  [#1292](https://github.com/bytecodealliance/wasmtime/pull/1292)\n\n* The exit code of the `wasmtime` CLI has changed if the program traps.\n  [#1274](https://github.com/bytecodealliance/wasmtime/pull/1274)\n\n* The `wasmtime` CLI now logs to stderr by default and the `-d` flag has been\n  renamed to `--log-to-file`.\n  [#1266](https://github.com/bytecodealliance/wasmtime/pull/1266)\n\n* Values cannot cross `Store` objects, meaning you can't instantiate a module\n  with values from different stores nor pass values from different stores into\n  methods.\n  [#1016](https://github.com/bytecodealliance/wasmtime/pull/1016)\n\n--------------------------------------------------------------------------------\n\n## 0.12.0\n\nReleased 2020-02-26.\n\n### Added\n\n* Support for the [WebAssembly text annotations proposal][annotations-proposal]\n  has been added.\n  [#998](https://github.com/bytecodealliance/wasmtime/pull/998)\n\n* An initial C API for instantiating WASI modules has been added.\n  [#977](https://github.com/bytecodealliance/wasmtime/pull/977)\n\n* A new suite of `Func::getN` functions have been added to the `wasmtime` API to\n  call statically-known function signatures in a highly optimized fashion.\n  [#955](https://github.com/bytecodealliance/wasmtime/pull/955)\n\n* Initial support for profiling JIT code through perf jitdump has been added.\n  [#360](https://github.com/bytecodealliance/wasmtime/pull/360)\n\n* More CLI flags corresponding to proposed WebAssembly features have been added.\n  [#917](https://github.com/bytecodealliance/wasmtime/pull/917)\n\n[annotations-proposal]: https://github.com/webassembly/annotations\n\n### Changed\n\n* The `wasmtime` CLI as well as embedding API will optimize WebAssembly code by\n  default now.\n  [#973](https://github.com/bytecodealliance/wasmtime/pull/973)\n  [#988](https://github.com/bytecodealliance/wasmtime/pull/988)\n\n* The `verifier` pass in Cranelift is now no longer run by default when using\n  the embedding API.\n  [#882](https://github.com/bytecodealliance/wasmtime/pull/882)\n\n### Fixed\n\n* Code caching now accurately accounts for optimization levels, ensuring that if\n  you ask for optimized code you're not accidentally handed unoptimized code\n  from the cache.\n  [#974](https://github.com/bytecodealliance/wasmtime/pull/974)\n\n* Automated releases for tags should be up and running again, along with\n  automatic publication of the `wasmtime` Python package.\n  [#971](https://github.com/bytecodealliance/wasmtime/pull/971)\n", ";; x86-64 instruction selection and CLIF-to-MachInst lowering.\n\n;; The main lowering constructor term: takes a clif `Inst` and returns the\n;; register(s) within which the lowered instruction's result values live.\n(decl partial lower (Inst) InstOutput)\n\n;; A variant of the main lowering constructor term, used for branches.\n;; The only difference is that it gets an extra argument holding a vector\n;; of branch targets to be used.\n(decl partial lower_branch (Inst MachLabelSlice) Unit)\n\n;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n(rule (lower (has_type (fits_in_64 ty)\n                       (iconst (u64_from_imm64 x))))\n      (imm ty x))\n\n;; `i128`\n(rule 1 (lower (has_type $I128\n                       (iconst (u64_from_imm64 x))))\n      (value_regs (imm $I64 x)\n                  (imm $I64 0)))\n\n;;;; Rules for `f32const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (f32const (u32_from_ieee32 x)))\n      (imm $F32 x))\n\n;;;; Rules for `f64const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (f64const (u64_from_ieee64 x)))\n      (imm $F64 x))\n\n;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type ty (null)))\n      (imm ty 0))\n\n;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n;; Base case for 8 and 16-bit types\n(rule -6 (lower (has_type (fits_in_16 ty)\n                       (iadd x y)))\n      (x64_add ty x y))\n\n;; Base case for 32 and 64-bit types which might end up using the `lea`\n;; instruction to fold multiple operations into one.\n;;\n;; Note that at this time this always generates a `lea` pseudo-instruction,\n;; but the actual instruction emitted might be an `add` if it's equivalent.\n;; For more details on this see the `emit.rs` logic to emit\n;; `LoadEffectiveAddress`.\n(rule -5 (lower (has_type (ty_32_or_64 ty) (iadd x y)))\n      (x64_lea ty (to_amode_add (mem_flags_trusted) x y (zero_offset))))\n\n;; Higher-priority cases than the previous two where a load can be sunk into\n;; the add instruction itself. Note that both operands are tested for\n;; sink-ability since addition is commutative\n(rule -4 (lower (has_type (fits_in_64 ty)\n                       (iadd x (sinkable_load y))))\n      (x64_add ty x y))\n(rule -3 (lower (has_type (fits_in_64 ty)\n                       (iadd (sinkable_load x) y)))\n      (x64_add ty y x))\n\n;; SSE.\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (iadd x y)))\n      (x64_paddb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (iadd x y)))\n      (x64_paddw x y))\n\n(rule (lower (has_type (multi_lane 32 4)\n                       (iadd x y)))\n      (x64_paddd x y))\n\n(rule (lower (has_type (multi_lane 64 2)\n                       (iadd x y)))\n      (x64_paddq x y))\n\n;; `i128`\n(rule 1 (lower (has_type $I128 (iadd x y)))\n      ;; Get the high/low registers for `x`.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        ;; Get the high/low registers for `y`.\n        (let ((y_regs ValueRegs y)\n              (y_lo Gpr (value_regs_get_gpr y_regs 0))\n              (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n          ;; Do an add followed by an add-with-carry.\n          (with_flags (x64_add_with_flags_paired $I64 x_lo y_lo)\n                      (x64_adc_paired $I64 x_hi y_hi)))))\n\n;;;; Helpers for `*_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(decl construct_overflow_op (CC ProducesFlags) InstOutput)\n(rule (construct_overflow_op cc inst)\n      (let ((results ValueRegs (with_flags inst\n                                           (x64_setcc_paired cc))))\n        (output_pair (value_regs_get results 0)\n                     (value_regs_get results 1))))\n\n(decl construct_overflow_op_alu (Type CC AluRmiROpcode Gpr GprMemImm) InstOutput)\n(rule (construct_overflow_op_alu ty cc alu_op src1 src2)\n      (construct_overflow_op cc (x64_alurmi_with_flags_paired alu_op ty src1 src2)))\n\n;; This essentially creates\n;; alu_<op1> x_lo, y_lo\n;; alu_<op2> x_hi, y_hi\n;; set<cc> r8\n(decl construct_overflow_op_alu_128 (CC AluRmiROpcode AluRmiROpcode Value Value) InstOutput)\n(rule (construct_overflow_op_alu_128 cc op1 op2 x y)\n      ;; Get the high/low registers for `x`.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        ;; Get the high/low registers for `y`.\n        (let ((y_regs ValueRegs y)\n              (y_lo Gpr (value_regs_get_gpr y_regs 0))\n              (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n          (let    ((lo_inst ProducesFlags (x64_alurmi_with_flags_paired op1 $I64 x_lo y_lo))\n                   (hi_inst ConsumesAndProducesFlags (x64_alurmi_with_flags_chained op2 $I64 x_hi y_hi))\n                   (of_inst ConsumesFlags (x64_setcc_paired cc))\n\n                   (result MultiReg (with_flags_chained lo_inst hi_inst of_inst)))\n                  (multi_reg_to_pair_and_single result)))))\n\n;;;; Rules for `uadd_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (uadd_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.B) (AluRmiROpcode.Add) x y))\n\n;; i128 gets lowered into adc and add\n(rule 0 (lower (uadd_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.B) (AluRmiROpcode.Add) (AluRmiROpcode.Adc) x y))\n\n;;;; Rules for `sadd_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (sadd_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.O) (AluRmiROpcode.Add) x y))\n\n(rule 0 (lower (sadd_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.O) (AluRmiROpcode.Add) (AluRmiROpcode.Adc) x y))\n\n;;;; Rules for `usub_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (usub_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.B) (AluRmiROpcode.Sub) x y))\n\n(rule 0 (lower (usub_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.B) (AluRmiROpcode.Sub) (AluRmiROpcode.Sbb) x y))\n\n;;;; Rules for `ssub_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (ssub_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.O) (AluRmiROpcode.Sub) x y))\n\n(rule 0 (lower (ssub_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.O) (AluRmiROpcode.Sub) (AluRmiROpcode.Sbb) x y))\n\n;;;; Rules for `umul_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (umul_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op (CC.O) (x64_umullo_with_flags_paired ty x y)))\n\n;;;; Rules for `smul_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (smul_overflow x y @ (value_type (ty_int_ref_16_to_64 ty))))\n      (construct_overflow_op_alu ty (CC.O) (AluRmiROpcode.Mul) x y))\n\n;; there is no 8bit imul with an immediate operand so we need to put it in a register or memory\n(rule 1 (lower (smul_overflow x y @ (value_type $I8)))\n      (construct_overflow_op (CC.O) (x64_alurmi_with_flags_paired (AluRmiROpcode.Mul) $I8 x (reg_mem_to_reg_mem_imm (put_in_reg_mem y)))))\n\n;;;; Rules for `sadd_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (sadd_sat x y)))\n      (x64_paddsb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (sadd_sat x y)))\n      (x64_paddsw x y))\n\n;;;; Rules for `uadd_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (uadd_sat x y)))\n      (x64_paddusb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (uadd_sat x y)))\n      (x64_paddusw x y))\n\n;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n;; Sub two registers.\n(rule -3 (lower (has_type (fits_in_64 ty)\n                       (isub x y)))\n      (x64_sub ty x y))\n\n;; SSE.\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (isub x y)))\n      (x64_psubb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (isub x y)))\n      (x64_psubw x y))\n\n(rule (lower (has_type (multi_lane 32 4)\n                       (isub x y)))\n      (x64_psubd x y))\n\n(rule (lower (has_type (multi_lane 64 2)\n                       (isub x y)))\n      (x64_psubq x y))\n\n;; `i128`\n(rule 1 (lower (has_type $I128 (isub x y)))\n      ;; Get the high/low registers for `x`.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        ;; Get the high/low registers for `y`.\n        (let ((y_regs ValueRegs y)\n              (y_lo Gpr (value_regs_get_gpr y_regs 0))\n              (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n          ;; Do a sub followed by an sub-with-borrow.\n          (with_flags (x64_sub_with_flags_paired $I64 x_lo y_lo)\n                      (x64_sbb_paired $I64 x_hi y_hi)))))\n\n;;;; Rules for `ssub_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (ssub_sat x y)))\n      (x64_psubsb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (ssub_sat x y)))\n      (x64_psubsw x y))\n\n;;;; Rules for `usub_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (usub_sat x y)))\n      (x64_psubusb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (usub_sat x y)))\n      (x64_psubusw x y))\n\n;;;; Rules for `band` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `{i,b}64` and smaller.\n\n;; And two registers.\n(rule 0 (lower (has_type ty (band x y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_and ty x y))\n\n;; The above case automatically handles when the rhs is an immediate or a\n;; sinkable load, but additionally handle the lhs here.\n\n(rule 1 (lower (has_type ty (band (sinkable_load x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_and ty y x))\n\n(rule 2 (lower (has_type ty (band (simm32_from_value x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_and ty y x))\n\n;; f32 and f64\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (band x y)))\n      (sse_and ty x y))\n\n;; SSE.\n\n(decl sse_and (Type Xmm XmmMem) Xmm)\n(rule (sse_and $F32X4 x y) (x64_andps x y))\n(rule (sse_and $F64X2 x y) (x64_andpd x y))\n(rule (sse_and $F32 x y) (x64_andps x y))\n(rule (sse_and $F64 x y) (x64_andpd x y))\n(rule -1 (sse_and (multi_lane _bits _lanes) x y) (x64_pand x y))\n\n(rule 6 (lower (has_type ty @ (multi_lane _bits _lanes)\n                       (band x y)))\n      (sse_and ty x y))\n\n;; `i128`.\n\n(decl and_i128 (ValueRegs ValueRegs) ValueRegs)\n(rule (and_i128 x y)\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1))\n            (y_regs ValueRegs y)\n            (y_lo Gpr (value_regs_get_gpr y_regs 0))\n            (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n        (value_gprs (x64_and $I64 x_lo y_lo)\n                    (x64_and $I64 x_hi y_hi))))\n\n(rule 7 (lower (has_type $I128 (band x y)))\n      (and_i128 x y))\n\n;; Specialized lowerings for `(band x (bnot y))` which is additionally produced\n;; by Cranelift's `band_not` instruction that is legalized into the simpler\n;; forms early on.\n\n(decl sse_and_not (Type Xmm XmmMem) Xmm)\n(rule (sse_and_not $F32X4 x y) (x64_andnps x y))\n(rule (sse_and_not $F64X2 x y) (x64_andnpd x y))\n(rule -1 (sse_and_not (multi_lane _bits _lanes) x y) (x64_pandn x y))\n\n;; Note the flipping of operands below as we're match\n;;\n;;   (band x (bnot y))\n;;\n;; while x86 does\n;;\n;;   pandn(x, y) = and(not(x), y)\n(rule 8 (lower (has_type ty @ (multi_lane _bits _lane) (band x (bnot y))))\n      (sse_and_not ty y x))\n(rule 9 (lower (has_type ty @ (multi_lane _bits _lane) (band (bnot y) x)))\n      (sse_and_not ty y x))\n\n(rule 10 (lower (has_type ty (band x (bnot y))))\n      (if (ty_int_ref_scalar_64 ty))\n      (if-let $true (use_bmi1))\n      ;; the first argument is the one that gets inverted with andn\n      (x64_andn ty y x))\n(rule 11 (lower (has_type ty (band (bnot y) x)))\n      (if (ty_int_ref_scalar_64 ty))\n      (if-let $true (use_bmi1))\n      (x64_andn ty y x))\n\n;; Specialization of `blsr` for BMI1\n\n(decl pure partial val_minus_one (Value) Value)\n(rule 0 (val_minus_one (isub x (u64_from_iconst 1))) x)\n(rule 0 (val_minus_one (iadd x (i64_from_iconst -1))) x)\n(rule 1 (val_minus_one (iadd (i64_from_iconst -1) x)) x)\n\n(rule 12 (lower (has_type (ty_32_or_64 ty) (band x y)))\n         (if-let $true (use_bmi1))\n         (if-let x (val_minus_one y))\n         (x64_blsr ty x))\n(rule 13 (lower (has_type (ty_32_or_64 ty) (band y x)))\n         (if-let $true (use_bmi1))\n         (if-let x (val_minus_one y))\n         (x64_blsr ty x))\n\n;; Specialization of `blsi` for BMI1\n\n(rule 14 (lower (has_type (ty_32_or_64 ty) (band (ineg x) x)))\n         (if-let $true (use_bmi1))\n         (x64_blsi ty x))\n(rule 15 (lower (has_type (ty_32_or_64 ty) (band x (ineg x))))\n         (if-let $true (use_bmi1))\n         (x64_blsi ty x))\n\n;; Specialization of `bzhi` for BMI2\n;;\n;; The `bzhi` instruction clears all bits indexed by the second operand of the\n;; first operand. This is pattern-matched here with a `band` against a mask\n;; which is generated to be N bits large. Note that if the index is larger than\n;; the bit-width of the type then `bzhi` doesn't have the same semantics as\n;; `ishl`, so an `and` instruction is required to mask the index to match the\n;; semantics of Cranelift's `ishl`.\n\n(rule 16 (lower (has_type (ty_32_or_64 ty) (band x y)))\n         (if-let $true (use_bmi2))\n         (if-let (ishl (u64_from_iconst 1) index) (val_minus_one y))\n         (x64_bzhi ty x (x64_and ty index (RegMemImm.Imm (u32_sub (ty_bits ty) 1)))))\n\n;;;; Rules for `bor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `{i,b}64` and smaller.\n\n;; Or two registers.\n(rule 0 (lower (has_type ty (bor x y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_or ty x y))\n\n;; Handle immediates/sinkable loads on the lhs in addition to the automatic\n;; handling of the rhs above\n\n(rule 1 (lower (has_type ty (bor (sinkable_load x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_or ty y x))\n\n(rule 2 (lower (has_type ty (bor (simm32_from_value x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_or ty y x))\n\n;; f32 and f64\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (bor x y)))\n      (sse_or ty x y))\n\n;; SSE.\n\n(decl sse_or (Type Xmm XmmMem) Xmm)\n(rule (sse_or $F32X4 x y) (x64_orps x y))\n(rule (sse_or $F64X2 x y) (x64_orpd x y))\n(rule (sse_or $F32 x y) (x64_orps x y))\n(rule (sse_or $F64 x y) (x64_orpd x y))\n(rule -1 (sse_or (multi_lane _bits _lanes) x y) (x64_por x y))\n\n(rule 6 (lower (has_type ty @ (multi_lane _bits _lanes)\n                       (bor x y)))\n      (sse_or ty x y))\n\n;; `{i,b}128`.\n\n(decl or_i128 (ValueRegs ValueRegs) ValueRegs)\n(rule (or_i128 x y)\n      (let ((x_lo Gpr (value_regs_get_gpr x 0))\n            (x_hi Gpr (value_regs_get_gpr x 1))\n            (y_lo Gpr (value_regs_get_gpr y 0))\n            (y_hi Gpr (value_regs_get_gpr y 1)))\n        (value_gprs (x64_or $I64 x_lo y_lo)\n                    (x64_or $I64 x_hi y_hi))))\n\n(rule 7 (lower (has_type $I128 (bor x y)))\n      (or_i128 x y))\n\n;;;; Rules for `bxor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `{i,b}64` and smaller.\n\n;; Xor two registers.\n(rule 0 (lower (has_type ty (bxor x y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_xor ty x y))\n\n;; Handle xor with lhs immediates/sinkable loads in addition to the automatic\n;; handling of the rhs above.\n\n(rule 1 (lower (has_type ty (bxor (sinkable_load x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_xor ty y x))\n\n(rule 4 (lower (has_type ty (bxor (simm32_from_value x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_xor ty y x))\n\n;; f32 and f64\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (bxor x y)))\n      (x64_xor_vector ty x y))\n\n;; SSE.\n\n(rule 6 (lower (has_type ty @ (multi_lane _bits _lanes) (bxor x y)))\n      (x64_xor_vector ty x y))\n\n;; `{i,b}128`.\n\n(rule 7 (lower (has_type $I128 (bxor x y)))\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1))\n            (y_regs ValueRegs y)\n            (y_lo Gpr (value_regs_get_gpr y_regs 0))\n            (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n        (value_gprs (x64_xor $I64 x_lo y_lo)\n                    (x64_xor $I64 x_hi y_hi))))\n\n;; Specialization of `blsmsk` for BMI1\n\n(rule 8 (lower (has_type (ty_32_or_64 ty) (bxor x y)))\n        (if-let $true (use_bmi1))\n        (if-let x (val_minus_one y))\n        (x64_blsmsk ty x))\n(rule 9 (lower (has_type (ty_32_or_64 ty) (bxor y x)))\n        (if-let $true (use_bmi1))\n        (if-let x (val_minus_one y))\n        (x64_blsmsk ty x))\n\n;;;; Rules for `ishl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (ishl src amt)))\n      (x64_shl ty src (put_masked_in_imm8_gpr amt ty)))\n\n;; `i128`.\n\n(decl shl_i128 (ValueRegs Gpr) ValueRegs)\n(rule (shl_i128 src amt)\n      ;; Unpack the registers that make up the 128-bit value being shifted.\n      (let ((src_lo Gpr (value_regs_get_gpr src 0))\n            (src_hi Gpr (value_regs_get_gpr src 1))\n            ;; Do two 64-bit shifts.\n            (lo_shifted Gpr (x64_shl $I64 src_lo amt))\n            (hi_shifted Gpr (x64_shl $I64 src_hi amt))\n            ;; `src_lo >> (64 - amt)` are the bits to carry over from the lo\n            ;; into the hi.\n            (carry Gpr (x64_shr $I64\n                            src_lo\n                            (x64_sub $I64\n                                 (imm $I64 64)\n                                 amt)))\n            (zero Gpr (imm $I64 0))\n            ;; Nullify the carry if we are shifting in by a multiple of 128.\n            (carry_ Gpr (with_flags_reg (x64_test (OperandSize.Size64)\n                                              (RegMemImm.Imm 127)\n                                              amt)\n                                        (cmove $I64\n                                               (CC.Z)\n                                               zero\n                                               carry)))\n            ;; Add the carry into the high half.\n            (hi_shifted_ Gpr (x64_or $I64 carry_ hi_shifted)))\n        ;; Combine the two shifted halves. However, if we are shifting by >= 64\n        ;; (modulo 128), then the low bits are zero and the high bits are our\n        ;; low bits.\n        (with_flags (x64_test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                    (consumes_flags_concat\n                     (cmove $I64 (CC.Z) lo_shifted zero)\n                     (cmove $I64 (CC.Z) hi_shifted_ lo_shifted)))))\n\n(rule (lower (has_type $I128 (ishl src amt)))\n      ;; NB: Only the low bits of `amt` matter since we logically mask the shift\n      ;; amount to the value's bit width.\n      (let ((amt_ Gpr (lo_gpr amt)))\n        (shl_i128 src amt_)))\n\n;; SSE.\n\n;; Since the x86 instruction set does not have any 8x16 shift instructions (even\n;; in higher feature sets like AVX), we lower the `ishl.i8x16` to a sequence of\n;; instructions. The basic idea, whether the amount to shift by is an immediate\n;; or not, is to use a 16x8 shift and then mask off the incorrect bits to 0s.\n(rule (lower (has_type ty @ $I8X16 (ishl src amt)))\n      (let (\n            ;; Mask the amount to ensure wrapping behaviour\n            (masked_amt RegMemImm (mask_xmm_shift ty amt))\n            ;; Shift `src` using 16x8. Unfortunately, a 16x8 shift will only be\n            ;; correct for half of the lanes; the others must be fixed up with\n            ;; the mask below.\n            (unmasked Xmm (x64_psllw src (mov_rmi_to_xmm masked_amt)))\n            (mask_addr SyntheticAmode (ishl_i8x16_mask masked_amt))\n            (mask Reg (x64_load $I8X16 mask_addr (ExtKind.None))))\n        (sse_and $I8X16 unmasked (RegMem.Reg mask))))\n\n;; Get the address of the mask to use when fixing up the lanes that weren't\n;; correctly generated by the 16x8 shift.\n(decl ishl_i8x16_mask (RegMemImm) SyntheticAmode)\n\n;; When the shift amount is known, we can statically (i.e. at compile time)\n;; determine the mask to use and only emit that.\n(decl ishl_i8x16_mask_for_const (u32) SyntheticAmode)\n(extern constructor ishl_i8x16_mask_for_const ishl_i8x16_mask_for_const)\n(rule (ishl_i8x16_mask (RegMemImm.Imm amt))\n      (ishl_i8x16_mask_for_const amt))\n\n;; Otherwise, we must emit the entire mask table and dynamically (i.e. at run\n;; time) find the correct mask offset in the table. We use `lea` to find the\n;; base address of the mask table and then complex addressing to offset to the\n;; right mask: `base_address + amt << 4`\n(decl ishl_i8x16_mask_table () SyntheticAmode)\n(extern constructor ishl_i8x16_mask_table ishl_i8x16_mask_table)\n(rule (ishl_i8x16_mask (RegMemImm.Reg amt))\n      (let ((mask_table SyntheticAmode (ishl_i8x16_mask_table))\n            (base_mask_addr Gpr (x64_lea $I64 mask_table))\n            (mask_offset Gpr (x64_shl $I64 amt\n                                  (imm8_to_imm8_gpr 4))))\n        (Amode.ImmRegRegShift 0\n                              base_mask_addr\n                              mask_offset\n                              0\n                              (mem_flags_trusted))))\n\n(rule (ishl_i8x16_mask (RegMemImm.Mem amt))\n      (ishl_i8x16_mask (RegMemImm.Reg (x64_load $I64 amt (ExtKind.None)))))\n\n;; 16x8, 32x4, and 64x2 shifts can each use a single instruction, once the shift amount is masked.\n\n(rule (lower (has_type ty @ $I16X8 (ishl src amt)))\n      (x64_psllw src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I32X4 (ishl src amt)))\n      (x64_pslld src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I64X2 (ishl src amt)))\n      (x64_psllq src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n;;;; Rules for `ushr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (ushr src amt)))\n      (let ((src_ Gpr (extend_to_gpr src ty (ExtendKind.Zero))))\n        (x64_shr ty src_ (put_masked_in_imm8_gpr amt ty))))\n\n;; `i128`.\n\n(decl shr_i128 (ValueRegs Gpr) ValueRegs)\n(rule (shr_i128 src amt)\n      ;; Unpack the lo/hi halves of `src`.\n      (let ((src_lo Gpr (value_regs_get_gpr src 0))\n            (src_hi Gpr (value_regs_get_gpr src 1))\n            ;; Do a shift on each half.\n            (lo_shifted Gpr (x64_shr $I64 src_lo amt))\n            (hi_shifted Gpr (x64_shr $I64 src_hi amt))\n            ;; `src_hi << (64 - amt)` are the bits to carry over from the hi\n            ;; into the lo.\n            (carry Gpr (x64_shl $I64\n                            src_hi\n                            (x64_sub $I64\n                                 (imm $I64 64)\n                                 amt)))\n            ;; Share the zero value to reduce register pressure\n            (zero Gpr (imm $I64 0))\n\n            ;; Nullify the carry if we are shifting by a multiple of 128.\n            (carry_ Gpr (with_flags_reg (x64_test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                        (cmove $I64 (CC.Z) zero carry)))\n            ;; Add the carry bits into the lo.\n            (lo_shifted_ Gpr (x64_or $I64 carry_ lo_shifted)))\n        ;; Combine the two shifted halves. However, if we are shifting by >= 64\n        ;; (modulo 128), then the hi bits are zero and the lo bits are what\n        ;; would otherwise be our hi bits.\n        (with_flags (x64_test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                    (consumes_flags_concat\n                     (cmove $I64 (CC.Z) lo_shifted_ hi_shifted)\n                     (cmove $I64 (CC.Z) hi_shifted zero)))))\n\n(rule (lower (has_type $I128 (ushr src amt)))\n      ;; NB: Only the low bits of `amt` matter since we logically mask the shift\n      ;; amount to the value's bit width.\n      (let ((amt_ Gpr (lo_gpr amt)))\n        (shr_i128 src amt_)))\n\n;; SSE.\n\n;; There are no 8x16 shifts in x64. Do the same 16x8-shift-and-mask thing we do\n;; with 8x16 `ishl`.\n(rule (lower (has_type ty @ $I8X16 (ushr src amt)))\n      (let (\n            ;; Mask the amount to ensure wrapping behaviour\n            (masked_amt RegMemImm (mask_xmm_shift ty amt))\n            ;; Shift `src` using 16x8. Unfortunately, a 16x8 shift will only be\n            ;; correct for half of the lanes; the others must be fixed up with\n            ;; the mask below.\n            (unmasked Xmm (x64_psrlw src (mov_rmi_to_xmm masked_amt))))\n        (sse_and $I8X16\n                 unmasked\n                 (ushr_i8x16_mask masked_amt))))\n\n;; Get the address of the mask to use when fixing up the lanes that weren't\n;; correctly generated by the 16x8 shift.\n(decl ushr_i8x16_mask (RegMemImm) SyntheticAmode)\n\n;; When the shift amount is known, we can statically (i.e. at compile time)\n;; determine the mask to use and only emit that.\n(decl ushr_i8x16_mask_for_const (u32) SyntheticAmode)\n(extern constructor ushr_i8x16_mask_for_const ushr_i8x16_mask_for_const)\n(rule (ushr_i8x16_mask (RegMemImm.Imm amt))\n      (ushr_i8x16_mask_for_const amt))\n\n;; Otherwise, we must emit the entire mask table and dynamically (i.e. at run\n;; time) find the correct mask offset in the table. We use `lea` to find the\n;; base address of the mask table and then complex addressing to offset to the\n;; right mask: `base_address + amt << 4`\n(decl ushr_i8x16_mask_table () SyntheticAmode)\n(extern constructor ushr_i8x16_mask_table ushr_i8x16_mask_table)\n(rule (ushr_i8x16_mask (RegMemImm.Reg amt))\n      (let ((mask_table SyntheticAmode (ushr_i8x16_mask_table))\n            (base_mask_addr Gpr (x64_lea $I64 mask_table))\n            (mask_offset Gpr (x64_shl $I64\n                                  amt\n                                  (imm8_to_imm8_gpr 4))))\n        (Amode.ImmRegRegShift 0\n                              base_mask_addr\n                              mask_offset\n                              0\n                              (mem_flags_trusted))))\n\n(rule (ushr_i8x16_mask (RegMemImm.Mem amt))\n      (ushr_i8x16_mask (RegMemImm.Reg (x64_load $I64 amt (ExtKind.None)))))\n\n;; 16x8, 32x4, and 64x2 shifts can each use a single instruction, once the shift amount is masked.\n\n(rule (lower (has_type ty @ $I16X8 (ushr src amt)))\n      (x64_psrlw src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I32X4 (ushr src amt)))\n      (x64_psrld src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I64X2 (ushr src amt)))\n      (x64_psrlq src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(decl mask_xmm_shift (Type Value) RegMemImm)\n(rule (mask_xmm_shift ty amt)\n      (gpr_to_reg (x64_and $I64 amt (RegMemImm.Imm (shift_mask ty)))))\n(rule 1 (mask_xmm_shift ty (iconst n))\n      (RegMemImm.Imm (shift_amount_masked ty n)))\n\n;;;; Rules for `sshr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (sshr src amt)))\n      (let ((src_ Gpr (extend_to_gpr src ty (ExtendKind.Sign))))\n        (x64_sar ty src_ (put_masked_in_imm8_gpr amt ty))))\n\n;; `i128`.\n\n(decl sar_i128 (ValueRegs Gpr) ValueRegs)\n(rule (sar_i128 src amt)\n      ;; Unpack the low/high halves of `src`.\n      (let ((src_lo Gpr (value_regs_get_gpr src 0))\n            (src_hi Gpr (value_regs_get_gpr src 1))\n            ;; Do a shift of each half. NB: the low half uses an unsigned shift\n            ;; because its MSB is not a sign bit.\n            (lo_shifted Gpr (x64_shr $I64 src_lo amt))\n            (hi_shifted Gpr (x64_sar $I64 src_hi amt))\n            ;; `src_hi << (64 - amt)` are the bits to carry over from the low\n            ;; half to the high half.\n            (carry Gpr (x64_shl $I64\n                            src_hi\n                            (x64_sub $I64\n                                 (imm $I64 64)\n                                 amt)))\n            ;; Nullify the carry if we are shifting by a multiple of 128.\n            (carry_ Gpr (with_flags_reg (x64_test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                        (cmove $I64 (CC.Z) (imm $I64 0) carry)))\n            ;; Add the carry into the low half.\n            (lo_shifted_ Gpr (x64_or $I64 lo_shifted carry_))\n            ;; Get all sign bits.\n            (sign_bits Gpr (x64_sar $I64 src_hi (imm8_to_imm8_gpr 63))))\n        ;; Combine the two shifted halves. However, if we are shifting by >= 64\n        ;; (modulo 128), then the hi bits are all sign bits and the lo bits are\n        ;; what would otherwise be our hi bits.\n        (with_flags (x64_test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                    (consumes_flags_concat\n                     (cmove $I64 (CC.Z) lo_shifted_ hi_shifted)\n                     (cmove $I64 (CC.Z) hi_shifted sign_bits)))))\n\n(rule (lower (has_type $I128 (sshr src amt)))\n      ;; NB: Only the low bits of `amt` matter since we logically mask the shift\n      ;; amount to the value's bit width.\n      (let ((amt_ Gpr (lo_gpr amt)))\n        (sar_i128 src amt_)))\n\n;; SSE.\n\n;; Since the x86 instruction set does not have an 8x16 shift instruction and the\n;; approach used for `ishl` and `ushr` cannot be easily used (the masks do not\n;; preserve the sign), we use a different approach here: separate the low and\n;; high lanes, shift them separately, and merge them into the final result.\n;;\n;; Visually, this looks like the following, where `src.i8x16 = [s0, s1, ...,\n;; s15]:\n;;\n;;   lo.i16x8 = [(s0, s0), (s1, s1), ..., (s7, s7)]\n;;   shifted_lo.i16x8 = shift each lane of `low`\n;;   hi.i16x8 = [(s8, s8), (s9, s9), ..., (s15, s15)]\n;;   shifted_hi.i16x8 = shift each lane of `high`\n;;   result = [s0'', s1'', ..., s15'']\n(rule (lower (has_type ty @ $I8X16 (sshr src amt @ (value_type amt_ty))))\n      (let ((src_ Xmm (put_in_xmm src))\n            ;; Mask the amount to ensure wrapping behaviour\n            (masked_amt RegMemImm (mask_xmm_shift ty amt))\n            ;; In order for `packsswb` later to only use the high byte of each\n            ;; 16x8 lane, we shift right an extra 8 bits, relying on `psraw` to\n            ;; fill in the upper bits appropriately.\n            (lo Xmm (x64_punpcklbw src_ src_))\n            (hi Xmm (x64_punpckhbw src_ src_))\n            (amt_ XmmMemImm (sshr_i8x16_bigger_shift amt_ty masked_amt))\n            (shifted_lo Xmm (x64_psraw lo amt_))\n            (shifted_hi Xmm (x64_psraw hi amt_)))\n        (x64_packsswb shifted_lo shifted_hi)))\n\n(decl sshr_i8x16_bigger_shift (Type RegMemImm) XmmMemImm)\n(rule (sshr_i8x16_bigger_shift _ty (RegMemImm.Imm i))\n      (xmm_mem_imm_new (RegMemImm.Imm (u32_add i 8))))\n(rule (sshr_i8x16_bigger_shift ty (RegMemImm.Reg r))\n      (mov_rmi_to_xmm (RegMemImm.Reg (x64_add ty\n                                          r\n                                          (RegMemImm.Imm 8)))))\n(rule (sshr_i8x16_bigger_shift ty rmi @ (RegMemImm.Mem _m))\n      (mov_rmi_to_xmm (RegMemImm.Reg (x64_add ty\n                                          (imm ty 8)\n                                          rmi))))\n\n;; `sshr.{i16x8,i32x4}` can be a simple `psra{w,d}`, we just have to make sure\n;; that if the shift amount is in a register, it is in an XMM register.\n\n(rule (lower (has_type ty @ $I16X8 (sshr src amt)))\n      (x64_psraw src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I32X4 (sshr src amt)))\n      (x64_psrad src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n;; The `sshr.i64x2` CLIF instruction has no single x86 instruction in the older\n;; feature sets. To remedy this, a small dance is done with an unsigned right\n;; shift plus some extra ops.\n(rule 3 (lower (has_type ty @ $I64X2 (sshr src (iconst n))))\n        (if-let $true (use_avx512vl))\n        (if-let $true (use_avx512f))\n        (x64_vpsraq_imm src (shift_amount_masked ty n)))\n\n(rule 2 (lower (has_type ty @ $I64X2 (sshr src amt)))\n        (if-let $true (use_avx512vl))\n        (if-let $true (use_avx512f))\n        (let ((masked Gpr (x64_and $I64 amt (RegMemImm.Imm (shift_mask ty)))))\n          (x64_vpsraq src (x64_movd_to_xmm masked))))\n\n(rule 1 (lower (has_type $I64X2 (sshr src (iconst (u64_from_imm64 (u64_as_u32 amt))))))\n        (lower_i64x2_sshr_imm src (u32_and amt 63)))\n\n(rule (lower (has_type $I64X2 (sshr src amt)))\n      (lower_i64x2_sshr_gpr src (x64_and $I64 amt (RegMemImm.Imm 63))))\n\n(decl lower_i64x2_sshr_imm (Xmm u32) Xmm)\n\n;; If the shift amount is less than 32 then do an sshr with 32-bit lanes to\n;; produce the upper halves of each result, followed by a ushr of 64-bit lanes\n;; to produce the lower halves of each result. Interleave results at the end.\n(rule 2 (lower_i64x2_sshr_imm vec imm)\n        (if-let $true (u64_lt imm 32))\n        (let (\n            (high32 Xmm (x64_psrad vec (xmi_imm imm)))\n            (high32 Xmm (x64_pshufd high32 0b11_10_11_01))\n            (low32  Xmm (x64_psrlq vec (xmi_imm imm)))\n            (low32  Xmm (x64_pshufd low32 0b11_10_10_00))\n          )\n          (x64_punpckldq low32 high32)))\n\n;; If the shift amount is 32 then the `psrlq` from the above rule can be avoided\n(rule 1 (lower_i64x2_sshr_imm vec 32)\n        (let (\n            (low32  Xmm (x64_pshufd vec 0b11_10_11_01))\n            (high32 Xmm (x64_psrad vec (xmi_imm 31)))\n            (high32 Xmm (x64_pshufd high32 0b11_10_11_01))\n          )\n          (x64_punpckldq low32 high32)))\n\n;; Shifts >= 32 use one `psrad` to generate the upper bits and second `psrad` to\n;; generate the lower bits. Everything is then woven back together with\n;; shuffles.\n(rule (lower_i64x2_sshr_imm vec imm)\n      (if-let $true (u64_lt 32 imm))\n      (let (\n          (high32 Xmm (x64_psrad vec (xmi_imm 31)))\n          (high32 Xmm (x64_pshufd high32 0b11_10_11_01))\n          (low32  Xmm (x64_psrad vec (xmi_imm (u32_sub imm 32))))\n          (low32  Xmm (x64_pshufd low32 0b11_10_10_01))\n        )\n        (x64_punpckldq low32 high32)))\n\n;; A variable shift amount is slightly more complicated than the immediate\n;; shift amounts from above. The `Gpr` argument is guaranteed to be <= 63 by\n;; earlier masking. A `ushr` operation is used with some xor/sub math to\n;; generate the sign bits.\n(decl lower_i64x2_sshr_gpr (Xmm Gpr) Xmm)\n(rule (lower_i64x2_sshr_gpr vec val)\n      (let (\n          (val                Xmm (x64_movq_to_xmm val))\n          (mask               Xmm (flip_high_bit_mask $I64X2))\n          (sign_bit_loc       Xmm (x64_psrlq mask val))\n          (ushr               Xmm (x64_psrlq vec val))\n          (ushr_sign_bit_flip Xmm (x64_pxor sign_bit_loc ushr))\n        )\n        (x64_psubq ushr_sign_bit_flip sign_bit_loc)))\n\n;;;; Rules for `rotl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller: we can rely on x86's rotate-amount masking since\n;;  we operate on the whole register. For const's we mask the constant.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (rotl src amt)))\n        (x64_rotl ty src (put_masked_in_imm8_gpr amt ty)))\n\n\n;; `i128`.\n\n(rule (lower (has_type $I128 (rotl src amt)))\n      (let ((src_ ValueRegs src)\n            ;; NB: Only the low bits of `amt` matter since we logically mask the\n            ;; rotation amount to the value's bit width.\n            (amt_ Gpr (lo_gpr amt)))\n        (or_i128 (shl_i128 src_ amt_)\n                 (shr_i128 src_ (x64_sub $I64\n                                     (imm $I64 128)\n                                     amt_)))))\n\n;;;; Rules for `rotr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller: we can rely on x86's rotate-amount masking since\n;;  we operate on the whole register. For const's we mask the constant.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (rotr src amt)))\n        (x64_rotr ty src (put_masked_in_imm8_gpr amt ty)))\n\n\n;; `i128`.\n\n(rule (lower (has_type $I128 (rotr src amt)))\n      (let ((src_ ValueRegs src)\n            ;; NB: Only the low bits of `amt` matter since we logically mask the\n            ;; rotation amount to the value's bit width.\n            (amt_ Gpr (lo_gpr amt)))\n        (or_i128 (shr_i128 src_ amt_)\n                 (shl_i128 src_ (x64_sub $I64\n                                     (imm $I64 128)\n                                     amt_)))))\n\n;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (ineg x)))\n      (x64_neg ty x))\n\n(rule -2 (lower (has_type $I128 (ineg x)))\n      ;; Get the high/low registers for `x`.\n      (let ((regs ValueRegs x)\n            (lo Gpr (value_regs_get_gpr regs 0))\n            (hi Gpr (value_regs_get_gpr regs 1)))\n        ;; Do a neg followed by an sub-with-borrow.\n        (with_flags (x64_neg_paired $I64 lo)\n                    (x64_sbb_paired $I64 (imm $I64 0) hi))))\n\n;; SSE.\n\n(rule (lower (has_type $I8X16 (ineg x)))\n      (x64_psubb (imm $I8X16 0) x))\n\n(rule (lower (has_type $I16X8 (ineg x)))\n      (x64_psubw (imm $I16X8 0) x))\n\n(rule (lower (has_type $I32X4 (ineg x)))\n      (x64_psubd (imm $I32X4 0) x))\n\n(rule (lower (has_type $I64X2 (ineg x)))\n      (x64_psubq (imm $I64X2 0) x))\n\n;;;; Rules for `avg_round` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (avg_round x y)))\n      (x64_pavgb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (avg_round x y)))\n      (x64_pavgw x y))\n\n;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n;; Multiply two registers.\n(rule -5 (lower (has_type (fits_in_64 ty) (imul x y)))\n      (x64_mul ty x y))\n\n;; Handle multiplication where the lhs is an immediate or sinkable load in\n;; addition to the automatic rhs handling above.\n\n(rule -4 (lower (has_type (fits_in_64 ty)\n                       (imul (simm32_from_value x) y)))\n      (x64_mul ty y x))\n(rule -3 (lower (has_type (fits_in_64 ty)\n                       (imul (sinkable_load x) y)))\n      (x64_mul ty y x))\n\n;; `i128`.\n\n;; mul:\n;;   dst_lo = lhs_lo * rhs_lo\n;;   dst_hi = umulhi(lhs_lo, rhs_lo) +\n;;            lhs_lo * rhs_hi +\n;;            lhs_hi * rhs_lo\n;;\n;; so we emit:\n;;   lo_hi = mul x_lo, y_hi\n;;   hi_lo = mul x_hi, y_lo\n;;   hilo_hilo = add lo_hi, hi_lo\n;;   dst_lo:hi_lolo = mulhi_u x_lo, y_lo\n;;   dst_hi = add hilo_hilo, hi_lolo\n;;   return (dst_lo, dst_hi)\n(rule 2 (lower (has_type $I128 (imul x y)))\n      ;; Put `x` into registers and unpack its hi/lo halves.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1))\n            ;; Put `y` into registers and unpack its hi/lo halves.\n            (y_regs ValueRegs y)\n            (y_lo Gpr (value_regs_get_gpr y_regs 0))\n            (y_hi Gpr (value_regs_get_gpr y_regs 1))\n            ;; lo_hi = mul x_lo, y_hi\n            (lo_hi Gpr (x64_mul $I64 x_lo y_hi))\n            ;; hi_lo = mul x_hi, y_lo\n            (hi_lo Gpr (x64_mul $I64 x_hi y_lo))\n            ;; hilo_hilo = add lo_hi, hi_lo\n            (hilo_hilo Gpr (x64_add $I64 lo_hi hi_lo))\n            ;; dst_lo:hi_lolo = mulhi_u x_lo, y_lo\n            (mul_regs ValueRegs (mulhi_u $I64 x_lo y_lo))\n            (dst_lo Gpr (value_regs_get_gpr mul_regs 0))\n            (hi_lolo Gpr (value_regs_get_gpr mul_regs 1))\n            ;; dst_hi = add hilo_hilo, hi_lolo\n            (dst_hi Gpr (x64_add $I64 hilo_hilo hi_lolo)))\n        (value_gprs dst_lo dst_hi)))\n\n;; SSE.\n\n;; (No i8x16 multiply.)\n\n(rule (lower (has_type (multi_lane 16 8) (imul x y)))\n      (x64_pmullw x y))\n\n(rule (lower (has_type (multi_lane 32 4) (imul x y)))\n      (if-let $true (use_sse41))\n      (x64_pmulld x y))\n\n;; Without `pmulld` the `pmuludq` instruction is used instead which performs\n;; 32-bit multiplication storing the 64-bit result. The 64-bit result is\n;; truncated to 32-bits and everything else is woven into place.\n(rule -1 (lower (has_type (multi_lane 32 4) (imul x y)))\n         (let (\n            (x Xmm x)\n            (y Xmm y)\n            (x_hi Xmm (x64_pshufd x 0b00_11_00_01))\n            (y_hi Xmm (x64_pshufd y 0b00_11_00_01))\n            (mul_lo Xmm (x64_pshufd (x64_pmuludq x y)       0b00_00_10_00))\n            (mul_hi Xmm (x64_pshufd (x64_pmuludq x_hi y_hi) 0b00_00_10_00))\n          )\n          (x64_punpckldq mul_lo mul_hi)))\n\n;; With AVX-512 we can implement `i64x2` multiplication with a single\n;; instruction.\n(rule 3 (lower (has_type (multi_lane 64 2) (imul x y)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512dq))\n      (x64_vpmullq x y))\n\n;; Otherwise, for i64x2 multiplication we describe a lane A as being composed of\n;; a 32-bit upper half \"Ah\" and a 32-bit lower half \"Al\". The 32-bit long hand\n;; multiplication can then be written as:\n;;\n;;    Ah Al\n;; *  Bh Bl\n;;    -----\n;;    Al * Bl\n;; + (Ah * Bl) << 32\n;; + (Al * Bh) << 32\n;;\n;; So for each lane we will compute:\n;;\n;;   A * B  = (Al * Bl) + ((Ah * Bl) + (Al * Bh)) << 32\n;;\n;; Note, the algorithm will use `pmuludq` which operates directly on the lower\n;; 32-bit (`Al` or `Bl`) of a lane and writes the result to the full 64-bits of\n;; the lane of the destination. For this reason we don't need shifts to isolate\n;; the lower 32-bits, however, we will need to use shifts to isolate the high\n;; 32-bits when doing calculations, i.e., `Ah == A >> 32`.\n(rule (lower (has_type (multi_lane 64 2)\n                       (imul a b)))\n      (let ((a0 Xmm a)\n            (b0 Xmm b)\n            ;; a_hi = A >> 32\n            (a_hi Xmm (x64_psrlq a0 (xmi_imm 32)))\n            ;; ah_bl = Ah * Bl\n            (ah_bl Xmm (x64_pmuludq a_hi b0))\n            ;; b_hi = B >> 32\n            (b_hi Xmm (x64_psrlq b0 (xmi_imm 32)))\n            ;; al_bh = Al * Bh\n            (al_bh Xmm (x64_pmuludq a0 b_hi))\n            ;; aa_bb = ah_bl + al_bh\n            (aa_bb Xmm (x64_paddq ah_bl al_bh))\n            ;; aa_bb_shifted = aa_bb << 32\n            (aa_bb_shifted Xmm (x64_psllq aa_bb (xmi_imm 32)))\n            ;; al_bl = Al * Bl\n            (al_bl Xmm (x64_pmuludq a0 b0)))\n        ;; al_bl + aa_bb_shifted\n        (x64_paddq al_bl aa_bb_shifted)))\n\n;; Special case for `i32x4.extmul_high_i16x8_s`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (swiden_high (and (value_type (multi_lane 16 8))\n                                               x))\n                             (swiden_high (and (value_type (multi_lane 16 8))\n                                               y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhw x2 y2)))\n        (x64_punpckhwd lo hi)))\n\n;; Special case for `i64x2.extmul_high_i32x4_s`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (swiden_high (and (value_type (multi_lane 32 4))\n                                               x))\n                             (swiden_high (and (value_type (multi_lane 32 4))\n                                               y)))))\n      (if-let $true (use_sse41))\n      (let ((x2 Xmm (x64_pshufd x 0xFA))\n            (y2 Xmm (x64_pshufd y 0xFA)))\n        (x64_pmuldq x2 y2)))\n\n;; Special case for `i32x4.extmul_low_i16x8_s`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (swiden_low (and (value_type (multi_lane 16 8))\n                                              x))\n                             (swiden_low (and (value_type (multi_lane 16 8))\n                                              y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhw x2 y2)))\n        (x64_punpcklwd lo hi)))\n\n;; Special case for `i64x2.extmul_low_i32x4_s`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (swiden_low (and (value_type (multi_lane 32 4))\n                                              x))\n                             (swiden_low (and (value_type (multi_lane 32 4))\n                                              y)))))\n      (if-let $true (use_sse41))\n      (let ((x2 Xmm (x64_pshufd x 0x50))\n            (y2 Xmm (x64_pshufd y 0x50)))\n        (x64_pmuldq x2 y2)))\n\n;; Special case for `i32x4.extmul_high_i16x8_u`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (uwiden_high (and (value_type (multi_lane 16 8))\n                                               x))\n                             (uwiden_high (and (value_type (multi_lane 16 8))\n                                               y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhuw x2 y2)))\n        (x64_punpckhwd lo hi)))\n\n;; Special case for `i64x2.extmul_high_i32x4_u`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (uwiden_high (and (value_type (multi_lane 32 4))\n                                               x))\n                             (uwiden_high (and (value_type (multi_lane 32 4))\n                                               y)))))\n      (let ((x2 Xmm (x64_pshufd x 0xFA))\n            (y2 Xmm (x64_pshufd y 0xFA)))\n        (x64_pmuludq x2 y2)))\n\n;; Special case for `i32x4.extmul_low_i16x8_u`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (uwiden_low (and (value_type (multi_lane 16 8))\n                                              x))\n                             (uwiden_low (and (value_type (multi_lane 16 8))\n                                              y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhuw x2 y2)))\n        (x64_punpcklwd lo hi)))\n\n;; Special case for `i64x2.extmul_low_i32x4_u`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (uwiden_low (and (value_type (multi_lane 32 4))\n                                              x))\n                             (uwiden_low (and (value_type (multi_lane 32 4))\n                                              y)))))\n      (let ((x2 Xmm (x64_pshufd x 0x50))\n            (y2 Xmm (x64_pshufd y 0x50)))\n        (x64_pmuludq x2 y2)))\n\n;;;; Rules for `iabs` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (has_type $I8X16 (iabs x)))\n        (if-let $true (use_ssse3))\n        (x64_pabsb x))\n\n;; Note the use of `pminub` with signed inputs will produce the positive signed\n;; result which is what is desired here. The `pmaxub` isn't available until\n;; SSE4.1 in which case the single-instruction above lowering would apply.\n(rule (lower (has_type $I8X16 (iabs x)))\n      (let (\n          (x Xmm x)\n          (negated Xmm (x64_psubb (xmm_zero $I8X16) x))\n        )\n        (x64_pminub x negated)))\n\n(rule 1 (lower (has_type $I16X8 (iabs x)))\n        (if-let $true (use_ssse3))\n        (x64_pabsw x))\n\n(rule (lower (has_type $I16X8 (iabs x)))\n      (let (\n          (x Xmm x)\n          (negated Xmm (x64_psubw (xmm_zero $I16X8) x))\n        )\n        (x64_pmaxsw x negated)))\n\n(rule 1 (lower (has_type $I32X4 (iabs x)))\n        (if-let $true (use_ssse3))\n        (x64_pabsd x))\n\n;; Generate a `negative_mask` which is either numerically -1 or 0 depending on\n;; if the lane is negative. If the lane is positive then the xor operation\n;; won't change the lane but otherwise it'll bit-flip everything. By then\n;; subtracting the mask this subtracts 0 for positive lanes (does nothing) or\n;; ends up adding one for negative lanes. This means that for a negative lane\n;; `x` the result is `!x + 1` which is the result of negating it.\n(rule (lower (has_type $I32X4 (iabs x)))\n      (let (\n          (x Xmm x)\n          (negative_mask Xmm (x64_psrad x (xmi_imm 31)))\n          (flipped_if_negative Xmm (x64_pxor x negative_mask))\n        )\n        (x64_psubd flipped_if_negative negative_mask)))\n\n;; When AVX512 is available, we can use a single `vpabsq` instruction.\n(rule 2 (lower (has_type $I64X2 (iabs x)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512f))\n      (x64_vpabsq x))\n\n;; Otherwise, we use a separate register, `neg`, to contain the results of `0 -\n;; x` and then blend in those results with `blendvpd` if the MSB of `neg` was\n;; set to 1 (i.e. if `neg` was negative or, conversely, if `x` was originally\n;; positive).\n(rule 1 (lower (has_type $I64X2 (iabs x)))\n        (if-let $true (use_sse41))\n        (let ((rx Xmm x)\n              (neg Xmm (x64_psubq (imm $I64X2 0) rx)))\n          (x64_blendvpd neg rx neg)))\n\n;; and if `blendvpd` isn't available then perform a shift/shuffle to generate a\n;; mask of which lanes are negative, followed by flipping bits/sub to make both\n;; positive.\n(rule (lower (has_type $I64X2 (iabs x)))\n      (let ((x Xmm x)\n            (signs Xmm (x64_psrad x (RegMemImm.Imm 31)))\n            (signs Xmm (x64_pshufd signs 0b11_11_01_01))\n            (xor_if_negative Xmm (x64_pxor x signs)))\n        (x64_psubq xor_if_negative signs)))\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (iabs x)))\n      (let ((src Gpr x)\n            (neg ProducesFlags (x64_neg_paired ty src))\n            ;; Manually extract the result from the neg, then ignore\n            ;; it below, since we need to pass it into the cmove\n            ;; before we pass the cmove to with_flags_reg.\n            (neg_result Gpr (produces_flags_get_reg neg))\n            ;; When the neg instruction sets the sign flag,\n            ;; takes the original (non-negative) value.\n            (cmove ConsumesFlags (cmove ty (CC.S) src neg_result)))\n        (with_flags_reg (produces_flags_ignore neg) cmove)))\n\n;;;; Rules for `fabs` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fabs x)))\n      (x64_andps x (imm $F32 0x7fffffff)))\n\n(rule (lower (has_type $F64 (fabs x)))\n      (x64_andpd x (imm $F64 0x7fffffffffffffff)))\n\n;; Special case for `f32x4.abs`.\n(rule (lower (has_type $F32X4 (fabs x)))\n      (x64_andps x\n             (x64_psrld (vector_all_ones) (xmi_imm 1))))\n\n;; Special case for `f64x2.abs`.\n(rule (lower (has_type $F64X2 (fabs x)))\n      (x64_andpd x\n             (x64_psrlq (vector_all_ones) (xmi_imm 1))))\n\n;;;; Rules for `fneg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fneg x)))\n      (x64_xorps x (imm $F32 0x80000000)))\n\n(rule (lower (has_type $F64 (fneg x)))\n      (x64_xorpd x (imm $F64 0x8000000000000000)))\n\n(rule (lower (has_type $F32X4 (fneg x)))\n      (x64_xorps x\n             (x64_pslld (vector_all_ones) (xmi_imm 31))))\n\n(rule (lower (has_type $F64X2 (fneg x)))\n      (x64_xorpd x\n             (x64_psllq (vector_all_ones) (xmi_imm 63))))\n\n;;;; Rules for `bmask` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(decl lower_bmask (Type Type ValueRegs) ValueRegs)\n\n;; Values that fit in a register\n;;\n;; Use the neg instruction on the input which sets the CF (carry) flag\n;; to 0 if the input is 0 or 1 otherwise.\n;; We then subtract the output register with itself, which always gives a 0,\n;; however use the carry flag from the previous negate to generate a -1 if it\n;; was nonzero.\n;;\n;; neg in_reg\n;; sbb out_reg, out_reg\n(rule 0\n      (lower_bmask (fits_in_64 out_ty) (fits_in_64 in_ty) val)\n      (let ((reg Gpr (value_regs_get_gpr val 0))\n            (out ValueRegs (with_flags\n                  (x64_neg_paired in_ty reg)\n                  (x64_sbb_paired out_ty reg reg))))\n        ;; Extract only the output of the sbb instruction\n        (value_reg (value_regs_get out 1))))\n\n\n;; If the input type is I128 we can `or` the registers, and recurse to the general case.\n(rule 1\n      (lower_bmask (fits_in_64 out_ty) $I128 val)\n      (let ((lo Gpr (value_regs_get_gpr val 0))\n            (hi Gpr (value_regs_get_gpr val 1))\n            (mixed Gpr (x64_or $I64 lo hi)))\n        (lower_bmask out_ty $I64 (value_reg mixed))))\n\n;; If the output type is I128 we just duplicate the result of the I64 lowering\n(rule 2\n      (lower_bmask $I128 in_ty val)\n      (let ((res ValueRegs (lower_bmask $I64 in_ty val))\n            (res Gpr (value_regs_get_gpr res 0)))\n        (value_regs res res)))\n\n\n;; Call the lower_bmask rule that does all the procssing\n(rule (lower (has_type out_ty (bmask x @ (value_type in_ty))))\n      (lower_bmask out_ty in_ty x))\n\n;;;; Rules for `bnot` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -2 (lower (has_type ty (bnot x)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_not ty x))\n\n\n;; `i128`.\n\n(decl i128_not (Value) ValueRegs)\n(rule (i128_not x)\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        (value_gprs (x64_not $I64 x_lo)\n                    (x64_not $I64 x_hi))))\n\n(rule (lower (has_type $I128 (bnot x)))\n      (i128_not x))\n\n;; f32 and f64\n\n(rule -3 (lower (has_type (ty_scalar_float ty) (bnot x)))\n      (x64_xor_vector ty x (vector_all_ones)))\n\n;; Special case for vector-types where bit-negation is an xor against an\n;; all-one value\n(rule -1 (lower (has_type ty @ (multi_lane _bits _lanes) (bnot x)))\n      (x64_xor_vector ty x (vector_all_ones)))\n\n;;;; Rules for `bitselect` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type ty @ (multi_lane _bits _lanes)\n                       (bitselect condition\n                                  if_true\n                                  if_false)))\n      ;; a = and if_true, condition\n      ;; b = and_not condition, if_false\n      ;; or b, a\n      (let ((cond_xmm Xmm condition)\n            (a Xmm (sse_and ty if_true cond_xmm))\n            (b Xmm (sse_and_not ty cond_xmm if_false)))\n        (sse_or ty b a)))\n\n;; If every byte of the condition is guaranteed to be all ones or all zeroes,\n;; we can use x64_blend.\n(rule 1 (lower (has_type ty @ (multi_lane _bits _lanes)\n                         (bitselect condition\n                                    if_true\n                                    if_false)))\n      (if-let $true (use_sse41))\n      (if (all_ones_or_all_zeros condition))\n      (x64_pblendvb if_false if_true condition))\n\n(decl pure partial all_ones_or_all_zeros (Value) bool)\n(rule (all_ones_or_all_zeros (and (icmp _ _ _) (value_type (multi_lane _ _)))) $true)\n(rule (all_ones_or_all_zeros (and (fcmp _ _ _) (value_type (multi_lane _ _)))) $true)\n(rule (all_ones_or_all_zeros (vconst (vconst_all_ones_or_all_zeros))) $true)\n\n(decl pure vconst_all_ones_or_all_zeros () Constant)\n(extern extractor vconst_all_ones_or_all_zeros vconst_all_ones_or_all_zeros)\n\n;; Specializations for floating-pointer compares to generate a `minp*` or a\n;; `maxp*` instruction. These are equivalent to the wasm `f32x4.{pmin,pmax}`\n;; instructions and how they're lowered into CLIF. Note the careful ordering\n;; of all the operands here to ensure that the input CLIF matched is implemented\n;; by the corresponding x64 instruction.\n(rule 2 (lower (has_type $F32X4 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minps x y))\n(rule 2 (lower (has_type $F64X2 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minpd x y))\n\n(rule 3 (lower (has_type $F32X4 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxps x y))\n(rule 3 (lower (has_type $F64X2 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxpd x y))\n\n;; Scalar rules\n\n(rule 3 (lower (has_type $I128 (bitselect c t f)))\n      (let ((a ValueRegs (and_i128 c t))\n            (b ValueRegs (and_i128 (i128_not c) f)))\n        (or_i128 a b)))\n\n(rule 4 (lower (has_type (ty_int_ref_scalar_64 ty) (bitselect c t f)))\n      (let ((a Gpr (x64_and ty c t))\n            (b Gpr (x64_and ty (x64_not ty c) f)))\n        (x64_or ty a b)))\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (bitselect c t f)))\n      (let ((a Xmm (sse_and ty c t))\n            (c_neg Xmm (x64_xor_vector ty c (vector_all_ones)))\n            (b Xmm (sse_and ty c_neg f)))\n        (sse_or ty a b)))\n\n;;;; Rules for `x86_blendv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16\n                       (x86_blendv condition if_true if_false)))\n      (if-let $true (use_sse41))\n      (x64_pblendvb if_false if_true condition))\n\n(rule (lower (has_type $I32X4\n                       (x86_blendv condition if_true if_false)))\n      (if-let $true (use_sse41))\n      (x64_blendvps if_false if_true condition))\n\n(rule (lower (has_type $I64X2\n                       (x86_blendv condition if_true if_false)))\n      (if-let $true (use_sse41))\n      (x64_blendvpd if_false if_true condition))\n\n;;;; Rules for `insertlane` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (insertlane vec @ (value_type ty) val (u8_from_uimm8 idx)))\n      (vec_insert_lane ty vec val idx))\n\n;; Helper function used below for `insertlane` but also here for other\n;; lowerings.\n;;\n;; Note that the `Type` used here is the type of vector the insertion is\n;; happening into, or the type of the first `Reg` argument.\n(decl vec_insert_lane (Type Xmm RegMem u8) Xmm)\n\n;; i8x16.replace_lane\n(rule 1 (vec_insert_lane $I8X16 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_pinsrb vec val idx))\n\n;; This lowering is particularly unoptimized and is mostly just here to work\n;; rather than here to be fast. Requiring SSE 4.1 for the above lowering isn't\n;; the end of the world hopefully as that's a pretty old instruction set, so\n;; this is the \"simplest\" version that works on SSE2 for now.\n;;\n;; This lowering masks the original vector with a constant with all 1s except\n;; for the \"hole\" where this value will get placed into, meaning the desired\n;; lane is guaranteed as all 0s. Next the `val` is shuffled into this hole with\n;; a few operations:\n;;\n;;  1. The `val` is zero-extended to 32-bits to guarantee the lower 32-bits\n;;     are all defined.\n;;  2. An arithmetic shift-left is used with the low two bits of `n`, the\n;;     desired lane, to move the value into the right position within the 32-bit\n;;     register value.\n;;  3. The 32-bit register is moved with `movd` into an XMM register\n;;  4. The XMM register, where all lanes are 0 except for the first lane which\n;;     has the shifted value, is then shuffled with `pshufd` to move the\n;;     shifted value to the correct and final lane. This uses the upper two\n;;     bits of `n` to index the i32x4 lane that we're targeting.\n;;\n;; This all, laboriously, gets the `val` into the desired lane so it's then\n;; `por`'d with the original vec-with-a-hole to produce the final result of the\n;; insertion.\n(rule (vec_insert_lane $I8X16 vec val n)\n      (let ((vec_with_hole Xmm (x64_pand vec (insert_i8x16_lane_hole n)))\n            (val Gpr (x64_movzx (ExtMode.BL) val))\n            (val Gpr (x64_shl $I32 val (Imm8Reg.Imm8 (u8_shl (u8_and n 3) 3))))\n            (val Xmm (x64_movd_to_xmm val))\n            (val_at_hole Xmm (x64_pshufd val (insert_i8x16_lane_pshufd_imm (u8_shr n 2)))))\n        (x64_por vec_with_hole val_at_hole)))\n\n(decl insert_i8x16_lane_hole (u8) VCodeConstant)\n(extern constructor insert_i8x16_lane_hole insert_i8x16_lane_hole)\n(decl insert_i8x16_lane_pshufd_imm (u8) u8)\n(rule (insert_i8x16_lane_pshufd_imm 0) 0b01_01_01_00)\n(rule (insert_i8x16_lane_pshufd_imm 1) 0b01_01_00_01)\n(rule (insert_i8x16_lane_pshufd_imm 2) 0b01_00_01_01)\n(rule (insert_i8x16_lane_pshufd_imm 3) 0b00_01_01_01)\n\n;; i16x8.replace_lane\n(rule (vec_insert_lane $I16X8 vec val idx)\n      (x64_pinsrw vec val idx))\n\n;; i32x4.replace_lane\n(rule 1 (vec_insert_lane $I32X4 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_pinsrd vec val idx))\n\n(rule (vec_insert_lane $I32X4 vec val 0)\n      (x64_movss_regmove vec (x64_movd_to_xmm val)))\n\n;; tmp    = [ vec[1] vec[0] val[1] val[0] ]\n;; result = [ vec[3] vec[2] tmp[0] tmp[2] ]\n(rule (vec_insert_lane $I32X4 vec val 1)\n      (let ((val Xmm (x64_movd_to_xmm val))\n            (vec Xmm vec))\n        (x64_shufps (x64_punpcklqdq val vec) vec 0b11_10_00_10)))\n\n;; tmp    = [ vec[0] vec[3] val[0] val[0] ]\n;; result = [ tmp[2] tmp[0] vec[1] vec[0] ]\n(rule (vec_insert_lane $I32X4 vec val 2)\n      (let ((val Xmm (x64_movd_to_xmm val))\n            (vec Xmm vec))\n        (x64_shufps vec (x64_shufps val vec 0b00_11_00_00) 0b10_00_01_00)))\n\n;; tmp    = [ vec[3] vec[2] val[1] val[0] ]\n;; result = [ tmp[0] tmp[2] vec[1] vec[0] ]\n(rule (vec_insert_lane $I32X4 vec val 3)\n      (let ((val Xmm (x64_movd_to_xmm val))\n            (vec Xmm vec))\n        (x64_shufps vec (x64_shufps val vec 0b11_10_01_00) 0b00_10_01_00)))\n\n;; i64x2.replace_lane\n(rule 1 (vec_insert_lane $I64X2 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_pinsrq vec val idx))\n(rule (vec_insert_lane $I64X2 vec val 0)\n      (x64_movsd_regmove vec (x64_movq_to_xmm val)))\n(rule (vec_insert_lane $I64X2 vec val 1)\n      (x64_punpcklqdq vec (x64_movq_to_xmm val)))\n\n;; f32x4.replace_lane\n(rule 1 (vec_insert_lane $F32X4 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_insertps vec val (sse_insertps_lane_imm idx)))\n\n;; f32x4.replace_lane 0 - without insertps\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 0)\n      (x64_movss_regmove vec val))\n\n;; f32x4.replace_lane 1 - without insertps\n;; tmp    = [ vec[1] vec[0] val[1] val[0] ]\n;; result = [ vec[3] vec[2] tmp[0] tmp[2] ]\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 1)\n      (let ((tmp Xmm (x64_movlhps val vec)))\n        (x64_shufps tmp vec 0b11_10_00_10)))\n\n;; f32x4.replace_lane 2 - without insertps\n;; tmp    = [ vec[0] vec[3] val[0] val[0] ]\n;; result = [ tmp[2] tmp[0] vec[1] vec[0] ]\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 2)\n      (let ((tmp Xmm (x64_shufps val vec 0b00_11_00_00)))\n        (x64_shufps vec tmp 0b10_00_01_00)))\n\n;; f32x4.replace_lane 3 - without insertps\n;; tmp    = [ vec[3] vec[2] val[1] val[0] ]\n;; result = [ tmp[0] tmp[2] vec[1] vec[0] ]\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 3)\n      (let ((tmp Xmm (x64_shufps val vec 0b11_10_01_00)))\n        (x64_shufps vec tmp 0b00_10_01_00)))\n\n;; Recursively delegate to the above rules by loading from memory first.\n(rule (vec_insert_lane $F32X4 vec (RegMem.Mem addr) idx)\n      (vec_insert_lane $F32X4 vec (x64_movss_load addr) idx))\n\n;; External rust code used to calculate the immediate value to `insertps`.\n(decl sse_insertps_lane_imm (u8) u8)\n(extern constructor sse_insertps_lane_imm sse_insertps_lane_imm)\n\n;; f64x2.replace_lane 0\n;;\n;; Here the `movsd` instruction is used specifically to specialize moving\n;; into the fist lane where unlike above cases we're not using the lane\n;; immediate as an immediate to the instruction itself.\n(rule (vec_insert_lane $F64X2 vec (RegMem.Reg val) 0)\n      (x64_movsd_regmove vec val))\n(rule (vec_insert_lane $F64X2 vec (RegMem.Mem val) 0)\n      (x64_movsd_regmove vec (x64_movsd_load val)))\n\n;; f64x2.replace_lane 1\n;;\n;; Here the `movlhps` instruction is used specifically to specialize moving\n;; into the second lane where unlike above cases we're not using the lane\n;; immediate as an immediate to the instruction itself.\n(rule (vec_insert_lane $F64X2 vec val 1)\n      (x64_movlhps vec val))\n\n;;;; Rules for `smin`, `smax`, `umin`, `umax` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(decl cmp_and_choose (Type CC Value Value) ValueRegs)\n(rule (cmp_and_choose (fits_in_64 ty) cc x y)\n      (let ((size OperandSize (raw_operand_size_of_type ty))\n            ;; We need to put x and y in registers explicitly because\n            ;; we use the values more than once. Hence, even if these\n            ;; are \"unique uses\" at the CLIF level and would otherwise\n            ;; allow for load-op merging, here we cannot do that.\n            (x_reg Reg x)\n            (y_reg Reg y))\n        (with_flags_reg (x64_cmp size x_reg y_reg)\n                        (cmove ty cc y_reg x_reg))))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (umin x y)))\n      (cmp_and_choose ty (CC.B) x y))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (umax x y)))\n      (cmp_and_choose ty (CC.NB) x y))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (smin x y)))\n      (cmp_and_choose ty (CC.L) x y))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (smax x y)))\n      (cmp_and_choose ty (CC.NL) x y))\n\n;; SSE helpers for determining if single-instruction lowerings are available.\n\n(decl pure has_pmins (Type) bool)\n(rule 1 (has_pmins $I16X8) $true)\n(rule 1 (has_pmins $I64X2) $false)\n(rule (has_pmins _) (use_sse41))\n\n(decl pure has_pmaxs (Type) bool)\n(rule 1 (has_pmaxs $I16X8) $true)\n(rule 1 (has_pmaxs $I64X2) $false)\n(rule (has_pmaxs _) (use_sse41))\n\n(decl pure has_pmaxu (Type) bool)\n(rule 1 (has_pmaxu $I8X16) $true)\n(rule 1 (has_pmaxu $I64X2) $false)\n(rule (has_pmaxu _) (use_sse41))\n\n(decl pure has_pminu (Type) bool)\n(rule 1 (has_pminu $I8X16) $true)\n(rule 1 (has_pminu $I64X2) $false)\n(rule (has_pminu _) (use_sse41))\n\n;; SSE `smax`.\n\n(rule (lower (has_type (ty_vec128 ty) (smax x y)))\n      (lower_vec_smax ty x y))\n\n(decl lower_vec_smax (Type Xmm Xmm) Xmm)\n(rule 1 (lower_vec_smax ty x y)\n        (if-let $true (has_pmaxs ty))\n        (x64_pmaxs ty x y))\n\n(rule (lower_vec_smax ty x y)\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (cmp Xmm (x64_pcmpgt ty x y))\n          (x_is_max Xmm (x64_pand cmp x))\n          (y_is_max Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_max y_is_max)))\n\n;; SSE `smin`.\n\n(rule 1 (lower (has_type (ty_vec128 ty) (smin x y)))\n        (if-let $true (has_pmins ty))\n        (x64_pmins ty x y))\n\n(rule (lower (has_type (ty_vec128 ty) (smin x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (cmp Xmm (x64_pcmpgt ty y x))\n          (x_is_min Xmm (x64_pand cmp x))\n          (y_is_min Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_min y_is_min)))\n\n;; SSE `umax`.\n\n(rule 2 (lower (has_type (ty_vec128 ty) (umax x y)))\n        (if-let $true (has_pmaxu ty))\n        (x64_pmaxu ty x y))\n\n;; If y < x then the saturating subtraction will be zero, otherwise when added\n;; back to x it'll return y.\n(rule 1 (lower (has_type $I16X8 (umax x y)))\n        (let ((x Xmm x))\n          (x64_paddw x (x64_psubusw y x))))\n\n;; Flip the upper bits of each lane so the signed comparison has the same\n;; result as a signed comparison, and then select the results with the output\n;; mask. See `pcmpgt` lowering for info on flipping the upper bit.\n(rule (lower (has_type (ty_vec128 ty) (umax x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (mask Xmm (flip_high_bit_mask ty))\n          (x_masked Xmm (x64_pxor x mask))\n          (y_masked Xmm (x64_pxor y mask))\n          (cmp Xmm (x64_pcmpgt ty x_masked y_masked))\n          (x_is_max Xmm (x64_pand cmp x))\n          (y_is_max Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_max y_is_max)))\n\n(decl flip_high_bit_mask (Type) Xmm)\n(rule (flip_high_bit_mask $I16X8)\n      (x64_movdqu_load (emit_u128_le_const 0x8000_8000_8000_8000_8000_8000_8000_8000)))\n(rule (flip_high_bit_mask $I32X4)\n      (x64_movdqu_load (emit_u128_le_const 0x80000000_80000000_80000000_80000000)))\n(rule (flip_high_bit_mask $I64X2)\n      (x64_movdqu_load (emit_u128_le_const 0x8000000000000000_8000000000000000)))\n\n;; SSE `umin`.\n\n(rule 2 (lower (has_type (ty_vec128 ty) (umin x y)))\n        (if-let $true (has_pminu ty))\n        (x64_pminu ty x y))\n\n;; If x < y then the saturating subtraction will be 0. Otherwise if x > y then\n;; the saturated result, when subtracted again, will go back to `y`.\n(rule 1 (lower (has_type $I16X8 (umin x y)))\n        (let ((x Xmm x))\n          (x64_psubw x (x64_psubusw x y))))\n\n;; Same as `umax`, and see `pcmpgt` for docs on flipping the upper bit.\n(rule (lower (has_type (ty_vec128 ty) (umin x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (mask Xmm (flip_high_bit_mask ty))\n          (x_masked Xmm (x64_pxor x mask))\n          (y_masked Xmm (x64_pxor y mask))\n          (cmp Xmm (x64_pcmpgt ty y_masked x_masked))\n          (x_is_max Xmm (x64_pand cmp x))\n          (y_is_max Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_max y_is_max)))\n\n;;;; Rules for `trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (trap code))\n      (side_effect (x64_ud2 code)))\n\n;;;; Rules for `uadd_overflow_trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (fits_in_64 ty) (uadd_overflow_trap a b tc)))\n      (with_flags\n        (x64_add_with_flags_paired ty a b)\n        (trap_if (CC.B) tc)))\n\n;; Handle lhs immediates/sinkable loads in addition to the automatic rhs\n;; handling of above.\n\n(rule 1 (lower (has_type (fits_in_64 ty)\n                         (uadd_overflow_trap (simm32_from_value a) b tc)))\n      (with_flags\n        (x64_add_with_flags_paired ty b a)\n        (trap_if (CC.B) tc)))\n\n(rule 2 (lower (has_type (fits_in_64 ty)\n                         (uadd_overflow_trap (sinkable_load a) b tc)))\n      (with_flags\n        (x64_add_with_flags_paired ty b a)\n        (trap_if (CC.B) tc)))\n\n;;;; Rules for `resumable_trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (resumable_trap code))\n      (side_effect (x64_ud2 code)))\n\n;;;; Rules for `return` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; N.B.: the Ret itself is generated by the ABI.\n(rule (lower (return args))\n      (lower_return args))\n\n;;;; Rules for `icmp` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule -2 (lower (icmp cc a @ (value_type (fits_in_64 ty)) b))\n      (lower_icmp_bool (emit_cmp cc a b)))\n\n(rule -1 (lower (icmp cc a @ (value_type $I128) b))\n      (lower_icmp_bool (emit_cmp cc a b)))\n\n;; Peephole optimization for `x < 0`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThan) x @ (value_type $I64) (u64_from_iconst 0))))\n      (x64_shr $I64 x (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `0 > x`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThan) (u64_from_iconst 0) x @ (value_type $I64))))\n      (x64_shr $I64 x (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `0 <= x`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThanOrEqual) (u64_from_iconst 0) x @ (value_type $I64))))\n      (x64_shr $I64 (x64_not $I64 x) (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `x >= 0`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThanOrEqual) x @ (value_type $I64) (u64_from_iconst 0))))\n      (x64_shr $I64 (x64_not $I64 x) (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `x < 0`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThan) x @ (value_type $I32) (u64_from_iconst 0))))\n      (x64_shr $I32 x (Imm8Reg.Imm8 31)))\n\n;; Peephole optimization for `0 > x`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThan) (u64_from_iconst 0) x @ (value_type $I32))))\n      (x64_shr $I32 x (Imm8Reg.Imm8 31)))\n\n;; Peephole optimization for `0 <= x`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThanOrEqual) (u64_from_iconst 0) x @ (value_type $I32))))\n      (x64_shr $I32 (x64_not $I64 x) (Imm8Reg.Imm8 31)))\n\n;; Peephole optimization for `x >= 0`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThanOrEqual) x @ (value_type $I32) (u64_from_iconst 0))))\n      (x64_shr $I32 (x64_not $I64 x) (Imm8Reg.Imm8 31)))\n\n;; For XMM-held values, we lower to `PCMP*` instructions, sometimes more than\n;; one. To note: what is different here about the output values is that each\n;; lane will be filled with all 1s or all 0s according to the comparison,\n;; whereas for GPR-held values, the result will be simply 0 or 1 (upper bits\n;; unset).\n(rule (lower (icmp (IntCC.Equal) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pcmpeq ty a b))\n\n;; To lower a not-equals comparison, we perform an equality comparison\n;; (PCMPEQ*) and then invert the bits (PXOR with all 1s).\n(rule (lower (icmp (IntCC.NotEqual) a @ (value_type (ty_vec128 ty)) b))\n      (let ((checked Xmm (x64_pcmpeq ty a b))\n            (all_ones Xmm (vector_all_ones)))\n           (x64_pxor checked all_ones)))\n\n;; SSE `sgt`\n\n(rule (lower (icmp (IntCC.SignedGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pcmpgt ty a b))\n\n;; SSE `slt`\n\n(rule (lower (icmp (IntCC.SignedLessThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pcmpgt ty b a))\n\n;; SSE `ugt`\n\n;; N.B.: we must manually prevent load coalescing operands; the\n;; register allocator gets confused otherwise.\n(rule 1 (lower (icmp (IntCC.UnsignedGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmaxu ty))\n        (let ((a Xmm a)\n              (b Xmm b)\n              (max Xmm (x64_pmaxu ty a b))\n              (eq Xmm (x64_pcmpeq ty max b)))\n             (x64_pxor eq (vector_all_ones))))\n\n;; Flip the upper bit of each lane so the result of a signed comparison is the\n;; same as the result of an unsigned comparison (see docs on `pcmpgt` for more)\n(rule (lower (icmp (IntCC.UnsignedGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (let ((mask Xmm (flip_high_bit_mask ty))\n            (a_masked Xmm (x64_pxor a mask))\n            (b_masked Xmm (x64_pxor b mask)))\n           (x64_pcmpgt ty a_masked b_masked)))\n\n;; SSE `ult`\n\n(rule 1 (lower (icmp (IntCC.UnsignedLessThan) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pminu ty))\n        ;; N.B.: see note above.\n        (let ((a Xmm a)\n              (b Xmm b)\n              (min Xmm (x64_pminu ty a b))\n              (eq Xmm (x64_pcmpeq ty min b)))\n             (x64_pxor eq (vector_all_ones))))\n\n;; Flip the upper bit of `a` and `b` so the signed comparison result will\n;; be the same as the unsigned comparison result (see docs on `pcmpgt` for more).\n(rule (lower (icmp (IntCC.UnsignedLessThan) a @ (value_type (ty_vec128 ty)) b))\n      (let ((mask Xmm (flip_high_bit_mask ty))\n            (a_masked Xmm (x64_pxor a mask))\n            (b_masked Xmm (x64_pxor b mask)))\n           (x64_pcmpgt ty b_masked a_masked)))\n\n;; SSE `sge`\n\n;; Use `pmaxs*` and compare the result to `a` to see if it's `>= b`.\n(rule 1 (lower (icmp (IntCC.SignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmaxs ty))\n        (x64_pcmpeq ty a (x64_pmaxs ty a b)))\n\n;; Without `pmaxs*` use a `pcmpgt*` with reversed operands and invert the\n;; result.\n(rule (lower (icmp (IntCC.SignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pxor (x64_pcmpgt ty b a) (vector_all_ones)))\n\n;; SSE `sle`\n\n;; With `pmins*` use that and compare the result to `a`.\n(rule 1 (lower (icmp (IntCC.SignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmins ty))\n        (x64_pcmpeq ty a (x64_pmins ty a b)))\n\n;; Without `pmins*` perform a greater-than test and invert the result.\n(rule (lower (icmp (IntCC.SignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pxor (x64_pcmpgt ty a b) (vector_all_ones)))\n\n;; SSE `uge`\n\n(rule 2 (lower (icmp (IntCC.UnsignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmaxu ty))\n        (x64_pcmpeq ty a (x64_pmaxu ty a b)))\n\n;; Perform a saturating subtract of `a` from `b` and if the result is zero then\n;; `a` is greater or equal.\n(rule 1 (lower (icmp (IntCC.UnsignedGreaterThanOrEqual) a @ (value_type $I16X8) b))\n         (x64_pcmpeqw (x64_psubusw b a) (xmm_zero $I16X8)))\n\n;; Flip the upper bit of each lane so the signed comparison is the same as\n;; an unsigned one and then invert the result. See docs on `pcmpgt` for why\n;; flipping the upper bit works.\n(rule (lower (icmp (IntCC.UnsignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (let (\n          (mask Xmm (flip_high_bit_mask ty))\n          (a_masked Xmm (x64_pxor a mask))\n          (b_masked Xmm (x64_pxor b mask))\n          (cmp Xmm (x64_pcmpgt ty b_masked a_masked))\n        )\n        (x64_pxor cmp (vector_all_ones))))\n\n;; SSE `ule`\n\n(rule 2 (lower (icmp (IntCC.UnsignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pminu ty))\n        (x64_pcmpeq ty a (x64_pminu ty a b)))\n\n;; A saturating subtraction will produce zeros if `a` is less than `b`, so\n;; compare that result to an all-zeros result to figure out lanes of `a` that\n;; are <= to the lanes in `b`\n(rule 1 (lower (icmp (IntCC.UnsignedLessThanOrEqual) a @ (value_type $I16X8) b))\n        (let ((zeros_if_a_is_min Xmm (x64_psubusw a b)))\n            (x64_pcmpeqw zeros_if_a_is_min (xmm_zero $I8X16))))\n\n;; Flip the upper bit of each lane in `a` and `b` so a signed comparison\n;; produces the same result as an unsigned comparison. Then test test for `gt`\n;; and invert the result to get the `le` that is desired here. See docs on\n;; `pcmpgt` for why flipping the upper bit works.\n(rule (lower (icmp (IntCC.UnsignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (let (\n          (mask Xmm (flip_high_bit_mask ty))\n          (a_masked Xmm (x64_pxor a mask))\n          (b_masked Xmm (x64_pxor b mask))\n          (cmp Xmm (x64_pcmpgt ty a_masked b_masked))\n        )\n        (x64_pxor cmp (vector_all_ones))))\n\n;;;; Rules for `fcmp` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; CLIF's `fcmp` instruction always operates on XMM registers--both scalar and\n;; vector. For the scalar versions, we use the flag-setting behavior of the\n;; `UCOMIS*` instruction to `SETcc` a 0 or 1 in a GPR register. Note that CLIF's\n;; `select` uses the same kind of flag-setting behavior but chooses values other\n;; than 0 or 1.\n;;\n;; Checking the result of `UCOMIS*` is unfortunately difficult in some cases\n;; because we do not have `SETcc` instructions that explicitly check\n;; simultaneously for the condition (i.e., `eq`, `le`, `gt`, etc.) *and*\n;; orderedness. Instead, we must check the flags multiple times. The UCOMIS*\n;; documentation (see Intel's Software Developer's Manual, volume 2, chapter 4)\n;; is helpful:\n;;  - unordered assigns    Z = 1, P = 1, C = 1\n;;  - greater than assigns Z = 0, P = 0, C = 0\n;;  - less than assigns    Z = 0, P = 0, C = 1\n;;  - equal assigns        Z = 1, P = 0, C = 0\n\n(rule -1 (lower (fcmp cc a @ (value_type (ty_scalar_float ty)) b))\n      (lower_fcmp_bool (emit_fcmp cc a b)))\n\n;; For vector lowerings, we use `CMPP*` instructions with a 3-bit operand that\n;; determines the comparison to make. Note that comparisons that succeed will\n;; fill the lane with 1s; comparisons that do not will fill the lane with 0s.\n\n(rule (lower (fcmp (FloatCC.Equal) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.Equal)))\n(rule (lower (fcmp (FloatCC.NotEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.NotEqual)))\n(rule (lower (fcmp (FloatCC.LessThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.LessThan)))\n(rule (lower (fcmp (FloatCC.LessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.LessThanOrEqual)))\n(rule (lower (fcmp (FloatCC.Ordered) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.Ordered)))\n(rule (lower (fcmp (FloatCC.Unordered) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.Unordered)))\n(rule (lower (fcmp (FloatCC.UnorderedOrGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.UnorderedOrGreaterThan)))\n(rule (lower (fcmp (FloatCC.UnorderedOrGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.UnorderedOrGreaterThanOrEqual)))\n\n;; Some vector lowerings rely on flipping the operands and using a reversed\n;; comparison code.\n\n(rule (lower (fcmp (FloatCC.GreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.LessThan)))\n(rule (lower (fcmp (FloatCC.GreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.LessThanOrEqual)))\n(rule (lower (fcmp (FloatCC.UnorderedOrLessThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.UnorderedOrGreaterThan)))\n(rule (lower (fcmp (FloatCC.UnorderedOrLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.UnorderedOrGreaterThanOrEqual)))\n\n;; Some vector lowerings are simply not supported for certain codes:\n;; - FloatCC::OrderedNotEqual\n;; - FloatCC::UnorderedOrEqual\n\n;;;; Rules for `select` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; When a `select` has an `fcmp` as a condition then rely on `emit_fcmp` to\n;; figure out how to perform the comparison.\n;;\n;; Note, though, that the `FloatCC.Equal` requires an \"and\" to happen for two\n;; condition codes which isn't the easiest thing to lower to a `cmove`\n;; instruction. For this reason a `select (fcmp eq ..) ..` is instead\n;; flipped around to be `select (fcmp ne ..) ..` with all operands reversed.\n;; This will produce a `FcmpCondResult.OrCondition` which is easier to codegen\n;; for.\n(rule (lower (has_type ty (select (maybe_uextend (fcmp cc a b)) x y)))\n      (lower_select_fcmp ty (emit_fcmp cc a b) x y))\n(rule 1 (lower (has_type ty (select (maybe_uextend (fcmp (FloatCC.Equal) a b)) x y)))\n        (lower_select_fcmp ty (emit_fcmp (FloatCC.NotEqual) a b) y x))\n\n(decl lower_select_fcmp (Type FcmpCondResult Value Value) InstOutput)\n(rule (lower_select_fcmp ty (FcmpCondResult.Condition flags cc) x y)\n      (with_flags flags (cmove_from_values ty cc x y)))\n(rule (lower_select_fcmp ty (FcmpCondResult.OrCondition flags cc1 cc2) x y)\n      (with_flags flags (cmove_or_from_values ty cc1 cc2 x y)))\n\n;; We also can lower `select`s that depend on an `icmp` test, but more simply\n;; than the `fcmp` variants above. In these cases, we lower to a `CMP`\n;; instruction plus a `CMOV`; recall that `cmove_from_values` here may emit more\n;; than one instruction for certain types (e.g., XMM-held, I128).\n\n(rule (lower (has_type ty (select (maybe_uextend (icmp cc a @ (value_type (fits_in_64 a_ty)) b)) x y)))\n      (let ((size OperandSize (raw_operand_size_of_type a_ty)))\n           (with_flags (x64_cmp size b a) (cmove_from_values ty cc x y))))\n\n;; Finally, we lower `select` from a condition value `c`. These rules are meant\n;; to be the final, default lowerings if no other patterns matched above.\n\n(rule -1 (lower (has_type ty (select c @ (value_type (fits_in_64 a_ty)) x y)))\n      (let ((size OperandSize (raw_operand_size_of_type a_ty))\n            ;; N.B.: disallow load-op fusion, see above. TODO:\n            ;; https://github.com/bytecodealliance/wasmtime/issues/3953.\n            (gpr_c Gpr (put_in_gpr c)))\n           (with_flags (x64_test size gpr_c gpr_c) (cmove_from_values ty (CC.NZ) x y))))\n\n(rule -2 (lower (has_type ty (select c @ (value_type $I128) x y)))\n      (let ((cond_result IcmpCondResult (cmp_zero_i128 (CC.Z) c)))\n        (select_icmp cond_result x y)))\n\n;; Specializations for floating-point compares to generate a `mins*` or a\n;; `maxs*` instruction. These are equivalent to the \"pseudo-m{in,ax}\"\n;; specializations for vectors.\n(rule 2 (lower (has_type $F32 (select (maybe_uextend (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minss x y))\n(rule 2 (lower (has_type $F64 (select (maybe_uextend (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minsd x y))\n(rule 3 (lower (has_type $F32 (select (maybe_uextend (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxss x y))\n(rule 3 (lower (has_type $F64 (select (maybe_uextend (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxsd x y))\n\n;; Rules for `clz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; If available, we can use a plain lzcnt instruction here. Note no\n;; special handling is required for zero inputs, because the machine\n;; instruction does what the CLIF expects for zero, i.e. it returns\n;; zero.\n(rule 3 (lower (has_type (ty_32_or_64 ty) (clz src)))\n      (if-let $true (use_lzcnt))\n      (x64_lzcnt ty src))\n\n(rule 2 (lower (has_type (ty_32_or_64 ty) (clz src)))\n      (do_clz ty ty src))\n\n(rule 1 (lower\n       (has_type (ty_8_or_16 ty)\n                 (clz src)))\n      (do_clz $I32 ty (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule 0 (lower\n       (has_type $I128\n                 (clz src)))\n      (let ((upper Gpr (do_clz $I64 $I64 (value_regs_get_gpr src 1)))\n            (lower Gpr (x64_add $I64\n                            (do_clz $I64 $I64 (value_regs_get_gpr src 0))\n                            (RegMemImm.Imm 64)))\n            (result_lo Gpr\n              (with_flags_reg\n               (x64_cmp_imm (OperandSize.Size64) 64 upper)\n               (cmove $I64 (CC.NZ) upper lower))))\n        (value_regs result_lo (imm $I64 0))))\n\n;; Implementation helper for clz; operates on 32 or 64-bit units.\n(decl do_clz (Type Type Gpr) Gpr)\n(rule (do_clz ty orig_ty src)\n      (let ((highest_bit_index Reg (bsr_or_else ty src (imm_i64 $I64 -1)))\n            (bits_minus_1 Reg (imm ty (u64_sub (ty_bits_u64 orig_ty) 1))))\n        (x64_sub ty bits_minus_1 highest_bit_index)))\n\n;; Rules for `ctz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Analogous to `clz` cases above, but using mirror instructions\n;; (tzcnt vs lzcnt, bsf vs bsr).\n\n(rule 3 (lower (has_type (ty_32_or_64 ty) (ctz src)))\n      (if-let $true (use_bmi1))\n      (x64_tzcnt ty src))\n\n(rule 2 (lower (has_type (ty_32_or_64 ty) (ctz src)))\n      (do_ctz ty ty src))\n\n(rule 1 (lower\n       (has_type (ty_8_or_16 ty)\n                 (ctz src)))\n      (do_ctz $I32 ty (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule 0 (lower\n       (has_type $I128\n                 (ctz src)))\n      (let ((lower Gpr (do_ctz $I64 $I64 (value_regs_get_gpr src 0)))\n            (upper Gpr (x64_add $I64\n                            (do_ctz $I64 $I64 (value_regs_get_gpr src 1))\n                            (RegMemImm.Imm 64)))\n            (result_lo Gpr\n              (with_flags_reg\n               (x64_cmp_imm (OperandSize.Size64) 64 lower)\n               (cmove $I64 (CC.Z) upper lower))))\n        (value_regs result_lo (imm $I64 0))))\n\n(decl do_ctz (Type Type Gpr) Gpr)\n(rule (do_ctz ty orig_ty src)\n      (bsf_or_else ty src (imm $I64 (ty_bits_u64 orig_ty))))\n\n;; Rules for `popcnt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 4 (lower (has_type (ty_32_or_64 ty) (popcnt src)))\n      (if-let $true (use_popcnt))\n      (x64_popcnt ty src))\n\n(rule 3 (lower (has_type (ty_8_or_16 ty) (popcnt src)))\n      (if-let $true (use_popcnt))\n      (x64_popcnt $I32 (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule 1 (lower (has_type $I128 (popcnt src)))\n      (if-let $true (use_popcnt))\n      (let ((lo_count Gpr (x64_popcnt $I64 (value_regs_get_gpr src 0)))\n            (hi_count Gpr (x64_popcnt $I64 (value_regs_get_gpr src 1))))\n        (value_regs (x64_add $I64 lo_count hi_count) (imm $I64 0))))\n\n(rule -1 (lower\n       (has_type (ty_32_or_64 ty)\n                 (popcnt src)))\n      (do_popcnt ty src))\n\n(rule -2 (lower\n       (has_type (ty_8_or_16 ty)\n                 (popcnt src)))\n      (do_popcnt $I32 (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule (lower\n       (has_type $I128\n                 (popcnt src)))\n      (let ((lo_count Gpr (do_popcnt $I64 (value_regs_get_gpr src 0)))\n            (hi_count Gpr (do_popcnt $I64 (value_regs_get_gpr src 1))))\n        (value_regs (x64_add $I64 lo_count hi_count) (imm $I64 0))))\n\n;; Implementation of popcount when we don't nave a native popcount\n;; instruction.\n(decl do_popcnt (Type Gpr) Gpr)\n(rule (do_popcnt $I64 src)\n      (let ((shifted1 Gpr (x64_shr $I64 src (Imm8Reg.Imm8 1)))\n            (sevens Gpr (imm $I64 0x7777777777777777))\n            (masked1 Gpr (x64_and $I64 shifted1 sevens))\n            ;; diff1 := src - ((src >> 1) & 0b0111_0111_0111...)\n            (diff1 Gpr (x64_sub $I64 src masked1))\n            (shifted2 Gpr (x64_shr $I64 masked1 (Imm8Reg.Imm8 1)))\n            (masked2 Gpr (x64_and $I64 shifted2 sevens))\n            ;; diff2 := diff1 - ((diff1 >> 1) & 0b0111_0111_0111...)\n            (diff2 Gpr (x64_sub $I64 diff1 masked2))\n            (shifted3 Gpr (x64_shr $I64 masked2 (Imm8Reg.Imm8 1)))\n            (masked3 Gpr (x64_and $I64 shifted3 sevens))\n            ;; diff3 := diff2 - ((diff2 >> 1) & 0b0111_0111_0111...)\n            ;;\n            ;; At this point, each nibble of diff3 is the popcount of\n            ;; that nibble. This works because at each step above, we\n            ;; are basically subtracting floor(value / 2) from the\n            ;; running value; the leftover remainder is 1 if the LSB\n            ;; was 1. After three steps, we have (nibble / 8) -- 0 or\n            ;; 1 for the MSB of the nibble -- plus three possible\n            ;; additions for the three other bits.\n            (diff3 Gpr (x64_sub $I64 diff2 masked3))\n            ;; Add the two nibbles of each byte together.\n            (sum1 Gpr (x64_add $I64\n                           (x64_shr $I64 diff3 (Imm8Reg.Imm8 4))\n                           diff3))\n            ;; Mask the above sum to have the popcount for each byte\n            ;; in the lower nibble of that byte.\n            (ofof Gpr (imm $I64 0x0f0f0f0f0f0f0f0f))\n            (masked4 Gpr (x64_and $I64 sum1 ofof))\n            (ones Gpr (imm $I64 0x0101010101010101))\n            ;; Use a multiply to sum all of the bytes' popcounts into\n            ;; the top byte. Consider the binomial expansion for the\n            ;; top byte: it is the sum of the bytes (masked4 >> 56) *\n            ;; 0x01 + (masked4 >> 48) * 0x01 + (masked4 >> 40) * 0x01\n            ;; + ... + (masked4 >> 0).\n            (mul Gpr (x64_mul $I64 masked4 ones))\n            ;; Now take that top byte and return it as the popcount.\n            (final Gpr (x64_shr $I64 mul (Imm8Reg.Imm8 56))))\n        final))\n\n;; This is the 32-bit version of the above; the steps for each nibble\n;; are the same, we just use constants half as wide.\n(rule (do_popcnt $I32 src)\n      (let ((shifted1 Gpr (x64_shr $I32 src (Imm8Reg.Imm8 1)))\n            (sevens Gpr (imm $I32 0x77777777))\n            (masked1 Gpr (x64_and $I32 shifted1 sevens))\n            (diff1 Gpr (x64_sub $I32 src masked1))\n            (shifted2 Gpr (x64_shr $I32 masked1 (Imm8Reg.Imm8 1)))\n            (masked2 Gpr (x64_and $I32 shifted2 sevens))\n            (diff2 Gpr (x64_sub $I32 diff1 masked2))\n            (shifted3 Gpr (x64_shr $I32 masked2 (Imm8Reg.Imm8 1)))\n            (masked3 Gpr (x64_and $I32 shifted3 sevens))\n            (diff3 Gpr (x64_sub $I32 diff2 masked3))\n            (sum1 Gpr (x64_add $I32\n                           (x64_shr $I32 diff3 (Imm8Reg.Imm8 4))\n                           diff3))\n            (masked4 Gpr (x64_and $I32 sum1 (RegMemImm.Imm 0x0f0f0f0f)))\n            (mul Gpr (x64_mul $I32 masked4 (RegMemImm.Imm 0x01010101)))\n            (final Gpr (x64_shr $I32 mul (Imm8Reg.Imm8 24))))\n        final))\n\n\n(rule 2 (lower (has_type $I8X16 (popcnt src)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512bitalg))\n      (x64_vpopcntb src))\n\n\n;; For SSE 4.2 we use Mula's algorithm (https://arxiv.org/pdf/1611.07612.pdf):\n;;\n;; __m128i count_bytes ( __m128i v) {\n;;     __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n;;     __m128i low_mask = _mm_set1_epi8 (0x0f);\n;;     __m128i lo = _mm_and_si128 (v, low_mask);\n;;     __m128i hi = _mm_and_si128 (_mm_srli_epi16 (v, 4), low_mask);\n;;     __m128i cnt1 = _mm_shuffle_epi8 (lookup, lo);\n;;     __m128i cnt2 = _mm_shuffle_epi8 (lookup, hi);\n;;     return _mm_add_epi8 (cnt1, cnt2);\n;; }\n;;\n;; Details of the above algorithm can be found in the reference noted above, but the basics\n;; are to create a lookup table that pre populates the popcnt values for each number [0,15].\n;; The algorithm uses shifts to isolate 4 bit sections of the vector, pshufb as part of the\n;; lookup process, and adds together the results.\n;;\n;; __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n\n\n(rule 1 (lower (has_type $I8X16 (popcnt src)))\n      (if-let $true (use_ssse3))\n      (let ((low_mask XmmMem (emit_u128_le_const 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f))\n            (low_nibbles Xmm (sse_and $I8X16 src low_mask))\n            ;; Note that this is a 16x8 shift, but that's OK; we mask\n            ;; off anything that traverses from one byte to the next\n            ;; with the low_mask below.\n            (shifted_src Xmm (x64_psrlw src (xmi_imm 4)))\n            (high_nibbles Xmm (sse_and $I8X16 shifted_src low_mask))\n            (lookup Xmm (x64_xmm_load_const $I8X16\n              (emit_u128_le_const 0x04030302_03020201_03020201_02010100)))\n            (bit_counts_low Xmm (x64_pshufb lookup low_nibbles))\n            (bit_counts_high Xmm (x64_pshufb lookup high_nibbles)))\n        (x64_paddb bit_counts_low bit_counts_high)))\n\n;; A modified version of the popcnt method from Hacker's Delight.\n(rule (lower (has_type $I8X16 (popcnt src)))\n      (let ((mask1 XmmMem (emit_u128_le_const 0x77777777777777777777777777777777))\n            (src Xmm src)\n            (shifted Xmm (x64_pand (x64_psrlq src (xmi_imm 1)) mask1))\n            (src Xmm (x64_psubb src shifted))\n            (shifted Xmm (x64_pand (x64_psrlq shifted (xmi_imm 1)) mask1))\n            (src Xmm (x64_psubb src shifted))\n            (shifted Xmm (x64_pand (x64_psrlq shifted (xmi_imm 1)) mask1))\n            (src Xmm (x64_psubb src shifted))\n            (src Xmm (x64_paddb src (x64_psrlw src (xmi_imm 4)))))\n        (x64_pand src (emit_u128_le_const 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f))))\n\n;; Rules for `bitrev` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8 (bitrev src)))\n      (do_bitrev8 $I32 src))\n\n(rule (lower (has_type $I16 (bitrev src)))\n      (do_bitrev16 $I32 src))\n\n(rule (lower (has_type $I32 (bitrev src)))\n      (do_bitrev32 $I32 src))\n\n(rule (lower (has_type $I64 (bitrev src)))\n      (do_bitrev64 $I64 src))\n\n(rule (lower (has_type $I128 (bitrev src)))\n      (value_regs\n       (do_bitrev64 $I64 (value_regs_get_gpr src 1))\n       (do_bitrev64 $I64 (value_regs_get_gpr src 0))))\n\n(decl do_bitrev8 (Type Gpr) Gpr)\n(rule (do_bitrev8 ty src)\n      (let ((tymask u64 (ty_mask ty))\n            (mask1 Gpr (imm ty (u64_and tymask 0x5555555555555555)))\n            (lo1 Gpr (x64_and ty src mask1))\n            (hi1 Gpr (x64_and ty (x64_shr ty src (Imm8Reg.Imm8 1)) mask1))\n            (swap1 Gpr (x64_or ty\n                           (x64_shl ty lo1 (Imm8Reg.Imm8 1))\n                           hi1))\n            (mask2 Gpr (imm ty (u64_and tymask 0x3333333333333333)))\n            (lo2 Gpr (x64_and ty swap1 mask2))\n            (hi2 Gpr (x64_and ty (x64_shr ty swap1 (Imm8Reg.Imm8 2)) mask2))\n            (swap2 Gpr (x64_or ty\n                           (x64_shl ty lo2 (Imm8Reg.Imm8 2))\n                           hi2))\n            (mask4 Gpr (imm ty (u64_and tymask 0x0f0f0f0f0f0f0f0f)))\n            (lo4 Gpr (x64_and ty swap2 mask4))\n            (hi4 Gpr (x64_and ty (x64_shr ty swap2 (Imm8Reg.Imm8 4)) mask4))\n            (swap4 Gpr (x64_or ty\n                           (x64_shl ty lo4 (Imm8Reg.Imm8 4))\n                           hi4)))\n        swap4))\n\n(decl do_bitrev16 (Type Gpr) Gpr)\n(rule (do_bitrev16 ty src)\n      (let ((src_ Gpr (do_bitrev8 ty src))\n            (tymask u64 (ty_mask ty))\n            (mask8 Gpr (imm ty (u64_and tymask 0x00ff00ff00ff00ff)))\n            (lo8 Gpr (x64_and ty src_ mask8))\n            (hi8 Gpr (x64_and ty (x64_shr ty src_ (Imm8Reg.Imm8 8)) mask8))\n            (swap8 Gpr (x64_or ty\n                           (x64_shl ty lo8 (Imm8Reg.Imm8 8))\n                           hi8)))\n        swap8))\n\n(decl do_bitrev32 (Type Gpr) Gpr)\n(rule (do_bitrev32 ty src)\n      (let ((src_ Gpr (do_bitrev16 ty src))\n            (tymask u64 (ty_mask ty))\n            (mask16 Gpr (imm ty (u64_and tymask 0x0000ffff0000ffff)))\n            (lo16 Gpr (x64_and ty src_ mask16))\n            (hi16 Gpr (x64_and ty (x64_shr ty src_ (Imm8Reg.Imm8 16)) mask16))\n            (swap16 Gpr (x64_or ty\n                            (x64_shl ty lo16 (Imm8Reg.Imm8 16))\n                            hi16)))\n        swap16))\n\n(decl do_bitrev64 (Type Gpr) Gpr)\n(rule (do_bitrev64 ty @ $I64 src)\n      (let ((src_ Gpr (do_bitrev32 ty src))\n            (mask32 Gpr (imm ty 0xffffffff))\n            (lo32 Gpr (x64_and ty src_ mask32))\n            (hi32 Gpr (x64_shr ty src_ (Imm8Reg.Imm8 32)))\n            (swap32 Gpr (x64_or ty\n                            (x64_shl ty lo32 (Imm8Reg.Imm8 32))\n                            hi32)))\n        swap32))\n\n;; Rules for `bswap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; x64 bswap instruction is only for 32- or 64-bit swaps\n;; implement the 16-bit swap as a rotl by 8\n(rule (lower (has_type $I16 (bswap src)))\n      (x64_rotl $I16 src (Imm8Reg.Imm8 8)))\n\n(rule (lower (has_type $I32 (bswap src)))\n      (x64_bswap $I32 src))\n\n(rule (lower (has_type $I64 (bswap src)))\n      (x64_bswap $I64 src))\n\n(rule (lower (has_type $I128 (bswap src)))\n      (value_regs\n       (x64_bswap $I64 (value_regs_get_gpr src 1))\n       (x64_bswap $I64 (value_regs_get_gpr src 0))))\n\n;; Rules for `is_null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Null references are represented by the constant value `0`.\n(rule (lower (is_null src @ (value_type $R64)))\n      (with_flags\n       (x64_cmp_imm (OperandSize.Size64) 0 src)\n       (x64_setcc (CC.Z))))\n\n;; Rules for `is_invalid` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Invalid references are represented by the constant value `-1`.\n(rule (lower (is_invalid src @ (value_type $R64)))\n      (with_flags\n       (x64_cmp_imm (OperandSize.Size64) 0xffffffff src)  ;; simm32 0xffff_ffff is sign-extended to -1.\n       (x64_setcc (CC.Z))))\n\n\n;; Rules for `uextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; I{8,16,32,64} -> I128.\n(rule (lower (has_type $I128 (uextend src)))\n      (value_regs (extend_to_gpr src $I64 (ExtendKind.Zero)) (imm $I64 0)))\n\n;; I{8,16,32} -> I64.\n(rule (lower (has_type $I64 (uextend src)))\n      (extend_to_gpr src $I64 (ExtendKind.Zero)))\n\n;; I{8,16} -> I32\n;; I8 -> I16\n(rule -1 (lower (has_type (fits_in_32 _) (uextend src)))\n         (extend_to_gpr src $I32 (ExtendKind.Zero)))\n\n;; Rules for `sextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; I{8,16,32} -> I128.\n;;\n;; Produce upper 64 bits sign-extended from lower 64: shift right by\n;; 63 bits to spread the sign bit across the result.\n(rule (lower (has_type $I128 (sextend src)))\n      (let ((lo Gpr (extend_to_gpr src $I64 (ExtendKind.Sign)))\n            (hi Gpr (x64_sar $I64 lo (Imm8Reg.Imm8 63))))\n      (value_regs lo hi)))\n\n;; I{8,16,32} -> I64.\n(rule (lower (has_type $I64 (sextend src)))\n      (extend_to_gpr src $I64 (ExtendKind.Sign)))\n\n;; I{8,16} -> I32\n;; I8 -> I16\n(rule -1 (lower (has_type (fits_in_32 _) (sextend src)))\n         (extend_to_gpr src $I32 (ExtendKind.Sign)))\n\n;; Rules for `ireduce` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; T -> T is always a no-op, even I128 -> I128.\n(rule (lower (has_type ty (ireduce src @ (value_type ty))))\n      src)\n\n;; T -> I{64,32,16,8}: We can simply pass through the value: values\n;; are always stored with high bits undefined, so we can just leave\n;; them be.\n(rule 1 (lower (has_type (fits_in_64 ty) (ireduce src)))\n      (value_regs_get_gpr src 0))\n\n;; Rules for `debugtrap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (debugtrap))\n      (side_effect (x64_hlt)))\n\n;; Rules for `x86_pmaddubsw` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I16X8 (x86_pmaddubsw x y)))\n      (if-let $true (use_ssse3))\n      (x64_pmaddubsw y x))\n\n;; Rules for `fadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fadd x y)))\n      (x64_addss x y))\n(rule (lower (has_type $F64 (fadd x y)))\n      (x64_addsd x y))\n(rule (lower (has_type $F32X4 (fadd x y)))\n      (x64_addps x y))\n(rule (lower (has_type $F64X2 (fadd x y)))\n      (x64_addpd x y))\n\n;; The above rules automatically sink loads for rhs operands, so additionally\n;; add rules for sinking loads with lhs operands.\n(rule 1 (lower (has_type $F32 (fadd (sinkable_load x) y)))\n      (x64_addss y x))\n(rule 1 (lower (has_type $F64 (fadd (sinkable_load x) y)))\n      (x64_addsd y x))\n(rule 1 (lower (has_type $F32X4 (fadd (sinkable_load x) y)))\n      (x64_addps y x))\n(rule 1 (lower (has_type $F64X2 (fadd (sinkable_load x) y)))\n      (x64_addpd y x))\n\n;; Rules for `fsub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fsub x y)))\n      (x64_subss x y))\n(rule (lower (has_type $F64 (fsub x y)))\n      (x64_subsd x y))\n(rule (lower (has_type $F32X4 (fsub x y)))\n      (x64_subps x y))\n(rule (lower (has_type $F64X2 (fsub x y)))\n      (x64_subpd x y))\n\n;; Rules for `fmul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fmul x y)))\n      (x64_mulss x y))\n(rule (lower (has_type $F64 (fmul x y)))\n      (x64_mulsd x y))\n(rule (lower (has_type $F32X4 (fmul x y)))\n      (x64_mulps x y))\n(rule (lower (has_type $F64X2 (fmul x y)))\n      (x64_mulpd x y))\n\n;; The above rules automatically sink loads for rhs operands, so additionally\n;; add rules for sinking loads with lhs operands.\n(rule 1 (lower (has_type $F32 (fmul (sinkable_load x) y)))\n      (x64_mulss y x))\n(rule 1 (lower (has_type $F64 (fmul (sinkable_load x) y)))\n      (x64_mulsd y x))\n(rule 1 (lower (has_type $F32X4 (fmul (sinkable_load x) y)))\n      (x64_mulps y x))\n(rule 1 (lower (has_type $F64X2 (fmul (sinkable_load x) y)))\n      (x64_mulpd y x))\n\n;; Rules for `fdiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fdiv x y)))\n      (x64_divss x y))\n(rule (lower (has_type $F64 (fdiv x y)))\n      (x64_divsd x y))\n(rule (lower (has_type $F32X4 (fdiv x y)))\n      (x64_divps x y))\n(rule (lower (has_type $F64X2 (fdiv x y)))\n      (x64_divpd x y))\n\n;; Rules for `sqrt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F32 (sqrt x)))\n      (x64_sqrtss x))\n(rule (lower (has_type $F64 (sqrt x)))\n      (x64_sqrtsd x))\n(rule (lower (has_type $F32X4 (sqrt x)))\n      (x64_sqrtps x))\n(rule (lower (has_type $F64X2 (sqrt x)))\n      (x64_sqrtpd x))\n\n;; Rules for `fpromote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F64 (fpromote x)))\n      (x64_cvtss2sd x))\n\n;; Rules for `fvpromote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F64X2 (fvpromote_low x)))\n      (x64_cvtps2pd (put_in_xmm x)))\n\n;; Rules for `fdemote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F32 (fdemote x)))\n      (x64_cvtsd2ss x))\n\n;; Rules for `fvdemote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F32X4 (fvdemote x)))\n      (x64_cvtpd2ps x))\n\n;; Rules for `fmin` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fmin x y)))\n      (xmm_min_max_seq $F32 $true x y))\n(rule (lower (has_type $F64 (fmin x y)))\n      (xmm_min_max_seq $F64 $true x y))\n\n;; Vector-typed version. We don't use single pseudoinstructions as\n;; above, because we don't need to generate a mini-CFG. Instead, we\n;; perform a branchless series of operations.\n;;\n;; We cannot simply use native min instructions (minps, minpd) because\n;; NaN handling is different per CLIF semantics than on\n;; x86. Specifically, if an argument is NaN, or the arguments are both\n;; zero but of opposite signs, then the x86 instruction always\n;; produces the second argument. However, per CLIF semantics, we\n;; require that fmin(NaN, _) = fmin(_, NaN) = NaN, and fmin(+0, -0) =\n;; fmin(-0, +0) = -0.\n\n(rule (lower (has_type $F32X4 (fmin x y)))\n      ;; Compute min(x, y) and min(y, x) with native\n      ;; instructions. These will differ in one of the edge cases\n      ;; above that we have to handle properly. (Conversely, if they\n      ;; don't differ, then the native instruction's answer is the\n      ;; right one per CLIF semantics.)\n      (let ((min1 Xmm (x64_minps x y))\n            (min2 Xmm (x64_minps y x))\n            ;; Compute the OR of the two. Note that NaNs have an\n            ;; exponent field of all-ones (0xFF for F32), so if either\n            ;; result is a NaN, this OR will be. And if either is a\n            ;; zero (which has an exponent of 0 and mantissa of 0),\n            ;; this captures a sign-bit of 1 (negative) if either\n            ;; input is negative.\n            ;;\n            ;; In the case where we don't have a +/-0 mismatch or\n            ;; NaNs, then `min1` and `min2` are equal and `min_or` is\n            ;; the correct minimum.\n            (min_or Xmm (x64_orps min1 min2))\n            ;; \"compare unordered\" produces a true mask (all ones) in\n            ;; a given lane if the min is a NaN. We use this to\n            ;; generate a mask to ensure quiet NaNs.\n            (is_nan_mask Xmm (x64_cmpps min_or min2 (FcmpImm.Unordered)))\n            ;; OR in the NaN mask.\n            (min_or_2 Xmm (x64_orps min_or is_nan_mask))\n            ;; Shift the NaN mask down so that it covers just the\n            ;; fraction below the NaN signalling bit; we'll use this\n            ;; to mask off non-canonical NaN payloads.\n            ;;\n            ;; All-ones for NaN, shifted down to leave 10 top bits (1\n            ;; sign, 8 exponent, 1 QNaN bit that must remain set)\n            ;; cleared.\n            (nan_fraction_mask Xmm (x64_psrld is_nan_mask (xmi_imm 10)))\n            ;; Do a NAND, so that we retain every bit not set in\n            ;; `nan_fraction_mask`. This mask will be all zeroes (so\n            ;; we retain every bit) in non-NaN cases, and will have\n            ;; ones (so we clear those bits) in NaN-payload bits\n            ;; otherwise.\n            (final Xmm (x64_andnps nan_fraction_mask min_or_2)))\n        final))\n\n;; Likewise for F64 lanes, except that the right-shift is by 13 bits\n;; (1 sign, 11 exponent, 1 QNaN bit).\n(rule (lower (has_type $F64X2 (fmin x y)))\n      (let ((min1 Xmm (x64_minpd x y))\n            (min2 Xmm (x64_minpd y x))\n            (min_or Xmm (x64_orpd min1 min2))\n            (is_nan_mask Xmm (x64_cmppd min1 min2 (FcmpImm.Unordered)))\n            (min_or_2 Xmm (x64_orpd min_or is_nan_mask))\n            (nan_fraction_mask Xmm (x64_psrlq is_nan_mask (xmi_imm 13)))\n            (final Xmm (x64_andnpd nan_fraction_mask min_or_2)))\n        final))\n\n;; Rules for `fmax` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fmax x y)))\n      (xmm_min_max_seq $F32 $false x y))\n(rule (lower (has_type $F64 (fmax x y)))\n      (xmm_min_max_seq $F64 $false x y))\n\n;; The vector version of fmax here is a dual to the fmin sequence\n;; above, almost, with a few differences.\n\n(rule (lower (has_type $F32X4 (fmax x y)))\n      ;; Compute max(x, y) and max(y, x) with native\n      ;; instructions. These will differ in one of the edge cases\n      ;; above that we have to handle properly. (Conversely, if they\n      ;; don't differ, then the native instruction's answer is the\n      ;; right one per CLIF semantics.)\n      (let ((max1 Xmm (x64_maxps x y))\n            (max2 Xmm (x64_maxps y x))\n            ;; Compute the XOR of the two maxima. In the case\n            ;; where we don't have a +/-0 mismatch or NaNs, then\n            ;; `min1` and `min2` are equal and this XOR is zero.\n            (max_xor Xmm (x64_xorps max1 max2))\n            ;; OR the XOR into one of the original maxima. If they are\n            ;; equal, this does nothing. If max2 was NaN, its exponent\n            ;; bits were all-ones, so the xor's exponent bits were the\n            ;; complement of max1, and the OR of max1 and max_xor has\n            ;; an all-ones exponent (is a NaN). If max1 was NaN, then\n            ;; its exponent bits were already all-ones, so the OR will\n            ;; be a NaN as well.\n            (max_blended_nan Xmm (x64_orps max1 max_xor))\n            ;; Subtract the XOR. This ensures that if we had +0 and\n            ;; -0, we end up with +0.\n            (max_blended_nan_positive Xmm (x64_subps max_blended_nan max_xor))\n            ;; \"compare unordered\" produces a true mask (all ones) in\n            ;; a given lane if the min is a NaN. We use this to\n            ;; generate a mask to ensure quiet NaNs.\n            (is_nan_mask Xmm (x64_cmpps max_blended_nan max_blended_nan (FcmpImm.Unordered)))\n            ;; Shift the NaN mask down so that it covers just the\n            ;; fraction below the NaN signalling bit; we'll use this\n            ;; to mask off non-canonical NaN payloads.\n            ;;\n            ;; All-ones for NaN, shifted down to leave 10 top bits (1\n            ;; sign, 8 exponent, 1 QNaN bit that must remain set)\n            ;; cleared.\n            (nan_fraction_mask Xmm (x64_psrld is_nan_mask (xmi_imm 10)))\n            ;; Do a NAND, so that we retain every bit not set in\n            ;; `nan_fraction_mask`. This mask will be all zeroes (so\n            ;; we retain every bit) in non-NaN cases, and will have\n            ;; ones (so we clear those bits) in NaN-payload bits\n            ;; otherwise.\n            (final Xmm (x64_andnps nan_fraction_mask max_blended_nan_positive)))\n        final))\n\n(rule (lower (has_type $F64X2 (fmax x y)))\n      ;; Compute max(x, y) and max(y, x) with native\n      ;; instructions. These will differ in one of the edge cases\n      ;; above that we have to handle properly. (Conversely, if they\n      ;; don't differ, then the native instruction's answer is the\n      ;; right one per CLIF semantics.)\n      (let ((max1 Xmm (x64_maxpd x y))\n            (max2 Xmm (x64_maxpd y x))\n            ;; Compute the XOR of the two maxima. In the case\n            ;; where we don't have a +/-0 mismatch or NaNs, then\n            ;; `min1` and `min2` are equal and this XOR is zero.\n            (max_xor Xmm (x64_xorpd max1 max2))\n            ;; OR the XOR into one of the original maxima. If they are\n            ;; equal, this does nothing. If max2 was NaN, its exponent\n            ;; bits were all-ones, so the xor's exponent bits were the\n            ;; complement of max1, and the OR of max1 and max_xor has\n            ;; an all-ones exponent (is a NaN). If max1 was NaN, then\n            ;; its exponent bits were already all-ones, so the OR will\n            ;; be a NaN as well.\n            (max_blended_nan Xmm (x64_orpd max1 max_xor))\n            ;; Subtract the XOR. This ensures that if we had +0 and\n            ;; -0, we end up with +0.\n            (max_blended_nan_positive Xmm (x64_subpd max_blended_nan max_xor))\n            ;; `cmpps` with predicate index `3` is `cmpunordps`, or\n            ;; \"compare unordered\": it produces a true mask (all ones)\n            ;; in a given lane if the min is a NaN. We use this to\n            ;; generate a mask to ensure quiet NaNs.\n            (is_nan_mask Xmm (x64_cmppd max_blended_nan max_blended_nan (FcmpImm.Unordered)))\n            ;; Shift the NaN mask down so that it covers just the\n            ;; fraction below the NaN signalling bit; we'll use this\n            ;; to mask off non-canonical NaN payloads.\n            ;;\n            ;; All-ones for NaN, shifted down to leave 13 top bits (1\n            ;; sign, 11 exponent, 1 QNaN bit that must remain set)\n            ;; cleared.\n            (nan_fraction_mask Xmm (x64_psrlq is_nan_mask (xmi_imm 13)))\n            ;; Do a NAND, so that we retain every bit not set in\n            ;; `nan_fraction_mask`. This mask will be all zeroes (so\n            ;; we retain every bit) in non-NaN cases, and will have\n            ;; ones (so we clear those bits) in NaN-payload bits\n            ;; otherwise.\n            (final Xmm (x64_andnpd nan_fraction_mask max_blended_nan_positive)))\n        final))\n\n;; Rules for `fma` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Base case for fma is to call out to one of two libcalls. For vectors they\n;; need to be decomposed, handle each element individually, and then recomposed.\n\n(rule (lower (has_type $F32 (fma x y z)))\n      (libcall_3 (LibCall.FmaF32) x y z))\n(rule (lower (has_type $F64 (fma x y z)))\n      (libcall_3 (LibCall.FmaF64) x y z))\n\n(rule (lower (has_type $F32X4 (fma x y z)))\n      (let (\n          (x Xmm (put_in_xmm x))\n          (y Xmm (put_in_xmm y))\n          (z Xmm (put_in_xmm z))\n          (x0 Xmm (libcall_3 (LibCall.FmaF32) x y z))\n          (x1 Xmm (libcall_3 (LibCall.FmaF32)\n            (x64_pshufd x 1)\n            (x64_pshufd y 1)\n            (x64_pshufd z 1)))\n          (x2 Xmm (libcall_3 (LibCall.FmaF32)\n            (x64_pshufd x 2)\n            (x64_pshufd y 2)\n            (x64_pshufd z 2)))\n          (x3 Xmm (libcall_3 (LibCall.FmaF32)\n            (x64_pshufd x 3)\n            (x64_pshufd y 3)\n            (x64_pshufd z 3)))\n\n          (tmp Xmm (vec_insert_lane $F32X4 x0 x1 1))\n          (tmp Xmm (vec_insert_lane $F32X4 tmp x2 2))\n          (tmp Xmm (vec_insert_lane $F32X4 tmp x3 3))\n        )\n        tmp))\n(rule (lower (has_type $F64X2 (fma x y z)))\n      (let (\n          (x Xmm (put_in_xmm x))\n          (y Xmm (put_in_xmm y))\n          (z Xmm (put_in_xmm z))\n          (x0 Xmm (libcall_3 (LibCall.FmaF64) x y z))\n          (x1 Xmm (libcall_3 (LibCall.FmaF64)\n            (x64_pshufd x 0xee)\n            (x64_pshufd y 0xee)\n            (x64_pshufd z 0xee)))\n        )\n        (vec_insert_lane $F64X2 x0 x1 1)))\n\n\n;; Special case for when the `fma` feature is active and a native instruction\n;; can be used.\n(rule 1 (lower (has_type ty (fma x y z)))\n      (if-let $true (use_fma))\n      (fmadd ty x y z))\n\n(decl fmadd (Type Value Value Value) Xmm)\n(decl fnmadd (Type Value Value Value) Xmm)\n\n;; Base case. Note that this will automatically sink a load with `z`, the value\n;; to add.\n(rule (fmadd ty x y z) (x64_vfmadd213 ty x y z))\n\n;; Allow sinking loads with one of the two values being multiplied in addition\n;; to the value being added. Note that both x and y can be sunk here due to\n;; multiplication being commutative.\n(rule 1 (fmadd ty (sinkable_load x) y z) (x64_vfmadd132 ty y z x))\n(rule 2 (fmadd ty x (sinkable_load y) z) (x64_vfmadd132 ty x z y))\n\n;; If one of the values being multiplied is negated then use a `vfnmadd*`\n;; instruction instead\n(rule 3 (fmadd ty (fneg x) y z) (fnmadd ty x y z))\n(rule 4 (fmadd ty x (fneg y) z) (fnmadd ty x y z))\n\n(rule (fnmadd ty x y z) (x64_vfnmadd213 ty x y z))\n(rule 1 (fnmadd ty (sinkable_load x) y z) (x64_vfnmadd132 ty y z x))\n(rule 2 (fnmadd ty x (sinkable_load y) z) (x64_vfnmadd132 ty x z y))\n\n;; Like `fmadd` if one argument is negated switch which one is being codegen'd\n(rule 3 (fnmadd ty (fneg x) y z) (fmadd ty x y z))\n(rule 4 (fnmadd ty x (fneg y) z) (fmadd ty x y z))\n\n;; Rules for `load*` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; In order to load a value from memory to a GPR register, we may need to extend\n;; the loaded value from 8-, 16-, or 32-bits to this backend's expected GPR\n;; width: 64 bits. Note that `ext_mode` will load 1-bit types (booleans) as\n;; 8-bit loads.\n;;\n;; By default, we zero-extend all sub-64-bit loads to a GPR.\n(rule -4 (lower (has_type (and (fits_in_32 ty) (is_gpr_type _)) (load flags address offset)))\n      (x64_movzx (ext_mode (ty_bits_u16 ty) 64) (to_amode flags address offset)))\n;; But if we know that both the `from` and `to` are 64 bits, we simply load with\n;; no extension.\n(rule -1 (lower (has_type (ty_int_ref_64 ty) (load flags address offset)))\n      (x64_mov (to_amode flags address offset)))\n;; Also, certain scalar loads have a specific `from` width and extension kind\n;; (signed -> `sx`, zeroed -> `zx`). We overwrite the high bits of the 64-bit\n;; GPR even if the `to` type is smaller (e.g., 16-bits).\n(rule (lower (has_type (is_gpr_type ty) (uload8 flags address offset)))\n      (x64_movzx (ExtMode.BQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (sload8 flags address offset)))\n      (x64_movsx (ExtMode.BQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (uload16 flags address offset)))\n      (x64_movzx (ExtMode.WQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (sload16 flags address offset)))\n      (x64_movsx (ExtMode.WQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (uload32 flags address offset)))\n      (x64_movzx (ExtMode.LQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (sload32 flags address offset)))\n      (x64_movsx (ExtMode.LQ) (to_amode flags address offset)))\n\n;; To load to XMM registers, we use the x64-specific instructions for each type.\n;; For `$F32` and `$F64` this is important--we only want to load 32 or 64 bits.\n;; But for the 128-bit types, this is not strictly necessary for performance but\n;; might help with clarity during disassembly.\n(rule (lower (has_type $F32 (load flags address offset)))\n      (x64_movss_load (to_amode flags address offset)))\n(rule (lower (has_type $F64 (load flags address offset)))\n      (x64_movsd_load (to_amode flags address offset)))\n(rule (lower (has_type $F32X4 (load flags address offset)))\n      (x64_movups_load (to_amode flags address offset)))\n(rule (lower (has_type $F64X2 (load flags address offset)))\n      (x64_movupd_load (to_amode flags address offset)))\n(rule -2 (lower (has_type (ty_vec128 ty) (load flags address offset)))\n      (x64_movdqu_load (to_amode flags address offset)))\n\n;; We can load an I128 by doing two 64-bit loads.\n(rule -3 (lower (has_type $I128\n                       (load flags address offset)))\n      (let ((addr_lo Amode (to_amode flags address offset))\n            (addr_hi Amode (amode_offset addr_lo 8))\n            (value_lo Reg (x64_mov addr_lo))\n            (value_hi Reg (x64_mov addr_hi)))\n        (value_regs value_lo value_hi)))\n\n;; We also include widening vector loads; these sign- or zero-extend each lane\n;; to the next wider width (e.g., 16x4 -> 32x4).\n(rule 1 (lower (has_type $I16X8 (sload8x8 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovsxbw (to_amode flags address offset)))\n(rule 1 (lower (has_type $I16X8 (uload8x8 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovzxbw (to_amode flags address offset)))\n(rule 1 (lower (has_type $I32X4 (sload16x4 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovsxwd (to_amode flags address offset)))\n(rule 1 (lower (has_type $I32X4 (uload16x4 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovzxwd (to_amode flags address offset)))\n(rule 1 (lower (has_type $I64X2 (sload32x2 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovsxdq (to_amode flags address offset)))\n(rule 1 (lower (has_type $I64X2 (uload32x2 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovzxdq (to_amode flags address offset)))\n\n(rule (lower (has_type $I16X8 (sload8x8 flags address offset)))\n      (lower_swiden_low $I16X8 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I16X8 (uload8x8 flags address offset)))\n      (lower_uwiden_low $I16X8 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I32X4 (sload16x4 flags address offset)))\n      (lower_swiden_low $I32X4 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I32X4 (uload16x4 flags address offset)))\n      (lower_uwiden_low $I32X4 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I64X2 (sload32x2 flags address offset)))\n      (lower_swiden_low $I64X2 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I64X2 (uload32x2 flags address offset)))\n      (lower_uwiden_low $I64X2 (x64_movq_to_xmm (to_amode flags address offset))))\n\n;; Rules for `store*` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; 8-, 16-, 32- and 64-bit GPR stores.\n(rule -2 (lower (store flags\n                    value @ (value_type (is_gpr_type ty))\n                    address\n                    offset))\n      (side_effect\n       (x64_movrm ty (to_amode flags address offset) value)))\n\n;; Explicit 8/16/32-bit opcodes.\n(rule (lower (istore8 flags value address offset))\n      (side_effect\n       (x64_movrm $I8 (to_amode flags address offset) value)))\n(rule (lower (istore16 flags value address offset))\n      (side_effect\n       (x64_movrm $I16 (to_amode flags address offset) value)))\n(rule (lower (istore32 flags value address offset))\n      (side_effect\n       (x64_movrm $I32 (to_amode flags address offset) value)))\n\n;; IMM stores\n(rule 2 (lower (store flags (has_type (fits_in_64 ty) (iconst (simm32 value))) address offset))\n      (side_effect\n       (x64_movimm_m ty (to_amode flags address offset) value)))\n\n;; F32 stores of values in XMM registers.\n(rule 1 (lower (store flags\n                    value @ (value_type $F32)\n                    address\n                    offset))\n      (side_effect\n       (x64_movss_store (to_amode flags address offset) value)))\n\n;; F64 stores of values in XMM registers.\n(rule 1 (lower (store flags\n                    value @ (value_type $F64)\n                    address\n                    offset))\n      (side_effect\n       (x64_movsd_store (to_amode flags address offset) value)))\n\n;; Stores of F32X4 vectors.\n(rule 1 (lower (store flags\n                    value @ (value_type $F32X4)\n                    address\n                    offset))\n      (side_effect\n       (x64_movups_store (to_amode flags address offset) value)))\n\n;; Stores of F64X2 vectors.\n(rule 1 (lower (store flags\n                    value @ (value_type $F64X2)\n                    address\n                    offset))\n      (side_effect\n       (x64_movupd_store (to_amode flags address offset) value)))\n\n;; Stores of all other 128-bit vector types with integer lanes.\n(rule -1 (lower (store flags\n                    value @ (value_type (ty_vec128_int _))\n                    address\n                    offset))\n      (side_effect\n       (x64_movdqu_store (to_amode flags address offset) value)))\n\n;; Stores of I128 values: store the two 64-bit halves separately.\n(rule 0 (lower (store flags\n                    value @ (value_type $I128)\n                    address\n                    offset))\n      (let ((value_reg ValueRegs value)\n            (value_lo Gpr (value_regs_get_gpr value_reg 0))\n            (value_hi Gpr (value_regs_get_gpr value_reg 1))\n            (addr_lo Amode (to_amode flags address offset))\n            (addr_hi Amode (amode_offset addr_lo 8)))\n      (side_effect\n       (side_effect_concat\n        (x64_movrm $I64 addr_lo value_lo)\n        (x64_movrm $I64 addr_hi value_hi)))))\n\n;; Slightly optimize the extraction of the first lane from a vector which is\n;; stored in memory. In the case the first lane specifically is selected the\n;; standard `movss` and `movsd` instructions can be used as-if we're storing a\n;; f32 or f64 despite the source perhaps being an integer vector since the\n;; result of the instruction is the same.\n(rule 2 (lower (store flags\n                    (has_type $F32 (extractlane value (u8_from_uimm8 0)))\n                    address\n                    offset))\n      (side_effect\n       (x64_movss_store (to_amode flags address offset) value)))\n(rule 2 (lower (store flags\n                    (has_type $F64 (extractlane value (u8_from_uimm8 0)))\n                    address\n                    offset))\n      (side_effect\n       (x64_movsd_store (to_amode flags address offset) value)))\n(rule 2 (lower (store flags\n                    (has_type $I8 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrb_store (to_amode flags address offset) value n)))\n(rule 2 (lower (store flags\n                    (has_type $I16 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrw_store (to_amode flags address offset) value n)))\n(rule 2 (lower (store flags\n                    (has_type $I32 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrd_store (to_amode flags address offset) value n)))\n(rule 2 (lower (store flags\n                    (has_type $I64 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrq_store (to_amode flags address offset) value n)))\n\n;; Rules for `load*` + ALU op + `store*` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Add mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (iadd (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_add_mem ty (to_amode flags addr offset) src2))))\n\n;; Add mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (iadd src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_add_mem ty (to_amode flags addr offset) src2))))\n\n;; Sub mem, reg\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (isub (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_sub_mem ty (to_amode flags addr offset) src2))))\n\n;; And mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (band (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_and_mem ty (to_amode flags addr offset) src2))))\n\n;; And mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (band src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_and_mem ty (to_amode flags addr offset) src2))))\n\n;; Or mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bor (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_or_mem ty (to_amode flags addr offset) src2))))\n\n;; Or mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bor src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_or_mem ty (to_amode flags addr offset) src2))))\n\n;; Xor mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bxor (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_xor_mem ty (to_amode flags addr offset) src2))))\n\n;; Xor mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bxor src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_xor_mem ty (to_amode flags addr offset) src2))))\n\n;; Rules for `fence` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (fence))\n      (side_effect (x64_mfence)))\n\n;; Rules for `func_addr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (func_addr (func_ref_data _ extname dist)))\n      (load_ext_name extname 0 dist))\n\n;; Rules for `symbol_value` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (symbol_value (symbol_value_data extname dist offset)))\n      (load_ext_name extname offset dist))\n\n;; Rules for `atomic_load` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; This is a normal load. The x86-TSO memory model provides sufficient\n;; sequencing to satisfy the CLIF synchronisation requirements for `AtomicLoad`\n;; without the need for any fence instructions.\n;;\n;; As described in the `atomic_load` documentation, this lowering is only valid\n;; for I8, I16, I32, and I64. The sub-64-bit types are zero extended, as with a\n;; normal load.\n(rule 1 (lower (has_type $I64 (atomic_load flags address)))\n      (x64_mov (to_amode flags address (zero_offset))))\n(rule (lower (has_type (and (fits_in_32 ty) (ty_int _)) (atomic_load flags address)))\n      (x64_movzx (ext_mode (ty_bits_u16 ty) 64) (to_amode flags address (zero_offset))))\n\n;; Rules for `atomic_store` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; This is a normal store followed by an `mfence` instruction. As described in\n;; the `atomic_load` documentation, this lowering is only valid for I8, I16,\n;; I32, and I64.\n(rule (lower (atomic_store flags\n                           value @ (value_type (and (fits_in_64 ty) (ty_int _)))\n                           address))\n      (side_effect (side_effect_concat\n       (x64_movrm ty (to_amode flags address (zero_offset)) value)\n       (x64_mfence))))\n\n;; Rules for `atomic_cas` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (and (fits_in_64 ty) (ty_int _))\n                  (atomic_cas flags address expected replacement)))\n      (x64_cmpxchg ty expected replacement (to_amode flags address (zero_offset))))\n\n;; Rules for `atomic_rmw` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; This is a simple, general-case atomic update, based on a loop involving\n;; `cmpxchg`.  Note that we could do much better than this in the case where the\n;; old value at the location (that is to say, the SSA `Value` computed by this\n;; CLIF instruction) is not required.  In that case, we could instead implement\n;; this using a single `lock`-prefixed x64 read-modify-write instruction.  Also,\n;; even in the case where the old value is required, for the `add` and `sub`\n;; cases, we can use the single instruction `lock xadd`.  However, those\n;; improvements have been left for another day. TODO: filed as\n;; https://github.com/bytecodealliance/wasmtime/issues/2153.\n\n(rule (lower (has_type (and (fits_in_64 ty) (ty_int _))\n                  (atomic_rmw flags op address input)))\n      (x64_atomic_rmw_seq ty op (to_amode flags address (zero_offset)) input))\n\n;; Rules for `call` and `call_indirect` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (call (func_ref_data sig_ref extname dist) inputs))\n      (gen_call sig_ref extname dist inputs))\n\n(rule (lower (call_indirect sig_ref val inputs))\n      (gen_call_indirect sig_ref val inputs))\n\n;;;; Rules for `return_call` and `return_call_indirect` ;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (return_call (func_ref_data sig_ref extname dist) args))\n      (gen_return_call sig_ref extname dist args))\n\n(rule (lower (return_call_indirect sig_ref callee args))\n      (gen_return_call_indirect sig_ref callee args))\n\n;;;; Rules for `get_{frame,stack}_pointer` and `get_return_address` ;;;;;;;;;;;;\n\n(rule (lower (get_frame_pointer))\n      (x64_rbp))\n\n(rule (lower (get_stack_pointer))\n      (x64_rsp))\n\n(rule (lower (get_return_address))\n      (x64_load $I64\n                (Amode.ImmReg 8 (x64_rbp) (mem_flags_trusted))\n                (ExtKind.None)))\n\n;; Rules for `jump` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower_branch (jump _) (single_target target))\n      (emit_side_effect (jmp_known target)))\n\n;; Rules for `brif` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower_branch (brif (maybe_uextend (icmp cc a b)) _ _) (two_targets then else))\n        (emit_side_effect (jmp_cond_icmp (emit_cmp cc a b) then else)))\n\n(rule 2 (lower_branch (brif (maybe_uextend (fcmp cc a b)) _ _) (two_targets then else))\n        (emit_side_effect (jmp_cond_fcmp (emit_fcmp cc a b) then else)))\n\n(rule 1 (lower_branch (brif val @ (value_type $I128) _ _)\n                      (two_targets then else))\n      (emit_side_effect (jmp_cond_icmp (cmp_zero_i128 (CC.Z) val) then else)))\n\n(rule (lower_branch (brif val @ (value_type (ty_int_bool_or_ref)) _ _)\n                    (two_targets then else))\n      (emit_side_effect (with_flags_side_effect\n                          (cmp_zero_int_bool_ref val)\n                          (jmp_cond (CC.NZ) then else))))\n\n\n;; Compare an I128 value to zero, returning a flags result suitable for making a\n;; jump decision. The comparison is implemented as `(hi == 0) && (low == 0)`,\n;; and the result can be interpreted as follows\n;; * CC.Z indicates that the value was non-zero, as one or both of the halves of\n;;   the value were non-zero\n;; * CC.NZ indicates that both halves of the value were 0\n(decl cmp_zero_i128 (CC ValueRegs) IcmpCondResult)\n(rule (cmp_zero_i128 (cc_nz_or_z cc) val)\n      (let ((lo Gpr (value_regs_get_gpr val 0))\n            (hi Gpr (value_regs_get_gpr val 1))\n            (lo_z Gpr (with_flags_reg (x64_cmp (OperandSize.Size64) (RegMemImm.Imm 0) lo)\n                                      (x64_setcc (CC.Z))))\n            (hi_z Gpr (with_flags_reg (x64_cmp (OperandSize.Size64) (RegMemImm.Imm 0) hi)\n                                      (x64_setcc (CC.Z)))))\n          (icmp_cond_result (x64_test (OperandSize.Size8) lo_z hi_z) cc)))\n\n\n(decl cmp_zero_int_bool_ref (Value) ProducesFlags)\n(rule (cmp_zero_int_bool_ref val @ (value_type ty))\n      (let ((size OperandSize (raw_operand_size_of_type ty))\n            (src Gpr val))\n        (x64_test size src src)))\n\n;; Rules for `br_table` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower_branch (br_table idx @ (value_type ty) _) (jump_table_targets default_target jt_targets))\n      (let ((size OperandSize (raw_operand_size_of_type ty))\n            (jt_size u32 (jump_table_size jt_targets))\n            (size_reg Reg (imm ty (u32_as_u64 jt_size)))\n            (idx_reg Gpr (extend_to_gpr idx $I64 (ExtendKind.Zero)))\n            (clamped_idx Reg (with_flags_reg\n              (x64_cmp size size_reg idx_reg)\n              (cmove ty (CC.B) idx_reg size_reg))))\n      (emit_side_effect (jmp_table_seq ty clamped_idx default_target jt_targets))))\n\n;; Rules for `select_spectre_guard` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (select_spectre_guard (icmp cc a b) x y))\n      (select_icmp (emit_cmp cc a b) x y))\n\n(rule -1 (lower (has_type ty (select_spectre_guard c @ (value_type (fits_in_64 a_ty)) x y)))\n      (let ((size OperandSize (raw_operand_size_of_type a_ty))\n            (gpr_c Gpr (put_in_gpr c)))\n        (with_flags (x64_test size gpr_c gpr_c) (cmove_from_values ty (CC.NZ) x y))))\n\n(rule -2 (lower (has_type ty (select_spectre_guard c @ (value_type $I128) x y)))\n      (let ((cond_result IcmpCondResult (cmp_zero_i128 (CC.Z) c)))\n        (select_icmp cond_result x y)))\n\n;; Rules for `fcvt_from_sint` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (has_type $F32 (fcvt_from_sint a @ (value_type $I8))))\n      (x64_cvtsi2ss $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 2 (lower (has_type $F32 (fcvt_from_sint a @ (value_type $I16))))\n      (x64_cvtsi2ss $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 1 (lower (has_type $F32 (fcvt_from_sint a @ (value_type (ty_int (fits_in_64 ty))))))\n      (x64_cvtsi2ss ty a))\n\n(rule 2 (lower (has_type $F64 (fcvt_from_sint a @ (value_type $I8))))\n      (x64_cvtsi2sd $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 2 (lower (has_type $F64 (fcvt_from_sint a @ (value_type $I16))))\n      (x64_cvtsi2sd $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 1 (lower (has_type $F64 (fcvt_from_sint a @ (value_type (ty_int (fits_in_64 ty))))))\n      (x64_cvtsi2sd ty a))\n\n(rule 0 (lower (fcvt_from_sint a @ (value_type $I32X4)))\n      (x64_cvtdq2ps a))\n\n(rule 1 (lower (has_type $F64X2 (fcvt_from_sint (swiden_low a @ (value_type $I32X4)))))\n      (x64_cvtdq2pd a))\n\n;; Rules for `fcvt_from_uint` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (has_type $F32 (fcvt_from_uint val @ (value_type (fits_in_32 (ty_int ty))))))\n      (x64_cvtsi2ss $I64 (extend_to_gpr val $I64 (ExtendKind.Zero))))\n\n(rule 1 (lower (has_type $F64 (fcvt_from_uint val @ (value_type (fits_in_32 (ty_int ty))))))\n      (x64_cvtsi2sd $I64 (extend_to_gpr val $I64 (ExtendKind.Zero))))\n\n(rule (lower (has_type ty (fcvt_from_uint val @ (value_type $I64))))\n      (cvt_u64_to_float_seq ty val))\n\n;; Algorithm uses unpcklps to help create a float that is equivalent\n;; 0x1.0p52 + double(src). 0x1.0p52 is unique because at this exponent\n;; every value of the mantissa represents a corresponding uint32 number.\n;; When we subtract 0x1.0p52 we are left with double(src).\n(rule 1 (lower (has_type $F64X2 (fcvt_from_uint (uwiden_low val @ (value_type $I32X4)))))\n      (let ((uint_mask XmmMem (emit_u128_le_const 0x43300000_43300000))\n            (res Xmm (x64_unpcklps val uint_mask))\n            (uint_mask_high XmmMem (emit_u128_le_const 0x4330000000000000_4330000000000000)))\n        (x64_subpd res uint_mask_high)))\n\n;; When AVX512VL and AVX512F are available,\n;; `fcvt_from_uint` can be lowered to a single instruction.\n(rule 2 (lower (has_type $F32X4 (fcvt_from_uint src)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512f))\n      (x64_vcvtudq2ps src))\n\n;; Converting packed unsigned integers to packed floats\n;; requires a few steps. There is no single instruction\n;; lowering for converting unsigned floats but there is for\n;; converting packed signed integers to float (cvtdq2ps). In\n;; the steps below we isolate the upper half (16 bits) and\n;; lower half (16 bits) of each lane and then we convert\n;; each half separately using cvtdq2ps meant for signed\n;; integers. In order for this to work for the upper half\n;; bits we must shift right by 1 (divide by 2) these bits in\n;; order to ensure the most significant bit is 0 not signed,\n;; and then after the conversion we double the value.\n;; Finally we add the converted values where addition will\n;; correctly round.\n;;\n;; Sequence:\n;; -> A = 0xffffffff\n;; -> Ah = 0xffff0000\n;; -> Al = 0x0000ffff\n;; -> Convert(Al) // Convert int to float\n;; -> Ah = Ah >> 1 // Shift right 1 to assure Ah conversion isn't treated as signed\n;; -> Convert(Ah) // Convert .. with no loss of significant digits from previous shift\n;; -> Ah = Ah + Ah // Double Ah to account for shift right before the conversion.\n;; -> dst = Ah + Al // Add the two floats together\n(rule 1 (lower (has_type $F32X4 (fcvt_from_uint val)))\n      (let ((a Xmm val)\n\n            ;;  get the low 16 bits\n            (a_lo Xmm (x64_pslld a (xmi_imm 16)))\n            (a_lo Xmm (x64_psrld a_lo (xmi_imm 16)))\n\n            ;; get the high 16 bits\n            (a_hi Xmm (x64_psubd a a_lo))\n\n            ;; convert the low 16 bits\n            (a_lo Xmm (x64_cvtdq2ps a_lo))\n\n            ;; shift the high bits by 1, convert, and double to get the correct\n            ;; value\n            (a_hi Xmm (x64_psrld a_hi (xmi_imm 1)))\n            (a_hi Xmm (x64_cvtdq2ps a_hi))\n            (a_hi Xmm (x64_addps a_hi a_hi)))\n\n        ;; add together the two converted values\n        (x64_addps a_hi a_lo)))\n\n;; Rules for `fcvt_to_uint` and `fcvt_to_sint` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type out_ty (fcvt_to_uint val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_uint_seq out_ty val $false))\n\n(rule (lower (has_type out_ty (fcvt_to_uint_sat val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_uint_seq out_ty val $true))\n\n(rule (lower (has_type out_ty (fcvt_to_sint val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_sint_seq out_ty val $false))\n\n(rule (lower (has_type out_ty (fcvt_to_sint_sat val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_sint_seq out_ty val $true))\n\n;; The x64 backend currently only supports these two type combinations.\n(rule 1 (lower (has_type $I32X4 (fcvt_to_sint_sat val @ (value_type $F32X4))))\n      (let ((src Xmm val)\n\n            ;; Sets tmp to zero if float is NaN\n            (tmp Xmm (x64_cmpps src src (FcmpImm.Equal)))\n            (dst Xmm (x64_andps src tmp))\n\n            ;; Sets top bit of tmp if float is positive\n            ;; Setting up to set top bit on negative float values\n            (tmp Xmm (x64_pxor tmp dst))\n\n            ;; Convert the packed float to packed doubleword.\n            (dst Xmm (x64_cvttps2dq dst))\n\n            ;; Set top bit only if < 0\n            (tmp Xmm (x64_pand dst tmp))\n            (tmp Xmm (x64_psrad tmp (xmi_imm 31))))\n\n        ;; On overflow 0x80000000 is returned to a lane.\n        ;; Below sets positive overflow lanes to 0x7FFFFFFF\n        ;; Keeps negative overflow lanes as is.\n        (x64_pxor tmp dst)))\n\n;; The algorithm for converting floats to unsigned ints is a little tricky. The\n;; complication arises because we are converting from a signed 64-bit int with a positive\n;; integer range from 1..INT_MAX (0x1..0x7FFFFFFF) to an unsigned integer with an extended\n;; range from (INT_MAX+1)..UINT_MAX. It's this range from (INT_MAX+1)..UINT_MAX\n;; (0x80000000..0xFFFFFFFF) that needs to be accounted for as a special case since our\n;; conversion instruction (cvttps2dq) only converts as high as INT_MAX (0x7FFFFFFF), but\n;; which conveniently setting underflows and overflows (smaller than MIN_INT or larger than\n;; MAX_INT) to be INT_MAX+1 (0x80000000). Nothing that the range (INT_MAX+1)..UINT_MAX includes\n;; precisely INT_MAX values we can correctly account for and convert every value in this range\n;; if we simply subtract INT_MAX+1 before doing the cvttps2dq conversion. After the subtraction\n;; every value originally (INT_MAX+1)..UINT_MAX is now the range (0..INT_MAX).\n;; After the conversion we add INT_MAX+1 back to this converted value, noting again that\n;; values we are trying to account for were already set to INT_MAX+1 during the original conversion.\n;; We simply have to create a mask and make sure we are adding together only the lanes that need\n;; to be accounted for. Digesting it all the steps then are:\n;;\n;; Step 1 - Account for NaN and negative floats by setting these src values to zero.\n;; Step 2 - Make a copy (tmp1) of the src value since we need to convert twice for\n;;          reasons described above.\n;; Step 3 - Convert the original src values. This will convert properly all floats up to INT_MAX\n;; Step 4 - Subtract INT_MAX from the copy set (tmp1). Note, all zero and negative values are those\n;;          values that were originally in the range (0..INT_MAX). This will come in handy during\n;;          step 7 when we zero negative lanes.\n;; Step 5 - Create a bit mask for tmp1 that will correspond to all lanes originally less than\n;;          UINT_MAX that are now less than INT_MAX thanks to the subtraction.\n;; Step 6 - Convert the second set of values (tmp1)\n;; Step 7 - Prep the converted second set by zeroing out negative lanes (these have already been\n;;          converted correctly with the first set) and by setting overflow lanes to 0x7FFFFFFF\n;;          as this will allow us to properly saturate overflow lanes when adding to 0x80000000\n;; Step 8 - Add the orginal converted src and the converted tmp1 where float values originally less\n;;          than and equal to INT_MAX will be unchanged, float values originally between INT_MAX+1 and\n;;          UINT_MAX will add together (INT_MAX) + (SRC - INT_MAX), and float values originally\n;;          greater than UINT_MAX will be saturated to UINT_MAX (0xFFFFFFFF) after adding (0x8000000 + 0x7FFFFFFF).\n;;\n;;\n;; The table below illustrates the result after each step where it matters for the converted set.\n;; Note the original value range (original src set) is the final dst in Step 8:\n;;\n;; Original src set:\n;; | Original Value Range |    Step 1    |         Step 3         |          Step 8           |\n;; |  -FLT_MIN..FLT_MAX   | 0.0..FLT_MAX | 0..INT_MAX(w/overflow) | 0..UINT_MAX(w/saturation) |\n;;\n;; Copied src set (tmp1):\n;; |    Step 2    |                  Step 4                  |\n;; | 0.0..FLT_MAX | (0.0-(INT_MAX+1))..(FLT_MAX-(INT_MAX+1)) |\n;;\n;; |                       Step 6                        |                 Step 7                 |\n;; | (0-(INT_MAX+1))..(UINT_MAX-(INT_MAX+1))(w/overflow) | ((INT_MAX+1)-(INT_MAX+1))..(INT_MAX+1) |\n(rule 1 (lower (has_type $I32X4 (fcvt_to_uint_sat val @ (value_type $F32X4))))\n      (let ((src Xmm val)\n\n            ;; Converting to unsigned int so if float src is negative or NaN\n            ;; will first set to zero.\n            (tmp2 Xmm (xmm_zero $F32X4))\n            (dst Xmm (x64_maxps src tmp2))\n\n            ;; Set tmp2 to INT_MAX+1. It is important to note here that after it looks\n            ;; like we are only converting INT_MAX (0x7FFFFFFF) but in fact because\n            ;; single precision IEEE-754 floats can only accurately represent contingous\n            ;; integers up to 2^23 and outside of this range it rounds to the closest\n            ;; integer that it can represent. In the case of INT_MAX, this value gets\n            ;; represented as 0x4f000000 which is the integer value (INT_MAX+1).\n            (tmp2 Xmm (x64_pcmpeqd tmp2 tmp2))\n            (tmp2 Xmm (x64_psrld tmp2 (xmi_imm 1)))\n            (tmp2 Xmm (x64_cvtdq2ps tmp2))\n\n            ;; Make a copy of these lanes and then do the first conversion.\n            ;; Overflow lanes greater than the maximum allowed signed value will\n            ;; set to 0x80000000. Negative and NaN lanes will be 0x0\n            (tmp1 Xmm dst)\n            (dst Xmm (x64_cvttps2dq dst))\n\n            ;; Set lanes to src - max_signed_int\n            (tmp1 Xmm (x64_subps tmp1 tmp2))\n\n            ;; Create mask for all positive lanes to saturate (i.e. greater than\n            ;; or equal to the maxmimum allowable unsigned int).\n            (tmp2 Xmm (x64_cmpps tmp2 tmp1 (FcmpImm.LessThanOrEqual)))\n\n            ;; Convert those set of lanes that have the max_signed_int factored out.\n            (tmp1 Xmm (x64_cvttps2dq tmp1))\n\n            ;; Prepare converted lanes by zeroing negative lanes and prepping lanes\n            ;; that have positive overflow (based on the mask) by setting these lanes\n            ;; to 0x7FFFFFFF\n            (tmp1 Xmm (x64_pxor tmp1 tmp2))\n            (tmp2 Xmm (xmm_zero $I32X4))\n            (tmp1 Xmm (lower_vec_smax $I32X4 tmp1 tmp2)))\n\n        ;; Add this second set of converted lanes to the original to properly handle\n        ;; values greater than max signed int.\n        (x64_paddd tmp1 dst)))\n\n;; Rules for `x86_cvtt2dq` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I32X4 (x86_cvtt2dq val @ (value_type $F32X4))))\n      (x64_cvttps2dq val))\n\n;; Rules for `iadd_pairwise` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16 (iadd_pairwise x y)))\n      (let (\n          ;; Shuffle all the even lanes of `x` and `y` into one register\n          (even_lane_mask Xmm (x64_movdqu_load (emit_u128_le_const 0x00ff_00ff_00ff_00ff_00ff_00ff_00ff_00ff)))\n          (x_evens Xmm (x64_pand x even_lane_mask))\n          (y_evens Xmm (x64_pand y even_lane_mask))\n          (evens Xmm (x64_packuswb x_evens y_evens))\n\n          ;; Shuffle all the odd lanes of `x` and `y` into one register\n          (x_odds Xmm (x64_psrlw x (xmi_imm 8)))\n          (y_odds Xmm (x64_psrlw y (xmi_imm 8)))\n          (odds Xmm (x64_packuswb x_odds y_odds))\n        )\n        (x64_paddb evens odds)))\n\n\n(rule 1 (lower (has_type $I16X8 (iadd_pairwise x y)))\n        (if-let $true (use_ssse3))\n        (x64_phaddw x y))\n\n(rule (lower (has_type $I16X8 (iadd_pairwise x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n\n          ;; Shuffle the even-numbered 16-bit lanes into low four lanes of each\n          ;; vector by shuffling 16-bit lanes then shuffling 32-bit lanes.\n          ;; With these in place generate a new vector from the two low 64-bits\n          ;; of each vector (the low four 16-bit lanes).\n          ;;\n          ;; 0xe8 == 0b11_10_10_00\n          (x_evens Xmm (x64_pshufd (x64_pshufhw (x64_pshuflw x 0xe8) 0xe8) 0xe8))\n          (y_evens Xmm (x64_pshufd (x64_pshufhw (x64_pshuflw y 0xe8) 0xe8) 0xe8))\n          (evens Xmm (x64_punpcklqdq x_evens y_evens))\n\n          ;; Shuffle the odd-numbered 16-bit lanes into the low 8 lanes by\n          ;; performing `sshr` operation on 32-bit lanes, effectively moving the\n          ;; odd lanes into even lanes while leaving their sign bits in the\n          ;; odd lanes. The `packssdw` instruction then conveniently will\n          ;; put everything into one vector for us.\n          (x_shifted Xmm (x64_psrad x (xmi_imm 16)))\n          (y_shifted Xmm (x64_psrad y (xmi_imm 16)))\n          (odds Xmm (x64_packssdw x_shifted y_shifted))\n        )\n      (x64_paddw evens odds)))\n\n(rule 1 (lower (has_type $I32X4 (iadd_pairwise x y)))\n        (if-let $true (use_ssse3))\n        (x64_phaddd x y))\n\n(rule (lower (has_type $I32X4 (iadd_pairwise x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          ;; evens = [ x[0] x[2] y[0] y[2] ]\n          (evens Xmm (x64_shufps x y 0b10_00_10_00))\n          ;; odds  = [ x[1] x[3] y[1] y[3] ]\n          (odds  Xmm (x64_shufps x y 0b11_01_11_01))\n        )\n      (x64_paddd evens odds)))\n\n;; special case for the `i16x8.extadd_pairwise_i8x16_s` wasm instruction\n(rule 2 (lower\n        (has_type $I16X8 (iadd_pairwise\n                           (swiden_low val @ (value_type $I8X16))\n                           (swiden_high val))))\n      (if-let $true (use_ssse3))\n      (let ((mul_const Xmm (x64_xmm_load_const $I8X16\n              (emit_u128_le_const 0x01010101010101010101010101010101))))\n        (x64_pmaddubsw mul_const val)))\n\n;; special case for the `i32x4.extadd_pairwise_i16x8_s` wasm instruction\n(rule 2 (lower\n        (has_type $I32X4 (iadd_pairwise\n                           (swiden_low val @ (value_type $I16X8))\n                           (swiden_high val))))\n      (let ((mul_const XmmMem (emit_u128_le_const 0x0001_0001_0001_0001_0001_0001_0001_0001)))\n        (x64_pmaddwd val mul_const)))\n\n;; special case for the `i16x8.extadd_pairwise_i8x16_u` wasm instruction\n(rule 2 (lower\n        (has_type $I16X8 (iadd_pairwise\n                           (uwiden_low val @ (value_type $I8X16))\n                           (uwiden_high val))))\n      (if-let $true (use_ssse3))\n      (let ((mul_const XmmMem (emit_u128_le_const 0x01010101010101010101010101010101)))\n        (x64_pmaddubsw val mul_const)))\n\n;; special case for the `i32x4.extadd_pairwise_i16x8_u` wasm instruction\n(rule 2 (lower\n        (has_type $I32X4 (iadd_pairwise\n                           (uwiden_low val @ (value_type $I16X8))\n                           (uwiden_high val))))\n      (let ((xor_const XmmMem (emit_u128_le_const 0x8000_8000_8000_8000_8000_8000_8000_8000))\n            (dst Xmm (x64_pxor val xor_const))\n\n            (madd_const XmmMem (emit_u128_le_const 0x0001_0001_0001_0001_0001_0001_0001_0001))\n            (dst Xmm (x64_pmaddwd dst madd_const))\n\n            (addd_const XmmMem (emit_u128_le_const 0x00010000_00010000_00010000_00010000)))\n        (x64_paddd dst addd_const)))\n\n;; special case for the `i32x4.dot_i16x8_s` wasm instruction\n(rule 2 (lower\n        (has_type $I32X4 (iadd_pairwise\n                           (imul (swiden_low x) (swiden_low y))\n                           (imul (swiden_high x) (swiden_high y)))))\n      (x64_pmaddwd x y))\n\n;; Rules for `swiden_low` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; With SSE4.1 use the `pmovsx*` instructions for this\n(rule 1 (lower (has_type $I16X8 (swiden_low val @ (value_type $I8X16))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxbw val))\n(rule 1 (lower (has_type $I32X4 (swiden_low val @ (value_type $I16X8))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxwd val))\n(rule 1 (lower (has_type $I64X2 (swiden_low val @ (value_type $I32X4))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxdq val))\n\n(rule (lower (has_type ty (swiden_low val))) (lower_swiden_low ty val))\n\n(decl lower_swiden_low (Type Xmm) Xmm)\n\n;; Duplicate the low lanes next to each other, then perform a wider shift-right\n;; by the low lane width to move the upper of each pair back into the lower lane\n;; of each pair, achieving the widening of the lower lanes.\n(rule (lower_swiden_low $I16X8 val)\n      (x64_psraw (x64_punpcklbw val val) (xmi_imm 8)))\n(rule (lower_swiden_low $I32X4 val)\n      (x64_psrad (x64_punpcklwd val val) (xmi_imm 16)))\n\n;; Generate the sign-extended halves with a `val < 0` comparison (expressed\n;; reversed here), then interleave the low 32-bit halves to create the full\n;; 64-bit results.\n(rule (lower_swiden_low $I64X2 val)\n      (let ((tmp Xmm (x64_pcmpgtd (xmm_zero $I32X4) val)))\n      (x64_punpckldq val tmp)))\n\n;; Rules for `swiden_high` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Similar to `swiden_low` with SSE4.1 except that the upper lanes are moved\n;; to the lower lanes first.\n(rule 1 (lower (has_type $I16X8 (swiden_high val @ (value_type $I8X16))))\n        (if-let $true (use_sse41))\n        (if-let $true (use_ssse3))\n        (let ((x Xmm val))\n          (x64_pmovsxbw (x64_palignr x x 8))))\n(rule 1 (lower (has_type $I32X4 (swiden_high val @ (value_type $I16X8))))\n        (if-let $true (use_sse41))\n        (if-let $true (use_ssse3))\n        (let ((x Xmm val))\n          (x64_pmovsxwd (x64_palignr x x 8))))\n(rule 1 (lower (has_type $I64X2 (swiden_high val @ (value_type $I32X4))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxdq (x64_pshufd val 0b11_10_11_10)))\n\n;; Similar to `swiden_low` versions but using `punpckh*` instructions to\n;; pair the high lanes next to each other.\n(rule (lower (has_type $I16X8 (swiden_high val @ (value_type $I8X16))))\n      (let ((val Xmm val))\n        (x64_psraw (x64_punpckhbw val val) (xmi_imm 8))))\n(rule (lower (has_type $I32X4 (swiden_high val @ (value_type $I16X8))))\n      (let ((val Xmm val))\n        (x64_psrad (x64_punpckhwd val val) (xmi_imm 16))))\n\n;; Same as `swiden_low`, but `val` has its high lanes moved down.\n(rule (lower (has_type $I64X2 (swiden_high val @ (value_type $I32X4))))\n      (let ((val Xmm (x64_pshufd val 0b00_00_11_10))\n            (tmp Xmm (x64_pcmpgtd (xmm_zero $I32X4) val)))\n      (x64_punpckldq val tmp)))\n\n;; Rules for `uwiden_low` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; With SSE4.1 use the `pmovzx*` instructions for this\n(rule 1 (lower (has_type $I16X8 (uwiden_low val @ (value_type $I8X16))))\n        (if-let $true (use_sse41))\n        (x64_pmovzxbw val))\n(rule 1 (lower (has_type $I32X4 (uwiden_low val @ (value_type $I16X8))))\n        (if-let $true (use_sse41))\n        (x64_pmovzxwd val))\n(rule 1 (lower (has_type $I64X2 (uwiden_low val @ (value_type $I32X4))))\n        (if-let $true (use_sse41))\n        (x64_pmovzxdq val))\n\n(rule (lower (has_type ty (uwiden_low val))) (lower_uwiden_low ty val))\n\n;; Interleave an all-zero register with the low lanes to produce zero-extended\n;; results.\n(decl lower_uwiden_low (Type Xmm) Xmm)\n(rule (lower_uwiden_low $I16X8 val) (x64_punpcklbw val (xmm_zero $I8X16)))\n(rule (lower_uwiden_low $I32X4 val) (x64_punpcklwd val (xmm_zero $I8X16)))\n(rule (lower_uwiden_low $I64X2 val) (x64_unpcklps val (xmm_zero $F32X4)))\n\n;; Rules for `uwiden_high` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Same as `uwiden_high`, but interleaving high lanes instead.\n;;\n;; Note that according to `llvm-mca` at least these instructions are faster\n;; than using `pmovzx*` in terms of cycles, even if SSE4.1 is available.\n(rule (lower (has_type $I16X8 (uwiden_high val @ (value_type $I8X16))))\n      (x64_punpckhbw val (xmm_zero $I8X16)))\n(rule (lower (has_type $I32X4 (uwiden_high val @ (value_type $I16X8))))\n      (x64_punpckhwd val (xmm_zero $I8X16)))\n(rule (lower (has_type $I64X2 (uwiden_high val @ (value_type $I32X4))))\n      (x64_unpckhps val (xmm_zero $F32X4)))\n\n;; Rules for `snarrow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16 (snarrow a @ (value_type $I16X8) b)))\n      (x64_packsswb a b))\n\n(rule (lower (has_type $I16X8 (snarrow a @ (value_type $I32X4) b)))\n      (x64_packssdw a b))\n\n;; We're missing a `snarrow` case for $I64X2\n;; https://github.com/bytecodealliance/wasmtime/issues/4734\n\n;; This rule is a special case for handling the translation of the wasm op\n;; `i32x4.trunc_sat_f64x2_s_zero`. It can be removed once we have an\n;; implementation of `snarrow` for `I64X2`.\n(rule (lower (has_type $I32X4 (snarrow (has_type $I64X2 (fcvt_to_sint_sat val))\n                                       (vconst (u128_from_constant 0)))))\n      (let ((a Xmm val)\n\n            ;; y = i32x4.trunc_sat_f64x2_s_zero(x) is lowered to:\n            ;; MOVE xmm_tmp, xmm_x\n            ;; CMPEQPD xmm_tmp, xmm_x\n            ;; MOVE xmm_y, xmm_x\n            ;; ANDPS xmm_tmp, [wasm_f64x2_splat(2147483647.0)]\n            ;; MINPD xmm_y, xmm_tmp\n            ;; CVTTPD2DQ xmm_y, xmm_y\n\n            (tmp1 Xmm (x64_cmppd a a (FcmpImm.Equal)))\n\n            ;; 2147483647.0 is equivalent to 0x41DFFFFFFFC00000\n            (umax_mask XmmMem (emit_u128_le_const 0x41DFFFFFFFC00000_41DFFFFFFFC00000))\n\n            ;; ANDPD xmm_y, [wasm_f64x2_splat(2147483647.0)]\n            (tmp1 Xmm (x64_andps tmp1 umax_mask))\n            (dst Xmm (x64_minpd a tmp1)))\n        (x64_cvttpd2dq dst)))\n\n;; This rule is a special case for handling the translation of the wasm op\n;; `i32x4.relaxed_trunc_f64x2_s_zero`.\n(rule (lower (has_type $I32X4 (snarrow (has_type $I64X2 (x86_cvtt2dq val))\n                                       (vconst (u128_from_constant 0)))))\n        (x64_cvttpd2dq val))\n\n;; Rules for `unarrow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16 (unarrow a @ (value_type $I16X8) b)))\n      (x64_packuswb a b))\n\n(rule 1 (lower (has_type $I16X8 (unarrow a @ (value_type $I32X4) b)))\n        (if-let $true (use_sse41))\n        (x64_packusdw a b))\n\n;; For each input `a` and `b` take the four 32-bit lanes and compress them to\n;; the low 64-bits of the vector as four 16-bit lanes. Then these are woven\n;; into one final vector with a `punpcklqdq`.\n;;\n;; If this is performance sensitive then it's probably best to upgrade the CPU\n;; to get the above single-instruction lowering.\n(rule (lower (has_type $I16X8 (unarrow a @ (value_type $I32X4) b)))\n      (let (\n          (a Xmm (unarrow_i32x4_lanes_to_low_u16_lanes a))\n          (b Xmm (unarrow_i32x4_lanes_to_low_u16_lanes b))\n        )\n        (x64_punpcklqdq a b)))\n\n(decl unarrow_i32x4_lanes_to_low_u16_lanes (Xmm) Xmm)\n(rule (unarrow_i32x4_lanes_to_low_u16_lanes val)\n      (let (\n          ;; First convert all negative values in `val` to zero lanes.\n          (val_gt_zero Xmm (x64_pcmpgtd val (xmm_zero $I32X4)))\n          (val Xmm (x64_pand val val_gt_zero))\n\n          ;; Next clamp all larger-than-u16-max lanes to u16::MAX.\n          (max Xmm (x64_movdqu_load (emit_u128_le_const 0x0000ffff_0000ffff_0000ffff_0000ffff)))\n          (cmp Xmm (x64_pcmpgtd max val))\n          (valid_lanes Xmm (x64_pand val cmp))\n          (clamped_lanes Xmm (x64_pandn cmp max))\n          (val Xmm (x64_por valid_lanes clamped_lanes))\n\n          ;; Within each 64-bit half of the 32x4 vector move the first 16 bits\n          ;; and the third 16 bits to the bottom of the half. Afterwards\n          ;; for the 32x4 vector move the first and third lanes to the bottom\n          ;; lanes, which finishes up the conversion here as all the lanes\n          ;; are now converted to 16-bit values in the low 4 lanes.\n          (val Xmm (x64_pshuflw val 0b00_00_10_00))\n          (val Xmm (x64_pshufhw val 0b00_00_10_00))\n        )\n        (x64_pshufd val 0b00_00_10_00)))\n\n\n;; We're missing a `unarrow` case for $I64X2\n;; https://github.com/bytecodealliance/wasmtime/issues/4734\n\n;; Rules for `bitcast` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I32 (bitcast _ src @ (value_type $F32))))\n      (bitcast_xmm_to_gpr $F32 src))\n\n(rule (lower (has_type $F32 (bitcast _ src @ (value_type $I32))))\n      (bitcast_gpr_to_xmm $I32 src))\n\n(rule (lower (has_type $I64 (bitcast _ src @ (value_type $F64))))\n      (bitcast_xmm_to_gpr $F64 src))\n\n(rule (lower (has_type $F64 (bitcast _ src @ (value_type $I64))))\n      (bitcast_gpr_to_xmm $I64 src))\n\n;; Bitcast between types residing in GPR registers is a no-op.\n(rule 1 (lower (has_type (is_gpr_type _)\n                         (bitcast _ x @ (value_type (is_gpr_type _))))) x)\n\n;; Bitcast between types residing in XMM registers is a no-op.\n(rule 2 (lower (has_type (is_xmm_type _)\n                         (bitcast _ x @ (value_type (is_xmm_type _))))) x)\n\n;; Rules for `fcopysign` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fcopysign a @ (value_type $F32) b)))\n      (let ((sign_bit Xmm (imm $F32 0x80000000)))\n        (x64_orps\n          (x64_andnps sign_bit a)\n          (x64_andps sign_bit b))))\n\n(rule (lower (has_type $F64 (fcopysign a @ (value_type $F64) b)))\n      (let ((sign_bit Xmm (imm $F64 0x8000000000000000)))\n        (x64_orpd\n          (x64_andnpd sign_bit a)\n          (x64_andpd sign_bit b))))\n\n;; Helper for the `ceil`/`floor`/`nearest`/`trunc` instructions ;;;;;;;;;;;;;;;;\n\n;; Emits either a `round{ss,sd,ps,pd}` instruction, as appropriate, or generates\n;; the appropriate libcall and sequence to call that.\n(decl x64_round (Type RegMem RoundImm) Xmm)\n(rule 1 (x64_round $F32 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundss a imm))\n(rule 1 (x64_round $F64 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundsd a imm))\n(rule 1 (x64_round $F32X4 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundps a imm))\n(rule 1 (x64_round $F64X2 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundpd a imm))\n\n(rule (x64_round $F32 (RegMem.Reg a) imm) (libcall_1 (round_libcall $F32 imm) a))\n(rule (x64_round $F64 (RegMem.Reg a) imm) (libcall_1 (round_libcall $F64 imm) a))\n(rule (x64_round $F32X4 (RegMem.Reg a) imm)\n      (let (\n          (libcall LibCall (round_libcall $F32 imm))\n          (result Xmm (libcall_1 libcall a))\n          (a1 Xmm (libcall_1 libcall (x64_pshufd a 1)))\n          (result Xmm (vec_insert_lane $F32X4 result a1 1))\n          (a2 Xmm (libcall_1 libcall (x64_pshufd a 2)))\n          (result Xmm (vec_insert_lane $F32X4 result a2 2))\n          (a3 Xmm (libcall_1 libcall (x64_pshufd a 3)))\n          (result Xmm (vec_insert_lane $F32X4 result a3 3))\n        )\n        result))\n(rule (x64_round $F64X2 (RegMem.Reg a) imm)\n      (let (\n          (libcall LibCall (round_libcall $F64 imm))\n          (result Xmm (libcall_1 libcall a))\n          (a1 Xmm (libcall_1 libcall (x64_pshufd a 0b00_00_11_10)))\n          (result Xmm (vec_insert_lane $F64X2 result a1 1))\n        )\n        result))\n(rule (x64_round ty (RegMem.Mem addr) imm)\n      (x64_round ty (RegMem.Reg (x64_load ty addr (ExtKind.ZeroExtend))) imm))\n\n(decl round_libcall (Type RoundImm) LibCall)\n(rule (round_libcall $F32 (RoundImm.RoundUp)) (LibCall.CeilF32))\n(rule (round_libcall $F64 (RoundImm.RoundUp)) (LibCall.CeilF64))\n(rule (round_libcall $F32 (RoundImm.RoundDown)) (LibCall.FloorF32))\n(rule (round_libcall $F64 (RoundImm.RoundDown)) (LibCall.FloorF64))\n(rule (round_libcall $F32 (RoundImm.RoundNearest)) (LibCall.NearestF32))\n(rule (round_libcall $F64 (RoundImm.RoundNearest)) (LibCall.NearestF64))\n(rule (round_libcall $F32 (RoundImm.RoundZero)) (LibCall.TruncF32))\n(rule (round_libcall $F64 (RoundImm.RoundZero)) (LibCall.TruncF64))\n\n;; Rules for `ceil` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (ceil a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundUp)))\n\n;; Rules for `floor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (floor a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundDown)))\n\n;; Rules for `nearest` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (nearest a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundNearest)))\n\n;; Rules for `trunc` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (trunc a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundZero)))\n\n;; Rules for `stack_addr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (stack_addr stack_slot offset))\n      (stack_addr_impl stack_slot offset))\n\n;; Rules for `udiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; NB: a `RegMem` divisor, while allowed in the instruction encoding, isn't\n;; used right now to prevent a possibly-trapping load getting folded into the\n;; `div` instruction. Ideally non-trapping loads would get folded, however, or\n;; alternatively Wasmtime/Cranelift would grow support for multiple traps on\n;; a single opcode and the signal kind would differentiate at runtime.\n\n;; The inputs to the `div` instruction are different for 8-bit division so\n;; it needs a special case here since the instruction being crafted has a\n;; different shape.\n(rule 2 (lower (udiv a @ (value_type $I8) b))\n        (x64_div8 (extend_to_gpr a $I32 (ExtendKind.Zero))\n                  (put_in_gpr b)\n                  (DivSignedness.Unsigned)\n                  (TrapCode.IntegerDivisionByZero)))\n\n;; 16-to-64-bit division is all done with a similar instruction and the only\n;; tricky requirement here is that when div traps are disallowed the divisor\n;; must not be zero.\n(rule 1 (lower (udiv a @ (value_type (fits_in_64 ty)) b))\n        (x64_div_quotient a\n                          (imm $I64 0)\n                          (put_in_gpr b)\n                          (raw_operand_size_of_type ty)\n                          (DivSignedness.Unsigned)\n                          (TrapCode.IntegerDivisionByZero)))\n\n;; Rules for `sdiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (sdiv a @ (value_type $I8) b))\n        (x64_div8 (x64_sign_extend_data a (OperandSize.Size8))\n                  (nonzero_sdiv_divisor $I8 b)\n                  (DivSignedness.Signed)\n                  (TrapCode.IntegerOverflow)))\n\n(rule 1 (lower (sdiv a @ (value_type (fits_in_64 ty)) b))\n        (let (\n            (a Gpr a)\n            (size OperandSize (raw_operand_size_of_type ty))\n          )\n        (x64_div_quotient a\n                          (x64_sign_extend_data a size)\n                          (nonzero_sdiv_divisor ty b)\n                          size\n                          (DivSignedness.Signed)\n                          (TrapCode.IntegerOverflow))))\n\n;; Checks to make sure that the input `Value` is a non-zero value for `sdiv`.\n;;\n;; This is required to differentiate the divide-by-zero trap from the\n;; integer-overflow trap, the two trapping conditions of signed division.\n(decl nonzero_sdiv_divisor (Type Value) Reg)\n(rule 1 (nonzero_sdiv_divisor ty (iconst imm))\n        (if-let n (safe_divisor_from_imm64 ty imm))\n        (imm ty n))\n(rule 0 (nonzero_sdiv_divisor ty val)\n      (let (\n          (val Reg val)\n          (_ InstOutput (side_effect (with_flags_side_effect\n            (x64_test (raw_operand_size_of_type ty) val val)\n            (trap_if (CC.Z) (TrapCode.IntegerDivisionByZero)))))\n        )\n        val))\n\n;; Rules for `urem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; The remainder is in AH, so take the result of the division and right-shift\n;; by 8.\n(rule 2 (lower (urem a @ (value_type $I8) b))\n        (let (\n            (result Gpr (x64_div8 (extend_to_gpr a $I32 (ExtendKind.Zero))\n                                  (put_in_gpr b) ;; see `udiv` for why not `gpr_mem`\n                                  (DivSignedness.Unsigned)\n                                  (TrapCode.IntegerDivisionByZero)))\n          )\n          (x64_shr $I64 result (Imm8Reg.Imm8 8))))\n\n(rule 1 (lower (urem a @ (value_type (fits_in_64 ty)) b))\n        (x64_div_remainder a\n                           (imm $I64 0)\n                           (put_in_gpr b) ;; see `udiv` for why not `gpr_mem`\n                           (raw_operand_size_of_type ty)\n                           (DivSignedness.Unsigned)\n                           (TrapCode.IntegerDivisionByZero)))\n\n;; Rules for `srem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Special-cases first for constant `srem` where the checks for 0 and -1 aren't\n;; applicable.\n;;\n;; Note that like `urem` for i8 types the result is in AH so to get the result\n;; it's right-shifted down.\n(rule 3 (lower (srem a @ (value_type $I8) (iconst imm)))\n        (if-let n (safe_divisor_from_imm64 $I8 imm))\n        (let (\n            (a Gpr (x64_sign_extend_data a (OperandSize.Size8)))\n            (result Gpr (x64_div8 a (imm $I8 n) (DivSignedness.Signed) (TrapCode.IntegerDivisionByZero)))\n          )\n          (x64_shr $I64 result (Imm8Reg.Imm8 8))))\n\n;; Same as the above rule but for 16-to-64 bit types.\n(rule 2 (lower (srem a @ (value_type ty) (iconst imm)))\n        (if-let n (safe_divisor_from_imm64 ty imm))\n        (let (\n            (a Gpr a)\n            (size OperandSize (raw_operand_size_of_type ty))\n          )\n          (x64_div_remainder a\n                             (x64_sign_extend_data a size)\n                             (imm ty n)\n                             size\n                             (DivSignedness.Signed)\n                             (TrapCode.IntegerDivisionByZero))))\n\n(rule 1 (lower (srem a @ (value_type $I8) b))\n        (let (\n            (a Gpr (x64_sign_extend_data a (OperandSize.Size8)))\n          )\n          (x64_shr $I64 (x64_checked_srem_seq8 a b) (Imm8Reg.Imm8 8))))\n\n(rule (lower (srem a @ (value_type ty) b))\n      (let (\n          (a Gpr a)\n          (size OperandSize (raw_operand_size_of_type ty))\n          (hi Gpr (x64_sign_extend_data a size))\n          (tmp ValueRegs (x64_checked_srem_seq size a hi b))\n        )\n        (value_regs_get tmp 1)))\n\n;; Rules for `umulhi` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (umulhi a @ (value_type $I16) b))\n      (let ((res ValueRegs (mul_hi $I16 $false a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (umulhi a @ (value_type $I32) b))\n      (let ((res ValueRegs (mul_hi $I32 $false a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (umulhi a @ (value_type $I64) b))\n      (let ((res ValueRegs (mul_hi $I64 $false a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n;; Rules for `smulhi` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (smulhi a @ (value_type $I16) b))\n      (let ((res ValueRegs (mul_hi $I16 $true a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (smulhi a @ (value_type $I32) b))\n      (let ((res ValueRegs (mul_hi $I32 $true a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (smulhi a @ (value_type $I64) b))\n      (let ((res ValueRegs (mul_hi $I64 $true a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n;; Rules for `get_pinned_reg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (get_pinned_reg))\n      (read_pinned_gpr))\n\n;; Rules for `set_pinned_reg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (set_pinned_reg a @ (value_type ty)))\n      (side_effect (write_pinned_gpr a)))\n\n;; Rules for `vconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type ty (vconst const)))\n      ;; TODO use Inst::gen_constant() instead.\n      (x64_xmm_load_const ty (const_to_vconst const)))\n\n;; Rules for `shuffle` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Special case for `pblendw` which takes an 8-bit immediate where each bit\n;; indicates which lane of the two operands is chosen for the output. A bit of\n;; 0 chooses the corresponding 16-it lane from `a` and a bit of 1 chooses the\n;; corresponding 16-bit lane from `b`.\n(rule 14 (lower (shuffle a b (pblendw_imm n)))\n         (if-let $true (use_sse41))\n         (x64_pblendw a b n))\n(decl pblendw_imm (u8) Immediate)\n(extern extractor pblendw_imm pblendw_imm)\n\n;; When the shuffle looks like \"concatenate `a` and `b` and shift right by n*8\n;; bytes\", that's a `palignr` instruction. Note that the order of operands are\n;; swapped in the instruction here. The `palignr` instruction uses the second\n;; operand as the low-order bytes and the first operand as high-order bytes,\n;; so put `a` second.\n(rule 13 (lower (shuffle a b (palignr_imm_from_immediate n)))\n         (if-let $true (use_ssse3))\n         (x64_palignr b a n))\n(decl palignr_imm_from_immediate (u8) Immediate)\n(extern extractor palignr_imm_from_immediate palignr_imm_from_immediate)\n\n;; Special case the `pshuf{l,h}w` instruction which shuffles four 16-bit\n;; integers within one value, preserving the other four 16-bit integers in that\n;; value (either the high or low half). The complicated logic is in the\n;; extractors here implemented in Rust and note that there's two cases for each\n;; instruction here to match when either the first or second shuffle operand is\n;; used.\n(rule 12 (lower (shuffle x y (pshuflw_lhs_imm imm)))\n      (x64_pshuflw x imm))\n(rule 11 (lower (shuffle x y (pshuflw_rhs_imm imm)))\n      (x64_pshuflw y imm))\n(rule 10 (lower (shuffle x y (pshufhw_lhs_imm imm)))\n      (x64_pshufhw x imm))\n(rule 9 (lower (shuffle x y (pshufhw_rhs_imm imm)))\n      (x64_pshufhw y imm))\n\n(decl pshuflw_lhs_imm (u8) Immediate)\n(extern extractor pshuflw_lhs_imm pshuflw_lhs_imm)\n(decl pshuflw_rhs_imm (u8) Immediate)\n(extern extractor pshuflw_rhs_imm pshuflw_rhs_imm)\n(decl pshufhw_lhs_imm (u8) Immediate)\n(extern extractor pshufhw_lhs_imm pshufhw_lhs_imm)\n(decl pshufhw_rhs_imm (u8) Immediate)\n(extern extractor pshufhw_rhs_imm pshufhw_rhs_imm)\n\n;; Special case for the `pshufd` instruction which will permute 32-bit values\n;; within a single register. This is only applicable if the `imm` specified\n;; selects 32-bit values from either `x` or `y`, but not both. This means\n;; there's one rule for selecting from `x` and another rule for selecting from\n;; `y`.\n(rule 8 (lower (shuffle x y (pshufd_lhs_imm imm)))\n      (x64_pshufd x imm))\n(rule 7 (lower (shuffle x y (pshufd_rhs_imm imm)))\n      (x64_pshufd y imm))\n\n(decl pshufd_lhs_imm (u8) Immediate)\n(extern extractor pshufd_lhs_imm pshufd_lhs_imm)\n(decl pshufd_rhs_imm (u8) Immediate)\n(extern extractor pshufd_rhs_imm pshufd_rhs_imm)\n\n;; Special case for i8-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f0f_1e0e_1d0d_1c0c_1b0b_1a0a_1909_1808)))\n      (x64_punpckhbw a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1707_1606_1505_1404_1303_1202_1101_1000)))\n      (x64_punpcklbw a b))\n\n;; Special case for i16-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f1e_0f0e_1d1c_0d0c_1b1a_0b0a_1918_0908)))\n      (x64_punpckhwd a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1716_0706_1514_0504_1312_0302_1110_0100)))\n      (x64_punpcklwd a b))\n\n;; Special case for i32-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f1e1d1c_0f0e0d0c_1b1a1918_0b0a0908)))\n      (x64_punpckhdq a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x17161514_07060504_13121110_03020100)))\n      (x64_punpckldq a b))\n\n;; Special case for i64-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f1e1d1c1b1a1918_0f0e0d0c0b0a0908)))\n      (x64_punpckhqdq a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1716151413121110_0706050403020100)))\n      (x64_punpcklqdq a b))\n\n;; If the vector shift mask is all 0s then that means the first byte of the\n;; first operand is broadcast to all bytes. Falling through would load an\n;; all-zeros constant from a rip-relative location but it should be slightly\n;; more efficient to execute the `pshufb` here-and-now with an xor'd-to-be-zero\n;; register.\n(rule 6 (lower (shuffle a _ (u128_from_immediate 0)))\n        (if-let $true (use_ssse3))\n        (x64_pshufb a (xmm_zero $I8X16)))\n\n;; Special case for the `shufps` instruction which will select two 32-bit values\n;; from the first operand and two 32-bit values from the second operand. Note\n;; that there is a second case here as well for when the operands can be\n;; swapped.\n;;\n;; Note that the priority of this instruction is currently lower than the above\n;; special cases since `shufps` handles many of them and for now it's\n;; hypothesized that the dedicated instructions are better than `shufps`.\n;; Someone with more knowledge about x86 timings should perhaps reorder the\n;; rules here eventually though.\n(rule 5 (lower (shuffle x y (shufps_imm imm)))\n      (x64_shufps x y imm))\n(rule 4 (lower (shuffle x y (shufps_rev_imm imm)))\n      (x64_shufps y x imm))\n\n(decl shufps_imm(u8) Immediate)\n(extern extractor shufps_imm shufps_imm)\n(decl shufps_rev_imm(u8) Immediate)\n(extern extractor shufps_rev_imm shufps_rev_imm)\n\n\n;; If `lhs` and `rhs` are the same we can use a single PSHUFB to shuffle the XMM\n;; register. We statically build `constructed_mask` to zero out any unknown lane\n;; indices (may not be completely necessary: verification could fail incorrect\n;; mask values) and fix the indexes to all point to the `dst` vector.\n(rule 3 (lower (shuffle a a (vec_mask_from_immediate mask)))\n        (if-let $true (use_ssse3))\n        (x64_pshufb a (shuffle_0_31_mask mask)))\n\n;; For the case where the shuffle mask contains out-of-bounds values (values\n;; greater than 31) we must mask off those resulting values in the result of\n;; `vpermi2b`.\n(rule 2 (lower (shuffle a b (vec_mask_from_immediate (perm_from_mask_with_zeros mask zeros))))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512vbmi))\n      (x64_andps (x64_vpermi2b (x64_xmm_load_const $I8X16 mask) a b) zeros))\n\n;; However, if the shuffle mask contains no out-of-bounds values, we can use\n;; `vpermi2b` without any masking.\n(rule 1 (lower (shuffle a b (vec_mask_from_immediate mask)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512vbmi))\n      (x64_vpermi2b (x64_xmm_load_const $I8X16 (perm_from_mask mask)) a b))\n\n;; If `lhs` and `rhs` are different, we must shuffle each separately and then OR\n;; them together. This is necessary due to PSHUFB semantics. As in the case\n;; above, we build the `constructed_mask` for each case statically.\n(rule (lower (shuffle a b (vec_mask_from_immediate mask)))\n      (x64_por\n        (lower_pshufb a (shuffle_0_15_mask mask))\n        (lower_pshufb b (shuffle_16_31_mask mask))))\n\n;; Rules for `swizzle` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; SIMD swizzle; the following inefficient implementation is due to the Wasm\n;; SIMD spec requiring mask indexes greater than 15 to have the same semantics\n;; as a 0 index. For the spec discussion, see\n;; https://github.com/WebAssembly/simd/issues/93. The CLIF semantics match the\n;; Wasm SIMD semantics for this instruction. The instruction format maps to\n;; variables like: %dst = swizzle %src, %mask\n(rule (lower (swizzle src mask))\n      (let ((mask Xmm (x64_paddusb mask (emit_u128_le_const 0x70707070707070707070707070707070))))\n        (lower_pshufb src mask)))\n\n;; Rules for `x86_pshufb` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (x86_pshufb src mask))\n      (if-let $true (use_ssse3))\n      (x64_pshufb src mask))\n\n;; A helper function to generate either the `pshufb` instruction or a libcall to\n;; the `X86Pshufb` libcall. Note that the libcall is not exactly the most\n;; performant thing in the world so this is primarily here for completeness\n;; of lowerings on all x86 cpus but if rules are ideally gated on the presence\n;; of SSSE3 to use the `pshufb` instruction itself.\n(decl lower_pshufb (Xmm RegMem) Xmm)\n(rule 1 (lower_pshufb src mask)\n        (if-let $true (use_ssse3))\n        (x64_pshufb src mask))\n(rule (lower_pshufb src (RegMem.Reg mask))\n      (libcall_2 (LibCall.X86Pshufb) src mask))\n(rule (lower_pshufb src (RegMem.Mem addr))\n      (lower_pshufb src (x64_movdqu_load addr)))\n\n;; Rules for `extractlane` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Remove the extractlane instruction, leaving the float where it is. The upper\n;; bits will remain unchanged; for correctness, this relies on Cranelift type\n;; checking to avoid using those bits.\n(rule 3 (lower (has_type (ty_scalar_float _) (extractlane val 0)))\n        val)\n\n;; `f32x4.extract_lane N` where `N != 0`\n(rule 1 (lower (extractlane val @ (value_type $F32X4) (u8_from_uimm8 lane)))\n        (x64_pshufd val lane))\n\n;; `f64x2.extract_lane N` where `N != 0` (aka N == 1)\n(rule (lower (extractlane val @ (value_type $F64X2) 1))\n      (x64_pshufd val 0b11_10_11_10))\n\n;; `i8x16.extract_lane N`\n;;\n;; Note that without SSE4.1 a 16-bit lane extraction is performed and then\n;; the result is updated if the desired index is either odd or even.\n(rule 2 (lower (extractlane val @ (value_type ty @ $I8X16) (u8_from_uimm8 lane)))\n        (if-let $true (use_sse41))\n        (x64_pextrb val lane))\n;; extracting an odd lane has an extra shift-right\n(rule 1 (lower (extractlane val @ (value_type ty @ $I8X16) (u8_from_uimm8 lane)))\n        (if-let 1 (u8_and lane 1))\n        (x64_shr $I16 (x64_pextrw val (u8_shr lane 1)) (Imm8Reg.Imm8 8)))\n;; Extracting an even lane already has the desired lane in the lower bits. Note\n;; that having arbitrary upper bits in the returned register should be ok since\n;; all operators on the resulting `i8` type should work correctly regardless of\n;; the bits in the rest of the register.\n(rule (lower (extractlane val @ (value_type ty @ $I8X16) (u8_from_uimm8 lane)))\n      (if-let 0 (u8_and lane 1))\n      (x64_pextrw val (u8_shr lane 1)))\n\n;; `i16x8.extract_lane N`\n(rule (lower (extractlane val @ (value_type ty @ $I16X8) (u8_from_uimm8 lane)))\n      (x64_pextrw val lane))\n\n;; `i32x4.extract_lane N`\n(rule 2 (lower (extractlane val @ (value_type ty @ $I32X4) (u8_from_uimm8 lane)))\n        (if-let $true (use_sse41))\n        (x64_pextrd val lane))\n(rule 1 (lower (extractlane val @ (value_type $I32X4) 0))\n        (x64_movd_to_gpr val))\n(rule (lower (extractlane val @ (value_type $I32X4) (u8_from_uimm8 n)))\n      (x64_movd_to_gpr (x64_pshufd val n)))\n\n;; `i64x2.extract_lane N`\n(rule 1 (lower (extractlane val @ (value_type $I64X2) (u8_from_uimm8 lane)))\n        (if-let $true (use_sse41))\n        (x64_pextrq val lane))\n(rule (lower (extractlane val @ (value_type $I64X2) 0))\n      (x64_movq_to_gpr val))\n(rule (lower (extractlane val @ (value_type $I64X2) 1))\n      (x64_movq_to_gpr (x64_pshufd val 0b00_00_11_10)))\n\n;; Rules for `scalar_to_vector` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Case 1: when moving a scalar float, we simply move from one XMM register\n;; to another, expecting the register allocator to elide this. Here we\n;; assume that the upper bits of a scalar float have not been munged with\n;; (the same assumption the old backend makes).\n(rule 1 (lower (scalar_to_vector src @ (value_type (ty_scalar_float _))))\n      src)\n\n;; Case 2: when moving a scalar value of any other type, use MOVD to zero\n;; the upper lanes.\n(rule (lower (scalar_to_vector src @ (value_type ty)))\n      (bitcast_gpr_to_xmm ty src))\n\n;; Case 3: when presented with `load + scalar_to_vector`, coalesce into a single\n;; MOVSS/MOVSD instruction.\n(rule 2 (lower (scalar_to_vector (and (sinkable_load src) (value_type (ty_32 _)))))\n      (x64_movss_load src))\n(rule 3 (lower (scalar_to_vector (and (sinkable_load src) (value_type (ty_64 _)))))\n      (x64_movsd_load src))\n\n;; Rules for `splat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; For all the splat rules below one of the goals is that splatting a value\n;; doesn't end up accidentally depending on the previous value in a register.\n;; This means that instructions are chosen to avoid false dependencies where\n;; new values are created fresh or otherwise overwrite previous register\n;; contents where possible.\n;;\n;; Additionally splats are specialized to special-case load-and-splat which\n;; has a number of micro-optimizations available.\n\n;; i8x16 splats: use `vpbroadcastb` on AVX2 and otherwise `pshufb` broadcasts\n;; with a mask of zero which is calculated with an xor-against-itself register.\n(rule 0 (lower (has_type $I8X16 (splat src)))\n        (let ((src Xmm (x64_movd_to_xmm src)))\n          (x64_pshufd (x64_pshuflw (x64_punpcklbw src src) 0) 0)))\n(rule 1 (lower (has_type $I8X16 (splat src)))\n        (if-let $true (use_ssse3))\n        (x64_pshufb (bitcast_gpr_to_xmm $I32 src) (xmm_zero $I8X16)))\n(rule 2 (lower (has_type $I8X16 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastb (bitcast_gpr_to_xmm $I32 src)))\n(rule 3 (lower (has_type $I8X16 (splat (sinkable_load_exact addr))))\n        (if-let $true (use_sse41))\n        (if-let $true (use_ssse3))\n        (x64_pshufb (x64_pinsrb (xmm_uninit_value) addr 0) (xmm_zero $I8X16)))\n(rule 4 (lower (has_type $I8X16 (splat (sinkable_load_exact addr))))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastb addr))\n\n;; i16x8 splats: use `vpbroadcastw` on AVX2 and otherwise a 16-bit value is\n;; loaded into an xmm register, `pshuflw` broadcasts the low 16-bit lane\n;; to the low four lanes, and `pshufd` broadcasts the low 32-bit lane (which\n;; at that point is two of the 16-bit values we want to broadcast) to all the\n;; lanes.\n(rule 0 (lower (has_type $I16X8 (splat src)))\n        (x64_pshufd (x64_pshuflw (bitcast_gpr_to_xmm $I32 src) 0) 0))\n(rule 1 (lower (has_type $I16X8 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastw (bitcast_gpr_to_xmm $I32 src)))\n(rule 2 (lower (has_type $I16X8 (splat (sinkable_load_exact addr))))\n        (x64_pshufd (x64_pshuflw (x64_pinsrw (xmm_uninit_value) addr 0) 0) 0))\n(rule 3 (lower (has_type $I16X8 (splat (sinkable_load_exact addr))))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastw addr))\n\n;; i32x4.splat - use `vpbroadcastd` on AVX2 and otherwise `pshufd` can be\n;; used to broadcast the low lane to all other lanes.\n;;\n;; Note that sinkable-load cases come later\n(rule 0 (lower (has_type $I32X4 (splat src)))\n        (x64_pshufd (bitcast_gpr_to_xmm $I32 src) 0))\n(rule 1 (lower (has_type $I32X4 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastd (bitcast_gpr_to_xmm $I32 src)))\n\n;; f32x4.splat - the source is already in an xmm register so `shufps` is all\n;; that's necessary to complete the splat. This is specialized to `vbroadcastss`\n;; on AVX2 to leverage that specific instruction for this operation.\n(rule 0 (lower (has_type $F32X4 (splat src)))\n        (let ((tmp Xmm src))\n          (x64_shufps src src 0)))\n(rule 1 (lower (has_type $F32X4 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vbroadcastss src))\n\n;; t32x4.splat of a load - use a `movss` to load into an xmm register and then\n;; `shufps` broadcasts to the other lanes. Note that this is used for both i32\n;; and f32 splats.\n;;\n;; With AVX the `vbroadcastss` instruction suits this purpose precisely. Note\n;; that the memory-operand encoding of `vbroadcastss` is usable with AVX, but\n;; the register-based encoding is only available with AVX2. With the\n;; `sinkable_load` extractor this should be guaranteed to use the memory-based\n;; encoding hence the `use_avx` test.\n(rule 5 (lower (has_type (multi_lane 32 4) (splat (sinkable_load addr))))\n        (let ((tmp Xmm (x64_movss_load addr)))\n          (x64_shufps tmp tmp 0)))\n(rule 6 (lower (has_type (multi_lane 32 4) (splat (sinkable_load addr))))\n        (if-let $true (use_avx))\n        (x64_vbroadcastss addr))\n\n;; t64x2.splat - use `pshufd` to broadcast the lower 64-bit lane to the upper\n;; lane. A minor specialization for sinkable loads to avoid going through a gpr\n;; for i64 splats is used as well when `movddup` is available.\n(rule 0 (lower (has_type $I64X2 (splat src)))\n        (x64_pshufd (bitcast_gpr_to_xmm $I64 src) 0b01_00_01_00))\n(rule 0 (lower (has_type $F64X2 (splat src)))\n        (x64_pshufd src 0b01_00_01_00))\n(rule 6 (lower (has_type (multi_lane 64 2) (splat (sinkable_load addr))))\n        (if-let $true (use_ssse3))\n        (x64_movddup addr))\n\n;; Rules for `vany_true` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (vany_true val))\n        (if-let $true (use_sse41))\n        (let ((val Xmm val))\n          (with_flags (x64_ptest val val) (x64_setcc (CC.NZ)))))\n\n;; Any nonzero byte in `val` means that any lane is true. Compare `val` with a\n;; zeroed register and extract the high bits to a gpr mask. If the mask is\n;; 0xffff then every byte was equal to zero, so test if the comparison is\n;; not-equal or NZ.\n(rule (lower (vany_true val))\n      (let (\n          (any_byte_zero Xmm (x64_pcmpeqb val (xmm_zero $I8X16)))\n          (mask Gpr (x64_pmovmskb (OperandSize.Size32) any_byte_zero))\n        )\n        (with_flags (x64_cmp (OperandSize.Size32) (RegMemImm.Imm 0xffff) mask)\n                    (x64_setcc (CC.NZ)))))\n\n;; Rules for `vall_true` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (vall_true val @ (value_type ty)))\n        (if-let $true (use_sse41))\n        (let ((src Xmm val)\n              (zeros Xmm (xmm_zero ty))\n              (cmp Xmm (x64_pcmpeq (vec_int_type ty) src zeros)))\n          (with_flags (x64_ptest cmp cmp) (x64_setcc (CC.Z)))))\n\n;; Perform an appropriately-sized lane-wise comparison with zero. If the\n;; result is all 0s then all of them are true because nothing was equal to\n;; zero.\n(rule (lower (vall_true val @ (value_type ty)))\n      (let ((lanes_with_zero Xmm (x64_pcmpeq (vec_int_type ty) val (xmm_zero ty)))\n            (mask Gpr (x64_pmovmskb (OperandSize.Size32) lanes_with_zero)))\n        (with_flags (x64_test (OperandSize.Size32) mask mask)\n                    (x64_setcc (CC.Z)))))\n\n;; Rules for `vhigh_bits` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; The Intel specification allows using both 32-bit and 64-bit GPRs as\n;; destination for the \"move mask\" instructions. This is controlled by the REX.R\n;; bit: \"In 64-bit mode, the instruction can access additional registers when\n;; used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode\"\n;; (PMOVMSKB in IA Software Development Manual, vol. 2). This being the case, we\n;; will always clear REX.W since its use is unnecessary (`OperandSize` is used\n;; for setting/clearing REX.W) as we need at most 16 bits of output for\n;; `vhigh_bits`.\n\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 8 16))))\n      (x64_pmovmskb (OperandSize.Size32) val))\n\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 32 4))))\n      (x64_movmskps (OperandSize.Size32) val))\n\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 64 2))))\n      (x64_movmskpd (OperandSize.Size32) val))\n\n;; There is no x86 instruction for extracting the high bit of 16-bit lanes so\n;; here we:\n;; - duplicate the 16-bit lanes of `src` into 8-bit lanes:\n;;     PACKSSWB([x1, x2, ...], [x1, x2, ...]) = [x1', x2', ..., x1', x2', ...]\n;; - use PMOVMSKB to gather the high bits; now we have duplicates, though\n;; - shift away the bottom 8 high bits to remove the duplicates.\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 16 8))))\n      (let ((src Xmm val)\n            (tmp Xmm (x64_packsswb src src))\n            (tmp Gpr (x64_pmovmskb (OperandSize.Size32) tmp)))\n        (x64_shr $I64 tmp (Imm8Reg.Imm8 8))))\n\n;; Rules for `iconcat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (iconcat lo @ (value_type $I64) hi))\n      (value_regs lo hi))\n\n;; Rules for `isplit` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (isplit val @ (value_type $I128)))\n      (let ((regs ValueRegs val)\n            (lo Reg (value_regs_get regs 0))\n            (hi Reg (value_regs_get regs 1)))\n        (output_pair lo hi)))\n\n;; Rules for `tls_value` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (tls_model (TlsModel.ElfGd)) (tls_value (symbol_value_data name _ _))))\n      (elf_tls_get_addr name))\n\n(rule (lower (has_type (tls_model (TlsModel.Macho)) (tls_value (symbol_value_data name _ _))))\n      (macho_tls_get_addr name))\n\n(rule (lower (has_type (tls_model (TlsModel.Coff)) (tls_value (symbol_value_data name _ _))))\n      (coff_tls_get_addr name))\n\n;; Rules for `sqmul_round_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (sqmul_round_sat qx @ (value_type $I16X8) qy))\n        (if-let $true (use_ssse3))\n        (let ((src1 Xmm qx)\n              (src2 Xmm qy)\n\n              (mask XmmMem (emit_u128_le_const 0x8000_8000_8000_8000_8000_8000_8000_8000))\n              (dst Xmm (x64_pmulhrsw src1 src2))\n              (cmp Xmm (x64_pcmpeqw dst mask)))\n          (x64_pxor dst cmp)))\n\n;; This operation is defined in wasm as:\n;;\n;;    S.SignedSaturate((x * y + 0x4000) >> 15)\n;;\n;; so perform all those operations here manually with a lack of the native\n;; instruction.\n(rule (lower (sqmul_round_sat qx @ (value_type $I16X8) qy))\n      (let (\n          (qx Xmm qx)\n          (qy Xmm qy)\n          ;; Multiply `qx` and `qy` generating 32-bit intermediate results. The\n          ;; 32-bit results have their low-halves stored in `mul_lsb` and the\n          ;; high halves are stored in `mul_msb`. These are then shuffled into\n          ;; `mul_lo` and `mul_hi` which represent the low 4 multiplications\n          ;; and the upper 4 multiplications.\n          (mul_lsb Xmm (x64_pmullw qx qy))\n          (mul_msb Xmm (x64_pmulhw qx qy))\n          (mul_lo Xmm (x64_punpcklwd mul_lsb mul_msb))\n          (mul_hi Xmm (x64_punpckhwd mul_lsb mul_msb))\n          ;; Add the 0x4000 constant to all multiplications\n          (val Xmm (x64_movdqu_load (emit_u128_le_const 0x00004000_00004000_00004000_00004000)))\n          (mul_lo Xmm (x64_paddd mul_lo val))\n          (mul_hi Xmm (x64_paddd mul_hi val))\n          ;; Perform the right-shift by 15 to all multiplications\n          (lo Xmm (x64_psrad mul_lo (xmi_imm 15)))\n          (hi Xmm (x64_psrad mul_hi (xmi_imm 15)))\n        )\n        ;; And finally perform a saturating 32-to-16-bit conversion.\n        (x64_packssdw lo hi)))\n\n;; Rules for `x86_pmulhrsw` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (x86_pmulhrsw qx @ (value_type $I16X8) qy))\n      (if-let $true (use_ssse3))\n      (x64_pmulhrsw qx qy))\n\n;; Rules for `uunarrow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO: currently we only lower a special case of `uunarrow` needed to support\n;; the translation of wasm's i32x4.trunc_sat_f64x2_u_zero operation.\n;; https://github.com/bytecodealliance/wasmtime/issues/4791\n;;\n;; y = i32x4.trunc_sat_f64x2_u_zero(x) is lowered to:\n;; MOVAPD xmm_y, xmm_x\n;; XORPD xmm_tmp, xmm_tmp\n;; MAXPD xmm_y, xmm_tmp\n;; MINPD xmm_y, [wasm_f64x2_splat(4294967295.0)]\n;; ROUNDPD xmm_y, xmm_y, 0x0B\n;; ADDPD xmm_y, [wasm_f64x2_splat(0x1.0p+52)]\n;; SHUFPS xmm_y, xmm_xmp, 0x88\n(rule (lower (uunarrow (fcvt_to_uint_sat src @ (value_type $F64X2))\n                       (vconst (u128_from_constant 0))))\n      (let ((src Xmm src)\n\n            ;; MOVAPD xmm_y, xmm_x\n            ;; XORPD xmm_tmp, xmm_tmp\n            (zeros Xmm (xmm_zero $F64X2))\n            (dst Xmm (x64_maxpd src zeros))\n\n            ;; 4294967295.0 is equivalent to 0x41EFFFFFFFE00000\n            (umax_mask XmmMem (emit_u128_le_const 0x41EFFFFFFFE00000_41EFFFFFFFE00000))\n\n            ;; MINPD xmm_y, [wasm_f64x2_splat(4294967295.0)]\n            (dst Xmm (x64_minpd dst umax_mask))\n\n            ;; ROUNDPD xmm_y, xmm_y, 0x0B\n            (dst Xmm (x64_round $F64X2 dst (RoundImm.RoundZero)))\n\n            ;; ADDPD xmm_y, [wasm_f64x2_splat(0x1.0p+52)]\n            (uint_mask XmmMem (emit_u128_le_const 0x4330000000000000_4330000000000000))\n\n            (dst Xmm (x64_addpd dst uint_mask)))\n\n        ;; SHUFPS xmm_y, xmm_xmp, 0x88\n        (x64_shufps dst zeros 0x88)))\n\n;; Rules for `nop` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (nop))\n      (invalid_reg))\n", "test interpret\ntest run\ntarget aarch64\ntarget s390x\ntarget x86_64\ntarget x86_64 ssse3\ntarget x86_64 sse41\ntarget x86_64 sse42\ntarget x86_64 sse42 has_avx\ntarget x86_64 sse42 has_avx has_avx2\ntarget x86_64 sse42 has_avx has_avx2 has_avx512f has_avx512vl\ntarget riscv64 has_v\ntarget riscv64 has_v has_c has_zcb\n\n\nfunction %sshr_i8x16(i8x16, i32) -> i8x16 {\nblock0(v0: i8x16, v1: i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 1) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]\n; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 9) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]\n\nfunction %sshr_i16x8(i16x8, i32) -> i16x8 {\nblock0(v0: i16x8, v1: i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; note: because of the shifted-in sign-bit, lane 0 remains -1 == 0xffff, whereas lane 4 has been shifted to -8 == 0xfff8\n; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 1) == [-1 1 2 4 -8 16 32 64]\n; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 17) == [-1 1 2 4 -8 16 32 64]\n\nfunction %sshr_i32x4(i32x4, i32) -> i32x4 {\nblock0(v0: i32x4, v1: i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %sshr_i32x4([1 2 4 -8], 1) == [0 1 2 -4]\n; run: %sshr_i32x4([1 2 4 -8], 33) == [0 1 2 -4]\n\nfunction %sshr_i64x2(i64x2, i32) -> i64x2 {\nblock0(v0:i64x2, v1:i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %sshr_i64x2([1 -1], 0) == [1 -1]\n; run: %sshr_i64x2([1 -1], 1) == [0 -1] ; note the -1 shift result\n; run: %sshr_i64x2([2 -2], 1) == [1 -1]\n; run: %sshr_i64x2([0x80000000_00000000 0x7FFFFFFF_FFFFFFFF], 63) == [0xFFFFFFFF_FFFFFFFF 0]\n; run: %sshr_i64x2([2 -2], 65) == [1 -1]\n\n\n\nfunction %sshr_imm_i32x4(i32x4) -> i32x4 {\nblock0(v0: i32x4):\n    v1 = sshr_imm v0, 1\n    return v1\n}\n; run: %sshr_imm_i32x4([1 2 4 -8]) == [0 1 2 -4]\n\nfunction %sshr_imm_i16x8(i16x8) -> i16x8 {\nblock0(v0: i16x8):\n    v1 = sshr_imm v0, 1\n    return v1\n}\n; run: %sshr_imm_i16x8([1 2 4 -8 0 0 0 0]) == [0 1 2 -4 0 0 0 0]\n\n\nfunction %i8x16_sshr_const(i8x16) -> i8x16 {\nblock0(v0: i8x16):\n    v1 = iconst.i32 2\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i8x16_sshr_const([0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80 0 0 0 0 0 0 0 0]) == [0 0 0x01 0x02 0x04 0x08 0x10 0xe0 0 0 0 0 0 0 0 0]\n\nfunction %i16x8_sshr_const(i16x8) -> i16x8 {\nblock0(v0: i16x8):\n    v1 = iconst.i32 4\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i16x8_sshr_const([0x0001 0x0002 0x0004 0x0008 0x0010 0x0020 0x0040 0x0080]) == [0 0 0 0 0x1 0x2 0x4 0x8]\n; run: %i16x8_sshr_const([-1 -2 -4 -8 -16 16 0x8000 0x80f3]) == [-1 -1 -1 -1 -1 1 0xf800 0xf80f]\n\nfunction %i32x4_sshr_const(i32x4) -> i32x4 {\nblock0(v0: i32x4):\n    v1 = iconst.i32 4\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i32x4_sshr_const([1 0xfc 0x80000000 0xf83f3000]) == [0 0xf 0xf8000000 0xff83f300]\n\nfunction %i64x2_sshr_const(i64x2) -> i64x2 {\nblock0(v0: i64x2):\n    v1 = iconst.i32 32\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i64x2_sshr_const([0x1 0xf]) == [0 0]\n; run: %i64x2_sshr_const([0x100000000 0]) == [1 0]\n; run: %i64x2_sshr_const([-1 -1]) == [-1 -1]\n\nfunction %i64x2_sshr_const2(i64x2) -> i64x2 {\nblock0(v0: i64x2):\n    v1 = iconst.i32 8\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i64x2_sshr_const2([0x1 0xf]) == [0 0]\n; run: %i64x2_sshr_const2([0x100000000 0]) == [0x1000000 0]\n; run: %i64x2_sshr_const2([-1 -1]) == [-1 -1]\n\nfunction %i64x2_sshr_const3(i64x2) -> i64x2 {\nblock0(v0: i64x2):\n    v1 = iconst.i32 40\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i64x2_sshr_const3([0x1 0xf]) == [0 0]\n; run: %i64x2_sshr_const3([0x10000000000 0]) == [1 0]\n; run: %i64x2_sshr_const3([-1 -1]) == [-1 -1]\n; run: %i64x2_sshr_const3([0x8000000080000000 0x8000000080000000]) == [0xffffffffff800000 0xffffffffff800000]\n\n"], "fixing_code": ["--------------------------------------------------------------------------------\n\n## 14.0.0\n\nUnreleased.\n\n### Added\n\n### Changed\n\n--------------------------------------------------------------------------------\n\n## 13.0.0\n\nUnreleased.\n\n### Added\n\n* Configuration of mach ports vs signals on macOS is now done through a `Config`\n  instead of at compile time.\n  [#6807](https://github.com/bytecodealliance/wasmtime/pull/6807)\n\n* `Engine::detect_precompiled{,_file}` can be used to to determine whether some\n  bytes or a file look like a precompiled module or a component.\n  [#6832](https://github.com/bytecodealliance/wasmtime/pull/6832)\n  [#6937](https://github.com/bytecodealliance/wasmtime/pull/6937)\n\n* A new feature \"wmemcheck\" has been added to enable Valgrind-like detection of\n  use-after-free within a WebAssembly guest module.\n  [#6820](https://github.com/bytecodealliance/wasmtime/pull/6820)\n  [#6856](https://github.com/bytecodealliance/wasmtime/pull/6856)\n\n* The `wasmtime` CLI now supports executing components.\n  [#6836](https://github.com/bytecodealliance/wasmtime/pull/6836)\n\n* Support for WASI preview2's TCP sockets interface has been added.\n  [#6837](https://github.com/bytecodealliance/wasmtime/pull/6837)\n\n* Wasmtime's implementation of the wasi-nn proposal now supports named models.\n  [#6854](https://github.com/bytecodealliance/wasmtime/pull/6854)\n\n* The C API now supports configuring `native_unwind_info`,\n  `dynamic_memory_reserved_for_growth`, `target`, and Cranelift settings.\n  [#6896](https://github.com/bytecodealliance/wasmtime/pull/6896)\n  [#6934](https://github.com/bytecodealliance/wasmtime/pull/6934)\n\n* The `wasmtime` crate now has initial support for component model bindings\n  generation for the WIT `resource` type.\n  [#6886](https://github.com/bytecodealliance/wasmtime/pull/6886)\n\n* Cranelift's RISC-V backend now has a complete implementation of the\n  WebAssembly SIMD proposal. Many thanks to Afonso Bordado for all their\n  contributions!\n  [#6920](https://github.com/bytecodealliance/wasmtime/pull/6920)\n  [#6924](https://github.com/bytecodealliance/wasmtime/pull/6924)\n\n* The `bindgen!` macro in the `wasmtime` crate now supports conditional\n  configuration for which imports should be `async` and which should be\n  synchronous.\n  [#6942](https://github.com/bytecodealliance/wasmtime/pull/6942)\n\n### Changed\n\n* The pooling allocator was significantly refactored and the\n  `PoolingAllocationConfig` has some minor breaking API changes that reflect\n  those changes.\n\n  Previously, the pooling allocator had `count` slots, and each slot had `N`\n  memories and `M` tables. Every allocated instance would reserve those `N`\n  memories and `M` tables regardless whether it actually needed them all or\n  not. This could lead to some waste and over-allocation when a module used less\n  memories and tables than the pooling allocator's configured maximums.\n\n  After the refactors in this release, the pooling allocator doesn't have\n  one-size-fits-all slots anymore. Instead, memories and tables are in separate\n  pools that can be allocated from independently, and we allocate exactly as\n  many memories and tables as are necessary for the instance being allocated.\n\n  To preserve your old configuration with the new methods you can do the following:\n\n  ```rust\n  let mut config = PoolingAllocationConfig::default();\n\n  // If you used to have this old, no-longer-compiling configuration:\n  config.count(count);\n  config.instance_memories(n);\n  config.instance_tables(m);\n\n  // You can use these equivalent settings for the new config methods:\n  config.total_core_instances(count);\n  config.total_stacks(count); // If using the `async` feature.\n  config.total_memories(count * n);\n  config.max_memories_per_module(n);\n  config.total_tables(count * m);\n  config.max_tables_per_module(m);\n  ```\n\n  There are additionally a variety of methods to limit the maximum amount of\n  resources a single core Wasm or component instance can take from the pool:\n\n  * `PoolingAllocationConfig::max_memories_per_module`\n  * `PoolingAllocationConfig::max_tables_per_module`\n  * `PoolingAllocationConfig::max_memories_per_component`\n  * `PoolingAllocationConfig::max_tables_per_component`\n  * `PoolingAllocationConfig::max_core_instances_per_component`\n\n  These methods do not affect the size of the pre-allocated pool.\n  [#6835](https://github.com/bytecodealliance/wasmtime/pull/6835)\n\n* Builder methods for WASI contexts now use `&mut self` instead of `self`.\n  [#6770](https://github.com/bytecodealliance/wasmtime/pull/6770)\n\n* Native unwinding information is now properly disabled when it is configured to\n  be turned off.\n  [#6547](https://github.com/bytecodealliance/wasmtime/pull/6547)\n\n* Wasmtime's minimum supported Rust version (MSRV) is now 1.70.0. Wasmtime's\n  MSRV policy of supporting the last three releases of Rust (N-2) is now\n  additionally documented. More discussion can additionally be found on the PR\n  itself.\n  [#6900](https://github.com/bytecodealliance/wasmtime/pull/6900)\n\n* Wasmtime's support for DWARF debugging information has seen some fixes for\n  previously reported crashes.\n  [#6931](https://github.com/bytecodealliance/wasmtime/pull/6931)\n\n### Removed\n\n* Wasmtime's experimental implementation of wasi-crypto has been removed. More\n  discussion of this change can be found on\n  [#6732](https://github.com/bytecodealliance/wasmtime/pull/6732)\n  and\n  [#6816](https://github.com/bytecodealliance/wasmtime/pull/6816)\n\n* Support for `union` types in the component model has been removed.\n  [#6913](https://github.com/bytecodealliance/wasmtime/pull/6913)\n\n--------------------------------------------------------------------------------\n\n## 12.0.2\n\nReleased 2023-09-14.\n\n### Fixed\n\n* [CVE-2023-41880] - Miscompilation of wasm `i64x2.shr_s` instruction with\n  constant input on x86\\_64\n\n[CVE-2023-41880]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gw5p-q8mj-p7gh\n\n--------------------------------------------------------------------------------\n\n## 12.0.1\n\nReleased 2023-08-24\n\n### Fixed\n\n* Optimized the cranelift compilation on aarch64 for large wasm modules.\n  [#6804](https://github.com/bytecodealliance/wasmtime/pull/6804)\n\n--------------------------------------------------------------------------------\n\n## 12.0.0\n\nReleased 2023-08-21\n\n### Added\n\n* Wasmtime now supports having multiple different versions of itself being\n  linked into the same final executable by mangling some C symbols used by\n  Wasmtime.\n  [#6673](https://github.com/bytecodealliance/wasmtime/pull/6673)\n\n* The `perfmap` profiling option is now supported on any Unix platform instead\n  of just Linux.\n  [#6701](https://github.com/bytecodealliance/wasmtime/pull/6701)\n\n* The `wasmtime` CLI now supports `--env FOO` to inherit the value of the\n  environment variable `FOO` which avoids needing to do `--env FOO=$FOO` for\n  example.\n  [#6746](https://github.com/bytecodealliance/wasmtime/pull/6746)\n\n* Wasmtime now supports component model resources, although support has not yet\n  been added to `bindgen!`.\n  [#6691](https://github.com/bytecodealliance/wasmtime/pull/6691)\n\n* Wasmtime now supports configuration to enable the tail calls proposal.\n  Platform support now also includes AArch64 and RISC-V in addition to the\n  previous x86\\_64 support.\n  [#6723](https://github.com/bytecodealliance/wasmtime/pull/6723)\n  [#6749](https://github.com/bytecodealliance/wasmtime/pull/6749)\n  [#6774](https://github.com/bytecodealliance/wasmtime/pull/6774)\n\n* Wasmtime's implementation of WASI Preview 2 now supports streams/pollables\n  with host objects that are all backed by Rust `async`.\n  [#6556](https://github.com/bytecodealliance/wasmtime/pull/6556)\n\n* Support for core dumps has now been added to the `wasmtime` crate.\n  [#6513](https://github.com/bytecodealliance/wasmtime/pull/6513)\n\n* New `{Module,Component}::resources_required` APIs allow inspecting what will\n  be required when instantiating the module or component.\n  [#6789](https://github.com/bytecodealliance/wasmtime/pull/6789)\n\n### Fixed\n\n* Functions on instances defined through `component::Linker::func_new` are now\n  defined correctly.\n  [#6637](https://github.com/bytecodealliance/wasmtime/pull/6637)\n\n* The `async_stack_size` configuration option is no longer inspected when\n  `async_support` is disabled at runtime.\n  [#6771](https://github.com/bytecodealliance/wasmtime/pull/6771)\n\n* WASI Preview 1 APIs will now trap on misaligned or out-of-bounds pointers\n  instead of returning an error.\n  [#6776](https://github.com/bytecodealliance/wasmtime/pull/6776)\n\n### Changed\n\n* Empty types are no longer allowed in the component model.\n  [#6777](https://github.com/bytecodealliance/wasmtime/pull/6777)\n\n--------------------------------------------------------------------------------\n\n## 11.0.2\n\nReleased 2023-09-14.\n\n### Fixed\n\n* [CVE-2023-41880] - Miscompilation of wasm `i64x2.shr_s` instruction with\n  constant input on x86\\_64\n\n[CVE-2023-41880]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gw5p-q8mj-p7gh\n\n--------------------------------------------------------------------------------\n\n## 11.0.1\n\nReleased 2023-07-24.\n\n### Fixed\n\n* Update some minimum version requirements for Wasmtime's dependencies to fix\n  building Wasmtime with historical versions of these dependencies.\n  [#6758](https://github.com/bytecodealliance/wasmtime/pull/6758)\n\n--------------------------------------------------------------------------------\n\n## 11.0.0\n\nReleased 2023-07-20\n\n### Changed\n\n* The WASI Preview 2 `WasiCtxBuilder` type has been refactored, and `WasiCtx` now has private\n  fields.\n  [#6652](https://github.com/bytecodealliance/wasmtime/pull/6652)\n\n* Component `bindgen!` now generates owned types by default instead of based on\n  how they're used\n  [#6648](https://github.com/bytecodealliance/wasmtime/pull/6648)\n\n* Wasmtime/Cranelift on x86-64 can now execute Wasm-SIMD on baseline SSE2, which\n  all x86-64 processors support (as part of the base x86-64 spec). Previously,\n  SSE4.2 extensions were required. This new work allows Wasm with SIMD\n  extensions to execute on processors produced back to 2003.\n  [#6625](https://github.com/bytecodealliance/wasmtime/pull/6625)\n\n\n### Fixed\n\n* Only export the top-level preview2 module from wasmtime-wasi when the\n  `preview2` feature is enabled.\n  [#6615](https://github.com/bytecodealliance/wasmtime/pull/6615)\n\n\n### Cranelift changes\n\n* Tail call implementation has begun in Cranelift\n  [#6641](https://github.com/bytecodealliance/wasmtime/pull/6641)\n  [#6666](https://github.com/bytecodealliance/wasmtime/pull/6666)\n  [#6650](https://github.com/bytecodealliance/wasmtime/pull/6650)\n  [#6635](https://github.com/bytecodealliance/wasmtime/pull/6635)\n  [#6608](https://github.com/bytecodealliance/wasmtime/pull/6608)\n  [#6586](https://github.com/bytecodealliance/wasmtime/pull/6586)\n\n* Work continues on SIMD support for the riscv64 backend\n  [#6657](https://github.com/bytecodealliance/wasmtime/pull/6657)\n  [#6643](https://github.com/bytecodealliance/wasmtime/pull/6643)\n  [#6601](https://github.com/bytecodealliance/wasmtime/pull/6601)\n  [#6609](https://github.com/bytecodealliance/wasmtime/pull/6609)\n  [#6602](https://github.com/bytecodealliance/wasmtime/pull/6602)\n  [#6598](https://github.com/bytecodealliance/wasmtime/pull/6598)\n  [#6599](https://github.com/bytecodealliance/wasmtime/pull/6599)\n  [#6587](https://github.com/bytecodealliance/wasmtime/pull/6587)\n  [#6568](https://github.com/bytecodealliance/wasmtime/pull/6568)\n  [#6515](https://github.com/bytecodealliance/wasmtime/pull/6515)\n\n* Fix `AuthenticatedRet` when stack bytes are popped in the aarch64 backend\n  [#6634](https://github.com/bytecodealliance/wasmtime/pull/6634)\n\n* The `fcvt_low_from_sint` instruction has been removed, as it its current\n  behavior can be recovered through a combination of `swiden_low` and\n  `fcvt_from_sint`\n  [#6565](https://github.com/bytecodealliance/wasmtime/pull/6565)\n\n--------------------------------------------------------------------------------\n\n## 10.0.2\n\nReleased 2023-09-14.\n\n### Fixed\n\n* [CVE-2023-41880] - Miscompilation of wasm `i64x2.shr_s` instruction with\n  constant input on x86\\_64\n\n[CVE-2023-41880]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gw5p-q8mj-p7gh\n\n--------------------------------------------------------------------------------\n\n## 10.0.1\n\nReleased 2023-06-21\n\n### Fixed\n\n* Only export the top-level preview2 module from wasmtime-wasi when the\n  `preview2` feature is enabled.\n  [#6615](https://github.com/bytecodealliance/wasmtime/pull/6615)\n\n--------------------------------------------------------------------------------\n\n## 10.0.0\n\nReleased 2023-06-20\n\n### Added\n\n* Expose the `Config::static_memory_forced` option through the C api\n  [#6413](https://github.com/bytecodealliance/wasmtime/pull/6413)\n\n* Basic guest-profiler documentation for the book\n  [#6394](https://github.com/bytecodealliance/wasmtime/pull/6394)\n\n* Merge the initial wasi-preview2 implementation\n  [#6391](https://github.com/bytecodealliance/wasmtime/pull/6391)\n\n* The wasi-preview2 component adapter has been pulled into the main wasmtime\n  repository. It is available for the first time as part of this release, but should be\n  treated as as a beta at this time. Patch releases will not be made for bug fixes.\n  [#6374](https://github.com/bytecodealliance/wasmtime/pull/6374)\n\n* A callback invoked when an epoch deadline is reached can now be configured via\n  the C API.\n  [#6359](https://github.com/bytecodealliance/wasmtime/pull/6359)\n\n* PR auto-assignment policies have been documented, to clarify the expectations of\n  reviewers.\n  [#6346](https://github.com/bytecodealliance/wasmtime/pull/6346)\n\n* Support for the function references has been added\n  [#5288](https://github.com/bytecodealliance/wasmtime/pull/5288)\n\n### Changed\n\n* An `epoch_deadline_callback` now returns an `UpdateDeadline` enum to allow\n  optionally yielding to the async executor after the callback runs.\n  [#6464](https://github.com/bytecodealliance/wasmtime/pull/6464)\n\n* The `--profile-guest` flag has now been folded into `--profile=guest`\n  [#6352](https://github.com/bytecodealliance/wasmtime/pull/6352)\n\n* Initializers are no longer tracked in the type information for globals, and\n  instead are provided when creating the global.\n  [#6349](https://github.com/bytecodealliance/wasmtime/pull/6349)\n\n* The \"raw\" representation of `funcref` and `externref` in the embedding API has\n  been updated from a `usize` to a `*mut u8` to be compatible with Rust's\n  proposed strict provenance rules. This change is additionally reflected into\n  the C API as well.\n  [#6338](https://github.com/bytecodealliance/wasmtime/pull/6338)\n\n### Fixed\n\n* Fixed a soundness issue with the component model and async\n  [#6509](https://github.com/bytecodealliance/wasmtime/pull/6509)\n\n* Opening directories with WASI on Windows with `NONBLOCK` in flags has been\n  fixed.\n  [#6348](https://github.com/bytecodealliance/wasmtime/pull/6348)\n\n### Cranelift changes\n\n* Performance improvements in regalloc2 have landed, and compilation time has\n  improved\n  [#6483](https://github.com/bytecodealliance/wasmtime/pull/6483)\n  [#6398](https://github.com/bytecodealliance/wasmtime/pull/6398)\n\n* Renamed `abi::Caller` to `abi::CallSite`\n  [#6414](https://github.com/bytecodealliance/wasmtime/pull/6414)\n\n* Work has begun on SIMD support for the riscv64 backend\n  [#6324](https://github.com/bytecodealliance/wasmtime/pull/6324)\n  [#6366](https://github.com/bytecodealliance/wasmtime/pull/6366)\n  [#6367](https://github.com/bytecodealliance/wasmtime/pull/6367)\n  [#6392](https://github.com/bytecodealliance/wasmtime/pull/6392)\n  [#6397](https://github.com/bytecodealliance/wasmtime/pull/6397)\n  [#6403](https://github.com/bytecodealliance/wasmtime/pull/6403)\n  [#6408](https://github.com/bytecodealliance/wasmtime/pull/6408)\n  [#6419](https://github.com/bytecodealliance/wasmtime/pull/6419)\n  [#6430](https://github.com/bytecodealliance/wasmtime/pull/6430)\n  [#6507](https://github.com/bytecodealliance/wasmtime/pull/6507)\n\n--------------------------------------------------------------------------------\n\n## 9.0.3\n\nReleased 2023-05-31.\n\n### Fixed\n\n* Fix Wasi rights system to work with wasi-testsuite, which exposed a corner case\n  that was missed by the fixes in the 9.0.2 release.\n  [#6479](https://github.com/bytecodealliance/wasmtime/pull/6479)\n\n--------------------------------------------------------------------------------\n\n## 9.0.2\n\nReleased 2023-05-26.\n\n### Fixed\n\n* Fix Wasi rights system to work with wasi-libc. This regression was\n  introduced in the 9.0.0 release.\n  [#6462](https://github.com/bytecodealliance/wasmtime/pull/6462)\n  [#6471](https://github.com/bytecodealliance/wasmtime/pull/6471)\n\n--------------------------------------------------------------------------------\n\n## 9.0.1\n\nReleased 2023-05-22.\n\n### Fixed\n\n* A panic which happened when enabling support for native platform profilers was\n  fixed.\n  [#6435](https://github.com/bytecodealliance/wasmtime/pull/6435)\n\n--------------------------------------------------------------------------------\n\n## 9.0.0\n\nReleased 2023-05-22.\n\n### Added\n\n* Initial integration of the Winch baseline compiler into Wasmtime is\n  implemented. Note that Winch still does not support much of WebAssembly, but\n  intrepid explorers may have an easier time playing around with it now.\n  [#6119](https://github.com/bytecodealliance/wasmtime/pull/6119)\n\n* The `wasmtime` CLI now has flags to limit memory, instances, and tables. For\n  example `--max-memory-size` or `--max-tables`. Additionally it has a new\n  `--trap-on-grow-failure` option to force a trap whenever a `memory.grow` would\n  otherwise fail which can be useful for debugging modules which may be\n  encountering OOM.\n  [#6149](https://github.com/bytecodealliance/wasmtime/pull/6149)\n\n* An initial implementation of the wasi-http proposal was added to Wasmtime in\n  the shape of a new `wasmtime-wasi-http` crate and a\n  `--wasi-modules=experimental-wasi-http` CLI flag.  Note that this is not\n  on-by-default and still in an experimental status at this time.\n  [#5929](https://github.com/bytecodealliance/wasmtime/pull/5929)\n\n* Wasmtime's `bindgen!` macro for components now has `interfaces` and\n  `with` options to configure use of interfaces defined externally in separate\n  crates.\n  [#6160](https://github.com/bytecodealliance/wasmtime/pull/6160)\n  [#6210](https://github.com/bytecodealliance/wasmtime/pull/6210)\n\n* Wasmtime's `bindgen!` macro emits trace events for arguments and results\n  when enabled.\n  [#6209](https://github.com/bytecodealliance/wasmtime/pull/6209)\n\n* A new `Engine::precompile_compatibility_hash` method has been added to assist\n  with hashing artifacts to be compatible with versions of Wasmtime.\n  [#5826](https://github.com/bytecodealliance/wasmtime/pull/5826)\n\n* Wasmtime's C API now has functions for enabling the WebAssembly relaxed-simd\n  proposal.\n  [#6292](https://github.com/bytecodealliance/wasmtime/pull/6292)\n\n* A new `--emit-clif` flag has been added to `wasmtime compile` to see the CLIF\n  corresponding to a WebAssembly module to be used for debugging.\n  [#6307](https://github.com/bytecodealliance/wasmtime/pull/6307)\n\n* Support for an in-process sampling-based profiler has been added to Wasmtime.\n  This is intended to be used in conjunction with epochs to enable relatively\n  simple implementations of profiling a guest module.\n  [#6282](https://github.com/bytecodealliance/wasmtime/pull/6282)\n\n### Changed\n\n* Overhauled the way that Wasmtime calls into Wasm and Wasm calls back out to\n  the host. Instead of chaining together trampolines to convert between calling\n  conventions, we now represent `funcref`s with multiple function pointers, one\n  per calling convention. This paves the way for supporting Wasm tail calls and\n  also results in ~10% speed ups to a variety of function call benchmarks,\n  however there are some slight compiled Wasm module code size regressions\n  (which can be alleviated by disabling optional `.eh_frame`\n  generation). Additionally, in the C API the `wasmtime_func_call_unchecked`\n  function gained one more parameter, which is the capacity of the\n  args-and-results\n  buffer.\n  [#6262](https://github.com/bytecodealliance/wasmtime/pull/6262)\n\n* The `wasmtime compile` command will now default to producing executables for\n  the native host and its CPU features instead of the baseline feature set of\n  the host's architecture.\n  [#6152](https://github.com/bytecodealliance/wasmtime/pull/6152)\n\n* The `ResourceLimiter` trait and its `async` equivalent now support returning\n  errors from growth to force a trap in the wasm module rather than reporting\n  -1 to the wasm module. Note that this is primarily intended for debugging.\n  [#6149](https://github.com/bytecodealliance/wasmtime/pull/6149)\n\n* The non-egraph-based optimization pipeline has been removed from Cranelift,\n  and the corresponding `Config::use_egraphs` option is also removed.\n  [#6167](https://github.com/bytecodealliance/wasmtime/pull/6167)\n\n* Generated types for WIT files now always generates owned types by default.\n  [#6189](https://github.com/bytecodealliance/wasmtime/pull/6189)\n\n* Wasmtime's baseline x86\\_64 CPU features required for SIMD support has been\n  lowered from SSE 4.2 to SSE 4.1.\n  [#6206](https://github.com/bytecodealliance/wasmtime/pull/6206)\n\n* The `fd_allocate` implementation in Wasmtime will now always fail with\n  `ENOTSUP`.\n  [#6217](https://github.com/bytecodealliance/wasmtime/pull/6217)\n\n* The \"rights\" system in WASI has been removed and rights are no longer\n  inspected in the implementation of any WASI functions.\n  [#6265](https://github.com/bytecodealliance/wasmtime/pull/6265)\n\n### Fixed\n\n* WASI can now open directories without `O_DIRECTORY`.\n  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163)\n\n* The `poll_oneoff` function has been fixed when handling non-regular files.\n  [#6258](https://github.com/bytecodealliance/wasmtime/pull/6258)\n\n* The behavior of `path_readlink` on too-small buffers has been fixed to\n  truncate.\n  [#6225](https://github.com/bytecodealliance/wasmtime/pull/6225)\n\n### Cranelift changes\n\n> Note: this section documents changes to Cranelift, a code generator backend\n> that Wasmtime uses. These changes are not always applicable to Wasmtime as a\n> WebAssembly runtime but may be interesting to other projects which embed or\n> use Cranelift.\n\n* New `{u,s}{add,sub,mul}_overflow` instructions have been added.\n  [#5784](https://github.com/bytecodealliance/wasmtime/pull/5784)\n\n* The `iadd_cout` and `isub_bout` instructions have been removed.\n  [#6198](https://github.com/bytecodealliance/wasmtime/pull/6198)\n\n* ISLE now supports binary and octal integer literals.\n  [#6234](https://github.com/bytecodealliance/wasmtime/pull/6234)\n\n* An implementation of SIMD for RISC-V has started.\n  [#6240](https://github.com/bytecodealliance/wasmtime/pull/6240)\n  [#6266](https://github.com/bytecodealliance/wasmtime/pull/6266)\n  [#6268](https://github.com/bytecodealliance/wasmtime/pull/6268)\n\n--------------------------------------------------------------------------------\n\n## 8.0.1\n\nReleased 2023-04-27.\n\n### Changed\n\n* Breaking: Files opened using Wasmtime's implementation of WASI on Windows now\n  cannot be deleted until the file handle is closed. This was already true for\n  open directories. The change was necessary for the bug fix in\n  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163).\n\n### Fixed\n\n* Fixed wasi-common's implementation of the `O_DIRECTORY` flag to match POSIX.\n  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163)\n\n* Undefined Behavior in Rust runtime functions\n  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n\n--------------------------------------------------------------------------------\n\n## 8.0.0\n\nReleased 2023-04-20\n\n### Added\n\n* Allow the MPL-2.0 and OpenSSL licenses in dependencies of wasmtime.\n  [#6136](https://github.com/bytecodealliance/wasmtime/pull/6136)\n\n* Add a bounds-checking optimization for dynamic memories and guard pages.\n  [#6031](https://github.com/bytecodealliance/wasmtime/pull/6031)\n\n* Add support for generating perf maps for simple perf profiling. Additionally,\n  the `--jitdump` and `--vtune` flags have been replaced with a single\n  `--profile` flags that accepts `perfmap`, `jitdump`, and `vtune` arguments.\n  [#6030](https://github.com/bytecodealliance/wasmtime/pull/6030)\n\n* Validate faulting addresses are valid to fault on. As a mitigation to CVEs\n  like `GHSA-ff4p-7xrq-q5r8`, check that the address involved in a fault is one\n  that could be contained in a `Store`, or print a scary message and abort\n  immediately.\n  [#6028](https://github.com/bytecodealliance/wasmtime/pull/6028)\n\n* Add the `--default-values-unknown-imports` option to define unknown function\n  imports as functions that return the default value for their result type.\n  [#6010](https://github.com/bytecodealliance/wasmtime/pull/6010)\n\n* Add `Clone` for `component::InstancePre`.\n  [#5996](https://github.com/bytecodealliance/wasmtime/issues/5996)\n\n* Add `--dynamic-memory-reserved-for-growth` cli flag.\n  [#5980](https://github.com/bytecodealliance/wasmtime/issues/5980)\n\n* Introduce the `wasmtime-explorer` crate for investigating the compilation of\n  wasm modules. This functionality is also exposed via the `wasmtime explore`\n  command.\n  [#5975](https://github.com/bytecodealliance/wasmtime/pull/5975)\n\n* Added support for the Relaxed SIMD proposal.\n  [#5892](https://github.com/bytecodealliance/wasmtime/pull/5892)\n\n* Cranelift gained many new machine-independent optimizations.\n  [#5909](https://github.com/bytecodealliance/wasmtime/pull/5909)\n  [#6032](https://github.com/bytecodealliance/wasmtime/pull/6032)\n  [#6033](https://github.com/bytecodealliance/wasmtime/pull/6033)\n  [#6034](https://github.com/bytecodealliance/wasmtime/pull/6034)\n  [#6037](https://github.com/bytecodealliance/wasmtime/pull/6037)\n  [#6052](https://github.com/bytecodealliance/wasmtime/pull/6052)\n  [#6053](https://github.com/bytecodealliance/wasmtime/pull/6053)\n  [#6072](https://github.com/bytecodealliance/wasmtime/pull/6072)\n  [#6095](https://github.com/bytecodealliance/wasmtime/pull/6095)\n  [#6130](https://github.com/bytecodealliance/wasmtime/pull/6130)\n\n### Changed\n\n* Derive `Copy` on `wasmtime::ValType`.\n  [#6138](https://github.com/bytecodealliance/wasmtime/pull/6138)\n\n* Make `StoreContextMut` accessible in the epoch deadline callback.\n  [#6075](https://github.com/bytecodealliance/wasmtime/pull/6075)\n\n* Take SIGFPE signals for divide traps on `x86_64`.\n  [#6026](https://github.com/bytecodealliance/wasmtime/pull/6026)\n\n* Use more specialized AVX instructions in the `x86_64` backend.\n  [#5924](https://github.com/bytecodealliance/wasmtime/pull/5924)\n  [#5930](https://github.com/bytecodealliance/wasmtime/pull/5930)\n  [#5931](https://github.com/bytecodealliance/wasmtime/pull/5931)\n  [#5982](https://github.com/bytecodealliance/wasmtime/pull/5982)\n  [#5986](https://github.com/bytecodealliance/wasmtime/pull/5986)\n  [#5999](https://github.com/bytecodealliance/wasmtime/pull/5999)\n  [#6023](https://github.com/bytecodealliance/wasmtime/pull/6023)\n  [#6025](https://github.com/bytecodealliance/wasmtime/pull/6025)\n  [#6060](https://github.com/bytecodealliance/wasmtime/pull/6060)\n  [#6086](https://github.com/bytecodealliance/wasmtime/pull/6086)\n  [#6092](https://github.com/bytecodealliance/wasmtime/pull/6092)\n\n* Generate more cache-friendly code for traps.\n  [#6011](https://github.com/bytecodealliance/wasmtime/pull/6011)\n\n### Fixed\n\n* Fixed suboptimal code generation in the `aarch64` backend.\n  [#5976](https://github.com/bytecodealliance/wasmtime/pull/5976)\n  [#5977](https://github.com/bytecodealliance/wasmtime/pull/5977)\n  [#5987](https://github.com/bytecodealliance/wasmtime/pull/5987)\n  [#5997](https://github.com/bytecodealliance/wasmtime/pull/5997)\n  [#6078](https://github.com/bytecodealliance/wasmtime/pull/6078)\n\n* Fixed suboptimal code generation in the `riscv64` backend.\n  [#5854](https://github.com/bytecodealliance/wasmtime/pull/5854)\n  [#5857](https://github.com/bytecodealliance/wasmtime/pull/5857)\n  [#5919](https://github.com/bytecodealliance/wasmtime/pull/5919)\n  [#5951](https://github.com/bytecodealliance/wasmtime/pull/5951)\n  [#5964](https://github.com/bytecodealliance/wasmtime/pull/5964)\n  [#6087](https://github.com/bytecodealliance/wasmtime/pull/6087)\n\n\n--------------------------------------------------------------------------------\n\n## 7.0.1\n\nReleased 2023-04-27.\n\n### Fixed\n\n* Undefined Behavior in Rust runtime functions\n  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n\n--------------------------------------------------------------------------------\n\n## 7.0.0\n\nReleased 2023-03-20\n\n### Added\n\n* An initial implementation of the wasi-threads proposal has been implemented\n  and landed in the Wasmtime CLI. This is available behind a\n  `--wasi-modules experimental-wasi-threads` flag.\n  [#5484](https://github.com/bytecodealliance/wasmtime/pull/5484)\n\n* Support for WASI sockets has been added to the C API.\n  [#5624](https://github.com/bytecodealliance/wasmtime/pull/5624)\n\n* Support for limiting `Store`-based resource usage, such as memory, tables,\n  etc, has been added to the C API.\n  [#5761](https://github.com/bytecodealliance/wasmtime/pull/5761)\n\n* A top level alias of `anyhow::Result` as `wasmtime::Result` has been added to\n  avoid the need to explicitly depend on `anyhow`.\n  [#5853](https://github.com/bytecodealliance/wasmtime/pull/5853)\n\n* Initial support for the WebAssembly core dump format has been added to the CLI\n  with a `--coredump-on-trap` flag.\n  [#5868](https://github.com/bytecodealliance/wasmtime/pull/5868)\n\n### Changed\n\n* The `S` type parameter on component-related methods has been removed.\n  [#5722](https://github.com/bytecodealliance/wasmtime/pull/5722)\n\n* Selection of a `world` to bindgen has been updated to select any `default\n  world` in a WIT package if there is only one.\n  [#5779](https://github.com/bytecodealliance/wasmtime/pull/5779)\n\n* WASI preopened file descriptors can now be closed.\n  [#5828](https://github.com/bytecodealliance/wasmtime/pull/5828)\n\n* The host traits generated by the `bindgen!` macro are now always named `Host`,\n  but are still scoped to each individual module.\n  [#5890](https://github.com/bytecodealliance/wasmtime/pull/5890)\n\n### Fixed\n\n* Components which have `type` imports are now supported better and error/panic\n  in fewer cases.\n  [#5777](https://github.com/bytecodealliance/wasmtime/pull/5777)\n\n* Types referred to by `wasmtime::component::Val` are now reexported under\n  `wasmtime::component`.\n  [#5790](https://github.com/bytecodealliance/wasmtime/pull/5790)\n\n* A panic due to a race between `memory.atomic.{wait32,wait64,notify}`\n  instructions has been fixed.\n  [#5871](https://github.com/bytecodealliance/wasmtime/pull/5871)\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 6.0.2\n\nReleased 2023-04-27.\n\n### Fixed\n\n* Undefined Behavior in Rust runtime functions\n  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n\n--------------------------------------------------------------------------------\n\n## 6.0.1\n\nReleased 2023-03-08.\n\n### Fixed\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 6.0.0\n\nReleased 2023-02-20\n\n### Added\n\n* Wasmtime's built-in cache can now be disabled after being enabled previously.\n  [#5542](https://github.com/bytecodealliance/wasmtime/pull/5542)\n\n* Older x86\\_64 CPUs, without SSE4.1 for example, are now supported when the\n  wasm SIMD proposal is disabled.\n  [#5567](https://github.com/bytecodealliance/wasmtime/pull/5567)\n\n* The Wasmtime C API now has `WASMTIME_VERSION_*` macros defined in its header\n  files.\n  [#5651](https://github.com/bytecodealliance/wasmtime/pull/5651)\n\n* The `wasmtime` CLI executable as part of Wasmtime's precompiled release\n  artifacts now has the `all-arch` feature enabled.\n  [#5657](https://github.com/bytecodealliance/wasmtime/pull/5657)\n\n### Changed\n\n* Equality of `wasmtime::component::Val::Float{32,64}` now considers NaNs as\n  equal for assistance when fuzzing.\n  [#5535](https://github.com/bytecodealliance/wasmtime/pull/5535)\n\n* WIT syntax supported by `wasmtime::component::bindgen!` has been updated in\n  addition to the generated code being updated.\n  [#5565](https://github.com/bytecodealliance/wasmtime/pull/5565)\n  [#5692](https://github.com/bytecodealliance/wasmtime/pull/5692)\n  [#5694](https://github.com/bytecodealliance/wasmtime/pull/5694)\n\n* Cranelift's egraph-based optimization framework is now enabled by default.\n  [#5587](https://github.com/bytecodealliance/wasmtime/pull/5587)\n\n* The old `PoolingAllocationStrategy` type has been removed in favor of a more\n  flexible configuration via a new option\n  `PoolingAllocationConfig::max_unused_warm_slots` which is more flexible and\n  subsumes the previous use cases for each strategy.\n  [#5661](https://github.com/bytecodealliance/wasmtime/pull/5661)\n\n* Creation of `InstancePre` through `Linker::instantiate_pre` no longer requires\n  a `Store` to be provided. Instead a `Store`-related argument is now required\n  on `Linker::define`-style APIs instead.\n  [#5683](https://github.com/bytecodealliance/wasmtime/pull/5683)\n\n### Fixed\n\n* Compilation for FreeBSD on x86\\_64 and AArch64 has been fixed.\n  [#5606](https://github.com/bytecodealliance/wasmtime/pull/5606)\n\n--------------------------------------------------------------------------------\n\n## 5.0.1\n\nReleased 2023-03-08.\n\n### Fixed\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 5.0.0\n\nReleased 2023-01-20\n\n### Added\n\n* A `wasmtime::component::bingen!` macro has been added for generating bindings\n  from `*.wit` files. Note that WIT is still heavily in development so this is\n  more of a preview of what will be as opposed to a finished feature.\n  [#5317](https://github.com/bytecodealliance/wasmtime/pull/5317)\n  [#5397](https://github.com/bytecodealliance/wasmtime/pull/5397)\n\n* The `wasmtime settings` CLI command now has a `--json` option for\n  machine-readable output.\n  [#5411](https://github.com/bytecodealliance/wasmtime/pull/5411)\n\n* Wiggle-generated bindings can now generate the trait for either `&mut self` or\n  `&self`.\n  [#5428](https://github.com/bytecodealliance/wasmtime/pull/5428)\n\n* The `wiggle` crate has more convenience APIs for working with guest data\n  that resides in shared memory.\n  [#5471](https://github.com/bytecodealliance/wasmtime/pull/5471)\n  [#5475](https://github.com/bytecodealliance/wasmtime/pull/5475)\n\n### Changed\n\n* Cranelift's egraph support has been rewritten and updated. This functionality\n  is still gated behind a flag and may become the default in the next release.\n  [#5382](https://github.com/bytecodealliance/wasmtime/pull/5382)\n\n* The implementation of codegen for WebAssembly linear memory has changed\n  significantly internally in Cranelift, moving more responsibility to the\n  Wasmtime embedding rather than Cranelift itself. This should have no\n  user-visible change, however.\n  [#5386](https://github.com/bytecodealliance/wasmtime/pull/5386)\n\n* The `Val::Float32` and `Val::Float64` variants for components now store `f32`\n  and `f64` instead of the bit representation.\n  [#5510](https://github.com/bytecodealliance/wasmtime/pull/5510)\n\n### Fixed\n\n* Handling of DWARF debugging information in components with multiple modules\n  has been fixed to ensure the right info is used for each module.\n  [#5358](https://github.com/bytecodealliance/wasmtime/pull/5358)\n\n--------------------------------------------------------------------------------\n\n## 4.0.1\n\nReleased 2023-03-08.\n\n### Fixed\n\n* Guest-controlled out-of-bounds read/write on x86\\_64\n  [GHSA-ff4p-7xrq-q5r8](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8)\n\n*  Miscompilation of `i8x16.select` with the same inputs on x86\\_64\n  [GHSA-xm67-587q-r2vw](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw)\n\n--------------------------------------------------------------------------------\n\n## 4.0.0\n\nReleased 2022-12-20\n\n### Added\n\n* Dynamic memories are now supported with the pooling instance allocator which\n  can possibly reduce the number of page faults throughout execution at the cost\n  of slower to run code. Page faults are primarily reduced by avoiding\n  releasing memory back to the system, relying on bounds checks to keep the\n  memory inaccessible.\n  [#5208](https://github.com/bytecodealliance/wasmtime/pull/5208)\n\n* The `wiggle` generator now supports function-level control over `tracing`\n  calls.\n  [#5194](https://github.com/bytecodealliance/wasmtime/pull/5194)\n\n* Support has been added to `wiggle` to be compatible with shared memories.\n  [#5225](https://github.com/bytecodealliance/wasmtime/pull/5225)\n  [#5229](https://github.com/bytecodealliance/wasmtime/pull/5229)\n  [#5264](https://github.com/bytecodealliance/wasmtime/pull/5264)\n  [#5268](https://github.com/bytecodealliance/wasmtime/pull/5268)\n  [#5054](https://github.com/bytecodealliance/wasmtime/pull/5054)\n\n* The `wiggle` generator now supports a \"trappable error\" configuration to\n  improve error conversions to guest errors and ensure that no host errors are\n  forgotten or accidentally become traps. The `wasi-common` crate has been\n  updated to use this.\n  [#5276](https://github.com/bytecodealliance/wasmtime/pull/5276)\n  [#5279](https://github.com/bytecodealliance/wasmtime/pull/5279)\n\n* The `memory.atomic.{notify,wait32,wait64}` instructions are now all\n  implemented in Wasmtime.\n  [#5255](https://github.com/bytecodealliance/wasmtime/pull/5255)\n  [#5311](https://github.com/bytecodealliance/wasmtime/pull/5311)\n\n* A `wasm_config_parallel_compilation_set` configuration function has been added\n  to the C API.\n  [#5298](https://github.com/bytecodealliance/wasmtime/pull/5298)\n\n* The `wasmtime` CLI can have its input module piped into it from stdin now.\n  [#5342](https://github.com/bytecodealliance/wasmtime/pull/5342)\n\n* `WasmBacktrace::{capture,force_capture}` methods have been added to\n  programmatically capture a backtrace outside of a trapping context.\n  [#5341](https://github.com/bytecodealliance/wasmtime/pull/5341)\n\n### Changed\n\n* The `S` type parameter on `Func::typed` and `Instance::get_typed_func` has\n  been removed and no longer needs to be specified.\n  [#5275](https://github.com/bytecodealliance/wasmtime/pull/5275)\n\n* The `SharedMemory::data` method now returns `&[UnsafeCell<u8>]` instead of the\n  prior raw slice return.\n  [#5240](https://github.com/bytecodealliance/wasmtime/pull/5240)\n\n* Creation of a `WasiCtx` will no longer unconditionally acquire randomness from\n  the OS, instead using the `rand::thread_rng()` function in Rust which is only\n  periodically reseeded with randomness from the OS.\n  [#5244](https://github.com/bytecodealliance/wasmtime/pull/5244)\n\n* Codegen of dynamically-bounds-checked wasm memory accesses has been improved.\n  [#5190](https://github.com/bytecodealliance/wasmtime/pull/5190)\n\n* Wasmtime will now emit inline stack probes in generated functions for x86\\_64,\n  aarch64, and riscv64 architectures. This guarantees a process abort if an\n  engine was misconfigured to give wasm too much stack instead of optionally\n  allowing wasm to skip the guard page.\n  [#5350](https://github.com/bytecodealliance/wasmtime/pull/5350)\n  [#5353](https://github.com/bytecodealliance/wasmtime/pull/5353)\n\n### Fixed\n\n* Dropping a `Module` will now release kernel resources in-use by the pooling\n  allocator when enabled instead of waiting for a new instance to be\n  re-instantiated into prior slots.\n  [#5321](https://github.com/bytecodealliance/wasmtime/pull/5321)\n\n--------------------------------------------------------------------------------\n\n## 3.0.1\n\nReleased 2022-12-01.\n\n### Fixed\n\n* The instruction cache is now flushed for AArch64 Android.\n  [#5331](https://github.com/bytecodealliance/wasmtime/pull/5331)\n\n* Building for FreeBSD and Android has been fixed.\n  [#5323](https://github.com/bytecodealliance/wasmtime/pull/5323)\n\n--------------------------------------------------------------------------------\n\n## 3.0.0\n\nReleased 2022-11-21\n\n### Added\n\n* New `WasiCtx::{push_file, push_dir}` methods exist for embedders to add their\n  own objects.\n  [#5027](https://github.com/bytecodealliance/wasmtime/pull/5027)\n\n* Wasmtime's `component-model` support now supports `async` host functions and\n  embedding in the same manner as core wasm.\n  [#5055](https://github.com/bytecodealliance/wasmtime/pull/5055)\n\n* The `wasmtime` CLI executable now supports a `--max-wasm-stack` flag.\n  [#5156](https://github.com/bytecodealliance/wasmtime/pull/5156)\n\n* AOT compilation support has been implemented for components (aka the\n  `component-model` feature of the Wasmtime crate).\n  [#5160](https://github.com/bytecodealliance/wasmtime/pull/5160)\n\n* A new `wasi_config_set_stdin_bytes` function is available in the C API to set\n  the stdin of a WASI-using module from an in-memory slice.\n  [#5179](https://github.com/bytecodealliance/wasmtime/pull/5179)\n\n* When using the pooling allocator there are now options to reset memory with\n  `memset` instead of `madvisev` on Linux to keep pages resident in memory to\n  reduce page faults when reusing linear memory slots.\n  [#5207](https://github.com/bytecodealliance/wasmtime/pull/5207)\n\n### Changed\n\n* Consuming 0 fuel with 0 fuel left is now considered to succeed. Additionally a\n  store may not consume its last unit of fuel.\n  [#5013](https://github.com/bytecodealliance/wasmtime/pull/5013)\n\n* A number of variants in the `wasi_common::ErrorKind` enum have been removed.\n  [#5015](https://github.com/bytecodealliance/wasmtime/pull/5015)\n\n* Methods on `WasiDir` now error-by-default instead of requiring a definition by\n  default.\n  [#5019](https://github.com/bytecodealliance/wasmtime/pull/5019)\n\n* Bindings generated by the `wiggle` crate now always depend on the `wasmtime`\n  crate meaning crates like `wasi-common` no longer compile for platforms such\n  as `wasm32-unknown-emscripten`.\n  [#5137](https://github.com/bytecodealliance/wasmtime/pull/5137)\n\n* Error handling in the `wasmtime` crate's API has been changed to primarily\n  work with `anyhow::Error` for custom errors. The `Trap` type has been replaced\n  with a simple `enum Trap { ... }` and backtrace information is now stored as a\n  `WasmBacktrace` type inserted as context into an `anyhow::Error`.\n  Host-functions are expected to return `anyhow::Result<T>` instead of the prior\n  `Trap` error return from before. Additionally the old `Trap::i32_exit`\n  constructor is now a concrete `wasi_commont::I32Exit` type which can be tested\n  for with a `downcast_ref` on the error returned from Wasmtime.\n  [#5149](https://github.com/bytecodealliance/wasmtime/pull/5149)\n\n* Configuration of the pooling allocator is now done through a builder-style\n  `PoolingAllocationConfig` API instead of the prior enum-variant API.\n  [#5205](https://github.com/bytecodealliance/wasmtime/pull/5205)\n\n### Fixed\n\n* The instruction cache is now properly flushed for AArch64 on Windows.\n  [#4997](https://github.com/bytecodealliance/wasmtime/pull/4997)\n\n* Backtrace capturing with many sequences of wasm->host calls on the stack no\n  longer exhibit quadratic capturing behavior.\n  [#5049](https://github.com/bytecodealliance/wasmtime/pull/5049)\n\n--------------------------------------------------------------------------------\n\n## 2.0.2\n\nReleased 2022-11-10.\n\n### Fixed\n\n* [CVE-2022-39392] - modules may perform out-of-bounds reads/writes when the\n  pooling allocator was configured with `memory_pages: 0`.\n\n* [CVE-2022-39393] - data can be leaked between instances when using the pooling\n  allocator.\n\n* [CVE-2022-39394] - An incorrect Rust signature for the C API\n  `wasmtime_trap_code` function could lead to an out-of-bounds write of three\n  zero bytes.\n\n[CVE-2022-39392]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-44mr-8vmm-wjhg\n[CVE-2022-39393]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf\n[CVE-2022-39394]: https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-h84q-m8rr-3v9q\n\n--------------------------------------------------------------------------------\n\n## 2.0.1\n\nReleased 2022-10-27.\n\n### Fixed\n\n* A compilation error when building only the `wasmtime` crate on Windows with\n  only the default features enabled has been fixed.\n  [#5134](https://github.com/bytecodealliance/wasmtime/pull/5134)\n\n### Changed\n\n* The `rayon` dependency added to `cranelift-isle` in 2.0.0 has been removed to\n  improve the compile time of the `cranelift-codegen` crate.\n  [#5101](https://github.com/bytecodealliance/wasmtime/pull/5101)\n\n--------------------------------------------------------------------------------\n\n## 2.0.0\n\nReleased 2022-10-20\n\n### Added\n\n* Cranelift has gained support for forward-edge CFI on the AArch64 backend.\n  [#3693](https://github.com/bytecodealliance/wasmtime/pull/3693)\n\n* A `--disable-parallel-compilation` CLI flag is now implemented for `wasmtime`.\n  [#4911](https://github.com/bytecodealliance/wasmtime/pull/4911)\n\n* [Tier 3] support has been added for for RISC-V 64 with a new backend in\n  Cranelift for this architecture.\n  [#4271](https://github.com/bytecodealliance/wasmtime/pull/4271)\n\n* Basic [tier 3] support for Windows ARM64 has been added but features such as\n  traps don't work at this time.\n  [#4990](https://github.com/bytecodealliance/wasmtime/pull/4990)\n\n### Changed\n\n* The implementation of the `random_get` function in `wasi-common` is now faster\n  by using a userspace CSPRNG rather than the OS for randomness.\n  [#4917](https://github.com/bytecodealliance/wasmtime/pull/4917)\n\n* The AArch64 backend has completed its transition to ISLE.\n  [#4851](https://github.com/bytecodealliance/wasmtime/pull/4851)\n  [#4866](https://github.com/bytecodealliance/wasmtime/pull/4866)\n  [#4898](https://github.com/bytecodealliance/wasmtime/pull/4898)\n  [#4884](https://github.com/bytecodealliance/wasmtime/pull/4884)\n  [#4820](https://github.com/bytecodealliance/wasmtime/pull/4820)\n  [#4913](https://github.com/bytecodealliance/wasmtime/pull/4913)\n  [#4942](https://github.com/bytecodealliance/wasmtime/pull/4942)\n  [#4943](https://github.com/bytecodealliance/wasmtime/pull/4943)\n\n* The size of the `sigaltstack` allocated per-thread for signal handling has\n  been increased from 16k to 64k.\n  [#4964](https://github.com/bytecodealliance/wasmtime/pull/4964)\n\n\n[Tier 3]: https://docs.wasmtime.dev/stability-tiers.html\n\n--------------------------------------------------------------------------------\n\n## 1.0.2\n\nReleased 2022-11-10.\n\n### Fixed\n\n* [CVE-2022-39392] - modules may perform out-of-bounds reads/writes when the\n  pooling allocator was configured with `memory_pages: 0`.\n\n* [CVE-2022-39393] - data can be leaked between instances when using the pooling\n  allocator.\n\n* [CVE-2022-39394] - An incorrect Rust signature for the C API\n  `wasmtime_trap_code` function could lead to an out-of-bounds write of three\n  zero bytes.\n\n--------------------------------------------------------------------------------\n\n## 1.0.1\n\nReleased 2022-09-26\n\nThis is a patch release that incorporates a fix for a miscompilation of an\natomic-CAS operator on aarch64. The instruction is not usable from Wasmtime\nwith default settings, but may be used if the Wasm atomics extension is\nenabled. The bug may also be reachable via other uses of Cranelift. Thanks to\n@bjorn3 for reporting and debugging this issue!\n\n### Fixed\n\n* Fixed a miscompilation of `atomic_cas` on aarch64. The output register was\n  swapped with a temporary register in the register-allocator constraints.\n  [#4959](https://github.com/bytecodealliance/wasmtime/pull/4959)\n  [#4960](https://github.com/bytecodealliance/wasmtime/pull/4960)\n\n--------------------------------------------------------------------------------\n\n## 1.0.0\n\nReleased 2022-09-20\n\nThis release marks the official 1.0 release of Wasmtime and represents the\nculmination of the work amongst over 300 contributors. Wasmtime has been\nbattle-tested in production through multiple embeddings for quite some time now\nand we're confident in releasing a 1.0 version to signify the stability and\nquality of the Wasmtime engine.\n\nMore information about Wasmtime's 1.0 release is on the [Bytecode Alliance's\nblog][ba-blog] with separate posts on [Wasmtime's performance\nfeatures][ba-perf], [Wasmtime's security story][ba-security], and [the 1.0\nrelease announcement][ba-1.0].\n\nAs a reminder the 2.0 release of Wasmtime is scheduled for one month from now on\nOctober 20th. For more information see the [RFC on Wasmtime's 1.0\nrelease][rfc-1.0].\n\n[ba-blog]: https://bytecodealliance.org/articles/\n[ba-perf]: https://bytecodealliance.org/articles/wasmtime-10-performance\n[ba-security]: https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime\n[ba-1.0]: https://bytecodealliance.org/articles/wasmtime-1-0-fast-safe-and-now-production-ready.md\n[rfc-1.0]: https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-one-dot-oh.md\n\n### Added\n\n* An incremental compilation cache for Cranelift has been added which can be\n  enabled with `Config::enable_incremental_compilation`, and this option is\n  disabled by default for now. The incremental compilation cache has been\n  measured to improve compile times for cold uncached modules as well due to\n  some wasm modules having similar-enough functions internally.\n  [#4551](https://github.com/bytecodealliance/wasmtime/pull/4551)\n\n* Source tarballs are now available as part of Wasmtime's release artifacts.\n  [#4294](https://github.com/bytecodealliance/wasmtime/pull/4294)\n\n* WASI APIs that specify the REALTIME clock are now supported.\n  [#4777](https://github.com/bytecodealliance/wasmtime/pull/4777)\n\n* WASI's socket functions are now fully implemented.\n  [#4776](https://github.com/bytecodealliance/wasmtime/pull/4776)\n\n* The native call stack for async-executed wasm functions are no longer\n  automatically reset to zero after the stack is returned to the pool when using\n  the pooling allocator. A `Config::async_stack_zeroing` option has been added\n  to restore the old behavior of zero-on-return-to-pool.\n  [#4813](https://github.com/bytecodealliance/wasmtime/pull/4813)\n\n* Inline stack probing has been implemented for the Cranelift x64 backend.\n  [#4747](https://github.com/bytecodealliance/wasmtime/pull/4747)\n\n### Changed\n\n* Generating of native unwind information has moved from a\n  `Config::wasm_backtrace` option to a new `Config::native_unwind_info` option\n  and is enabled by default.\n  [#4643](https://github.com/bytecodealliance/wasmtime/pull/4643)\n\n* The `memory-init-cow` feature is now enabled by default in the C API.\n  [#4690](https://github.com/bytecodealliance/wasmtime/pull/4690)\n\n* Back-edge CFI is now enabled by default on AArch64 macOS.\n  [#4720](https://github.com/bytecodealliance/wasmtime/pull/4720)\n\n* WASI calls will no longer return NOTCAPABLE in preparation for the removal of\n  the rights system from WASI.\n  [#4666](https://github.com/bytecodealliance/wasmtime/pull/4666)\n\n### Internal\n\nThis section of the release notes shouldn't affect external users since no\npublic-facing APIs are affected, but serves as a place to document larger\nchanges internally within Wasmtime.\n\n* Differential fuzzing has been refactored and improved into one fuzzing target\n  which can execute against any of Wasmtime itself (configured differently),\n  wasmi, V8, or the spec interpreter. Fuzzing now executes each exported\n  function with fuzz-generated inputs and the contents of all of memory and each\n  exported global is compared after each execution. Additionally more\n  interesting shapes of modules are also possible to generate.\n  [#4515](https://github.com/bytecodealliance/wasmtime/pull/4515)\n  [#4735](https://github.com/bytecodealliance/wasmtime/pull/4735)\n  [#4737](https://github.com/bytecodealliance/wasmtime/pull/4737)\n  [#4739](https://github.com/bytecodealliance/wasmtime/pull/4739)\n  [#4774](https://github.com/bytecodealliance/wasmtime/pull/4774)\n  [#4773](https://github.com/bytecodealliance/wasmtime/pull/4773)\n  [#4845](https://github.com/bytecodealliance/wasmtime/pull/4845)\n  [#4672](https://github.com/bytecodealliance/wasmtime/pull/4672)\n  [#4674](https://github.com/bytecodealliance/wasmtime/pull/4674)\n\n* The x64 backend for Cranelift has been fully migrated to ISLE.\n  [#4619](https://github.com/bytecodealliance/wasmtime/pull/4619)\n  [#4625](https://github.com/bytecodealliance/wasmtime/pull/4625)\n  [#4645](https://github.com/bytecodealliance/wasmtime/pull/4645)\n  [#4650](https://github.com/bytecodealliance/wasmtime/pull/4650)\n  [#4684](https://github.com/bytecodealliance/wasmtime/pull/4684)\n  [#4704](https://github.com/bytecodealliance/wasmtime/pull/4704)\n  [#4718](https://github.com/bytecodealliance/wasmtime/pull/4718)\n  [#4726](https://github.com/bytecodealliance/wasmtime/pull/4726)\n  [#4722](https://github.com/bytecodealliance/wasmtime/pull/4722)\n  [#4729](https://github.com/bytecodealliance/wasmtime/pull/4729)\n  [#4730](https://github.com/bytecodealliance/wasmtime/pull/4730)\n  [#4741](https://github.com/bytecodealliance/wasmtime/pull/4741)\n  [#4763](https://github.com/bytecodealliance/wasmtime/pull/4763)\n  [#4772](https://github.com/bytecodealliance/wasmtime/pull/4772)\n  [#4780](https://github.com/bytecodealliance/wasmtime/pull/4780)\n  [#4787](https://github.com/bytecodealliance/wasmtime/pull/4787)\n  [#4793](https://github.com/bytecodealliance/wasmtime/pull/4793)\n  [#4809](https://github.com/bytecodealliance/wasmtime/pull/4809)\n\n* The AArch64 backend for Cranelift has seen significant progress in being\n  ported to ISLE.\n  [#4608](https://github.com/bytecodealliance/wasmtime/pull/4608)\n  [#4639](https://github.com/bytecodealliance/wasmtime/pull/4639)\n  [#4634](https://github.com/bytecodealliance/wasmtime/pull/4634)\n  [#4748](https://github.com/bytecodealliance/wasmtime/pull/4748)\n  [#4750](https://github.com/bytecodealliance/wasmtime/pull/4750)\n  [#4751](https://github.com/bytecodealliance/wasmtime/pull/4751)\n  [#4753](https://github.com/bytecodealliance/wasmtime/pull/4753)\n  [#4788](https://github.com/bytecodealliance/wasmtime/pull/4788)\n  [#4796](https://github.com/bytecodealliance/wasmtime/pull/4796)\n  [#4785](https://github.com/bytecodealliance/wasmtime/pull/4785)\n  [#4819](https://github.com/bytecodealliance/wasmtime/pull/4819)\n  [#4821](https://github.com/bytecodealliance/wasmtime/pull/4821)\n  [#4832](https://github.com/bytecodealliance/wasmtime/pull/4832)\n\n* The s390x backend has seen improvements and additions to fully support the\n  Cranelift backend for rustc.\n  [#4682](https://github.com/bytecodealliance/wasmtime/pull/4682)\n  [#4702](https://github.com/bytecodealliance/wasmtime/pull/4702)\n  [#4616](https://github.com/bytecodealliance/wasmtime/pull/4616)\n  [#4680](https://github.com/bytecodealliance/wasmtime/pull/4680)\n\n* Significant improvements have been made to Cranelift-based fuzzing with more\n  supported features and more instructions being fuzzed.\n  [#4589](https://github.com/bytecodealliance/wasmtime/pull/4589)\n  [#4591](https://github.com/bytecodealliance/wasmtime/pull/4591)\n  [#4665](https://github.com/bytecodealliance/wasmtime/pull/4665)\n  [#4670](https://github.com/bytecodealliance/wasmtime/pull/4670)\n  [#4590](https://github.com/bytecodealliance/wasmtime/pull/4590)\n  [#4375](https://github.com/bytecodealliance/wasmtime/pull/4375)\n  [#4519](https://github.com/bytecodealliance/wasmtime/pull/4519)\n  [#4696](https://github.com/bytecodealliance/wasmtime/pull/4696)\n  [#4700](https://github.com/bytecodealliance/wasmtime/pull/4700)\n  [#4703](https://github.com/bytecodealliance/wasmtime/pull/4703)\n  [#4602](https://github.com/bytecodealliance/wasmtime/pull/4602)\n  [#4713](https://github.com/bytecodealliance/wasmtime/pull/4713)\n  [#4738](https://github.com/bytecodealliance/wasmtime/pull/4738)\n  [#4667](https://github.com/bytecodealliance/wasmtime/pull/4667)\n  [#4782](https://github.com/bytecodealliance/wasmtime/pull/4782)\n  [#4783](https://github.com/bytecodealliance/wasmtime/pull/4783)\n  [#4800](https://github.com/bytecodealliance/wasmtime/pull/4800)\n\n* Optimization work on cranelift has continued across various dimensions for\n  some modest compile-time improvements.\n  [#4621](https://github.com/bytecodealliance/wasmtime/pull/4621)\n  [#4701](https://github.com/bytecodealliance/wasmtime/pull/4701)\n  [#4697](https://github.com/bytecodealliance/wasmtime/pull/4697)\n  [#4711](https://github.com/bytecodealliance/wasmtime/pull/4711)\n  [#4710](https://github.com/bytecodealliance/wasmtime/pull/4710)\n  [#4829](https://github.com/bytecodealliance/wasmtime/pull/4829)\n\n--------------------------------------------------------------------------------\n\n## 0.40.0\n\nReleased 2022-08-20\n\nThis was a relatively quiet release in terms of user-facing features where most\nof the work was around the internals of Wasmtime and Cranelift. Improvements\ninternally have been made along the lines of:\n\n* Many more instructions are now implemented with ISLE instead of handwritten\n  lowerings.\n* Many improvements to the cranelift-based fuzzing.\n* Many platform improvements for s390x including full SIMD support, running\n  `rustc_codegen_cranelift` with features like `i128`, supporting more\n  ABIs, etc.\n* Much more of the component model has been implemented and is now fuzzed.\n\nFinally this release is currently scheduled to be the last `0.*` release of\nWasmtime. The upcoming release of Wasmtime on September 20 is planned to be\nWasmtime's 1.0 release. More information about what 1.0 means for Wasmtime is\navailable in the [1.0 RFC]\n\n[1.0 RFC]: https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-one-dot-oh.md\n\n### Added\n\n* Stack walking has been reimplemented with frame pointers rather than with\n  native unwind information. This means that backtraces are feasible to capture\n  in performance-critical environments and in general stack walking is much\n  faster than before.\n  [#4431](https://github.com/bytecodealliance/wasmtime/pull/4431)\n\n* The WebAssembly `simd` proposal is now fully implemented for the s390x\n  backend.\n  [#4427](https://github.com/bytecodealliance/wasmtime/pull/4427)\n\n* Support for AArch64 has been added in the experimental native debuginfo\n  support that Wasmtime has.\n  [#4468](https://github.com/bytecodealliance/wasmtime/pull/4468)\n\n* Support building the C API of Wasmtime with CMake has been added.\n  [#4369](https://github.com/bytecodealliance/wasmtime/pull/4369)\n\n* Clarification was added to Wasmtime's documentation about \"tiers of support\"\n  for various features.\n  [#4479](https://github.com/bytecodealliance/wasmtime/pull/4479)\n\n### Fixed\n\n* Support for `filestat_get` has been improved for stdio streams in WASI.\n  [#4531](https://github.com/bytecodealliance/wasmtime/pull/4531)\n\n* Enabling the `vtune` feature no longer breaks builds on AArch64.\n  [#4533](https://github.com/bytecodealliance/wasmtime/pull/4533)\n\n--------------------------------------------------------------------------------\n\n## 0.39.1\n\nReleased 2022-07-20.\n\n### Fixed\n\n* An s390x-specific codegen bug in addition to a mistake introduced in the fix\n  of CVE-2022-31146 were fixed.\n  [#4490](https://github.com/bytecodealliance/wasmtime/pull/4490)\n\n--------------------------------------------------------------------------------\n\n## 0.39.0\n\nReleased 2022-07-20\n\n### Added\n\n* Initial support for shared memories and the `threads` WebAssembly proposal\n  has been added. Note that this feature is still experimental and not ready\n  for production use yet.\n  [#4187](https://github.com/bytecodealliance/wasmtime/pull/4187)\n\n* A new `Linker::define_unknown_imports_as_traps` method and\n  `--trap-unknown-imports` CLI flag have been added to conveniently support\n  running modules with imports that aren't dynamically called at runtime.\n  [#4312](https://github.com/bytecodealliance/wasmtime/pull/4312)\n\n* The VTune profiling strategy can now be selected through the C API.\n  [#4316](https://github.com/bytecodealliance/wasmtime/pull/4316)\n\n### Changed\n\n* Some methods on the `Config` structure now return `&mut Self` instead of\n  `Result<&mut Self>` since the validation is deferred until `Engine::new`:\n  `profiler`, `cranelift_flag_enable`, `cranelift_flag_set`, `max_wasm_stack`,\n  `async_stack_size`, and `strategy`.\n  [#4252](https://github.com/bytecodealliance/wasmtime/pull/4252)\n  [#4262](https://github.com/bytecodealliance/wasmtime/pull/4262)\n\n* Parallel compilation of WebAssembly modules is now enabled in the C API by\n  default.\n  [#4270](https://github.com/bytecodealliance/wasmtime/pull/4270)\n\n* Implicit Cargo features of the `wasmtime` introduced through `optional`\n  dependencies may have been removed since namespaced features are now used.\n  It's recommended to only used the set of named `[features]` for Wasmtime.\n  [#4293](https://github.com/bytecodealliance/wasmtime/pull/4293)\n\n* Register allocation has fixed a few issues related to excessive memory usage\n  at compile time.\n  [#4324](https://github.com/bytecodealliance/wasmtime/pull/4324)\n\n### Fixed\n\n* A refactor of `Config` was made to fix an issue that the order of calls to `Config`\n  matters now, which may lead to unexpected behavior.\n  [#4252](https://github.com/bytecodealliance/wasmtime/pull/4252)\n  [#4262](https://github.com/bytecodealliance/wasmtime/pull/4262)\n\n* Wasmtime has been fixed to work on SSE2-only x86\\_64 platforms when the\n  `simd` feature is disabled in `Config`.\n  [#4231](https://github.com/bytecodealliance/wasmtime/pull/4231)\n\n* Generation of platform-specific unwinding information is disabled if\n  `wasm_backtrace` and `wasm_reference_types` are both disabled.\n  [#4351](https://github.com/bytecodealliance/wasmtime/pull/4351)\n\n--------------------------------------------------------------------------------\n\n## 0.38.3\n\nReleased 2022-07-20.\n\n### Fixed.\n\n* An s390x-specific codegen bug in addition to a mistake introduced in the fix\n  of CVE-2022-31146 were fixed.\n  [#4491](https://github.com/bytecodealliance/wasmtime/pull/4491)\n\n--------------------------------------------------------------------------------\n\n## 0.38.2\n\nReleased 2022-07-20.\n\n### Fixed.\n\n* A miscompilation when handling constant divisors on AArch64 has been fixed.\n  [CVE-2022-31169](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7f6x-jwh5-m9r4)\n\n* A use-after-free possible with accidentally missing stack maps has been fixed.\n  [CVE-2022-31146](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-5fhj-g3p3-pq9g)\n\n--------------------------------------------------------------------------------\n\n## 0.38.1\n\nReleased 2022-06-27.\n\n### Fixed.\n\n* A register allocator bug was fixed that could affect direct users of\n  Cranelift who use struct-return (`sret`) arguments. The bug had to do with\n  the handling of physical register constraints in the function prologue. No\n  impact should be possible for users of Cranelift via the Wasm frontend,\n  including Wasmtime.\n  [regalloc2#60](https://github.com/bytecodealliance/regalloc2/pull/60)\n  [#4333](https://github.com/bytecodealliance/wasmtime/pull/4333)\n\n* Lowering bugs for the `i8x16.swizzle` and `select`-with-`v128`-inputs\n  instructions were fixed for the x86\\_64 code generator. Note that aarch64 and\n  s390x are unaffected.\n  [#4334](https://github.com/bytecodealliance/wasmtime/pull/4334)\n\n* A bug in the 8-bit lowering of integer division on x86-64 was fixed in\n  Cranelift that could cause a register allocator panic due to an undefined\n  value in a register. (The divide instruction does not take a register `rdx`\n  as a source when 8 bits but the metadata incorrectly claimed it did.) No\n  impact on Wasm/Wasmtime users, and impact on direct Cranelift embedders\n  limited to compilation panics.\n  [#4332](https://github.com/bytecodealliance/wasmtime/pull/4332)\n\n--------------------------------------------------------------------------------\n\n## 0.38.0\n\nReleased 2022-06-21\n\n### Added\n\n* Enabling or disabling NaN canonicalization in generated code is now exposed\n  through the C API.\n  [#4154](https://github.com/bytecodealliance/wasmtime/pull/4154)\n\n* A user-defined callback can now be invoked when an epoch interruption happens\n  via the `Store::epoch_deadline_callback` API.\n  [#4152](https://github.com/bytecodealliance/wasmtime/pull/4152)\n\n* Basic alias analysis with redundant-load elimintation and store-to-load\n  forwarding optimizations has been added to Cranelift.\n  [#4163](https://github.com/bytecodealliance/wasmtime/pull/4163)\n\n### Changed\n\n* Traps originating from epoch-based interruption are now exposed as\n  `TrapCode::Interrupt`.\n  [#4105](https://github.com/bytecodealliance/wasmtime/pull/4105)\n\n* Binary builds for AArch64 now require glibc 2.17 and for s390x require glibc\n  2.16. Previously glibc 2.28 was required.\n  [#4171](https://github.com/bytecodealliance/wasmtime/pull/4171)\n\n* The `wasmtime::ValRaw` now has all of its fields listed as private and instead\n  constructors/accessors are provided for getting at the internal data.\n  [#4186](https://github.com/bytecodealliance/wasmtime/pull/4186)\n\n* The `wasm-backtrace` Cargo feature has been removed in favor of a\n  `Config::wasm_backtrace` runtime configuration option. Additionally backtraces\n  are now only captured when an embedder-generated trap actually reaches a\n  WebAssembly call stack.\n  [#4183](https://github.com/bytecodealliance/wasmtime/pull/4183)\n\n* Usage of `*_unchecked` APIs for `Func` in the `wasmtime` crate and C API now\n  take a `usize` parameter indicating the number of `ValRaw` values behind\n  the associated pointer.\n  [#4192](https://github.com/bytecodealliance/wasmtime/pull/4192)\n\n### Fixed\n\n* An improvement was made to the spill-slot allocation in code generation to fix\n  an issue where some stack slots accidentally weren't reused. This issue was\n  introduced with the landing of regalloc2 in 0.37.0 and may have resulted in\n  larger-than-intended increases in stack frame sizes.\n  [#4222](https://github.com/bytecodealliance/wasmtime/pull/4222)\n\n--------------------------------------------------------------------------------\n\n## 0.37.0\n\nReleased 2022-05-20\n\n### Added\n\n* Updated Cranelift to use regalloc2, a new register allocator. This should\n  result in ~20% faster compile times, and for programs that suffered from\n  register-allocation pressure before, up to ~20% faster generated code.\n  [#3989](https://github.com/bytecodealliance/wasmtime/pull/3989)\n\n* Pre-built binaries for macOS M1 machines are now available as release\n  artifacts.\n  [#3983](https://github.com/bytecodealliance/wasmtime/pull/3983)\n\n* Copy-on-write images of memory can now be manually initialized for a `Module`\n  with an explicit method call, but it is still not required to call this method\n  and will automatically otherwise happen on the first instantiation.\n  [#3964](https://github.com/bytecodealliance/wasmtime/pull/3964)\n\n### Fixed\n\n* Using `InstancePre::instantiate` or `Linker::instantiate` will now panic as\n  intended when used with an async-configured `Store`.\n  [#3972](https://github.com/bytecodealliance/wasmtime/pull/3972)\n\n### Changed\n\n* The unsafe `ValRaw` type in the `wasmtime` crate now always stores its values\n  in little-endian format instead of the prior native-endian format. Users of\n  `ValRaw` are recommended to audit their existing code for usage to continue\n  working on big-endian platforms.\n  [#4035](https://github.com/bytecodealliance/wasmtime/pull/4035)\n\n### Removed\n\n* Support for `Config::paged_memory_initialization` and the `uffd` crate feature\n  have been removed from the `wasmtime` crate. Users should migrate to using\n  `Config::memory_init_cow` which is more portable and faster at this point.\n  [#4040](https://github.com/bytecodealliance/wasmtime/pull/4040)\n\n--------------------------------------------------------------------------------\n\n## 0.36.0\n\nReleased 2022-04-20\n\n### Added\n\n* Support for epoch-based interruption has been added to the C API.\n  [#3925](https://github.com/bytecodealliance/wasmtime/pull/3925)\n\n* Support for disabling libunwind-based backtraces of WebAssembly code at\n  compile time has been added.\n  [#3932](https://github.com/bytecodealliance/wasmtime/pull/3932)\n\n* Async support for call hooks has been added to optionally execute \"blocking\"\n  work whenever a wasm module is entered or exited relative to the host.\n  [#3876](https://github.com/bytecodealliance/wasmtime/pull/3876)\n\n### Fixed\n\n* Loading a `Module` will now check, at runtime, that the compilation settings\n  enabled in a `Config` are compatible with the native host. For example this\n  ensures that if avx2 is enabled that the host actually has avx2 support.\n  [#3899](https://github.com/bytecodealliance/wasmtime/pull/3899)\n\n### Removed\n\n* Support for `Config::interruptable` and `InterruptHandle` has been removed\n  from the `wasmtime` crate. Users should migrate to using epoch-based\n  interruption instead.\n  [#3925](https://github.com/bytecodealliance/wasmtime/pull/3925)\n\n* The module linking implementation of Wasmtime has been removed to make room\n  for the upcoming support for the component model.\n  [#3958](https://github.com/bytecodealliance/wasmtime/pull/3958)\n\n--------------------------------------------------------------------------------\n\n## 0.35.3\n\nReleased 2022-04-11.\n\n### Fixed\n\n* Backported a bugfix for an instruction lowering issue that could cause a\n  regalloc panic due to an undefined register in some cases. No miscompilation\n  was ever possible, but panics would result in a compilation failure.\n  [#4012](https://github.com/bytecodealliance/wasmtime/pull/4012)\n\n--------------------------------------------------------------------------------\n\n## 0.35.2\n\nReleased 2022-03-31.\n\n### Security Fixes\n\n* [CVE-2022-24791](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2):\n  Fixed a use after free with `externref`s and epoch interruption.\n\n## 0.35.1\n\nReleased 2022-03-09.\n\n### Fixed\n\n* Fixed a bug in the x86-64 lowering of the `uextend` opcode for narrow (`i8`,\n  `i16`) integer sources when the value is produced by one of several\n  arithmetic instructions.\n  [#3906](https://github.com/bytecodealliance/wasmtime/pull/3906)\n\n## 0.35.0\n\nReleased 2022-03-07.\n\n### Added\n\n* The `wasmtime_wasi::add_to_linker` function now allows providing\n  a context object of a custom type instead of `wasmtime_wasi::WasiCtx`,\n  as long as that type implements the required WASI snapshot traits.\n  This allows, for example, wrapping `WasiCtx` into a struct and providing\n  custom implementations for those traits to override the default behaviour.\n\n### Changed\n\n* WebAssembly tables of `funcref` values are now lazily initialized which can,\n  in some cases, greatly speed up instantiation of a module.\n  [#3733](https://github.com/bytecodealliance/wasmtime/pull/3733)\n\n* The `memfd` feature in 0.34.0, now renamed to `memory-init-cow`, has been\n  enabled by default. This means that, where applicable, WebAssembly linear\n  memories are now initialized with copy-on-write mappings. Support from this\n  has been expanded from Linux-only to include macOS and other Unix systems when\n  modules are loaded from precompiled `*.cwasm` files on disk.\n  [#3777](https://github.com/bytecodealliance/wasmtime/pull/3777)\n  [#3778](https://github.com/bytecodealliance/wasmtime/pull/3778)\n  [#3787](https://github.com/bytecodealliance/wasmtime/pull/3787)\n  [#3819](https://github.com/bytecodealliance/wasmtime/pull/3819)\n  [#3831](https://github.com/bytecodealliance/wasmtime/pull/3831)\n\n* Clarify that SSE 4.2 (and prior) is required for running WebAssembly code with\n  simd support enabled on x86\\_64.\n  [#3816](https://github.com/bytecodealliance/wasmtime/pull/3816)\n  [#3817](https://github.com/bytecodealliance/wasmtime/pull/3817)\n  [#3833](https://github.com/bytecodealliance/wasmtime/pull/3833)\n  [#3825](https://github.com/bytecodealliance/wasmtime/pull/3825)\n\n* Support for profiling with VTune is now enabled at compile time by default,\n  but it remains disabled at runtime by default.\n  [#3821](https://github.com/bytecodealliance/wasmtime/pull/3821)\n\n* The `ModuleLimits` type has been removed from the configuration of the pooling\n  allocator in favor of configuring the total size of an instance allocation\n  rather than each individual field.\n  [#3837](https://github.com/bytecodealliance/wasmtime/pull/3837)\n\n* The native stack size allowed for WebAssembly has been decreased from 1 MiB to\n  512 KiB on all platforms to better accomodate running wasm on the main thread\n  on Windows.\n  [#3861](https://github.com/bytecodealliance/wasmtime/pull/3861)\n\n* The `wasi-common` crate now supports doing polls for both read and write\n  interest on a file descriptor at the same time.\n  [#3866](https://github.com/bytecodealliance/wasmtime/pull/3866)\n\n### Fixed\n\n* The `Store::call_hook` callback is now invoked when entering host functions\n  defined with `*_unchecked` variants.\n  [#3881](https://github.com/bytecodealliance/wasmtime/pull/3881)\n\n### Removed\n\n* The incomplete and unmaintained ARM32 backend has been removed from Cranelift.\n  [#3799](https://github.com/bytecodealliance/wasmtime/pull/3799)\n\n--------------------------------------------------------------------------------\n\n## 0.34.2\n\nReleased 2022-03-31.\n\n### Security Fixes\n\n* [CVE-2022-24791](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2):\n  Fixed a use after free with `externref`s and epoch interruption.\n\n## 0.34.1\n\nReleased 2022-02-16.\n\n### Security Fixes\n\n* [CVE-2022-23636](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-88xq-w8cq-xfg7):\n  Fixed an invalid drop of a partially-initialized instance in the pooling instance\n  allocator.\n\n## 0.33.1\n\nReleased 2022-02-16.\n\n### Security Fixes\n\n* [CVE-2022-23636](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-88xq-w8cq-xfg7):\n  Fixed an invalid drop of a partially-initialized instance in the pooling instance\n  allocator.\n\n## 0.34.0\n\nReleased 2022-02-07.\n\n### Fixed\n\n* The `wasi-common` default implementation of some attributes of files has been\n  updated to ensure that `wasi-libc`'s `isatty` function works as intended.\n  [#3696](https://github.com/bytecodealliance/wasmtime/pull/3696)\n\n* A benign debug assertion related to `externref` and garbage-collection has\n  been fixed.\n  [#3734](https://github.com/bytecodealliance/wasmtime/pull/3734)\n\n### Added\n\n* Function names are now automatically demangled when informing profilers of\n  regions of JIT code to apply Rust-specific demangling rules if applicable.\n  [#3683](https://github.com/bytecodealliance/wasmtime/pull/3683)\n\n* Support for profiling JIT-generated trampolines with VTune has been added.\n  [#3687](https://github.com/bytecodealliance/wasmtime/pull/3687)\n\n* Wasmtime now supports a new method of async preemption dubbed \"epoch-based\n  interruption\" which is intended to be much more efficient than the current\n  fuel-based method of preemption.\n  [#3699](https://github.com/bytecodealliance/wasmtime/pull/3699)\n\n* On Linux Wasmtime will now by default use copy-on-write mappings to initialize\n  memories of wasm modules where possible, accelerating instantiation by\n  avoiding costly memory copies. When combined with the pooling allocator this\n  can also be used to speed up instance-reuse cases due to fewer syscalls to\n  change memory mappings being necessary.\n  [#3697](https://github.com/bytecodealliance/wasmtime/pull/3697)\n  [#3738](https://github.com/bytecodealliance/wasmtime/pull/3738)\n  [#3760](https://github.com/bytecodealliance/wasmtime/pull/3760)\n\n* Wasmtime now supports the recently-added `sock_accept` WASI function.\n  [#3711](https://github.com/bytecodealliance/wasmtime/pull/3711)\n\n* Cranelift now has support for specifying blocks as cold.\n  [#3698](https://github.com/bytecodealliance/wasmtime/pull/3698)\n\n### Changed\n\n* Many more instructions for the x64 backend have been migrated to ISLE,\n  additionally with refactorings to make incorrect lowerings harder to\n  accidentally write.\n  [#3653](https://github.com/bytecodealliance/wasmtime/pull/3653)\n  [#3659](https://github.com/bytecodealliance/wasmtime/pull/3659)\n  [#3681](https://github.com/bytecodealliance/wasmtime/pull/3681)\n  [#3686](https://github.com/bytecodealliance/wasmtime/pull/3686)\n  [#3688](https://github.com/bytecodealliance/wasmtime/pull/3688)\n  [#3690](https://github.com/bytecodealliance/wasmtime/pull/3690)\n  [#3752](https://github.com/bytecodealliance/wasmtime/pull/3752)\n\n* More instructions in the aarch64 backend are now lowered with ISLE.\n  [#3658](https://github.com/bytecodealliance/wasmtime/pull/3658)\n  [#3662](https://github.com/bytecodealliance/wasmtime/pull/3662)\n\n* The s390x backend's lowering rules are now almost entirely defined with ISLE.\n  [#3702](https://github.com/bytecodealliance/wasmtime/pull/3702)\n  [#3703](https://github.com/bytecodealliance/wasmtime/pull/3703)\n  [#3706](https://github.com/bytecodealliance/wasmtime/pull/3706)\n  [#3717](https://github.com/bytecodealliance/wasmtime/pull/3717)\n  [#3723](https://github.com/bytecodealliance/wasmtime/pull/3723)\n  [#3724](https://github.com/bytecodealliance/wasmtime/pull/3724)\n\n* Instantiation of modules in Wasmtime has been further optimized now that the\n  copy-on-write memory initialization removed the previously most-expensive part\n  of instantiating a module.\n  [#3727](https://github.com/bytecodealliance/wasmtime/pull/3727)\n  [#3739](https://github.com/bytecodealliance/wasmtime/pull/3739)\n  [#3741](https://github.com/bytecodealliance/wasmtime/pull/3741)\n  [#3742](https://github.com/bytecodealliance/wasmtime/pull/3742)\n\n--------------------------------------------------------------------------------\n\n## 0.33.0\n\nReleased 2022-01-05.\n\n### Added\n\n* Compiled wasm modules may now optionally omit debugging information about\n  mapping addresses to source locations, resulting in smaller binaries.\n  [#3598](https://github.com/bytecodealliance/wasmtime/pull/3598)\n\n* The WebAssembly SIMD proposal is now enabled by default.\n  [#3601](https://github.com/bytecodealliance/wasmtime/pull/3601)\n\n--------------------------------------------------------------------------------\n\n## 0.32.1\n\nReleased 2022-01-04.\n\n### Fixed\n\n* Cranelift: remove recently-added build dependency on `sha2` to allow usage in\n  some dependency-sensitive environments, by computing ISLE manifest hashes\n  with a different hash function.\n  [#3619](https://github.com/bytecodealliance/wasmtime/pull/3619)\n\n* Cranelift: fixed 8- and 16-bit behavior of popcount (bit population count)\n  instruction. Does not affect Wasm frontend.\n  [#3617](https://github.com/bytecodealliance/wasmtime/pull/3617)\n\n* Cranelift: fixed miscompilation of 8- and 16-bit bit-rotate instructions.\n  Does not affect Wasm frontend.\n  [#3610](https://github.com/bytecodealliance/wasmtime/pull/3610)\n\n--------------------------------------------------------------------------------\n\n## 0.32.0\n\nReleased 2021-12-13.\n\n### Added\n\n* A new configuration option has been added to force using a \"static\" memory\n  style to automatically limit growth of memories in some configurations.\n  [#3503](https://github.com/bytecodealliance/wasmtime/pull/3503)\n\n* The `InstancePre<T>` type now implements `Clone`.\n  [#3510](https://github.com/bytecodealliance/wasmtime/pull/3510)\n\n* Cranelift's instruction selection process has begun to be migrated towards the\n  ISLE compiler and definition language.\n  [#3506](https://github.com/bytecodealliance/wasmtime/pull/3506)\n\n* A `pooling-allocator` feature has been added, which is on-by-default, to\n  disable the pooling allocator at compile time.\n  [#3514](https://github.com/bytecodealliance/wasmtime/pull/3514)\n\n### Fixed\n\n* A possible panic when parsing a WebAssembly `name` section has been fixed.\n  [#3509](https://github.com/bytecodealliance/wasmtime/pull/3509)\n\n* Generating native DWARF information for some C-produced modules has been\n  fixed, notably those where there may be DWARF about dead code.\n  [#3498](https://github.com/bytecodealliance/wasmtime/pull/3498)\n\n* A number of SIMD code generation bugs have been fixed in the x64 backend\n  by migrating their lowerings to ISLE.\n\n--------------------------------------------------------------------------------\n\n## 0.31.0\n\nReleased 2021-10-29.\n\n### Added\n\n* New `Func::new_unchecked` and `Func::call_unchecked` APIs have been added with\n  accompanying functions in the C API to improve the performance of calls into\n  wasm and the host in the C API.\n  [#3350](https://github.com/bytecodealliance/wasmtime/pull/3350)\n\n* Release binaries are now available for the s390x-unknown-linux-gnu\n  architecture.\n  [#3372](https://github.com/bytecodealliance/wasmtime/pull/3372)\n\n* A new `ResourceLimiterAsync` trait is added which allows asynchronous blocking\n  of WebAssembly on instructions such as `memory.grow`.\n  [#3393](https://github.com/bytecodealliance/wasmtime/pull/3393)\n\n### Changed\n\n* The `Func::call` method now takes a slice to write the results into rather\n  than returning a boxed slice.\n  [#3319](https://github.com/bytecodealliance/wasmtime/pull/3319)\n\n* Trampolines are now covered when jitdump profiling is enabled.\n  [#3344](https://github.com/bytecodealliance/wasmtime/pull/3344)\n\n### Fixed\n\n* Debugging with GDB has been fixed on Windows.\n  [#3373](https://github.com/bytecodealliance/wasmtime/pull/3373)\n\n* Some quadradic behavior in Wasmtime's compilation of modules has been fixed.\n  [#3469](https://github.com/bytecodealliance/wasmtime/pull/3469)\n  [#3466](https://github.com/bytecodealliance/wasmtime/pull/3466)\n\n* Bounds-checks for wasm memory accesses in certain non-default configurations\n  have been fixed to correctly allow loads at the end of the address space.\n  [#3462](https://github.com/bytecodealliance/wasmtime/pull/3462)\n\n* When type-checking memories and tables for satisfying instance imports the\n  runtime size of the table/memory is now consulted instead of the object's\n  original type.\n  [#3450](https://github.com/bytecodealliance/wasmtime/pull/3450)\n\n### Removed\n\n* The Lightbeam backend has been removed, as per [RFC 14].\n  [#3390](https://github.com/bytecodealliance/wasmtime/pull/3390)\n\n[RFC 14]: https://github.com/bytecodealliance/rfcs/pull/14\n\n* Cranelift's old x86 backend has been removed, as per [RFC 12].\n  [#3309](https://github.com/bytecodealliance/wasmtime/pull/3009)\n\n[RFC 12]: https://github.com/bytecodealliance/rfcs/pull/12\n\n## 0.30.0\n\nReleased 2021-09-17.\n\n### Security Fixes\n\n* [CVE-2021-39216](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf):\n  Fixed a use after free passing `externref`s to Wasm in Wasmtime.\n\n* [CVE-2021-39218](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49):\n  Fixed an out-of-bounds read/write and invalid free with `externref`s and GC\n  safepoints in Wasmtime.\n\n* [CVE-2021-39219](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx):\n  Fixed a bug where using two different `Engine`s with the same `Linker`-define\n  functions caused unsafety without `unsafe` blocks.\n\n### Added\n\n* Added experimental support for the in-progress 64-bit memories Wasm proposal.\n\n* Added support to build Wasmtime without the compiler. This lets you run\n  pre-compiled Wasm modules, without the ability (or potential attack surface)\n  of compiling new Wasm modules. The compilation functionality is gated by the\n  on-by-default `cranelift` cargo feature.\n\n* Added support for NaN canonicalization with SIMD vectors.\n\n* Added support for differential fuzzing against V8's Wasm engine.\n\n* Added support for fuzzing against the Wasm spec interpreter.\n\n* Enabled SIMD fuzzing on oss-fuzz.\n\n### Changed\n\n* A variety of performance improvements to loading pre-compiled modules.\n\n* A variety of performance improvements to function calls, both through Rust and\n  the C API.\n\n* Leaf functions that do not use the stack no longer bump the frame pointer on\n  aarch64 and s390x.\n\n* Many updates and expanded instruction support to the in-progress CLIF\n  interpreter.\n\n* Expanded fuzzing of reference types and GC.\n\n### Fixed\n\n* A number of fixes to both aarch64 and x86_64 support for the Wasm SIMD\n  proposal and the underlying CLIF vector instructions.\n\n* Fixed a potential infinite loop in the SSA computation for\n  `cranelift-frontend`. This was not reachable from `cranelift-wasm` or\n  Wasmtime, but might have affected general Cranelift users.\n\n### Removed\n\n* The `wasmtime wasm2obj` subcommand has been removed. Generating raw object\n  files for linking natively is no longer supported. Use the `wasmtime compile`\n  subcommand to pre-compile a Wasm module and `wasmtime run` to run pre-compiled\n  Wasm modules.\n\n## 0.29.0\n\nReleased 2021-08-02.\n\n### Changed\n\n* Instance exports are now loaded lazily from instances instead of eagerly as\n  they were before. This is an internal-only change and is not a breaking\n  change.\n  [#2984](https://github.com/bytecodealliance/wasmtime/pull/2984)\n\n* All linear memories created by Wasmtime will now, by default, have guard pages\n  in front of them in addition to after them. This is intended to help mitigate\n  future bugs in Cranelift, should they arise.\n  [#2977](https://github.com/bytecodealliance/wasmtime/pull/2977)\n\n* Linear memories now correctly support a maximum size of 4GB. Previously, the\n  limit field was 32 bits, which did not properly support a full 4GB memory.\n  This update is also a necessary change in preparation for future memory64\n  support.\n  [#3013](https://github.com/bytecodealliance/wasmtime/pull/3013)\n  [#3134](https://github.com/bytecodealliance/wasmtime/pull/3134)\n\n* Injection counts of fuel into a `wasmtime::Store` now uses a u64 instead of a\n  u32.\n  [#3048](https://github.com/bytecodealliance/wasmtime/pull/3048)\n\n### Added\n\n* Support for `i128` has improved in the AArch64 backend.\n  [#2959](https://github.com/bytecodealliance/wasmtime/pull/2959)\n  [#2975](https://github.com/bytecodealliance/wasmtime/pull/2975)\n  [#2985](https://github.com/bytecodealliance/wasmtime/pull/2985)\n  [#2990](https://github.com/bytecodealliance/wasmtime/pull/2990)\n  [#3002](https://github.com/bytecodealliance/wasmtime/pull/3002)\n  [#3004](https://github.com/bytecodealliance/wasmtime/pull/3004)\n  [#3005](https://github.com/bytecodealliance/wasmtime/pull/3005)\n  [#3008](https://github.com/bytecodealliance/wasmtime/pull/3008)\n  [#3027](https://github.com/bytecodealliance/wasmtime/pull/3027)\n\n* The s390x backend now supports z14 and atomics.\n  [#2988](https://github.com/bytecodealliance/wasmtime/pull/2988)\n  [#2991](https://github.com/bytecodealliance/wasmtime/pull/2991)\n\n* The `wasmtime::Linker` type now implements `Clone`.\n  [#2993](https://github.com/bytecodealliance/wasmtime/pull/2993)\n\n* Support for the SIMD proposal on both x86\\_64 and AArch64 has improved. On\n  x86\\_64, all SIMD opcodes are now supported.\n  [#2997](https://github.com/bytecodealliance/wasmtime/pull/2997)\n  [#3035](https://github.com/bytecodealliance/wasmtime/pull/3035)\n  [#2982](https://github.com/bytecodealliance/wasmtime/pull/2982)\n  [#3084](https://github.com/bytecodealliance/wasmtime/pull/3084)\n  [#3082](https://github.com/bytecodealliance/wasmtime/pull/3082)\n  [#3107](https://github.com/bytecodealliance/wasmtime/pull/3107)\n  [#3105](https://github.com/bytecodealliance/wasmtime/pull/3105)\n  [#3114](https://github.com/bytecodealliance/wasmtime/pull/3114)\n  [#3070](https://github.com/bytecodealliance/wasmtime/pull/3070)\n  [#3126](https://github.com/bytecodealliance/wasmtime/pull/3126)\n\n* A `Trap` can now display its reason without also displaying the backtrace.\n  [#3033](https://github.com/bytecodealliance/wasmtime/pull/3033)\n\n* An initiall fuzzer for CLIF has been added.\n  [#3038](https://github.com/bytecodealliance/wasmtime/pull/3038)\n\n* High-level architecture documentation has been added for Wasmtime.\n  [#3019](https://github.com/bytecodealliance/wasmtime/pull/3019)\n\n* Support for multi-memory can now be configured in Wasmtime's C API.\n  [#3071](https://github.com/bytecodealliance/wasmtime/pull/3071)\n\n* The `wasmtime` crate now supports a `posix-signals-on-macos` feature to force\n  the usage of signals instead of mach ports to handle traps on macOS.\n  [#3063](https://github.com/bytecodealliance/wasmtime/pull/3063)\n\n* Wasmtime's C API now has a `wasmtime_trap_code` function to get the raw trap\n  code, if present, for a trap.\n  [#3086](https://github.com/bytecodealliance/wasmtime/pull/3086)\n\n* Wasmtime's C API now has a `wasmtime_linker_define_func` function to define a\n  store-independent function within a linker.\n  [#3122](https://github.com/bytecodealliance/wasmtime/pull/3122)\n\n* A `wasmtime::Linker::module_async` function was added as the asynchronous\n  counterpart to `wasmtime::Linker::module`.\n  [#3121](https://github.com/bytecodealliance/wasmtime/pull/3121)\n\n### Fixed\n\n* Compiling the `wasmtime` crate into a `dylib` crate type has been fixed.\n  [#3010](https://github.com/bytecodealliance/wasmtime/pull/3010)\n\n* The enter/exit hooks for WebAssembly are now executed for an instance's\n  `start` function, if present.\n  [#3001](https://github.com/bytecodealliance/wasmtime/pull/3001)\n\n* Some WASI functions in `wasi-common` have been fixed for big-endian platforms.\n  [#3016](https://github.com/bytecodealliance/wasmtime/pull/3016)\n\n* Wasmtime no longer erroneously assumes that all custom sections may contain\n  DWARF information, reducing instances of `Trap`'s `Display` implementation\n  providing misleading information to set an env var to get more information.\n  [#3083](https://github.com/bytecodealliance/wasmtime/pull/3083)\n\n* Some issues with parsing DWARF debug information have been fixed.\n  [#3116](https://github.com/bytecodealliance/wasmtime/pull/3116)\n\n## 0.28.0\n\nReleased 2021-06-09.\n\n### Changed\n\n* Breaking: Wasmtime's embedding API has been redesigned, as specified in [RFC\n  11]. Rust users can now enjoy easier times with `Send` and `Sync`, and all\n  users can now more clearly manage memory, especially in the C API. Language\n  embeddings have been updated to the new API as well.\n  [#2897](https://github.com/bytecodealliance/wasmtime/pull/2897)\n\n[RFC 11]: https://github.com/bytecodealliance/rfcs/pull/11\n\n### Added\n\n* A new `InstancePre` type, created with `Linker::instantiate_pre`, has been\n  added to perform type-checking of an instance once and reduce the work done\n  for each instantiation of a module:\n  [#2962](https://github.com/bytecodealliance/wasmtime/pull/2962)\n\n* Deserialization of a module can now optionally skip checking the wasmtime\n  version string:\n  [#2945](https://github.com/bytecodealliance/wasmtime/pull/2945)\n\n* A method has been exposed to frontload per-thread initialization costs if the\n  latency of every last wasm call is important:\n  [#2946](https://github.com/bytecodealliance/wasmtime/pull/2946)\n\n* Hooks have been added for entry/exit into wasm code to allow embeddings to\n  track time and other properties about execution in a wasm environment:\n  [#2952](https://github.com/bytecodealliance/wasmtime/pull/2952)\n\n* A [C++ embedding of Wasmtime has been written][cpp].\n\n[RFC 11]: https://github.com/bytecodealliance/rfcs/pull/11\n[cpp]: https://github.com/bytecodealliance/wasmtime-cpp\n\n### Fixed\n\n* Multiple returns on macOS AArch64 have been fixed:\n  [#2956](https://github.com/bytecodealliance/wasmtime/pull/2956)\n\n## 0.27.0\n\nReleased 2021-05-21.\n\n### Security Fixes\n\n* Fixed a security issue in Cranelift's x64 backend that could result in a heap\n  sandbox escape due to an incorrect sign-extension:\n  [#2913](https://github.com/bytecodealliance/wasmtime/issues/2913).\n\n### Added\n\n* Support for IBM z/Archiecture (`s390x`) machines in Cranelift and Wasmtime:\n  [#2836](https://github.com/bytecodealliance/wasmtime/pull/2836),\n  [#2837](https://github.com/bytecodealliance/wasmtime/pull/2837),\n  [#2838](https://github.com/bytecodealliance/wasmtime/pull/2838),\n  [#2843](https://github.com/bytecodealliance/wasmtime/pull/2843),\n  [#2854](https://github.com/bytecodealliance/wasmtime/pull/2854),\n  [#2870](https://github.com/bytecodealliance/wasmtime/pull/2870),\n  [#2871](https://github.com/bytecodealliance/wasmtime/pull/2871),\n  [#2872](https://github.com/bytecodealliance/wasmtime/pull/2872),\n  [#2874](https://github.com/bytecodealliance/wasmtime/pull/2874).\n\n* Improved async support in wasi-common runtime:\n  [#2832](https://github.com/bytecodealliance/wasmtime/pull/2832).\n\n* Added `Store::with_limits`, `StoreLimits`, and `ResourceLimiter` to the\n  Wasmtime API to help with enforcing resource limits at runtime. The\n  `ResourceLimiter` trait can be implemented by custom resource limiters to\n  decide if linear memories or tables can be grown.\n\n* Added `allow-unknown-exports` option for the run command:\n  [#2879](https://github.com/bytecodealliance/wasmtime/pull/2879).\n\n* Added API to notify that a `Store` has moved to a new thread:\n  [#2822](https://github.com/bytecodealliance/wasmtime/pull/2822).\n\n* Documented guidance around using Wasmtime in multithreaded contexts:\n  [#2812](https://github.com/bytecodealliance/wasmtime/pull/2812).\n  In the future, the Wasmtime API will change to allow some of its core types\n  to be Send/Sync; see the in-progress\n  [#2897](https://github.com/bytecodealliance/wasmtime/pull/2897) for details.\n\n* Support calls from native code to multiple-return-value functions:\n  [#2806](https://github.com/bytecodealliance/wasmtime/pull/2806).\n\n### Changed\n\n* Breaking: `Memory::new` has been changed to return `Result` as creating a\n  host memory object is now a fallible operation when the initial size of\n  the memory exceeds the store limits.\n\n### Fixed\n\n* Many instruction selection improvements on x64 and aarch64:\n  [#2819](https://github.com/bytecodealliance/wasmtime/pull/2819),\n  [#2828](https://github.com/bytecodealliance/wasmtime/pull/2828),\n  [#2823](https://github.com/bytecodealliance/wasmtime/pull/2823),\n  [#2862](https://github.com/bytecodealliance/wasmtime/pull/2862),\n  [#2886](https://github.com/bytecodealliance/wasmtime/pull/2886),\n  [#2889](https://github.com/bytecodealliance/wasmtime/pull/2889),\n  [#2905](https://github.com/bytecodealliance/wasmtime/pull/2905).\n\n* Improved performance of Wasmtime runtime substantially:\n  [#2811](https://github.com/bytecodealliance/wasmtime/pull/2811),\n  [#2818](https://github.com/bytecodealliance/wasmtime/pull/2818),\n  [#2821](https://github.com/bytecodealliance/wasmtime/pull/2821),\n  [#2847](https://github.com/bytecodealliance/wasmtime/pull/2847),\n  [#2900](https://github.com/bytecodealliance/wasmtime/pull/2900).\n\n* Fixed WASI issue with file metadata on Windows:\n  [#2884](https://github.com/bytecodealliance/wasmtime/pull/2884).\n\n* Fixed an issue with debug info and an underflowing (trapping) offset:\n  [#2866](https://github.com/bytecodealliance/wasmtime/pull/2866).\n\n* Fixed an issue with unwind information in the old x86 backend:\n  [#2845](https://github.com/bytecodealliance/wasmtime/pull/2845).\n\n* Fixed i32 spilling in x64 backend:\n  [#2840](https://github.com/bytecodealliance/wasmtime/pull/2840).\n\n## 0.26.0\n\nReleased 2021-04-05.\n\n### Added\n\n* Added the `wasmtime compile` command to support AOT compilation of Wasm\n  modules. This adds the `Engine::precompile_module` method. Also added the\n  `Config::target` method to change the compilation target of the\n  configuration. This can be used in conjunction with\n  `Engine::precompile_module` to target a different host triple than the\n  current one.\n  [#2791](https://github.com/bytecodealliance/wasmtime/pull/2791)\n\n* Support for macOS on aarch64 (Apple M1 Silicon), including Apple-specific\n  calling convention details and unwinding/exception handling using Mach ports.\n  [#2742](https://github.com/bytecodealliance/wasmtime/pull/2742),\n  [#2723](https://github.com/bytecodealliance/wasmtime/pull/2723)\n\n* A number of SIMD instruction implementations in the new x86-64 backend.\n  [#2771](https://github.com/bytecodealliance/wasmtime/pull/2771)\n\n* Added the `Config::cranelift_flag_enable` method to enable setting Cranelift\n  boolean flags or presets in a config.\n\n* Added CLI option `--cranelift-enable` to enable boolean settings and ISA presets.\n\n* Deduplicate function signatures in Wasm modules.\n  [#2772](https://github.com/bytecodealliance/wasmtime/pull/2772)\n\n* Optimize overheads of calling into Wasm functions.\n  [#2757](https://github.com/bytecodealliance/wasmtime/pull/2757),\n  [#2759](https://github.com/bytecodealliance/wasmtime/pull/2759)\n\n* Improvements related to Module Linking: compile fewer trampolines;\n\n  [#2774](https://github.com/bytecodealliance/wasmtime/pull/2774)\n\n* Re-export sibling crates from `wasmtime-wasi` to make embedding easier\n  without needing to match crate versions.\n  [#2776](https://github.com/bytecodealliance/wasmtime/pull/2776)\n\n### Changed\n\n* Switched the default compiler backend on x86-64 to Cranelift's new backend.\n  This should not have any user-visible effects other than possibly runtime\n  performance improvements. The old backend is still available with the\n  `old-x86-backend` feature flag to the `cranelift-codegen` or `wasmtime`\n  crates, or programmatically with `BackendVariant::Legacy`. We plan to\n  maintain the old backend for at least one more release and ensure it works on\n  CI.\n  [#2718](https://github.com/bytecodealliance/wasmtime/pull/2718)\n\n* Breaking: `Module::deserialize` has been removed in favor of `Module::new`.\n\n* Breaking: `Config::cranelift_clear_cpu_flags` was removed. Use `Config::target`\n  to clear the CPU flags for the host's target.\n\n* Breaking: `Config::cranelift_other_flag` was renamed to `Config::cranelift_flag_set`.\n\n* CLI changes:\n  * Wasmtime CLI options to enable WebAssembly features have been replaced with\n    a singular `--wasm-features` option. The previous options are still\n    supported, but are not displayed in help text.\n  * Breaking: the CLI option `--cranelift-flags` was changed to\n    `--cranelift-set`.\n  * Breaking: the CLI option `--enable-reference-types=false` has been changed\n    to `--wasm-features=-reference-types`.\n  * Breaking: the CLI option `--enable-multi-value=false` has been changed to\n    `--wasm-features=-multi-value`.\n  * Breaking: the CLI option `--enable-bulk-memory=false` has been changed to\n    `--wasm-features=-bulk-memory`.\n\n* Improved error-reporting in wiggle.\n  [#2760](https://github.com/bytecodealliance/wasmtime/pull/2760)\n\n* Make WASI sleeping fallible (some systems do not support sleep).\n  [#2756](https://github.com/bytecodealliance/wasmtime/pull/2756)\n\n* WASI: Support `poll_oneoff` with a sleep.\n  [#2753](https://github.com/bytecodealliance/wasmtime/pull/2753)\n\n* Allow a `StackMapSink` to be passed when defining functions with\n  `cranelift-module`.\n  [#2739](https://github.com/bytecodealliance/wasmtime/pull/2739)\n\n* Some refactoring in new x86-64 backend to prepare for VEX/EVEX (e.g.,\n  AVX-512) instruction encodings to be supported.\n  [#2799](https://github.com/bytecodealliance/wasmtime/pull/2799)\n\n### Fixed\n\n* Fixed a corner case in `srem` (signed remainder) in the new x86-64 backend:\n  `INT_MIN % -1` should return `0`, rather than trapping. This only occurred\n  when `avoid_div_traps == false` was set by the embedding.\n  [#2763](https://github.com/bytecodealliance/wasmtime/pull/2763)\n\n* Fixed a memory leak of the `Store` when an instance traps.\n  [#2803](https://github.com/bytecodealliance/wasmtime/pull/2803)\n\n* Some fuzzing-related fixes.\n  [#2788](https://github.com/bytecodealliance/wasmtime/pull/2788),\n  [#2770](https://github.com/bytecodealliance/wasmtime/pull/2770)\n\n* Fixed memory-initialization bug in uffd allocator that could copy into the\n  wrong destination under certain conditions. Does not affect the default\n  wasmtime instance allocator.\n  [#2801](https://github.com/bytecodealliance/wasmtime/pull/2801)\n\n* Fix printing of float values from the Wasmtime CLI.\n  [#2797](https://github.com/bytecodealliance/wasmtime/pull/2797)\n\n* Remove the ability for the `Linker` to instantiate modules with duplicate\n  import strings of different types.\n  [#2789](https://github.com/bytecodealliance/wasmtime/pull/2789)\n\n## 0.25.0\n\nReleased 2021-03-16.\n\n### Added\n\n* An implementation of a pooling instance allocator, optionally backed by\n  `userfaultfd` on Linux, was added to improve the performance of embeddings\n  that instantiate a large number of instances continuously.\n  [#2518](https://github.com/bytecodealliance/wasmtime/pull/2518)\n\n* Host functions can now be defined on `Config` to share the function across all\n  `Store` objects connected to an `Engine`. This can improve the time it takes\n  to instantiate instances in a short-lived `Store`.\n  [#2625](https://github.com/bytecodealliance/wasmtime/pull/2625)\n\n* The `Store` object now supports having typed values attached to it which can\n  be retrieved from host functions.\n  [#2625](https://github.com/bytecodealliance/wasmtime/pull/2625)\n\n* The `wiggle` code generator now supports `async` host functions.\n  [#2701](https://github.com/bytecodealliance/wasmtime/pull/2701)\n\n### Changed\n\n* The `Func::getN{,_async}` APIs have all been removed in favor of a new\n  `Func::typed` API which should be more compact in terms of API surface area as\n  well as more flexible in how it can be used.\n  [#2719](https://github.com/bytecodealliance/wasmtime/pull/2719)\n\n* `Engine::new` has been changed from returning `Engine` to returning\n  `anyhow::Result<Engine>`. Callers of `Engine::new` will need to be updated to\n  use the `?` operator on the return value or otherwise unwrap the result to get\n  the `Engine`.\n\n### Fixed\n\n* Interpretation of timestamps in `poll_oneoff` for WASI have been fixed to\n  correctly use nanoseconds instead of microseconds.\n  [#2717](https://github.com/bytecodealliance/wasmtime/pull/2717)\n\n## 0.24.0\n\nReleased 2021-03-04.\n\n### Added\n\n* Implement support for `async` functions in Wasmtime\n  [#2434](https://github.com/bytecodealliance/wasmtime/pull/2434)\n\n### Fixed\n\n* Fix preservation of the sigaltstack on macOS\n  [#2676](https://github.com/bytecodealliance/wasmtime/pull/2676)\n* Fix incorrect semver dependencies involving fs-set-times.\n  [#2705](https://github.com/bytecodealliance/wasmtime/pull/2705)\n* Fix some `i128` shift-related bugs in x64 backend.\n  [#2682](https://github.com/bytecodealliance/wasmtime/pull/2682)\n* Fix incomplete trap metadata due to multiple traps at one address\n  [#2685](https://github.com/bytecodealliance/wasmtime/pull/2685)\n\n## 0.23.0\n\nReleased 2021-02-16.\n\n### Added\n\n* Support for limiting WebAssembly execution with fuel was added, including\n  support in the C API.\n  [#2611](https://github.com/bytecodealliance/wasmtime/pull/2611)\n  [#2643](https://github.com/bytecodealliance/wasmtime/pull/2643)\n* Wasmtime now has more knobs for limiting memory and table allocations\n  [#2617](https://github.com/bytecodealliance/wasmtime/pull/2617)\n* Added a method to share `Config` across machines\n  [#2608](https://github.com/bytecodealliance/wasmtime/pull/2608)\n* Added a safe memory read/write API\n  [#2528](https://github.com/bytecodealliance/wasmtime/pull/2528)\n* Added support for the experimental wasi-crypto APIs\n  [#2597](https://github.com/bytecodealliance/wasmtime/pull/2597)\n* Added an instance limit to `Config`\n  [#2593](https://github.com/bytecodealliance/wasmtime/pull/2593)\n* Implemented module-linking's outer module aliases\n  [#2590](https://github.com/bytecodealliance/wasmtime/pull/2590)\n* Cranelift now supports 128-bit operations for the new x64 backend.\n  [#2539](https://github.com/bytecodealliance/wasmtime/pull/2539)\n* Cranelift now has detailed debug-info (DWARF) support in new backends (initially x64).\n  [#2565](https://github.com/bytecodealliance/wasmtime/pull/2565)\n* Cranelift now uses the `POPCNT`, `TZCNT`, and `LZCNT`, as well as SSE 4.1\n  rounding instructions on x64 when available.\n* Cranelift now uses the `CNT`, instruction on aarch64 when available.\n\n### Changed\n\n* A new WASI implementation built on the new\n  [`cap-std`](https://github.com/bytecodealliance/cap-std) crate was added,\n  replacing the previous implementation. This brings improved robustness,\n  portability, and performance.\n\n* `wasmtime_wasi::WasiCtxBuilder` moved to\n  `wasi_cap_std_sync::WasiCtxBuilder`.\n\n* The WebAssembly C API is updated, with a few minor API changes\n  [#2579](https://github.com/bytecodealliance/wasmtime/pull/2579)\n\n### Fixed\n\n* Fixed a panic in WASI `fd_readdir` on large directories\n  [#2620](https://github.com/bytecodealliance/wasmtime/pull/2620)\n* Fixed a memory leak with command modules\n  [#2017](https://github.com/bytecodealliance/wasmtime/pull/2017)\n\n--------------------------------------------------------------------------------\n\n## 0.22.0\n\nReleased 2021-01-07.\n\n### Added\n\n* Experimental support for [the module-linking\n  proposal](https://github.com/WebAssembly/module-linking) was\n  added. [#2094](https://github.com/bytecodealliance/wasmtime/pull/2094)\n\n* Added support for [the reference types\n  proposal](https://webassembly.github.io/reference-types) on the aarch64\n  architecture. [#2410](https://github.com/bytecodealliance/wasmtime/pull/2410)\n\n* Experimental support for [wasi-nn](https://github.com/WebAssembly/wasi-nn) was\n  added. [#2208](https://github.com/bytecodealliance/wasmtime/pull/2208)\n\n### Changed\n\n### Fixed\n\n* Fixed an issue where the `select` instruction didn't accept `v128` SIMD\n  operands. [#2391](https://github.com/bytecodealliance/wasmtime/pull/2391)\n\n* Fixed an issue where Wasmtime could potentially use the wrong stack map during\n  GCs, leading to a\n  panic. [#2396](https://github.com/bytecodealliance/wasmtime/pull/2396)\n\n* Fixed an issue where if a host-defined function erroneously returned a value\n  from a different store, that value would be\n  leaked. [#2424](https://github.com/bytecodealliance/wasmtime/pull/2424)\n\n* Fixed a bug where in certain cases if a module's instantiation failed, it\n  could leave trampolines in the store that referenced the no-longer-valid\n  instance. These trampolines could be reused in future instantiations, leading\n  to use after free bugs.\n  [#2408](https://github.com/bytecodealliance/wasmtime/pull/2408)\n\n* Fixed a miscompilation on aarch64 where certain instructions would read `SP`\n  instead of the zero register. This could only affect you if you explicitly\n  enabled the Wasm SIMD\n  proposal. [#2548](https://github.com/bytecodealliance/wasmtime/pull/2548)\n\n--------------------------------------------------------------------------------\n\n## 0.21.0\n\nReleased 2020-11-05.\n\n### Added\n\n* Experimental support for the multi-memory proposal was added.\n  [#2263](https://github.com/bytecodealliance/wasmtime/pull/2263)\n\n* The `Trap::trap_code` API enables learning what kind of trap was raised.\n  [#2309](https://github.com/bytecodealliance/wasmtime/pull/2309)\n\n### Changed\n\n* WebAssembly module validation is now parallelized.\n  [#2059](https://github.com/bytecodealliance/wasmtime/pull/2059)\n\n* Documentation is now available at docs.wasmtime.dev.\n  [#2317](https://github.com/bytecodealliance/wasmtime/pull/2317)\n\n* Windows now compiles like other platforms with a huge guard page instead of\n  having its own custom limit which made modules compile and run more slowly.\n  [#2326](https://github.com/bytecodealliance/wasmtime/pull/2326)\n\n* The size of the cache entry for serialized modules has been greatly reduced.\n  [#2321](https://github.com/bytecodealliance/wasmtime/pull/2321)\n  [#2322](https://github.com/bytecodealliance/wasmtime/pull/2322)\n  [#2324](https://github.com/bytecodealliance/wasmtime/pull/2324)\n  [#2325](https://github.com/bytecodealliance/wasmtime/pull/2325)\n\n* The `FuncType` API constructor and accessors are now iterator-based.\n  [#2365](https://github.com/bytecodealliance/wasmtime/pull/2365)\n\n### Fixed\n\n* A panic in compiling reference-types-using modules has been fixed.\n  [#2350](https://github.com/bytecodealliance/wasmtime/pull/2350)\n\n--------------------------------------------------------------------------------\n\n## 0.20.0\n\nReleased 2020-09-23.\n\n### Added\n\n* Support for explicitly serializing and deserializing compiled wasm modules has\n  been added.\n  [#2020](https://github.com/bytecodealliance/wasmtime/pull/2020)\n\n* A `wasmtime_store_gc` C API was added to run GC for `externref`.\n  [#2052](https://github.com/bytecodealliance/wasmtime/pull/2052)\n\n* Support for atomics in Cranelift has been added. Support is not fully\n  implemented in Wasmtime at this time, however.\n  [#2077](https://github.com/bytecodealliance/wasmtime/pull/2077)\n\n* The `Caller::get_export` function is now implemented for `Func` references as\n  well.\n  [#2108](https://github.com/bytecodealliance/wasmtime/pull/2108)\n\n### Fixed\n\n* Leaks in the C API have been fixed.\n  [#2040](https://github.com/bytecodealliance/wasmtime/pull/2040)\n\n* The `wasm_val_copy` C API has been fixed for reference types.\n  [#2041](https://github.com/bytecodealliance/wasmtime/pull/2041)\n\n* Fix a panic with `Func::new` and reference types when the store doesn't have\n  reference types enabled.\n  [#2039](https://github.com/bytecodealliance/wasmtime/pull/2039)\n\n--------------------------------------------------------------------------------\n\n## 0.19.0\n\nReleased 2020-07-14.\n\n### Added\n\n* The [WebAssembly reference-types proposal][reftypes] is now supported in\n  Wasmtime and the C API.\n  [#1832](https://github.com/bytecodealliance/wasmtime/pull/1832),\n  [#1882](https://github.com/bytecodealliance/wasmtime/pull/1882),\n  [#1894](https://github.com/bytecodealliance/wasmtime/pull/1894),\n  [#1901](https://github.com/bytecodealliance/wasmtime/pull/1901),\n  [#1923](https://github.com/bytecodealliance/wasmtime/pull/1923),\n  [#1969](https://github.com/bytecodealliance/wasmtime/pull/1969),\n  [#1973](https://github.com/bytecodealliance/wasmtime/pull/1973),\n  [#1982](https://github.com/bytecodealliance/wasmtime/pull/1982),\n  [#1984](https://github.com/bytecodealliance/wasmtime/pull/1984),\n  [#1991](https://github.com/bytecodealliance/wasmtime/pull/1991),\n  [#1996](https://github.com/bytecodealliance/wasmtime/pull/1996)\n\n* The [WebAssembly simd proposal's][simd] spec tests now pass in Wasmtime.\n  [#1765](https://github.com/bytecodealliance/wasmtime/pull/1765),\n  [#1876](https://github.com/bytecodealliance/wasmtime/pull/1876),\n  [#1941](https://github.com/bytecodealliance/wasmtime/pull/1941),\n  [#1957](https://github.com/bytecodealliance/wasmtime/pull/1957),\n  [#1990](https://github.com/bytecodealliance/wasmtime/pull/1990),\n  [#1994](https://github.com/bytecodealliance/wasmtime/pull/1994)\n\n* Wasmtime can now be compiled without the usage of threads for parallel\n  compilation, although this is still enabled by default.\n  [#1903](https://github.com/bytecodealliance/wasmtime/pull/1903)\n\n* The C API is [now\n  documented](https://bytecodealliance.github.io/wasmtime/c-api/).\n  [#1928](https://github.com/bytecodealliance/wasmtime/pull/1928),\n  [#1959](https://github.com/bytecodealliance/wasmtime/pull/1959),\n  [#1968](https://github.com/bytecodealliance/wasmtime/pull/1968)\n\n* A `wasmtime_linker_get_one_by_name` function was added to the C API.\n  [#1897](https://github.com/bytecodealliance/wasmtime/pull/1897)\n\n* A `wasmtime_trap_exit_status` function was added to the C API.\n  [#1912](https://github.com/bytecodealliance/wasmtime/pull/1912)\n\n* Compilation for the `aarch64-linux-android` target should now work, although\n  keep in mind this platform is not fully tested still.\n  [#2002](https://github.com/bytecodealliance/wasmtime/pull/2002)\n\n[reftypes]: https://github.com/WebAssembly/reference-types\n\n### Fixed\n\n* Runtime warnings when using Wasmtime on musl have been fixed.\n  [#1914](https://github.com/bytecodealliance/wasmtime/pull/1914)\n\n* A bug affecting Windows unwind information with functions that have spilled\n  floating point registers has been fixed.\n  [#1983](https://github.com/bytecodealliance/wasmtime/pull/1983)\n\n### Changed\n\n* Wasmtime's default branch and development now happens on the `main` branch\n  instead of `master`.\n  [#1924](https://github.com/bytecodealliance/wasmtime/pull/1924)\n\n### Removed\n\n* The \"host info\" support in the C API has been removed since it was never fully\n  or correctly implemented.\n  [#1922](https://github.com/bytecodealliance/wasmtime/pull/1922)\n\n* Support for the `*_same` functions in the C API has been removed in the same\n  vein as the host info APIs.\n  [#1926](https://github.com/bytecodealliance/wasmtime/pull/1926)\n\n--------------------------------------------------------------------------------\n\n## 0.18.0\n\nRelease 2020-06-09.\n\n### Added\n\nThe `WasmTy` trait is now implemented for `u32` and `u64`.\n\n  [#1808](https://github.com/bytecodealliance/wasmtime/pull/1808)\n\n--------------------------------------------------------------------------------\n\n## 0.17.0\n\nReleased 2020-06-01.\n\n### Added\n\n* The [Commands and Reactors ABI] is now supported in the Rust API. `Linker::module`\n  loads a module and automatically handles Commands and Reactors semantics.\n\n  [#1565](https://github.com/bytecodealliance/wasmtime/pull/1565)\n\n[Commands and Reactors ABI]: https://github.com/WebAssembly/WASI/blob/master/design/application-abi.md#current-unstable-abi\n\nThe `Table::grow` function now returns the previous table size, making it consistent\nwith the `table.grow` instruction.\n\n  [#1653](https://github.com/bytecodealliance/wasmtime/pull/1653)\n\nNew Wasmtime-specific C APIs for working with tables were added which provide more\ndetailed error information and which make growing a table more consistent with the\n`table.grow` instruction as well.\n\n  [#1654](https://github.com/bytecodealliance/wasmtime/pull/1654)\n\nThe C API now includes support for enabling logging in Wasmtime.\n\n  [#1737](https://github.com/bytecodealliance/wasmtime/pull/1737)\n\n### Changed\n\nThe WASI `proc_exit` function no longer exits the host process. It now unwinds the\ncallstack back to the wasm entrypoint, and the exit value is available from the\n`Trap::i32_exit_status` method.\n\n  [#1646](https://github.com/bytecodealliance/wasmtime/pull/1646)\n\nThe WebAssembly [multi-value](https://github.com/WebAssembly/multi-value/) proposal\nis now enabled by default.\n\n  [#1667](https://github.com/bytecodealliance/wasmtime/pull/1667)\n\nThe Rust API does not require a store provided during `Module::new` operation. The `Module` can be send accross threads and instantiate for a specific store. The `Instance::new` now requires the store.\n\n  [#1761](https://github.com/bytecodealliance/wasmtime/pull/1761)\n\n--------------------------------------------------------------------------------\n\n## 0.16.0\n\nReleased 2020-04-29.\n\n### Added\n\n* The `Instance` struct has new accessors, `get_func`, `get_table`,\n  `get_memory`, and `get_global` for quickly looking up exported\n  functions, tables, memories, and globals by name.\n  [#1524](https://github.com/bytecodealliance/wasmtime/pull/1524)\n\n* The C API has a number of new `wasmtime_*` functions which return error\n  objects to get detailed error information when an API fails.\n  [#1467](https://github.com/bytecodealliance/wasmtime/pull/1467)\n\n* Users now have fine-grained control over creation of instances of `Memory`\n  with a new `MemoryCreator` trait.\n  [#1400](https://github.com/bytecodealliance/wasmtime/pull/1400)\n\n* Go bindings for Wasmtime are [now available][go-bindings].\n  [#1481](https://github.com/bytecodealliance/wasmtime/pull/1481)\n\n* APIs for looking up values in a `Linker` have been added.\n  [#1480](https://github.com/bytecodealliance/wasmtime/pull/1480)\n\n* Preliminary support for AArch64, also known as ARM64.\n  [#1581](https://github.com/bytecodealliance/wasmtime/pull/1581)\n\n[go-bindings]: https://github.com/bytecodealliance/wasmtime-go\n\n### Changed\n\n* `Instance::exports` now returns `Export` objects which contain\n  the `name`s of the exports in addition to their `Extern` definitions,\n  so it's no longer necessary to use `Module::exports` to obtain the\n  export names.\n  [#1524](https://github.com/bytecodealliance/wasmtime/pull/1524)\n\n* The `Func::call` API has changed its error type from `Trap` to `anyhow::Error`\n  to distinguish between wasm traps and runtime violations (like the wrong\n  number of parameters).\n  [#1467](https://github.com/bytecodealliance/wasmtime/pull/1467)\n\n* A number of `wasmtime_linker_*` and `wasmtime_config_*` C APIs have new type\n  signatures which reflect returning errors.\n  [#1467](https://github.com/bytecodealliance/wasmtime/pull/1467)\n\n* Bindings for .NET have moved to\n  https://github.com/bytecodealliance/wasmtime-dotnet.\n  [#1477](https://github.com/bytecodealliance/wasmtime/pull/1477)\n\n* Passing too many imports to `Instance::new` is now considered an error.\n  [#1478](https://github.com/bytecodealliance/wasmtime/pull/1478)\n\n### Fixed\n\n* Spurious segfaults due to out-of-stack conditions when handling signals have\n  been fixed.\n  [#1315](https://github.com/bytecodealliance/wasmtime/pull/1315)\n\n--------------------------------------------------------------------------------\n\n## 0.15.0\n\nReleased 2020-03-31.\n\n### Fixed\n\nFull release produced for all artifacts to account for hiccups in 0.13.0 and\n0.14.0.\n\n--------------------------------------------------------------------------------\n\n## 0.14.0\n\n*This version ended up not getting a full release*\n\n### Fixed\n\nFix build errors in wasi-common on Windows.\n\n--------------------------------------------------------------------------------\n\n## 0.13.0\n\nReleased 2020-03-24.\n\n### Added\n\n* Lots of documentation of `wasmtime` has been updated. Be sure to check out the\n  [book](https://bytecodealliance.github.io/wasmtime/) and [API\n  documentation](https://bytecodealliance.github.io/wasmtime/api/wasmtime/)!\n\n* All wasmtime example programs are now in a top-level `examples` directory and\n  are available in both C and Rust.\n  [#1286](https://github.com/bytecodealliance/wasmtime/pull/1286)\n\n* A `wasmtime::Linker` type was added to conveniently link link wasm modules\n  together and create instances that reference one another.\n  [#1384](https://github.com/bytecodealliance/wasmtime/pull/1384)\n\n* Wasmtime now has \"jitdump\" support enabled by default which allows [profiling\n  wasm code on linux][jitdump].\n  [#1310](https://github.com/bytecodealliance/wasmtime/pull/1310)\n\n* The `wasmtime::Caller` type now exists as a first-class way to access the\n  caller's exports, namely memory, when implementing host APIs. This can be the\n  first argument of functions defined with `Func::new` or `Func::wrap` which\n  allows easily implementing methods which take a pointer into wasm memory. Note\n  that this only works for accessing the caller's `Memory` for now and it must\n  be exported. This will eventually be replaced with a more general-purpose\n  mechanism like interface types.\n  [#1290](https://github.com/bytecodealliance/wasmtime/pull/1290)\n\n* The bulk memory proposal has been fully implemented.\n  [#1264](https://github.com/bytecodealliance/wasmtime/pull/1264)\n  [#976](https://github.com/bytecodealliance/wasmtime/pull/976)\n\n* Virtual file support has been added to `wasi-common`.\n  [#701](https://github.com/bytecodealliance/wasmtime/pull/701)\n\n* The C API has been enhanced with a Wasmtime-specific `wasmtime_wat2wasm` to\n  parse `*.wat` files via the C API.\n  [#1206](https://github.com/bytecodealliance/wasmtime/pull/1206)\n\n[jitdump]: https://bytecodealliance.github.io/wasmtime/examples-profiling.html\n\n### Changed\n\n* The `wast` and `wasm2obj` standalone binaries have been removed. They're\n  available via the `wasmtime wast` and `wasmtime wasm2obj` subcommands.\n  [#1372](https://github.com/bytecodealliance/wasmtime/pull/1372)\n\n* The `wasi-common` crate now uses the new `wiggle` crate to auto-generate a\n  trait which is implemented for the current wasi snapshot.\n  [#1202](https://github.com/bytecodealliance/wasmtime/pull/1202)\n\n* Wasmtime no longer has a dependency on a C++ compiler.\n  [#1365](https://github.com/bytecodealliance/wasmtime/pull/1365)\n\n* The `Func::wrapN` APIs have been consolidated into one `Func::wrap` API.\n  [#1363](https://github.com/bytecodealliance/wasmtime/pull/1363)\n\n* The `Callable` trait has been removed and now `Func::new` takes a closure\n  directly.\n  [#1363](https://github.com/bytecodealliance/wasmtime/pull/1363)\n\n* The Cranelift repository has been merged into the Wasmtime repository.\n\n* Support for interface types has been temporarily removed.\n  [#1292](https://github.com/bytecodealliance/wasmtime/pull/1292)\n\n* The exit code of the `wasmtime` CLI has changed if the program traps.\n  [#1274](https://github.com/bytecodealliance/wasmtime/pull/1274)\n\n* The `wasmtime` CLI now logs to stderr by default and the `-d` flag has been\n  renamed to `--log-to-file`.\n  [#1266](https://github.com/bytecodealliance/wasmtime/pull/1266)\n\n* Values cannot cross `Store` objects, meaning you can't instantiate a module\n  with values from different stores nor pass values from different stores into\n  methods.\n  [#1016](https://github.com/bytecodealliance/wasmtime/pull/1016)\n\n--------------------------------------------------------------------------------\n\n## 0.12.0\n\nReleased 2020-02-26.\n\n### Added\n\n* Support for the [WebAssembly text annotations proposal][annotations-proposal]\n  has been added.\n  [#998](https://github.com/bytecodealliance/wasmtime/pull/998)\n\n* An initial C API for instantiating WASI modules has been added.\n  [#977](https://github.com/bytecodealliance/wasmtime/pull/977)\n\n* A new suite of `Func::getN` functions have been added to the `wasmtime` API to\n  call statically-known function signatures in a highly optimized fashion.\n  [#955](https://github.com/bytecodealliance/wasmtime/pull/955)\n\n* Initial support for profiling JIT code through perf jitdump has been added.\n  [#360](https://github.com/bytecodealliance/wasmtime/pull/360)\n\n* More CLI flags corresponding to proposed WebAssembly features have been added.\n  [#917](https://github.com/bytecodealliance/wasmtime/pull/917)\n\n[annotations-proposal]: https://github.com/webassembly/annotations\n\n### Changed\n\n* The `wasmtime` CLI as well as embedding API will optimize WebAssembly code by\n  default now.\n  [#973](https://github.com/bytecodealliance/wasmtime/pull/973)\n  [#988](https://github.com/bytecodealliance/wasmtime/pull/988)\n\n* The `verifier` pass in Cranelift is now no longer run by default when using\n  the embedding API.\n  [#882](https://github.com/bytecodealliance/wasmtime/pull/882)\n\n### Fixed\n\n* Code caching now accurately accounts for optimization levels, ensuring that if\n  you ask for optimized code you're not accidentally handed unoptimized code\n  from the cache.\n  [#974](https://github.com/bytecodealliance/wasmtime/pull/974)\n\n* Automated releases for tags should be up and running again, along with\n  automatic publication of the `wasmtime` Python package.\n  [#971](https://github.com/bytecodealliance/wasmtime/pull/971)\n", ";; x86-64 instruction selection and CLIF-to-MachInst lowering.\n\n;; The main lowering constructor term: takes a clif `Inst` and returns the\n;; register(s) within which the lowered instruction's result values live.\n(decl partial lower (Inst) InstOutput)\n\n;; A variant of the main lowering constructor term, used for branches.\n;; The only difference is that it gets an extra argument holding a vector\n;; of branch targets to be used.\n(decl partial lower_branch (Inst MachLabelSlice) Unit)\n\n;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n(rule (lower (has_type (fits_in_64 ty)\n                       (iconst (u64_from_imm64 x))))\n      (imm ty x))\n\n;; `i128`\n(rule 1 (lower (has_type $I128\n                       (iconst (u64_from_imm64 x))))\n      (value_regs (imm $I64 x)\n                  (imm $I64 0)))\n\n;;;; Rules for `f32const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (f32const (u32_from_ieee32 x)))\n      (imm $F32 x))\n\n;;;; Rules for `f64const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (f64const (u64_from_ieee64 x)))\n      (imm $F64 x))\n\n;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type ty (null)))\n      (imm ty 0))\n\n;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n;; Base case for 8 and 16-bit types\n(rule -6 (lower (has_type (fits_in_16 ty)\n                       (iadd x y)))\n      (x64_add ty x y))\n\n;; Base case for 32 and 64-bit types which might end up using the `lea`\n;; instruction to fold multiple operations into one.\n;;\n;; Note that at this time this always generates a `lea` pseudo-instruction,\n;; but the actual instruction emitted might be an `add` if it's equivalent.\n;; For more details on this see the `emit.rs` logic to emit\n;; `LoadEffectiveAddress`.\n(rule -5 (lower (has_type (ty_32_or_64 ty) (iadd x y)))\n      (x64_lea ty (to_amode_add (mem_flags_trusted) x y (zero_offset))))\n\n;; Higher-priority cases than the previous two where a load can be sunk into\n;; the add instruction itself. Note that both operands are tested for\n;; sink-ability since addition is commutative\n(rule -4 (lower (has_type (fits_in_64 ty)\n                       (iadd x (sinkable_load y))))\n      (x64_add ty x y))\n(rule -3 (lower (has_type (fits_in_64 ty)\n                       (iadd (sinkable_load x) y)))\n      (x64_add ty y x))\n\n;; SSE.\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (iadd x y)))\n      (x64_paddb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (iadd x y)))\n      (x64_paddw x y))\n\n(rule (lower (has_type (multi_lane 32 4)\n                       (iadd x y)))\n      (x64_paddd x y))\n\n(rule (lower (has_type (multi_lane 64 2)\n                       (iadd x y)))\n      (x64_paddq x y))\n\n;; `i128`\n(rule 1 (lower (has_type $I128 (iadd x y)))\n      ;; Get the high/low registers for `x`.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        ;; Get the high/low registers for `y`.\n        (let ((y_regs ValueRegs y)\n              (y_lo Gpr (value_regs_get_gpr y_regs 0))\n              (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n          ;; Do an add followed by an add-with-carry.\n          (with_flags (x64_add_with_flags_paired $I64 x_lo y_lo)\n                      (x64_adc_paired $I64 x_hi y_hi)))))\n\n;;;; Helpers for `*_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(decl construct_overflow_op (CC ProducesFlags) InstOutput)\n(rule (construct_overflow_op cc inst)\n      (let ((results ValueRegs (with_flags inst\n                                           (x64_setcc_paired cc))))\n        (output_pair (value_regs_get results 0)\n                     (value_regs_get results 1))))\n\n(decl construct_overflow_op_alu (Type CC AluRmiROpcode Gpr GprMemImm) InstOutput)\n(rule (construct_overflow_op_alu ty cc alu_op src1 src2)\n      (construct_overflow_op cc (x64_alurmi_with_flags_paired alu_op ty src1 src2)))\n\n;; This essentially creates\n;; alu_<op1> x_lo, y_lo\n;; alu_<op2> x_hi, y_hi\n;; set<cc> r8\n(decl construct_overflow_op_alu_128 (CC AluRmiROpcode AluRmiROpcode Value Value) InstOutput)\n(rule (construct_overflow_op_alu_128 cc op1 op2 x y)\n      ;; Get the high/low registers for `x`.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        ;; Get the high/low registers for `y`.\n        (let ((y_regs ValueRegs y)\n              (y_lo Gpr (value_regs_get_gpr y_regs 0))\n              (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n          (let    ((lo_inst ProducesFlags (x64_alurmi_with_flags_paired op1 $I64 x_lo y_lo))\n                   (hi_inst ConsumesAndProducesFlags (x64_alurmi_with_flags_chained op2 $I64 x_hi y_hi))\n                   (of_inst ConsumesFlags (x64_setcc_paired cc))\n\n                   (result MultiReg (with_flags_chained lo_inst hi_inst of_inst)))\n                  (multi_reg_to_pair_and_single result)))))\n\n;;;; Rules for `uadd_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (uadd_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.B) (AluRmiROpcode.Add) x y))\n\n;; i128 gets lowered into adc and add\n(rule 0 (lower (uadd_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.B) (AluRmiROpcode.Add) (AluRmiROpcode.Adc) x y))\n\n;;;; Rules for `sadd_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (sadd_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.O) (AluRmiROpcode.Add) x y))\n\n(rule 0 (lower (sadd_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.O) (AluRmiROpcode.Add) (AluRmiROpcode.Adc) x y))\n\n;;;; Rules for `usub_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (usub_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.B) (AluRmiROpcode.Sub) x y))\n\n(rule 0 (lower (usub_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.B) (AluRmiROpcode.Sub) (AluRmiROpcode.Sbb) x y))\n\n;;;; Rules for `ssub_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (ssub_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op_alu ty (CC.O) (AluRmiROpcode.Sub) x y))\n\n(rule 0 (lower (ssub_overflow x y @ (value_type $I128)))\n        (construct_overflow_op_alu_128 (CC.O) (AluRmiROpcode.Sub) (AluRmiROpcode.Sbb) x y))\n\n;;;; Rules for `umul_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (umul_overflow x y @ (value_type (fits_in_64 ty))))\n      (construct_overflow_op (CC.O) (x64_umullo_with_flags_paired ty x y)))\n\n;;;; Rules for `smul_overflow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (smul_overflow x y @ (value_type (ty_int_ref_16_to_64 ty))))\n      (construct_overflow_op_alu ty (CC.O) (AluRmiROpcode.Mul) x y))\n\n;; there is no 8bit imul with an immediate operand so we need to put it in a register or memory\n(rule 1 (lower (smul_overflow x y @ (value_type $I8)))\n      (construct_overflow_op (CC.O) (x64_alurmi_with_flags_paired (AluRmiROpcode.Mul) $I8 x (reg_mem_to_reg_mem_imm (put_in_reg_mem y)))))\n\n;;;; Rules for `sadd_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (sadd_sat x y)))\n      (x64_paddsb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (sadd_sat x y)))\n      (x64_paddsw x y))\n\n;;;; Rules for `uadd_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (uadd_sat x y)))\n      (x64_paddusb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (uadd_sat x y)))\n      (x64_paddusw x y))\n\n;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n;; Sub two registers.\n(rule -3 (lower (has_type (fits_in_64 ty)\n                       (isub x y)))\n      (x64_sub ty x y))\n\n;; SSE.\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (isub x y)))\n      (x64_psubb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (isub x y)))\n      (x64_psubw x y))\n\n(rule (lower (has_type (multi_lane 32 4)\n                       (isub x y)))\n      (x64_psubd x y))\n\n(rule (lower (has_type (multi_lane 64 2)\n                       (isub x y)))\n      (x64_psubq x y))\n\n;; `i128`\n(rule 1 (lower (has_type $I128 (isub x y)))\n      ;; Get the high/low registers for `x`.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        ;; Get the high/low registers for `y`.\n        (let ((y_regs ValueRegs y)\n              (y_lo Gpr (value_regs_get_gpr y_regs 0))\n              (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n          ;; Do a sub followed by an sub-with-borrow.\n          (with_flags (x64_sub_with_flags_paired $I64 x_lo y_lo)\n                      (x64_sbb_paired $I64 x_hi y_hi)))))\n\n;;;; Rules for `ssub_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (ssub_sat x y)))\n      (x64_psubsb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (ssub_sat x y)))\n      (x64_psubsw x y))\n\n;;;; Rules for `usub_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (usub_sat x y)))\n      (x64_psubusb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (usub_sat x y)))\n      (x64_psubusw x y))\n\n;;;; Rules for `band` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `{i,b}64` and smaller.\n\n;; And two registers.\n(rule 0 (lower (has_type ty (band x y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_and ty x y))\n\n;; The above case automatically handles when the rhs is an immediate or a\n;; sinkable load, but additionally handle the lhs here.\n\n(rule 1 (lower (has_type ty (band (sinkable_load x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_and ty y x))\n\n(rule 2 (lower (has_type ty (band (simm32_from_value x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_and ty y x))\n\n;; f32 and f64\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (band x y)))\n      (sse_and ty x y))\n\n;; SSE.\n\n(decl sse_and (Type Xmm XmmMem) Xmm)\n(rule (sse_and $F32X4 x y) (x64_andps x y))\n(rule (sse_and $F64X2 x y) (x64_andpd x y))\n(rule (sse_and $F32 x y) (x64_andps x y))\n(rule (sse_and $F64 x y) (x64_andpd x y))\n(rule -1 (sse_and (multi_lane _bits _lanes) x y) (x64_pand x y))\n\n(rule 6 (lower (has_type ty @ (multi_lane _bits _lanes)\n                       (band x y)))\n      (sse_and ty x y))\n\n;; `i128`.\n\n(decl and_i128 (ValueRegs ValueRegs) ValueRegs)\n(rule (and_i128 x y)\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1))\n            (y_regs ValueRegs y)\n            (y_lo Gpr (value_regs_get_gpr y_regs 0))\n            (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n        (value_gprs (x64_and $I64 x_lo y_lo)\n                    (x64_and $I64 x_hi y_hi))))\n\n(rule 7 (lower (has_type $I128 (band x y)))\n      (and_i128 x y))\n\n;; Specialized lowerings for `(band x (bnot y))` which is additionally produced\n;; by Cranelift's `band_not` instruction that is legalized into the simpler\n;; forms early on.\n\n(decl sse_and_not (Type Xmm XmmMem) Xmm)\n(rule (sse_and_not $F32X4 x y) (x64_andnps x y))\n(rule (sse_and_not $F64X2 x y) (x64_andnpd x y))\n(rule -1 (sse_and_not (multi_lane _bits _lanes) x y) (x64_pandn x y))\n\n;; Note the flipping of operands below as we're match\n;;\n;;   (band x (bnot y))\n;;\n;; while x86 does\n;;\n;;   pandn(x, y) = and(not(x), y)\n(rule 8 (lower (has_type ty @ (multi_lane _bits _lane) (band x (bnot y))))\n      (sse_and_not ty y x))\n(rule 9 (lower (has_type ty @ (multi_lane _bits _lane) (band (bnot y) x)))\n      (sse_and_not ty y x))\n\n(rule 10 (lower (has_type ty (band x (bnot y))))\n      (if (ty_int_ref_scalar_64 ty))\n      (if-let $true (use_bmi1))\n      ;; the first argument is the one that gets inverted with andn\n      (x64_andn ty y x))\n(rule 11 (lower (has_type ty (band (bnot y) x)))\n      (if (ty_int_ref_scalar_64 ty))\n      (if-let $true (use_bmi1))\n      (x64_andn ty y x))\n\n;; Specialization of `blsr` for BMI1\n\n(decl pure partial val_minus_one (Value) Value)\n(rule 0 (val_minus_one (isub x (u64_from_iconst 1))) x)\n(rule 0 (val_minus_one (iadd x (i64_from_iconst -1))) x)\n(rule 1 (val_minus_one (iadd (i64_from_iconst -1) x)) x)\n\n(rule 12 (lower (has_type (ty_32_or_64 ty) (band x y)))\n         (if-let $true (use_bmi1))\n         (if-let x (val_minus_one y))\n         (x64_blsr ty x))\n(rule 13 (lower (has_type (ty_32_or_64 ty) (band y x)))\n         (if-let $true (use_bmi1))\n         (if-let x (val_minus_one y))\n         (x64_blsr ty x))\n\n;; Specialization of `blsi` for BMI1\n\n(rule 14 (lower (has_type (ty_32_or_64 ty) (band (ineg x) x)))\n         (if-let $true (use_bmi1))\n         (x64_blsi ty x))\n(rule 15 (lower (has_type (ty_32_or_64 ty) (band x (ineg x))))\n         (if-let $true (use_bmi1))\n         (x64_blsi ty x))\n\n;; Specialization of `bzhi` for BMI2\n;;\n;; The `bzhi` instruction clears all bits indexed by the second operand of the\n;; first operand. This is pattern-matched here with a `band` against a mask\n;; which is generated to be N bits large. Note that if the index is larger than\n;; the bit-width of the type then `bzhi` doesn't have the same semantics as\n;; `ishl`, so an `and` instruction is required to mask the index to match the\n;; semantics of Cranelift's `ishl`.\n\n(rule 16 (lower (has_type (ty_32_or_64 ty) (band x y)))\n         (if-let $true (use_bmi2))\n         (if-let (ishl (u64_from_iconst 1) index) (val_minus_one y))\n         (x64_bzhi ty x (x64_and ty index (RegMemImm.Imm (u32_sub (ty_bits ty) 1)))))\n\n;;;; Rules for `bor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `{i,b}64` and smaller.\n\n;; Or two registers.\n(rule 0 (lower (has_type ty (bor x y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_or ty x y))\n\n;; Handle immediates/sinkable loads on the lhs in addition to the automatic\n;; handling of the rhs above\n\n(rule 1 (lower (has_type ty (bor (sinkable_load x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_or ty y x))\n\n(rule 2 (lower (has_type ty (bor (simm32_from_value x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_or ty y x))\n\n;; f32 and f64\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (bor x y)))\n      (sse_or ty x y))\n\n;; SSE.\n\n(decl sse_or (Type Xmm XmmMem) Xmm)\n(rule (sse_or $F32X4 x y) (x64_orps x y))\n(rule (sse_or $F64X2 x y) (x64_orpd x y))\n(rule (sse_or $F32 x y) (x64_orps x y))\n(rule (sse_or $F64 x y) (x64_orpd x y))\n(rule -1 (sse_or (multi_lane _bits _lanes) x y) (x64_por x y))\n\n(rule 6 (lower (has_type ty @ (multi_lane _bits _lanes)\n                       (bor x y)))\n      (sse_or ty x y))\n\n;; `{i,b}128`.\n\n(decl or_i128 (ValueRegs ValueRegs) ValueRegs)\n(rule (or_i128 x y)\n      (let ((x_lo Gpr (value_regs_get_gpr x 0))\n            (x_hi Gpr (value_regs_get_gpr x 1))\n            (y_lo Gpr (value_regs_get_gpr y 0))\n            (y_hi Gpr (value_regs_get_gpr y 1)))\n        (value_gprs (x64_or $I64 x_lo y_lo)\n                    (x64_or $I64 x_hi y_hi))))\n\n(rule 7 (lower (has_type $I128 (bor x y)))\n      (or_i128 x y))\n\n;;;; Rules for `bxor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `{i,b}64` and smaller.\n\n;; Xor two registers.\n(rule 0 (lower (has_type ty (bxor x y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_xor ty x y))\n\n;; Handle xor with lhs immediates/sinkable loads in addition to the automatic\n;; handling of the rhs above.\n\n(rule 1 (lower (has_type ty (bxor (sinkable_load x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_xor ty y x))\n\n(rule 4 (lower (has_type ty (bxor (simm32_from_value x) y)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_xor ty y x))\n\n;; f32 and f64\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (bxor x y)))\n      (x64_xor_vector ty x y))\n\n;; SSE.\n\n(rule 6 (lower (has_type ty @ (multi_lane _bits _lanes) (bxor x y)))\n      (x64_xor_vector ty x y))\n\n;; `{i,b}128`.\n\n(rule 7 (lower (has_type $I128 (bxor x y)))\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1))\n            (y_regs ValueRegs y)\n            (y_lo Gpr (value_regs_get_gpr y_regs 0))\n            (y_hi Gpr (value_regs_get_gpr y_regs 1)))\n        (value_gprs (x64_xor $I64 x_lo y_lo)\n                    (x64_xor $I64 x_hi y_hi))))\n\n;; Specialization of `blsmsk` for BMI1\n\n(rule 8 (lower (has_type (ty_32_or_64 ty) (bxor x y)))\n        (if-let $true (use_bmi1))\n        (if-let x (val_minus_one y))\n        (x64_blsmsk ty x))\n(rule 9 (lower (has_type (ty_32_or_64 ty) (bxor y x)))\n        (if-let $true (use_bmi1))\n        (if-let x (val_minus_one y))\n        (x64_blsmsk ty x))\n\n;;;; Rules for `ishl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (ishl src amt)))\n      (x64_shl ty src (put_masked_in_imm8_gpr amt ty)))\n\n;; `i128`.\n\n(decl shl_i128 (ValueRegs Gpr) ValueRegs)\n(rule (shl_i128 src amt)\n      ;; Unpack the registers that make up the 128-bit value being shifted.\n      (let ((src_lo Gpr (value_regs_get_gpr src 0))\n            (src_hi Gpr (value_regs_get_gpr src 1))\n            ;; Do two 64-bit shifts.\n            (lo_shifted Gpr (x64_shl $I64 src_lo amt))\n            (hi_shifted Gpr (x64_shl $I64 src_hi amt))\n            ;; `src_lo >> (64 - amt)` are the bits to carry over from the lo\n            ;; into the hi.\n            (carry Gpr (x64_shr $I64\n                            src_lo\n                            (x64_sub $I64\n                                 (imm $I64 64)\n                                 amt)))\n            (zero Gpr (imm $I64 0))\n            ;; Nullify the carry if we are shifting in by a multiple of 128.\n            (carry_ Gpr (with_flags_reg (x64_test (OperandSize.Size64)\n                                              (RegMemImm.Imm 127)\n                                              amt)\n                                        (cmove $I64\n                                               (CC.Z)\n                                               zero\n                                               carry)))\n            ;; Add the carry into the high half.\n            (hi_shifted_ Gpr (x64_or $I64 carry_ hi_shifted)))\n        ;; Combine the two shifted halves. However, if we are shifting by >= 64\n        ;; (modulo 128), then the low bits are zero and the high bits are our\n        ;; low bits.\n        (with_flags (x64_test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                    (consumes_flags_concat\n                     (cmove $I64 (CC.Z) lo_shifted zero)\n                     (cmove $I64 (CC.Z) hi_shifted_ lo_shifted)))))\n\n(rule (lower (has_type $I128 (ishl src amt)))\n      ;; NB: Only the low bits of `amt` matter since we logically mask the shift\n      ;; amount to the value's bit width.\n      (let ((amt_ Gpr (lo_gpr amt)))\n        (shl_i128 src amt_)))\n\n;; SSE.\n\n;; Since the x86 instruction set does not have any 8x16 shift instructions (even\n;; in higher feature sets like AVX), we lower the `ishl.i8x16` to a sequence of\n;; instructions. The basic idea, whether the amount to shift by is an immediate\n;; or not, is to use a 16x8 shift and then mask off the incorrect bits to 0s.\n(rule (lower (has_type ty @ $I8X16 (ishl src amt)))\n      (let (\n            ;; Mask the amount to ensure wrapping behaviour\n            (masked_amt RegMemImm (mask_xmm_shift ty amt))\n            ;; Shift `src` using 16x8. Unfortunately, a 16x8 shift will only be\n            ;; correct for half of the lanes; the others must be fixed up with\n            ;; the mask below.\n            (unmasked Xmm (x64_psllw src (mov_rmi_to_xmm masked_amt)))\n            (mask_addr SyntheticAmode (ishl_i8x16_mask masked_amt))\n            (mask Reg (x64_load $I8X16 mask_addr (ExtKind.None))))\n        (sse_and $I8X16 unmasked (RegMem.Reg mask))))\n\n;; Get the address of the mask to use when fixing up the lanes that weren't\n;; correctly generated by the 16x8 shift.\n(decl ishl_i8x16_mask (RegMemImm) SyntheticAmode)\n\n;; When the shift amount is known, we can statically (i.e. at compile time)\n;; determine the mask to use and only emit that.\n(decl ishl_i8x16_mask_for_const (u32) SyntheticAmode)\n(extern constructor ishl_i8x16_mask_for_const ishl_i8x16_mask_for_const)\n(rule (ishl_i8x16_mask (RegMemImm.Imm amt))\n      (ishl_i8x16_mask_for_const amt))\n\n;; Otherwise, we must emit the entire mask table and dynamically (i.e. at run\n;; time) find the correct mask offset in the table. We use `lea` to find the\n;; base address of the mask table and then complex addressing to offset to the\n;; right mask: `base_address + amt << 4`\n(decl ishl_i8x16_mask_table () SyntheticAmode)\n(extern constructor ishl_i8x16_mask_table ishl_i8x16_mask_table)\n(rule (ishl_i8x16_mask (RegMemImm.Reg amt))\n      (let ((mask_table SyntheticAmode (ishl_i8x16_mask_table))\n            (base_mask_addr Gpr (x64_lea $I64 mask_table))\n            (mask_offset Gpr (x64_shl $I64 amt\n                                  (imm8_to_imm8_gpr 4))))\n        (Amode.ImmRegRegShift 0\n                              base_mask_addr\n                              mask_offset\n                              0\n                              (mem_flags_trusted))))\n\n(rule (ishl_i8x16_mask (RegMemImm.Mem amt))\n      (ishl_i8x16_mask (RegMemImm.Reg (x64_load $I64 amt (ExtKind.None)))))\n\n;; 16x8, 32x4, and 64x2 shifts can each use a single instruction, once the shift amount is masked.\n\n(rule (lower (has_type ty @ $I16X8 (ishl src amt)))\n      (x64_psllw src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I32X4 (ishl src amt)))\n      (x64_pslld src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I64X2 (ishl src amt)))\n      (x64_psllq src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n;;;; Rules for `ushr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (ushr src amt)))\n      (let ((src_ Gpr (extend_to_gpr src ty (ExtendKind.Zero))))\n        (x64_shr ty src_ (put_masked_in_imm8_gpr amt ty))))\n\n;; `i128`.\n\n(decl shr_i128 (ValueRegs Gpr) ValueRegs)\n(rule (shr_i128 src amt)\n      ;; Unpack the lo/hi halves of `src`.\n      (let ((src_lo Gpr (value_regs_get_gpr src 0))\n            (src_hi Gpr (value_regs_get_gpr src 1))\n            ;; Do a shift on each half.\n            (lo_shifted Gpr (x64_shr $I64 src_lo amt))\n            (hi_shifted Gpr (x64_shr $I64 src_hi amt))\n            ;; `src_hi << (64 - amt)` are the bits to carry over from the hi\n            ;; into the lo.\n            (carry Gpr (x64_shl $I64\n                            src_hi\n                            (x64_sub $I64\n                                 (imm $I64 64)\n                                 amt)))\n            ;; Share the zero value to reduce register pressure\n            (zero Gpr (imm $I64 0))\n\n            ;; Nullify the carry if we are shifting by a multiple of 128.\n            (carry_ Gpr (with_flags_reg (x64_test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                        (cmove $I64 (CC.Z) zero carry)))\n            ;; Add the carry bits into the lo.\n            (lo_shifted_ Gpr (x64_or $I64 carry_ lo_shifted)))\n        ;; Combine the two shifted halves. However, if we are shifting by >= 64\n        ;; (modulo 128), then the hi bits are zero and the lo bits are what\n        ;; would otherwise be our hi bits.\n        (with_flags (x64_test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                    (consumes_flags_concat\n                     (cmove $I64 (CC.Z) lo_shifted_ hi_shifted)\n                     (cmove $I64 (CC.Z) hi_shifted zero)))))\n\n(rule (lower (has_type $I128 (ushr src amt)))\n      ;; NB: Only the low bits of `amt` matter since we logically mask the shift\n      ;; amount to the value's bit width.\n      (let ((amt_ Gpr (lo_gpr amt)))\n        (shr_i128 src amt_)))\n\n;; SSE.\n\n;; There are no 8x16 shifts in x64. Do the same 16x8-shift-and-mask thing we do\n;; with 8x16 `ishl`.\n(rule (lower (has_type ty @ $I8X16 (ushr src amt)))\n      (let (\n            ;; Mask the amount to ensure wrapping behaviour\n            (masked_amt RegMemImm (mask_xmm_shift ty amt))\n            ;; Shift `src` using 16x8. Unfortunately, a 16x8 shift will only be\n            ;; correct for half of the lanes; the others must be fixed up with\n            ;; the mask below.\n            (unmasked Xmm (x64_psrlw src (mov_rmi_to_xmm masked_amt))))\n        (sse_and $I8X16\n                 unmasked\n                 (ushr_i8x16_mask masked_amt))))\n\n;; Get the address of the mask to use when fixing up the lanes that weren't\n;; correctly generated by the 16x8 shift.\n(decl ushr_i8x16_mask (RegMemImm) SyntheticAmode)\n\n;; When the shift amount is known, we can statically (i.e. at compile time)\n;; determine the mask to use and only emit that.\n(decl ushr_i8x16_mask_for_const (u32) SyntheticAmode)\n(extern constructor ushr_i8x16_mask_for_const ushr_i8x16_mask_for_const)\n(rule (ushr_i8x16_mask (RegMemImm.Imm amt))\n      (ushr_i8x16_mask_for_const amt))\n\n;; Otherwise, we must emit the entire mask table and dynamically (i.e. at run\n;; time) find the correct mask offset in the table. We use `lea` to find the\n;; base address of the mask table and then complex addressing to offset to the\n;; right mask: `base_address + amt << 4`\n(decl ushr_i8x16_mask_table () SyntheticAmode)\n(extern constructor ushr_i8x16_mask_table ushr_i8x16_mask_table)\n(rule (ushr_i8x16_mask (RegMemImm.Reg amt))\n      (let ((mask_table SyntheticAmode (ushr_i8x16_mask_table))\n            (base_mask_addr Gpr (x64_lea $I64 mask_table))\n            (mask_offset Gpr (x64_shl $I64\n                                  amt\n                                  (imm8_to_imm8_gpr 4))))\n        (Amode.ImmRegRegShift 0\n                              base_mask_addr\n                              mask_offset\n                              0\n                              (mem_flags_trusted))))\n\n(rule (ushr_i8x16_mask (RegMemImm.Mem amt))\n      (ushr_i8x16_mask (RegMemImm.Reg (x64_load $I64 amt (ExtKind.None)))))\n\n;; 16x8, 32x4, and 64x2 shifts can each use a single instruction, once the shift amount is masked.\n\n(rule (lower (has_type ty @ $I16X8 (ushr src amt)))\n      (x64_psrlw src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I32X4 (ushr src amt)))\n      (x64_psrld src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I64X2 (ushr src amt)))\n      (x64_psrlq src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(decl mask_xmm_shift (Type Value) RegMemImm)\n(rule (mask_xmm_shift ty amt)\n      (gpr_to_reg (x64_and $I64 amt (RegMemImm.Imm (shift_mask ty)))))\n(rule 1 (mask_xmm_shift ty (iconst n))\n      (RegMemImm.Imm (shift_amount_masked ty n)))\n\n;;;; Rules for `sshr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (sshr src amt)))\n      (let ((src_ Gpr (extend_to_gpr src ty (ExtendKind.Sign))))\n        (x64_sar ty src_ (put_masked_in_imm8_gpr amt ty))))\n\n;; `i128`.\n\n(decl sar_i128 (ValueRegs Gpr) ValueRegs)\n(rule (sar_i128 src amt)\n      ;; Unpack the low/high halves of `src`.\n      (let ((src_lo Gpr (value_regs_get_gpr src 0))\n            (src_hi Gpr (value_regs_get_gpr src 1))\n            ;; Do a shift of each half. NB: the low half uses an unsigned shift\n            ;; because its MSB is not a sign bit.\n            (lo_shifted Gpr (x64_shr $I64 src_lo amt))\n            (hi_shifted Gpr (x64_sar $I64 src_hi amt))\n            ;; `src_hi << (64 - amt)` are the bits to carry over from the low\n            ;; half to the high half.\n            (carry Gpr (x64_shl $I64\n                            src_hi\n                            (x64_sub $I64\n                                 (imm $I64 64)\n                                 amt)))\n            ;; Nullify the carry if we are shifting by a multiple of 128.\n            (carry_ Gpr (with_flags_reg (x64_test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                        (cmove $I64 (CC.Z) (imm $I64 0) carry)))\n            ;; Add the carry into the low half.\n            (lo_shifted_ Gpr (x64_or $I64 lo_shifted carry_))\n            ;; Get all sign bits.\n            (sign_bits Gpr (x64_sar $I64 src_hi (imm8_to_imm8_gpr 63))))\n        ;; Combine the two shifted halves. However, if we are shifting by >= 64\n        ;; (modulo 128), then the hi bits are all sign bits and the lo bits are\n        ;; what would otherwise be our hi bits.\n        (with_flags (x64_test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                    (consumes_flags_concat\n                     (cmove $I64 (CC.Z) lo_shifted_ hi_shifted)\n                     (cmove $I64 (CC.Z) hi_shifted sign_bits)))))\n\n(rule (lower (has_type $I128 (sshr src amt)))\n      ;; NB: Only the low bits of `amt` matter since we logically mask the shift\n      ;; amount to the value's bit width.\n      (let ((amt_ Gpr (lo_gpr amt)))\n        (sar_i128 src amt_)))\n\n;; SSE.\n\n;; Since the x86 instruction set does not have an 8x16 shift instruction and the\n;; approach used for `ishl` and `ushr` cannot be easily used (the masks do not\n;; preserve the sign), we use a different approach here: separate the low and\n;; high lanes, shift them separately, and merge them into the final result.\n;;\n;; Visually, this looks like the following, where `src.i8x16 = [s0, s1, ...,\n;; s15]:\n;;\n;;   lo.i16x8 = [(s0, s0), (s1, s1), ..., (s7, s7)]\n;;   shifted_lo.i16x8 = shift each lane of `low`\n;;   hi.i16x8 = [(s8, s8), (s9, s9), ..., (s15, s15)]\n;;   shifted_hi.i16x8 = shift each lane of `high`\n;;   result = [s0'', s1'', ..., s15'']\n(rule (lower (has_type ty @ $I8X16 (sshr src amt @ (value_type amt_ty))))\n      (let ((src_ Xmm (put_in_xmm src))\n            ;; Mask the amount to ensure wrapping behaviour\n            (masked_amt RegMemImm (mask_xmm_shift ty amt))\n            ;; In order for `packsswb` later to only use the high byte of each\n            ;; 16x8 lane, we shift right an extra 8 bits, relying on `psraw` to\n            ;; fill in the upper bits appropriately.\n            (lo Xmm (x64_punpcklbw src_ src_))\n            (hi Xmm (x64_punpckhbw src_ src_))\n            (amt_ XmmMemImm (sshr_i8x16_bigger_shift amt_ty masked_amt))\n            (shifted_lo Xmm (x64_psraw lo amt_))\n            (shifted_hi Xmm (x64_psraw hi amt_)))\n        (x64_packsswb shifted_lo shifted_hi)))\n\n(decl sshr_i8x16_bigger_shift (Type RegMemImm) XmmMemImm)\n(rule (sshr_i8x16_bigger_shift _ty (RegMemImm.Imm i))\n      (xmm_mem_imm_new (RegMemImm.Imm (u32_add i 8))))\n(rule (sshr_i8x16_bigger_shift ty (RegMemImm.Reg r))\n      (mov_rmi_to_xmm (RegMemImm.Reg (x64_add ty\n                                          r\n                                          (RegMemImm.Imm 8)))))\n(rule (sshr_i8x16_bigger_shift ty rmi @ (RegMemImm.Mem _m))\n      (mov_rmi_to_xmm (RegMemImm.Reg (x64_add ty\n                                          (imm ty 8)\n                                          rmi))))\n\n;; `sshr.{i16x8,i32x4}` can be a simple `psra{w,d}`, we just have to make sure\n;; that if the shift amount is in a register, it is in an XMM register.\n\n(rule (lower (has_type ty @ $I16X8 (sshr src amt)))\n      (x64_psraw src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n(rule (lower (has_type ty @ $I32X4 (sshr src amt)))\n      (x64_psrad src (mov_rmi_to_xmm (mask_xmm_shift ty amt))))\n\n;; The `sshr.i64x2` CLIF instruction has no single x86 instruction in the older\n;; feature sets. To remedy this, a small dance is done with an unsigned right\n;; shift plus some extra ops.\n(rule 3 (lower (has_type ty @ $I64X2 (sshr src (iconst n))))\n        (if-let $true (use_avx512vl))\n        (if-let $true (use_avx512f))\n        (x64_vpsraq_imm src (shift_amount_masked ty n)))\n\n(rule 2 (lower (has_type ty @ $I64X2 (sshr src amt)))\n        (if-let $true (use_avx512vl))\n        (if-let $true (use_avx512f))\n        (let ((masked Gpr (x64_and $I64 amt (RegMemImm.Imm (shift_mask ty)))))\n          (x64_vpsraq src (x64_movd_to_xmm masked))))\n\n(rule 1 (lower (has_type $I64X2 (sshr src (iconst (u64_from_imm64 (u64_as_u32 amt))))))\n        (lower_i64x2_sshr_imm src (u32_and amt 63)))\n\n(rule (lower (has_type $I64X2 (sshr src amt)))\n      (lower_i64x2_sshr_gpr src (x64_and $I64 amt (RegMemImm.Imm 63))))\n\n(decl lower_i64x2_sshr_imm (Xmm u32) Xmm)\n\n;; If the shift amount is less than 32 then do an sshr with 32-bit lanes to\n;; produce the upper halves of each result, followed by a ushr of 64-bit lanes\n;; to produce the lower halves of each result. Interleave results at the end.\n(rule 2 (lower_i64x2_sshr_imm vec imm)\n        (if-let $true (u64_lt imm 32))\n        (let (\n            (high32 Xmm (x64_psrad vec (xmi_imm imm)))\n            (high32 Xmm (x64_pshufd high32 0b11_10_11_01))\n            (low32  Xmm (x64_psrlq vec (xmi_imm imm)))\n            (low32  Xmm (x64_pshufd low32 0b11_10_10_00))\n          )\n          (x64_punpckldq low32 high32)))\n\n;; If the shift amount is 32 then the `psrlq` from the above rule can be avoided\n(rule 1 (lower_i64x2_sshr_imm vec 32)\n        (let (\n            (low32  Xmm (x64_pshufd vec 0b11_10_11_01))\n            (high32 Xmm (x64_psrad vec (xmi_imm 31)))\n            (high32 Xmm (x64_pshufd high32 0b11_10_11_01))\n          )\n          (x64_punpckldq low32 high32)))\n\n;; Shifts >= 32 use one `psrad` to generate the upper bits and second `psrad` to\n;; generate the lower bits. Everything is then woven back together with\n;; shuffles.\n(rule (lower_i64x2_sshr_imm vec imm)\n      (if-let $true (u64_lt 32 imm))\n      (let (\n          (high32 Xmm (x64_psrad vec (xmi_imm 31)))\n          (high32 Xmm (x64_pshufd high32 0b11_10_11_01))\n          (low32  Xmm (x64_psrad vec (xmi_imm (u32_sub imm 32))))\n          (low32  Xmm (x64_pshufd low32 0b11_10_11_01))\n        )\n        (x64_punpckldq low32 high32)))\n\n;; A variable shift amount is slightly more complicated than the immediate\n;; shift amounts from above. The `Gpr` argument is guaranteed to be <= 63 by\n;; earlier masking. A `ushr` operation is used with some xor/sub math to\n;; generate the sign bits.\n(decl lower_i64x2_sshr_gpr (Xmm Gpr) Xmm)\n(rule (lower_i64x2_sshr_gpr vec val)\n      (let (\n          (val                Xmm (x64_movq_to_xmm val))\n          (mask               Xmm (flip_high_bit_mask $I64X2))\n          (sign_bit_loc       Xmm (x64_psrlq mask val))\n          (ushr               Xmm (x64_psrlq vec val))\n          (ushr_sign_bit_flip Xmm (x64_pxor sign_bit_loc ushr))\n        )\n        (x64_psubq ushr_sign_bit_flip sign_bit_loc)))\n\n;;;; Rules for `rotl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller: we can rely on x86's rotate-amount masking since\n;;  we operate on the whole register. For const's we mask the constant.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (rotl src amt)))\n        (x64_rotl ty src (put_masked_in_imm8_gpr amt ty)))\n\n\n;; `i128`.\n\n(rule (lower (has_type $I128 (rotl src amt)))\n      (let ((src_ ValueRegs src)\n            ;; NB: Only the low bits of `amt` matter since we logically mask the\n            ;; rotation amount to the value's bit width.\n            (amt_ Gpr (lo_gpr amt)))\n        (or_i128 (shl_i128 src_ amt_)\n                 (shr_i128 src_ (x64_sub $I64\n                                     (imm $I64 128)\n                                     amt_)))))\n\n;;;; Rules for `rotr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller: we can rely on x86's rotate-amount masking since\n;;  we operate on the whole register. For const's we mask the constant.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (rotr src amt)))\n        (x64_rotr ty src (put_masked_in_imm8_gpr amt ty)))\n\n\n;; `i128`.\n\n(rule (lower (has_type $I128 (rotr src amt)))\n      (let ((src_ ValueRegs src)\n            ;; NB: Only the low bits of `amt` matter since we logically mask the\n            ;; rotation amount to the value's bit width.\n            (amt_ Gpr (lo_gpr amt)))\n        (or_i128 (shr_i128 src_ amt_)\n                 (shl_i128 src_ (x64_sub $I64\n                                     (imm $I64 128)\n                                     amt_)))))\n\n;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (ineg x)))\n      (x64_neg ty x))\n\n(rule -2 (lower (has_type $I128 (ineg x)))\n      ;; Get the high/low registers for `x`.\n      (let ((regs ValueRegs x)\n            (lo Gpr (value_regs_get_gpr regs 0))\n            (hi Gpr (value_regs_get_gpr regs 1)))\n        ;; Do a neg followed by an sub-with-borrow.\n        (with_flags (x64_neg_paired $I64 lo)\n                    (x64_sbb_paired $I64 (imm $I64 0) hi))))\n\n;; SSE.\n\n(rule (lower (has_type $I8X16 (ineg x)))\n      (x64_psubb (imm $I8X16 0) x))\n\n(rule (lower (has_type $I16X8 (ineg x)))\n      (x64_psubw (imm $I16X8 0) x))\n\n(rule (lower (has_type $I32X4 (ineg x)))\n      (x64_psubd (imm $I32X4 0) x))\n\n(rule (lower (has_type $I64X2 (ineg x)))\n      (x64_psubq (imm $I64X2 0) x))\n\n;;;; Rules for `avg_round` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (multi_lane 8 16)\n                       (avg_round x y)))\n      (x64_pavgb x y))\n\n(rule (lower (has_type (multi_lane 16 8)\n                       (avg_round x y)))\n      (x64_pavgw x y))\n\n;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n;; Multiply two registers.\n(rule -5 (lower (has_type (fits_in_64 ty) (imul x y)))\n      (x64_mul ty x y))\n\n;; Handle multiplication where the lhs is an immediate or sinkable load in\n;; addition to the automatic rhs handling above.\n\n(rule -4 (lower (has_type (fits_in_64 ty)\n                       (imul (simm32_from_value x) y)))\n      (x64_mul ty y x))\n(rule -3 (lower (has_type (fits_in_64 ty)\n                       (imul (sinkable_load x) y)))\n      (x64_mul ty y x))\n\n;; `i128`.\n\n;; mul:\n;;   dst_lo = lhs_lo * rhs_lo\n;;   dst_hi = umulhi(lhs_lo, rhs_lo) +\n;;            lhs_lo * rhs_hi +\n;;            lhs_hi * rhs_lo\n;;\n;; so we emit:\n;;   lo_hi = mul x_lo, y_hi\n;;   hi_lo = mul x_hi, y_lo\n;;   hilo_hilo = add lo_hi, hi_lo\n;;   dst_lo:hi_lolo = mulhi_u x_lo, y_lo\n;;   dst_hi = add hilo_hilo, hi_lolo\n;;   return (dst_lo, dst_hi)\n(rule 2 (lower (has_type $I128 (imul x y)))\n      ;; Put `x` into registers and unpack its hi/lo halves.\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1))\n            ;; Put `y` into registers and unpack its hi/lo halves.\n            (y_regs ValueRegs y)\n            (y_lo Gpr (value_regs_get_gpr y_regs 0))\n            (y_hi Gpr (value_regs_get_gpr y_regs 1))\n            ;; lo_hi = mul x_lo, y_hi\n            (lo_hi Gpr (x64_mul $I64 x_lo y_hi))\n            ;; hi_lo = mul x_hi, y_lo\n            (hi_lo Gpr (x64_mul $I64 x_hi y_lo))\n            ;; hilo_hilo = add lo_hi, hi_lo\n            (hilo_hilo Gpr (x64_add $I64 lo_hi hi_lo))\n            ;; dst_lo:hi_lolo = mulhi_u x_lo, y_lo\n            (mul_regs ValueRegs (mulhi_u $I64 x_lo y_lo))\n            (dst_lo Gpr (value_regs_get_gpr mul_regs 0))\n            (hi_lolo Gpr (value_regs_get_gpr mul_regs 1))\n            ;; dst_hi = add hilo_hilo, hi_lolo\n            (dst_hi Gpr (x64_add $I64 hilo_hilo hi_lolo)))\n        (value_gprs dst_lo dst_hi)))\n\n;; SSE.\n\n;; (No i8x16 multiply.)\n\n(rule (lower (has_type (multi_lane 16 8) (imul x y)))\n      (x64_pmullw x y))\n\n(rule (lower (has_type (multi_lane 32 4) (imul x y)))\n      (if-let $true (use_sse41))\n      (x64_pmulld x y))\n\n;; Without `pmulld` the `pmuludq` instruction is used instead which performs\n;; 32-bit multiplication storing the 64-bit result. The 64-bit result is\n;; truncated to 32-bits and everything else is woven into place.\n(rule -1 (lower (has_type (multi_lane 32 4) (imul x y)))\n         (let (\n            (x Xmm x)\n            (y Xmm y)\n            (x_hi Xmm (x64_pshufd x 0b00_11_00_01))\n            (y_hi Xmm (x64_pshufd y 0b00_11_00_01))\n            (mul_lo Xmm (x64_pshufd (x64_pmuludq x y)       0b00_00_10_00))\n            (mul_hi Xmm (x64_pshufd (x64_pmuludq x_hi y_hi) 0b00_00_10_00))\n          )\n          (x64_punpckldq mul_lo mul_hi)))\n\n;; With AVX-512 we can implement `i64x2` multiplication with a single\n;; instruction.\n(rule 3 (lower (has_type (multi_lane 64 2) (imul x y)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512dq))\n      (x64_vpmullq x y))\n\n;; Otherwise, for i64x2 multiplication we describe a lane A as being composed of\n;; a 32-bit upper half \"Ah\" and a 32-bit lower half \"Al\". The 32-bit long hand\n;; multiplication can then be written as:\n;;\n;;    Ah Al\n;; *  Bh Bl\n;;    -----\n;;    Al * Bl\n;; + (Ah * Bl) << 32\n;; + (Al * Bh) << 32\n;;\n;; So for each lane we will compute:\n;;\n;;   A * B  = (Al * Bl) + ((Ah * Bl) + (Al * Bh)) << 32\n;;\n;; Note, the algorithm will use `pmuludq` which operates directly on the lower\n;; 32-bit (`Al` or `Bl`) of a lane and writes the result to the full 64-bits of\n;; the lane of the destination. For this reason we don't need shifts to isolate\n;; the lower 32-bits, however, we will need to use shifts to isolate the high\n;; 32-bits when doing calculations, i.e., `Ah == A >> 32`.\n(rule (lower (has_type (multi_lane 64 2)\n                       (imul a b)))\n      (let ((a0 Xmm a)\n            (b0 Xmm b)\n            ;; a_hi = A >> 32\n            (a_hi Xmm (x64_psrlq a0 (xmi_imm 32)))\n            ;; ah_bl = Ah * Bl\n            (ah_bl Xmm (x64_pmuludq a_hi b0))\n            ;; b_hi = B >> 32\n            (b_hi Xmm (x64_psrlq b0 (xmi_imm 32)))\n            ;; al_bh = Al * Bh\n            (al_bh Xmm (x64_pmuludq a0 b_hi))\n            ;; aa_bb = ah_bl + al_bh\n            (aa_bb Xmm (x64_paddq ah_bl al_bh))\n            ;; aa_bb_shifted = aa_bb << 32\n            (aa_bb_shifted Xmm (x64_psllq aa_bb (xmi_imm 32)))\n            ;; al_bl = Al * Bl\n            (al_bl Xmm (x64_pmuludq a0 b0)))\n        ;; al_bl + aa_bb_shifted\n        (x64_paddq al_bl aa_bb_shifted)))\n\n;; Special case for `i32x4.extmul_high_i16x8_s`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (swiden_high (and (value_type (multi_lane 16 8))\n                                               x))\n                             (swiden_high (and (value_type (multi_lane 16 8))\n                                               y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhw x2 y2)))\n        (x64_punpckhwd lo hi)))\n\n;; Special case for `i64x2.extmul_high_i32x4_s`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (swiden_high (and (value_type (multi_lane 32 4))\n                                               x))\n                             (swiden_high (and (value_type (multi_lane 32 4))\n                                               y)))))\n      (if-let $true (use_sse41))\n      (let ((x2 Xmm (x64_pshufd x 0xFA))\n            (y2 Xmm (x64_pshufd y 0xFA)))\n        (x64_pmuldq x2 y2)))\n\n;; Special case for `i32x4.extmul_low_i16x8_s`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (swiden_low (and (value_type (multi_lane 16 8))\n                                              x))\n                             (swiden_low (and (value_type (multi_lane 16 8))\n                                              y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhw x2 y2)))\n        (x64_punpcklwd lo hi)))\n\n;; Special case for `i64x2.extmul_low_i32x4_s`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (swiden_low (and (value_type (multi_lane 32 4))\n                                              x))\n                             (swiden_low (and (value_type (multi_lane 32 4))\n                                              y)))))\n      (if-let $true (use_sse41))\n      (let ((x2 Xmm (x64_pshufd x 0x50))\n            (y2 Xmm (x64_pshufd y 0x50)))\n        (x64_pmuldq x2 y2)))\n\n;; Special case for `i32x4.extmul_high_i16x8_u`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (uwiden_high (and (value_type (multi_lane 16 8))\n                                               x))\n                             (uwiden_high (and (value_type (multi_lane 16 8))\n                                               y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhuw x2 y2)))\n        (x64_punpckhwd lo hi)))\n\n;; Special case for `i64x2.extmul_high_i32x4_u`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (uwiden_high (and (value_type (multi_lane 32 4))\n                                               x))\n                             (uwiden_high (and (value_type (multi_lane 32 4))\n                                               y)))))\n      (let ((x2 Xmm (x64_pshufd x 0xFA))\n            (y2 Xmm (x64_pshufd y 0xFA)))\n        (x64_pmuludq x2 y2)))\n\n;; Special case for `i32x4.extmul_low_i16x8_u`.\n(rule 1 (lower (has_type (multi_lane 32 4)\n                       (imul (uwiden_low (and (value_type (multi_lane 16 8))\n                                              x))\n                             (uwiden_low (and (value_type (multi_lane 16 8))\n                                              y)))))\n      (let ((x2 Xmm x)\n            (y2 Xmm y)\n            (lo Xmm (x64_pmullw x2 y2))\n            (hi Xmm (x64_pmulhuw x2 y2)))\n        (x64_punpcklwd lo hi)))\n\n;; Special case for `i64x2.extmul_low_i32x4_u`.\n(rule 1 (lower (has_type (multi_lane 64 2)\n                       (imul (uwiden_low (and (value_type (multi_lane 32 4))\n                                              x))\n                             (uwiden_low (and (value_type (multi_lane 32 4))\n                                              y)))))\n      (let ((x2 Xmm (x64_pshufd x 0x50))\n            (y2 Xmm (x64_pshufd y 0x50)))\n        (x64_pmuludq x2 y2)))\n\n;;;; Rules for `iabs` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (has_type $I8X16 (iabs x)))\n        (if-let $true (use_ssse3))\n        (x64_pabsb x))\n\n;; Note the use of `pminub` with signed inputs will produce the positive signed\n;; result which is what is desired here. The `pmaxub` isn't available until\n;; SSE4.1 in which case the single-instruction above lowering would apply.\n(rule (lower (has_type $I8X16 (iabs x)))\n      (let (\n          (x Xmm x)\n          (negated Xmm (x64_psubb (xmm_zero $I8X16) x))\n        )\n        (x64_pminub x negated)))\n\n(rule 1 (lower (has_type $I16X8 (iabs x)))\n        (if-let $true (use_ssse3))\n        (x64_pabsw x))\n\n(rule (lower (has_type $I16X8 (iabs x)))\n      (let (\n          (x Xmm x)\n          (negated Xmm (x64_psubw (xmm_zero $I16X8) x))\n        )\n        (x64_pmaxsw x negated)))\n\n(rule 1 (lower (has_type $I32X4 (iabs x)))\n        (if-let $true (use_ssse3))\n        (x64_pabsd x))\n\n;; Generate a `negative_mask` which is either numerically -1 or 0 depending on\n;; if the lane is negative. If the lane is positive then the xor operation\n;; won't change the lane but otherwise it'll bit-flip everything. By then\n;; subtracting the mask this subtracts 0 for positive lanes (does nothing) or\n;; ends up adding one for negative lanes. This means that for a negative lane\n;; `x` the result is `!x + 1` which is the result of negating it.\n(rule (lower (has_type $I32X4 (iabs x)))\n      (let (\n          (x Xmm x)\n          (negative_mask Xmm (x64_psrad x (xmi_imm 31)))\n          (flipped_if_negative Xmm (x64_pxor x negative_mask))\n        )\n        (x64_psubd flipped_if_negative negative_mask)))\n\n;; When AVX512 is available, we can use a single `vpabsq` instruction.\n(rule 2 (lower (has_type $I64X2 (iabs x)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512f))\n      (x64_vpabsq x))\n\n;; Otherwise, we use a separate register, `neg`, to contain the results of `0 -\n;; x` and then blend in those results with `blendvpd` if the MSB of `neg` was\n;; set to 1 (i.e. if `neg` was negative or, conversely, if `x` was originally\n;; positive).\n(rule 1 (lower (has_type $I64X2 (iabs x)))\n        (if-let $true (use_sse41))\n        (let ((rx Xmm x)\n              (neg Xmm (x64_psubq (imm $I64X2 0) rx)))\n          (x64_blendvpd neg rx neg)))\n\n;; and if `blendvpd` isn't available then perform a shift/shuffle to generate a\n;; mask of which lanes are negative, followed by flipping bits/sub to make both\n;; positive.\n(rule (lower (has_type $I64X2 (iabs x)))\n      (let ((x Xmm x)\n            (signs Xmm (x64_psrad x (RegMemImm.Imm 31)))\n            (signs Xmm (x64_pshufd signs 0b11_11_01_01))\n            (xor_if_negative Xmm (x64_pxor x signs)))\n        (x64_psubq xor_if_negative signs)))\n\n;; `i64` and smaller.\n\n(rule -1 (lower (has_type (fits_in_64 ty) (iabs x)))\n      (let ((src Gpr x)\n            (neg ProducesFlags (x64_neg_paired ty src))\n            ;; Manually extract the result from the neg, then ignore\n            ;; it below, since we need to pass it into the cmove\n            ;; before we pass the cmove to with_flags_reg.\n            (neg_result Gpr (produces_flags_get_reg neg))\n            ;; When the neg instruction sets the sign flag,\n            ;; takes the original (non-negative) value.\n            (cmove ConsumesFlags (cmove ty (CC.S) src neg_result)))\n        (with_flags_reg (produces_flags_ignore neg) cmove)))\n\n;;;; Rules for `fabs` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fabs x)))\n      (x64_andps x (imm $F32 0x7fffffff)))\n\n(rule (lower (has_type $F64 (fabs x)))\n      (x64_andpd x (imm $F64 0x7fffffffffffffff)))\n\n;; Special case for `f32x4.abs`.\n(rule (lower (has_type $F32X4 (fabs x)))\n      (x64_andps x\n             (x64_psrld (vector_all_ones) (xmi_imm 1))))\n\n;; Special case for `f64x2.abs`.\n(rule (lower (has_type $F64X2 (fabs x)))\n      (x64_andpd x\n             (x64_psrlq (vector_all_ones) (xmi_imm 1))))\n\n;;;; Rules for `fneg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fneg x)))\n      (x64_xorps x (imm $F32 0x80000000)))\n\n(rule (lower (has_type $F64 (fneg x)))\n      (x64_xorpd x (imm $F64 0x8000000000000000)))\n\n(rule (lower (has_type $F32X4 (fneg x)))\n      (x64_xorps x\n             (x64_pslld (vector_all_ones) (xmi_imm 31))))\n\n(rule (lower (has_type $F64X2 (fneg x)))\n      (x64_xorpd x\n             (x64_psllq (vector_all_ones) (xmi_imm 63))))\n\n;;;; Rules for `bmask` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(decl lower_bmask (Type Type ValueRegs) ValueRegs)\n\n;; Values that fit in a register\n;;\n;; Use the neg instruction on the input which sets the CF (carry) flag\n;; to 0 if the input is 0 or 1 otherwise.\n;; We then subtract the output register with itself, which always gives a 0,\n;; however use the carry flag from the previous negate to generate a -1 if it\n;; was nonzero.\n;;\n;; neg in_reg\n;; sbb out_reg, out_reg\n(rule 0\n      (lower_bmask (fits_in_64 out_ty) (fits_in_64 in_ty) val)\n      (let ((reg Gpr (value_regs_get_gpr val 0))\n            (out ValueRegs (with_flags\n                  (x64_neg_paired in_ty reg)\n                  (x64_sbb_paired out_ty reg reg))))\n        ;; Extract only the output of the sbb instruction\n        (value_reg (value_regs_get out 1))))\n\n\n;; If the input type is I128 we can `or` the registers, and recurse to the general case.\n(rule 1\n      (lower_bmask (fits_in_64 out_ty) $I128 val)\n      (let ((lo Gpr (value_regs_get_gpr val 0))\n            (hi Gpr (value_regs_get_gpr val 1))\n            (mixed Gpr (x64_or $I64 lo hi)))\n        (lower_bmask out_ty $I64 (value_reg mixed))))\n\n;; If the output type is I128 we just duplicate the result of the I64 lowering\n(rule 2\n      (lower_bmask $I128 in_ty val)\n      (let ((res ValueRegs (lower_bmask $I64 in_ty val))\n            (res Gpr (value_regs_get_gpr res 0)))\n        (value_regs res res)))\n\n\n;; Call the lower_bmask rule that does all the procssing\n(rule (lower (has_type out_ty (bmask x @ (value_type in_ty))))\n      (lower_bmask out_ty in_ty x))\n\n;;;; Rules for `bnot` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(rule -2 (lower (has_type ty (bnot x)))\n      (if (ty_int_ref_scalar_64 ty))\n      (x64_not ty x))\n\n\n;; `i128`.\n\n(decl i128_not (Value) ValueRegs)\n(rule (i128_not x)\n      (let ((x_regs ValueRegs x)\n            (x_lo Gpr (value_regs_get_gpr x_regs 0))\n            (x_hi Gpr (value_regs_get_gpr x_regs 1)))\n        (value_gprs (x64_not $I64 x_lo)\n                    (x64_not $I64 x_hi))))\n\n(rule (lower (has_type $I128 (bnot x)))\n      (i128_not x))\n\n;; f32 and f64\n\n(rule -3 (lower (has_type (ty_scalar_float ty) (bnot x)))\n      (x64_xor_vector ty x (vector_all_ones)))\n\n;; Special case for vector-types where bit-negation is an xor against an\n;; all-one value\n(rule -1 (lower (has_type ty @ (multi_lane _bits _lanes) (bnot x)))\n      (x64_xor_vector ty x (vector_all_ones)))\n\n;;;; Rules for `bitselect` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type ty @ (multi_lane _bits _lanes)\n                       (bitselect condition\n                                  if_true\n                                  if_false)))\n      ;; a = and if_true, condition\n      ;; b = and_not condition, if_false\n      ;; or b, a\n      (let ((cond_xmm Xmm condition)\n            (a Xmm (sse_and ty if_true cond_xmm))\n            (b Xmm (sse_and_not ty cond_xmm if_false)))\n        (sse_or ty b a)))\n\n;; If every byte of the condition is guaranteed to be all ones or all zeroes,\n;; we can use x64_blend.\n(rule 1 (lower (has_type ty @ (multi_lane _bits _lanes)\n                         (bitselect condition\n                                    if_true\n                                    if_false)))\n      (if-let $true (use_sse41))\n      (if (all_ones_or_all_zeros condition))\n      (x64_pblendvb if_false if_true condition))\n\n(decl pure partial all_ones_or_all_zeros (Value) bool)\n(rule (all_ones_or_all_zeros (and (icmp _ _ _) (value_type (multi_lane _ _)))) $true)\n(rule (all_ones_or_all_zeros (and (fcmp _ _ _) (value_type (multi_lane _ _)))) $true)\n(rule (all_ones_or_all_zeros (vconst (vconst_all_ones_or_all_zeros))) $true)\n\n(decl pure vconst_all_ones_or_all_zeros () Constant)\n(extern extractor vconst_all_ones_or_all_zeros vconst_all_ones_or_all_zeros)\n\n;; Specializations for floating-pointer compares to generate a `minp*` or a\n;; `maxp*` instruction. These are equivalent to the wasm `f32x4.{pmin,pmax}`\n;; instructions and how they're lowered into CLIF. Note the careful ordering\n;; of all the operands here to ensure that the input CLIF matched is implemented\n;; by the corresponding x64 instruction.\n(rule 2 (lower (has_type $F32X4 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minps x y))\n(rule 2 (lower (has_type $F64X2 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minpd x y))\n\n(rule 3 (lower (has_type $F32X4 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxps x y))\n(rule 3 (lower (has_type $F64X2 (bitselect (bitcast _ (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxpd x y))\n\n;; Scalar rules\n\n(rule 3 (lower (has_type $I128 (bitselect c t f)))\n      (let ((a ValueRegs (and_i128 c t))\n            (b ValueRegs (and_i128 (i128_not c) f)))\n        (or_i128 a b)))\n\n(rule 4 (lower (has_type (ty_int_ref_scalar_64 ty) (bitselect c t f)))\n      (let ((a Gpr (x64_and ty c t))\n            (b Gpr (x64_and ty (x64_not ty c) f)))\n        (x64_or ty a b)))\n\n(rule 5 (lower (has_type (ty_scalar_float ty) (bitselect c t f)))\n      (let ((a Xmm (sse_and ty c t))\n            (c_neg Xmm (x64_xor_vector ty c (vector_all_ones)))\n            (b Xmm (sse_and ty c_neg f)))\n        (sse_or ty a b)))\n\n;;;; Rules for `x86_blendv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16\n                       (x86_blendv condition if_true if_false)))\n      (if-let $true (use_sse41))\n      (x64_pblendvb if_false if_true condition))\n\n(rule (lower (has_type $I32X4\n                       (x86_blendv condition if_true if_false)))\n      (if-let $true (use_sse41))\n      (x64_blendvps if_false if_true condition))\n\n(rule (lower (has_type $I64X2\n                       (x86_blendv condition if_true if_false)))\n      (if-let $true (use_sse41))\n      (x64_blendvpd if_false if_true condition))\n\n;;;; Rules for `insertlane` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (insertlane vec @ (value_type ty) val (u8_from_uimm8 idx)))\n      (vec_insert_lane ty vec val idx))\n\n;; Helper function used below for `insertlane` but also here for other\n;; lowerings.\n;;\n;; Note that the `Type` used here is the type of vector the insertion is\n;; happening into, or the type of the first `Reg` argument.\n(decl vec_insert_lane (Type Xmm RegMem u8) Xmm)\n\n;; i8x16.replace_lane\n(rule 1 (vec_insert_lane $I8X16 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_pinsrb vec val idx))\n\n;; This lowering is particularly unoptimized and is mostly just here to work\n;; rather than here to be fast. Requiring SSE 4.1 for the above lowering isn't\n;; the end of the world hopefully as that's a pretty old instruction set, so\n;; this is the \"simplest\" version that works on SSE2 for now.\n;;\n;; This lowering masks the original vector with a constant with all 1s except\n;; for the \"hole\" where this value will get placed into, meaning the desired\n;; lane is guaranteed as all 0s. Next the `val` is shuffled into this hole with\n;; a few operations:\n;;\n;;  1. The `val` is zero-extended to 32-bits to guarantee the lower 32-bits\n;;     are all defined.\n;;  2. An arithmetic shift-left is used with the low two bits of `n`, the\n;;     desired lane, to move the value into the right position within the 32-bit\n;;     register value.\n;;  3. The 32-bit register is moved with `movd` into an XMM register\n;;  4. The XMM register, where all lanes are 0 except for the first lane which\n;;     has the shifted value, is then shuffled with `pshufd` to move the\n;;     shifted value to the correct and final lane. This uses the upper two\n;;     bits of `n` to index the i32x4 lane that we're targeting.\n;;\n;; This all, laboriously, gets the `val` into the desired lane so it's then\n;; `por`'d with the original vec-with-a-hole to produce the final result of the\n;; insertion.\n(rule (vec_insert_lane $I8X16 vec val n)\n      (let ((vec_with_hole Xmm (x64_pand vec (insert_i8x16_lane_hole n)))\n            (val Gpr (x64_movzx (ExtMode.BL) val))\n            (val Gpr (x64_shl $I32 val (Imm8Reg.Imm8 (u8_shl (u8_and n 3) 3))))\n            (val Xmm (x64_movd_to_xmm val))\n            (val_at_hole Xmm (x64_pshufd val (insert_i8x16_lane_pshufd_imm (u8_shr n 2)))))\n        (x64_por vec_with_hole val_at_hole)))\n\n(decl insert_i8x16_lane_hole (u8) VCodeConstant)\n(extern constructor insert_i8x16_lane_hole insert_i8x16_lane_hole)\n(decl insert_i8x16_lane_pshufd_imm (u8) u8)\n(rule (insert_i8x16_lane_pshufd_imm 0) 0b01_01_01_00)\n(rule (insert_i8x16_lane_pshufd_imm 1) 0b01_01_00_01)\n(rule (insert_i8x16_lane_pshufd_imm 2) 0b01_00_01_01)\n(rule (insert_i8x16_lane_pshufd_imm 3) 0b00_01_01_01)\n\n;; i16x8.replace_lane\n(rule (vec_insert_lane $I16X8 vec val idx)\n      (x64_pinsrw vec val idx))\n\n;; i32x4.replace_lane\n(rule 1 (vec_insert_lane $I32X4 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_pinsrd vec val idx))\n\n(rule (vec_insert_lane $I32X4 vec val 0)\n      (x64_movss_regmove vec (x64_movd_to_xmm val)))\n\n;; tmp    = [ vec[1] vec[0] val[1] val[0] ]\n;; result = [ vec[3] vec[2] tmp[0] tmp[2] ]\n(rule (vec_insert_lane $I32X4 vec val 1)\n      (let ((val Xmm (x64_movd_to_xmm val))\n            (vec Xmm vec))\n        (x64_shufps (x64_punpcklqdq val vec) vec 0b11_10_00_10)))\n\n;; tmp    = [ vec[0] vec[3] val[0] val[0] ]\n;; result = [ tmp[2] tmp[0] vec[1] vec[0] ]\n(rule (vec_insert_lane $I32X4 vec val 2)\n      (let ((val Xmm (x64_movd_to_xmm val))\n            (vec Xmm vec))\n        (x64_shufps vec (x64_shufps val vec 0b00_11_00_00) 0b10_00_01_00)))\n\n;; tmp    = [ vec[3] vec[2] val[1] val[0] ]\n;; result = [ tmp[0] tmp[2] vec[1] vec[0] ]\n(rule (vec_insert_lane $I32X4 vec val 3)\n      (let ((val Xmm (x64_movd_to_xmm val))\n            (vec Xmm vec))\n        (x64_shufps vec (x64_shufps val vec 0b11_10_01_00) 0b00_10_01_00)))\n\n;; i64x2.replace_lane\n(rule 1 (vec_insert_lane $I64X2 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_pinsrq vec val idx))\n(rule (vec_insert_lane $I64X2 vec val 0)\n      (x64_movsd_regmove vec (x64_movq_to_xmm val)))\n(rule (vec_insert_lane $I64X2 vec val 1)\n      (x64_punpcklqdq vec (x64_movq_to_xmm val)))\n\n;; f32x4.replace_lane\n(rule 1 (vec_insert_lane $F32X4 vec val idx)\n        (if-let $true (use_sse41))\n        (x64_insertps vec val (sse_insertps_lane_imm idx)))\n\n;; f32x4.replace_lane 0 - without insertps\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 0)\n      (x64_movss_regmove vec val))\n\n;; f32x4.replace_lane 1 - without insertps\n;; tmp    = [ vec[1] vec[0] val[1] val[0] ]\n;; result = [ vec[3] vec[2] tmp[0] tmp[2] ]\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 1)\n      (let ((tmp Xmm (x64_movlhps val vec)))\n        (x64_shufps tmp vec 0b11_10_00_10)))\n\n;; f32x4.replace_lane 2 - without insertps\n;; tmp    = [ vec[0] vec[3] val[0] val[0] ]\n;; result = [ tmp[2] tmp[0] vec[1] vec[0] ]\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 2)\n      (let ((tmp Xmm (x64_shufps val vec 0b00_11_00_00)))\n        (x64_shufps vec tmp 0b10_00_01_00)))\n\n;; f32x4.replace_lane 3 - without insertps\n;; tmp    = [ vec[3] vec[2] val[1] val[0] ]\n;; result = [ tmp[0] tmp[2] vec[1] vec[0] ]\n(rule (vec_insert_lane $F32X4 vec (RegMem.Reg val) 3)\n      (let ((tmp Xmm (x64_shufps val vec 0b11_10_01_00)))\n        (x64_shufps vec tmp 0b00_10_01_00)))\n\n;; Recursively delegate to the above rules by loading from memory first.\n(rule (vec_insert_lane $F32X4 vec (RegMem.Mem addr) idx)\n      (vec_insert_lane $F32X4 vec (x64_movss_load addr) idx))\n\n;; External rust code used to calculate the immediate value to `insertps`.\n(decl sse_insertps_lane_imm (u8) u8)\n(extern constructor sse_insertps_lane_imm sse_insertps_lane_imm)\n\n;; f64x2.replace_lane 0\n;;\n;; Here the `movsd` instruction is used specifically to specialize moving\n;; into the fist lane where unlike above cases we're not using the lane\n;; immediate as an immediate to the instruction itself.\n(rule (vec_insert_lane $F64X2 vec (RegMem.Reg val) 0)\n      (x64_movsd_regmove vec val))\n(rule (vec_insert_lane $F64X2 vec (RegMem.Mem val) 0)\n      (x64_movsd_regmove vec (x64_movsd_load val)))\n\n;; f64x2.replace_lane 1\n;;\n;; Here the `movlhps` instruction is used specifically to specialize moving\n;; into the second lane where unlike above cases we're not using the lane\n;; immediate as an immediate to the instruction itself.\n(rule (vec_insert_lane $F64X2 vec val 1)\n      (x64_movlhps vec val))\n\n;;;; Rules for `smin`, `smax`, `umin`, `umax` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; `i64` and smaller.\n\n(decl cmp_and_choose (Type CC Value Value) ValueRegs)\n(rule (cmp_and_choose (fits_in_64 ty) cc x y)\n      (let ((size OperandSize (raw_operand_size_of_type ty))\n            ;; We need to put x and y in registers explicitly because\n            ;; we use the values more than once. Hence, even if these\n            ;; are \"unique uses\" at the CLIF level and would otherwise\n            ;; allow for load-op merging, here we cannot do that.\n            (x_reg Reg x)\n            (y_reg Reg y))\n        (with_flags_reg (x64_cmp size x_reg y_reg)\n                        (cmove ty cc y_reg x_reg))))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (umin x y)))\n      (cmp_and_choose ty (CC.B) x y))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (umax x y)))\n      (cmp_and_choose ty (CC.NB) x y))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (smin x y)))\n      (cmp_and_choose ty (CC.L) x y))\n\n(rule -1 (lower (has_type (fits_in_64 ty) (smax x y)))\n      (cmp_and_choose ty (CC.NL) x y))\n\n;; SSE helpers for determining if single-instruction lowerings are available.\n\n(decl pure has_pmins (Type) bool)\n(rule 1 (has_pmins $I16X8) $true)\n(rule 1 (has_pmins $I64X2) $false)\n(rule (has_pmins _) (use_sse41))\n\n(decl pure has_pmaxs (Type) bool)\n(rule 1 (has_pmaxs $I16X8) $true)\n(rule 1 (has_pmaxs $I64X2) $false)\n(rule (has_pmaxs _) (use_sse41))\n\n(decl pure has_pmaxu (Type) bool)\n(rule 1 (has_pmaxu $I8X16) $true)\n(rule 1 (has_pmaxu $I64X2) $false)\n(rule (has_pmaxu _) (use_sse41))\n\n(decl pure has_pminu (Type) bool)\n(rule 1 (has_pminu $I8X16) $true)\n(rule 1 (has_pminu $I64X2) $false)\n(rule (has_pminu _) (use_sse41))\n\n;; SSE `smax`.\n\n(rule (lower (has_type (ty_vec128 ty) (smax x y)))\n      (lower_vec_smax ty x y))\n\n(decl lower_vec_smax (Type Xmm Xmm) Xmm)\n(rule 1 (lower_vec_smax ty x y)\n        (if-let $true (has_pmaxs ty))\n        (x64_pmaxs ty x y))\n\n(rule (lower_vec_smax ty x y)\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (cmp Xmm (x64_pcmpgt ty x y))\n          (x_is_max Xmm (x64_pand cmp x))\n          (y_is_max Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_max y_is_max)))\n\n;; SSE `smin`.\n\n(rule 1 (lower (has_type (ty_vec128 ty) (smin x y)))\n        (if-let $true (has_pmins ty))\n        (x64_pmins ty x y))\n\n(rule (lower (has_type (ty_vec128 ty) (smin x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (cmp Xmm (x64_pcmpgt ty y x))\n          (x_is_min Xmm (x64_pand cmp x))\n          (y_is_min Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_min y_is_min)))\n\n;; SSE `umax`.\n\n(rule 2 (lower (has_type (ty_vec128 ty) (umax x y)))\n        (if-let $true (has_pmaxu ty))\n        (x64_pmaxu ty x y))\n\n;; If y < x then the saturating subtraction will be zero, otherwise when added\n;; back to x it'll return y.\n(rule 1 (lower (has_type $I16X8 (umax x y)))\n        (let ((x Xmm x))\n          (x64_paddw x (x64_psubusw y x))))\n\n;; Flip the upper bits of each lane so the signed comparison has the same\n;; result as a signed comparison, and then select the results with the output\n;; mask. See `pcmpgt` lowering for info on flipping the upper bit.\n(rule (lower (has_type (ty_vec128 ty) (umax x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (mask Xmm (flip_high_bit_mask ty))\n          (x_masked Xmm (x64_pxor x mask))\n          (y_masked Xmm (x64_pxor y mask))\n          (cmp Xmm (x64_pcmpgt ty x_masked y_masked))\n          (x_is_max Xmm (x64_pand cmp x))\n          (y_is_max Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_max y_is_max)))\n\n(decl flip_high_bit_mask (Type) Xmm)\n(rule (flip_high_bit_mask $I16X8)\n      (x64_movdqu_load (emit_u128_le_const 0x8000_8000_8000_8000_8000_8000_8000_8000)))\n(rule (flip_high_bit_mask $I32X4)\n      (x64_movdqu_load (emit_u128_le_const 0x80000000_80000000_80000000_80000000)))\n(rule (flip_high_bit_mask $I64X2)\n      (x64_movdqu_load (emit_u128_le_const 0x8000000000000000_8000000000000000)))\n\n;; SSE `umin`.\n\n(rule 2 (lower (has_type (ty_vec128 ty) (umin x y)))\n        (if-let $true (has_pminu ty))\n        (x64_pminu ty x y))\n\n;; If x < y then the saturating subtraction will be 0. Otherwise if x > y then\n;; the saturated result, when subtracted again, will go back to `y`.\n(rule 1 (lower (has_type $I16X8 (umin x y)))\n        (let ((x Xmm x))\n          (x64_psubw x (x64_psubusw x y))))\n\n;; Same as `umax`, and see `pcmpgt` for docs on flipping the upper bit.\n(rule (lower (has_type (ty_vec128 ty) (umin x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          (mask Xmm (flip_high_bit_mask ty))\n          (x_masked Xmm (x64_pxor x mask))\n          (y_masked Xmm (x64_pxor y mask))\n          (cmp Xmm (x64_pcmpgt ty y_masked x_masked))\n          (x_is_max Xmm (x64_pand cmp x))\n          (y_is_max Xmm (x64_pandn cmp y))\n        )\n        (x64_por x_is_max y_is_max)))\n\n;;;; Rules for `trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (trap code))\n      (side_effect (x64_ud2 code)))\n\n;;;; Rules for `uadd_overflow_trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (fits_in_64 ty) (uadd_overflow_trap a b tc)))\n      (with_flags\n        (x64_add_with_flags_paired ty a b)\n        (trap_if (CC.B) tc)))\n\n;; Handle lhs immediates/sinkable loads in addition to the automatic rhs\n;; handling of above.\n\n(rule 1 (lower (has_type (fits_in_64 ty)\n                         (uadd_overflow_trap (simm32_from_value a) b tc)))\n      (with_flags\n        (x64_add_with_flags_paired ty b a)\n        (trap_if (CC.B) tc)))\n\n(rule 2 (lower (has_type (fits_in_64 ty)\n                         (uadd_overflow_trap (sinkable_load a) b tc)))\n      (with_flags\n        (x64_add_with_flags_paired ty b a)\n        (trap_if (CC.B) tc)))\n\n;;;; Rules for `resumable_trap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (resumable_trap code))\n      (side_effect (x64_ud2 code)))\n\n;;;; Rules for `return` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; N.B.: the Ret itself is generated by the ABI.\n(rule (lower (return args))\n      (lower_return args))\n\n;;;; Rules for `icmp` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule -2 (lower (icmp cc a @ (value_type (fits_in_64 ty)) b))\n      (lower_icmp_bool (emit_cmp cc a b)))\n\n(rule -1 (lower (icmp cc a @ (value_type $I128) b))\n      (lower_icmp_bool (emit_cmp cc a b)))\n\n;; Peephole optimization for `x < 0`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThan) x @ (value_type $I64) (u64_from_iconst 0))))\n      (x64_shr $I64 x (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `0 > x`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThan) (u64_from_iconst 0) x @ (value_type $I64))))\n      (x64_shr $I64 x (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `0 <= x`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThanOrEqual) (u64_from_iconst 0) x @ (value_type $I64))))\n      (x64_shr $I64 (x64_not $I64 x) (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `x >= 0`, when x is a signed 64 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThanOrEqual) x @ (value_type $I64) (u64_from_iconst 0))))\n      (x64_shr $I64 (x64_not $I64 x) (Imm8Reg.Imm8 63)))\n\n;; Peephole optimization for `x < 0`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThan) x @ (value_type $I32) (u64_from_iconst 0))))\n      (x64_shr $I32 x (Imm8Reg.Imm8 31)))\n\n;; Peephole optimization for `0 > x`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThan) (u64_from_iconst 0) x @ (value_type $I32))))\n      (x64_shr $I32 x (Imm8Reg.Imm8 31)))\n\n;; Peephole optimization for `0 <= x`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedLessThanOrEqual) (u64_from_iconst 0) x @ (value_type $I32))))\n      (x64_shr $I32 (x64_not $I64 x) (Imm8Reg.Imm8 31)))\n\n;; Peephole optimization for `x >= 0`, when x is a signed 32 bit value\n(rule 2 (lower (has_type $I8 (icmp (IntCC.SignedGreaterThanOrEqual) x @ (value_type $I32) (u64_from_iconst 0))))\n      (x64_shr $I32 (x64_not $I64 x) (Imm8Reg.Imm8 31)))\n\n;; For XMM-held values, we lower to `PCMP*` instructions, sometimes more than\n;; one. To note: what is different here about the output values is that each\n;; lane will be filled with all 1s or all 0s according to the comparison,\n;; whereas for GPR-held values, the result will be simply 0 or 1 (upper bits\n;; unset).\n(rule (lower (icmp (IntCC.Equal) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pcmpeq ty a b))\n\n;; To lower a not-equals comparison, we perform an equality comparison\n;; (PCMPEQ*) and then invert the bits (PXOR with all 1s).\n(rule (lower (icmp (IntCC.NotEqual) a @ (value_type (ty_vec128 ty)) b))\n      (let ((checked Xmm (x64_pcmpeq ty a b))\n            (all_ones Xmm (vector_all_ones)))\n           (x64_pxor checked all_ones)))\n\n;; SSE `sgt`\n\n(rule (lower (icmp (IntCC.SignedGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pcmpgt ty a b))\n\n;; SSE `slt`\n\n(rule (lower (icmp (IntCC.SignedLessThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pcmpgt ty b a))\n\n;; SSE `ugt`\n\n;; N.B.: we must manually prevent load coalescing operands; the\n;; register allocator gets confused otherwise.\n(rule 1 (lower (icmp (IntCC.UnsignedGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmaxu ty))\n        (let ((a Xmm a)\n              (b Xmm b)\n              (max Xmm (x64_pmaxu ty a b))\n              (eq Xmm (x64_pcmpeq ty max b)))\n             (x64_pxor eq (vector_all_ones))))\n\n;; Flip the upper bit of each lane so the result of a signed comparison is the\n;; same as the result of an unsigned comparison (see docs on `pcmpgt` for more)\n(rule (lower (icmp (IntCC.UnsignedGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (let ((mask Xmm (flip_high_bit_mask ty))\n            (a_masked Xmm (x64_pxor a mask))\n            (b_masked Xmm (x64_pxor b mask)))\n           (x64_pcmpgt ty a_masked b_masked)))\n\n;; SSE `ult`\n\n(rule 1 (lower (icmp (IntCC.UnsignedLessThan) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pminu ty))\n        ;; N.B.: see note above.\n        (let ((a Xmm a)\n              (b Xmm b)\n              (min Xmm (x64_pminu ty a b))\n              (eq Xmm (x64_pcmpeq ty min b)))\n             (x64_pxor eq (vector_all_ones))))\n\n;; Flip the upper bit of `a` and `b` so the signed comparison result will\n;; be the same as the unsigned comparison result (see docs on `pcmpgt` for more).\n(rule (lower (icmp (IntCC.UnsignedLessThan) a @ (value_type (ty_vec128 ty)) b))\n      (let ((mask Xmm (flip_high_bit_mask ty))\n            (a_masked Xmm (x64_pxor a mask))\n            (b_masked Xmm (x64_pxor b mask)))\n           (x64_pcmpgt ty b_masked a_masked)))\n\n;; SSE `sge`\n\n;; Use `pmaxs*` and compare the result to `a` to see if it's `>= b`.\n(rule 1 (lower (icmp (IntCC.SignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmaxs ty))\n        (x64_pcmpeq ty a (x64_pmaxs ty a b)))\n\n;; Without `pmaxs*` use a `pcmpgt*` with reversed operands and invert the\n;; result.\n(rule (lower (icmp (IntCC.SignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pxor (x64_pcmpgt ty b a) (vector_all_ones)))\n\n;; SSE `sle`\n\n;; With `pmins*` use that and compare the result to `a`.\n(rule 1 (lower (icmp (IntCC.SignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmins ty))\n        (x64_pcmpeq ty a (x64_pmins ty a b)))\n\n;; Without `pmins*` perform a greater-than test and invert the result.\n(rule (lower (icmp (IntCC.SignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_pxor (x64_pcmpgt ty a b) (vector_all_ones)))\n\n;; SSE `uge`\n\n(rule 2 (lower (icmp (IntCC.UnsignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pmaxu ty))\n        (x64_pcmpeq ty a (x64_pmaxu ty a b)))\n\n;; Perform a saturating subtract of `a` from `b` and if the result is zero then\n;; `a` is greater or equal.\n(rule 1 (lower (icmp (IntCC.UnsignedGreaterThanOrEqual) a @ (value_type $I16X8) b))\n         (x64_pcmpeqw (x64_psubusw b a) (xmm_zero $I16X8)))\n\n;; Flip the upper bit of each lane so the signed comparison is the same as\n;; an unsigned one and then invert the result. See docs on `pcmpgt` for why\n;; flipping the upper bit works.\n(rule (lower (icmp (IntCC.UnsignedGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (let (\n          (mask Xmm (flip_high_bit_mask ty))\n          (a_masked Xmm (x64_pxor a mask))\n          (b_masked Xmm (x64_pxor b mask))\n          (cmp Xmm (x64_pcmpgt ty b_masked a_masked))\n        )\n        (x64_pxor cmp (vector_all_ones))))\n\n;; SSE `ule`\n\n(rule 2 (lower (icmp (IntCC.UnsignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n        (if-let $true (has_pminu ty))\n        (x64_pcmpeq ty a (x64_pminu ty a b)))\n\n;; A saturating subtraction will produce zeros if `a` is less than `b`, so\n;; compare that result to an all-zeros result to figure out lanes of `a` that\n;; are <= to the lanes in `b`\n(rule 1 (lower (icmp (IntCC.UnsignedLessThanOrEqual) a @ (value_type $I16X8) b))\n        (let ((zeros_if_a_is_min Xmm (x64_psubusw a b)))\n            (x64_pcmpeqw zeros_if_a_is_min (xmm_zero $I8X16))))\n\n;; Flip the upper bit of each lane in `a` and `b` so a signed comparison\n;; produces the same result as an unsigned comparison. Then test test for `gt`\n;; and invert the result to get the `le` that is desired here. See docs on\n;; `pcmpgt` for why flipping the upper bit works.\n(rule (lower (icmp (IntCC.UnsignedLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (let (\n          (mask Xmm (flip_high_bit_mask ty))\n          (a_masked Xmm (x64_pxor a mask))\n          (b_masked Xmm (x64_pxor b mask))\n          (cmp Xmm (x64_pcmpgt ty a_masked b_masked))\n        )\n        (x64_pxor cmp (vector_all_ones))))\n\n;;;; Rules for `fcmp` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; CLIF's `fcmp` instruction always operates on XMM registers--both scalar and\n;; vector. For the scalar versions, we use the flag-setting behavior of the\n;; `UCOMIS*` instruction to `SETcc` a 0 or 1 in a GPR register. Note that CLIF's\n;; `select` uses the same kind of flag-setting behavior but chooses values other\n;; than 0 or 1.\n;;\n;; Checking the result of `UCOMIS*` is unfortunately difficult in some cases\n;; because we do not have `SETcc` instructions that explicitly check\n;; simultaneously for the condition (i.e., `eq`, `le`, `gt`, etc.) *and*\n;; orderedness. Instead, we must check the flags multiple times. The UCOMIS*\n;; documentation (see Intel's Software Developer's Manual, volume 2, chapter 4)\n;; is helpful:\n;;  - unordered assigns    Z = 1, P = 1, C = 1\n;;  - greater than assigns Z = 0, P = 0, C = 0\n;;  - less than assigns    Z = 0, P = 0, C = 1\n;;  - equal assigns        Z = 1, P = 0, C = 0\n\n(rule -1 (lower (fcmp cc a @ (value_type (ty_scalar_float ty)) b))\n      (lower_fcmp_bool (emit_fcmp cc a b)))\n\n;; For vector lowerings, we use `CMPP*` instructions with a 3-bit operand that\n;; determines the comparison to make. Note that comparisons that succeed will\n;; fill the lane with 1s; comparisons that do not will fill the lane with 0s.\n\n(rule (lower (fcmp (FloatCC.Equal) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.Equal)))\n(rule (lower (fcmp (FloatCC.NotEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.NotEqual)))\n(rule (lower (fcmp (FloatCC.LessThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.LessThan)))\n(rule (lower (fcmp (FloatCC.LessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.LessThanOrEqual)))\n(rule (lower (fcmp (FloatCC.Ordered) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.Ordered)))\n(rule (lower (fcmp (FloatCC.Unordered) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.Unordered)))\n(rule (lower (fcmp (FloatCC.UnorderedOrGreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.UnorderedOrGreaterThan)))\n(rule (lower (fcmp (FloatCC.UnorderedOrGreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty a b (FcmpImm.UnorderedOrGreaterThanOrEqual)))\n\n;; Some vector lowerings rely on flipping the operands and using a reversed\n;; comparison code.\n\n(rule (lower (fcmp (FloatCC.GreaterThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.LessThan)))\n(rule (lower (fcmp (FloatCC.GreaterThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.LessThanOrEqual)))\n(rule (lower (fcmp (FloatCC.UnorderedOrLessThan) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.UnorderedOrGreaterThan)))\n(rule (lower (fcmp (FloatCC.UnorderedOrLessThanOrEqual) a @ (value_type (ty_vec128 ty)) b))\n      (x64_cmpp ty b a (FcmpImm.UnorderedOrGreaterThanOrEqual)))\n\n;; Some vector lowerings are simply not supported for certain codes:\n;; - FloatCC::OrderedNotEqual\n;; - FloatCC::UnorderedOrEqual\n\n;;;; Rules for `select` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; When a `select` has an `fcmp` as a condition then rely on `emit_fcmp` to\n;; figure out how to perform the comparison.\n;;\n;; Note, though, that the `FloatCC.Equal` requires an \"and\" to happen for two\n;; condition codes which isn't the easiest thing to lower to a `cmove`\n;; instruction. For this reason a `select (fcmp eq ..) ..` is instead\n;; flipped around to be `select (fcmp ne ..) ..` with all operands reversed.\n;; This will produce a `FcmpCondResult.OrCondition` which is easier to codegen\n;; for.\n(rule (lower (has_type ty (select (maybe_uextend (fcmp cc a b)) x y)))\n      (lower_select_fcmp ty (emit_fcmp cc a b) x y))\n(rule 1 (lower (has_type ty (select (maybe_uextend (fcmp (FloatCC.Equal) a b)) x y)))\n        (lower_select_fcmp ty (emit_fcmp (FloatCC.NotEqual) a b) y x))\n\n(decl lower_select_fcmp (Type FcmpCondResult Value Value) InstOutput)\n(rule (lower_select_fcmp ty (FcmpCondResult.Condition flags cc) x y)\n      (with_flags flags (cmove_from_values ty cc x y)))\n(rule (lower_select_fcmp ty (FcmpCondResult.OrCondition flags cc1 cc2) x y)\n      (with_flags flags (cmove_or_from_values ty cc1 cc2 x y)))\n\n;; We also can lower `select`s that depend on an `icmp` test, but more simply\n;; than the `fcmp` variants above. In these cases, we lower to a `CMP`\n;; instruction plus a `CMOV`; recall that `cmove_from_values` here may emit more\n;; than one instruction for certain types (e.g., XMM-held, I128).\n\n(rule (lower (has_type ty (select (maybe_uextend (icmp cc a @ (value_type (fits_in_64 a_ty)) b)) x y)))\n      (let ((size OperandSize (raw_operand_size_of_type a_ty)))\n           (with_flags (x64_cmp size b a) (cmove_from_values ty cc x y))))\n\n;; Finally, we lower `select` from a condition value `c`. These rules are meant\n;; to be the final, default lowerings if no other patterns matched above.\n\n(rule -1 (lower (has_type ty (select c @ (value_type (fits_in_64 a_ty)) x y)))\n      (let ((size OperandSize (raw_operand_size_of_type a_ty))\n            ;; N.B.: disallow load-op fusion, see above. TODO:\n            ;; https://github.com/bytecodealliance/wasmtime/issues/3953.\n            (gpr_c Gpr (put_in_gpr c)))\n           (with_flags (x64_test size gpr_c gpr_c) (cmove_from_values ty (CC.NZ) x y))))\n\n(rule -2 (lower (has_type ty (select c @ (value_type $I128) x y)))\n      (let ((cond_result IcmpCondResult (cmp_zero_i128 (CC.Z) c)))\n        (select_icmp cond_result x y)))\n\n;; Specializations for floating-point compares to generate a `mins*` or a\n;; `maxs*` instruction. These are equivalent to the \"pseudo-m{in,ax}\"\n;; specializations for vectors.\n(rule 2 (lower (has_type $F32 (select (maybe_uextend (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minss x y))\n(rule 2 (lower (has_type $F64 (select (maybe_uextend (fcmp (FloatCC.LessThan) x y)) x y)))\n        (x64_minsd x y))\n(rule 3 (lower (has_type $F32 (select (maybe_uextend (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxss x y))\n(rule 3 (lower (has_type $F64 (select (maybe_uextend (fcmp (FloatCC.LessThan) y x)) x y)))\n        (x64_maxsd x y))\n\n;; Rules for `clz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; If available, we can use a plain lzcnt instruction here. Note no\n;; special handling is required for zero inputs, because the machine\n;; instruction does what the CLIF expects for zero, i.e. it returns\n;; zero.\n(rule 3 (lower (has_type (ty_32_or_64 ty) (clz src)))\n      (if-let $true (use_lzcnt))\n      (x64_lzcnt ty src))\n\n(rule 2 (lower (has_type (ty_32_or_64 ty) (clz src)))\n      (do_clz ty ty src))\n\n(rule 1 (lower\n       (has_type (ty_8_or_16 ty)\n                 (clz src)))\n      (do_clz $I32 ty (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule 0 (lower\n       (has_type $I128\n                 (clz src)))\n      (let ((upper Gpr (do_clz $I64 $I64 (value_regs_get_gpr src 1)))\n            (lower Gpr (x64_add $I64\n                            (do_clz $I64 $I64 (value_regs_get_gpr src 0))\n                            (RegMemImm.Imm 64)))\n            (result_lo Gpr\n              (with_flags_reg\n               (x64_cmp_imm (OperandSize.Size64) 64 upper)\n               (cmove $I64 (CC.NZ) upper lower))))\n        (value_regs result_lo (imm $I64 0))))\n\n;; Implementation helper for clz; operates on 32 or 64-bit units.\n(decl do_clz (Type Type Gpr) Gpr)\n(rule (do_clz ty orig_ty src)\n      (let ((highest_bit_index Reg (bsr_or_else ty src (imm_i64 $I64 -1)))\n            (bits_minus_1 Reg (imm ty (u64_sub (ty_bits_u64 orig_ty) 1))))\n        (x64_sub ty bits_minus_1 highest_bit_index)))\n\n;; Rules for `ctz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Analogous to `clz` cases above, but using mirror instructions\n;; (tzcnt vs lzcnt, bsf vs bsr).\n\n(rule 3 (lower (has_type (ty_32_or_64 ty) (ctz src)))\n      (if-let $true (use_bmi1))\n      (x64_tzcnt ty src))\n\n(rule 2 (lower (has_type (ty_32_or_64 ty) (ctz src)))\n      (do_ctz ty ty src))\n\n(rule 1 (lower\n       (has_type (ty_8_or_16 ty)\n                 (ctz src)))\n      (do_ctz $I32 ty (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule 0 (lower\n       (has_type $I128\n                 (ctz src)))\n      (let ((lower Gpr (do_ctz $I64 $I64 (value_regs_get_gpr src 0)))\n            (upper Gpr (x64_add $I64\n                            (do_ctz $I64 $I64 (value_regs_get_gpr src 1))\n                            (RegMemImm.Imm 64)))\n            (result_lo Gpr\n              (with_flags_reg\n               (x64_cmp_imm (OperandSize.Size64) 64 lower)\n               (cmove $I64 (CC.Z) upper lower))))\n        (value_regs result_lo (imm $I64 0))))\n\n(decl do_ctz (Type Type Gpr) Gpr)\n(rule (do_ctz ty orig_ty src)\n      (bsf_or_else ty src (imm $I64 (ty_bits_u64 orig_ty))))\n\n;; Rules for `popcnt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 4 (lower (has_type (ty_32_or_64 ty) (popcnt src)))\n      (if-let $true (use_popcnt))\n      (x64_popcnt ty src))\n\n(rule 3 (lower (has_type (ty_8_or_16 ty) (popcnt src)))\n      (if-let $true (use_popcnt))\n      (x64_popcnt $I32 (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule 1 (lower (has_type $I128 (popcnt src)))\n      (if-let $true (use_popcnt))\n      (let ((lo_count Gpr (x64_popcnt $I64 (value_regs_get_gpr src 0)))\n            (hi_count Gpr (x64_popcnt $I64 (value_regs_get_gpr src 1))))\n        (value_regs (x64_add $I64 lo_count hi_count) (imm $I64 0))))\n\n(rule -1 (lower\n       (has_type (ty_32_or_64 ty)\n                 (popcnt src)))\n      (do_popcnt ty src))\n\n(rule -2 (lower\n       (has_type (ty_8_or_16 ty)\n                 (popcnt src)))\n      (do_popcnt $I32 (extend_to_gpr src $I32 (ExtendKind.Zero))))\n\n(rule (lower\n       (has_type $I128\n                 (popcnt src)))\n      (let ((lo_count Gpr (do_popcnt $I64 (value_regs_get_gpr src 0)))\n            (hi_count Gpr (do_popcnt $I64 (value_regs_get_gpr src 1))))\n        (value_regs (x64_add $I64 lo_count hi_count) (imm $I64 0))))\n\n;; Implementation of popcount when we don't nave a native popcount\n;; instruction.\n(decl do_popcnt (Type Gpr) Gpr)\n(rule (do_popcnt $I64 src)\n      (let ((shifted1 Gpr (x64_shr $I64 src (Imm8Reg.Imm8 1)))\n            (sevens Gpr (imm $I64 0x7777777777777777))\n            (masked1 Gpr (x64_and $I64 shifted1 sevens))\n            ;; diff1 := src - ((src >> 1) & 0b0111_0111_0111...)\n            (diff1 Gpr (x64_sub $I64 src masked1))\n            (shifted2 Gpr (x64_shr $I64 masked1 (Imm8Reg.Imm8 1)))\n            (masked2 Gpr (x64_and $I64 shifted2 sevens))\n            ;; diff2 := diff1 - ((diff1 >> 1) & 0b0111_0111_0111...)\n            (diff2 Gpr (x64_sub $I64 diff1 masked2))\n            (shifted3 Gpr (x64_shr $I64 masked2 (Imm8Reg.Imm8 1)))\n            (masked3 Gpr (x64_and $I64 shifted3 sevens))\n            ;; diff3 := diff2 - ((diff2 >> 1) & 0b0111_0111_0111...)\n            ;;\n            ;; At this point, each nibble of diff3 is the popcount of\n            ;; that nibble. This works because at each step above, we\n            ;; are basically subtracting floor(value / 2) from the\n            ;; running value; the leftover remainder is 1 if the LSB\n            ;; was 1. After three steps, we have (nibble / 8) -- 0 or\n            ;; 1 for the MSB of the nibble -- plus three possible\n            ;; additions for the three other bits.\n            (diff3 Gpr (x64_sub $I64 diff2 masked3))\n            ;; Add the two nibbles of each byte together.\n            (sum1 Gpr (x64_add $I64\n                           (x64_shr $I64 diff3 (Imm8Reg.Imm8 4))\n                           diff3))\n            ;; Mask the above sum to have the popcount for each byte\n            ;; in the lower nibble of that byte.\n            (ofof Gpr (imm $I64 0x0f0f0f0f0f0f0f0f))\n            (masked4 Gpr (x64_and $I64 sum1 ofof))\n            (ones Gpr (imm $I64 0x0101010101010101))\n            ;; Use a multiply to sum all of the bytes' popcounts into\n            ;; the top byte. Consider the binomial expansion for the\n            ;; top byte: it is the sum of the bytes (masked4 >> 56) *\n            ;; 0x01 + (masked4 >> 48) * 0x01 + (masked4 >> 40) * 0x01\n            ;; + ... + (masked4 >> 0).\n            (mul Gpr (x64_mul $I64 masked4 ones))\n            ;; Now take that top byte and return it as the popcount.\n            (final Gpr (x64_shr $I64 mul (Imm8Reg.Imm8 56))))\n        final))\n\n;; This is the 32-bit version of the above; the steps for each nibble\n;; are the same, we just use constants half as wide.\n(rule (do_popcnt $I32 src)\n      (let ((shifted1 Gpr (x64_shr $I32 src (Imm8Reg.Imm8 1)))\n            (sevens Gpr (imm $I32 0x77777777))\n            (masked1 Gpr (x64_and $I32 shifted1 sevens))\n            (diff1 Gpr (x64_sub $I32 src masked1))\n            (shifted2 Gpr (x64_shr $I32 masked1 (Imm8Reg.Imm8 1)))\n            (masked2 Gpr (x64_and $I32 shifted2 sevens))\n            (diff2 Gpr (x64_sub $I32 diff1 masked2))\n            (shifted3 Gpr (x64_shr $I32 masked2 (Imm8Reg.Imm8 1)))\n            (masked3 Gpr (x64_and $I32 shifted3 sevens))\n            (diff3 Gpr (x64_sub $I32 diff2 masked3))\n            (sum1 Gpr (x64_add $I32\n                           (x64_shr $I32 diff3 (Imm8Reg.Imm8 4))\n                           diff3))\n            (masked4 Gpr (x64_and $I32 sum1 (RegMemImm.Imm 0x0f0f0f0f)))\n            (mul Gpr (x64_mul $I32 masked4 (RegMemImm.Imm 0x01010101)))\n            (final Gpr (x64_shr $I32 mul (Imm8Reg.Imm8 24))))\n        final))\n\n\n(rule 2 (lower (has_type $I8X16 (popcnt src)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512bitalg))\n      (x64_vpopcntb src))\n\n\n;; For SSE 4.2 we use Mula's algorithm (https://arxiv.org/pdf/1611.07612.pdf):\n;;\n;; __m128i count_bytes ( __m128i v) {\n;;     __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n;;     __m128i low_mask = _mm_set1_epi8 (0x0f);\n;;     __m128i lo = _mm_and_si128 (v, low_mask);\n;;     __m128i hi = _mm_and_si128 (_mm_srli_epi16 (v, 4), low_mask);\n;;     __m128i cnt1 = _mm_shuffle_epi8 (lookup, lo);\n;;     __m128i cnt2 = _mm_shuffle_epi8 (lookup, hi);\n;;     return _mm_add_epi8 (cnt1, cnt2);\n;; }\n;;\n;; Details of the above algorithm can be found in the reference noted above, but the basics\n;; are to create a lookup table that pre populates the popcnt values for each number [0,15].\n;; The algorithm uses shifts to isolate 4 bit sections of the vector, pshufb as part of the\n;; lookup process, and adds together the results.\n;;\n;; __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n\n\n(rule 1 (lower (has_type $I8X16 (popcnt src)))\n      (if-let $true (use_ssse3))\n      (let ((low_mask XmmMem (emit_u128_le_const 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f))\n            (low_nibbles Xmm (sse_and $I8X16 src low_mask))\n            ;; Note that this is a 16x8 shift, but that's OK; we mask\n            ;; off anything that traverses from one byte to the next\n            ;; with the low_mask below.\n            (shifted_src Xmm (x64_psrlw src (xmi_imm 4)))\n            (high_nibbles Xmm (sse_and $I8X16 shifted_src low_mask))\n            (lookup Xmm (x64_xmm_load_const $I8X16\n              (emit_u128_le_const 0x04030302_03020201_03020201_02010100)))\n            (bit_counts_low Xmm (x64_pshufb lookup low_nibbles))\n            (bit_counts_high Xmm (x64_pshufb lookup high_nibbles)))\n        (x64_paddb bit_counts_low bit_counts_high)))\n\n;; A modified version of the popcnt method from Hacker's Delight.\n(rule (lower (has_type $I8X16 (popcnt src)))\n      (let ((mask1 XmmMem (emit_u128_le_const 0x77777777777777777777777777777777))\n            (src Xmm src)\n            (shifted Xmm (x64_pand (x64_psrlq src (xmi_imm 1)) mask1))\n            (src Xmm (x64_psubb src shifted))\n            (shifted Xmm (x64_pand (x64_psrlq shifted (xmi_imm 1)) mask1))\n            (src Xmm (x64_psubb src shifted))\n            (shifted Xmm (x64_pand (x64_psrlq shifted (xmi_imm 1)) mask1))\n            (src Xmm (x64_psubb src shifted))\n            (src Xmm (x64_paddb src (x64_psrlw src (xmi_imm 4)))))\n        (x64_pand src (emit_u128_le_const 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f))))\n\n;; Rules for `bitrev` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8 (bitrev src)))\n      (do_bitrev8 $I32 src))\n\n(rule (lower (has_type $I16 (bitrev src)))\n      (do_bitrev16 $I32 src))\n\n(rule (lower (has_type $I32 (bitrev src)))\n      (do_bitrev32 $I32 src))\n\n(rule (lower (has_type $I64 (bitrev src)))\n      (do_bitrev64 $I64 src))\n\n(rule (lower (has_type $I128 (bitrev src)))\n      (value_regs\n       (do_bitrev64 $I64 (value_regs_get_gpr src 1))\n       (do_bitrev64 $I64 (value_regs_get_gpr src 0))))\n\n(decl do_bitrev8 (Type Gpr) Gpr)\n(rule (do_bitrev8 ty src)\n      (let ((tymask u64 (ty_mask ty))\n            (mask1 Gpr (imm ty (u64_and tymask 0x5555555555555555)))\n            (lo1 Gpr (x64_and ty src mask1))\n            (hi1 Gpr (x64_and ty (x64_shr ty src (Imm8Reg.Imm8 1)) mask1))\n            (swap1 Gpr (x64_or ty\n                           (x64_shl ty lo1 (Imm8Reg.Imm8 1))\n                           hi1))\n            (mask2 Gpr (imm ty (u64_and tymask 0x3333333333333333)))\n            (lo2 Gpr (x64_and ty swap1 mask2))\n            (hi2 Gpr (x64_and ty (x64_shr ty swap1 (Imm8Reg.Imm8 2)) mask2))\n            (swap2 Gpr (x64_or ty\n                           (x64_shl ty lo2 (Imm8Reg.Imm8 2))\n                           hi2))\n            (mask4 Gpr (imm ty (u64_and tymask 0x0f0f0f0f0f0f0f0f)))\n            (lo4 Gpr (x64_and ty swap2 mask4))\n            (hi4 Gpr (x64_and ty (x64_shr ty swap2 (Imm8Reg.Imm8 4)) mask4))\n            (swap4 Gpr (x64_or ty\n                           (x64_shl ty lo4 (Imm8Reg.Imm8 4))\n                           hi4)))\n        swap4))\n\n(decl do_bitrev16 (Type Gpr) Gpr)\n(rule (do_bitrev16 ty src)\n      (let ((src_ Gpr (do_bitrev8 ty src))\n            (tymask u64 (ty_mask ty))\n            (mask8 Gpr (imm ty (u64_and tymask 0x00ff00ff00ff00ff)))\n            (lo8 Gpr (x64_and ty src_ mask8))\n            (hi8 Gpr (x64_and ty (x64_shr ty src_ (Imm8Reg.Imm8 8)) mask8))\n            (swap8 Gpr (x64_or ty\n                           (x64_shl ty lo8 (Imm8Reg.Imm8 8))\n                           hi8)))\n        swap8))\n\n(decl do_bitrev32 (Type Gpr) Gpr)\n(rule (do_bitrev32 ty src)\n      (let ((src_ Gpr (do_bitrev16 ty src))\n            (tymask u64 (ty_mask ty))\n            (mask16 Gpr (imm ty (u64_and tymask 0x0000ffff0000ffff)))\n            (lo16 Gpr (x64_and ty src_ mask16))\n            (hi16 Gpr (x64_and ty (x64_shr ty src_ (Imm8Reg.Imm8 16)) mask16))\n            (swap16 Gpr (x64_or ty\n                            (x64_shl ty lo16 (Imm8Reg.Imm8 16))\n                            hi16)))\n        swap16))\n\n(decl do_bitrev64 (Type Gpr) Gpr)\n(rule (do_bitrev64 ty @ $I64 src)\n      (let ((src_ Gpr (do_bitrev32 ty src))\n            (mask32 Gpr (imm ty 0xffffffff))\n            (lo32 Gpr (x64_and ty src_ mask32))\n            (hi32 Gpr (x64_shr ty src_ (Imm8Reg.Imm8 32)))\n            (swap32 Gpr (x64_or ty\n                            (x64_shl ty lo32 (Imm8Reg.Imm8 32))\n                            hi32)))\n        swap32))\n\n;; Rules for `bswap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; x64 bswap instruction is only for 32- or 64-bit swaps\n;; implement the 16-bit swap as a rotl by 8\n(rule (lower (has_type $I16 (bswap src)))\n      (x64_rotl $I16 src (Imm8Reg.Imm8 8)))\n\n(rule (lower (has_type $I32 (bswap src)))\n      (x64_bswap $I32 src))\n\n(rule (lower (has_type $I64 (bswap src)))\n      (x64_bswap $I64 src))\n\n(rule (lower (has_type $I128 (bswap src)))\n      (value_regs\n       (x64_bswap $I64 (value_regs_get_gpr src 1))\n       (x64_bswap $I64 (value_regs_get_gpr src 0))))\n\n;; Rules for `is_null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Null references are represented by the constant value `0`.\n(rule (lower (is_null src @ (value_type $R64)))\n      (with_flags\n       (x64_cmp_imm (OperandSize.Size64) 0 src)\n       (x64_setcc (CC.Z))))\n\n;; Rules for `is_invalid` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Invalid references are represented by the constant value `-1`.\n(rule (lower (is_invalid src @ (value_type $R64)))\n      (with_flags\n       (x64_cmp_imm (OperandSize.Size64) 0xffffffff src)  ;; simm32 0xffff_ffff is sign-extended to -1.\n       (x64_setcc (CC.Z))))\n\n\n;; Rules for `uextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; I{8,16,32,64} -> I128.\n(rule (lower (has_type $I128 (uextend src)))\n      (value_regs (extend_to_gpr src $I64 (ExtendKind.Zero)) (imm $I64 0)))\n\n;; I{8,16,32} -> I64.\n(rule (lower (has_type $I64 (uextend src)))\n      (extend_to_gpr src $I64 (ExtendKind.Zero)))\n\n;; I{8,16} -> I32\n;; I8 -> I16\n(rule -1 (lower (has_type (fits_in_32 _) (uextend src)))\n         (extend_to_gpr src $I32 (ExtendKind.Zero)))\n\n;; Rules for `sextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; I{8,16,32} -> I128.\n;;\n;; Produce upper 64 bits sign-extended from lower 64: shift right by\n;; 63 bits to spread the sign bit across the result.\n(rule (lower (has_type $I128 (sextend src)))\n      (let ((lo Gpr (extend_to_gpr src $I64 (ExtendKind.Sign)))\n            (hi Gpr (x64_sar $I64 lo (Imm8Reg.Imm8 63))))\n      (value_regs lo hi)))\n\n;; I{8,16,32} -> I64.\n(rule (lower (has_type $I64 (sextend src)))\n      (extend_to_gpr src $I64 (ExtendKind.Sign)))\n\n;; I{8,16} -> I32\n;; I8 -> I16\n(rule -1 (lower (has_type (fits_in_32 _) (sextend src)))\n         (extend_to_gpr src $I32 (ExtendKind.Sign)))\n\n;; Rules for `ireduce` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; T -> T is always a no-op, even I128 -> I128.\n(rule (lower (has_type ty (ireduce src @ (value_type ty))))\n      src)\n\n;; T -> I{64,32,16,8}: We can simply pass through the value: values\n;; are always stored with high bits undefined, so we can just leave\n;; them be.\n(rule 1 (lower (has_type (fits_in_64 ty) (ireduce src)))\n      (value_regs_get_gpr src 0))\n\n;; Rules for `debugtrap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (debugtrap))\n      (side_effect (x64_hlt)))\n\n;; Rules for `x86_pmaddubsw` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I16X8 (x86_pmaddubsw x y)))\n      (if-let $true (use_ssse3))\n      (x64_pmaddubsw y x))\n\n;; Rules for `fadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fadd x y)))\n      (x64_addss x y))\n(rule (lower (has_type $F64 (fadd x y)))\n      (x64_addsd x y))\n(rule (lower (has_type $F32X4 (fadd x y)))\n      (x64_addps x y))\n(rule (lower (has_type $F64X2 (fadd x y)))\n      (x64_addpd x y))\n\n;; The above rules automatically sink loads for rhs operands, so additionally\n;; add rules for sinking loads with lhs operands.\n(rule 1 (lower (has_type $F32 (fadd (sinkable_load x) y)))\n      (x64_addss y x))\n(rule 1 (lower (has_type $F64 (fadd (sinkable_load x) y)))\n      (x64_addsd y x))\n(rule 1 (lower (has_type $F32X4 (fadd (sinkable_load x) y)))\n      (x64_addps y x))\n(rule 1 (lower (has_type $F64X2 (fadd (sinkable_load x) y)))\n      (x64_addpd y x))\n\n;; Rules for `fsub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fsub x y)))\n      (x64_subss x y))\n(rule (lower (has_type $F64 (fsub x y)))\n      (x64_subsd x y))\n(rule (lower (has_type $F32X4 (fsub x y)))\n      (x64_subps x y))\n(rule (lower (has_type $F64X2 (fsub x y)))\n      (x64_subpd x y))\n\n;; Rules for `fmul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fmul x y)))\n      (x64_mulss x y))\n(rule (lower (has_type $F64 (fmul x y)))\n      (x64_mulsd x y))\n(rule (lower (has_type $F32X4 (fmul x y)))\n      (x64_mulps x y))\n(rule (lower (has_type $F64X2 (fmul x y)))\n      (x64_mulpd x y))\n\n;; The above rules automatically sink loads for rhs operands, so additionally\n;; add rules for sinking loads with lhs operands.\n(rule 1 (lower (has_type $F32 (fmul (sinkable_load x) y)))\n      (x64_mulss y x))\n(rule 1 (lower (has_type $F64 (fmul (sinkable_load x) y)))\n      (x64_mulsd y x))\n(rule 1 (lower (has_type $F32X4 (fmul (sinkable_load x) y)))\n      (x64_mulps y x))\n(rule 1 (lower (has_type $F64X2 (fmul (sinkable_load x) y)))\n      (x64_mulpd y x))\n\n;; Rules for `fdiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fdiv x y)))\n      (x64_divss x y))\n(rule (lower (has_type $F64 (fdiv x y)))\n      (x64_divsd x y))\n(rule (lower (has_type $F32X4 (fdiv x y)))\n      (x64_divps x y))\n(rule (lower (has_type $F64X2 (fdiv x y)))\n      (x64_divpd x y))\n\n;; Rules for `sqrt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F32 (sqrt x)))\n      (x64_sqrtss x))\n(rule (lower (has_type $F64 (sqrt x)))\n      (x64_sqrtsd x))\n(rule (lower (has_type $F32X4 (sqrt x)))\n      (x64_sqrtps x))\n(rule (lower (has_type $F64X2 (sqrt x)))\n      (x64_sqrtpd x))\n\n;; Rules for `fpromote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F64 (fpromote x)))\n      (x64_cvtss2sd x))\n\n;; Rules for `fvpromote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F64X2 (fvpromote_low x)))\n      (x64_cvtps2pd (put_in_xmm x)))\n\n;; Rules for `fdemote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F32 (fdemote x)))\n      (x64_cvtsd2ss x))\n\n;; Rules for `fvdemote` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(rule (lower (has_type $F32X4 (fvdemote x)))\n      (x64_cvtpd2ps x))\n\n;; Rules for `fmin` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fmin x y)))\n      (xmm_min_max_seq $F32 $true x y))\n(rule (lower (has_type $F64 (fmin x y)))\n      (xmm_min_max_seq $F64 $true x y))\n\n;; Vector-typed version. We don't use single pseudoinstructions as\n;; above, because we don't need to generate a mini-CFG. Instead, we\n;; perform a branchless series of operations.\n;;\n;; We cannot simply use native min instructions (minps, minpd) because\n;; NaN handling is different per CLIF semantics than on\n;; x86. Specifically, if an argument is NaN, or the arguments are both\n;; zero but of opposite signs, then the x86 instruction always\n;; produces the second argument. However, per CLIF semantics, we\n;; require that fmin(NaN, _) = fmin(_, NaN) = NaN, and fmin(+0, -0) =\n;; fmin(-0, +0) = -0.\n\n(rule (lower (has_type $F32X4 (fmin x y)))\n      ;; Compute min(x, y) and min(y, x) with native\n      ;; instructions. These will differ in one of the edge cases\n      ;; above that we have to handle properly. (Conversely, if they\n      ;; don't differ, then the native instruction's answer is the\n      ;; right one per CLIF semantics.)\n      (let ((min1 Xmm (x64_minps x y))\n            (min2 Xmm (x64_minps y x))\n            ;; Compute the OR of the two. Note that NaNs have an\n            ;; exponent field of all-ones (0xFF for F32), so if either\n            ;; result is a NaN, this OR will be. And if either is a\n            ;; zero (which has an exponent of 0 and mantissa of 0),\n            ;; this captures a sign-bit of 1 (negative) if either\n            ;; input is negative.\n            ;;\n            ;; In the case where we don't have a +/-0 mismatch or\n            ;; NaNs, then `min1` and `min2` are equal and `min_or` is\n            ;; the correct minimum.\n            (min_or Xmm (x64_orps min1 min2))\n            ;; \"compare unordered\" produces a true mask (all ones) in\n            ;; a given lane if the min is a NaN. We use this to\n            ;; generate a mask to ensure quiet NaNs.\n            (is_nan_mask Xmm (x64_cmpps min_or min2 (FcmpImm.Unordered)))\n            ;; OR in the NaN mask.\n            (min_or_2 Xmm (x64_orps min_or is_nan_mask))\n            ;; Shift the NaN mask down so that it covers just the\n            ;; fraction below the NaN signalling bit; we'll use this\n            ;; to mask off non-canonical NaN payloads.\n            ;;\n            ;; All-ones for NaN, shifted down to leave 10 top bits (1\n            ;; sign, 8 exponent, 1 QNaN bit that must remain set)\n            ;; cleared.\n            (nan_fraction_mask Xmm (x64_psrld is_nan_mask (xmi_imm 10)))\n            ;; Do a NAND, so that we retain every bit not set in\n            ;; `nan_fraction_mask`. This mask will be all zeroes (so\n            ;; we retain every bit) in non-NaN cases, and will have\n            ;; ones (so we clear those bits) in NaN-payload bits\n            ;; otherwise.\n            (final Xmm (x64_andnps nan_fraction_mask min_or_2)))\n        final))\n\n;; Likewise for F64 lanes, except that the right-shift is by 13 bits\n;; (1 sign, 11 exponent, 1 QNaN bit).\n(rule (lower (has_type $F64X2 (fmin x y)))\n      (let ((min1 Xmm (x64_minpd x y))\n            (min2 Xmm (x64_minpd y x))\n            (min_or Xmm (x64_orpd min1 min2))\n            (is_nan_mask Xmm (x64_cmppd min1 min2 (FcmpImm.Unordered)))\n            (min_or_2 Xmm (x64_orpd min_or is_nan_mask))\n            (nan_fraction_mask Xmm (x64_psrlq is_nan_mask (xmi_imm 13)))\n            (final Xmm (x64_andnpd nan_fraction_mask min_or_2)))\n        final))\n\n;; Rules for `fmax` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fmax x y)))\n      (xmm_min_max_seq $F32 $false x y))\n(rule (lower (has_type $F64 (fmax x y)))\n      (xmm_min_max_seq $F64 $false x y))\n\n;; The vector version of fmax here is a dual to the fmin sequence\n;; above, almost, with a few differences.\n\n(rule (lower (has_type $F32X4 (fmax x y)))\n      ;; Compute max(x, y) and max(y, x) with native\n      ;; instructions. These will differ in one of the edge cases\n      ;; above that we have to handle properly. (Conversely, if they\n      ;; don't differ, then the native instruction's answer is the\n      ;; right one per CLIF semantics.)\n      (let ((max1 Xmm (x64_maxps x y))\n            (max2 Xmm (x64_maxps y x))\n            ;; Compute the XOR of the two maxima. In the case\n            ;; where we don't have a +/-0 mismatch or NaNs, then\n            ;; `min1` and `min2` are equal and this XOR is zero.\n            (max_xor Xmm (x64_xorps max1 max2))\n            ;; OR the XOR into one of the original maxima. If they are\n            ;; equal, this does nothing. If max2 was NaN, its exponent\n            ;; bits were all-ones, so the xor's exponent bits were the\n            ;; complement of max1, and the OR of max1 and max_xor has\n            ;; an all-ones exponent (is a NaN). If max1 was NaN, then\n            ;; its exponent bits were already all-ones, so the OR will\n            ;; be a NaN as well.\n            (max_blended_nan Xmm (x64_orps max1 max_xor))\n            ;; Subtract the XOR. This ensures that if we had +0 and\n            ;; -0, we end up with +0.\n            (max_blended_nan_positive Xmm (x64_subps max_blended_nan max_xor))\n            ;; \"compare unordered\" produces a true mask (all ones) in\n            ;; a given lane if the min is a NaN. We use this to\n            ;; generate a mask to ensure quiet NaNs.\n            (is_nan_mask Xmm (x64_cmpps max_blended_nan max_blended_nan (FcmpImm.Unordered)))\n            ;; Shift the NaN mask down so that it covers just the\n            ;; fraction below the NaN signalling bit; we'll use this\n            ;; to mask off non-canonical NaN payloads.\n            ;;\n            ;; All-ones for NaN, shifted down to leave 10 top bits (1\n            ;; sign, 8 exponent, 1 QNaN bit that must remain set)\n            ;; cleared.\n            (nan_fraction_mask Xmm (x64_psrld is_nan_mask (xmi_imm 10)))\n            ;; Do a NAND, so that we retain every bit not set in\n            ;; `nan_fraction_mask`. This mask will be all zeroes (so\n            ;; we retain every bit) in non-NaN cases, and will have\n            ;; ones (so we clear those bits) in NaN-payload bits\n            ;; otherwise.\n            (final Xmm (x64_andnps nan_fraction_mask max_blended_nan_positive)))\n        final))\n\n(rule (lower (has_type $F64X2 (fmax x y)))\n      ;; Compute max(x, y) and max(y, x) with native\n      ;; instructions. These will differ in one of the edge cases\n      ;; above that we have to handle properly. (Conversely, if they\n      ;; don't differ, then the native instruction's answer is the\n      ;; right one per CLIF semantics.)\n      (let ((max1 Xmm (x64_maxpd x y))\n            (max2 Xmm (x64_maxpd y x))\n            ;; Compute the XOR of the two maxima. In the case\n            ;; where we don't have a +/-0 mismatch or NaNs, then\n            ;; `min1` and `min2` are equal and this XOR is zero.\n            (max_xor Xmm (x64_xorpd max1 max2))\n            ;; OR the XOR into one of the original maxima. If they are\n            ;; equal, this does nothing. If max2 was NaN, its exponent\n            ;; bits were all-ones, so the xor's exponent bits were the\n            ;; complement of max1, and the OR of max1 and max_xor has\n            ;; an all-ones exponent (is a NaN). If max1 was NaN, then\n            ;; its exponent bits were already all-ones, so the OR will\n            ;; be a NaN as well.\n            (max_blended_nan Xmm (x64_orpd max1 max_xor))\n            ;; Subtract the XOR. This ensures that if we had +0 and\n            ;; -0, we end up with +0.\n            (max_blended_nan_positive Xmm (x64_subpd max_blended_nan max_xor))\n            ;; `cmpps` with predicate index `3` is `cmpunordps`, or\n            ;; \"compare unordered\": it produces a true mask (all ones)\n            ;; in a given lane if the min is a NaN. We use this to\n            ;; generate a mask to ensure quiet NaNs.\n            (is_nan_mask Xmm (x64_cmppd max_blended_nan max_blended_nan (FcmpImm.Unordered)))\n            ;; Shift the NaN mask down so that it covers just the\n            ;; fraction below the NaN signalling bit; we'll use this\n            ;; to mask off non-canonical NaN payloads.\n            ;;\n            ;; All-ones for NaN, shifted down to leave 13 top bits (1\n            ;; sign, 11 exponent, 1 QNaN bit that must remain set)\n            ;; cleared.\n            (nan_fraction_mask Xmm (x64_psrlq is_nan_mask (xmi_imm 13)))\n            ;; Do a NAND, so that we retain every bit not set in\n            ;; `nan_fraction_mask`. This mask will be all zeroes (so\n            ;; we retain every bit) in non-NaN cases, and will have\n            ;; ones (so we clear those bits) in NaN-payload bits\n            ;; otherwise.\n            (final Xmm (x64_andnpd nan_fraction_mask max_blended_nan_positive)))\n        final))\n\n;; Rules for `fma` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Base case for fma is to call out to one of two libcalls. For vectors they\n;; need to be decomposed, handle each element individually, and then recomposed.\n\n(rule (lower (has_type $F32 (fma x y z)))\n      (libcall_3 (LibCall.FmaF32) x y z))\n(rule (lower (has_type $F64 (fma x y z)))\n      (libcall_3 (LibCall.FmaF64) x y z))\n\n(rule (lower (has_type $F32X4 (fma x y z)))\n      (let (\n          (x Xmm (put_in_xmm x))\n          (y Xmm (put_in_xmm y))\n          (z Xmm (put_in_xmm z))\n          (x0 Xmm (libcall_3 (LibCall.FmaF32) x y z))\n          (x1 Xmm (libcall_3 (LibCall.FmaF32)\n            (x64_pshufd x 1)\n            (x64_pshufd y 1)\n            (x64_pshufd z 1)))\n          (x2 Xmm (libcall_3 (LibCall.FmaF32)\n            (x64_pshufd x 2)\n            (x64_pshufd y 2)\n            (x64_pshufd z 2)))\n          (x3 Xmm (libcall_3 (LibCall.FmaF32)\n            (x64_pshufd x 3)\n            (x64_pshufd y 3)\n            (x64_pshufd z 3)))\n\n          (tmp Xmm (vec_insert_lane $F32X4 x0 x1 1))\n          (tmp Xmm (vec_insert_lane $F32X4 tmp x2 2))\n          (tmp Xmm (vec_insert_lane $F32X4 tmp x3 3))\n        )\n        tmp))\n(rule (lower (has_type $F64X2 (fma x y z)))\n      (let (\n          (x Xmm (put_in_xmm x))\n          (y Xmm (put_in_xmm y))\n          (z Xmm (put_in_xmm z))\n          (x0 Xmm (libcall_3 (LibCall.FmaF64) x y z))\n          (x1 Xmm (libcall_3 (LibCall.FmaF64)\n            (x64_pshufd x 0xee)\n            (x64_pshufd y 0xee)\n            (x64_pshufd z 0xee)))\n        )\n        (vec_insert_lane $F64X2 x0 x1 1)))\n\n\n;; Special case for when the `fma` feature is active and a native instruction\n;; can be used.\n(rule 1 (lower (has_type ty (fma x y z)))\n      (if-let $true (use_fma))\n      (fmadd ty x y z))\n\n(decl fmadd (Type Value Value Value) Xmm)\n(decl fnmadd (Type Value Value Value) Xmm)\n\n;; Base case. Note that this will automatically sink a load with `z`, the value\n;; to add.\n(rule (fmadd ty x y z) (x64_vfmadd213 ty x y z))\n\n;; Allow sinking loads with one of the two values being multiplied in addition\n;; to the value being added. Note that both x and y can be sunk here due to\n;; multiplication being commutative.\n(rule 1 (fmadd ty (sinkable_load x) y z) (x64_vfmadd132 ty y z x))\n(rule 2 (fmadd ty x (sinkable_load y) z) (x64_vfmadd132 ty x z y))\n\n;; If one of the values being multiplied is negated then use a `vfnmadd*`\n;; instruction instead\n(rule 3 (fmadd ty (fneg x) y z) (fnmadd ty x y z))\n(rule 4 (fmadd ty x (fneg y) z) (fnmadd ty x y z))\n\n(rule (fnmadd ty x y z) (x64_vfnmadd213 ty x y z))\n(rule 1 (fnmadd ty (sinkable_load x) y z) (x64_vfnmadd132 ty y z x))\n(rule 2 (fnmadd ty x (sinkable_load y) z) (x64_vfnmadd132 ty x z y))\n\n;; Like `fmadd` if one argument is negated switch which one is being codegen'd\n(rule 3 (fnmadd ty (fneg x) y z) (fmadd ty x y z))\n(rule 4 (fnmadd ty x (fneg y) z) (fmadd ty x y z))\n\n;; Rules for `load*` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; In order to load a value from memory to a GPR register, we may need to extend\n;; the loaded value from 8-, 16-, or 32-bits to this backend's expected GPR\n;; width: 64 bits. Note that `ext_mode` will load 1-bit types (booleans) as\n;; 8-bit loads.\n;;\n;; By default, we zero-extend all sub-64-bit loads to a GPR.\n(rule -4 (lower (has_type (and (fits_in_32 ty) (is_gpr_type _)) (load flags address offset)))\n      (x64_movzx (ext_mode (ty_bits_u16 ty) 64) (to_amode flags address offset)))\n;; But if we know that both the `from` and `to` are 64 bits, we simply load with\n;; no extension.\n(rule -1 (lower (has_type (ty_int_ref_64 ty) (load flags address offset)))\n      (x64_mov (to_amode flags address offset)))\n;; Also, certain scalar loads have a specific `from` width and extension kind\n;; (signed -> `sx`, zeroed -> `zx`). We overwrite the high bits of the 64-bit\n;; GPR even if the `to` type is smaller (e.g., 16-bits).\n(rule (lower (has_type (is_gpr_type ty) (uload8 flags address offset)))\n      (x64_movzx (ExtMode.BQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (sload8 flags address offset)))\n      (x64_movsx (ExtMode.BQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (uload16 flags address offset)))\n      (x64_movzx (ExtMode.WQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (sload16 flags address offset)))\n      (x64_movsx (ExtMode.WQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (uload32 flags address offset)))\n      (x64_movzx (ExtMode.LQ) (to_amode flags address offset)))\n(rule (lower (has_type (is_gpr_type ty) (sload32 flags address offset)))\n      (x64_movsx (ExtMode.LQ) (to_amode flags address offset)))\n\n;; To load to XMM registers, we use the x64-specific instructions for each type.\n;; For `$F32` and `$F64` this is important--we only want to load 32 or 64 bits.\n;; But for the 128-bit types, this is not strictly necessary for performance but\n;; might help with clarity during disassembly.\n(rule (lower (has_type $F32 (load flags address offset)))\n      (x64_movss_load (to_amode flags address offset)))\n(rule (lower (has_type $F64 (load flags address offset)))\n      (x64_movsd_load (to_amode flags address offset)))\n(rule (lower (has_type $F32X4 (load flags address offset)))\n      (x64_movups_load (to_amode flags address offset)))\n(rule (lower (has_type $F64X2 (load flags address offset)))\n      (x64_movupd_load (to_amode flags address offset)))\n(rule -2 (lower (has_type (ty_vec128 ty) (load flags address offset)))\n      (x64_movdqu_load (to_amode flags address offset)))\n\n;; We can load an I128 by doing two 64-bit loads.\n(rule -3 (lower (has_type $I128\n                       (load flags address offset)))\n      (let ((addr_lo Amode (to_amode flags address offset))\n            (addr_hi Amode (amode_offset addr_lo 8))\n            (value_lo Reg (x64_mov addr_lo))\n            (value_hi Reg (x64_mov addr_hi)))\n        (value_regs value_lo value_hi)))\n\n;; We also include widening vector loads; these sign- or zero-extend each lane\n;; to the next wider width (e.g., 16x4 -> 32x4).\n(rule 1 (lower (has_type $I16X8 (sload8x8 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovsxbw (to_amode flags address offset)))\n(rule 1 (lower (has_type $I16X8 (uload8x8 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovzxbw (to_amode flags address offset)))\n(rule 1 (lower (has_type $I32X4 (sload16x4 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovsxwd (to_amode flags address offset)))\n(rule 1 (lower (has_type $I32X4 (uload16x4 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovzxwd (to_amode flags address offset)))\n(rule 1 (lower (has_type $I64X2 (sload32x2 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovsxdq (to_amode flags address offset)))\n(rule 1 (lower (has_type $I64X2 (uload32x2 flags address offset)))\n        (if-let $true (use_sse41))\n        (x64_pmovzxdq (to_amode flags address offset)))\n\n(rule (lower (has_type $I16X8 (sload8x8 flags address offset)))\n      (lower_swiden_low $I16X8 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I16X8 (uload8x8 flags address offset)))\n      (lower_uwiden_low $I16X8 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I32X4 (sload16x4 flags address offset)))\n      (lower_swiden_low $I32X4 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I32X4 (uload16x4 flags address offset)))\n      (lower_uwiden_low $I32X4 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I64X2 (sload32x2 flags address offset)))\n      (lower_swiden_low $I64X2 (x64_movq_to_xmm (to_amode flags address offset))))\n(rule (lower (has_type $I64X2 (uload32x2 flags address offset)))\n      (lower_uwiden_low $I64X2 (x64_movq_to_xmm (to_amode flags address offset))))\n\n;; Rules for `store*` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; 8-, 16-, 32- and 64-bit GPR stores.\n(rule -2 (lower (store flags\n                    value @ (value_type (is_gpr_type ty))\n                    address\n                    offset))\n      (side_effect\n       (x64_movrm ty (to_amode flags address offset) value)))\n\n;; Explicit 8/16/32-bit opcodes.\n(rule (lower (istore8 flags value address offset))\n      (side_effect\n       (x64_movrm $I8 (to_amode flags address offset) value)))\n(rule (lower (istore16 flags value address offset))\n      (side_effect\n       (x64_movrm $I16 (to_amode flags address offset) value)))\n(rule (lower (istore32 flags value address offset))\n      (side_effect\n       (x64_movrm $I32 (to_amode flags address offset) value)))\n\n;; IMM stores\n(rule 2 (lower (store flags (has_type (fits_in_64 ty) (iconst (simm32 value))) address offset))\n      (side_effect\n       (x64_movimm_m ty (to_amode flags address offset) value)))\n\n;; F32 stores of values in XMM registers.\n(rule 1 (lower (store flags\n                    value @ (value_type $F32)\n                    address\n                    offset))\n      (side_effect\n       (x64_movss_store (to_amode flags address offset) value)))\n\n;; F64 stores of values in XMM registers.\n(rule 1 (lower (store flags\n                    value @ (value_type $F64)\n                    address\n                    offset))\n      (side_effect\n       (x64_movsd_store (to_amode flags address offset) value)))\n\n;; Stores of F32X4 vectors.\n(rule 1 (lower (store flags\n                    value @ (value_type $F32X4)\n                    address\n                    offset))\n      (side_effect\n       (x64_movups_store (to_amode flags address offset) value)))\n\n;; Stores of F64X2 vectors.\n(rule 1 (lower (store flags\n                    value @ (value_type $F64X2)\n                    address\n                    offset))\n      (side_effect\n       (x64_movupd_store (to_amode flags address offset) value)))\n\n;; Stores of all other 128-bit vector types with integer lanes.\n(rule -1 (lower (store flags\n                    value @ (value_type (ty_vec128_int _))\n                    address\n                    offset))\n      (side_effect\n       (x64_movdqu_store (to_amode flags address offset) value)))\n\n;; Stores of I128 values: store the two 64-bit halves separately.\n(rule 0 (lower (store flags\n                    value @ (value_type $I128)\n                    address\n                    offset))\n      (let ((value_reg ValueRegs value)\n            (value_lo Gpr (value_regs_get_gpr value_reg 0))\n            (value_hi Gpr (value_regs_get_gpr value_reg 1))\n            (addr_lo Amode (to_amode flags address offset))\n            (addr_hi Amode (amode_offset addr_lo 8)))\n      (side_effect\n       (side_effect_concat\n        (x64_movrm $I64 addr_lo value_lo)\n        (x64_movrm $I64 addr_hi value_hi)))))\n\n;; Slightly optimize the extraction of the first lane from a vector which is\n;; stored in memory. In the case the first lane specifically is selected the\n;; standard `movss` and `movsd` instructions can be used as-if we're storing a\n;; f32 or f64 despite the source perhaps being an integer vector since the\n;; result of the instruction is the same.\n(rule 2 (lower (store flags\n                    (has_type $F32 (extractlane value (u8_from_uimm8 0)))\n                    address\n                    offset))\n      (side_effect\n       (x64_movss_store (to_amode flags address offset) value)))\n(rule 2 (lower (store flags\n                    (has_type $F64 (extractlane value (u8_from_uimm8 0)))\n                    address\n                    offset))\n      (side_effect\n       (x64_movsd_store (to_amode flags address offset) value)))\n(rule 2 (lower (store flags\n                    (has_type $I8 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrb_store (to_amode flags address offset) value n)))\n(rule 2 (lower (store flags\n                    (has_type $I16 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrw_store (to_amode flags address offset) value n)))\n(rule 2 (lower (store flags\n                    (has_type $I32 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrd_store (to_amode flags address offset) value n)))\n(rule 2 (lower (store flags\n                    (has_type $I64 (extractlane value (u8_from_uimm8 n)))\n                    address\n                    offset))\n      (if-let $true (use_sse41))\n      (side_effect\n       (x64_pextrq_store (to_amode flags address offset) value n)))\n\n;; Rules for `load*` + ALU op + `store*` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Add mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (iadd (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_add_mem ty (to_amode flags addr offset) src2))))\n\n;; Add mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (iadd src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_add_mem ty (to_amode flags addr offset) src2))))\n\n;; Sub mem, reg\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (isub (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_sub_mem ty (to_amode flags addr offset) src2))))\n\n;; And mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (band (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_and_mem ty (to_amode flags addr offset) src2))))\n\n;; And mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (band src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_and_mem ty (to_amode flags addr offset) src2))))\n\n;; Or mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bor (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_or_mem ty (to_amode flags addr offset) src2))))\n\n;; Or mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bor src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_or_mem ty (to_amode flags addr offset) src2))))\n\n;; Xor mem, reg\n(rule 3 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bxor (and\n                               (sinkable_load sink)\n                               (load flags addr offset))\n                              src2))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_xor_mem ty (to_amode flags addr offset) src2))))\n\n;; Xor mem, reg with args swapped\n(rule 2 (lower\n       (store flags\n              (has_type (ty_32_or_64 ty)\n                        (bxor src2\n                              (and\n                               (sinkable_load sink)\n                               (load flags addr offset))))\n              addr\n              offset))\n      (let ((_ RegMemImm sink))\n        (side_effect\n         (x64_xor_mem ty (to_amode flags addr offset) src2))))\n\n;; Rules for `fence` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (fence))\n      (side_effect (x64_mfence)))\n\n;; Rules for `func_addr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (func_addr (func_ref_data _ extname dist)))\n      (load_ext_name extname 0 dist))\n\n;; Rules for `symbol_value` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (symbol_value (symbol_value_data extname dist offset)))\n      (load_ext_name extname offset dist))\n\n;; Rules for `atomic_load` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; This is a normal load. The x86-TSO memory model provides sufficient\n;; sequencing to satisfy the CLIF synchronisation requirements for `AtomicLoad`\n;; without the need for any fence instructions.\n;;\n;; As described in the `atomic_load` documentation, this lowering is only valid\n;; for I8, I16, I32, and I64. The sub-64-bit types are zero extended, as with a\n;; normal load.\n(rule 1 (lower (has_type $I64 (atomic_load flags address)))\n      (x64_mov (to_amode flags address (zero_offset))))\n(rule (lower (has_type (and (fits_in_32 ty) (ty_int _)) (atomic_load flags address)))\n      (x64_movzx (ext_mode (ty_bits_u16 ty) 64) (to_amode flags address (zero_offset))))\n\n;; Rules for `atomic_store` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; This is a normal store followed by an `mfence` instruction. As described in\n;; the `atomic_load` documentation, this lowering is only valid for I8, I16,\n;; I32, and I64.\n(rule (lower (atomic_store flags\n                           value @ (value_type (and (fits_in_64 ty) (ty_int _)))\n                           address))\n      (side_effect (side_effect_concat\n       (x64_movrm ty (to_amode flags address (zero_offset)) value)\n       (x64_mfence))))\n\n;; Rules for `atomic_cas` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (and (fits_in_64 ty) (ty_int _))\n                  (atomic_cas flags address expected replacement)))\n      (x64_cmpxchg ty expected replacement (to_amode flags address (zero_offset))))\n\n;; Rules for `atomic_rmw` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; This is a simple, general-case atomic update, based on a loop involving\n;; `cmpxchg`.  Note that we could do much better than this in the case where the\n;; old value at the location (that is to say, the SSA `Value` computed by this\n;; CLIF instruction) is not required.  In that case, we could instead implement\n;; this using a single `lock`-prefixed x64 read-modify-write instruction.  Also,\n;; even in the case where the old value is required, for the `add` and `sub`\n;; cases, we can use the single instruction `lock xadd`.  However, those\n;; improvements have been left for another day. TODO: filed as\n;; https://github.com/bytecodealliance/wasmtime/issues/2153.\n\n(rule (lower (has_type (and (fits_in_64 ty) (ty_int _))\n                  (atomic_rmw flags op address input)))\n      (x64_atomic_rmw_seq ty op (to_amode flags address (zero_offset)) input))\n\n;; Rules for `call` and `call_indirect` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (call (func_ref_data sig_ref extname dist) inputs))\n      (gen_call sig_ref extname dist inputs))\n\n(rule (lower (call_indirect sig_ref val inputs))\n      (gen_call_indirect sig_ref val inputs))\n\n;;;; Rules for `return_call` and `return_call_indirect` ;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (return_call (func_ref_data sig_ref extname dist) args))\n      (gen_return_call sig_ref extname dist args))\n\n(rule (lower (return_call_indirect sig_ref callee args))\n      (gen_return_call_indirect sig_ref callee args))\n\n;;;; Rules for `get_{frame,stack}_pointer` and `get_return_address` ;;;;;;;;;;;;\n\n(rule (lower (get_frame_pointer))\n      (x64_rbp))\n\n(rule (lower (get_stack_pointer))\n      (x64_rsp))\n\n(rule (lower (get_return_address))\n      (x64_load $I64\n                (Amode.ImmReg 8 (x64_rbp) (mem_flags_trusted))\n                (ExtKind.None)))\n\n;; Rules for `jump` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower_branch (jump _) (single_target target))\n      (emit_side_effect (jmp_known target)))\n\n;; Rules for `brif` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower_branch (brif (maybe_uextend (icmp cc a b)) _ _) (two_targets then else))\n        (emit_side_effect (jmp_cond_icmp (emit_cmp cc a b) then else)))\n\n(rule 2 (lower_branch (brif (maybe_uextend (fcmp cc a b)) _ _) (two_targets then else))\n        (emit_side_effect (jmp_cond_fcmp (emit_fcmp cc a b) then else)))\n\n(rule 1 (lower_branch (brif val @ (value_type $I128) _ _)\n                      (two_targets then else))\n      (emit_side_effect (jmp_cond_icmp (cmp_zero_i128 (CC.Z) val) then else)))\n\n(rule (lower_branch (brif val @ (value_type (ty_int_bool_or_ref)) _ _)\n                    (two_targets then else))\n      (emit_side_effect (with_flags_side_effect\n                          (cmp_zero_int_bool_ref val)\n                          (jmp_cond (CC.NZ) then else))))\n\n\n;; Compare an I128 value to zero, returning a flags result suitable for making a\n;; jump decision. The comparison is implemented as `(hi == 0) && (low == 0)`,\n;; and the result can be interpreted as follows\n;; * CC.Z indicates that the value was non-zero, as one or both of the halves of\n;;   the value were non-zero\n;; * CC.NZ indicates that both halves of the value were 0\n(decl cmp_zero_i128 (CC ValueRegs) IcmpCondResult)\n(rule (cmp_zero_i128 (cc_nz_or_z cc) val)\n      (let ((lo Gpr (value_regs_get_gpr val 0))\n            (hi Gpr (value_regs_get_gpr val 1))\n            (lo_z Gpr (with_flags_reg (x64_cmp (OperandSize.Size64) (RegMemImm.Imm 0) lo)\n                                      (x64_setcc (CC.Z))))\n            (hi_z Gpr (with_flags_reg (x64_cmp (OperandSize.Size64) (RegMemImm.Imm 0) hi)\n                                      (x64_setcc (CC.Z)))))\n          (icmp_cond_result (x64_test (OperandSize.Size8) lo_z hi_z) cc)))\n\n\n(decl cmp_zero_int_bool_ref (Value) ProducesFlags)\n(rule (cmp_zero_int_bool_ref val @ (value_type ty))\n      (let ((size OperandSize (raw_operand_size_of_type ty))\n            (src Gpr val))\n        (x64_test size src src)))\n\n;; Rules for `br_table` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower_branch (br_table idx @ (value_type ty) _) (jump_table_targets default_target jt_targets))\n      (let ((size OperandSize (raw_operand_size_of_type ty))\n            (jt_size u32 (jump_table_size jt_targets))\n            (size_reg Reg (imm ty (u32_as_u64 jt_size)))\n            (idx_reg Gpr (extend_to_gpr idx $I64 (ExtendKind.Zero)))\n            (clamped_idx Reg (with_flags_reg\n              (x64_cmp size size_reg idx_reg)\n              (cmove ty (CC.B) idx_reg size_reg))))\n      (emit_side_effect (jmp_table_seq ty clamped_idx default_target jt_targets))))\n\n;; Rules for `select_spectre_guard` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (select_spectre_guard (icmp cc a b) x y))\n      (select_icmp (emit_cmp cc a b) x y))\n\n(rule -1 (lower (has_type ty (select_spectre_guard c @ (value_type (fits_in_64 a_ty)) x y)))\n      (let ((size OperandSize (raw_operand_size_of_type a_ty))\n            (gpr_c Gpr (put_in_gpr c)))\n        (with_flags (x64_test size gpr_c gpr_c) (cmove_from_values ty (CC.NZ) x y))))\n\n(rule -2 (lower (has_type ty (select_spectre_guard c @ (value_type $I128) x y)))\n      (let ((cond_result IcmpCondResult (cmp_zero_i128 (CC.Z) c)))\n        (select_icmp cond_result x y)))\n\n;; Rules for `fcvt_from_sint` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (has_type $F32 (fcvt_from_sint a @ (value_type $I8))))\n      (x64_cvtsi2ss $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 2 (lower (has_type $F32 (fcvt_from_sint a @ (value_type $I16))))\n      (x64_cvtsi2ss $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 1 (lower (has_type $F32 (fcvt_from_sint a @ (value_type (ty_int (fits_in_64 ty))))))\n      (x64_cvtsi2ss ty a))\n\n(rule 2 (lower (has_type $F64 (fcvt_from_sint a @ (value_type $I8))))\n      (x64_cvtsi2sd $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 2 (lower (has_type $F64 (fcvt_from_sint a @ (value_type $I16))))\n      (x64_cvtsi2sd $I32 (extend_to_gpr a $I32 (ExtendKind.Sign))))\n\n(rule 1 (lower (has_type $F64 (fcvt_from_sint a @ (value_type (ty_int (fits_in_64 ty))))))\n      (x64_cvtsi2sd ty a))\n\n(rule 0 (lower (fcvt_from_sint a @ (value_type $I32X4)))\n      (x64_cvtdq2ps a))\n\n(rule 1 (lower (has_type $F64X2 (fcvt_from_sint (swiden_low a @ (value_type $I32X4)))))\n      (x64_cvtdq2pd a))\n\n;; Rules for `fcvt_from_uint` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (has_type $F32 (fcvt_from_uint val @ (value_type (fits_in_32 (ty_int ty))))))\n      (x64_cvtsi2ss $I64 (extend_to_gpr val $I64 (ExtendKind.Zero))))\n\n(rule 1 (lower (has_type $F64 (fcvt_from_uint val @ (value_type (fits_in_32 (ty_int ty))))))\n      (x64_cvtsi2sd $I64 (extend_to_gpr val $I64 (ExtendKind.Zero))))\n\n(rule (lower (has_type ty (fcvt_from_uint val @ (value_type $I64))))\n      (cvt_u64_to_float_seq ty val))\n\n;; Algorithm uses unpcklps to help create a float that is equivalent\n;; 0x1.0p52 + double(src). 0x1.0p52 is unique because at this exponent\n;; every value of the mantissa represents a corresponding uint32 number.\n;; When we subtract 0x1.0p52 we are left with double(src).\n(rule 1 (lower (has_type $F64X2 (fcvt_from_uint (uwiden_low val @ (value_type $I32X4)))))\n      (let ((uint_mask XmmMem (emit_u128_le_const 0x43300000_43300000))\n            (res Xmm (x64_unpcklps val uint_mask))\n            (uint_mask_high XmmMem (emit_u128_le_const 0x4330000000000000_4330000000000000)))\n        (x64_subpd res uint_mask_high)))\n\n;; When AVX512VL and AVX512F are available,\n;; `fcvt_from_uint` can be lowered to a single instruction.\n(rule 2 (lower (has_type $F32X4 (fcvt_from_uint src)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512f))\n      (x64_vcvtudq2ps src))\n\n;; Converting packed unsigned integers to packed floats\n;; requires a few steps. There is no single instruction\n;; lowering for converting unsigned floats but there is for\n;; converting packed signed integers to float (cvtdq2ps). In\n;; the steps below we isolate the upper half (16 bits) and\n;; lower half (16 bits) of each lane and then we convert\n;; each half separately using cvtdq2ps meant for signed\n;; integers. In order for this to work for the upper half\n;; bits we must shift right by 1 (divide by 2) these bits in\n;; order to ensure the most significant bit is 0 not signed,\n;; and then after the conversion we double the value.\n;; Finally we add the converted values where addition will\n;; correctly round.\n;;\n;; Sequence:\n;; -> A = 0xffffffff\n;; -> Ah = 0xffff0000\n;; -> Al = 0x0000ffff\n;; -> Convert(Al) // Convert int to float\n;; -> Ah = Ah >> 1 // Shift right 1 to assure Ah conversion isn't treated as signed\n;; -> Convert(Ah) // Convert .. with no loss of significant digits from previous shift\n;; -> Ah = Ah + Ah // Double Ah to account for shift right before the conversion.\n;; -> dst = Ah + Al // Add the two floats together\n(rule 1 (lower (has_type $F32X4 (fcvt_from_uint val)))\n      (let ((a Xmm val)\n\n            ;;  get the low 16 bits\n            (a_lo Xmm (x64_pslld a (xmi_imm 16)))\n            (a_lo Xmm (x64_psrld a_lo (xmi_imm 16)))\n\n            ;; get the high 16 bits\n            (a_hi Xmm (x64_psubd a a_lo))\n\n            ;; convert the low 16 bits\n            (a_lo Xmm (x64_cvtdq2ps a_lo))\n\n            ;; shift the high bits by 1, convert, and double to get the correct\n            ;; value\n            (a_hi Xmm (x64_psrld a_hi (xmi_imm 1)))\n            (a_hi Xmm (x64_cvtdq2ps a_hi))\n            (a_hi Xmm (x64_addps a_hi a_hi)))\n\n        ;; add together the two converted values\n        (x64_addps a_hi a_lo)))\n\n;; Rules for `fcvt_to_uint` and `fcvt_to_sint` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type out_ty (fcvt_to_uint val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_uint_seq out_ty val $false))\n\n(rule (lower (has_type out_ty (fcvt_to_uint_sat val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_uint_seq out_ty val $true))\n\n(rule (lower (has_type out_ty (fcvt_to_sint val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_sint_seq out_ty val $false))\n\n(rule (lower (has_type out_ty (fcvt_to_sint_sat val @ (value_type (ty_scalar_float _)))))\n      (cvt_float_to_sint_seq out_ty val $true))\n\n;; The x64 backend currently only supports these two type combinations.\n(rule 1 (lower (has_type $I32X4 (fcvt_to_sint_sat val @ (value_type $F32X4))))\n      (let ((src Xmm val)\n\n            ;; Sets tmp to zero if float is NaN\n            (tmp Xmm (x64_cmpps src src (FcmpImm.Equal)))\n            (dst Xmm (x64_andps src tmp))\n\n            ;; Sets top bit of tmp if float is positive\n            ;; Setting up to set top bit on negative float values\n            (tmp Xmm (x64_pxor tmp dst))\n\n            ;; Convert the packed float to packed doubleword.\n            (dst Xmm (x64_cvttps2dq dst))\n\n            ;; Set top bit only if < 0\n            (tmp Xmm (x64_pand dst tmp))\n            (tmp Xmm (x64_psrad tmp (xmi_imm 31))))\n\n        ;; On overflow 0x80000000 is returned to a lane.\n        ;; Below sets positive overflow lanes to 0x7FFFFFFF\n        ;; Keeps negative overflow lanes as is.\n        (x64_pxor tmp dst)))\n\n;; The algorithm for converting floats to unsigned ints is a little tricky. The\n;; complication arises because we are converting from a signed 64-bit int with a positive\n;; integer range from 1..INT_MAX (0x1..0x7FFFFFFF) to an unsigned integer with an extended\n;; range from (INT_MAX+1)..UINT_MAX. It's this range from (INT_MAX+1)..UINT_MAX\n;; (0x80000000..0xFFFFFFFF) that needs to be accounted for as a special case since our\n;; conversion instruction (cvttps2dq) only converts as high as INT_MAX (0x7FFFFFFF), but\n;; which conveniently setting underflows and overflows (smaller than MIN_INT or larger than\n;; MAX_INT) to be INT_MAX+1 (0x80000000). Nothing that the range (INT_MAX+1)..UINT_MAX includes\n;; precisely INT_MAX values we can correctly account for and convert every value in this range\n;; if we simply subtract INT_MAX+1 before doing the cvttps2dq conversion. After the subtraction\n;; every value originally (INT_MAX+1)..UINT_MAX is now the range (0..INT_MAX).\n;; After the conversion we add INT_MAX+1 back to this converted value, noting again that\n;; values we are trying to account for were already set to INT_MAX+1 during the original conversion.\n;; We simply have to create a mask and make sure we are adding together only the lanes that need\n;; to be accounted for. Digesting it all the steps then are:\n;;\n;; Step 1 - Account for NaN and negative floats by setting these src values to zero.\n;; Step 2 - Make a copy (tmp1) of the src value since we need to convert twice for\n;;          reasons described above.\n;; Step 3 - Convert the original src values. This will convert properly all floats up to INT_MAX\n;; Step 4 - Subtract INT_MAX from the copy set (tmp1). Note, all zero and negative values are those\n;;          values that were originally in the range (0..INT_MAX). This will come in handy during\n;;          step 7 when we zero negative lanes.\n;; Step 5 - Create a bit mask for tmp1 that will correspond to all lanes originally less than\n;;          UINT_MAX that are now less than INT_MAX thanks to the subtraction.\n;; Step 6 - Convert the second set of values (tmp1)\n;; Step 7 - Prep the converted second set by zeroing out negative lanes (these have already been\n;;          converted correctly with the first set) and by setting overflow lanes to 0x7FFFFFFF\n;;          as this will allow us to properly saturate overflow lanes when adding to 0x80000000\n;; Step 8 - Add the orginal converted src and the converted tmp1 where float values originally less\n;;          than and equal to INT_MAX will be unchanged, float values originally between INT_MAX+1 and\n;;          UINT_MAX will add together (INT_MAX) + (SRC - INT_MAX), and float values originally\n;;          greater than UINT_MAX will be saturated to UINT_MAX (0xFFFFFFFF) after adding (0x8000000 + 0x7FFFFFFF).\n;;\n;;\n;; The table below illustrates the result after each step where it matters for the converted set.\n;; Note the original value range (original src set) is the final dst in Step 8:\n;;\n;; Original src set:\n;; | Original Value Range |    Step 1    |         Step 3         |          Step 8           |\n;; |  -FLT_MIN..FLT_MAX   | 0.0..FLT_MAX | 0..INT_MAX(w/overflow) | 0..UINT_MAX(w/saturation) |\n;;\n;; Copied src set (tmp1):\n;; |    Step 2    |                  Step 4                  |\n;; | 0.0..FLT_MAX | (0.0-(INT_MAX+1))..(FLT_MAX-(INT_MAX+1)) |\n;;\n;; |                       Step 6                        |                 Step 7                 |\n;; | (0-(INT_MAX+1))..(UINT_MAX-(INT_MAX+1))(w/overflow) | ((INT_MAX+1)-(INT_MAX+1))..(INT_MAX+1) |\n(rule 1 (lower (has_type $I32X4 (fcvt_to_uint_sat val @ (value_type $F32X4))))\n      (let ((src Xmm val)\n\n            ;; Converting to unsigned int so if float src is negative or NaN\n            ;; will first set to zero.\n            (tmp2 Xmm (xmm_zero $F32X4))\n            (dst Xmm (x64_maxps src tmp2))\n\n            ;; Set tmp2 to INT_MAX+1. It is important to note here that after it looks\n            ;; like we are only converting INT_MAX (0x7FFFFFFF) but in fact because\n            ;; single precision IEEE-754 floats can only accurately represent contingous\n            ;; integers up to 2^23 and outside of this range it rounds to the closest\n            ;; integer that it can represent. In the case of INT_MAX, this value gets\n            ;; represented as 0x4f000000 which is the integer value (INT_MAX+1).\n            (tmp2 Xmm (x64_pcmpeqd tmp2 tmp2))\n            (tmp2 Xmm (x64_psrld tmp2 (xmi_imm 1)))\n            (tmp2 Xmm (x64_cvtdq2ps tmp2))\n\n            ;; Make a copy of these lanes and then do the first conversion.\n            ;; Overflow lanes greater than the maximum allowed signed value will\n            ;; set to 0x80000000. Negative and NaN lanes will be 0x0\n            (tmp1 Xmm dst)\n            (dst Xmm (x64_cvttps2dq dst))\n\n            ;; Set lanes to src - max_signed_int\n            (tmp1 Xmm (x64_subps tmp1 tmp2))\n\n            ;; Create mask for all positive lanes to saturate (i.e. greater than\n            ;; or equal to the maxmimum allowable unsigned int).\n            (tmp2 Xmm (x64_cmpps tmp2 tmp1 (FcmpImm.LessThanOrEqual)))\n\n            ;; Convert those set of lanes that have the max_signed_int factored out.\n            (tmp1 Xmm (x64_cvttps2dq tmp1))\n\n            ;; Prepare converted lanes by zeroing negative lanes and prepping lanes\n            ;; that have positive overflow (based on the mask) by setting these lanes\n            ;; to 0x7FFFFFFF\n            (tmp1 Xmm (x64_pxor tmp1 tmp2))\n            (tmp2 Xmm (xmm_zero $I32X4))\n            (tmp1 Xmm (lower_vec_smax $I32X4 tmp1 tmp2)))\n\n        ;; Add this second set of converted lanes to the original to properly handle\n        ;; values greater than max signed int.\n        (x64_paddd tmp1 dst)))\n\n;; Rules for `x86_cvtt2dq` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I32X4 (x86_cvtt2dq val @ (value_type $F32X4))))\n      (x64_cvttps2dq val))\n\n;; Rules for `iadd_pairwise` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16 (iadd_pairwise x y)))\n      (let (\n          ;; Shuffle all the even lanes of `x` and `y` into one register\n          (even_lane_mask Xmm (x64_movdqu_load (emit_u128_le_const 0x00ff_00ff_00ff_00ff_00ff_00ff_00ff_00ff)))\n          (x_evens Xmm (x64_pand x even_lane_mask))\n          (y_evens Xmm (x64_pand y even_lane_mask))\n          (evens Xmm (x64_packuswb x_evens y_evens))\n\n          ;; Shuffle all the odd lanes of `x` and `y` into one register\n          (x_odds Xmm (x64_psrlw x (xmi_imm 8)))\n          (y_odds Xmm (x64_psrlw y (xmi_imm 8)))\n          (odds Xmm (x64_packuswb x_odds y_odds))\n        )\n        (x64_paddb evens odds)))\n\n\n(rule 1 (lower (has_type $I16X8 (iadd_pairwise x y)))\n        (if-let $true (use_ssse3))\n        (x64_phaddw x y))\n\n(rule (lower (has_type $I16X8 (iadd_pairwise x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n\n          ;; Shuffle the even-numbered 16-bit lanes into low four lanes of each\n          ;; vector by shuffling 16-bit lanes then shuffling 32-bit lanes.\n          ;; With these in place generate a new vector from the two low 64-bits\n          ;; of each vector (the low four 16-bit lanes).\n          ;;\n          ;; 0xe8 == 0b11_10_10_00\n          (x_evens Xmm (x64_pshufd (x64_pshufhw (x64_pshuflw x 0xe8) 0xe8) 0xe8))\n          (y_evens Xmm (x64_pshufd (x64_pshufhw (x64_pshuflw y 0xe8) 0xe8) 0xe8))\n          (evens Xmm (x64_punpcklqdq x_evens y_evens))\n\n          ;; Shuffle the odd-numbered 16-bit lanes into the low 8 lanes by\n          ;; performing `sshr` operation on 32-bit lanes, effectively moving the\n          ;; odd lanes into even lanes while leaving their sign bits in the\n          ;; odd lanes. The `packssdw` instruction then conveniently will\n          ;; put everything into one vector for us.\n          (x_shifted Xmm (x64_psrad x (xmi_imm 16)))\n          (y_shifted Xmm (x64_psrad y (xmi_imm 16)))\n          (odds Xmm (x64_packssdw x_shifted y_shifted))\n        )\n      (x64_paddw evens odds)))\n\n(rule 1 (lower (has_type $I32X4 (iadd_pairwise x y)))\n        (if-let $true (use_ssse3))\n        (x64_phaddd x y))\n\n(rule (lower (has_type $I32X4 (iadd_pairwise x y)))\n      (let (\n          (x Xmm x)\n          (y Xmm y)\n          ;; evens = [ x[0] x[2] y[0] y[2] ]\n          (evens Xmm (x64_shufps x y 0b10_00_10_00))\n          ;; odds  = [ x[1] x[3] y[1] y[3] ]\n          (odds  Xmm (x64_shufps x y 0b11_01_11_01))\n        )\n      (x64_paddd evens odds)))\n\n;; special case for the `i16x8.extadd_pairwise_i8x16_s` wasm instruction\n(rule 2 (lower\n        (has_type $I16X8 (iadd_pairwise\n                           (swiden_low val @ (value_type $I8X16))\n                           (swiden_high val))))\n      (if-let $true (use_ssse3))\n      (let ((mul_const Xmm (x64_xmm_load_const $I8X16\n              (emit_u128_le_const 0x01010101010101010101010101010101))))\n        (x64_pmaddubsw mul_const val)))\n\n;; special case for the `i32x4.extadd_pairwise_i16x8_s` wasm instruction\n(rule 2 (lower\n        (has_type $I32X4 (iadd_pairwise\n                           (swiden_low val @ (value_type $I16X8))\n                           (swiden_high val))))\n      (let ((mul_const XmmMem (emit_u128_le_const 0x0001_0001_0001_0001_0001_0001_0001_0001)))\n        (x64_pmaddwd val mul_const)))\n\n;; special case for the `i16x8.extadd_pairwise_i8x16_u` wasm instruction\n(rule 2 (lower\n        (has_type $I16X8 (iadd_pairwise\n                           (uwiden_low val @ (value_type $I8X16))\n                           (uwiden_high val))))\n      (if-let $true (use_ssse3))\n      (let ((mul_const XmmMem (emit_u128_le_const 0x01010101010101010101010101010101)))\n        (x64_pmaddubsw val mul_const)))\n\n;; special case for the `i32x4.extadd_pairwise_i16x8_u` wasm instruction\n(rule 2 (lower\n        (has_type $I32X4 (iadd_pairwise\n                           (uwiden_low val @ (value_type $I16X8))\n                           (uwiden_high val))))\n      (let ((xor_const XmmMem (emit_u128_le_const 0x8000_8000_8000_8000_8000_8000_8000_8000))\n            (dst Xmm (x64_pxor val xor_const))\n\n            (madd_const XmmMem (emit_u128_le_const 0x0001_0001_0001_0001_0001_0001_0001_0001))\n            (dst Xmm (x64_pmaddwd dst madd_const))\n\n            (addd_const XmmMem (emit_u128_le_const 0x00010000_00010000_00010000_00010000)))\n        (x64_paddd dst addd_const)))\n\n;; special case for the `i32x4.dot_i16x8_s` wasm instruction\n(rule 2 (lower\n        (has_type $I32X4 (iadd_pairwise\n                           (imul (swiden_low x) (swiden_low y))\n                           (imul (swiden_high x) (swiden_high y)))))\n      (x64_pmaddwd x y))\n\n;; Rules for `swiden_low` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; With SSE4.1 use the `pmovsx*` instructions for this\n(rule 1 (lower (has_type $I16X8 (swiden_low val @ (value_type $I8X16))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxbw val))\n(rule 1 (lower (has_type $I32X4 (swiden_low val @ (value_type $I16X8))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxwd val))\n(rule 1 (lower (has_type $I64X2 (swiden_low val @ (value_type $I32X4))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxdq val))\n\n(rule (lower (has_type ty (swiden_low val))) (lower_swiden_low ty val))\n\n(decl lower_swiden_low (Type Xmm) Xmm)\n\n;; Duplicate the low lanes next to each other, then perform a wider shift-right\n;; by the low lane width to move the upper of each pair back into the lower lane\n;; of each pair, achieving the widening of the lower lanes.\n(rule (lower_swiden_low $I16X8 val)\n      (x64_psraw (x64_punpcklbw val val) (xmi_imm 8)))\n(rule (lower_swiden_low $I32X4 val)\n      (x64_psrad (x64_punpcklwd val val) (xmi_imm 16)))\n\n;; Generate the sign-extended halves with a `val < 0` comparison (expressed\n;; reversed here), then interleave the low 32-bit halves to create the full\n;; 64-bit results.\n(rule (lower_swiden_low $I64X2 val)\n      (let ((tmp Xmm (x64_pcmpgtd (xmm_zero $I32X4) val)))\n      (x64_punpckldq val tmp)))\n\n;; Rules for `swiden_high` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Similar to `swiden_low` with SSE4.1 except that the upper lanes are moved\n;; to the lower lanes first.\n(rule 1 (lower (has_type $I16X8 (swiden_high val @ (value_type $I8X16))))\n        (if-let $true (use_sse41))\n        (if-let $true (use_ssse3))\n        (let ((x Xmm val))\n          (x64_pmovsxbw (x64_palignr x x 8))))\n(rule 1 (lower (has_type $I32X4 (swiden_high val @ (value_type $I16X8))))\n        (if-let $true (use_sse41))\n        (if-let $true (use_ssse3))\n        (let ((x Xmm val))\n          (x64_pmovsxwd (x64_palignr x x 8))))\n(rule 1 (lower (has_type $I64X2 (swiden_high val @ (value_type $I32X4))))\n        (if-let $true (use_sse41))\n        (x64_pmovsxdq (x64_pshufd val 0b11_10_11_10)))\n\n;; Similar to `swiden_low` versions but using `punpckh*` instructions to\n;; pair the high lanes next to each other.\n(rule (lower (has_type $I16X8 (swiden_high val @ (value_type $I8X16))))\n      (let ((val Xmm val))\n        (x64_psraw (x64_punpckhbw val val) (xmi_imm 8))))\n(rule (lower (has_type $I32X4 (swiden_high val @ (value_type $I16X8))))\n      (let ((val Xmm val))\n        (x64_psrad (x64_punpckhwd val val) (xmi_imm 16))))\n\n;; Same as `swiden_low`, but `val` has its high lanes moved down.\n(rule (lower (has_type $I64X2 (swiden_high val @ (value_type $I32X4))))\n      (let ((val Xmm (x64_pshufd val 0b00_00_11_10))\n            (tmp Xmm (x64_pcmpgtd (xmm_zero $I32X4) val)))\n      (x64_punpckldq val tmp)))\n\n;; Rules for `uwiden_low` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; With SSE4.1 use the `pmovzx*` instructions for this\n(rule 1 (lower (has_type $I16X8 (uwiden_low val @ (value_type $I8X16))))\n        (if-let $true (use_sse41))\n        (x64_pmovzxbw val))\n(rule 1 (lower (has_type $I32X4 (uwiden_low val @ (value_type $I16X8))))\n        (if-let $true (use_sse41))\n        (x64_pmovzxwd val))\n(rule 1 (lower (has_type $I64X2 (uwiden_low val @ (value_type $I32X4))))\n        (if-let $true (use_sse41))\n        (x64_pmovzxdq val))\n\n(rule (lower (has_type ty (uwiden_low val))) (lower_uwiden_low ty val))\n\n;; Interleave an all-zero register with the low lanes to produce zero-extended\n;; results.\n(decl lower_uwiden_low (Type Xmm) Xmm)\n(rule (lower_uwiden_low $I16X8 val) (x64_punpcklbw val (xmm_zero $I8X16)))\n(rule (lower_uwiden_low $I32X4 val) (x64_punpcklwd val (xmm_zero $I8X16)))\n(rule (lower_uwiden_low $I64X2 val) (x64_unpcklps val (xmm_zero $F32X4)))\n\n;; Rules for `uwiden_high` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Same as `uwiden_high`, but interleaving high lanes instead.\n;;\n;; Note that according to `llvm-mca` at least these instructions are faster\n;; than using `pmovzx*` in terms of cycles, even if SSE4.1 is available.\n(rule (lower (has_type $I16X8 (uwiden_high val @ (value_type $I8X16))))\n      (x64_punpckhbw val (xmm_zero $I8X16)))\n(rule (lower (has_type $I32X4 (uwiden_high val @ (value_type $I16X8))))\n      (x64_punpckhwd val (xmm_zero $I8X16)))\n(rule (lower (has_type $I64X2 (uwiden_high val @ (value_type $I32X4))))\n      (x64_unpckhps val (xmm_zero $F32X4)))\n\n;; Rules for `snarrow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16 (snarrow a @ (value_type $I16X8) b)))\n      (x64_packsswb a b))\n\n(rule (lower (has_type $I16X8 (snarrow a @ (value_type $I32X4) b)))\n      (x64_packssdw a b))\n\n;; We're missing a `snarrow` case for $I64X2\n;; https://github.com/bytecodealliance/wasmtime/issues/4734\n\n;; This rule is a special case for handling the translation of the wasm op\n;; `i32x4.trunc_sat_f64x2_s_zero`. It can be removed once we have an\n;; implementation of `snarrow` for `I64X2`.\n(rule (lower (has_type $I32X4 (snarrow (has_type $I64X2 (fcvt_to_sint_sat val))\n                                       (vconst (u128_from_constant 0)))))\n      (let ((a Xmm val)\n\n            ;; y = i32x4.trunc_sat_f64x2_s_zero(x) is lowered to:\n            ;; MOVE xmm_tmp, xmm_x\n            ;; CMPEQPD xmm_tmp, xmm_x\n            ;; MOVE xmm_y, xmm_x\n            ;; ANDPS xmm_tmp, [wasm_f64x2_splat(2147483647.0)]\n            ;; MINPD xmm_y, xmm_tmp\n            ;; CVTTPD2DQ xmm_y, xmm_y\n\n            (tmp1 Xmm (x64_cmppd a a (FcmpImm.Equal)))\n\n            ;; 2147483647.0 is equivalent to 0x41DFFFFFFFC00000\n            (umax_mask XmmMem (emit_u128_le_const 0x41DFFFFFFFC00000_41DFFFFFFFC00000))\n\n            ;; ANDPD xmm_y, [wasm_f64x2_splat(2147483647.0)]\n            (tmp1 Xmm (x64_andps tmp1 umax_mask))\n            (dst Xmm (x64_minpd a tmp1)))\n        (x64_cvttpd2dq dst)))\n\n;; This rule is a special case for handling the translation of the wasm op\n;; `i32x4.relaxed_trunc_f64x2_s_zero`.\n(rule (lower (has_type $I32X4 (snarrow (has_type $I64X2 (x86_cvtt2dq val))\n                                       (vconst (u128_from_constant 0)))))\n        (x64_cvttpd2dq val))\n\n;; Rules for `unarrow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I8X16 (unarrow a @ (value_type $I16X8) b)))\n      (x64_packuswb a b))\n\n(rule 1 (lower (has_type $I16X8 (unarrow a @ (value_type $I32X4) b)))\n        (if-let $true (use_sse41))\n        (x64_packusdw a b))\n\n;; For each input `a` and `b` take the four 32-bit lanes and compress them to\n;; the low 64-bits of the vector as four 16-bit lanes. Then these are woven\n;; into one final vector with a `punpcklqdq`.\n;;\n;; If this is performance sensitive then it's probably best to upgrade the CPU\n;; to get the above single-instruction lowering.\n(rule (lower (has_type $I16X8 (unarrow a @ (value_type $I32X4) b)))\n      (let (\n          (a Xmm (unarrow_i32x4_lanes_to_low_u16_lanes a))\n          (b Xmm (unarrow_i32x4_lanes_to_low_u16_lanes b))\n        )\n        (x64_punpcklqdq a b)))\n\n(decl unarrow_i32x4_lanes_to_low_u16_lanes (Xmm) Xmm)\n(rule (unarrow_i32x4_lanes_to_low_u16_lanes val)\n      (let (\n          ;; First convert all negative values in `val` to zero lanes.\n          (val_gt_zero Xmm (x64_pcmpgtd val (xmm_zero $I32X4)))\n          (val Xmm (x64_pand val val_gt_zero))\n\n          ;; Next clamp all larger-than-u16-max lanes to u16::MAX.\n          (max Xmm (x64_movdqu_load (emit_u128_le_const 0x0000ffff_0000ffff_0000ffff_0000ffff)))\n          (cmp Xmm (x64_pcmpgtd max val))\n          (valid_lanes Xmm (x64_pand val cmp))\n          (clamped_lanes Xmm (x64_pandn cmp max))\n          (val Xmm (x64_por valid_lanes clamped_lanes))\n\n          ;; Within each 64-bit half of the 32x4 vector move the first 16 bits\n          ;; and the third 16 bits to the bottom of the half. Afterwards\n          ;; for the 32x4 vector move the first and third lanes to the bottom\n          ;; lanes, which finishes up the conversion here as all the lanes\n          ;; are now converted to 16-bit values in the low 4 lanes.\n          (val Xmm (x64_pshuflw val 0b00_00_10_00))\n          (val Xmm (x64_pshufhw val 0b00_00_10_00))\n        )\n        (x64_pshufd val 0b00_00_10_00)))\n\n\n;; We're missing a `unarrow` case for $I64X2\n;; https://github.com/bytecodealliance/wasmtime/issues/4734\n\n;; Rules for `bitcast` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $I32 (bitcast _ src @ (value_type $F32))))\n      (bitcast_xmm_to_gpr $F32 src))\n\n(rule (lower (has_type $F32 (bitcast _ src @ (value_type $I32))))\n      (bitcast_gpr_to_xmm $I32 src))\n\n(rule (lower (has_type $I64 (bitcast _ src @ (value_type $F64))))\n      (bitcast_xmm_to_gpr $F64 src))\n\n(rule (lower (has_type $F64 (bitcast _ src @ (value_type $I64))))\n      (bitcast_gpr_to_xmm $I64 src))\n\n;; Bitcast between types residing in GPR registers is a no-op.\n(rule 1 (lower (has_type (is_gpr_type _)\n                         (bitcast _ x @ (value_type (is_gpr_type _))))) x)\n\n;; Bitcast between types residing in XMM registers is a no-op.\n(rule 2 (lower (has_type (is_xmm_type _)\n                         (bitcast _ x @ (value_type (is_xmm_type _))))) x)\n\n;; Rules for `fcopysign` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type $F32 (fcopysign a @ (value_type $F32) b)))\n      (let ((sign_bit Xmm (imm $F32 0x80000000)))\n        (x64_orps\n          (x64_andnps sign_bit a)\n          (x64_andps sign_bit b))))\n\n(rule (lower (has_type $F64 (fcopysign a @ (value_type $F64) b)))\n      (let ((sign_bit Xmm (imm $F64 0x8000000000000000)))\n        (x64_orpd\n          (x64_andnpd sign_bit a)\n          (x64_andpd sign_bit b))))\n\n;; Helper for the `ceil`/`floor`/`nearest`/`trunc` instructions ;;;;;;;;;;;;;;;;\n\n;; Emits either a `round{ss,sd,ps,pd}` instruction, as appropriate, or generates\n;; the appropriate libcall and sequence to call that.\n(decl x64_round (Type RegMem RoundImm) Xmm)\n(rule 1 (x64_round $F32 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundss a imm))\n(rule 1 (x64_round $F64 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundsd a imm))\n(rule 1 (x64_round $F32X4 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundps a imm))\n(rule 1 (x64_round $F64X2 a imm)\n        (if-let $true (use_sse41))\n        (x64_roundpd a imm))\n\n(rule (x64_round $F32 (RegMem.Reg a) imm) (libcall_1 (round_libcall $F32 imm) a))\n(rule (x64_round $F64 (RegMem.Reg a) imm) (libcall_1 (round_libcall $F64 imm) a))\n(rule (x64_round $F32X4 (RegMem.Reg a) imm)\n      (let (\n          (libcall LibCall (round_libcall $F32 imm))\n          (result Xmm (libcall_1 libcall a))\n          (a1 Xmm (libcall_1 libcall (x64_pshufd a 1)))\n          (result Xmm (vec_insert_lane $F32X4 result a1 1))\n          (a2 Xmm (libcall_1 libcall (x64_pshufd a 2)))\n          (result Xmm (vec_insert_lane $F32X4 result a2 2))\n          (a3 Xmm (libcall_1 libcall (x64_pshufd a 3)))\n          (result Xmm (vec_insert_lane $F32X4 result a3 3))\n        )\n        result))\n(rule (x64_round $F64X2 (RegMem.Reg a) imm)\n      (let (\n          (libcall LibCall (round_libcall $F64 imm))\n          (result Xmm (libcall_1 libcall a))\n          (a1 Xmm (libcall_1 libcall (x64_pshufd a 0b00_00_11_10)))\n          (result Xmm (vec_insert_lane $F64X2 result a1 1))\n        )\n        result))\n(rule (x64_round ty (RegMem.Mem addr) imm)\n      (x64_round ty (RegMem.Reg (x64_load ty addr (ExtKind.ZeroExtend))) imm))\n\n(decl round_libcall (Type RoundImm) LibCall)\n(rule (round_libcall $F32 (RoundImm.RoundUp)) (LibCall.CeilF32))\n(rule (round_libcall $F64 (RoundImm.RoundUp)) (LibCall.CeilF64))\n(rule (round_libcall $F32 (RoundImm.RoundDown)) (LibCall.FloorF32))\n(rule (round_libcall $F64 (RoundImm.RoundDown)) (LibCall.FloorF64))\n(rule (round_libcall $F32 (RoundImm.RoundNearest)) (LibCall.NearestF32))\n(rule (round_libcall $F64 (RoundImm.RoundNearest)) (LibCall.NearestF64))\n(rule (round_libcall $F32 (RoundImm.RoundZero)) (LibCall.TruncF32))\n(rule (round_libcall $F64 (RoundImm.RoundZero)) (LibCall.TruncF64))\n\n;; Rules for `ceil` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (ceil a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundUp)))\n\n;; Rules for `floor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (floor a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundDown)))\n\n;; Rules for `nearest` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (nearest a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundNearest)))\n\n;; Rules for `trunc` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (trunc a @ (value_type ty)))\n      (x64_round ty a (RoundImm.RoundZero)))\n\n;; Rules for `stack_addr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (stack_addr stack_slot offset))\n      (stack_addr_impl stack_slot offset))\n\n;; Rules for `udiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; NB: a `RegMem` divisor, while allowed in the instruction encoding, isn't\n;; used right now to prevent a possibly-trapping load getting folded into the\n;; `div` instruction. Ideally non-trapping loads would get folded, however, or\n;; alternatively Wasmtime/Cranelift would grow support for multiple traps on\n;; a single opcode and the signal kind would differentiate at runtime.\n\n;; The inputs to the `div` instruction are different for 8-bit division so\n;; it needs a special case here since the instruction being crafted has a\n;; different shape.\n(rule 2 (lower (udiv a @ (value_type $I8) b))\n        (x64_div8 (extend_to_gpr a $I32 (ExtendKind.Zero))\n                  (put_in_gpr b)\n                  (DivSignedness.Unsigned)\n                  (TrapCode.IntegerDivisionByZero)))\n\n;; 16-to-64-bit division is all done with a similar instruction and the only\n;; tricky requirement here is that when div traps are disallowed the divisor\n;; must not be zero.\n(rule 1 (lower (udiv a @ (value_type (fits_in_64 ty)) b))\n        (x64_div_quotient a\n                          (imm $I64 0)\n                          (put_in_gpr b)\n                          (raw_operand_size_of_type ty)\n                          (DivSignedness.Unsigned)\n                          (TrapCode.IntegerDivisionByZero)))\n\n;; Rules for `sdiv` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 2 (lower (sdiv a @ (value_type $I8) b))\n        (x64_div8 (x64_sign_extend_data a (OperandSize.Size8))\n                  (nonzero_sdiv_divisor $I8 b)\n                  (DivSignedness.Signed)\n                  (TrapCode.IntegerOverflow)))\n\n(rule 1 (lower (sdiv a @ (value_type (fits_in_64 ty)) b))\n        (let (\n            (a Gpr a)\n            (size OperandSize (raw_operand_size_of_type ty))\n          )\n        (x64_div_quotient a\n                          (x64_sign_extend_data a size)\n                          (nonzero_sdiv_divisor ty b)\n                          size\n                          (DivSignedness.Signed)\n                          (TrapCode.IntegerOverflow))))\n\n;; Checks to make sure that the input `Value` is a non-zero value for `sdiv`.\n;;\n;; This is required to differentiate the divide-by-zero trap from the\n;; integer-overflow trap, the two trapping conditions of signed division.\n(decl nonzero_sdiv_divisor (Type Value) Reg)\n(rule 1 (nonzero_sdiv_divisor ty (iconst imm))\n        (if-let n (safe_divisor_from_imm64 ty imm))\n        (imm ty n))\n(rule 0 (nonzero_sdiv_divisor ty val)\n      (let (\n          (val Reg val)\n          (_ InstOutput (side_effect (with_flags_side_effect\n            (x64_test (raw_operand_size_of_type ty) val val)\n            (trap_if (CC.Z) (TrapCode.IntegerDivisionByZero)))))\n        )\n        val))\n\n;; Rules for `urem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; The remainder is in AH, so take the result of the division and right-shift\n;; by 8.\n(rule 2 (lower (urem a @ (value_type $I8) b))\n        (let (\n            (result Gpr (x64_div8 (extend_to_gpr a $I32 (ExtendKind.Zero))\n                                  (put_in_gpr b) ;; see `udiv` for why not `gpr_mem`\n                                  (DivSignedness.Unsigned)\n                                  (TrapCode.IntegerDivisionByZero)))\n          )\n          (x64_shr $I64 result (Imm8Reg.Imm8 8))))\n\n(rule 1 (lower (urem a @ (value_type (fits_in_64 ty)) b))\n        (x64_div_remainder a\n                           (imm $I64 0)\n                           (put_in_gpr b) ;; see `udiv` for why not `gpr_mem`\n                           (raw_operand_size_of_type ty)\n                           (DivSignedness.Unsigned)\n                           (TrapCode.IntegerDivisionByZero)))\n\n;; Rules for `srem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Special-cases first for constant `srem` where the checks for 0 and -1 aren't\n;; applicable.\n;;\n;; Note that like `urem` for i8 types the result is in AH so to get the result\n;; it's right-shifted down.\n(rule 3 (lower (srem a @ (value_type $I8) (iconst imm)))\n        (if-let n (safe_divisor_from_imm64 $I8 imm))\n        (let (\n            (a Gpr (x64_sign_extend_data a (OperandSize.Size8)))\n            (result Gpr (x64_div8 a (imm $I8 n) (DivSignedness.Signed) (TrapCode.IntegerDivisionByZero)))\n          )\n          (x64_shr $I64 result (Imm8Reg.Imm8 8))))\n\n;; Same as the above rule but for 16-to-64 bit types.\n(rule 2 (lower (srem a @ (value_type ty) (iconst imm)))\n        (if-let n (safe_divisor_from_imm64 ty imm))\n        (let (\n            (a Gpr a)\n            (size OperandSize (raw_operand_size_of_type ty))\n          )\n          (x64_div_remainder a\n                             (x64_sign_extend_data a size)\n                             (imm ty n)\n                             size\n                             (DivSignedness.Signed)\n                             (TrapCode.IntegerDivisionByZero))))\n\n(rule 1 (lower (srem a @ (value_type $I8) b))\n        (let (\n            (a Gpr (x64_sign_extend_data a (OperandSize.Size8)))\n          )\n          (x64_shr $I64 (x64_checked_srem_seq8 a b) (Imm8Reg.Imm8 8))))\n\n(rule (lower (srem a @ (value_type ty) b))\n      (let (\n          (a Gpr a)\n          (size OperandSize (raw_operand_size_of_type ty))\n          (hi Gpr (x64_sign_extend_data a size))\n          (tmp ValueRegs (x64_checked_srem_seq size a hi b))\n        )\n        (value_regs_get tmp 1)))\n\n;; Rules for `umulhi` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (umulhi a @ (value_type $I16) b))\n      (let ((res ValueRegs (mul_hi $I16 $false a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (umulhi a @ (value_type $I32) b))\n      (let ((res ValueRegs (mul_hi $I32 $false a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (umulhi a @ (value_type $I64) b))\n      (let ((res ValueRegs (mul_hi $I64 $false a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n;; Rules for `smulhi` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (smulhi a @ (value_type $I16) b))\n      (let ((res ValueRegs (mul_hi $I16 $true a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (smulhi a @ (value_type $I32) b))\n      (let ((res ValueRegs (mul_hi $I32 $true a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n(rule (lower (smulhi a @ (value_type $I64) b))\n      (let ((res ValueRegs (mul_hi $I64 $true a b))\n            (hi Gpr (value_regs_get_gpr res 1)))\n        hi))\n\n;; Rules for `get_pinned_reg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (get_pinned_reg))\n      (read_pinned_gpr))\n\n;; Rules for `set_pinned_reg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (set_pinned_reg a @ (value_type ty)))\n      (side_effect (write_pinned_gpr a)))\n\n;; Rules for `vconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type ty (vconst const)))\n      ;; TODO use Inst::gen_constant() instead.\n      (x64_xmm_load_const ty (const_to_vconst const)))\n\n;; Rules for `shuffle` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Special case for `pblendw` which takes an 8-bit immediate where each bit\n;; indicates which lane of the two operands is chosen for the output. A bit of\n;; 0 chooses the corresponding 16-it lane from `a` and a bit of 1 chooses the\n;; corresponding 16-bit lane from `b`.\n(rule 14 (lower (shuffle a b (pblendw_imm n)))\n         (if-let $true (use_sse41))\n         (x64_pblendw a b n))\n(decl pblendw_imm (u8) Immediate)\n(extern extractor pblendw_imm pblendw_imm)\n\n;; When the shuffle looks like \"concatenate `a` and `b` and shift right by n*8\n;; bytes\", that's a `palignr` instruction. Note that the order of operands are\n;; swapped in the instruction here. The `palignr` instruction uses the second\n;; operand as the low-order bytes and the first operand as high-order bytes,\n;; so put `a` second.\n(rule 13 (lower (shuffle a b (palignr_imm_from_immediate n)))\n         (if-let $true (use_ssse3))\n         (x64_palignr b a n))\n(decl palignr_imm_from_immediate (u8) Immediate)\n(extern extractor palignr_imm_from_immediate palignr_imm_from_immediate)\n\n;; Special case the `pshuf{l,h}w` instruction which shuffles four 16-bit\n;; integers within one value, preserving the other four 16-bit integers in that\n;; value (either the high or low half). The complicated logic is in the\n;; extractors here implemented in Rust and note that there's two cases for each\n;; instruction here to match when either the first or second shuffle operand is\n;; used.\n(rule 12 (lower (shuffle x y (pshuflw_lhs_imm imm)))\n      (x64_pshuflw x imm))\n(rule 11 (lower (shuffle x y (pshuflw_rhs_imm imm)))\n      (x64_pshuflw y imm))\n(rule 10 (lower (shuffle x y (pshufhw_lhs_imm imm)))\n      (x64_pshufhw x imm))\n(rule 9 (lower (shuffle x y (pshufhw_rhs_imm imm)))\n      (x64_pshufhw y imm))\n\n(decl pshuflw_lhs_imm (u8) Immediate)\n(extern extractor pshuflw_lhs_imm pshuflw_lhs_imm)\n(decl pshuflw_rhs_imm (u8) Immediate)\n(extern extractor pshuflw_rhs_imm pshuflw_rhs_imm)\n(decl pshufhw_lhs_imm (u8) Immediate)\n(extern extractor pshufhw_lhs_imm pshufhw_lhs_imm)\n(decl pshufhw_rhs_imm (u8) Immediate)\n(extern extractor pshufhw_rhs_imm pshufhw_rhs_imm)\n\n;; Special case for the `pshufd` instruction which will permute 32-bit values\n;; within a single register. This is only applicable if the `imm` specified\n;; selects 32-bit values from either `x` or `y`, but not both. This means\n;; there's one rule for selecting from `x` and another rule for selecting from\n;; `y`.\n(rule 8 (lower (shuffle x y (pshufd_lhs_imm imm)))\n      (x64_pshufd x imm))\n(rule 7 (lower (shuffle x y (pshufd_rhs_imm imm)))\n      (x64_pshufd y imm))\n\n(decl pshufd_lhs_imm (u8) Immediate)\n(extern extractor pshufd_lhs_imm pshufd_lhs_imm)\n(decl pshufd_rhs_imm (u8) Immediate)\n(extern extractor pshufd_rhs_imm pshufd_rhs_imm)\n\n;; Special case for i8-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f0f_1e0e_1d0d_1c0c_1b0b_1a0a_1909_1808)))\n      (x64_punpckhbw a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1707_1606_1505_1404_1303_1202_1101_1000)))\n      (x64_punpcklbw a b))\n\n;; Special case for i16-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f1e_0f0e_1d1c_0d0c_1b1a_0b0a_1918_0908)))\n      (x64_punpckhwd a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1716_0706_1514_0504_1312_0302_1110_0100)))\n      (x64_punpcklwd a b))\n\n;; Special case for i32-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f1e1d1c_0f0e0d0c_1b1a1918_0b0a0908)))\n      (x64_punpckhdq a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x17161514_07060504_13121110_03020100)))\n      (x64_punpckldq a b))\n\n;; Special case for i64-level interleaving of upper/low bytes.\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1f1e1d1c1b1a1918_0f0e0d0c0b0a0908)))\n      (x64_punpckhqdq a b))\n(rule 6 (lower (shuffle a b (u128_from_immediate 0x1716151413121110_0706050403020100)))\n      (x64_punpcklqdq a b))\n\n;; If the vector shift mask is all 0s then that means the first byte of the\n;; first operand is broadcast to all bytes. Falling through would load an\n;; all-zeros constant from a rip-relative location but it should be slightly\n;; more efficient to execute the `pshufb` here-and-now with an xor'd-to-be-zero\n;; register.\n(rule 6 (lower (shuffle a _ (u128_from_immediate 0)))\n        (if-let $true (use_ssse3))\n        (x64_pshufb a (xmm_zero $I8X16)))\n\n;; Special case for the `shufps` instruction which will select two 32-bit values\n;; from the first operand and two 32-bit values from the second operand. Note\n;; that there is a second case here as well for when the operands can be\n;; swapped.\n;;\n;; Note that the priority of this instruction is currently lower than the above\n;; special cases since `shufps` handles many of them and for now it's\n;; hypothesized that the dedicated instructions are better than `shufps`.\n;; Someone with more knowledge about x86 timings should perhaps reorder the\n;; rules here eventually though.\n(rule 5 (lower (shuffle x y (shufps_imm imm)))\n      (x64_shufps x y imm))\n(rule 4 (lower (shuffle x y (shufps_rev_imm imm)))\n      (x64_shufps y x imm))\n\n(decl shufps_imm(u8) Immediate)\n(extern extractor shufps_imm shufps_imm)\n(decl shufps_rev_imm(u8) Immediate)\n(extern extractor shufps_rev_imm shufps_rev_imm)\n\n\n;; If `lhs` and `rhs` are the same we can use a single PSHUFB to shuffle the XMM\n;; register. We statically build `constructed_mask` to zero out any unknown lane\n;; indices (may not be completely necessary: verification could fail incorrect\n;; mask values) and fix the indexes to all point to the `dst` vector.\n(rule 3 (lower (shuffle a a (vec_mask_from_immediate mask)))\n        (if-let $true (use_ssse3))\n        (x64_pshufb a (shuffle_0_31_mask mask)))\n\n;; For the case where the shuffle mask contains out-of-bounds values (values\n;; greater than 31) we must mask off those resulting values in the result of\n;; `vpermi2b`.\n(rule 2 (lower (shuffle a b (vec_mask_from_immediate (perm_from_mask_with_zeros mask zeros))))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512vbmi))\n      (x64_andps (x64_vpermi2b (x64_xmm_load_const $I8X16 mask) a b) zeros))\n\n;; However, if the shuffle mask contains no out-of-bounds values, we can use\n;; `vpermi2b` without any masking.\n(rule 1 (lower (shuffle a b (vec_mask_from_immediate mask)))\n      (if-let $true (use_avx512vl))\n      (if-let $true (use_avx512vbmi))\n      (x64_vpermi2b (x64_xmm_load_const $I8X16 (perm_from_mask mask)) a b))\n\n;; If `lhs` and `rhs` are different, we must shuffle each separately and then OR\n;; them together. This is necessary due to PSHUFB semantics. As in the case\n;; above, we build the `constructed_mask` for each case statically.\n(rule (lower (shuffle a b (vec_mask_from_immediate mask)))\n      (x64_por\n        (lower_pshufb a (shuffle_0_15_mask mask))\n        (lower_pshufb b (shuffle_16_31_mask mask))))\n\n;; Rules for `swizzle` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; SIMD swizzle; the following inefficient implementation is due to the Wasm\n;; SIMD spec requiring mask indexes greater than 15 to have the same semantics\n;; as a 0 index. For the spec discussion, see\n;; https://github.com/WebAssembly/simd/issues/93. The CLIF semantics match the\n;; Wasm SIMD semantics for this instruction. The instruction format maps to\n;; variables like: %dst = swizzle %src, %mask\n(rule (lower (swizzle src mask))\n      (let ((mask Xmm (x64_paddusb mask (emit_u128_le_const 0x70707070707070707070707070707070))))\n        (lower_pshufb src mask)))\n\n;; Rules for `x86_pshufb` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (x86_pshufb src mask))\n      (if-let $true (use_ssse3))\n      (x64_pshufb src mask))\n\n;; A helper function to generate either the `pshufb` instruction or a libcall to\n;; the `X86Pshufb` libcall. Note that the libcall is not exactly the most\n;; performant thing in the world so this is primarily here for completeness\n;; of lowerings on all x86 cpus but if rules are ideally gated on the presence\n;; of SSSE3 to use the `pshufb` instruction itself.\n(decl lower_pshufb (Xmm RegMem) Xmm)\n(rule 1 (lower_pshufb src mask)\n        (if-let $true (use_ssse3))\n        (x64_pshufb src mask))\n(rule (lower_pshufb src (RegMem.Reg mask))\n      (libcall_2 (LibCall.X86Pshufb) src mask))\n(rule (lower_pshufb src (RegMem.Mem addr))\n      (lower_pshufb src (x64_movdqu_load addr)))\n\n;; Rules for `extractlane` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Remove the extractlane instruction, leaving the float where it is. The upper\n;; bits will remain unchanged; for correctness, this relies on Cranelift type\n;; checking to avoid using those bits.\n(rule 3 (lower (has_type (ty_scalar_float _) (extractlane val 0)))\n        val)\n\n;; `f32x4.extract_lane N` where `N != 0`\n(rule 1 (lower (extractlane val @ (value_type $F32X4) (u8_from_uimm8 lane)))\n        (x64_pshufd val lane))\n\n;; `f64x2.extract_lane N` where `N != 0` (aka N == 1)\n(rule (lower (extractlane val @ (value_type $F64X2) 1))\n      (x64_pshufd val 0b11_10_11_10))\n\n;; `i8x16.extract_lane N`\n;;\n;; Note that without SSE4.1 a 16-bit lane extraction is performed and then\n;; the result is updated if the desired index is either odd or even.\n(rule 2 (lower (extractlane val @ (value_type ty @ $I8X16) (u8_from_uimm8 lane)))\n        (if-let $true (use_sse41))\n        (x64_pextrb val lane))\n;; extracting an odd lane has an extra shift-right\n(rule 1 (lower (extractlane val @ (value_type ty @ $I8X16) (u8_from_uimm8 lane)))\n        (if-let 1 (u8_and lane 1))\n        (x64_shr $I16 (x64_pextrw val (u8_shr lane 1)) (Imm8Reg.Imm8 8)))\n;; Extracting an even lane already has the desired lane in the lower bits. Note\n;; that having arbitrary upper bits in the returned register should be ok since\n;; all operators on the resulting `i8` type should work correctly regardless of\n;; the bits in the rest of the register.\n(rule (lower (extractlane val @ (value_type ty @ $I8X16) (u8_from_uimm8 lane)))\n      (if-let 0 (u8_and lane 1))\n      (x64_pextrw val (u8_shr lane 1)))\n\n;; `i16x8.extract_lane N`\n(rule (lower (extractlane val @ (value_type ty @ $I16X8) (u8_from_uimm8 lane)))\n      (x64_pextrw val lane))\n\n;; `i32x4.extract_lane N`\n(rule 2 (lower (extractlane val @ (value_type ty @ $I32X4) (u8_from_uimm8 lane)))\n        (if-let $true (use_sse41))\n        (x64_pextrd val lane))\n(rule 1 (lower (extractlane val @ (value_type $I32X4) 0))\n        (x64_movd_to_gpr val))\n(rule (lower (extractlane val @ (value_type $I32X4) (u8_from_uimm8 n)))\n      (x64_movd_to_gpr (x64_pshufd val n)))\n\n;; `i64x2.extract_lane N`\n(rule 1 (lower (extractlane val @ (value_type $I64X2) (u8_from_uimm8 lane)))\n        (if-let $true (use_sse41))\n        (x64_pextrq val lane))\n(rule (lower (extractlane val @ (value_type $I64X2) 0))\n      (x64_movq_to_gpr val))\n(rule (lower (extractlane val @ (value_type $I64X2) 1))\n      (x64_movq_to_gpr (x64_pshufd val 0b00_00_11_10)))\n\n;; Rules for `scalar_to_vector` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Case 1: when moving a scalar float, we simply move from one XMM register\n;; to another, expecting the register allocator to elide this. Here we\n;; assume that the upper bits of a scalar float have not been munged with\n;; (the same assumption the old backend makes).\n(rule 1 (lower (scalar_to_vector src @ (value_type (ty_scalar_float _))))\n      src)\n\n;; Case 2: when moving a scalar value of any other type, use MOVD to zero\n;; the upper lanes.\n(rule (lower (scalar_to_vector src @ (value_type ty)))\n      (bitcast_gpr_to_xmm ty src))\n\n;; Case 3: when presented with `load + scalar_to_vector`, coalesce into a single\n;; MOVSS/MOVSD instruction.\n(rule 2 (lower (scalar_to_vector (and (sinkable_load src) (value_type (ty_32 _)))))\n      (x64_movss_load src))\n(rule 3 (lower (scalar_to_vector (and (sinkable_load src) (value_type (ty_64 _)))))\n      (x64_movsd_load src))\n\n;; Rules for `splat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; For all the splat rules below one of the goals is that splatting a value\n;; doesn't end up accidentally depending on the previous value in a register.\n;; This means that instructions are chosen to avoid false dependencies where\n;; new values are created fresh or otherwise overwrite previous register\n;; contents where possible.\n;;\n;; Additionally splats are specialized to special-case load-and-splat which\n;; has a number of micro-optimizations available.\n\n;; i8x16 splats: use `vpbroadcastb` on AVX2 and otherwise `pshufb` broadcasts\n;; with a mask of zero which is calculated with an xor-against-itself register.\n(rule 0 (lower (has_type $I8X16 (splat src)))\n        (let ((src Xmm (x64_movd_to_xmm src)))\n          (x64_pshufd (x64_pshuflw (x64_punpcklbw src src) 0) 0)))\n(rule 1 (lower (has_type $I8X16 (splat src)))\n        (if-let $true (use_ssse3))\n        (x64_pshufb (bitcast_gpr_to_xmm $I32 src) (xmm_zero $I8X16)))\n(rule 2 (lower (has_type $I8X16 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastb (bitcast_gpr_to_xmm $I32 src)))\n(rule 3 (lower (has_type $I8X16 (splat (sinkable_load_exact addr))))\n        (if-let $true (use_sse41))\n        (if-let $true (use_ssse3))\n        (x64_pshufb (x64_pinsrb (xmm_uninit_value) addr 0) (xmm_zero $I8X16)))\n(rule 4 (lower (has_type $I8X16 (splat (sinkable_load_exact addr))))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastb addr))\n\n;; i16x8 splats: use `vpbroadcastw` on AVX2 and otherwise a 16-bit value is\n;; loaded into an xmm register, `pshuflw` broadcasts the low 16-bit lane\n;; to the low four lanes, and `pshufd` broadcasts the low 32-bit lane (which\n;; at that point is two of the 16-bit values we want to broadcast) to all the\n;; lanes.\n(rule 0 (lower (has_type $I16X8 (splat src)))\n        (x64_pshufd (x64_pshuflw (bitcast_gpr_to_xmm $I32 src) 0) 0))\n(rule 1 (lower (has_type $I16X8 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastw (bitcast_gpr_to_xmm $I32 src)))\n(rule 2 (lower (has_type $I16X8 (splat (sinkable_load_exact addr))))\n        (x64_pshufd (x64_pshuflw (x64_pinsrw (xmm_uninit_value) addr 0) 0) 0))\n(rule 3 (lower (has_type $I16X8 (splat (sinkable_load_exact addr))))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastw addr))\n\n;; i32x4.splat - use `vpbroadcastd` on AVX2 and otherwise `pshufd` can be\n;; used to broadcast the low lane to all other lanes.\n;;\n;; Note that sinkable-load cases come later\n(rule 0 (lower (has_type $I32X4 (splat src)))\n        (x64_pshufd (bitcast_gpr_to_xmm $I32 src) 0))\n(rule 1 (lower (has_type $I32X4 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vpbroadcastd (bitcast_gpr_to_xmm $I32 src)))\n\n;; f32x4.splat - the source is already in an xmm register so `shufps` is all\n;; that's necessary to complete the splat. This is specialized to `vbroadcastss`\n;; on AVX2 to leverage that specific instruction for this operation.\n(rule 0 (lower (has_type $F32X4 (splat src)))\n        (let ((tmp Xmm src))\n          (x64_shufps src src 0)))\n(rule 1 (lower (has_type $F32X4 (splat src)))\n        (if-let $true (use_avx2))\n        (x64_vbroadcastss src))\n\n;; t32x4.splat of a load - use a `movss` to load into an xmm register and then\n;; `shufps` broadcasts to the other lanes. Note that this is used for both i32\n;; and f32 splats.\n;;\n;; With AVX the `vbroadcastss` instruction suits this purpose precisely. Note\n;; that the memory-operand encoding of `vbroadcastss` is usable with AVX, but\n;; the register-based encoding is only available with AVX2. With the\n;; `sinkable_load` extractor this should be guaranteed to use the memory-based\n;; encoding hence the `use_avx` test.\n(rule 5 (lower (has_type (multi_lane 32 4) (splat (sinkable_load addr))))\n        (let ((tmp Xmm (x64_movss_load addr)))\n          (x64_shufps tmp tmp 0)))\n(rule 6 (lower (has_type (multi_lane 32 4) (splat (sinkable_load addr))))\n        (if-let $true (use_avx))\n        (x64_vbroadcastss addr))\n\n;; t64x2.splat - use `pshufd` to broadcast the lower 64-bit lane to the upper\n;; lane. A minor specialization for sinkable loads to avoid going through a gpr\n;; for i64 splats is used as well when `movddup` is available.\n(rule 0 (lower (has_type $I64X2 (splat src)))\n        (x64_pshufd (bitcast_gpr_to_xmm $I64 src) 0b01_00_01_00))\n(rule 0 (lower (has_type $F64X2 (splat src)))\n        (x64_pshufd src 0b01_00_01_00))\n(rule 6 (lower (has_type (multi_lane 64 2) (splat (sinkable_load addr))))\n        (if-let $true (use_ssse3))\n        (x64_movddup addr))\n\n;; Rules for `vany_true` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (vany_true val))\n        (if-let $true (use_sse41))\n        (let ((val Xmm val))\n          (with_flags (x64_ptest val val) (x64_setcc (CC.NZ)))))\n\n;; Any nonzero byte in `val` means that any lane is true. Compare `val` with a\n;; zeroed register and extract the high bits to a gpr mask. If the mask is\n;; 0xffff then every byte was equal to zero, so test if the comparison is\n;; not-equal or NZ.\n(rule (lower (vany_true val))\n      (let (\n          (any_byte_zero Xmm (x64_pcmpeqb val (xmm_zero $I8X16)))\n          (mask Gpr (x64_pmovmskb (OperandSize.Size32) any_byte_zero))\n        )\n        (with_flags (x64_cmp (OperandSize.Size32) (RegMemImm.Imm 0xffff) mask)\n                    (x64_setcc (CC.NZ)))))\n\n;; Rules for `vall_true` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (vall_true val @ (value_type ty)))\n        (if-let $true (use_sse41))\n        (let ((src Xmm val)\n              (zeros Xmm (xmm_zero ty))\n              (cmp Xmm (x64_pcmpeq (vec_int_type ty) src zeros)))\n          (with_flags (x64_ptest cmp cmp) (x64_setcc (CC.Z)))))\n\n;; Perform an appropriately-sized lane-wise comparison with zero. If the\n;; result is all 0s then all of them are true because nothing was equal to\n;; zero.\n(rule (lower (vall_true val @ (value_type ty)))\n      (let ((lanes_with_zero Xmm (x64_pcmpeq (vec_int_type ty) val (xmm_zero ty)))\n            (mask Gpr (x64_pmovmskb (OperandSize.Size32) lanes_with_zero)))\n        (with_flags (x64_test (OperandSize.Size32) mask mask)\n                    (x64_setcc (CC.Z)))))\n\n;; Rules for `vhigh_bits` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; The Intel specification allows using both 32-bit and 64-bit GPRs as\n;; destination for the \"move mask\" instructions. This is controlled by the REX.R\n;; bit: \"In 64-bit mode, the instruction can access additional registers when\n;; used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode\"\n;; (PMOVMSKB in IA Software Development Manual, vol. 2). This being the case, we\n;; will always clear REX.W since its use is unnecessary (`OperandSize` is used\n;; for setting/clearing REX.W) as we need at most 16 bits of output for\n;; `vhigh_bits`.\n\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 8 16))))\n      (x64_pmovmskb (OperandSize.Size32) val))\n\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 32 4))))\n      (x64_movmskps (OperandSize.Size32) val))\n\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 64 2))))\n      (x64_movmskpd (OperandSize.Size32) val))\n\n;; There is no x86 instruction for extracting the high bit of 16-bit lanes so\n;; here we:\n;; - duplicate the 16-bit lanes of `src` into 8-bit lanes:\n;;     PACKSSWB([x1, x2, ...], [x1, x2, ...]) = [x1', x2', ..., x1', x2', ...]\n;; - use PMOVMSKB to gather the high bits; now we have duplicates, though\n;; - shift away the bottom 8 high bits to remove the duplicates.\n(rule (lower (vhigh_bits val @ (value_type (multi_lane 16 8))))\n      (let ((src Xmm val)\n            (tmp Xmm (x64_packsswb src src))\n            (tmp Gpr (x64_pmovmskb (OperandSize.Size32) tmp)))\n        (x64_shr $I64 tmp (Imm8Reg.Imm8 8))))\n\n;; Rules for `iconcat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (iconcat lo @ (value_type $I64) hi))\n      (value_regs lo hi))\n\n;; Rules for `isplit` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (isplit val @ (value_type $I128)))\n      (let ((regs ValueRegs val)\n            (lo Reg (value_regs_get regs 0))\n            (hi Reg (value_regs_get regs 1)))\n        (output_pair lo hi)))\n\n;; Rules for `tls_value` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (has_type (tls_model (TlsModel.ElfGd)) (tls_value (symbol_value_data name _ _))))\n      (elf_tls_get_addr name))\n\n(rule (lower (has_type (tls_model (TlsModel.Macho)) (tls_value (symbol_value_data name _ _))))\n      (macho_tls_get_addr name))\n\n(rule (lower (has_type (tls_model (TlsModel.Coff)) (tls_value (symbol_value_data name _ _))))\n      (coff_tls_get_addr name))\n\n;; Rules for `sqmul_round_sat` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule 1 (lower (sqmul_round_sat qx @ (value_type $I16X8) qy))\n        (if-let $true (use_ssse3))\n        (let ((src1 Xmm qx)\n              (src2 Xmm qy)\n\n              (mask XmmMem (emit_u128_le_const 0x8000_8000_8000_8000_8000_8000_8000_8000))\n              (dst Xmm (x64_pmulhrsw src1 src2))\n              (cmp Xmm (x64_pcmpeqw dst mask)))\n          (x64_pxor dst cmp)))\n\n;; This operation is defined in wasm as:\n;;\n;;    S.SignedSaturate((x * y + 0x4000) >> 15)\n;;\n;; so perform all those operations here manually with a lack of the native\n;; instruction.\n(rule (lower (sqmul_round_sat qx @ (value_type $I16X8) qy))\n      (let (\n          (qx Xmm qx)\n          (qy Xmm qy)\n          ;; Multiply `qx` and `qy` generating 32-bit intermediate results. The\n          ;; 32-bit results have their low-halves stored in `mul_lsb` and the\n          ;; high halves are stored in `mul_msb`. These are then shuffled into\n          ;; `mul_lo` and `mul_hi` which represent the low 4 multiplications\n          ;; and the upper 4 multiplications.\n          (mul_lsb Xmm (x64_pmullw qx qy))\n          (mul_msb Xmm (x64_pmulhw qx qy))\n          (mul_lo Xmm (x64_punpcklwd mul_lsb mul_msb))\n          (mul_hi Xmm (x64_punpckhwd mul_lsb mul_msb))\n          ;; Add the 0x4000 constant to all multiplications\n          (val Xmm (x64_movdqu_load (emit_u128_le_const 0x00004000_00004000_00004000_00004000)))\n          (mul_lo Xmm (x64_paddd mul_lo val))\n          (mul_hi Xmm (x64_paddd mul_hi val))\n          ;; Perform the right-shift by 15 to all multiplications\n          (lo Xmm (x64_psrad mul_lo (xmi_imm 15)))\n          (hi Xmm (x64_psrad mul_hi (xmi_imm 15)))\n        )\n        ;; And finally perform a saturating 32-to-16-bit conversion.\n        (x64_packssdw lo hi)))\n\n;; Rules for `x86_pmulhrsw` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (x86_pmulhrsw qx @ (value_type $I16X8) qy))\n      (if-let $true (use_ssse3))\n      (x64_pmulhrsw qx qy))\n\n;; Rules for `uunarrow` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO: currently we only lower a special case of `uunarrow` needed to support\n;; the translation of wasm's i32x4.trunc_sat_f64x2_u_zero operation.\n;; https://github.com/bytecodealliance/wasmtime/issues/4791\n;;\n;; y = i32x4.trunc_sat_f64x2_u_zero(x) is lowered to:\n;; MOVAPD xmm_y, xmm_x\n;; XORPD xmm_tmp, xmm_tmp\n;; MAXPD xmm_y, xmm_tmp\n;; MINPD xmm_y, [wasm_f64x2_splat(4294967295.0)]\n;; ROUNDPD xmm_y, xmm_y, 0x0B\n;; ADDPD xmm_y, [wasm_f64x2_splat(0x1.0p+52)]\n;; SHUFPS xmm_y, xmm_xmp, 0x88\n(rule (lower (uunarrow (fcvt_to_uint_sat src @ (value_type $F64X2))\n                       (vconst (u128_from_constant 0))))\n      (let ((src Xmm src)\n\n            ;; MOVAPD xmm_y, xmm_x\n            ;; XORPD xmm_tmp, xmm_tmp\n            (zeros Xmm (xmm_zero $F64X2))\n            (dst Xmm (x64_maxpd src zeros))\n\n            ;; 4294967295.0 is equivalent to 0x41EFFFFFFFE00000\n            (umax_mask XmmMem (emit_u128_le_const 0x41EFFFFFFFE00000_41EFFFFFFFE00000))\n\n            ;; MINPD xmm_y, [wasm_f64x2_splat(4294967295.0)]\n            (dst Xmm (x64_minpd dst umax_mask))\n\n            ;; ROUNDPD xmm_y, xmm_y, 0x0B\n            (dst Xmm (x64_round $F64X2 dst (RoundImm.RoundZero)))\n\n            ;; ADDPD xmm_y, [wasm_f64x2_splat(0x1.0p+52)]\n            (uint_mask XmmMem (emit_u128_le_const 0x4330000000000000_4330000000000000))\n\n            (dst Xmm (x64_addpd dst uint_mask)))\n\n        ;; SHUFPS xmm_y, xmm_xmp, 0x88\n        (x64_shufps dst zeros 0x88)))\n\n;; Rules for `nop` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(rule (lower (nop))\n      (invalid_reg))\n", "test interpret\ntest run\ntarget aarch64\ntarget s390x\ntarget x86_64\ntarget x86_64 ssse3\ntarget x86_64 sse41\ntarget x86_64 sse42\ntarget x86_64 sse42 has_avx\ntarget x86_64 sse42 has_avx has_avx2\ntarget x86_64 sse42 has_avx has_avx2 has_avx512f has_avx512vl\ntarget riscv64 has_v\ntarget riscv64 has_v has_c has_zcb\n\n\nfunction %sshr_i8x16(i8x16, i32) -> i8x16 {\nblock0(v0: i8x16, v1: i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 1) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]\n; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 9) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]\n\nfunction %sshr_i16x8(i16x8, i32) -> i16x8 {\nblock0(v0: i16x8, v1: i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; note: because of the shifted-in sign-bit, lane 0 remains -1 == 0xffff, whereas lane 4 has been shifted to -8 == 0xfff8\n; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 1) == [-1 1 2 4 -8 16 32 64]\n; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 17) == [-1 1 2 4 -8 16 32 64]\n\nfunction %sshr_i32x4(i32x4, i32) -> i32x4 {\nblock0(v0: i32x4, v1: i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %sshr_i32x4([1 2 4 -8], 1) == [0 1 2 -4]\n; run: %sshr_i32x4([1 2 4 -8], 33) == [0 1 2 -4]\n\nfunction %sshr_i64x2(i64x2, i32) -> i64x2 {\nblock0(v0:i64x2, v1:i32):\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %sshr_i64x2([1 -1], 0) == [1 -1]\n; run: %sshr_i64x2([1 -1], 1) == [0 -1] ; note the -1 shift result\n; run: %sshr_i64x2([2 -2], 1) == [1 -1]\n; run: %sshr_i64x2([0x80000000_00000000 0x7FFFFFFF_FFFFFFFF], 63) == [0xFFFFFFFF_FFFFFFFF 0]\n; run: %sshr_i64x2([2 -2], 65) == [1 -1]\n\n\n\nfunction %sshr_imm_i32x4(i32x4) -> i32x4 {\nblock0(v0: i32x4):\n    v1 = sshr_imm v0, 1\n    return v1\n}\n; run: %sshr_imm_i32x4([1 2 4 -8]) == [0 1 2 -4]\n\nfunction %sshr_imm_i16x8(i16x8) -> i16x8 {\nblock0(v0: i16x8):\n    v1 = sshr_imm v0, 1\n    return v1\n}\n; run: %sshr_imm_i16x8([1 2 4 -8 0 0 0 0]) == [0 1 2 -4 0 0 0 0]\n\n\nfunction %i8x16_sshr_const(i8x16) -> i8x16 {\nblock0(v0: i8x16):\n    v1 = iconst.i32 2\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i8x16_sshr_const([0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80 0 0 0 0 0 0 0 0]) == [0 0 0x01 0x02 0x04 0x08 0x10 0xe0 0 0 0 0 0 0 0 0]\n\nfunction %i16x8_sshr_const(i16x8) -> i16x8 {\nblock0(v0: i16x8):\n    v1 = iconst.i32 4\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i16x8_sshr_const([0x0001 0x0002 0x0004 0x0008 0x0010 0x0020 0x0040 0x0080]) == [0 0 0 0 0x1 0x2 0x4 0x8]\n; run: %i16x8_sshr_const([-1 -2 -4 -8 -16 16 0x8000 0x80f3]) == [-1 -1 -1 -1 -1 1 0xf800 0xf80f]\n\nfunction %i32x4_sshr_const(i32x4) -> i32x4 {\nblock0(v0: i32x4):\n    v1 = iconst.i32 4\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i32x4_sshr_const([1 0xfc 0x80000000 0xf83f3000]) == [0 0xf 0xf8000000 0xff83f300]\n\nfunction %i64x2_sshr_const(i64x2) -> i64x2 {\nblock0(v0: i64x2):\n    v1 = iconst.i32 32\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i64x2_sshr_const([0x1 0xf]) == [0 0]\n; run: %i64x2_sshr_const([0x100000000 0]) == [1 0]\n; run: %i64x2_sshr_const([-1 -1]) == [-1 -1]\n\nfunction %i64x2_sshr_const2(i64x2) -> i64x2 {\nblock0(v0: i64x2):\n    v1 = iconst.i32 8\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i64x2_sshr_const2([0x1 0xf]) == [0 0]\n; run: %i64x2_sshr_const2([0x100000000 0]) == [0x1000000 0]\n; run: %i64x2_sshr_const2([-1 -1]) == [-1 -1]\n\nfunction %i64x2_sshr_const3(i64x2) -> i64x2 {\nblock0(v0: i64x2):\n    v1 = iconst.i32 40\n    v2 = sshr v0, v1\n    return v2\n}\n; run: %i64x2_sshr_const3([0x1 0xf]) == [0 0]\n; run: %i64x2_sshr_const3([0x10000000000 0]) == [1 0]\n; run: %i64x2_sshr_const3([-1 -1]) == [-1 -1]\n; run: %i64x2_sshr_const3([0x8000000080000000 0x8000000080000000]) == [0xffffffffff800000 0xffffffffff800000]\n; run: %i64x2_sshr_const3([0x2424242424244424 0x8b1b1b1bffffff24]) == [0x242424 0xffffffffff8b1b1b]\n; run: %i64x2_sshr_const3([0x2424242424244424 0x1b1b1b1bffffff24]) == [0x242424 0x1b1b1b]\n\n"], "filenames": ["RELEASES.md", "cranelift/codegen/src/isa/x64/lower.isle", "cranelift/filetests/filetests/runtests/simd-sshr.clif"], "buggy_code_start_loc": [139, 863, 123], "buggy_code_end_loc": [270, 864, 123], "fixing_code_start_loc": [140, 863, 124], "fixing_code_end_loc": [322, 864, 126], "type": "CWE-193", "message": "Wasmtime is a standalone runtime for WebAssembly. Wasmtime versions from 10.0.0 to versions 10.02, 11.0.2, and 12.0.1 contain a miscompilation of the WebAssembly `i64x2.shr_s` instruction on x86_64 platforms when the shift amount is a constant value that is larger than 32. Only x86_64 is affected so all other targets are not affected by this. The miscompilation results in the instruction producing an incorrect result, namely the low 32-bits of the second lane of the vector are derived from the low 32-bits of the second lane of the input vector instead of the high 32-bits. The primary impact of this issue is that any WebAssembly program using the `i64x2.shr_s` with a constant shift amount larger than 32 may produce an incorrect result.\n\nThis issue is not an escape from the WebAssembly sandbox. Execution of WebAssembly guest programs will still behave correctly with respect to memory sandboxing and isolation from the host. Wasmtime considers non-spec-compliant behavior as a security issue nonetheless.\n\nThis issue was discovered through fuzzing of Wasmtime's code generator Cranelift.\n\nWasmtime versions 10.0.2, 11.0.2, and 12.0.2 are all patched to no longer have this miscompilation. This issue only affects x86_64 hosts and the only workaround is to either scan for this pattern in wasm modules which is nontrivial or to disable the SIMD proposal for WebAssembly. Users prior to 10.0.0 are unaffected by this vulnerability.", "other": {"cve": {"id": "CVE-2023-41880", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-15T20:15:11.017", "lastModified": "2023-09-21T16:17:54.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wasmtime is a standalone runtime for WebAssembly. Wasmtime versions from 10.0.0 to versions 10.02, 11.0.2, and 12.0.1 contain a miscompilation of the WebAssembly `i64x2.shr_s` instruction on x86_64 platforms when the shift amount is a constant value that is larger than 32. Only x86_64 is affected so all other targets are not affected by this. The miscompilation results in the instruction producing an incorrect result, namely the low 32-bits of the second lane of the vector are derived from the low 32-bits of the second lane of the input vector instead of the high 32-bits. The primary impact of this issue is that any WebAssembly program using the `i64x2.shr_s` with a constant shift amount larger than 32 may produce an incorrect result.\n\nThis issue is not an escape from the WebAssembly sandbox. Execution of WebAssembly guest programs will still behave correctly with respect to memory sandboxing and isolation from the host. Wasmtime considers non-spec-compliant behavior as a security issue nonetheless.\n\nThis issue was discovered through fuzzing of Wasmtime's code generator Cranelift.\n\nWasmtime versions 10.0.2, 11.0.2, and 12.0.2 are all patched to no longer have this miscompilation. This issue only affects x86_64 hosts and the only workaround is to either scan for this pattern in wasm modules which is nontrivial or to disable the SIMD proposal for WebAssembly. Users prior to 10.0.0 are unaffected by this vulnerability."}, {"lang": "es", "value": "Wasmtime es un standalone en tiempo de ejecuci\u00f3n para WebAssembly. Las versiones de Wasmtime desde 10.0.0 hasta las versiones 10.02, 11.0.2 y 12.0.1 contienen una mala compilaci\u00f3n de la instrucci\u00f3n WebAssembly `i64x2.shr_s` en plataformas x86_64 cuando la cantidad de desplazamiento es un valor constante mayor que 32. Solo x86_64 es afectado por lo que todos los dem\u00e1s objetivos no se ven afectados por esto. La mala compilaci\u00f3n da como resultado que la instrucci\u00f3n produzca un resultado incorrecto, es decir, los 32 bits bajos del segundo carril del vector se derivan de los 32 bits bajos del segundo carril del vector de entrada en lugar de los 32 bits altos. El impacto principal de este problema es que cualquier programa WebAssembly que utilice `i64x2.shr_s` con una cantidad de desplazamiento constante mayor que 32 puede producir un resultado incorrecto. Este problema no es un escape del entorno limitado de WebAssembly. La ejecuci\u00f3n de los programas invitados de WebAssembly seguir\u00e1 comport\u00e1ndose correctamente con respecto al espacio aislado de la memoria y el aislamiento del host. No obstante, Wasmtime considera el comportamiento que no cumple con las especificaciones como un problema de seguridad. Este problema se descubri\u00f3 mediante la confusi\u00f3n del generador de c\u00f3digo Cranelift de Wasmtime. Las versiones 10.0.2, 11.0.2 y 12.0.2 de Wasmtime est\u00e1n parcheadas para que ya no tengan esta mala compilaci\u00f3n. Este problema solo afecta a los hosts x86_64 y el \u00fanico workaround es buscar este patr\u00f3n en los m\u00f3dulos wasm, lo cual no es trivial, o deshabilitar la propuesta SIMD para WebAssembly. Los usuarios anteriores a 10.0.0 no se ven afectados por esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:x64:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.0.2", "matchCriteriaId": "86124D0A-F8ED-4D8C-8DA4-1D1376EAF38A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:x64:*", "versionStartIncluding": "11.0.0", "versionEndExcluding": "11.0.2", "matchCriteriaId": "9F0CA660-E2F9-4455-ABF5-41A8B8B67212"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:x64:*", "versionStartIncluding": "12.0.0", "versionEndExcluding": "12.0.2", "matchCriteriaId": "EE886793-5F3B-492D-817D-79577FE7A8A5"}]}]}], "references": [{"url": "https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/bytecodealliance/wasmtime/commit/8d7eda15b0badcbea83a7aac2d08f80788b59240", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/bytecodealliance/wasmtime/pull/6372", "source": "security-advisories@github.com", "tags": ["Patch", "Product"]}, {"url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gw5p-q8mj-p7gh", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gw5p-q8mj-p7gh#:~:text=Mailing%20list%20announcement", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/bytecodealliance/wasmtime/commit/8d7eda15b0badcbea83a7aac2d08f80788b59240"}}