{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"thrift/lib/cpp2/protocol/TableBasedSerializer.h\"\n\n#include \"folly/CppAttributes.h\"\n#include \"glog/logging.h\"\n#include \"thrift/lib/cpp2/protocol/BinaryProtocol.h\"\n#include \"thrift/lib/cpp2/protocol/CompactProtocol.h\"\n#include \"thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h\"\n#include \"thrift/lib/cpp2/protocol/ProtocolReaderWireTypeInfo.h\"\n#include \"thrift/lib/cpp2/protocol/SimpleJSONProtocol.h\"\n\nnamespace apache {\nnamespace thrift {\nnamespace detail {\n\n#define THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(                          \\\n    TypeClass, Type, ThriftType, TTypeValue)                           \\\n  const TypeInfo TypeToInfo<type_class::TypeClass, Type>::typeInfo = { \\\n      protocol::TType::TTypeValue,                                     \\\n      reinterpret_cast<VoidFuncPtr>(identity(set<Type, ThriftType>)),  \\\n      reinterpret_cast<VoidFuncPtr>(identity(get<ThriftType, Type>)),  \\\n      nullptr,                                                         \\\n  }\n\n// Specialization for numbers.\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int8_t,\n    std::int8_t,\n    T_BYTE);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int16_t,\n    std::int16_t,\n    T_I16);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int32_t,\n    std::int32_t,\n    T_I32);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int64_t,\n    std::int64_t,\n    T_I64);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint8_t,\n    std::int8_t,\n    T_BYTE);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint16_t,\n    std::int16_t,\n    T_I16);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint32_t,\n    std::int32_t,\n    T_I32);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint64_t,\n    std::int64_t,\n    T_I64);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(integral, bool, bool, T_BOOL);\n\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, float, float, T_FLOAT);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, double, double, T_DOUBLE);\n\n// Specialization for string.\n#define THRIFT_DEFINE_STRING_TYPE_TO_INFO(TypeClass, ActualType, ExtVal)     \\\n  const StringFieldType TypeToInfo<type_class::TypeClass, ActualType>::ext = \\\n      ExtVal;                                                                \\\n  const TypeInfo TypeToInfo<type_class::TypeClass, ActualType>::typeInfo = { \\\n      /* .type */ protocol::TType::T_STRING,                                 \\\n      /* .set */ nullptr,                                                    \\\n      /* .get */ nullptr,                                                    \\\n      /* .typeExt */ &ext,                                                   \\\n  }\n\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(string, std::string, StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(\n    string,\n    folly::fbstring,\n    StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, std::string, StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(\n    binary,\n    folly::fbstring,\n    StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, folly::IOBuf, StringFieldType::IOBuf);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(\n    binary,\n    std::unique_ptr<folly::IOBuf>,\n    StringFieldType::IOBufPtr);\n\nnamespace {\nconstexpr TypeInfo kStopType = {\n    protocol::TType::T_STOP,\n    nullptr,\n    nullptr,\n    nullptr};\nconstexpr FieldInfo kStopMarker = {0, false, nullptr, 0, 0, &kStopType};\n\ntemplate <class Protocol_>\nvoid skip(\n    Protocol_* iprot,\n    ProtocolReaderStructReadState<Protocol_>& readState) {\n  readState.skip(iprot);\n  readState.readFieldEnd(iprot);\n  readState.readFieldBeginNoInline(iprot);\n}\n\nconst void* getMember(const FieldInfo& fieldInfo, const void* object) {\n  return static_cast<const char*>(object) + fieldInfo.memberOffset;\n}\n\nvoid* getMember(const FieldInfo& fieldInfo, void* object) {\n  return static_cast<char*>(object) + fieldInfo.memberOffset;\n}\n\nconst OptionalThriftValue getValue(\n    const TypeInfo& typeInfo,\n    const void* object) {\n  if (typeInfo.get) {\n    // Handle smart pointer and numerical types.\n    return reinterpret_cast<OptionalThriftValue (*)(const void*)>(typeInfo.get)(\n        object);\n  }\n  // Handle others.\n  if (object) {\n    return folly::make_optional<ThriftValue>(object);\n  }\n  return folly::none;\n}\n\nFOLLY_ERASE void* invokeSet(VoidFuncPtr set, void* object) {\n  return reinterpret_cast<void* (*)(void*)>(set)(object);\n}\n\ntemplate <class Protocol_>\nconst FieldInfo* FOLLY_NULLABLE findFieldInfo(\n    Protocol_* iprot,\n    ProtocolReaderStructReadState<Protocol_>& readState,\n    const StructInfo& structInfo) {\n  auto* end = structInfo.fieldInfos + structInfo.numFields;\n  if (iprot->kUsesFieldNames()) {\n    const FieldInfo* found =\n        std::find_if(structInfo.fieldInfos, end, [&](const FieldInfo& val) {\n          return val.name == readState.fieldName();\n        });\n    if (found != end) {\n      readState.fieldId = found->id;\n      readState.fieldType = found->typeInfo->type;\n      if (readState.isCompatibleWithType(iprot, found->typeInfo->type)) {\n        return found;\n      }\n    }\n  } else {\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        readState.fieldId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found != end && found->id == readState.fieldId &&\n        readState.isCompatibleWithType(iprot, found->typeInfo->type)) {\n      return found;\n    }\n  }\n  return nullptr;\n}\n\nconst FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const FieldID*>(\n      offset + static_cast<const char*>(object));\n}\n\nconst bool& fieldIsSet(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const bool*>(\n      offset + static_cast<const char*>(object));\n}\n\ntemplate <class Protocol_>\nvoid read(\n    Protocol_* iprot,\n    const TypeInfo& typeInfo,\n    ProtocolReaderStructReadState<Protocol_>& readState,\n    void* object) {\n  using WireTypeInfo = ProtocolReaderWireTypeInfo<Protocol_>;\n  using WireType = typename WireTypeInfo::WireType;\n  switch (typeInfo.type) {\n    case protocol::TType::T_STRUCT:\n      readState.beforeSubobject(iprot);\n      read<Protocol_>(\n          iprot,\n          *static_cast<const StructInfo*>(typeInfo.typeExt),\n          typeInfo.set ? invokeSet(typeInfo.set, object) : object);\n      readState.afterSubobject(iprot);\n      break;\n    case protocol::TType::T_I64: {\n      std::int64_t temp;\n      iprot->readI64(temp);\n      reinterpret_cast<void (*)(void*, std::int64_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_I32: {\n      std::int32_t temp;\n      iprot->readI32(temp);\n      reinterpret_cast<void (*)(void*, std::int32_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_I16: {\n      std::int16_t temp;\n      iprot->readI16(temp);\n      reinterpret_cast<void (*)(void*, std::int16_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_BYTE: {\n      std::int8_t temp;\n      iprot->readByte(temp);\n      reinterpret_cast<void (*)(void*, std::int8_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_BOOL: {\n      bool temp;\n      iprot->readBool(temp);\n      reinterpret_cast<void (*)(void*, bool)>(typeInfo.set)(object, temp);\n      break;\n    }\n    case protocol::TType::T_DOUBLE: {\n      double temp;\n      iprot->readDouble(temp);\n      reinterpret_cast<void (*)(void*, double)>(typeInfo.set)(object, temp);\n      break;\n    }\n    case protocol::TType::T_FLOAT: {\n      float temp;\n      iprot->readFloat(temp);\n      reinterpret_cast<void (*)(void*, float)>(typeInfo.set)(object, temp);\n      break;\n    }\n    case protocol::TType::T_STRING: {\n      switch (*static_cast<const StringFieldType*>(typeInfo.typeExt)) {\n        case StringFieldType::String:\n          iprot->readString(*static_cast<std::string*>(object));\n          break;\n        case StringFieldType::IOBuf:\n          iprot->readBinary(*static_cast<folly::IOBuf*>(object));\n          break;\n        case StringFieldType::IOBufPtr:\n          iprot->readBinary(\n              *static_cast<std::unique_ptr<folly::IOBuf>*>(object));\n          break;\n      }\n      break;\n    }\n    case protocol::TType::T_MAP: {\n      readState.beforeSubobject(iprot);\n      // Initialize the container to clear out current values.\n      auto* actualObject = invokeSet(typeInfo.set, object);\n      const MapFieldExt& ext =\n          *static_cast<const MapFieldExt*>(typeInfo.typeExt);\n      std::uint32_t size = ~0;\n      WireType reportedKeyType = WireTypeInfo::defaultValue();\n      WireType reportedMappedType = WireTypeInfo::defaultValue();\n      iprot->readMapBegin(reportedKeyType, reportedMappedType, size);\n      struct Context {\n        const TypeInfo* keyInfo;\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n        ProtocolReaderStructReadState<Protocol_>& readState;\n      };\n      const Context context = {\n          ext.keyInfo,\n          ext.valInfo,\n          iprot,\n          readState,\n      };\n      auto const keyReader = [](const void* context, void* key) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.keyInfo,\n            typedContext.readState,\n            key);\n      };\n      auto const valueReader = [](const void* context, void* val) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.valInfo,\n            typedContext.readState,\n            val);\n      };\n      if (iprot->kOmitsContainerSizes()) {\n        while (iprot->peekMap()) {\n          ext.consumeElem(&context, actualObject, keyReader, valueReader);\n        }\n      } else {\n        if (size > 0 &&\n            (ext.keyInfo->type != reportedKeyType ||\n             ext.valInfo->type != reportedMappedType)) {\n          skip_n(*iprot, size, {reportedKeyType, reportedMappedType});\n        } else {\n          if (!canReadNElements(\n                  *iprot, size, {reportedKeyType, reportedMappedType})) {\n            protocol::TProtocolException::throwTruncatedData();\n          }\n          ext.readMap(&context, actualObject, size, keyReader, valueReader);\n        }\n      }\n      iprot->readMapEnd();\n      readState.afterSubobject(iprot);\n      break;\n    }\n    case protocol::TType::T_SET: {\n      readState.beforeSubobject(iprot);\n      // Initialize the container to clear out current values.\n      auto* actualObject = invokeSet(typeInfo.set, object);\n      const SetFieldExt& ext =\n          *static_cast<const SetFieldExt*>(typeInfo.typeExt);\n      std::uint32_t size = ~0;\n      WireType reportedType = WireTypeInfo::defaultValue();\n      iprot->readSetBegin(reportedType, size);\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n        ProtocolReaderStructReadState<Protocol_>& readState;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n          readState,\n      };\n      auto const reader = [](const void* context, void* value) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.valInfo,\n            typedContext.readState,\n            value);\n      };\n      if (iprot->kOmitsContainerSizes()) {\n        while (iprot->peekSet()) {\n          ext.consumeElem(&context, actualObject, reader);\n        }\n      } else {\n        if (reportedType != ext.valInfo->type) {\n          skip_n(*iprot, size, {reportedType});\n        } else {\n          if (!canReadNElements(*iprot, size, {reportedType})) {\n            protocol::TProtocolException::throwTruncatedData();\n          }\n          ext.readSet(&context, actualObject, size, reader);\n        }\n      }\n      iprot->readSetEnd();\n      readState.afterSubobject(iprot);\n      break;\n    }\n    case protocol::TType::T_LIST: {\n      readState.beforeSubobject(iprot);\n      // Initialize the container to clear out current values.\n      auto* actualObject = invokeSet(typeInfo.set, object);\n      const ListFieldExt& ext =\n          *static_cast<const ListFieldExt*>(typeInfo.typeExt);\n      std::uint32_t size = ~0;\n      WireType reportedType = WireTypeInfo::defaultValue();\n\n      iprot->readListBegin(reportedType, size);\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n        ProtocolReaderStructReadState<Protocol_>& readState;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n          readState,\n      };\n      auto const reader = [](const void* context, void* value) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.valInfo,\n            typedContext.readState,\n            value);\n      };\n      if (iprot->kOmitsContainerSizes()) {\n        while (iprot->peekList()) {\n          ext.consumeElem(&context, actualObject, reader);\n        }\n      } else {\n        if (reportedType != ext.valInfo->type) {\n          skip_n(*iprot, size, {reportedType});\n        } else {\n          if (!canReadNElements(*iprot, size, {reportedType})) {\n            protocol::TProtocolException::throwTruncatedData();\n          }\n          ext.readList(&context, actualObject, size, reader);\n        }\n      }\n      iprot->readListEnd();\n      readState.afterSubobject(iprot);\n      break;\n    }\n    case protocol::TType::T_STOP:\n    case protocol::TType::T_VOID:\n    case protocol::TType::T_UTF8:\n    case protocol::TType::T_U64:\n    case protocol::TType::T_UTF16:\n    case protocol::TType::T_STREAM:\n      skip(iprot, readState);\n  }\n}\n\ntemplate <class Protocol_>\nsize_t write(Protocol_* iprot, const TypeInfo& typeInfo, ThriftValue value) {\n  switch (typeInfo.type) {\n    case protocol::TType::T_STRUCT:\n      return write(\n          iprot,\n          *static_cast<const StructInfo*>(typeInfo.typeExt),\n          value.object);\n    case protocol::TType::T_I64:\n      return iprot->writeI64(value.int64Value);\n    case protocol::TType::T_I32:\n      return iprot->writeI32(value.int32Value);\n    case protocol::TType::T_I16:\n      return iprot->writeI16(value.int16Value);\n    case protocol::TType::T_BYTE:\n      return iprot->writeByte(value.int8Value);\n    case protocol::TType::T_BOOL:\n      return iprot->writeBool(value.boolValue);\n    case protocol::TType::T_DOUBLE:\n      return iprot->writeDouble(value.doubleValue);\n    case protocol::TType::T_FLOAT:\n      return iprot->writeFloat(value.floatValue);\n    case protocol::TType::T_STRING: {\n      switch (*static_cast<const StringFieldType*>(typeInfo.typeExt)) {\n        case StringFieldType::String:\n          return iprot->writeString(\n              *static_cast<const std::string*>(value.object));\n        case StringFieldType::IOBuf:\n          return iprot->writeBinary(\n              *static_cast<const folly::IOBuf*>(value.object));\n        case StringFieldType::IOBufPtr:\n          return iprot->writeBinary(\n              *static_cast<const std::unique_ptr<folly::IOBuf>*>(value.object));\n      };\n    }\n      // For container types, when recursively writing with lambdas we\n      // intentionally skip checking OptionalThriftValue.hasValue and treat it\n      // as a user error if the value is a nullptr.\n    case protocol::TType::T_MAP: {\n      const auto& ext = *static_cast<const MapFieldExt*>(typeInfo.typeExt);\n      size_t written = iprot->writeMapBegin(\n          ext.keyInfo->type, ext.valInfo->type, ext.size(value.object));\n\n      struct Context {\n        const TypeInfo* keyInfo;\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n      };\n      const Context context = {\n          ext.keyInfo,\n          ext.valInfo,\n          iprot,\n      };\n      written += ext.writeMap(\n          &context,\n          value.object,\n          iprot->kSortKeys(),\n          [](const void* context, const void* key, const void* val) {\n            const auto& typedContext = *static_cast<const Context*>(context);\n            const TypeInfo& keyInfo = *typedContext.keyInfo;\n            const TypeInfo& valInfo = *typedContext.valInfo;\n            return write(typedContext.iprot, keyInfo, *getValue(keyInfo, key)) +\n                write(typedContext.iprot,\n                      *typedContext.valInfo,\n                      *getValue(valInfo, val));\n          });\n      written += iprot->writeMapEnd();\n      return written;\n    }\n    case protocol::TType::T_SET: {\n      const auto& ext = *static_cast<const SetFieldExt*>(typeInfo.typeExt);\n      size_t written =\n          iprot->writeSetBegin(ext.valInfo->type, ext.size(value.object));\n\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n      };\n      written += ext.writeSet(\n          &context,\n          value.object,\n          iprot->kSortKeys(),\n          [](const void* context, const void* value) {\n            const auto& typedContext = *static_cast<const Context*>(context);\n            const TypeInfo& valInfo = *typedContext.valInfo;\n            return write(\n                typedContext.iprot, valInfo, *getValue(valInfo, value));\n          });\n      written += iprot->writeSetEnd();\n      return written;\n    }\n    case protocol::TType::T_LIST: {\n      const auto& ext = *static_cast<const ListFieldExt*>(typeInfo.typeExt);\n      size_t written =\n          iprot->writeListBegin(ext.valInfo->type, ext.size(value.object));\n\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n      };\n      written += ext.writeList(\n          &context, value.object, [](const void* context, const void* value) {\n            const auto& typedContext = *static_cast<const Context*>(context);\n            const TypeInfo& valInfo = *typedContext.valInfo;\n            return write(\n                typedContext.iprot, valInfo, *getValue(valInfo, value));\n          });\n      written += iprot->writeListEnd();\n      return written;\n    }\n    case protocol::TType::T_STOP:\n    case protocol::TType::T_VOID:\n    case protocol::TType::T_STREAM:\n    case protocol::TType::T_UTF8:\n    case protocol::TType::T_U64:\n    case protocol::TType::T_UTF16:\n      DCHECK(false);\n      break;\n  }\n  return 0;\n}\n\ntemplate <class Protocol_>\nsize_t writeField(\n    Protocol_* iprot,\n    const FieldInfo& fieldInfo,\n    const ThriftValue& value) {\n  size_t written = iprot->writeFieldBegin(\n      fieldInfo.name, fieldInfo.typeInfo->type, fieldInfo.id);\n  written += write(iprot, *fieldInfo.typeInfo, value);\n  written += iprot->writeFieldEnd();\n  return written;\n}\n} // namespace\n\ntemplate <class Protocol_>\nvoid read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    // Found it.\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      // Default construct and placement new into the member union.\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n\n  // Define out of loop to call advanceToNextField after the loop ends.\n  FieldID prevFieldId = 0;\n\n  // The index of the expected field in the struct layout.\n  std::int16_t index = 0;\n\n  // Every time advanceToNextField reports a field mismatch, either because the\n  // field is missing or if the serialized fields are not sorted (protocols\n  // don't guarantee a specific field order), we search for the field info\n  // matching the read bytes. Then we resume from the one past the found field\n  // to reduce the number of scans we have to do if the fields are sorted which\n  // is a common case. When we increment index past the number of fields we\n  // utilize the same search logic with a field info of type TType::T_STOP.\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    // Try to match the next field in order against the current bytes.\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      // Loop to skip until we find a match for both field id/name and type.\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          // Already at stop, return immediately.\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        // Found it.\n        if (fieldInfo) {\n          // Set the index to the field next in order to the found field.\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      // We are at stop and have tried all of the fields, so return.\n      readState.readStructEnd(iprot);\n      return;\n    }\n    // Id and type are what we expect, try read.\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}\n\ntemplate <class Protocol_>\nsize_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}\n\ntemplate void read<CompactProtocolReader>(\n    CompactProtocolReader* iprot,\n    const StructInfo& structInfo,\n    void* object);\ntemplate size_t write<CompactProtocolWriter>(\n    CompactProtocolWriter* iprot,\n    const StructInfo& structInfo,\n    const void* object);\ntemplate void read<BinaryProtocolReader>(\n    BinaryProtocolReader* iprot,\n    const StructInfo& structInfo,\n    void* object);\ntemplate size_t write<BinaryProtocolWriter>(\n    BinaryProtocolWriter* iprot,\n    const StructInfo& structInfo,\n    const void* object);\ntemplate void read<SimpleJSONProtocolReader>(\n    SimpleJSONProtocolReader* iprot,\n    const StructInfo& structInfo,\n    void* object);\ntemplate size_t write<SimpleJSONProtocolWriter>(\n    SimpleJSONProtocolWriter* iprot,\n    const StructInfo& structInfo,\n    const void* object);\n} // namespace detail\n} // namespace thrift\n} // namespace apache\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <thrift/lib/cpp2/protocol/Serializer.h>\n\n#include <folly/io/IOBuf.h>\n#include <folly/json.h>\n#include <folly/portability/GTest.h>\n#include <folly/test/JsonTestUtil.h>\n#include <thrift/test/tablebased/gen-cpp2/frozen_tablebased_types.h>\n#include <thrift/test/tablebased/gen-cpp2/frozen_types.h>\n#include <thrift/test/tablebased/gen-cpp2/thrift_tablebased_types.h>\n#include <thrift/test/tablebased/gen-cpp2/thrift_types.h>\n\nusing apache::thrift::BinarySerializer;\nusing apache::thrift::CompactSerializer;\nusing apache::thrift::SimpleJSONSerializer;\nusing namespace facebook::thrift::test;\nnamespace tablebased = facebook::thrift::test::tablebased;\n\nnamespace {\n// This will actually fail if fields with larger ids are listed first in the\n// thrift struct because old serialization code will serialize by IDL order,\n// while new serialization code will serialize by field id order. The resulting\n// difference in order will consequently change the bytes serialized.\n#define EXPECT_SERIALIZED_DATA_EQ(Serializer, expected, result) \\\n  do {                                                          \\\n    if (std::is_same_v<Serializer, SimpleJSONSerializer>) {     \\\n      FOLLY_EXPECT_JSON_EQ(expected, result);                   \\\n    } else {                                                    \\\n      EXPECT_EQ(expected, result);                              \\\n    }                                                           \\\n  } while (false)\n\nconstexpr const char* UNQUALIFIED = \"unqualified\";\n\n// Tests that table based serialization matches the output of original\n// serialization. Tests that table based deserialization works with original\n// serialized bytes.\n#define EXPECT_COMPATIBLE_PROTOCOL_IMPL(                                     \\\n    object, tableBasedObject, Serializer, shouldSkipEqualityForUnionWithRef) \\\n  do {                                                                       \\\n    std::string originalBytes =                                              \\\n        Serializer::template serialize<std::string>(object);                 \\\n    auto tableBasedObjectFromOriginalBytes =                                 \\\n        Serializer::template deserialize<decltype(tableBasedObject)>(        \\\n            originalBytes);                                                  \\\n    std::string tableBasedBytes =                                            \\\n        Serializer::template serialize<std::string>(tableBasedObject);       \\\n    if (!shouldSkipEqualityForUnionWithRef) {                                \\\n      EXPECT_EQ(tableBasedObject, tableBasedObjectFromOriginalBytes);        \\\n    }                                                                        \\\n    EXPECT_SERIALIZED_DATA_EQ(Serializer, originalBytes, tableBasedBytes);   \\\n  } while (false)\n\n#define EXPECT_COMPATIBLE_PROTOCOL(object, tableBasedObject, Serializer) \\\n  EXPECT_COMPATIBLE_PROTOCOL_IMPL(object, tableBasedObject, Serializer, false)\n\n#define EXPECT_COMPATIBLE_PROTOCOL_UNION_REF( \\\n    object, tableBasedObject, Serializer)     \\\n  EXPECT_COMPATIBLE_PROTOCOL_IMPL(object, tableBasedObject, Serializer, true)\n\ntemplate <typename Type>\nType makeStructWithIncludeLike() {\n  Type object;\n  object.fieldA_ref().emplace();\n  return object;\n}\n\ntemplate <typename Type>\nType makeFrozenStructBLike() {\n  Type structBLike;\n  structBLike.fieldA_ref() = 2000;\n  return structBLike;\n}\n\ntemplate <typename Type>\nType makeFrozenStructALike() {\n  Type structALike;\n  structALike.fieldA_ref() = 2000;\n  return structALike;\n}\n\ntemplate <typename Type>\nType makeStructBLike() {\n  Type otherStructLike;\n  otherStructLike.fieldB_ref() = 2000;\n\n  otherStructLike.fieldC_ref() = folly::IOBuf::copyBuffer(\"testBuffer\");\n\n  otherStructLike.fieldD_ref() = std::make_shared<std::vector<int64_t>>();\n  otherStructLike.fieldD_ref()->emplace_back(9000);\n  otherStructLike.fieldD_ref()->emplace_back(8000);\n  otherStructLike.fieldE_ref() = 1000;\n  otherStructLike.fieldF_ref() = 20;\n  otherStructLike.fieldG_ref() = 16;\n  otherStructLike.fieldH_ref() = true;\n  otherStructLike.fieldI_ref() = std::set{1, 2, 3};\n  otherStructLike.fieldJ_ref() = \"testBuffer\";\n  otherStructLike.fieldK_ref() = 1.0;\n  otherStructLike.fieldL_ref() = 2.0;\n  return otherStructLike;\n}\n\ntemplate <typename Type>\nType makeStructALike() {\n  Type structALike;\n  structALike.fieldD_ref() = {\"first\", \"second\"};\n  structALike.fieldE_ref() = {{\"first\", 1}, {\"second\", 2}};\n  structALike.fieldA_ref() = \"yo\";\n  structALike.fieldB_ref() = 123;\n  structALike.fieldF_ref() = UNQUALIFIED;\n  structALike.fieldC_ref().emplace();\n  structALike.fieldC_ref() = makeStructBLike<\n      std::remove_reference_t<decltype(*structALike.fieldC_ref())>>();\n  using EnumType = std::remove_reference_t<decltype(*structALike.fieldG_ref())>;\n  structALike.fieldG_ref() = EnumType::A;\n  return structALike;\n}\n\ntemplate <typename Type>\nType makeStructWithRefLike() {\n  Type object;\n  object.fieldA_ref() = std::make_shared<std::add_const_t<\n      std::remove_reference_t<decltype(*object.fieldA_ref())>>>(\n      makeStructBLike<typename std::remove_const<\n          std::remove_reference_t<decltype(*object.fieldA_ref())>>::type>());\n  std::vector<std::string> tmp = {\"test1\", \"test2\"};\n  object.fieldB_ref() =\n      std::make_shared<const std::vector<std::string>>(std::move(tmp));\n  object.fieldC_ref() = std::make_shared<const std::int16_t>(1000);\n  object.fieldD_ref() = std::make_unique<std::int32_t>(5000);\n  return object;\n}\n} // namespace\n\nusing Protocols =\n    ::testing::Types<CompactSerializer, SimpleJSONSerializer, BinarySerializer>;\n\ntemplate <typename Serializer>\nclass MultiProtocolTest : public ::testing::Test {};\nTYPED_TEST_CASE(MultiProtocolTest, Protocols);\n\nTYPED_TEST(MultiProtocolTest, EmptyFrozenStructA) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      FrozenStructA(), tablebased::FrozenStructA(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, FrozenStructA) {\n  FrozenStructA oldObject = makeFrozenStructALike<FrozenStructA>();\n  tablebased::FrozenStructA newObject =\n      makeFrozenStructALike<tablebased::FrozenStructA>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyFrozenStructB) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      FrozenStructB(), tablebased::FrozenStructA(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, FrozenStructB) {\n  FrozenStructB oldObject = makeFrozenStructBLike<FrozenStructB>();\n  tablebased::FrozenStructB newObject =\n      makeFrozenStructBLike<tablebased::FrozenStructB>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyStructA) {\n  EXPECT_COMPATIBLE_PROTOCOL(StructA(), tablebased::StructA(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, StructA) {\n  StructA oldObject = makeStructALike<StructA>();\n  tablebased::StructA newObject = makeStructALike<tablebased::StructA>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyStructWithRef) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      StructWithRef(), tablebased::StructWithRef(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, StructWithRef) {\n  auto oldObject = makeStructWithRefLike<StructWithRef>();\n  auto newObject = makeStructWithRefLike<tablebased::StructWithRef>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyStructWithInclude) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      StructWithInclude(), tablebased::StructWithInclude(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, StructWithInclude) {\n  auto oldObject = makeStructWithIncludeLike<StructWithInclude>();\n  auto newObject = makeStructWithIncludeLike<tablebased::StructWithInclude>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyUnion) {\n  EXPECT_COMPATIBLE_PROTOCOL(Union(), tablebased::Union(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, Union) {\n  {\n    StructA oldUnionVal = makeStructALike<StructA>();\n    Union oldObject;\n    oldObject.fieldA_ref() = oldUnionVal;\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    tablebased::Union newObject;\n    newObject.fieldA_ref() = newUnionVal;\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    StructB oldUnionVal = makeStructBLike<StructB>();\n    Union oldObject;\n    oldObject.fieldB_ref() = oldUnionVal;\n    tablebased::StructB newUnionVal = makeStructBLike<tablebased::StructB>();\n    tablebased::Union newObject;\n    newObject.fieldB_ref() = newUnionVal;\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    Union oldObject;\n    oldObject.fieldC_ref() = \"test\";\n    tablebased::Union newObject;\n    newObject.fieldC_ref() = \"test\";\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyUnionWithRef) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      UnionWithRef(), tablebased::UnionWithRef(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, UnionWithRef) {\n  {\n    UnionWithRef oldObject;\n    oldObject.set_fieldA();\n    {\n      auto& ptr = oldObject.get_fieldA();\n      const_cast<std::unique_ptr<StructA>&>(ptr) =\n          std::unique_ptr<StructA>(nullptr);\n    }\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldA();\n    {\n      auto& ptr = newObject.get_fieldA();\n      const_cast<std::unique_ptr<tablebased::StructA>&>(ptr) =\n          std::unique_ptr<tablebased::StructA>(nullptr);\n    }\n    EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);\n    StructA oldUnionVal = makeStructALike<StructA>();\n    oldObject.set_fieldA(oldUnionVal);\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    newObject.set_fieldA(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    StructB oldUnionVal = makeStructBLike<StructB>();\n    UnionWithRef oldObject;\n    oldObject.set_fieldB(oldUnionVal);\n    tablebased::StructB newUnionVal = makeStructBLike<tablebased::StructB>();\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldB(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    UnionWithRef oldObject;\n    oldObject.set_fieldC();\n    {\n      auto& ptr = oldObject.get_fieldC();\n      const_cast<std::shared_ptr<const StructA>&>(ptr) =\n          std::shared_ptr<const StructA>(nullptr);\n    }\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldC();\n    {\n      auto& ptr = newObject.get_fieldC();\n      const_cast<std::shared_ptr<const tablebased::StructA>&>(ptr) =\n          std::shared_ptr<const tablebased::StructA>(nullptr);\n    }\n    EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);\n    StructA oldUnionVal = makeStructALike<StructA>();\n    oldObject.set_fieldC(oldUnionVal);\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    newObject.set_fieldC(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    UnionWithRef oldObject;\n    oldObject.set_fieldD();\n    {\n      auto& ptr = oldObject.get_fieldD();\n      const_cast<std::shared_ptr<StructA>&>(ptr) =\n          std::shared_ptr<StructA>(nullptr);\n    }\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldD();\n    {\n      auto& ptr = newObject.get_fieldD();\n      const_cast<std::shared_ptr<tablebased::StructA>&>(ptr) =\n          std::shared_ptr<tablebased::StructA>(nullptr);\n    }\n    EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);\n    StructA oldUnionVal = makeStructALike<StructA>();\n    oldObject.set_fieldD(oldUnionVal);\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    newObject.set_fieldD(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n}\n\nTYPED_TEST(MultiProtocolTest, DirtyReadIntoContainer) {\n  tablebased::StructA dirty;\n  dirty.fieldD_ref() = {\"should be cleared\"};\n\n  tablebased::StructA filled = makeStructALike<tablebased::StructA>();\n  std::string serialized = TypeParam::template serialize<std::string>(filled);\n  TypeParam::deserialize(serialized, dirty);\n  EXPECT_EQ(*filled.fieldD_ref(), *dirty.fieldD_ref());\n}\n\nTYPED_TEST(MultiProtocolTest, ReadingUnqualifiedFieldShouldSetIsset) {\n  tablebased::StructA obj = makeStructALike<tablebased::StructA>();\n\n  tablebased::StructA deserialized =\n      TypeParam::template deserialize<tablebased::StructA>(\n          TypeParam::template serialize<std::string>(obj));\n  EXPECT_TRUE(deserialized.fieldF_ref().is_set());\n  EXPECT_EQ(deserialized.fieldF_ref().value(), UNQUALIFIED);\n}\n\nTEST(SerializerTest, UnionValueOffsetIsZero) {\n  tablebased::Union u;\n  u.set_fieldC(\"test\");\n  EXPECT_EQ(static_cast<void*>(&u), &*u.fieldC_ref());\n\n  u.set_fieldA({});\n  EXPECT_EQ(static_cast<void*>(&u), &*u.fieldA_ref());\n\n  u.set_fieldB({});\n  EXPECT_EQ(static_cast<void*>(&u), &*u.fieldB_ref());\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace cpp2 facebook.thrift.test.tablebased\n\ninclude \"thrift/test/tablebased/include_tablebased.thrift\"\n\ntypedef binary (cpp2.type = \"std::unique_ptr<folly::IOBuf>\") IOBufPtr\n\nenum Enum {\n  A = 1,\n  B = 2,\n}\n\nstruct StructA {\n  1: optional string fieldA;\n  2: optional i64 fieldB;\n  3: optional StructB fieldC;\n  5: optional list<string> fieldD;\n  10: optional map<string, i64> fieldE;\n  11: string fieldF;\n  12: Enum fieldG;\n}\n\nstruct StructWithRef {\n  1: optional StructB fieldA (cpp2.ref_type = \"shared_const\");\n  2: optional list<string> fieldB (cpp2.ref_type = \"shared_const\");\n  3: optional i16 fieldC (cpp2.ref_type = \"shared_const\");\n  4: optional i32 fieldD (cpp2.ref_type = \"unique\");\n}\n\nstruct StructWithCppType {\n  1: optional map<string, StructA> (\n    cpp.type = \"std::unordered_map<std::string, StructA>\",\n  ) fieldA;\n}\n\nstruct StructB {\n  1: string fieldA;\n  2: optional i64 fieldB;\n  3: optional IOBufPtr fieldC;\n  5: optional list<i64> fieldD (cpp2.ref_type = \"shared\");\n  6: i32 fieldE;\n  7: i16 fieldF;\n  8: byte fieldG;\n  9: bool fieldH;\n  10: set<i32> fieldI;\n  11: string fieldJ (cpp2.type = \"folly::IOBuf\");\n  12: double fieldK;\n  13: float fieldL;\n}\n\nstruct StructWithInclude {\n  1: optional include_tablebased.IncludedStruct fieldA;\n}\n\nunion Union {\n  1: StructA fieldA;\n  2: StructB fieldB;\n  3: string fieldC;\n}\n\nunion UnionWithRef {\n  1: StructA fieldA (cpp2.ref_type = \"unique\");\n  2: StructB fieldB;\n  3: StructA fieldC (cpp2.ref_type = \"shared_const\");\n  4: StructA fieldD (cpp2.ref_type = \"shared\");\n}\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"thrift/lib/cpp2/protocol/TableBasedSerializer.h\"\n\n#include \"folly/CppAttributes.h\"\n#include \"glog/logging.h\"\n#include \"thrift/lib/cpp2/protocol/BinaryProtocol.h\"\n#include \"thrift/lib/cpp2/protocol/CompactProtocol.h\"\n#include \"thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h\"\n#include \"thrift/lib/cpp2/protocol/ProtocolReaderWireTypeInfo.h\"\n#include \"thrift/lib/cpp2/protocol/SimpleJSONProtocol.h\"\n\nnamespace apache {\nnamespace thrift {\nnamespace detail {\n\n#define THRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(                          \\\n    TypeClass, Type, ThriftType, TTypeValue)                           \\\n  const TypeInfo TypeToInfo<type_class::TypeClass, Type>::typeInfo = { \\\n      protocol::TType::TTypeValue,                                     \\\n      reinterpret_cast<VoidFuncPtr>(identity(set<Type, ThriftType>)),  \\\n      reinterpret_cast<VoidFuncPtr>(identity(get<ThriftType, Type>)),  \\\n      nullptr,                                                         \\\n  }\n\n// Specialization for numbers.\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int8_t,\n    std::int8_t,\n    T_BYTE);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int16_t,\n    std::int16_t,\n    T_I16);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int32_t,\n    std::int32_t,\n    T_I32);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::int64_t,\n    std::int64_t,\n    T_I64);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint8_t,\n    std::int8_t,\n    T_BYTE);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint16_t,\n    std::int16_t,\n    T_I16);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint32_t,\n    std::int32_t,\n    T_I32);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(\n    integral,\n    std::uint64_t,\n    std::int64_t,\n    T_I64);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(integral, bool, bool, T_BOOL);\n\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, float, float, T_FLOAT);\nTHRIFT_DEFINE_PRIMITIVE_TYPE_TO_INFO(floating_point, double, double, T_DOUBLE);\n\n// Specialization for string.\n#define THRIFT_DEFINE_STRING_TYPE_TO_INFO(TypeClass, ActualType, ExtVal)     \\\n  const StringFieldType TypeToInfo<type_class::TypeClass, ActualType>::ext = \\\n      ExtVal;                                                                \\\n  const TypeInfo TypeToInfo<type_class::TypeClass, ActualType>::typeInfo = { \\\n      /* .type */ protocol::TType::T_STRING,                                 \\\n      /* .set */ nullptr,                                                    \\\n      /* .get */ nullptr,                                                    \\\n      /* .typeExt */ &ext,                                                   \\\n  }\n\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(string, std::string, StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(\n    string,\n    folly::fbstring,\n    StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, std::string, StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(\n    binary,\n    folly::fbstring,\n    StringFieldType::String);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(binary, folly::IOBuf, StringFieldType::IOBuf);\nTHRIFT_DEFINE_STRING_TYPE_TO_INFO(\n    binary,\n    std::unique_ptr<folly::IOBuf>,\n    StringFieldType::IOBufPtr);\n\nnamespace {\nconstexpr TypeInfo kStopType = {\n    protocol::TType::T_STOP,\n    nullptr,\n    nullptr,\n    nullptr};\nconstexpr FieldInfo kStopMarker = {0, false, nullptr, 0, 0, &kStopType};\n\ntemplate <class Protocol_>\nvoid skip(\n    Protocol_* iprot,\n    ProtocolReaderStructReadState<Protocol_>& readState) {\n  readState.skip(iprot);\n  readState.readFieldEnd(iprot);\n  readState.readFieldBeginNoInline(iprot);\n}\n\nconst void* getMember(const FieldInfo& fieldInfo, const void* object) {\n  return static_cast<const char*>(object) + fieldInfo.memberOffset;\n}\n\nvoid* getMember(const FieldInfo& fieldInfo, void* object) {\n  return static_cast<char*>(object) + fieldInfo.memberOffset;\n}\n\nconst OptionalThriftValue getValue(\n    const TypeInfo& typeInfo,\n    const void* object) {\n  if (typeInfo.get) {\n    // Handle smart pointer and numerical types.\n    return reinterpret_cast<OptionalThriftValue (*)(const void*)>(typeInfo.get)(\n        object);\n  }\n  // Handle others.\n  if (object) {\n    return folly::make_optional<ThriftValue>(object);\n  }\n  return folly::none;\n}\n\nFOLLY_ERASE void* invokeSet(VoidFuncPtr set, void* object) {\n  return reinterpret_cast<void* (*)(void*)>(set)(object);\n}\n\ntemplate <class Protocol_>\nconst FieldInfo* FOLLY_NULLABLE findFieldInfo(\n    Protocol_* iprot,\n    ProtocolReaderStructReadState<Protocol_>& readState,\n    const StructInfo& structInfo) {\n  auto* end = structInfo.fieldInfos + structInfo.numFields;\n  if (iprot->kUsesFieldNames()) {\n    const FieldInfo* found =\n        std::find_if(structInfo.fieldInfos, end, [&](const FieldInfo& val) {\n          return val.name == readState.fieldName();\n        });\n    if (found != end) {\n      readState.fieldId = found->id;\n      readState.fieldType = found->typeInfo->type;\n      if (readState.isCompatibleWithType(iprot, found->typeInfo->type)) {\n        return found;\n      }\n    }\n  } else {\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        readState.fieldId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found != end && found->id == readState.fieldId &&\n        readState.isCompatibleWithType(iprot, found->typeInfo->type)) {\n      return found;\n    }\n  }\n  return nullptr;\n}\n\n// Returns a reference to the data member that holds the active field id for a\n// Thrift union object.\nconst int& getActiveId(const void* object, const StructInfo& info) {\n  return *reinterpret_cast<const int*>(\n      static_cast<const char*>(object) + info.unionExt->unionTypeOffset);\n}\n\nconst bool& fieldIsSet(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const bool*>(\n      offset + static_cast<const char*>(object));\n}\n\ntemplate <class Protocol_>\nvoid read(\n    Protocol_* iprot,\n    const TypeInfo& typeInfo,\n    ProtocolReaderStructReadState<Protocol_>& readState,\n    void* object) {\n  using WireTypeInfo = ProtocolReaderWireTypeInfo<Protocol_>;\n  using WireType = typename WireTypeInfo::WireType;\n  switch (typeInfo.type) {\n    case protocol::TType::T_STRUCT:\n      readState.beforeSubobject(iprot);\n      read<Protocol_>(\n          iprot,\n          *static_cast<const StructInfo*>(typeInfo.typeExt),\n          typeInfo.set ? invokeSet(typeInfo.set, object) : object);\n      readState.afterSubobject(iprot);\n      break;\n    case protocol::TType::T_I64: {\n      std::int64_t temp;\n      iprot->readI64(temp);\n      reinterpret_cast<void (*)(void*, std::int64_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_I32: {\n      std::int32_t temp;\n      iprot->readI32(temp);\n      reinterpret_cast<void (*)(void*, std::int32_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_I16: {\n      std::int16_t temp;\n      iprot->readI16(temp);\n      reinterpret_cast<void (*)(void*, std::int16_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_BYTE: {\n      std::int8_t temp;\n      iprot->readByte(temp);\n      reinterpret_cast<void (*)(void*, std::int8_t)>(typeInfo.set)(\n          object, temp);\n      break;\n    }\n    case protocol::TType::T_BOOL: {\n      bool temp;\n      iprot->readBool(temp);\n      reinterpret_cast<void (*)(void*, bool)>(typeInfo.set)(object, temp);\n      break;\n    }\n    case protocol::TType::T_DOUBLE: {\n      double temp;\n      iprot->readDouble(temp);\n      reinterpret_cast<void (*)(void*, double)>(typeInfo.set)(object, temp);\n      break;\n    }\n    case protocol::TType::T_FLOAT: {\n      float temp;\n      iprot->readFloat(temp);\n      reinterpret_cast<void (*)(void*, float)>(typeInfo.set)(object, temp);\n      break;\n    }\n    case protocol::TType::T_STRING: {\n      switch (*static_cast<const StringFieldType*>(typeInfo.typeExt)) {\n        case StringFieldType::String:\n          iprot->readString(*static_cast<std::string*>(object));\n          break;\n        case StringFieldType::IOBuf:\n          iprot->readBinary(*static_cast<folly::IOBuf*>(object));\n          break;\n        case StringFieldType::IOBufPtr:\n          iprot->readBinary(\n              *static_cast<std::unique_ptr<folly::IOBuf>*>(object));\n          break;\n      }\n      break;\n    }\n    case protocol::TType::T_MAP: {\n      readState.beforeSubobject(iprot);\n      // Initialize the container to clear out current values.\n      auto* actualObject = invokeSet(typeInfo.set, object);\n      const MapFieldExt& ext =\n          *static_cast<const MapFieldExt*>(typeInfo.typeExt);\n      std::uint32_t size = ~0;\n      WireType reportedKeyType = WireTypeInfo::defaultValue();\n      WireType reportedMappedType = WireTypeInfo::defaultValue();\n      iprot->readMapBegin(reportedKeyType, reportedMappedType, size);\n      struct Context {\n        const TypeInfo* keyInfo;\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n        ProtocolReaderStructReadState<Protocol_>& readState;\n      };\n      const Context context = {\n          ext.keyInfo,\n          ext.valInfo,\n          iprot,\n          readState,\n      };\n      auto const keyReader = [](const void* context, void* key) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.keyInfo,\n            typedContext.readState,\n            key);\n      };\n      auto const valueReader = [](const void* context, void* val) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.valInfo,\n            typedContext.readState,\n            val);\n      };\n      if (iprot->kOmitsContainerSizes()) {\n        while (iprot->peekMap()) {\n          ext.consumeElem(&context, actualObject, keyReader, valueReader);\n        }\n      } else {\n        if (size > 0 &&\n            (ext.keyInfo->type != reportedKeyType ||\n             ext.valInfo->type != reportedMappedType)) {\n          skip_n(*iprot, size, {reportedKeyType, reportedMappedType});\n        } else {\n          if (!canReadNElements(\n                  *iprot, size, {reportedKeyType, reportedMappedType})) {\n            protocol::TProtocolException::throwTruncatedData();\n          }\n          ext.readMap(&context, actualObject, size, keyReader, valueReader);\n        }\n      }\n      iprot->readMapEnd();\n      readState.afterSubobject(iprot);\n      break;\n    }\n    case protocol::TType::T_SET: {\n      readState.beforeSubobject(iprot);\n      // Initialize the container to clear out current values.\n      auto* actualObject = invokeSet(typeInfo.set, object);\n      const SetFieldExt& ext =\n          *static_cast<const SetFieldExt*>(typeInfo.typeExt);\n      std::uint32_t size = ~0;\n      WireType reportedType = WireTypeInfo::defaultValue();\n      iprot->readSetBegin(reportedType, size);\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n        ProtocolReaderStructReadState<Protocol_>& readState;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n          readState,\n      };\n      auto const reader = [](const void* context, void* value) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.valInfo,\n            typedContext.readState,\n            value);\n      };\n      if (iprot->kOmitsContainerSizes()) {\n        while (iprot->peekSet()) {\n          ext.consumeElem(&context, actualObject, reader);\n        }\n      } else {\n        if (reportedType != ext.valInfo->type) {\n          skip_n(*iprot, size, {reportedType});\n        } else {\n          if (!canReadNElements(*iprot, size, {reportedType})) {\n            protocol::TProtocolException::throwTruncatedData();\n          }\n          ext.readSet(&context, actualObject, size, reader);\n        }\n      }\n      iprot->readSetEnd();\n      readState.afterSubobject(iprot);\n      break;\n    }\n    case protocol::TType::T_LIST: {\n      readState.beforeSubobject(iprot);\n      // Initialize the container to clear out current values.\n      auto* actualObject = invokeSet(typeInfo.set, object);\n      const ListFieldExt& ext =\n          *static_cast<const ListFieldExt*>(typeInfo.typeExt);\n      std::uint32_t size = ~0;\n      WireType reportedType = WireTypeInfo::defaultValue();\n\n      iprot->readListBegin(reportedType, size);\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n        ProtocolReaderStructReadState<Protocol_>& readState;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n          readState,\n      };\n      auto const reader = [](const void* context, void* value) {\n        const auto& typedContext = *static_cast<const Context*>(context);\n        read(\n            typedContext.iprot,\n            *typedContext.valInfo,\n            typedContext.readState,\n            value);\n      };\n      if (iprot->kOmitsContainerSizes()) {\n        while (iprot->peekList()) {\n          ext.consumeElem(&context, actualObject, reader);\n        }\n      } else {\n        if (reportedType != ext.valInfo->type) {\n          skip_n(*iprot, size, {reportedType});\n        } else {\n          if (!canReadNElements(*iprot, size, {reportedType})) {\n            protocol::TProtocolException::throwTruncatedData();\n          }\n          ext.readList(&context, actualObject, size, reader);\n        }\n      }\n      iprot->readListEnd();\n      readState.afterSubobject(iprot);\n      break;\n    }\n    case protocol::TType::T_STOP:\n    case protocol::TType::T_VOID:\n    case protocol::TType::T_UTF8:\n    case protocol::TType::T_U64:\n    case protocol::TType::T_UTF16:\n    case protocol::TType::T_STREAM:\n      skip(iprot, readState);\n  }\n}\n\ntemplate <class Protocol_>\nsize_t write(Protocol_* iprot, const TypeInfo& typeInfo, ThriftValue value) {\n  switch (typeInfo.type) {\n    case protocol::TType::T_STRUCT:\n      return write(\n          iprot,\n          *static_cast<const StructInfo*>(typeInfo.typeExt),\n          value.object);\n    case protocol::TType::T_I64:\n      return iprot->writeI64(value.int64Value);\n    case protocol::TType::T_I32:\n      return iprot->writeI32(value.int32Value);\n    case protocol::TType::T_I16:\n      return iprot->writeI16(value.int16Value);\n    case protocol::TType::T_BYTE:\n      return iprot->writeByte(value.int8Value);\n    case protocol::TType::T_BOOL:\n      return iprot->writeBool(value.boolValue);\n    case protocol::TType::T_DOUBLE:\n      return iprot->writeDouble(value.doubleValue);\n    case protocol::TType::T_FLOAT:\n      return iprot->writeFloat(value.floatValue);\n    case protocol::TType::T_STRING: {\n      switch (*static_cast<const StringFieldType*>(typeInfo.typeExt)) {\n        case StringFieldType::String:\n          return iprot->writeString(\n              *static_cast<const std::string*>(value.object));\n        case StringFieldType::IOBuf:\n          return iprot->writeBinary(\n              *static_cast<const folly::IOBuf*>(value.object));\n        case StringFieldType::IOBufPtr:\n          return iprot->writeBinary(\n              *static_cast<const std::unique_ptr<folly::IOBuf>*>(value.object));\n      };\n    }\n      // For container types, when recursively writing with lambdas we\n      // intentionally skip checking OptionalThriftValue.hasValue and treat it\n      // as a user error if the value is a nullptr.\n    case protocol::TType::T_MAP: {\n      const auto& ext = *static_cast<const MapFieldExt*>(typeInfo.typeExt);\n      size_t written = iprot->writeMapBegin(\n          ext.keyInfo->type, ext.valInfo->type, ext.size(value.object));\n\n      struct Context {\n        const TypeInfo* keyInfo;\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n      };\n      const Context context = {\n          ext.keyInfo,\n          ext.valInfo,\n          iprot,\n      };\n      written += ext.writeMap(\n          &context,\n          value.object,\n          iprot->kSortKeys(),\n          [](const void* context, const void* key, const void* val) {\n            const auto& typedContext = *static_cast<const Context*>(context);\n            const TypeInfo& keyInfo = *typedContext.keyInfo;\n            const TypeInfo& valInfo = *typedContext.valInfo;\n            return write(typedContext.iprot, keyInfo, *getValue(keyInfo, key)) +\n                write(typedContext.iprot,\n                      *typedContext.valInfo,\n                      *getValue(valInfo, val));\n          });\n      written += iprot->writeMapEnd();\n      return written;\n    }\n    case protocol::TType::T_SET: {\n      const auto& ext = *static_cast<const SetFieldExt*>(typeInfo.typeExt);\n      size_t written =\n          iprot->writeSetBegin(ext.valInfo->type, ext.size(value.object));\n\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n      };\n      written += ext.writeSet(\n          &context,\n          value.object,\n          iprot->kSortKeys(),\n          [](const void* context, const void* value) {\n            const auto& typedContext = *static_cast<const Context*>(context);\n            const TypeInfo& valInfo = *typedContext.valInfo;\n            return write(\n                typedContext.iprot, valInfo, *getValue(valInfo, value));\n          });\n      written += iprot->writeSetEnd();\n      return written;\n    }\n    case protocol::TType::T_LIST: {\n      const auto& ext = *static_cast<const ListFieldExt*>(typeInfo.typeExt);\n      size_t written =\n          iprot->writeListBegin(ext.valInfo->type, ext.size(value.object));\n\n      struct Context {\n        const TypeInfo* valInfo;\n        Protocol_* iprot;\n      };\n      const Context context = {\n          ext.valInfo,\n          iprot,\n      };\n      written += ext.writeList(\n          &context, value.object, [](const void* context, const void* value) {\n            const auto& typedContext = *static_cast<const Context*>(context);\n            const TypeInfo& valInfo = *typedContext.valInfo;\n            return write(\n                typedContext.iprot, valInfo, *getValue(valInfo, value));\n          });\n      written += iprot->writeListEnd();\n      return written;\n    }\n    case protocol::TType::T_STOP:\n    case protocol::TType::T_VOID:\n    case protocol::TType::T_STREAM:\n    case protocol::TType::T_UTF8:\n    case protocol::TType::T_U64:\n    case protocol::TType::T_UTF16:\n      DCHECK(false);\n      break;\n  }\n  return 0;\n}\n\ntemplate <class Protocol_>\nsize_t writeField(\n    Protocol_* iprot,\n    const FieldInfo& fieldInfo,\n    const ThriftValue& value) {\n  size_t written = iprot->writeFieldBegin(\n      fieldInfo.name, fieldInfo.typeInfo->type, fieldInfo.id);\n  written += write(iprot, *fieldInfo.typeInfo, value);\n  written += iprot->writeFieldEnd();\n  return written;\n}\n} // namespace\n\ntemplate <class Protocol_>\nvoid read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {\n      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));\n      if (activeId != 0) {\n        structInfo.unionExt->clear(object);\n      }\n      void* value = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);\n      read(iprot, *fieldInfo->typeInfo, readState, value);\n      activeId = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n\n  // Define out of loop to call advanceToNextField after the loop ends.\n  FieldID prevFieldId = 0;\n\n  // The index of the expected field in the struct layout.\n  std::int16_t index = 0;\n\n  // Every time advanceToNextField reports a field mismatch, either because the\n  // field is missing or if the serialized fields are not sorted (protocols\n  // don't guarantee a specific field order), we search for the field info\n  // matching the read bytes. Then we resume from the one past the found field\n  // to reduce the number of scans we have to do if the fields are sorted which\n  // is a common case. When we increment index past the number of fields we\n  // utilize the same search logic with a field info of type TType::T_STOP.\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    // Try to match the next field in order against the current bytes.\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      // Loop to skip until we find a match for both field id/name and type.\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          // Already at stop, return immediately.\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        // Found it.\n        if (fieldInfo) {\n          // Set the index to the field next in order to the found field.\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      // We are at stop and have tried all of the fields, so return.\n      readState.readStructEnd(iprot);\n      return;\n    }\n    // Id and type are what we expect, try read.\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}\n\ntemplate <class Protocol_>\nsize_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& activeId = getActiveId(object, structInfo);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        activeId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == activeId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}\n\ntemplate void read<CompactProtocolReader>(\n    CompactProtocolReader* iprot,\n    const StructInfo& structInfo,\n    void* object);\ntemplate size_t write<CompactProtocolWriter>(\n    CompactProtocolWriter* iprot,\n    const StructInfo& structInfo,\n    const void* object);\ntemplate void read<BinaryProtocolReader>(\n    BinaryProtocolReader* iprot,\n    const StructInfo& structInfo,\n    void* object);\ntemplate size_t write<BinaryProtocolWriter>(\n    BinaryProtocolWriter* iprot,\n    const StructInfo& structInfo,\n    const void* object);\ntemplate void read<SimpleJSONProtocolReader>(\n    SimpleJSONProtocolReader* iprot,\n    const StructInfo& structInfo,\n    void* object);\ntemplate size_t write<SimpleJSONProtocolWriter>(\n    SimpleJSONProtocolWriter* iprot,\n    const StructInfo& structInfo,\n    const void* object);\n} // namespace detail\n} // namespace thrift\n} // namespace apache\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <thrift/lib/cpp2/protocol/Serializer.h>\n\n#include <folly/io/IOBuf.h>\n#include <folly/json.h>\n#include <folly/portability/GTest.h>\n#include <folly/test/JsonTestUtil.h>\n#include <thrift/test/tablebased/gen-cpp2/frozen_tablebased_types.h>\n#include <thrift/test/tablebased/gen-cpp2/frozen_types.h>\n#include <thrift/test/tablebased/gen-cpp2/thrift_tablebased_types.h>\n#include <thrift/test/tablebased/gen-cpp2/thrift_types.h>\n\nusing apache::thrift::BinarySerializer;\nusing apache::thrift::CompactSerializer;\nusing apache::thrift::SimpleJSONSerializer;\nusing namespace facebook::thrift::test;\nnamespace tablebased = facebook::thrift::test::tablebased;\n\nnamespace {\n// This will actually fail if fields with larger ids are listed first in the\n// thrift struct because old serialization code will serialize by IDL order,\n// while new serialization code will serialize by field id order. The resulting\n// difference in order will consequently change the bytes serialized.\n#define EXPECT_SERIALIZED_DATA_EQ(Serializer, expected, result) \\\n  do {                                                          \\\n    if (std::is_same_v<Serializer, SimpleJSONSerializer>) {     \\\n      FOLLY_EXPECT_JSON_EQ(expected, result);                   \\\n    } else {                                                    \\\n      EXPECT_EQ(expected, result);                              \\\n    }                                                           \\\n  } while (false)\n\nconstexpr const char* UNQUALIFIED = \"unqualified\";\n\n// Tests that table based serialization matches the output of original\n// serialization. Tests that table based deserialization works with original\n// serialized bytes.\n#define EXPECT_COMPATIBLE_PROTOCOL_IMPL(                                     \\\n    object, tableBasedObject, Serializer, shouldSkipEqualityForUnionWithRef) \\\n  do {                                                                       \\\n    std::string originalBytes =                                              \\\n        Serializer::template serialize<std::string>(object);                 \\\n    auto tableBasedObjectFromOriginalBytes =                                 \\\n        Serializer::template deserialize<decltype(tableBasedObject)>(        \\\n            originalBytes);                                                  \\\n    std::string tableBasedBytes =                                            \\\n        Serializer::template serialize<std::string>(tableBasedObject);       \\\n    if (!shouldSkipEqualityForUnionWithRef) {                                \\\n      EXPECT_EQ(tableBasedObject, tableBasedObjectFromOriginalBytes);        \\\n    }                                                                        \\\n    EXPECT_SERIALIZED_DATA_EQ(Serializer, originalBytes, tableBasedBytes);   \\\n  } while (false)\n\n#define EXPECT_COMPATIBLE_PROTOCOL(object, tableBasedObject, Serializer) \\\n  EXPECT_COMPATIBLE_PROTOCOL_IMPL(object, tableBasedObject, Serializer, false)\n\n#define EXPECT_COMPATIBLE_PROTOCOL_UNION_REF( \\\n    object, tableBasedObject, Serializer)     \\\n  EXPECT_COMPATIBLE_PROTOCOL_IMPL(object, tableBasedObject, Serializer, true)\n\ntemplate <typename Type>\nType makeStructWithIncludeLike() {\n  Type object;\n  object.fieldA_ref().emplace();\n  return object;\n}\n\ntemplate <typename Type>\nType makeFrozenStructBLike() {\n  Type structBLike;\n  structBLike.fieldA_ref() = 2000;\n  return structBLike;\n}\n\ntemplate <typename Type>\nType makeFrozenStructALike() {\n  Type structALike;\n  structALike.fieldA_ref() = 2000;\n  return structALike;\n}\n\ntemplate <typename Type>\nType makeStructBLike() {\n  Type otherStructLike;\n  otherStructLike.fieldB_ref() = 2000;\n\n  otherStructLike.fieldC_ref() = folly::IOBuf::copyBuffer(\"testBuffer\");\n\n  otherStructLike.fieldD_ref() = std::make_shared<std::vector<int64_t>>();\n  otherStructLike.fieldD_ref()->emplace_back(9000);\n  otherStructLike.fieldD_ref()->emplace_back(8000);\n  otherStructLike.fieldE_ref() = 1000;\n  otherStructLike.fieldF_ref() = 20;\n  otherStructLike.fieldG_ref() = 16;\n  otherStructLike.fieldH_ref() = true;\n  otherStructLike.fieldI_ref() = std::set{1, 2, 3};\n  otherStructLike.fieldJ_ref() = \"testBuffer\";\n  otherStructLike.fieldK_ref() = 1.0;\n  otherStructLike.fieldL_ref() = 2.0;\n  return otherStructLike;\n}\n\ntemplate <typename Type>\nType makeStructALike() {\n  Type structALike;\n  structALike.fieldD_ref() = {\"first\", \"second\"};\n  structALike.fieldE_ref() = {{\"first\", 1}, {\"second\", 2}};\n  structALike.fieldA_ref() = \"yo\";\n  structALike.fieldB_ref() = 123;\n  structALike.fieldF_ref() = UNQUALIFIED;\n  structALike.fieldC_ref().emplace();\n  structALike.fieldC_ref() = makeStructBLike<\n      std::remove_reference_t<decltype(*structALike.fieldC_ref())>>();\n  using EnumType = std::remove_reference_t<decltype(*structALike.fieldG_ref())>;\n  structALike.fieldG_ref() = EnumType::A;\n  return structALike;\n}\n\ntemplate <typename Type>\nType makeStructWithRefLike() {\n  Type object;\n  object.fieldA_ref() = std::make_shared<std::add_const_t<\n      std::remove_reference_t<decltype(*object.fieldA_ref())>>>(\n      makeStructBLike<typename std::remove_const<\n          std::remove_reference_t<decltype(*object.fieldA_ref())>>::type>());\n  std::vector<std::string> tmp = {\"test1\", \"test2\"};\n  object.fieldB_ref() =\n      std::make_shared<const std::vector<std::string>>(std::move(tmp));\n  object.fieldC_ref() = std::make_shared<const std::int16_t>(1000);\n  object.fieldD_ref() = std::make_unique<std::int32_t>(5000);\n  return object;\n}\n} // namespace\n\nusing Protocols =\n    ::testing::Types<CompactSerializer, SimpleJSONSerializer, BinarySerializer>;\n\ntemplate <typename Serializer>\nclass MultiProtocolTest : public ::testing::Test {};\nTYPED_TEST_CASE(MultiProtocolTest, Protocols);\n\nTYPED_TEST(MultiProtocolTest, EmptyFrozenStructA) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      FrozenStructA(), tablebased::FrozenStructA(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, FrozenStructA) {\n  FrozenStructA oldObject = makeFrozenStructALike<FrozenStructA>();\n  tablebased::FrozenStructA newObject =\n      makeFrozenStructALike<tablebased::FrozenStructA>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyFrozenStructB) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      FrozenStructB(), tablebased::FrozenStructA(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, FrozenStructB) {\n  FrozenStructB oldObject = makeFrozenStructBLike<FrozenStructB>();\n  tablebased::FrozenStructB newObject =\n      makeFrozenStructBLike<tablebased::FrozenStructB>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyStructA) {\n  EXPECT_COMPATIBLE_PROTOCOL(StructA(), tablebased::StructA(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, StructA) {\n  StructA oldObject = makeStructALike<StructA>();\n  tablebased::StructA newObject = makeStructALike<tablebased::StructA>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyStructWithRef) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      StructWithRef(), tablebased::StructWithRef(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, StructWithRef) {\n  auto oldObject = makeStructWithRefLike<StructWithRef>();\n  auto newObject = makeStructWithRefLike<tablebased::StructWithRef>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyStructWithInclude) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      StructWithInclude(), tablebased::StructWithInclude(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, StructWithInclude) {\n  auto oldObject = makeStructWithIncludeLike<StructWithInclude>();\n  auto newObject = makeStructWithIncludeLike<tablebased::StructWithInclude>();\n  EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyUnion) {\n  EXPECT_COMPATIBLE_PROTOCOL(Union(), tablebased::Union(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, Union) {\n  {\n    StructA oldUnionVal = makeStructALike<StructA>();\n    Union oldObject;\n    oldObject.fieldA_ref() = oldUnionVal;\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    tablebased::Union newObject;\n    newObject.fieldA_ref() = newUnionVal;\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    StructB oldUnionVal = makeStructBLike<StructB>();\n    Union oldObject;\n    oldObject.fieldB_ref() = oldUnionVal;\n    tablebased::StructB newUnionVal = makeStructBLike<tablebased::StructB>();\n    tablebased::Union newObject;\n    newObject.fieldB_ref() = newUnionVal;\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    Union oldObject;\n    oldObject.fieldC_ref() = \"test\";\n    tablebased::Union newObject;\n    newObject.fieldC_ref() = \"test\";\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n}\n\nTYPED_TEST(MultiProtocolTest, EmptyUnionWithRef) {\n  EXPECT_COMPATIBLE_PROTOCOL(\n      UnionWithRef(), tablebased::UnionWithRef(), TypeParam);\n}\n\nTYPED_TEST(MultiProtocolTest, UnionWithRef) {\n  {\n    UnionWithRef oldObject;\n    oldObject.set_fieldA();\n    {\n      auto& ptr = oldObject.get_fieldA();\n      const_cast<std::unique_ptr<StructA>&>(ptr) =\n          std::unique_ptr<StructA>(nullptr);\n    }\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldA();\n    {\n      auto& ptr = newObject.get_fieldA();\n      const_cast<std::unique_ptr<tablebased::StructA>&>(ptr) =\n          std::unique_ptr<tablebased::StructA>(nullptr);\n    }\n    EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);\n    StructA oldUnionVal = makeStructALike<StructA>();\n    oldObject.set_fieldA(oldUnionVal);\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    newObject.set_fieldA(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    StructB oldUnionVal = makeStructBLike<StructB>();\n    UnionWithRef oldObject;\n    oldObject.set_fieldB(oldUnionVal);\n    tablebased::StructB newUnionVal = makeStructBLike<tablebased::StructB>();\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldB(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    UnionWithRef oldObject;\n    oldObject.set_fieldC();\n    {\n      auto& ptr = oldObject.get_fieldC();\n      const_cast<std::shared_ptr<const StructA>&>(ptr) =\n          std::shared_ptr<const StructA>(nullptr);\n    }\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldC();\n    {\n      auto& ptr = newObject.get_fieldC();\n      const_cast<std::shared_ptr<const tablebased::StructA>&>(ptr) =\n          std::shared_ptr<const tablebased::StructA>(nullptr);\n    }\n    EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);\n    StructA oldUnionVal = makeStructALike<StructA>();\n    oldObject.set_fieldC(oldUnionVal);\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    newObject.set_fieldC(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n  {\n    UnionWithRef oldObject;\n    oldObject.set_fieldD();\n    {\n      auto& ptr = oldObject.get_fieldD();\n      const_cast<std::shared_ptr<StructA>&>(ptr) =\n          std::shared_ptr<StructA>(nullptr);\n    }\n    tablebased::UnionWithRef newObject;\n    newObject.set_fieldD();\n    {\n      auto& ptr = newObject.get_fieldD();\n      const_cast<std::shared_ptr<tablebased::StructA>&>(ptr) =\n          std::shared_ptr<tablebased::StructA>(nullptr);\n    }\n    EXPECT_COMPATIBLE_PROTOCOL_UNION_REF(oldObject, newObject, TypeParam);\n    StructA oldUnionVal = makeStructALike<StructA>();\n    oldObject.set_fieldD(oldUnionVal);\n    tablebased::StructA newUnionVal = makeStructALike<tablebased::StructA>();\n    newObject.set_fieldD(newUnionVal);\n    EXPECT_COMPATIBLE_PROTOCOL(oldObject, newObject, TypeParam);\n  }\n}\n\nTYPED_TEST(MultiProtocolTest, DirtyReadIntoContainer) {\n  tablebased::StructA dirty;\n  dirty.fieldD_ref() = {\"should be cleared\"};\n\n  tablebased::StructA filled = makeStructALike<tablebased::StructA>();\n  std::string serialized = TypeParam::template serialize<std::string>(filled);\n  TypeParam::deserialize(serialized, dirty);\n  EXPECT_EQ(*filled.fieldD_ref(), *dirty.fieldD_ref());\n}\n\nTYPED_TEST(MultiProtocolTest, ReadingUnqualifiedFieldShouldSetIsset) {\n  tablebased::StructA obj = makeStructALike<tablebased::StructA>();\n\n  tablebased::StructA deserialized =\n      TypeParam::template deserialize<tablebased::StructA>(\n          TypeParam::template serialize<std::string>(obj));\n  EXPECT_TRUE(deserialized.fieldF_ref().is_set());\n  EXPECT_EQ(deserialized.fieldF_ref().value(), UNQUALIFIED);\n}\n\nTEST(SerializerTest, UnionValueOffsetIsZero) {\n  tablebased::Union u;\n  u.set_fieldC(\"test\");\n  EXPECT_EQ(static_cast<void*>(&u), &*u.fieldC_ref());\n\n  u.set_fieldA({});\n  EXPECT_EQ(static_cast<void*>(&u), &*u.fieldA_ref());\n\n  u.set_fieldB({});\n  EXPECT_EQ(static_cast<void*>(&u), &*u.fieldB_ref());\n}\n\nTEST(SerializerTest, DuplicateUnionData) {\n  // Test that we can handle invalid serialized input with duplicate and\n  // incomplete union data.\n  const char data[] =\n      \"\\x0c\" // type = TType::T_STRUCT\n      \"\\x00\\x01\" // fieldId = 1 (unionField)\n      \"\\x0b\" // type = TType::T_STRING\n      \"\\x00\\x01\" // fieldId = 1 (stringField)\n      \"\\x00\\x00\\x00\\x00\" // size = 0\n      \"\\x00\" // end of unionField\n\n      \"\\x0c\" // type = TType::T_STRUCT\n      \"\\x00\\x01\" // fieldId = 1 (unionField)\n      \"\\x13\" // type = TType::T_FLOAT\n      \"\\x00\\x02\"; // fieldId = 2 (floatField), value is missing\n\n  EXPECT_THROW(\n      BinarySerializer::deserialize<tablebased::TestStructWithUnion>(\n          folly::StringPiece(data, sizeof(data))),\n      std::out_of_range);\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace cpp2 facebook.thrift.test.tablebased\n\ninclude \"thrift/test/tablebased/include_tablebased.thrift\"\n\ntypedef binary (cpp2.type = \"std::unique_ptr<folly::IOBuf>\") IOBufPtr\n\nenum Enum {\n  A = 1,\n  B = 2,\n}\n\nstruct StructA {\n  1: optional string fieldA;\n  2: optional i64 fieldB;\n  3: optional StructB fieldC;\n  5: optional list<string> fieldD;\n  10: optional map<string, i64> fieldE;\n  11: string fieldF;\n  12: Enum fieldG;\n}\n\nstruct StructWithRef {\n  1: optional StructB fieldA (cpp2.ref_type = \"shared_const\");\n  2: optional list<string> fieldB (cpp2.ref_type = \"shared_const\");\n  3: optional i16 fieldC (cpp2.ref_type = \"shared_const\");\n  4: optional i32 fieldD (cpp2.ref_type = \"unique\");\n}\n\nstruct StructWithCppType {\n  1: optional map<string, StructA> (\n    cpp.type = \"std::unordered_map<std::string, StructA>\",\n  ) fieldA;\n}\n\nstruct StructB {\n  1: string fieldA;\n  2: optional i64 fieldB;\n  3: optional IOBufPtr fieldC;\n  5: optional list<i64> fieldD (cpp2.ref_type = \"shared\");\n  6: i32 fieldE;\n  7: i16 fieldF;\n  8: byte fieldG;\n  9: bool fieldH;\n  10: set<i32> fieldI;\n  11: string fieldJ (cpp2.type = \"folly::IOBuf\");\n  12: double fieldK;\n  13: float fieldL;\n}\n\nstruct StructWithInclude {\n  1: optional include_tablebased.IncludedStruct fieldA;\n}\n\nunion Union {\n  1: StructA fieldA;\n  2: StructB fieldB;\n  3: string fieldC;\n}\n\nunion UnionWithRef {\n  1: StructA fieldA (cpp2.ref_type = \"unique\");\n  2: StructB fieldB;\n  3: StructA fieldC (cpp2.ref_type = \"shared_const\");\n  4: StructA fieldD (cpp2.ref_type = \"shared\");\n}\n\nunion TestUnion {\n  1: string stringField;\n  2: float floatField;\n}\n\nstruct TestStructWithUnion {\n  1: TestUnion unionField;\n}\n"], "filenames": ["thrift/lib/cpp2/protocol/TableBasedSerializer.cpp", "thrift/test/tablebased/SerializerTest.cpp", "thrift/test/tablebased/thrift_tablebased.thrift"], "buggy_code_start_loc": [189, 358, 81], "buggy_code_end_loc": [682, 358, 81], "fixing_code_start_loc": [189, 359, 82], "fixing_code_end_loc": [682, 381, 91], "type": "CWE-763", "message": "An invalid free in Thrift's table-based serialization can cause the application to crash or potentially result in code execution or other undesirable effects. This issue affects Facebook Thrift prior to v2021.02.22.00.", "other": {"cve": {"id": "CVE-2021-24028", "sourceIdentifier": "cve-assign@fb.com", "published": "2021-04-14T00:15:13.057", "lastModified": "2021-04-21T15:38:52.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An invalid free in Thrift's table-based serialization can cause the application to crash or potentially result in code execution or other undesirable effects. This issue affects Facebook Thrift prior to v2021.02.22.00."}, {"lang": "es", "value": "Una liberaci\u00f3n no v\u00e1lida en la serializaci\u00f3n basada en tablas de Thrift puede causar que la aplicaci\u00f3n se bloquee o potencialmente resultar en una ejecuci\u00f3n de c\u00f3digo u otros efectos no deseados.&#xa0;Este problema afecta a Facebook Thrift versiones anteriores a v2021.02.22.00"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-763"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-763"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:thrift:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021.02.22.00", "matchCriteriaId": "A18FDF19-9F34-428F-A9C3-BB2E870D080C"}]}]}], "references": [{"url": "https://github.com/facebook/fbthrift/commit/bfda1efa547dce11a38592820916db01b05b9339", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2021-24028", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/fbthrift/commit/bfda1efa547dce11a38592820916db01b05b9339"}}