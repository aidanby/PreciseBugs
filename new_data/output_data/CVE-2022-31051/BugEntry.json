{"buggy_code": ["const {pick} = require('lodash');\nconst marked = require('marked');\nconst envCi = require('env-ci');\nconst hookStd = require('hook-std');\nconst semver = require('semver');\nconst AggregateError = require('aggregate-error');\nconst pkg = require('./package.json');\nconst hideSensitive = require('./lib/hide-sensitive');\nconst getConfig = require('./lib/get-config');\nconst verify = require('./lib/verify');\nconst getNextVersion = require('./lib/get-next-version');\nconst getCommits = require('./lib/get-commits');\nconst getLastRelease = require('./lib/get-last-release');\nconst getReleaseToAdd = require('./lib/get-release-to-add');\nconst {extractErrors, makeTag} = require('./lib/utils');\nconst getGitAuthUrl = require('./lib/get-git-auth-url');\nconst getBranches = require('./lib/branches');\nconst getLogger = require('./lib/get-logger');\nconst {verifyAuth, isBranchUpToDate, getGitHead, tag, push, pushNotes, getTagHead, addNote} = require('./lib/git');\nconst getError = require('./lib/get-error');\nconst {COMMIT_NAME, COMMIT_EMAIL} = require('./lib/definitions/constants');\n\nlet markedOptionsSet = false;\nasync function terminalOutput(text) {\n  if (!markedOptionsSet) {\n    const {default: TerminalRenderer} = await import('marked-terminal'); // eslint-disable-line node/no-unsupported-features/es-syntax\n    marked.setOptions({renderer: new TerminalRenderer()});\n    markedOptionsSet = true;\n  }\n\n  return marked.parse(text);\n}\n\n/* eslint complexity: off */\nasync function run(context, plugins) {\n  const {cwd, env, options, logger} = context;\n  const {isCi, branch, prBranch, isPr} = context.envCi;\n  const ciBranch = isPr ? prBranch : branch;\n\n  if (!isCi && !options.dryRun && !options.noCi) {\n    logger.warn('This run was not triggered in a known CI environment, running in dry-run mode.');\n    options.dryRun = true;\n  } else {\n    // When running on CI, set the commits author and commiter info and prevent the `git` CLI to prompt for username/password. See #703.\n    Object.assign(env, {\n      GIT_AUTHOR_NAME: COMMIT_NAME,\n      GIT_AUTHOR_EMAIL: COMMIT_EMAIL,\n      GIT_COMMITTER_NAME: COMMIT_NAME,\n      GIT_COMMITTER_EMAIL: COMMIT_EMAIL,\n      ...env,\n      GIT_ASKPASS: 'echo',\n      GIT_TERMINAL_PROMPT: 0,\n    });\n  }\n\n  if (isCi && isPr && !options.noCi) {\n    logger.log(\"This run was triggered by a pull request and therefore a new version won't be published.\");\n    return false;\n  }\n\n  // Verify config\n  await verify(context);\n\n  options.repositoryUrl = await getGitAuthUrl({...context, branch: {name: ciBranch}});\n  context.branches = await getBranches(options.repositoryUrl, ciBranch, context);\n  context.branch = context.branches.find(({name}) => name === ciBranch);\n\n  if (!context.branch) {\n    logger.log(\n      `This test run was triggered on the branch ${ciBranch}, while semantic-release is configured to only publish from ${context.branches\n        .map(({name}) => name)\n        .join(', ')}, therefore a new version won\u2019t be published.`\n    );\n    return false;\n  }\n\n  logger[options.dryRun ? 'warn' : 'success'](\n    `Run automated release from branch ${ciBranch} on repository ${options.repositoryUrl}${\n      options.dryRun ? ' in dry-run mode' : ''\n    }`\n  );\n\n  try {\n    try {\n      await verifyAuth(options.repositoryUrl, context.branch.name, {cwd, env});\n    } catch (error) {\n      if (!(await isBranchUpToDate(options.repositoryUrl, context.branch.name, {cwd, env}))) {\n        logger.log(\n          `The local branch ${context.branch.name} is behind the remote one, therefore a new version won't be published.`\n        );\n        return false;\n      }\n\n      throw error;\n    }\n  } catch (error) {\n    logger.error(`The command \"${error.command}\" failed with the error message ${error.stderr}.`);\n    throw getError('EGITNOPERMISSION', context);\n  }\n\n  logger.success(`Allowed to push to the Git repository`);\n\n  await plugins.verifyConditions(context);\n\n  const errors = [];\n  context.releases = [];\n  const releaseToAdd = getReleaseToAdd(context);\n\n  if (releaseToAdd) {\n    const {lastRelease, currentRelease, nextRelease} = releaseToAdd;\n\n    nextRelease.gitHead = await getTagHead(nextRelease.gitHead, {cwd, env});\n    currentRelease.gitHead = await getTagHead(currentRelease.gitHead, {cwd, env});\n    if (context.branch.mergeRange && !semver.satisfies(nextRelease.version, context.branch.mergeRange)) {\n      errors.push(getError('EINVALIDMAINTENANCEMERGE', {...context, nextRelease}));\n    } else {\n      const commits = await getCommits({...context, lastRelease, nextRelease});\n      nextRelease.notes = await plugins.generateNotes({...context, commits, lastRelease, nextRelease});\n\n      if (options.dryRun) {\n        logger.warn(`Skip ${nextRelease.gitTag} tag creation in dry-run mode`);\n      } else {\n        await addNote({channels: [...currentRelease.channels, nextRelease.channel]}, nextRelease.gitHead, {cwd, env});\n        await push(options.repositoryUrl, {cwd, env});\n        await pushNotes(options.repositoryUrl, {cwd, env});\n        logger.success(\n          `Add ${nextRelease.channel ? `channel ${nextRelease.channel}` : 'default channel'} to tag ${\n            nextRelease.gitTag\n          }`\n        );\n      }\n\n      context.branch.tags.push({\n        version: nextRelease.version,\n        channel: nextRelease.channel,\n        gitTag: nextRelease.gitTag,\n        gitHead: nextRelease.gitHead,\n      });\n\n      const releases = await plugins.addChannel({...context, commits, lastRelease, currentRelease, nextRelease});\n      context.releases.push(...releases);\n      await plugins.success({...context, lastRelease, commits, nextRelease, releases});\n    }\n  }\n\n  if (errors.length > 0) {\n    throw new AggregateError(errors);\n  }\n\n  context.lastRelease = getLastRelease(context);\n  if (context.lastRelease.gitHead) {\n    context.lastRelease.gitHead = await getTagHead(context.lastRelease.gitHead, {cwd, env});\n  }\n\n  if (context.lastRelease.gitTag) {\n    logger.log(\n      `Found git tag ${context.lastRelease.gitTag} associated with version ${context.lastRelease.version} on branch ${context.branch.name}`\n    );\n  } else {\n    logger.log(`No git tag version found on branch ${context.branch.name}`);\n  }\n\n  context.commits = await getCommits(context);\n\n  const nextRelease = {\n    type: await plugins.analyzeCommits(context),\n    channel: context.branch.channel || null,\n    gitHead: await getGitHead({cwd, env}),\n  };\n  if (!nextRelease.type) {\n    logger.log('There are no relevant changes, so no new version is released.');\n    return context.releases.length > 0 ? {releases: context.releases} : false;\n  }\n\n  context.nextRelease = nextRelease;\n  nextRelease.version = getNextVersion(context);\n  nextRelease.gitTag = makeTag(options.tagFormat, nextRelease.version);\n  nextRelease.name = nextRelease.gitTag;\n\n  if (context.branch.type !== 'prerelease' && !semver.satisfies(nextRelease.version, context.branch.range)) {\n    throw getError('EINVALIDNEXTVERSION', {\n      ...context,\n      validBranches: context.branches.filter(\n        ({type, accept}) => type !== 'prerelease' && accept.includes(nextRelease.type)\n      ),\n    });\n  }\n\n  await plugins.verifyRelease(context);\n\n  nextRelease.notes = await plugins.generateNotes(context);\n\n  await plugins.prepare(context);\n\n  if (options.dryRun) {\n    logger.warn(`Skip ${nextRelease.gitTag} tag creation in dry-run mode`);\n  } else {\n    // Create the tag before calling the publish plugins as some require the tag to exists\n    await tag(nextRelease.gitTag, nextRelease.gitHead, {cwd, env});\n    await addNote({channels: [nextRelease.channel]}, nextRelease.gitHead, {cwd, env});\n    await push(options.repositoryUrl, {cwd, env});\n    await pushNotes(options.repositoryUrl, {cwd, env});\n    logger.success(`Created tag ${nextRelease.gitTag}`);\n  }\n\n  const releases = await plugins.publish(context);\n  context.releases.push(...releases);\n\n  await plugins.success({...context, releases});\n\n  logger.success(\n    `Published release ${nextRelease.version} on ${nextRelease.channel ? nextRelease.channel : 'default'} channel`\n  );\n\n  if (options.dryRun) {\n    logger.log(`Release note for version ${nextRelease.version}:`);\n    if (nextRelease.notes) {\n      context.stdout.write(await terminalOutput(nextRelease.notes));\n    }\n  }\n\n  return pick(context, ['lastRelease', 'commits', 'nextRelease', 'releases']);\n}\n\nasync function logErrors({logger, stderr}, err) {\n  const errors = extractErrors(err).sort((error) => (error.semanticRelease ? -1 : 0));\n  for (const error of errors) {\n    if (error.semanticRelease) {\n      logger.error(`${error.code} ${error.message}`);\n      if (error.details) {\n        stderr.write(await terminalOutput(error.details)); // eslint-disable-line no-await-in-loop\n      }\n    } else {\n      logger.error('An error occurred while running semantic-release: %O', error);\n    }\n  }\n}\n\nasync function callFail(context, plugins, err) {\n  const errors = extractErrors(err).filter((err) => err.semanticRelease);\n  if (errors.length > 0) {\n    try {\n      await plugins.fail({...context, errors});\n    } catch (error) {\n      await logErrors(context, error);\n    }\n  }\n}\n\nmodule.exports = async (cliOptions = {}, {cwd = process.cwd(), env = process.env, stdout, stderr} = {}) => {\n  const {unhook} = hookStd(\n    {silent: false, streams: [process.stdout, process.stderr, stdout, stderr].filter(Boolean)},\n    hideSensitive(env)\n  );\n  const context = {\n    cwd,\n    env,\n    stdout: stdout || process.stdout,\n    stderr: stderr || process.stderr,\n    envCi: envCi({env, cwd}),\n  };\n  context.logger = getLogger(context);\n  context.logger.log(`Running ${pkg.name} version ${pkg.version}`);\n  try {\n    const {plugins, options} = await getConfig(context, cliOptions);\n    context.options = options;\n    try {\n      const result = await run(context, plugins);\n      unhook();\n      return result;\n    } catch (error) {\n      await callFail(context, plugins, error);\n      throw error;\n    }\n  } catch (error) {\n    await logErrors(context, error);\n    unhook();\n    throw error;\n  }\n};\n", "const test = require('ava');\nconst {escapeRegExp, isString, sortBy, omit} = require('lodash');\nconst proxyquire = require('proxyquire');\nconst {spy, stub} = require('sinon');\nconst {WritableStreamBuffer} = require('stream-buffers');\nconst AggregateError = require('aggregate-error');\nconst SemanticReleaseError = require('@semantic-release/error');\nconst {COMMIT_NAME, COMMIT_EMAIL, SECRET_REPLACEMENT} = require('../lib/definitions/constants');\nconst {\n  gitHead: getGitHead,\n  gitCheckout,\n  gitTagHead,\n  gitRepo,\n  gitCommits,\n  gitTagVersion,\n  gitRemoteTagHead,\n  gitPush,\n  gitShallowClone,\n  merge,\n  mergeFf,\n  rebase,\n  gitAddNote,\n  gitGetNote,\n} = require('./helpers/git-utils');\n\nconst requireNoCache = proxyquire.noPreserveCache();\nconst pluginNoop = require.resolve('./fixtures/plugin-noop');\n\ntest.beforeEach((t) => {\n  // Stub the logger functions\n  t.context.log = spy();\n  t.context.error = spy();\n  t.context.success = spy();\n  t.context.warn = spy();\n  t.context.logger = {\n    log: t.context.log,\n    error: t.context.error,\n    success: t.context.success,\n    warn: t.context.warn,\n    scope: () => t.context.logger,\n  };\n});\n\ntest('Plugins are called with expected values', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  let commits = await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.0.0', {cwd});\n  commits = (await gitCommits(['Second'], {cwd})).concat(commits);\n  await gitCheckout('next', true, {cwd});\n  await gitPush(repositoryUrl, 'next', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const lastRelease = {\n    version: '1.0.0',\n    gitHead: commits[commits.length - 1].hash,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    channels: ['next'],\n  };\n  const nextRelease = {\n    name: 'v1.1.0',\n    type: 'minor',\n    version: '1.1.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v1.1.0',\n    channel: null,\n  };\n  const notes1 = 'Release notes 1';\n  const notes2 = 'Release notes 2';\n  const notes3 = 'Release notes 3';\n  const verifyConditions1 = stub().resolves();\n  const verifyConditions2 = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes1 = stub().resolves(notes1);\n  const generateNotes2 = stub().resolves(notes2);\n  const generateNotes3 = stub().resolves(notes3);\n  const release1 = {name: 'Release 1', url: 'https://release1.com'};\n  const release2 = {name: 'Release 2', url: 'https://release2.com'};\n  const addChannel = stub().resolves(release1);\n  const prepare = stub().resolves();\n  const publish = stub().resolves(release2);\n  const success = stub().resolves();\n  const env = {};\n  const config = {\n    branches: [{name: 'master'}, {name: 'next'}],\n    repositoryUrl,\n    globalOpt: 'global',\n    tagFormat: `v\\${version}`,\n  };\n  const branches = [\n    {\n      channel: undefined,\n      name: 'master',\n      range: '>=1.0.0',\n      accept: ['patch', 'minor', 'major'],\n      tags: [{channels: ['next'], gitTag: 'v1.0.0', version: '1.0.0'}],\n      type: 'release',\n      main: true,\n    },\n    {\n      channel: 'next',\n      name: 'next',\n      range: '>=1.0.0',\n      accept: ['patch', 'minor', 'major'],\n      tags: [{channels: ['next'], gitTag: 'v1.0.0', version: '1.0.0'}],\n      type: 'release',\n      main: false,\n    },\n  ];\n  const branch = branches[0];\n  const options = {\n    ...config,\n    plugins: false,\n    verifyConditions: [verifyConditions1, verifyConditions2],\n    analyzeCommits,\n    verifyRelease,\n    addChannel,\n    generateNotes: [generateNotes1, generateNotes2, generateNotes3],\n    prepare,\n    publish: [publish, pluginNoop],\n    success,\n  };\n  const envCi = {branch: 'master', isCi: true, isPr: false};\n\n  const releases = [\n    {\n      ...omit(lastRelease, 'channels'),\n      ...release1,\n      type: 'major',\n      version: '1.0.0',\n      channel: null,\n      gitTag: 'v1.0.0',\n      notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`,\n      pluginName: '[Function: functionStub]',\n    },\n    {...nextRelease, ...release2, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`, pluginName: '[Function: functionStub]'},\n    {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`, pluginName: pluginNoop},\n  ];\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => envCi,\n  });\n  const result = await semanticRelease(options, {\n    cwd,\n    env,\n    stdout: new WritableStreamBuffer(),\n    stderr: new WritableStreamBuffer(),\n  });\n\n  t.is(verifyConditions1.callCount, 1);\n  t.deepEqual(verifyConditions1.args[0][0], config);\n  t.deepEqual(verifyConditions1.args[0][1].cwd, cwd);\n  t.deepEqual(verifyConditions1.args[0][1].options, options);\n  t.deepEqual(verifyConditions1.args[0][1].branch, branch);\n  t.deepEqual(verifyConditions1.args[0][1].branches, branches);\n  t.deepEqual(verifyConditions1.args[0][1].logger, t.context.logger);\n  t.deepEqual(verifyConditions1.args[0][1].envCi, envCi);\n  t.is(verifyConditions2.callCount, 1);\n  t.deepEqual(verifyConditions2.args[0][0], config);\n  t.deepEqual(verifyConditions2.args[0][1].cwd, cwd);\n  t.deepEqual(verifyConditions2.args[0][1].options, options);\n  t.deepEqual(verifyConditions2.args[0][1].branch, branch);\n  t.deepEqual(verifyConditions2.args[0][1].branches, branches);\n  t.deepEqual(verifyConditions2.args[0][1].logger, t.context.logger);\n  t.deepEqual(verifyConditions2.args[0][1].envCi, envCi);\n\n  t.is(generateNotes1.callCount, 2);\n  t.is(generateNotes2.callCount, 2);\n  t.is(generateNotes3.callCount, 2);\n\n  t.deepEqual(generateNotes1.args[0][0], config);\n  t.deepEqual(generateNotes1.args[0][1].options, options);\n  t.deepEqual(generateNotes1.args[0][1].branch, branch);\n  t.deepEqual(generateNotes1.args[0][1].branches, branches);\n  t.deepEqual(generateNotes1.args[0][1].logger, t.context.logger);\n  t.deepEqual(generateNotes1.args[0][1].lastRelease, {});\n  t.deepEqual(generateNotes1.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(generateNotes1.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(generateNotes1.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n  });\n  t.deepEqual(generateNotes2.args[0][1].envCi, envCi);\n\n  t.deepEqual(generateNotes2.args[0][0], config);\n  t.deepEqual(generateNotes2.args[0][1].options, options);\n  t.deepEqual(generateNotes2.args[0][1].branch, branch);\n  t.deepEqual(generateNotes2.args[0][1].branches, branches);\n  t.deepEqual(generateNotes2.args[0][1].logger, t.context.logger);\n  t.deepEqual(generateNotes2.args[0][1].lastRelease, {});\n  t.deepEqual(generateNotes2.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(generateNotes2.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(generateNotes2.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: notes1,\n  });\n  t.deepEqual(generateNotes2.args[0][1].envCi, envCi);\n\n  t.deepEqual(generateNotes3.args[0][0], config);\n  t.deepEqual(generateNotes3.args[0][1].options, options);\n  t.deepEqual(generateNotes3.args[0][1].branch, branch);\n  t.deepEqual(generateNotes3.args[0][1].branches, branches);\n  t.deepEqual(generateNotes3.args[0][1].logger, t.context.logger);\n  t.deepEqual(generateNotes3.args[0][1].lastRelease, {});\n  t.deepEqual(generateNotes3.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(generateNotes3.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(generateNotes3.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: `${notes1}\\n\\n${notes2}`,\n  });\n  t.deepEqual(generateNotes3.args[0][1].envCi, envCi);\n\n  branch.tags.push({\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    gitHead: commits[commits.length - 1].hash,\n  });\n\n  t.is(addChannel.callCount, 1);\n  t.deepEqual(addChannel.args[0][0], config);\n  t.deepEqual(addChannel.args[0][1].options, options);\n  t.deepEqual(addChannel.args[0][1].branch, branch);\n  t.deepEqual(addChannel.args[0][1].branches, branches);\n  t.deepEqual(addChannel.args[0][1].logger, t.context.logger);\n  t.deepEqual(addChannel.args[0][1].lastRelease, {});\n  t.deepEqual(addChannel.args[0][1].currentRelease, {...lastRelease, type: 'major'});\n  t.deepEqual(addChannel.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`,\n  });\n  t.deepEqual(addChannel.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(addChannel.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(addChannel.args[0][1].envCi, envCi);\n\n  t.is(analyzeCommits.callCount, 1);\n  t.deepEqual(analyzeCommits.args[0][0], config);\n  t.deepEqual(analyzeCommits.args[0][1].options, options);\n  t.deepEqual(analyzeCommits.args[0][1].branch, branch);\n  t.deepEqual(analyzeCommits.args[0][1].branches, branches);\n  t.deepEqual(analyzeCommits.args[0][1].logger, t.context.logger);\n  t.deepEqual(analyzeCommits.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(analyzeCommits.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(analyzeCommits.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(analyzeCommits.args[0][1].envCi, envCi);\n\n  t.is(verifyRelease.callCount, 1);\n  t.deepEqual(verifyRelease.args[0][0], config);\n  t.deepEqual(verifyRelease.args[0][1].options, options);\n  t.deepEqual(verifyRelease.args[0][1].branch, branch);\n  t.deepEqual(verifyRelease.args[0][1].branches, branches);\n  t.deepEqual(verifyRelease.args[0][1].logger, t.context.logger);\n  t.deepEqual(verifyRelease.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(verifyRelease.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(verifyRelease.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(verifyRelease.args[0][1].nextRelease, nextRelease);\n  t.deepEqual(verifyRelease.args[0][1].envCi, envCi);\n\n  t.deepEqual(generateNotes1.args[1][0], config);\n  t.deepEqual(generateNotes1.args[1][1].options, options);\n  t.deepEqual(generateNotes1.args[1][1].branch, branch);\n  t.deepEqual(generateNotes1.args[1][1].branches, branches);\n  t.deepEqual(generateNotes1.args[1][1].logger, t.context.logger);\n  t.deepEqual(generateNotes1.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(generateNotes1.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(generateNotes1.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(generateNotes1.args[1][1].nextRelease, nextRelease);\n  t.deepEqual(generateNotes1.args[1][1].envCi, envCi);\n\n  t.deepEqual(generateNotes2.args[1][0], config);\n  t.deepEqual(generateNotes2.args[1][1].options, options);\n  t.deepEqual(generateNotes2.args[1][1].branch, branch);\n  t.deepEqual(generateNotes2.args[1][1].branches, branches);\n  t.deepEqual(generateNotes2.args[1][1].logger, t.context.logger);\n  t.deepEqual(generateNotes2.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(generateNotes2.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(generateNotes2.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(generateNotes2.args[1][1].nextRelease, {...nextRelease, notes: notes1});\n  t.deepEqual(generateNotes2.args[1][1].envCi, envCi);\n\n  t.deepEqual(generateNotes3.args[1][0], config);\n  t.deepEqual(generateNotes3.args[1][1].options, options);\n  t.deepEqual(generateNotes3.args[1][1].branch, branch);\n  t.deepEqual(generateNotes3.args[1][1].branches, branches);\n  t.deepEqual(generateNotes3.args[1][1].logger, t.context.logger);\n  t.deepEqual(generateNotes3.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(generateNotes3.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(generateNotes3.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(generateNotes3.args[1][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}`});\n  t.deepEqual(generateNotes3.args[1][1].envCi, envCi);\n\n  t.is(prepare.callCount, 1);\n  t.deepEqual(prepare.args[0][0], config);\n  t.deepEqual(prepare.args[0][1].options, options);\n  t.deepEqual(prepare.args[0][1].branch, branch);\n  t.deepEqual(prepare.args[0][1].branches, branches);\n  t.deepEqual(prepare.args[0][1].logger, t.context.logger);\n  t.deepEqual(prepare.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(prepare.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(prepare.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(prepare.args[0][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`});\n  t.deepEqual(prepare.args[0][1].envCi, envCi);\n\n  t.is(publish.callCount, 1);\n  t.deepEqual(publish.args[0][0], config);\n  t.deepEqual(publish.args[0][1].options, options);\n  t.deepEqual(publish.args[0][1].branch, branch);\n  t.deepEqual(publish.args[0][1].branches, branches);\n  t.deepEqual(publish.args[0][1].logger, t.context.logger);\n  t.deepEqual(publish.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(publish.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(publish.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(publish.args[0][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`});\n  t.deepEqual(publish.args[0][1].envCi, envCi);\n\n  t.is(success.callCount, 2);\n  t.deepEqual(success.args[0][0], config);\n  t.deepEqual(success.args[0][1].options, options);\n  t.deepEqual(success.args[0][1].branch, branch);\n  t.deepEqual(success.args[0][1].branches, branches);\n  t.deepEqual(success.args[0][1].logger, t.context.logger);\n  t.deepEqual(success.args[0][1].lastRelease, {});\n  t.deepEqual(success.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(success.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(success.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`,\n  });\n  t.deepEqual(success.args[0][1].releases, [releases[0]]);\n  t.deepEqual(success.args[0][1].envCi, envCi);\n\n  t.deepEqual(success.args[1][0], config);\n  t.deepEqual(success.args[1][1].options, options);\n  t.deepEqual(success.args[1][1].branch, branch);\n  t.deepEqual(success.args[1][1].branches, branches);\n  t.deepEqual(success.args[1][1].logger, t.context.logger);\n  t.deepEqual(success.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(success.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(success.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(success.args[1][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`});\n  t.deepEqual(success.args[1][1].releases, [releases[1], releases[2]]);\n  t.deepEqual(success.args[1][1].envCi, envCi);\n\n  t.deepEqual(result, {\n    lastRelease,\n    commits: [{...commits[0], gitTags: '(HEAD -> master, next)'}],\n    nextRelease: {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`},\n    releases,\n  });\n\n  // Verify the tag has been created on the local and remote repo and reference the gitHead\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n\n  // Verify the author/commiter name and email have been set\n  t.is(env.GIT_AUTHOR_NAME, COMMIT_NAME);\n  t.is(env.GIT_AUTHOR_EMAIL, COMMIT_EMAIL);\n  t.is(env.GIT_COMMITTER_NAME, COMMIT_NAME);\n  t.is(env.GIT_COMMITTER_EMAIL, COMMIT_EMAIL);\n});\n\ntest('Use custom tag format', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('test-1.0.0', undefined, {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'test-2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'test-2.0.0',\n  };\n  const notes = 'Release notes';\n  const config = {branches: 'master', repositoryUrl, globalOpt: 'global', tagFormat: `test-\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves(nextRelease.type),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(notes),\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  // Verify the tag has been created on the local and remote repo and reference the gitHead\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n});\n\ntest('Use new gitHead, and recreate release notes if a prepare plugin create a commit', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  let commits = await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  commits = (await gitCommits(['Second'], {cwd})).concat(commits);\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: null,\n  };\n  const notes = 'Release notes';\n\n  const generateNotes = stub().resolves(notes);\n  const prepare1 = stub().callsFake(async () => {\n    commits = (await gitCommits(['Third'], {cwd})).concat(commits);\n  });\n  const prepare2 = stub().resolves();\n  const publish = stub().resolves();\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves(nextRelease.type),\n    verifyRelease: stub().resolves(),\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: [prepare1, prepare2],\n    publish,\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.is(generateNotes.callCount, 2);\n  t.deepEqual(generateNotes.args[0][1].nextRelease, nextRelease);\n  t.is(prepare1.callCount, 1);\n  t.deepEqual(prepare1.args[0][1].nextRelease, {...nextRelease, notes});\n\n  nextRelease.gitHead = await getGitHead({cwd});\n\n  t.deepEqual(generateNotes.args[1][1].nextRelease, {...nextRelease, notes});\n  t.is(prepare2.callCount, 1);\n  t.deepEqual(prepare2.args[0][1].nextRelease, {...nextRelease, notes});\n\n  t.is(publish.callCount, 1);\n  t.deepEqual(publish.args[0][1].nextRelease, {...nextRelease, notes});\n\n  // Verify the tag has been created on the local and remote repo and reference the last gitHead\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), commits[0].hash);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), commits[0].hash);\n});\n\ntest('Make a new release when a commit is forward-ported to an upper branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.0.x']}), 'v1.0.0', {cwd});\n  await gitCheckout('1.0.x', true, {cwd});\n  await gitCommits(['fix: fix on maintenance version 1.0.x'], {cwd});\n  await gitTagVersion('v1.0.1', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['1.0.x']}), 'v1.0.1', {cwd});\n  await gitPush('origin', '1.0.x', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['feat: new feature on master'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await merge('1.0.x', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {branches: [{name: '1.0.x'}, {name: 'master'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}}));\n\n  t.is(addChannel.callCount, 0);\n  t.is(publish.callCount, 1);\n  // The release 1.1.1, triggered by the forward-port of \"fix: fix on maintenance version 1.0.x\" has been published from master\n  t.is(publish.args[0][1].nextRelease.version, '1.1.1');\n  t.is(success.callCount, 1);\n});\n\ntest('Publish a pre-release version', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('beta', true, {cwd});\n  await gitCommits(['feat: a feature'], {cwd});\n  await gitPush(repositoryUrl, 'beta', {cwd});\n\n  const config = {branches: ['master', {name: 'beta', prerelease: true}], repositoryUrl};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(''),\n    addChannel: false,\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'beta', isPr: false}),\n  });\n  let {releases} = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.1');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.1');\n  t.is(await gitGetNote('v1.1.0-beta.1', {cwd}), '{\"channels\":[\"beta\"]}');\n\n  await gitCommits(['fix: a fix'], {cwd});\n  ({releases} = await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: {write: () => {}},\n    stderr: {write: () => {}},\n  }));\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.2');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.2');\n  t.is(await gitGetNote('v1.1.0-beta.2', {cwd}), '{\"channels\":[\"beta\"]}');\n});\n\ntest('Publish releases from different branch on the same channel', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('next-major', true, {cwd});\n  await gitPush(repositoryUrl, 'next-major', {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitCommits(['feat: a feature'], {cwd});\n  await gitPush(repositoryUrl, 'next', {cwd});\n\n  const config = {\n    branches: ['master', {name: 'next', channel: false}, {name: 'next-major', channel: false}],\n    repositoryUrl,\n  };\n  const addChannel = stub().resolves({});\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(''),\n    addChannel,\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  let semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'next', isPr: false}),\n  });\n  let {releases} = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0');\n  t.is(releases[0].gitTag, 'v1.1.0');\n\n  await gitCommits(['fix: a fix'], {cwd});\n  ({releases} = await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: {write: () => {}},\n    stderr: {write: () => {}},\n  }));\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.1');\n  t.is(releases[0].gitTag, 'v1.1.1');\n\n  await gitCheckout('master', false, {cwd});\n  await merge('next', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.falsy(await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}}));\n  t.is(addChannel.callCount, 0);\n});\n\ntest('Publish pre-releases the same channel as regular releases', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('beta', true, {cwd});\n  await gitCommits(['feat: a feature'], {cwd});\n  await gitPush(repositoryUrl, 'beta', {cwd});\n\n  const config = {\n    branches: ['master', {name: 'beta', channel: false, prerelease: true}],\n    repositoryUrl,\n  };\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(''),\n    addChannel: false,\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'beta', isPr: false}),\n  });\n  let {releases} = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.1');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.1');\n\n  await gitCommits(['fix: a fix'], {cwd});\n  ({releases} = await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: {write: () => {}},\n    stderr: {write: () => {}},\n  }));\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.2');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.2');\n});\n\ntest('Do not add pre-releases to a different channel', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'beta']}), 'v1.0.0', {cwd});\n  await gitCheckout('beta', true, {cwd});\n  await gitCommits(['feat: breaking change/n/nBREAKING CHANGE: break something'], {cwd});\n  await gitTagVersion('v2.0.0-beta.1', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['beta']}), 'v2.0.0-beta.1', {cwd});\n  await gitCommits(['fix: a fix'], {cwd});\n  await gitTagVersion('v2.0.0-beta.2', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['beta']}), 'v2.0.0-beta.2', {cwd});\n  await gitPush('origin', 'beta', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await merge('beta', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves('Release notes');\n  const release1 = {name: 'Release 1', url: 'https://release1.com'};\n  const addChannel = stub().resolves(release1);\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [{name: 'master'}, {name: 'beta', prerelease: 'beta'}],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    generateNotes,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}}));\n\n  t.is(addChannel.callCount, 0);\n});\n\nasync function addChannelMacro(t, mergeFunction) {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const commits = await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'next']}), 'v1.0.0', {cwd});\n  await gitCheckout('next', true, {cwd});\n  commits.push(...(await gitCommits(['feat: breaking change/n/nBREAKING CHANGE: break something'], {cwd})));\n  await gitTagVersion('v2.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v2.0.0', {cwd});\n\n  commits.push(...(await gitCommits(['fix: a fix'], {cwd})));\n  await gitTagVersion('v2.0.1', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v2.0.1', {cwd});\n  commits.push(...(await gitCommits(['feat: a feature'], {cwd})));\n  await gitTagVersion('v2.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v2.1.0', {cwd});\n  await gitPush('origin', 'next', {cwd});\n  await gitCheckout('master', false, {cwd});\n  // Merge all commits but last one from next to master\n  await mergeFunction('next~1', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const notes = 'Release notes';\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const release1 = {name: 'Release 1', url: 'https://release1.com'};\n  const addChannel1 = stub().resolves(release1);\n  const addChannel2 = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [\n      {name: 'master', channel: 'latest'},\n      {name: 'next', channel: 'next'},\n    ],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel: [addChannel1, addChannel2],\n    generateNotes,\n    prepare,\n    publish,\n    success,\n  };\n  const nextRelease = {\n    name: 'v2.0.1',\n    type: 'patch',\n    version: '2.0.1',\n    channel: 'latest',\n    gitTag: 'v2.0.1',\n    gitHead: commits[2].hash,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const result = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.deepEqual(result.releases, [\n    {...nextRelease, ...release1, notes, pluginName: '[Function: functionStub]'},\n    {...nextRelease, notes, pluginName: '[Function: functionStub]'},\n  ]);\n\n  // Verify the tag has been created on the local and remote repo and reference\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n}\n\naddChannelMacro.title = (providedTitle) => `Add version to a channel after a merge (${providedTitle})`;\n\ntest('fast-forward', addChannelMacro, mergeFf);\ntest('non fast-forward', addChannelMacro, merge);\ntest('rebase', addChannelMacro, rebase);\n\ntest('Call all \"success\" plugins even if one errors out', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: null,\n  };\n  const notes = 'Release notes';\n  const verifyConditions1 = stub().resolves();\n  const verifyConditions2 = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const generateNotes = stub().resolves(notes);\n  const release = {name: 'Release', url: 'https://release.com'};\n  const publish = stub().resolves(release);\n  const success1 = stub().rejects();\n  const success2 = stub().resolves();\n  const config = {\n    branches: [{name: 'master'}],\n    repositoryUrl,\n    globalOpt: 'global',\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions: [verifyConditions1, verifyConditions2],\n    analyzeCommits,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success: [success1, success2],\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  t.is(success1.callCount, 1);\n  t.deepEqual(success1.args[0][0], config);\n  t.deepEqual(success1.args[0][1].releases, [\n    {...nextRelease, ...release, notes, pluginName: '[Function: functionStub]'},\n  ]);\n\n  t.is(success2.callCount, 1);\n  t.deepEqual(success2.args[0][1].releases, [\n    {...nextRelease, ...release, notes, pluginName: '[Function: functionStub]'},\n  ]);\n});\n\ntest('Log all \"verifyConditions\" errors', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const error1 = new Error('error 1');\n  const error2 = new SemanticReleaseError('error 2', 'ERR2');\n  const error3 = new SemanticReleaseError('error 3', 'ERR3');\n  const fail = stub().resolves();\n  const config = {branches: [{name: 'master'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    plugins: false,\n    verifyConditions: [stub().rejects(new AggregateError([error1, error2])), stub().rejects(error3)],\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  t.deepEqual(sortBy(errors, ['message']), sortBy([error1, error2, error3], ['message']));\n  t.true(t.context.error.calledWith('An error occurred while running semantic-release: %O', error1));\n  t.true(t.context.error.calledWith('ERR2 error 2'));\n  t.true(t.context.error.calledWith('ERR3 error 3'));\n  t.true(t.context.error.calledAfter(t.context.log));\n  t.is(fail.callCount, 1);\n  t.deepEqual(fail.args[0][0], config);\n  t.deepEqual(fail.args[0][1].options, options);\n  t.deepEqual(fail.args[0][1].logger, t.context.logger);\n  t.deepEqual(fail.args[0][1].errors, [error2, error3]);\n});\n\ntest('Log all \"verifyRelease\" errors', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const error1 = new SemanticReleaseError('error 1', 'ERR1');\n  const error2 = new SemanticReleaseError('error 2', 'ERR2');\n  const fail = stub().resolves();\n  const config = {branches: [{name: 'master'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves('major'),\n    verifyRelease: [stub().rejects(error1), stub().rejects(error2)],\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  t.deepEqual(sortBy(errors, ['message']), sortBy([error1, error2], ['message']));\n  t.true(t.context.error.calledWith('ERR1 error 1'));\n  t.true(t.context.error.calledWith('ERR2 error 2'));\n  t.is(fail.callCount, 1);\n  t.deepEqual(fail.args[0][0], config);\n  t.deepEqual(fail.args[0][1].errors, [error1, error2]);\n});\n\ntest('Dry-run skips addChannel, prepare, publish and success', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'next']}), 'v1.0.0', {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.1.0', {cwd});\n\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitPush('origin', 'next', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves('minor');\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const options = {\n    dryRun: true,\n    branches: ['master', 'next'],\n    repositoryUrl,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.not(t.context.warn.args[0][0], 'This run was not triggered in a known CI environment, running in dry-run mode.');\n  t.is(verifyConditions.callCount, 1);\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes.callCount, 2);\n  t.is(addChannel.callCount, 0);\n  t.true(\n    t.context.warn.calledWith(`Skip step \"addChannel\" of plugin \"[Function: ${addChannel.name}]\" in dry-run mode`)\n  );\n  t.is(prepare.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"prepare\" of plugin \"[Function: ${prepare.name}]\" in dry-run mode`));\n  t.is(publish.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"publish\" of plugin \"[Function: ${publish.name}]\" in dry-run mode`));\n  t.is(success.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"success\" of plugin \"[Function: ${success.name}]\" in dry-run mode`));\n});\n\ntest('Dry-run skips fail', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const error1 = new SemanticReleaseError('error 1', 'ERR1');\n  const error2 = new SemanticReleaseError('error 2', 'ERR2');\n  const fail = stub().resolves();\n\n  const options = {\n    dryRun: true,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: [stub().rejects(error1), stub().rejects(error2)],\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  t.deepEqual(sortBy(errors, ['message']), sortBy([error1, error2], ['message']));\n  t.true(t.context.error.calledWith('ERR1 error 1'));\n  t.true(t.context.error.calledWith('ERR2 error 2'));\n  t.is(fail.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"fail\" of plugin \"[Function: ${fail.name}]\" in dry-run mode`));\n});\n\ntest('Force a dry-run if not on a CI and \"noCi\" is not explicitly set', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: undefined,\n  };\n  const notes = 'Release notes';\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const options = {\n    dryRun: false,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: false, branch: 'master'}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.true(t.context.warn.calledWith('This run was not triggered in a known CI environment, running in dry-run mode.'));\n  t.is(verifyConditions.callCount, 1);\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes.callCount, 1);\n  t.is(publish.callCount, 0);\n  t.is(success.callCount, 0);\n});\n\ntest('Dry-run does not print changelog if \"generateNotes\" return \"undefined\"', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {type: 'major', version: '2.0.0', gitHead: await getGitHead({cwd}), gitTag: 'v2.0.0'};\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const generateNotes = stub().resolves();\n\n  const options = {\n    dryRun: true,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: false,\n    analyzeCommits,\n    verifyRelease: false,\n    generateNotes,\n    prepare: false,\n    publish: false,\n    success: false,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.deepEqual(t.context.log.args[t.context.log.args.length - 1], ['Release note for version 2.0.0:']);\n});\n\ntest('Allow local releases with \"noCi\" option', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: undefined,\n  };\n  const notes = 'Release notes';\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const options = {\n    noCi: true,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: false, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.not(t.context.log.args[0][0], 'This run was not triggered in a known CI environment, running in dry-run mode.');\n  t.not(\n    t.context.log.args[0][0],\n    \"This run was triggered by a pull request and therefore a new version won't be published.\"\n  );\n  t.is(verifyConditions.callCount, 1);\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes.callCount, 1);\n  t.is(publish.callCount, 1);\n  t.is(success.callCount, 1);\n});\n\ntest('Accept \"undefined\" value returned by \"generateNotes\" and \"false\" by \"publish\" and \"addChannel\"', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'next']}), 'v1.0.0', {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.1.0', {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitPush('origin', 'next', {cwd});\n  await gitCheckout('master', false, {cwd});\n\n  const nextRelease = {\n    name: 'v1.2.0',\n    type: 'minor',\n    version: '1.2.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v1.2.0',\n    channel: null,\n  };\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes1 = stub().resolves();\n  const notes2 = 'Release notes 2';\n  const generateNotes2 = stub().resolves(notes2);\n  const publish = stub().resolves(false);\n  const addChannel = stub().resolves(false);\n  const success = stub().resolves();\n\n  const options = {\n    branches: ['master', 'next'],\n    repositoryUrl,\n    verifyConditions: stub().resolves(),\n    analyzeCommits,\n    verifyRelease,\n    generateNotes: [generateNotes1, generateNotes2],\n    addChannel,\n    prepare: stub().resolves(),\n    publish,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes1.callCount, 2);\n  t.is(generateNotes2.callCount, 2);\n  t.is(addChannel.callCount, 1);\n  t.is(publish.callCount, 1);\n  t.is(success.callCount, 2);\n  t.deepEqual(publish.args[0][1].nextRelease, {...nextRelease, notes: notes2});\n  t.deepEqual(success.args[0][1].releases, [{pluginName: '[Function: functionStub]'}]);\n  t.deepEqual(success.args[1][1].releases, [{pluginName: '[Function: functionStub]'}]);\n});\n\ntest('Returns false if triggered by a PR', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', prBranch: 'patch-1', isPr: true}),\n  });\n\n  t.false(\n    await semanticRelease(\n      {cwd, repositoryUrl},\n      {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()}\n    )\n  );\n  t.is(\n    t.context.log.args[t.context.log.args.length - 1][0],\n    \"This run was triggered by a pull request and therefore a new version won't be published.\"\n  );\n});\n\ntest('Throws \"EINVALIDNEXTVERSION\" if next release is out of range of the current maintenance branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.x']}), 'v1.0.0', {cwd});\n  await gitCheckout('1.x', true, {cwd});\n  await gitPush('origin', '1.x', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['feat: new feature on master'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitCheckout('1.x', false, {cwd});\n  await gitCommits(['feat: feature on maintenance version 1.x'], {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [{name: '1.x'}, {name: 'master'}],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: '1.x', isPr: false}),\n  });\n\n  const error = await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}})\n  );\n\n  t.is(error.code, 'EINVALIDNEXTVERSION');\n  t.is(error.name, 'SemanticReleaseError');\n  t.is(error.message, 'The release `1.1.0` on branch `1.x` cannot be published as it is out of range.');\n  t.regex(error.details, /A valid branch could be `master`./);\n});\n\ntest('Throws \"EINVALIDNEXTVERSION\" if next release is out of range of the current release branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitCommits(['feat: new feature on next'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.1.0', {cwd});\n  await gitPush('origin', 'next', {cwd});\n  await gitCheckout('next-major', true, {cwd});\n  await gitPush('origin', 'next-major', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['feat: new feature on master', 'fix: new fix on master'], {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [{name: 'master'}, {name: 'next'}, {name: 'next-major'}],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  const error = await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}})\n  );\n\n  t.is(error.code, 'EINVALIDNEXTVERSION');\n  t.is(error.name, 'SemanticReleaseError');\n  t.is(error.message, 'The release `1.1.0` on branch `master` cannot be published as it is out of range.');\n  t.regex(error.details, /A valid branch could be `next` or `next-major`./);\n});\n\ntest('Throws \"EINVALIDMAINTENANCEMERGE\" if merge an out of range release in a maintenance branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.1.x']}), 'v1.0.0', {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.1.x']}), 'v1.1.0', {cwd});\n  await gitCheckout('1.1.x', 'master', {cwd});\n  await gitPush('origin', '1.1.x', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['Third'], {cwd});\n  await gitTagVersion('v1.1.1', undefined, {cwd});\n  await gitCommits(['Fourth'], {cwd});\n  await gitTagVersion('v1.2.0', undefined, {cwd});\n  await gitPush('origin', 'master', {cwd});\n  await gitCheckout('1.1.x', false, {cwd});\n  await merge('master', {cwd});\n  await gitPush('origin', '1.1.x', {cwd});\n\n  const notes = 'Release notes';\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n  const fail = stub().resolves();\n\n  const config = {branches: [{name: 'master'}, {name: '1.1.x'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    addChannel,\n    generateNotes,\n    prepare,\n    publish,\n    success,\n    fail,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: '1.1.x', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}})\n    )),\n  ];\n\n  t.is(addChannel.callCount, 0);\n\n  t.is(publish.callCount, 0);\n\n  t.is(success.callCount, 0);\n\n  t.is(fail.callCount, 1);\n  t.deepEqual(fail.args[0][1].errors, errors);\n\n  t.is(errors[0].code, 'EINVALIDMAINTENANCEMERGE');\n  t.is(errors[0].name, 'SemanticReleaseError');\n  t.truthy(errors[0].message);\n  t.truthy(errors[0].details);\n});\n\ntest('Returns false value if triggered on an outdated clone', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  let {cwd, repositoryUrl} = await gitRepo(true);\n  const repoDir = cwd;\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  cwd = await gitShallowClone(repositoryUrl);\n  await gitCommits(['Third'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.false(\n    await semanticRelease(\n      {repositoryUrl},\n      {cwd: repoDir, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()}\n    )\n  );\n  t.deepEqual(t.context.log.args[t.context.log.args.length - 1], [\n    \"The local branch master is behind the remote one, therefore a new version won't be published.\",\n  ]);\n});\n\ntest('Returns false if not running from the configured branch', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(),\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'other-branch', isPr: false}),\n  });\n\n  t.false(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n  t.is(\n    t.context.log.args[1][0],\n    'This test run was triggered on the branch other-branch, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.'\n  );\n});\n\ntest('Returns false if there is no relevant changes', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const analyzeCommits = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves();\n  const publish = stub().resolves();\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: [stub().resolves()],\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.false(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 0);\n  t.is(generateNotes.callCount, 0);\n  t.is(publish.callCount, 0);\n  t.is(\n    t.context.log.args[t.context.log.args.length - 1][0],\n    'There are no relevant changes, so no new version is released.'\n  );\n});\n\ntest('Exclude commits with [skip release] or [release skip] from analysis', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  const commits = await gitCommits(\n    [\n      'Test commit',\n      'Test commit [skip release]',\n      'Test commit [release skip]',\n      'Test commit [Release Skip]',\n      'Test commit [Skip Release]',\n      'Test commit [skip    release]',\n      'Test commit\\n\\n commit body\\n[skip release]',\n      'Test commit\\n\\n commit body\\n[release skip]',\n    ],\n    {cwd}\n  );\n  await gitPush(repositoryUrl, 'master', {cwd});\n  const analyzeCommits = stub().resolves();\n  const config = {branches: ['master'], repositoryUrl, globalOpt: 'global'};\n  const options = {\n    ...config,\n    verifyConditions: [stub().resolves(), stub().resolves()],\n    analyzeCommits,\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(),\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: new WritableStreamBuffer(),\n    stderr: new WritableStreamBuffer(),\n  });\n\n  t.is(analyzeCommits.callCount, 1);\n  t.is(analyzeCommits.args[0][1].commits.length, 2);\n  t.deepEqual(analyzeCommits.args[0][1].commits[0], commits[commits.length - 1]);\n});\n\ntest('Log both plugins errors and errors thrown by \"fail\" plugin', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const pluginError = new SemanticReleaseError('Plugin error', 'ERR');\n  const failError1 = new Error('Fail error 1');\n  const failError2 = new Error('Fail error 2');\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().rejects(pluginError),\n    fail: [stub().rejects(failError1), stub().rejects(failError2)],\n  };\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  t.is(t.context.error.args[t.context.error.args.length - 1][0], 'ERR Plugin error');\n  t.is(t.context.error.args[t.context.error.args.length - 3][1], failError1);\n  t.is(t.context.error.args[t.context.error.args.length - 2][1], failError2);\n});\n\ntest('Call \"fail\" only if a plugin returns a SemanticReleaseError', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const pluginError = new Error('Plugin error');\n  const fail = stub().resolves();\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().rejects(pluginError),\n    fail,\n  };\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  t.true(fail.notCalled);\n  t.is(t.context.error.args[t.context.error.args.length - 1][1], pluginError);\n});\n\ntest('Throw SemanticReleaseError if repositoryUrl is not set and cannot be found from repo config', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd} = await gitRepo();\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease({}, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  // Verify error code and type\n  t.is(errors[0].code, 'ENOREPOURL');\n  t.is(errors[0].name, 'SemanticReleaseError');\n  t.truthy(errors[0].message);\n  t.truthy(errors[0].details);\n});\n\ntest('Throw an Error if plugin returns an unexpected value', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves('string');\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: [verifyConditions],\n    analyzeCommits,\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const error = await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()}),\n    {instanceOf: SemanticReleaseError}\n  );\n  t.regex(error.details, /string/);\n});\n\ntest('Hide sensitive information passed to \"fail\" plugin', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n\n  const fail = stub().resolves();\n  const env = {MY_TOKEN: 'secret token'};\n  const options = {\n    branch: 'master',\n    repositoryUrl,\n    verifyConditions: stub().throws(\n      new SemanticReleaseError(\n        `Message: Exposing token ${env.MY_TOKEN}`,\n        'ERR',\n        `Details: Exposing token ${env.MY_TOKEN}`\n      )\n    ),\n    success: stub().resolves(),\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  const error = fail.args[0][1].errors[0];\n\n  t.is(error.message, `Message: Exposing token ${SECRET_REPLACEMENT}`);\n  t.is(error.details, `Details: Exposing token ${SECRET_REPLACEMENT}`);\n\n  Object.getOwnPropertyNames(error).forEach((prop) => {\n    if (isString(error[prop])) {\n      t.notRegex(error[prop], new RegExp(escapeRegExp(env.MY_TOKEN)));\n    }\n  });\n});\n\ntest('Hide sensitive information passed to \"success\" plugin', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitCommits(['feat: new feature'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const success = stub().resolves();\n  const env = {MY_TOKEN: 'secret token'};\n  const options = {\n    branch: 'master',\n    repositoryUrl,\n    verifyConditions: false,\n    verifyRelease: false,\n    prepare: false,\n    generateNotes: stub().resolves(`Exposing token ${env.MY_TOKEN}`),\n    publish: stub().resolves({\n      name: `Name: Exposing token ${env.MY_TOKEN}`,\n      url: `URL: Exposing token ${env.MY_TOKEN}`,\n    }),\n    addChannel: false,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  await semanticRelease(options, {cwd, env, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()});\n\n  const release = success.args[0][1].releases[0];\n\n  t.is(release.name, `Name: Exposing token ${SECRET_REPLACEMENT}`);\n  t.is(release.url, `URL: Exposing token ${SECRET_REPLACEMENT}`);\n\n  Object.getOwnPropertyNames(release).forEach((prop) => {\n    if (isString(release[prop])) {\n      t.notRegex(release[prop], new RegExp(escapeRegExp(env.MY_TOKEN)));\n    }\n  });\n});\n\ntest('Get all commits including the ones not in the shallow clone', async (t) => {\n  let {cwd, repositoryUrl} = await gitRepo(true);\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitCommits(['First', 'Second', 'Third'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  cwd = await gitShallowClone(repositoryUrl);\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: undefined,\n  };\n  const notes = 'Release notes';\n  const analyzeCommits = stub().resolves(nextRelease.type);\n\n  const config = {branches: ['master'], repositoryUrl, globalOpt: 'global'};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    analyzeCommits,\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(notes),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.is(analyzeCommits.args[0][1].commits.length, 3);\n});\n"], "fixing_code": ["const {pick} = require('lodash');\nconst marked = require('marked');\nconst envCi = require('env-ci');\nconst hookStd = require('hook-std');\nconst semver = require('semver');\nconst AggregateError = require('aggregate-error');\nconst pkg = require('./package.json');\nconst hideSensitive = require('./lib/hide-sensitive');\nconst getConfig = require('./lib/get-config');\nconst verify = require('./lib/verify');\nconst getNextVersion = require('./lib/get-next-version');\nconst getCommits = require('./lib/get-commits');\nconst getLastRelease = require('./lib/get-last-release');\nconst getReleaseToAdd = require('./lib/get-release-to-add');\nconst {extractErrors, makeTag} = require('./lib/utils');\nconst getGitAuthUrl = require('./lib/get-git-auth-url');\nconst getBranches = require('./lib/branches');\nconst getLogger = require('./lib/get-logger');\nconst {verifyAuth, isBranchUpToDate, getGitHead, tag, push, pushNotes, getTagHead, addNote} = require('./lib/git');\nconst getError = require('./lib/get-error');\nconst {COMMIT_NAME, COMMIT_EMAIL} = require('./lib/definitions/constants');\n\nlet markedOptionsSet = false;\nasync function terminalOutput(text) {\n  if (!markedOptionsSet) {\n    const {default: TerminalRenderer} = await import('marked-terminal'); // eslint-disable-line node/no-unsupported-features/es-syntax\n    marked.setOptions({renderer: new TerminalRenderer()});\n    markedOptionsSet = true;\n  }\n\n  return marked.parse(text);\n}\n\n/* eslint complexity: off */\nasync function run(context, plugins) {\n  const {cwd, env, options, logger} = context;\n  const {isCi, branch, prBranch, isPr} = context.envCi;\n  const ciBranch = isPr ? prBranch : branch;\n\n  if (!isCi && !options.dryRun && !options.noCi) {\n    logger.warn('This run was not triggered in a known CI environment, running in dry-run mode.');\n    options.dryRun = true;\n  } else {\n    // When running on CI, set the commits author and commiter info and prevent the `git` CLI to prompt for username/password. See #703.\n    Object.assign(env, {\n      GIT_AUTHOR_NAME: COMMIT_NAME,\n      GIT_AUTHOR_EMAIL: COMMIT_EMAIL,\n      GIT_COMMITTER_NAME: COMMIT_NAME,\n      GIT_COMMITTER_EMAIL: COMMIT_EMAIL,\n      ...env,\n      GIT_ASKPASS: 'echo',\n      GIT_TERMINAL_PROMPT: 0,\n    });\n  }\n\n  if (isCi && isPr && !options.noCi) {\n    logger.log(\"This run was triggered by a pull request and therefore a new version won't be published.\");\n    return false;\n  }\n\n  // Verify config\n  await verify(context);\n\n  options.repositoryUrl = await getGitAuthUrl({...context, branch: {name: ciBranch}});\n  context.branches = await getBranches(options.repositoryUrl, ciBranch, context);\n  context.branch = context.branches.find(({name}) => name === ciBranch);\n\n  if (!context.branch) {\n    logger.log(\n      `This test run was triggered on the branch ${ciBranch}, while semantic-release is configured to only publish from ${context.branches\n        .map(({name}) => name)\n        .join(', ')}, therefore a new version won\u2019t be published.`\n    );\n    return false;\n  }\n\n  logger[options.dryRun ? 'warn' : 'success'](\n    `Run automated release from branch ${ciBranch} on repository ${options.originalRepositoryURL}${\n      options.dryRun ? ' in dry-run mode' : ''\n    }`\n  );\n\n  try {\n    try {\n      await verifyAuth(options.repositoryUrl, context.branch.name, {cwd, env});\n    } catch (error) {\n      if (!(await isBranchUpToDate(options.repositoryUrl, context.branch.name, {cwd, env}))) {\n        logger.log(\n          `The local branch ${context.branch.name} is behind the remote one, therefore a new version won't be published.`\n        );\n        return false;\n      }\n\n      throw error;\n    }\n  } catch (error) {\n    logger.error(`The command \"${error.command}\" failed with the error message ${error.stderr}.`);\n    throw getError('EGITNOPERMISSION', context);\n  }\n\n  logger.success(`Allowed to push to the Git repository`);\n\n  await plugins.verifyConditions(context);\n\n  const errors = [];\n  context.releases = [];\n  const releaseToAdd = getReleaseToAdd(context);\n\n  if (releaseToAdd) {\n    const {lastRelease, currentRelease, nextRelease} = releaseToAdd;\n\n    nextRelease.gitHead = await getTagHead(nextRelease.gitHead, {cwd, env});\n    currentRelease.gitHead = await getTagHead(currentRelease.gitHead, {cwd, env});\n    if (context.branch.mergeRange && !semver.satisfies(nextRelease.version, context.branch.mergeRange)) {\n      errors.push(getError('EINVALIDMAINTENANCEMERGE', {...context, nextRelease}));\n    } else {\n      const commits = await getCommits({...context, lastRelease, nextRelease});\n      nextRelease.notes = await plugins.generateNotes({...context, commits, lastRelease, nextRelease});\n\n      if (options.dryRun) {\n        logger.warn(`Skip ${nextRelease.gitTag} tag creation in dry-run mode`);\n      } else {\n        await addNote({channels: [...currentRelease.channels, nextRelease.channel]}, nextRelease.gitHead, {cwd, env});\n        await push(options.repositoryUrl, {cwd, env});\n        await pushNotes(options.repositoryUrl, {cwd, env});\n        logger.success(\n          `Add ${nextRelease.channel ? `channel ${nextRelease.channel}` : 'default channel'} to tag ${\n            nextRelease.gitTag\n          }`\n        );\n      }\n\n      context.branch.tags.push({\n        version: nextRelease.version,\n        channel: nextRelease.channel,\n        gitTag: nextRelease.gitTag,\n        gitHead: nextRelease.gitHead,\n      });\n\n      const releases = await plugins.addChannel({...context, commits, lastRelease, currentRelease, nextRelease});\n      context.releases.push(...releases);\n      await plugins.success({...context, lastRelease, commits, nextRelease, releases});\n    }\n  }\n\n  if (errors.length > 0) {\n    throw new AggregateError(errors);\n  }\n\n  context.lastRelease = getLastRelease(context);\n  if (context.lastRelease.gitHead) {\n    context.lastRelease.gitHead = await getTagHead(context.lastRelease.gitHead, {cwd, env});\n  }\n\n  if (context.lastRelease.gitTag) {\n    logger.log(\n      `Found git tag ${context.lastRelease.gitTag} associated with version ${context.lastRelease.version} on branch ${context.branch.name}`\n    );\n  } else {\n    logger.log(`No git tag version found on branch ${context.branch.name}`);\n  }\n\n  context.commits = await getCommits(context);\n\n  const nextRelease = {\n    type: await plugins.analyzeCommits(context),\n    channel: context.branch.channel || null,\n    gitHead: await getGitHead({cwd, env}),\n  };\n  if (!nextRelease.type) {\n    logger.log('There are no relevant changes, so no new version is released.');\n    return context.releases.length > 0 ? {releases: context.releases} : false;\n  }\n\n  context.nextRelease = nextRelease;\n  nextRelease.version = getNextVersion(context);\n  nextRelease.gitTag = makeTag(options.tagFormat, nextRelease.version);\n  nextRelease.name = nextRelease.gitTag;\n\n  if (context.branch.type !== 'prerelease' && !semver.satisfies(nextRelease.version, context.branch.range)) {\n    throw getError('EINVALIDNEXTVERSION', {\n      ...context,\n      validBranches: context.branches.filter(\n        ({type, accept}) => type !== 'prerelease' && accept.includes(nextRelease.type)\n      ),\n    });\n  }\n\n  await plugins.verifyRelease(context);\n\n  nextRelease.notes = await plugins.generateNotes(context);\n\n  await plugins.prepare(context);\n\n  if (options.dryRun) {\n    logger.warn(`Skip ${nextRelease.gitTag} tag creation in dry-run mode`);\n  } else {\n    // Create the tag before calling the publish plugins as some require the tag to exists\n    await tag(nextRelease.gitTag, nextRelease.gitHead, {cwd, env});\n    await addNote({channels: [nextRelease.channel]}, nextRelease.gitHead, {cwd, env});\n    await push(options.repositoryUrl, {cwd, env});\n    await pushNotes(options.repositoryUrl, {cwd, env});\n    logger.success(`Created tag ${nextRelease.gitTag}`);\n  }\n\n  const releases = await plugins.publish(context);\n  context.releases.push(...releases);\n\n  await plugins.success({...context, releases});\n\n  logger.success(\n    `Published release ${nextRelease.version} on ${nextRelease.channel ? nextRelease.channel : 'default'} channel`\n  );\n\n  if (options.dryRun) {\n    logger.log(`Release note for version ${nextRelease.version}:`);\n    if (nextRelease.notes) {\n      context.stdout.write(await terminalOutput(nextRelease.notes));\n    }\n  }\n\n  return pick(context, ['lastRelease', 'commits', 'nextRelease', 'releases']);\n}\n\nasync function logErrors({logger, stderr}, err) {\n  const errors = extractErrors(err).sort((error) => (error.semanticRelease ? -1 : 0));\n  for (const error of errors) {\n    if (error.semanticRelease) {\n      logger.error(`${error.code} ${error.message}`);\n      if (error.details) {\n        stderr.write(await terminalOutput(error.details)); // eslint-disable-line no-await-in-loop\n      }\n    } else {\n      logger.error('An error occurred while running semantic-release: %O', error);\n    }\n  }\n}\n\nasync function callFail(context, plugins, err) {\n  const errors = extractErrors(err).filter((err) => err.semanticRelease);\n  if (errors.length > 0) {\n    try {\n      await plugins.fail({...context, errors});\n    } catch (error) {\n      await logErrors(context, error);\n    }\n  }\n}\n\nmodule.exports = async (cliOptions = {}, {cwd = process.cwd(), env = process.env, stdout, stderr} = {}) => {\n  const {unhook} = hookStd(\n    {silent: false, streams: [process.stdout, process.stderr, stdout, stderr].filter(Boolean)},\n    hideSensitive(env)\n  );\n  const context = {\n    cwd,\n    env,\n    stdout: stdout || process.stdout,\n    stderr: stderr || process.stderr,\n    envCi: envCi({env, cwd}),\n  };\n  context.logger = getLogger(context);\n  context.logger.log(`Running ${pkg.name} version ${pkg.version}`);\n  try {\n    const {plugins, options} = await getConfig(context, cliOptions);\n    options.originalRepositoryURL = options.repositoryUrl;\n    context.options = options;\n    try {\n      const result = await run(context, plugins);\n      unhook();\n      return result;\n    } catch (error) {\n      await callFail(context, plugins, error);\n      throw error;\n    }\n  } catch (error) {\n    await logErrors(context, error);\n    unhook();\n    throw error;\n  }\n};\n", "const test = require('ava');\nconst {escapeRegExp, isString, sortBy, omit} = require('lodash');\nconst proxyquire = require('proxyquire');\nconst {spy, stub} = require('sinon');\nconst {WritableStreamBuffer} = require('stream-buffers');\nconst AggregateError = require('aggregate-error');\nconst SemanticReleaseError = require('@semantic-release/error');\nconst {COMMIT_NAME, COMMIT_EMAIL, SECRET_REPLACEMENT} = require('../lib/definitions/constants');\nconst {\n  gitHead: getGitHead,\n  gitCheckout,\n  gitTagHead,\n  gitRepo,\n  gitCommits,\n  gitTagVersion,\n  gitRemoteTagHead,\n  gitPush,\n  gitShallowClone,\n  merge,\n  mergeFf,\n  rebase,\n  gitAddNote,\n  gitGetNote,\n} = require('./helpers/git-utils');\n\nconst requireNoCache = proxyquire.noPreserveCache();\nconst pluginNoop = require.resolve('./fixtures/plugin-noop');\n\ntest.beforeEach((t) => {\n  // Stub the logger functions\n  t.context.log = spy();\n  t.context.error = spy();\n  t.context.success = spy();\n  t.context.warn = spy();\n  t.context.logger = {\n    log: t.context.log,\n    error: t.context.error,\n    success: t.context.success,\n    warn: t.context.warn,\n    scope: () => t.context.logger,\n  };\n});\n\ntest('Plugins are called with expected values', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  let commits = await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.0.0', {cwd});\n  commits = (await gitCommits(['Second'], {cwd})).concat(commits);\n  await gitCheckout('next', true, {cwd});\n  await gitPush(repositoryUrl, 'next', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const lastRelease = {\n    version: '1.0.0',\n    gitHead: commits[commits.length - 1].hash,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    channels: ['next'],\n  };\n  const nextRelease = {\n    name: 'v1.1.0',\n    type: 'minor',\n    version: '1.1.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v1.1.0',\n    channel: null,\n  };\n  const notes1 = 'Release notes 1';\n  const notes2 = 'Release notes 2';\n  const notes3 = 'Release notes 3';\n  const verifyConditions1 = stub().resolves();\n  const verifyConditions2 = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes1 = stub().resolves(notes1);\n  const generateNotes2 = stub().resolves(notes2);\n  const generateNotes3 = stub().resolves(notes3);\n  const release1 = {name: 'Release 1', url: 'https://release1.com'};\n  const release2 = {name: 'Release 2', url: 'https://release2.com'};\n  const addChannel = stub().resolves(release1);\n  const prepare = stub().resolves();\n  const publish = stub().resolves(release2);\n  const success = stub().resolves();\n  const env = {};\n  const config = {\n    branches: [{name: 'master'}, {name: 'next'}],\n    repositoryUrl,\n    originalRepositoryURL: repositoryUrl,\n    globalOpt: 'global',\n    tagFormat: `v\\${version}`,\n  };\n  const branches = [\n    {\n      channel: undefined,\n      name: 'master',\n      range: '>=1.0.0',\n      accept: ['patch', 'minor', 'major'],\n      tags: [{channels: ['next'], gitTag: 'v1.0.0', version: '1.0.0'}],\n      type: 'release',\n      main: true,\n    },\n    {\n      channel: 'next',\n      name: 'next',\n      range: '>=1.0.0',\n      accept: ['patch', 'minor', 'major'],\n      tags: [{channels: ['next'], gitTag: 'v1.0.0', version: '1.0.0'}],\n      type: 'release',\n      main: false,\n    },\n  ];\n  const branch = branches[0];\n  const options = {\n    ...config,\n    plugins: false,\n    verifyConditions: [verifyConditions1, verifyConditions2],\n    analyzeCommits,\n    verifyRelease,\n    addChannel,\n    generateNotes: [generateNotes1, generateNotes2, generateNotes3],\n    prepare,\n    publish: [publish, pluginNoop],\n    success,\n  };\n  const envCi = {branch: 'master', isCi: true, isPr: false};\n\n  const releases = [\n    {\n      ...omit(lastRelease, 'channels'),\n      ...release1,\n      type: 'major',\n      version: '1.0.0',\n      channel: null,\n      gitTag: 'v1.0.0',\n      notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`,\n      pluginName: '[Function: functionStub]',\n    },\n    {...nextRelease, ...release2, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`, pluginName: '[Function: functionStub]'},\n    {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`, pluginName: pluginNoop},\n  ];\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => envCi,\n  });\n  const result = await semanticRelease(options, {\n    cwd,\n    env,\n    stdout: new WritableStreamBuffer(),\n    stderr: new WritableStreamBuffer(),\n  });\n\n  t.is(verifyConditions1.callCount, 1);\n  t.deepEqual(verifyConditions1.args[0][0], config);\n  t.deepEqual(verifyConditions1.args[0][1].cwd, cwd);\n  t.deepEqual(verifyConditions1.args[0][1].options, options);\n  t.deepEqual(verifyConditions1.args[0][1].branch, branch);\n  t.deepEqual(verifyConditions1.args[0][1].branches, branches);\n  t.deepEqual(verifyConditions1.args[0][1].logger, t.context.logger);\n  t.deepEqual(verifyConditions1.args[0][1].envCi, envCi);\n  t.is(verifyConditions2.callCount, 1);\n  t.deepEqual(verifyConditions2.args[0][0], config);\n  t.deepEqual(verifyConditions2.args[0][1].cwd, cwd);\n  t.deepEqual(verifyConditions2.args[0][1].options, options);\n  t.deepEqual(verifyConditions2.args[0][1].branch, branch);\n  t.deepEqual(verifyConditions2.args[0][1].branches, branches);\n  t.deepEqual(verifyConditions2.args[0][1].logger, t.context.logger);\n  t.deepEqual(verifyConditions2.args[0][1].envCi, envCi);\n\n  t.is(generateNotes1.callCount, 2);\n  t.is(generateNotes2.callCount, 2);\n  t.is(generateNotes3.callCount, 2);\n\n  t.deepEqual(generateNotes1.args[0][0], config);\n  t.deepEqual(generateNotes1.args[0][1].options, options);\n  t.deepEqual(generateNotes1.args[0][1].branch, branch);\n  t.deepEqual(generateNotes1.args[0][1].branches, branches);\n  t.deepEqual(generateNotes1.args[0][1].logger, t.context.logger);\n  t.deepEqual(generateNotes1.args[0][1].lastRelease, {});\n  t.deepEqual(generateNotes1.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(generateNotes1.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(generateNotes1.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n  });\n  t.deepEqual(generateNotes2.args[0][1].envCi, envCi);\n\n  t.deepEqual(generateNotes2.args[0][0], config);\n  t.deepEqual(generateNotes2.args[0][1].options, options);\n  t.deepEqual(generateNotes2.args[0][1].branch, branch);\n  t.deepEqual(generateNotes2.args[0][1].branches, branches);\n  t.deepEqual(generateNotes2.args[0][1].logger, t.context.logger);\n  t.deepEqual(generateNotes2.args[0][1].lastRelease, {});\n  t.deepEqual(generateNotes2.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(generateNotes2.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(generateNotes2.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: notes1,\n  });\n  t.deepEqual(generateNotes2.args[0][1].envCi, envCi);\n\n  t.deepEqual(generateNotes3.args[0][0], config);\n  t.deepEqual(generateNotes3.args[0][1].options, options);\n  t.deepEqual(generateNotes3.args[0][1].branch, branch);\n  t.deepEqual(generateNotes3.args[0][1].branches, branches);\n  t.deepEqual(generateNotes3.args[0][1].logger, t.context.logger);\n  t.deepEqual(generateNotes3.args[0][1].lastRelease, {});\n  t.deepEqual(generateNotes3.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(generateNotes3.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(generateNotes3.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: `${notes1}\\n\\n${notes2}`,\n  });\n  t.deepEqual(generateNotes3.args[0][1].envCi, envCi);\n\n  branch.tags.push({\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    gitHead: commits[commits.length - 1].hash,\n  });\n\n  t.is(addChannel.callCount, 1);\n  t.deepEqual(addChannel.args[0][0], config);\n  t.deepEqual(addChannel.args[0][1].options, options);\n  t.deepEqual(addChannel.args[0][1].branch, branch);\n  t.deepEqual(addChannel.args[0][1].branches, branches);\n  t.deepEqual(addChannel.args[0][1].logger, t.context.logger);\n  t.deepEqual(addChannel.args[0][1].lastRelease, {});\n  t.deepEqual(addChannel.args[0][1].currentRelease, {...lastRelease, type: 'major'});\n  t.deepEqual(addChannel.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`,\n  });\n  t.deepEqual(addChannel.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(addChannel.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(addChannel.args[0][1].envCi, envCi);\n\n  t.is(analyzeCommits.callCount, 1);\n  t.deepEqual(analyzeCommits.args[0][0], config);\n  t.deepEqual(analyzeCommits.args[0][1].options, options);\n  t.deepEqual(analyzeCommits.args[0][1].branch, branch);\n  t.deepEqual(analyzeCommits.args[0][1].branches, branches);\n  t.deepEqual(analyzeCommits.args[0][1].logger, t.context.logger);\n  t.deepEqual(analyzeCommits.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(analyzeCommits.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(analyzeCommits.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(analyzeCommits.args[0][1].envCi, envCi);\n\n  t.is(verifyRelease.callCount, 1);\n  t.deepEqual(verifyRelease.args[0][0], config);\n  t.deepEqual(verifyRelease.args[0][1].options, options);\n  t.deepEqual(verifyRelease.args[0][1].branch, branch);\n  t.deepEqual(verifyRelease.args[0][1].branches, branches);\n  t.deepEqual(verifyRelease.args[0][1].logger, t.context.logger);\n  t.deepEqual(verifyRelease.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(verifyRelease.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(verifyRelease.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(verifyRelease.args[0][1].nextRelease, nextRelease);\n  t.deepEqual(verifyRelease.args[0][1].envCi, envCi);\n\n  t.deepEqual(generateNotes1.args[1][0], config);\n  t.deepEqual(generateNotes1.args[1][1].options, options);\n  t.deepEqual(generateNotes1.args[1][1].branch, branch);\n  t.deepEqual(generateNotes1.args[1][1].branches, branches);\n  t.deepEqual(generateNotes1.args[1][1].logger, t.context.logger);\n  t.deepEqual(generateNotes1.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(generateNotes1.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(generateNotes1.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(generateNotes1.args[1][1].nextRelease, nextRelease);\n  t.deepEqual(generateNotes1.args[1][1].envCi, envCi);\n\n  t.deepEqual(generateNotes2.args[1][0], config);\n  t.deepEqual(generateNotes2.args[1][1].options, options);\n  t.deepEqual(generateNotes2.args[1][1].branch, branch);\n  t.deepEqual(generateNotes2.args[1][1].branches, branches);\n  t.deepEqual(generateNotes2.args[1][1].logger, t.context.logger);\n  t.deepEqual(generateNotes2.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(generateNotes2.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(generateNotes2.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(generateNotes2.args[1][1].nextRelease, {...nextRelease, notes: notes1});\n  t.deepEqual(generateNotes2.args[1][1].envCi, envCi);\n\n  t.deepEqual(generateNotes3.args[1][0], config);\n  t.deepEqual(generateNotes3.args[1][1].options, options);\n  t.deepEqual(generateNotes3.args[1][1].branch, branch);\n  t.deepEqual(generateNotes3.args[1][1].branches, branches);\n  t.deepEqual(generateNotes3.args[1][1].logger, t.context.logger);\n  t.deepEqual(generateNotes3.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(generateNotes3.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(generateNotes3.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(generateNotes3.args[1][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}`});\n  t.deepEqual(generateNotes3.args[1][1].envCi, envCi);\n\n  t.is(prepare.callCount, 1);\n  t.deepEqual(prepare.args[0][0], config);\n  t.deepEqual(prepare.args[0][1].options, options);\n  t.deepEqual(prepare.args[0][1].branch, branch);\n  t.deepEqual(prepare.args[0][1].branches, branches);\n  t.deepEqual(prepare.args[0][1].logger, t.context.logger);\n  t.deepEqual(prepare.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(prepare.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(prepare.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(prepare.args[0][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`});\n  t.deepEqual(prepare.args[0][1].envCi, envCi);\n\n  t.is(publish.callCount, 1);\n  t.deepEqual(publish.args[0][0], config);\n  t.deepEqual(publish.args[0][1].options, options);\n  t.deepEqual(publish.args[0][1].branch, branch);\n  t.deepEqual(publish.args[0][1].branches, branches);\n  t.deepEqual(publish.args[0][1].logger, t.context.logger);\n  t.deepEqual(publish.args[0][1].lastRelease, lastRelease);\n  t.deepEqual(publish.args[0][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(publish.args[0][1].commits[0].message, commits[0].message);\n  t.deepEqual(publish.args[0][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`});\n  t.deepEqual(publish.args[0][1].envCi, envCi);\n\n  t.is(success.callCount, 2);\n  t.deepEqual(success.args[0][0], config);\n  t.deepEqual(success.args[0][1].options, options);\n  t.deepEqual(success.args[0][1].branch, branch);\n  t.deepEqual(success.args[0][1].branches, branches);\n  t.deepEqual(success.args[0][1].logger, t.context.logger);\n  t.deepEqual(success.args[0][1].lastRelease, {});\n  t.deepEqual(success.args[0][1].commits[0].hash, commits[1].hash);\n  t.deepEqual(success.args[0][1].commits[0].message, commits[1].message);\n  t.deepEqual(success.args[0][1].nextRelease, {\n    ...omit(lastRelease, 'channels'),\n    type: 'major',\n    version: '1.0.0',\n    channel: null,\n    gitTag: 'v1.0.0',\n    name: 'v1.0.0',\n    notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`,\n  });\n  t.deepEqual(success.args[0][1].releases, [releases[0]]);\n  t.deepEqual(success.args[0][1].envCi, envCi);\n\n  t.deepEqual(success.args[1][0], config);\n  t.deepEqual(success.args[1][1].options, options);\n  t.deepEqual(success.args[1][1].branch, branch);\n  t.deepEqual(success.args[1][1].branches, branches);\n  t.deepEqual(success.args[1][1].logger, t.context.logger);\n  t.deepEqual(success.args[1][1].lastRelease, lastRelease);\n  t.deepEqual(success.args[1][1].commits[0].hash, commits[0].hash);\n  t.deepEqual(success.args[1][1].commits[0].message, commits[0].message);\n  t.deepEqual(success.args[1][1].nextRelease, {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`});\n  t.deepEqual(success.args[1][1].releases, [releases[1], releases[2]]);\n  t.deepEqual(success.args[1][1].envCi, envCi);\n\n  t.deepEqual(result, {\n    lastRelease,\n    commits: [{...commits[0], gitTags: '(HEAD -> master, next)'}],\n    nextRelease: {...nextRelease, notes: `${notes1}\\n\\n${notes2}\\n\\n${notes3}`},\n    releases,\n  });\n\n  // Verify the tag has been created on the local and remote repo and reference the gitHead\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n\n  // Verify the author/commiter name and email have been set\n  t.is(env.GIT_AUTHOR_NAME, COMMIT_NAME);\n  t.is(env.GIT_AUTHOR_EMAIL, COMMIT_EMAIL);\n  t.is(env.GIT_COMMITTER_NAME, COMMIT_NAME);\n  t.is(env.GIT_COMMITTER_EMAIL, COMMIT_EMAIL);\n});\n\ntest('Use custom tag format', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('test-1.0.0', undefined, {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'test-2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'test-2.0.0',\n  };\n  const notes = 'Release notes';\n  const config = {branches: 'master', repositoryUrl, globalOpt: 'global', tagFormat: `test-\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves(nextRelease.type),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(notes),\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  // Verify the tag has been created on the local and remote repo and reference the gitHead\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n});\n\ntest('Use new gitHead, and recreate release notes if a prepare plugin create a commit', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  let commits = await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  commits = (await gitCommits(['Second'], {cwd})).concat(commits);\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: null,\n  };\n  const notes = 'Release notes';\n\n  const generateNotes = stub().resolves(notes);\n  const prepare1 = stub().callsFake(async () => {\n    commits = (await gitCommits(['Third'], {cwd})).concat(commits);\n  });\n  const prepare2 = stub().resolves();\n  const publish = stub().resolves();\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves(nextRelease.type),\n    verifyRelease: stub().resolves(),\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: [prepare1, prepare2],\n    publish,\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.is(generateNotes.callCount, 2);\n  t.deepEqual(generateNotes.args[0][1].nextRelease, nextRelease);\n  t.is(prepare1.callCount, 1);\n  t.deepEqual(prepare1.args[0][1].nextRelease, {...nextRelease, notes});\n\n  nextRelease.gitHead = await getGitHead({cwd});\n\n  t.deepEqual(generateNotes.args[1][1].nextRelease, {...nextRelease, notes});\n  t.is(prepare2.callCount, 1);\n  t.deepEqual(prepare2.args[0][1].nextRelease, {...nextRelease, notes});\n\n  t.is(publish.callCount, 1);\n  t.deepEqual(publish.args[0][1].nextRelease, {...nextRelease, notes});\n\n  // Verify the tag has been created on the local and remote repo and reference the last gitHead\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), commits[0].hash);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), commits[0].hash);\n});\n\ntest('Make a new release when a commit is forward-ported to an upper branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.0.x']}), 'v1.0.0', {cwd});\n  await gitCheckout('1.0.x', true, {cwd});\n  await gitCommits(['fix: fix on maintenance version 1.0.x'], {cwd});\n  await gitTagVersion('v1.0.1', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['1.0.x']}), 'v1.0.1', {cwd});\n  await gitPush('origin', '1.0.x', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['feat: new feature on master'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await merge('1.0.x', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {branches: [{name: '1.0.x'}, {name: 'master'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}}));\n\n  t.is(addChannel.callCount, 0);\n  t.is(publish.callCount, 1);\n  // The release 1.1.1, triggered by the forward-port of \"fix: fix on maintenance version 1.0.x\" has been published from master\n  t.is(publish.args[0][1].nextRelease.version, '1.1.1');\n  t.is(success.callCount, 1);\n});\n\ntest('Publish a pre-release version', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('beta', true, {cwd});\n  await gitCommits(['feat: a feature'], {cwd});\n  await gitPush(repositoryUrl, 'beta', {cwd});\n\n  const config = {branches: ['master', {name: 'beta', prerelease: true}], repositoryUrl};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(''),\n    addChannel: false,\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'beta', isPr: false}),\n  });\n  let {releases} = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.1');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.1');\n  t.is(await gitGetNote('v1.1.0-beta.1', {cwd}), '{\"channels\":[\"beta\"]}');\n\n  await gitCommits(['fix: a fix'], {cwd});\n  ({releases} = await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: {write: () => {}},\n    stderr: {write: () => {}},\n  }));\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.2');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.2');\n  t.is(await gitGetNote('v1.1.0-beta.2', {cwd}), '{\"channels\":[\"beta\"]}');\n});\n\ntest('Publish releases from different branch on the same channel', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('next-major', true, {cwd});\n  await gitPush(repositoryUrl, 'next-major', {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitCommits(['feat: a feature'], {cwd});\n  await gitPush(repositoryUrl, 'next', {cwd});\n\n  const config = {\n    branches: ['master', {name: 'next', channel: false}, {name: 'next-major', channel: false}],\n    repositoryUrl,\n  };\n  const addChannel = stub().resolves({});\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(''),\n    addChannel,\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  let semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'next', isPr: false}),\n  });\n  let {releases} = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0');\n  t.is(releases[0].gitTag, 'v1.1.0');\n\n  await gitCommits(['fix: a fix'], {cwd});\n  ({releases} = await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: {write: () => {}},\n    stderr: {write: () => {}},\n  }));\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.1');\n  t.is(releases[0].gitTag, 'v1.1.1');\n\n  await gitCheckout('master', false, {cwd});\n  await merge('next', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.falsy(await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}}));\n  t.is(addChannel.callCount, 0);\n});\n\ntest('Publish pre-releases the same channel as regular releases', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('beta', true, {cwd});\n  await gitCommits(['feat: a feature'], {cwd});\n  await gitPush(repositoryUrl, 'beta', {cwd});\n\n  const config = {\n    branches: ['master', {name: 'beta', channel: false, prerelease: true}],\n    repositoryUrl,\n  };\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(''),\n    addChannel: false,\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'beta', isPr: false}),\n  });\n  let {releases} = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.1');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.1');\n\n  await gitCommits(['fix: a fix'], {cwd});\n  ({releases} = await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: {write: () => {}},\n    stderr: {write: () => {}},\n  }));\n\n  t.is(releases.length, 1);\n  t.is(releases[0].version, '1.1.0-beta.2');\n  t.is(releases[0].gitTag, 'v1.1.0-beta.2');\n});\n\ntest('Do not add pre-releases to a different channel', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'beta']}), 'v1.0.0', {cwd});\n  await gitCheckout('beta', true, {cwd});\n  await gitCommits(['feat: breaking change/n/nBREAKING CHANGE: break something'], {cwd});\n  await gitTagVersion('v2.0.0-beta.1', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['beta']}), 'v2.0.0-beta.1', {cwd});\n  await gitCommits(['fix: a fix'], {cwd});\n  await gitTagVersion('v2.0.0-beta.2', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['beta']}), 'v2.0.0-beta.2', {cwd});\n  await gitPush('origin', 'beta', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await merge('beta', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves('Release notes');\n  const release1 = {name: 'Release 1', url: 'https://release1.com'};\n  const addChannel = stub().resolves(release1);\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [{name: 'master'}, {name: 'beta', prerelease: 'beta'}],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    generateNotes,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}}));\n\n  t.is(addChannel.callCount, 0);\n});\n\nasync function addChannelMacro(t, mergeFunction) {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const commits = await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'next']}), 'v1.0.0', {cwd});\n  await gitCheckout('next', true, {cwd});\n  commits.push(...(await gitCommits(['feat: breaking change/n/nBREAKING CHANGE: break something'], {cwd})));\n  await gitTagVersion('v2.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v2.0.0', {cwd});\n\n  commits.push(...(await gitCommits(['fix: a fix'], {cwd})));\n  await gitTagVersion('v2.0.1', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v2.0.1', {cwd});\n  commits.push(...(await gitCommits(['feat: a feature'], {cwd})));\n  await gitTagVersion('v2.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v2.1.0', {cwd});\n  await gitPush('origin', 'next', {cwd});\n  await gitCheckout('master', false, {cwd});\n  // Merge all commits but last one from next to master\n  await mergeFunction('next~1', {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const notes = 'Release notes';\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const release1 = {name: 'Release 1', url: 'https://release1.com'};\n  const addChannel1 = stub().resolves(release1);\n  const addChannel2 = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [\n      {name: 'master', channel: 'latest'},\n      {name: 'next', channel: 'next'},\n    ],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel: [addChannel1, addChannel2],\n    generateNotes,\n    prepare,\n    publish,\n    success,\n  };\n  const nextRelease = {\n    name: 'v2.0.1',\n    type: 'patch',\n    version: '2.0.1',\n    channel: 'latest',\n    gitTag: 'v2.0.1',\n    gitHead: commits[2].hash,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const result = await semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}});\n\n  t.deepEqual(result.releases, [\n    {...nextRelease, ...release1, notes, pluginName: '[Function: functionStub]'},\n    {...nextRelease, notes, pluginName: '[Function: functionStub]'},\n  ]);\n\n  // Verify the tag has been created on the local and remote repo and reference\n  t.is(await gitTagHead(nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n  t.is(await gitRemoteTagHead(repositoryUrl, nextRelease.gitTag, {cwd}), nextRelease.gitHead);\n}\n\naddChannelMacro.title = (providedTitle) => `Add version to a channel after a merge (${providedTitle})`;\n\ntest('fast-forward', addChannelMacro, mergeFf);\ntest('non fast-forward', addChannelMacro, merge);\ntest('rebase', addChannelMacro, rebase);\n\ntest('Call all \"success\" plugins even if one errors out', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: null,\n  };\n  const notes = 'Release notes';\n  const verifyConditions1 = stub().resolves();\n  const verifyConditions2 = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const generateNotes = stub().resolves(notes);\n  const release = {name: 'Release', url: 'https://release.com'};\n  const publish = stub().resolves(release);\n  const success1 = stub().rejects();\n  const success2 = stub().resolves();\n  const config = {\n    branches: [{name: 'master'}],\n    repositoryUrl,\n    globalOpt: 'global',\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions: [verifyConditions1, verifyConditions2],\n    analyzeCommits,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success: [success1, success2],\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  t.is(success1.callCount, 1);\n  t.deepEqual(success1.args[0][0], config);\n  t.deepEqual(success1.args[0][1].releases, [\n    {...nextRelease, ...release, notes, pluginName: '[Function: functionStub]'},\n  ]);\n\n  t.is(success2.callCount, 1);\n  t.deepEqual(success2.args[0][1].releases, [\n    {...nextRelease, ...release, notes, pluginName: '[Function: functionStub]'},\n  ]);\n});\n\ntest('Log all \"verifyConditions\" errors', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const error1 = new Error('error 1');\n  const error2 = new SemanticReleaseError('error 2', 'ERR2');\n  const error3 = new SemanticReleaseError('error 3', 'ERR3');\n  const fail = stub().resolves();\n  const config = {\n    branches: [{name: 'master'}],\n    repositoryUrl,\n    originalRepositoryURL: repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    plugins: false,\n    verifyConditions: [stub().rejects(new AggregateError([error1, error2])), stub().rejects(error3)],\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  t.deepEqual(sortBy(errors, ['message']), sortBy([error1, error2, error3], ['message']));\n  t.true(t.context.error.calledWith('An error occurred while running semantic-release: %O', error1));\n  t.true(t.context.error.calledWith('ERR2 error 2'));\n  t.true(t.context.error.calledWith('ERR3 error 3'));\n  t.true(t.context.error.calledAfter(t.context.log));\n  t.is(fail.callCount, 1);\n  t.deepEqual(fail.args[0][0], config);\n  t.deepEqual(fail.args[0][1].options, options);\n  t.deepEqual(fail.args[0][1].logger, t.context.logger);\n  t.deepEqual(fail.args[0][1].errors, [error2, error3]);\n});\n\ntest('Log all \"verifyRelease\" errors', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const error1 = new SemanticReleaseError('error 1', 'ERR1');\n  const error2 = new SemanticReleaseError('error 2', 'ERR2');\n  const fail = stub().resolves();\n  const config = {branches: [{name: 'master'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves('major'),\n    verifyRelease: [stub().rejects(error1), stub().rejects(error2)],\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  t.deepEqual(sortBy(errors, ['message']), sortBy([error1, error2], ['message']));\n  t.true(t.context.error.calledWith('ERR1 error 1'));\n  t.true(t.context.error.calledWith('ERR2 error 2'));\n  t.is(fail.callCount, 1);\n  t.deepEqual(fail.args[0][0], config);\n  t.deepEqual(fail.args[0][1].errors, [error1, error2]);\n});\n\ntest('Dry-run skips addChannel, prepare, publish and success', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'next']}), 'v1.0.0', {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.1.0', {cwd});\n\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitPush('origin', 'next', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves('minor');\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const options = {\n    dryRun: true,\n    branches: ['master', 'next'],\n    repositoryUrl,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.not(t.context.warn.args[0][0], 'This run was not triggered in a known CI environment, running in dry-run mode.');\n  t.is(verifyConditions.callCount, 1);\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes.callCount, 2);\n  t.is(addChannel.callCount, 0);\n  t.true(\n    t.context.warn.calledWith(`Skip step \"addChannel\" of plugin \"[Function: ${addChannel.name}]\" in dry-run mode`)\n  );\n  t.is(prepare.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"prepare\" of plugin \"[Function: ${prepare.name}]\" in dry-run mode`));\n  t.is(publish.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"publish\" of plugin \"[Function: ${publish.name}]\" in dry-run mode`));\n  t.is(success.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"success\" of plugin \"[Function: ${success.name}]\" in dry-run mode`));\n});\n\ntest('Dry-run skips fail', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const error1 = new SemanticReleaseError('error 1', 'ERR1');\n  const error2 = new SemanticReleaseError('error 2', 'ERR2');\n  const fail = stub().resolves();\n\n  const options = {\n    dryRun: true,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: [stub().rejects(error1), stub().rejects(error2)],\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  t.deepEqual(sortBy(errors, ['message']), sortBy([error1, error2], ['message']));\n  t.true(t.context.error.calledWith('ERR1 error 1'));\n  t.true(t.context.error.calledWith('ERR2 error 2'));\n  t.is(fail.callCount, 0);\n  t.true(t.context.warn.calledWith(`Skip step \"fail\" of plugin \"[Function: ${fail.name}]\" in dry-run mode`));\n});\n\ntest('Force a dry-run if not on a CI and \"noCi\" is not explicitly set', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: undefined,\n  };\n  const notes = 'Release notes';\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const options = {\n    dryRun: false,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: false, branch: 'master'}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.true(t.context.warn.calledWith('This run was not triggered in a known CI environment, running in dry-run mode.'));\n  t.is(verifyConditions.callCount, 1);\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes.callCount, 1);\n  t.is(publish.callCount, 0);\n  t.is(success.callCount, 0);\n});\n\ntest('Dry-run does not print changelog if \"generateNotes\" return \"undefined\"', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {type: 'major', version: '2.0.0', gitHead: await getGitHead({cwd}), gitTag: 'v2.0.0'};\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const generateNotes = stub().resolves();\n\n  const options = {\n    dryRun: true,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: false,\n    analyzeCommits,\n    verifyRelease: false,\n    generateNotes,\n    prepare: false,\n    publish: false,\n    success: false,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.deepEqual(t.context.log.args[t.context.log.args.length - 1], ['Release note for version 2.0.0:']);\n});\n\ntest('Allow local releases with \"noCi\" option', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: undefined,\n  };\n  const notes = 'Release notes';\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const options = {\n    noCi: true,\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: false, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.not(t.context.log.args[0][0], 'This run was not triggered in a known CI environment, running in dry-run mode.');\n  t.not(\n    t.context.log.args[0][0],\n    \"This run was triggered by a pull request and therefore a new version won't be published.\"\n  );\n  t.is(verifyConditions.callCount, 1);\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes.callCount, 1);\n  t.is(publish.callCount, 1);\n  t.is(success.callCount, 1);\n});\n\ntest('Accept \"undefined\" value returned by \"generateNotes\" and \"false\" by \"publish\" and \"addChannel\"', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, 'next']}), 'v1.0.0', {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.1.0', {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitPush('origin', 'next', {cwd});\n  await gitCheckout('master', false, {cwd});\n\n  const nextRelease = {\n    name: 'v1.2.0',\n    type: 'minor',\n    version: '1.2.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v1.2.0',\n    channel: null,\n  };\n  const analyzeCommits = stub().resolves(nextRelease.type);\n  const verifyRelease = stub().resolves();\n  const generateNotes1 = stub().resolves();\n  const notes2 = 'Release notes 2';\n  const generateNotes2 = stub().resolves(notes2);\n  const publish = stub().resolves(false);\n  const addChannel = stub().resolves(false);\n  const success = stub().resolves();\n\n  const options = {\n    branches: ['master', 'next'],\n    repositoryUrl,\n    verifyConditions: stub().resolves(),\n    analyzeCommits,\n    verifyRelease,\n    generateNotes: [generateNotes1, generateNotes2],\n    addChannel,\n    prepare: stub().resolves(),\n    publish,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 1);\n  t.is(generateNotes1.callCount, 2);\n  t.is(generateNotes2.callCount, 2);\n  t.is(addChannel.callCount, 1);\n  t.is(publish.callCount, 1);\n  t.is(success.callCount, 2);\n  t.deepEqual(publish.args[0][1].nextRelease, {...nextRelease, notes: notes2});\n  t.deepEqual(success.args[0][1].releases, [{pluginName: '[Function: functionStub]'}]);\n  t.deepEqual(success.args[1][1].releases, [{pluginName: '[Function: functionStub]'}]);\n});\n\ntest('Returns false if triggered by a PR', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', prBranch: 'patch-1', isPr: true}),\n  });\n\n  t.false(\n    await semanticRelease(\n      {cwd, repositoryUrl},\n      {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()}\n    )\n  );\n  t.is(\n    t.context.log.args[t.context.log.args.length - 1][0],\n    \"This run was triggered by a pull request and therefore a new version won't be published.\"\n  );\n});\n\ntest('Throws \"EINVALIDNEXTVERSION\" if next release is out of range of the current maintenance branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.x']}), 'v1.0.0', {cwd});\n  await gitCheckout('1.x', true, {cwd});\n  await gitPush('origin', '1.x', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['feat: new feature on master'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitCheckout('1.x', false, {cwd});\n  await gitCommits(['feat: feature on maintenance version 1.x'], {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [{name: '1.x'}, {name: 'master'}],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: '1.x', isPr: false}),\n  });\n\n  const error = await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}})\n  );\n\n  t.is(error.code, 'EINVALIDNEXTVERSION');\n  t.is(error.name, 'SemanticReleaseError');\n  t.is(error.message, 'The release `1.1.0` on branch `1.x` cannot be published as it is out of range.');\n  t.regex(error.details, /A valid branch could be `master`./);\n});\n\ntest('Throws \"EINVALIDNEXTVERSION\" if next release is out of range of the current release branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial commit'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitCheckout('next', true, {cwd});\n  await gitCommits(['feat: new feature on next'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: ['next']}), 'v1.1.0', {cwd});\n  await gitPush('origin', 'next', {cwd});\n  await gitCheckout('next-major', true, {cwd});\n  await gitPush('origin', 'next-major', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['feat: new feature on master', 'fix: new fix on master'], {cwd});\n  await gitPush('origin', 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n\n  const config = {\n    branches: [{name: 'master'}, {name: 'next'}, {name: 'next-major'}],\n    repositoryUrl,\n    tagFormat: `v\\${version}`,\n  };\n  const options = {\n    ...config,\n    verifyConditions,\n    verifyRelease,\n    addChannel,\n    prepare,\n    publish,\n    success,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  const error = await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}})\n  );\n\n  t.is(error.code, 'EINVALIDNEXTVERSION');\n  t.is(error.name, 'SemanticReleaseError');\n  t.is(error.message, 'The release `1.1.0` on branch `master` cannot be published as it is out of range.');\n  t.regex(error.details, /A valid branch could be `next` or `next-major`./);\n});\n\ntest('Throws \"EINVALIDMAINTENANCEMERGE\" if merge an out of range release in a maintenance branch', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['First'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.1.x']}), 'v1.0.0', {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitTagVersion('v1.1.0', undefined, {cwd});\n  await gitAddNote(JSON.stringify({channels: [null, '1.1.x']}), 'v1.1.0', {cwd});\n  await gitCheckout('1.1.x', 'master', {cwd});\n  await gitPush('origin', '1.1.x', {cwd});\n  await gitCheckout('master', false, {cwd});\n  await gitCommits(['Third'], {cwd});\n  await gitTagVersion('v1.1.1', undefined, {cwd});\n  await gitCommits(['Fourth'], {cwd});\n  await gitTagVersion('v1.2.0', undefined, {cwd});\n  await gitPush('origin', 'master', {cwd});\n  await gitCheckout('1.1.x', false, {cwd});\n  await merge('master', {cwd});\n  await gitPush('origin', '1.1.x', {cwd});\n\n  const notes = 'Release notes';\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves(notes);\n  const addChannel = stub().resolves();\n  const prepare = stub().resolves();\n  const publish = stub().resolves();\n  const success = stub().resolves();\n  const fail = stub().resolves();\n\n  const config = {branches: [{name: 'master'}, {name: '1.1.x'}], repositoryUrl, tagFormat: `v\\${version}`};\n  const options = {\n    ...config,\n    verifyConditions,\n    analyzeCommits,\n    verifyRelease,\n    addChannel,\n    generateNotes,\n    prepare,\n    publish,\n    success,\n    fail,\n  };\n\n  const semanticRelease = proxyquire('..', {\n    './lib/logger': t.context.logger,\n    'env-ci': () => ({isCi: true, branch: '1.1.x', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease(options, {cwd, env: {}, stdout: {write: () => {}}, stderr: {write: () => {}}})\n    )),\n  ];\n\n  t.is(addChannel.callCount, 0);\n\n  t.is(publish.callCount, 0);\n\n  t.is(success.callCount, 0);\n\n  t.is(fail.callCount, 1);\n  t.deepEqual(fail.args[0][1].errors, errors);\n\n  t.is(errors[0].code, 'EINVALIDMAINTENANCEMERGE');\n  t.is(errors[0].name, 'SemanticReleaseError');\n  t.truthy(errors[0].message);\n  t.truthy(errors[0].details);\n});\n\ntest('Returns false value if triggered on an outdated clone', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  let {cwd, repositoryUrl} = await gitRepo(true);\n  const repoDir = cwd;\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n  cwd = await gitShallowClone(repositoryUrl);\n  await gitCommits(['Third'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.false(\n    await semanticRelease(\n      {repositoryUrl},\n      {cwd: repoDir, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()}\n    )\n  );\n  t.deepEqual(t.context.log.args[t.context.log.args.length - 1], [\n    \"The local branch master is behind the remote one, therefore a new version won't be published.\",\n  ]);\n});\n\ntest('Returns false if not running from the configured branch', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().resolves(),\n    analyzeCommits: stub().resolves(),\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(),\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'other-branch', isPr: false}),\n  });\n\n  t.false(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n  t.is(\n    t.context.log.args[1][0],\n    'This test run was triggered on the branch other-branch, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.'\n  );\n});\n\ntest('Returns false if there is no relevant changes', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const analyzeCommits = stub().resolves();\n  const verifyRelease = stub().resolves();\n  const generateNotes = stub().resolves();\n  const publish = stub().resolves();\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: [stub().resolves()],\n    analyzeCommits,\n    verifyRelease,\n    generateNotes,\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish,\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  t.false(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n  t.is(analyzeCommits.callCount, 1);\n  t.is(verifyRelease.callCount, 0);\n  t.is(generateNotes.callCount, 0);\n  t.is(publish.callCount, 0);\n  t.is(\n    t.context.log.args[t.context.log.args.length - 1][0],\n    'There are no relevant changes, so no new version is released.'\n  );\n});\n\ntest('Exclude commits with [skip release] or [release skip] from analysis', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  const commits = await gitCommits(\n    [\n      'Test commit',\n      'Test commit [skip release]',\n      'Test commit [release skip]',\n      'Test commit [Release Skip]',\n      'Test commit [Skip Release]',\n      'Test commit [skip    release]',\n      'Test commit\\n\\n commit body\\n[skip release]',\n      'Test commit\\n\\n commit body\\n[release skip]',\n    ],\n    {cwd}\n  );\n  await gitPush(repositoryUrl, 'master', {cwd});\n  const analyzeCommits = stub().resolves();\n  const config = {branches: ['master'], repositoryUrl, globalOpt: 'global'};\n  const options = {\n    ...config,\n    verifyConditions: [stub().resolves(), stub().resolves()],\n    analyzeCommits,\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(),\n    addChannel: stub().resolves(),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  await semanticRelease(options, {\n    cwd,\n    env: {},\n    stdout: new WritableStreamBuffer(),\n    stderr: new WritableStreamBuffer(),\n  });\n\n  t.is(analyzeCommits.callCount, 1);\n  t.is(analyzeCommits.args[0][1].commits.length, 2);\n  t.deepEqual(analyzeCommits.args[0][1].commits[0], commits[commits.length - 1]);\n});\n\ntest('Log both plugins errors and errors thrown by \"fail\" plugin', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const pluginError = new SemanticReleaseError('Plugin error', 'ERR');\n  const failError1 = new Error('Fail error 1');\n  const failError2 = new Error('Fail error 2');\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().rejects(pluginError),\n    fail: [stub().rejects(failError1), stub().rejects(failError2)],\n  };\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  t.is(t.context.error.args[t.context.error.args.length - 1][0], 'ERR Plugin error');\n  t.is(t.context.error.args[t.context.error.args.length - 3][1], failError1);\n  t.is(t.context.error.args[t.context.error.args.length - 2][1], failError2);\n});\n\ntest('Call \"fail\" only if a plugin returns a SemanticReleaseError', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  const pluginError = new Error('Plugin error');\n  const fail = stub().resolves();\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: stub().rejects(pluginError),\n    fail,\n  };\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  t.true(fail.notCalled);\n  t.is(t.context.error.args[t.context.error.args.length - 1][1], pluginError);\n});\n\ntest('Throw SemanticReleaseError if repositoryUrl is not set and cannot be found from repo config', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd} = await gitRepo();\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const errors = [\n    ...(await t.throwsAsync(\n      semanticRelease({}, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n    )),\n  ];\n\n  // Verify error code and type\n  t.is(errors[0].code, 'ENOREPOURL');\n  t.is(errors[0].name, 'SemanticReleaseError');\n  t.truthy(errors[0].message);\n  t.truthy(errors[0].details);\n});\n\ntest('Throw an Error if plugin returns an unexpected value', async (t) => {\n  // Create a git repository, set the current working directory at the root of the repo\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  // Add commits to the master branch\n  await gitCommits(['First'], {cwd});\n  // Create the tag corresponding to version 1.0.0\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  // Add new commits to the master branch\n  await gitCommits(['Second'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const verifyConditions = stub().resolves();\n  const analyzeCommits = stub().resolves('string');\n\n  const options = {\n    branches: ['master'],\n    repositoryUrl,\n    verifyConditions: [verifyConditions],\n    analyzeCommits,\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  const error = await t.throwsAsync(\n    semanticRelease(options, {cwd, env: {}, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()}),\n    {instanceOf: SemanticReleaseError}\n  );\n  t.regex(error.details, /string/);\n});\n\ntest('Hide sensitive information passed to \"fail\" plugin', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n\n  const fail = stub().resolves();\n  const env = {MY_TOKEN: 'secret token'};\n  const options = {\n    branch: 'master',\n    repositoryUrl,\n    verifyConditions: stub().throws(\n      new SemanticReleaseError(\n        `Message: Exposing token ${env.MY_TOKEN}`,\n        'ERR',\n        `Details: Exposing token ${env.MY_TOKEN}`\n      )\n    ),\n    success: stub().resolves(),\n    fail,\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  await t.throwsAsync(\n    semanticRelease(options, {cwd, env, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()})\n  );\n\n  const error = fail.args[0][1].errors[0];\n\n  t.is(error.message, `Message: Exposing token ${SECRET_REPLACEMENT}`);\n  t.is(error.details, `Details: Exposing token ${SECRET_REPLACEMENT}`);\n\n  Object.getOwnPropertyNames(error).forEach((prop) => {\n    if (isString(error[prop])) {\n      t.notRegex(error[prop], new RegExp(escapeRegExp(env.MY_TOKEN)));\n    }\n  });\n});\n\ntest('Hide sensitive information passed to \"success\" plugin', async (t) => {\n  const {cwd, repositoryUrl} = await gitRepo(true);\n  await gitCommits(['feat: initial release'], {cwd});\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitCommits(['feat: new feature'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  const success = stub().resolves();\n  const env = {MY_TOKEN: 'secret token'};\n  const options = {\n    branch: 'master',\n    repositoryUrl,\n    verifyConditions: false,\n    verifyRelease: false,\n    prepare: false,\n    generateNotes: stub().resolves(`Exposing token ${env.MY_TOKEN}`),\n    publish: stub().resolves({\n      name: `Name: Exposing token ${env.MY_TOKEN}`,\n      url: `URL: Exposing token ${env.MY_TOKEN}`,\n    }),\n    addChannel: false,\n    success,\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  await semanticRelease(options, {cwd, env, stdout: new WritableStreamBuffer(), stderr: new WritableStreamBuffer()});\n\n  const release = success.args[0][1].releases[0];\n\n  t.is(release.name, `Name: Exposing token ${SECRET_REPLACEMENT}`);\n  t.is(release.url, `URL: Exposing token ${SECRET_REPLACEMENT}`);\n\n  Object.getOwnPropertyNames(release).forEach((prop) => {\n    if (isString(release[prop])) {\n      t.notRegex(release[prop], new RegExp(escapeRegExp(env.MY_TOKEN)));\n    }\n  });\n});\n\ntest('Get all commits including the ones not in the shallow clone', async (t) => {\n  let {cwd, repositoryUrl} = await gitRepo(true);\n  await gitTagVersion('v1.0.0', undefined, {cwd});\n  await gitCommits(['First', 'Second', 'Third'], {cwd});\n  await gitPush(repositoryUrl, 'master', {cwd});\n\n  cwd = await gitShallowClone(repositoryUrl);\n\n  const nextRelease = {\n    name: 'v2.0.0',\n    type: 'major',\n    version: '2.0.0',\n    gitHead: await getGitHead({cwd}),\n    gitTag: 'v2.0.0',\n    channel: undefined,\n  };\n  const notes = 'Release notes';\n  const analyzeCommits = stub().resolves(nextRelease.type);\n\n  const config = {branches: ['master'], repositoryUrl, globalOpt: 'global'};\n  const options = {\n    ...config,\n    verifyConditions: stub().resolves(),\n    analyzeCommits,\n    verifyRelease: stub().resolves(),\n    generateNotes: stub().resolves(notes),\n    prepare: stub().resolves(),\n    publish: stub().resolves(),\n    success: stub().resolves(),\n    fail: stub().resolves(),\n  };\n\n  const semanticRelease = requireNoCache('..', {\n    './lib/get-logger': () => t.context.logger,\n    'env-ci': () => ({isCi: true, branch: 'master', isPr: false}),\n  });\n  t.truthy(\n    await semanticRelease(options, {\n      cwd,\n      env: {},\n      stdout: new WritableStreamBuffer(),\n      stderr: new WritableStreamBuffer(),\n    })\n  );\n\n  t.is(analyzeCommits.args[0][1].commits.length, 3);\n});\n"], "filenames": ["index.js", "test/index.test.js"], "buggy_code_start_loc": [78, 92], "buggy_code_end_loc": [265, 931], "fixing_code_start_loc": [78, 93], "fixing_code_end_loc": [267, 937], "type": "CWE-200", "message": "semantic-release is an open source npm package for automated version management and package publishing. In affected versions secrets that would normally be masked by semantic-release can be accidentally disclosed if they contain characters that are excluded from uri encoding by `encodeURI`. Occurrence is further limited to execution contexts where push access to the related repository is not available without modifying the repository url to inject credentials. Users are advised to upgrade. Users unable to upgrade should ensure that secrets that do not contain characters that are excluded from encoding with `encodeURI` when included in a URL are already masked properly.", "other": {"cve": {"id": "CVE-2022-31051", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T20:15:08.400", "lastModified": "2022-06-17T14:48:40.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "semantic-release is an open source npm package for automated version management and package publishing. In affected versions secrets that would normally be masked by semantic-release can be accidentally disclosed if they contain characters that are excluded from uri encoding by `encodeURI`. Occurrence is further limited to execution contexts where push access to the related repository is not available without modifying the repository url to inject credentials. Users are advised to upgrade. Users unable to upgrade should ensure that secrets that do not contain characters that are excluded from encoding with `encodeURI` when included in a URL are already masked properly."}, {"lang": "es", "value": "semantic-release es un paquete npm de c\u00f3digo abierto para la administraci\u00f3n automatizada de versiones y la publicaci\u00f3n de paquetes. En versiones afectadas, los secretos que normalmente estar\u00edan enmascarados por semantic-release pueden ser revelados accidentalmente si contienen caracteres que est\u00e1n excluidos de la codificaci\u00f3n uri por \"encodeURI\". La ocurrencia es limitada adem\u00e1s a contextos de ejecuci\u00f3n en los que el acceso push al repositorio relacionado no est\u00e1 disponible sin modificar la url del repositorio para inyectar credenciales. Es recomendado a usuarios actualizar. Los usuarios que no puedan actualizar deben asegurarse de que los secretos que no contengan caracteres excluidos de la codificaci\u00f3n con \"encodeURI\" cuando sean incluidos en una URL ya est\u00e9n enmascarados correctamente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:semantic-release_project:semantic-release:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.0.4", "versionEndExcluding": "19.0.3", "matchCriteriaId": "568BC3E0-23CD-43A5-BF0D-FD867359D17A"}]}]}], "references": [{"url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/semantic-release/semantic-release/commit/58a226f29c04ee56bbb02cc661f020d568849cad", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/semantic-release/semantic-release/releases/tag/v19.0.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/semantic-release/semantic-release/security/advisories/GHSA-x2pg-mjhr-2m5x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/semantic-release/semantic-release/commit/58a226f29c04ee56bbb02cc661f020d568849cad"}}