{"buggy_code": ["<?php\n\n/**\n * The main Session class.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n * obtain one at https://mozilla.org/MPL/2.0/.\n *\n * @package   phpMyFAQ\n * @author    Thorsten Rinne <thorsten@phpmyfaq.de>\n * @copyright 2007-2023 phpMyFAQ Team\n * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0\n * @link      https://www.phpmyfaq.de\n * @since     2007-03-31\n */\n\nnamespace phpMyFAQ;\n\nuse phpMyFAQ\\Core\\Exception;\nuse phpMyFAQ\\User\\CurrentUser;\nuse stdClass;\nuse Symfony\\Component\\HttpFoundation\\IpUtils;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Class Session\n *\n * @package phpMyFAQ\n */\nclass Session\n{\n    /** @var string Name of the \"remember me\" cookie */\n    final public const PMF_COOKIE_NAME_REMEMBERME = 'pmf_rememberme';\n\n    /** @var string Name of the session cookie */\n    final public const PMF_COOKIE_NAME_SESSIONID = 'pmf_sid';\n\n    /** @var string Name of the session GET parameter */\n    final public const PMF_GET_KEY_NAME_SESSIONID = 'sid';\n\n    /** @var string Azure AD session key */\n    final public const PMF_AZURE_AD_SESSIONKEY = 'phpmyfaq_aad_sessionkey';\n\n    /** @var string */\n    final public const PMF_AZURE_AD_OAUTH_VERIFIER = 'phpmyfaq_azure_ad_oauth_verifier';\n\n    /** @var string */\n    final public const PMF_AZURE_AD_JWT = 'phpmyfaq_azure_ad_jwt';\n\n    private ?int $currentSessionId = null;\n\n    private string $currentSessionKey;\n\n    private readonly string $currentToken;\n\n    private ?CurrentUser $currentUser = null;\n\n    /** @var string[] List of bots we don't track */\n    private array $botIgnoreList = [\n        'nustcrape',\n        'webpost',\n        'GoogleBot',\n        'msnbot',\n        'crawler',\n        'scooter',\n        'bravobrian',\n        'archiver',\n        'w3c',\n        'control',\n        'wget',\n        'bot',\n        'spider',\n        'Yahoo! Slurp',\n        'htdig',\n        'gsa-crawler',\n        'AirControl'\n    ];\n\n    /**\n     * Constructor.\n     */\n    public function __construct(private readonly Configuration $config)\n    {\n    }\n\n    /**\n     * Returns the current session ID.\n     */\n    public function getCurrentSessionId(): ?int\n    {\n        return $this->currentSessionId;\n    }\n\n    /**\n     * Sets the current session ID.\n     */\n    public function setCurrentSessionId(int $currentSessionId): Session\n    {\n        $this->currentSessionId = $currentSessionId;\n        return $this;\n    }\n\n    /**\n     * Sets current User object\n     */\n    public function setCurrentUser(CurrentUser $currentUser): Session\n    {\n        $this->currentUser = $currentUser;\n        return $this;\n    }\n\n    /**\n     * Returns the current UUID session key\n     */\n    public function getCurrentSessionKey(): ?string\n    {\n        return $this->currentSessionKey ?? $_SESSION[self::PMF_AZURE_AD_SESSIONKEY];\n    }\n\n    public function getCurrentToken(): ?string\n    {\n        return $this->currentToken ?? $_SESSION[self::PMF_AZURE_AD_JWT];\n    }\n\n    /**\n     * Sets the current UUID session key\n     */\n    public function setCurrentSessionKey(): Session\n    {\n        if (!isset($this->currentSessionKey)) {\n            $this->createCurrentSessionKey();\n        }\n\n        $_SESSION[self::PMF_AZURE_AD_SESSIONKEY] = $this->getCurrentSessionKey();\n        return $this;\n    }\n\n    /**\n     * Creates the current UUID session key\n     */\n    public function createCurrentSessionKey(): void\n    {\n        $this->currentSessionKey = $this->uuid();\n    }\n\n    public function set(string $key, string $value): void\n    {\n        $_SESSION[$key] = $value;\n    }\n\n    public function get(string $key): string\n    {\n        return $_SESSION[$key];\n    }\n\n    /**\n     * Returns the timestamp of a session.\n     *\n     * @param int $sessionId Session ID\n     */\n    public function getTimeFromSessionId(int $sessionId): int\n    {\n        $timestamp = 0;\n\n        $query = sprintf('SELECT time FROM %sfaqsessions WHERE sid = %d', Database::getTablePrefix(), $sessionId);\n\n        $result = $this->config->getDb()->query($query);\n\n        if ($result) {\n            $res = $this->config->getDb()->fetchObject($result);\n            $timestamp = $res->time;\n        }\n\n        return $timestamp;\n    }\n\n    /**\n     * Returns all session from a date.\n     *\n     * @param int $firstHour First hour\n     * @param int $lastHour Last hour\n     *\n     * @return array<int, string[]>\n     */\n    public function getSessionsByDate(int $firstHour, int $lastHour): array\n    {\n        $sessions = [];\n\n        $query = sprintf(\n            'SELECT sid, ip, time FROM %sfaqsessions WHERE time > %d AND time < %d ORDER BY time',\n            Database::getTablePrefix(),\n            $firstHour,\n            $lastHour\n        );\n\n        $result = $this->config->getDb()->query($query);\n        while ($row = $this->config->getDb()->fetchObject($result)) {\n            $sessions[$row->sid] = [\n                'ip' => $row->ip,\n                'time' => $row->time,\n            ];\n        }\n\n        return $sessions;\n    }\n\n    /**\n     * Returns the number of sessions.\n     */\n    public function getNumberOfSessions(): int\n    {\n        $num = 0;\n\n        $query = sprintf('SELECT COUNT(sid) as num_sessions FROM %sfaqsessions', Database::getTablePrefix());\n\n        $result = $this->config->getDb()->query($query);\n        if ($result) {\n            $row = $this->config->getDb()->fetchObject($result);\n            $num = $row->num_sessions;\n        }\n\n        return $num;\n    }\n\n    /**\n     * Deletes the sessions for a given timespan.\n     *\n     * @param int $first First session ID\n     * @param int $last Last session ID\n     */\n    public function deleteSessions(int $first, int $last): bool\n    {\n        $query = sprintf(\n            'DELETE FROM %sfaqsessions WHERE time >= %d AND time <= %d',\n            Database::getTablePrefix(),\n            $first,\n            $last\n        );\n\n        $this->config->getDb()->query($query);\n\n        return true;\n    }\n\n    /**\n     * Deletes all entries in the table.\n     */\n    public function deleteAllSessions(): mixed\n    {\n        $query = sprintf('DELETE FROM %sfaqsessions', Database::getTablePrefix());\n\n        return $this->config->getDb()->query($query);\n    }\n\n    /**\n     * Checks the Session ID.\n     *\n     * @param int $sessionIdToCheck Session ID\n     * @param string $ip IP\n     * @throws Exception\n     */\n    public function checkSessionId(int $sessionIdToCheck, string $ip): void\n    {\n        $query = sprintf(\n            \"SELECT sid FROM %sfaqsessions WHERE sid = %d AND ip = '%s' AND time > %d\",\n            Database::getTablePrefix(),\n            $sessionIdToCheck,\n            $ip,\n            $_SERVER['REQUEST_TIME'] - 86400\n        );\n        $result = $this->config->getDb()->query($query);\n\n        if ($this->config->getDb()->numRows($result) == 0) {\n            $this->userTracking('old_session', $sessionIdToCheck);\n        } else {\n            // Update global session id\n            $this->setCurrentSessionId($sessionIdToCheck);\n            // Update db tracking\n            $query = sprintf(\n                \"UPDATE %sfaqsessions SET time = %d, user_id = %d WHERE sid = %d AND ip = '%s'\",\n                Database::getTablePrefix(),\n                $_SERVER['REQUEST_TIME'],\n                $this->currentUser->getUserId(),\n                $sessionIdToCheck,\n                $ip\n            );\n            $this->config->getDb()->query($query);\n        }\n    }\n\n    /**\n     * Tracks the user and log what he did.\n     *\n     * @param string          $action Action string\n     * @param int|string|null $data\n     * @throws Exception\n     */\n    public function userTracking(string $action, int|string $data = null): void\n    {\n        if ($this->config->get('main.enableUserTracking')) {\n            $request = Request::createFromGlobals();\n            $bots = 0;\n            $banned = false;\n            $this->currentSessionId = Filter::filterVar(\n                $request->query->get(self::PMF_GET_KEY_NAME_SESSIONID),\n                FILTER_VALIDATE_INT\n            );\n            $cookieId = Filter::filterVar($request->query->get(self::PMF_COOKIE_NAME_SESSIONID), FILTER_VALIDATE_INT);\n\n            if (!is_null($cookieId)) {\n                $this->setCurrentSessionId($cookieId);\n            }\n            if ($action === 'old_session') {\n                $this->setCurrentSessionId(0);\n            }\n\n            foreach ($this->botIgnoreList as $bot) {\n                if (Strings::strstr($request->headers->get('user-agent'), $bot)) {\n                    ++$bots;\n                }\n            }\n\n            // if we're running behind a reverse proxy like nginx/varnish, fix the client IP\n            $remoteAddress = Request::createFromGlobals()->getClientIp();\n            $localAddresses = ['127.0.0.1', '::1'];\n\n            if (in_array($remoteAddress, $localAddresses) && isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n                $remoteAddress = $_SERVER['HTTP_X_FORWARDED_FOR'];\n            }\n\n            // clean up as well\n            $remoteAddress = preg_replace('([^0-9a-z:\\.]+)i', '', (string) $remoteAddress);\n\n            // Anonymize IP address\n            $remoteAddress = IpUtils::anonymize($remoteAddress);\n\n            $network = new Network($this->config);\n            if ($network->isBanned($remoteAddress)) {\n                $banned = true;\n            }\n\n            if (0 === $bots && false === $banned) {\n                if (!isset($this->currentSessionId)) {\n                    $this->currentSessionId = $this->config->getDb()->nextId(\n                        Database::getTablePrefix() . 'faqsessions',\n                        'sid'\n                    );\n                    // Check: force the session cookie to contains the current $sid\n                    if (!is_null($cookieId) && (!$cookieId != $this->getCurrentSessionId())) {\n                        self::setCookie(self::PMF_COOKIE_NAME_SESSIONID, $this->getCurrentSessionId());\n                    }\n\n                    $query = sprintf(\n                        \"INSERT INTO %sfaqsessions (sid, user_id, ip, time) VALUES (%d, %d, '%s', %d)\",\n                        Database::getTablePrefix(),\n                        $this->getCurrentSessionId(),\n                        $this->currentUser->getUserId(),\n                        $remoteAddress,\n                        $_SERVER['REQUEST_TIME']\n                    );\n\n                    $this->config->getDb()->query($query);\n                }\n\n                $data = $this->getCurrentSessionId() . ';' .\n                    str_replace(';', ',', $action) . ';' .\n                    $data . ';' .\n                    $remoteAddress . ';' .\n                    str_replace(';', ',', $_SERVER['QUERY_STRING'] ?? '') . ';' .\n                    str_replace(';', ',', $_SERVER['HTTP_REFERER'] ?? '') . ';' .\n                    str_replace(';', ',', urldecode((string) $_SERVER['HTTP_USER_AGENT'])) . ';' .\n                    $_SERVER['REQUEST_TIME'] . \";\\n\";\n\n                $file = PMF_ROOT_DIR . '/data/tracking' . date('dmY');\n\n                if (!is_file($file)) {\n                    touch($file);\n                }\n\n                if (is_writeable($file)) {\n                    file_put_contents($file, $data, FILE_APPEND | LOCK_EX);\n                } else {\n                    throw new Exception('Cannot write to ' . $file);\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the Session ID into a persistent cookie expiring\n     * 3600 seconds after the page request.\n     *\n     * @param string          $name Cookie name\n     * @param int|string|null $sessionId Session ID\n     * @param int             $timeout Cookie timeout\n     */\n    public function setCookie(string $name, int|string|null $sessionId, int $timeout = 3600): bool\n    {\n        $secure = false;\n        if (isset($_SERVER['HTTPS']) && strtoupper((string) $_SERVER['HTTPS']) === 'ON') {\n            $secure = true;\n        }\n\n        return setcookie(\n            $name,\n            $sessionId ?? '',\n            [\n                'expires' => $_SERVER['REQUEST_TIME'] + $timeout,\n                'path' => dirname((string) $_SERVER['SCRIPT_NAME']),\n                'domain' => parse_url($this->config->getDefaultUrl(), PHP_URL_HOST),\n                'samesite' => 'strict',\n                'secure' => $secure,\n                'httponly' => true,\n            ]\n        );\n    }\n\n    /**\n     * Returns the number of anonymous users and registered ones.\n     * These are the numbers of unique users who have performed\n     * some activities within the last five minutes.\n     *\n     * @param int $activityTimeWindow Optionally set the time window size in sec.\n     *                                Default: 300sec, 5 minutes\n     *\n     * @return array<int>\n     */\n    public function getUsersOnline(int $activityTimeWindow = 300): array\n    {\n        $users = [0, 0];\n\n        if ($this->config->get('main.enableUserTracking')) {\n            $timeNow = ($_SERVER['REQUEST_TIME'] - $activityTimeWindow);\n\n            if (!$this->config->get('security.enableLoginOnly')) {\n                // Count all sids within the time window for public installations\n                $query = sprintf(\n                    'SELECT count(sid) AS anonymous_users FROM %sfaqsessions WHERE user_id = -1 AND time > %d',\n                    Database::getTablePrefix(),\n                    $timeNow\n                );\n\n                $result = $this->config->getDb()->query($query);\n\n                if (isset($result)) {\n                    $row = $this->config->getDb()->fetchObject($result);\n                    $users[0] = $row->anonymous_users;\n                }\n            }\n\n            // Count all faq user records within the time window\n            $query = sprintf(\n                'SELECT count(session_id) AS registered_users FROM %sfaquser WHERE session_timestamp > %d',\n                Database::getTablePrefix(),\n                $timeNow\n            );\n\n            $result = $this->config->getDb()->query($query);\n\n            if (isset($result)) {\n                $row = $this->config->getDb()->fetchObject($result);\n                $users[1] = $row->registered_users;\n            }\n        }\n\n        return $users;\n    }\n\n    /**\n     * Calculates the number of visits per day the last 30 days.\n     *\n     * @return array<int, stdClass>\n     */\n    public function getLast30DaysVisits(): array\n    {\n        $stats = $visits = $completeData = [];\n\n        $startDate = strtotime('-1 month');\n        $endDate = $_SERVER['REQUEST_TIME'];\n\n        $query = sprintf(\n            'SELECT time FROM %sfaqsessions WHERE time > %d AND time < %d;',\n            Database::getTablePrefix(),\n            $startDate,\n            $endDate\n        );\n        $result = $this->config->getDb()->query($query);\n\n        while ($row = $this->config->getDb()->fetchObject($result)) {\n            $visits[] = $row->time;\n        }\n\n        for ($date = $startDate; $date <= $endDate; $date += 86400) {\n            $stats[date('Y-m-d', $date)] = 0;\n        }\n\n        foreach ($visits as $visitDate) {\n            isset($stats[date('Y-m-d', $visitDate)]) ? $stats[date('Y-m-d', $visitDate)]++ : null;\n        }\n\n        foreach ($stats as $date => $stat) {\n            $visit = new stdClass();\n            $visit->date = $date;\n            $visit->number = $stats[$date];\n            $completeData[] = $visit;\n        }\n\n        return $completeData;\n    }\n\n    /**\n     * Returns a UUID Version 4 compatible universally unique identifier.\n     */\n    public function uuid(): string\n    {\n        return sprintf(\n            '%04x%04x-%04x-%04x-%04x-%04x%04x%04x',\n            random_int(0, 0xffff),\n            random_int(0, 0xffff),\n            random_int(0, 0xffff),\n            random_int(0, 0x0fff) | 0x4000,\n            random_int(0, 0x3fff) | 0x8000,\n            random_int(0, 0xffff),\n            random_int(0, 0xffff),\n            random_int(0, 0xffff)\n        );\n    }\n}\n", "<?php\n\n/**\n * Token class for CSRF (Cross Site Request Forgery) protection.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n * obtain one at https://mozilla.org/MPL/2.0/.\n *\n * @package   phpMyFAQ\n * @author    Thorsten Rinne <thorsten@phpmyfaq.de>\n * @copyright 2023 phpMyFAQ Team\n * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0\n * @link      https://www.phpmyfaq.de\n * @since     2023-02-19\n */\n\nnamespace phpMyFAQ\\Session;\n\nuse Exception;\n\nclass Token\n{\n    final public const PMF_SESSION_NAME = 'pmf-csrf-token';\n    private const PMF_SESSION_EXPIRY = 1800;\n\n    private string $page;\n\n    private int $expiry = 0;\n\n    private ?string $sessionToken = null;\n\n    private ?string $cookieToken = null;\n\n    private static ?Token $instance = null;\n\n    /**\n     * Constructor.\n     */\n    final private function __construct()\n    {\n    }\n\n    public function getPage(): string\n    {\n        return $this->page;\n    }\n\n    public function setPage(string $page): Token\n    {\n        $this->page = $page;\n        return $this;\n    }\n\n    public function getExpiry(): int\n    {\n        return $this->expiry;\n    }\n\n    public function setExpiry(int $expiry): Token\n    {\n        $this->expiry = $expiry;\n        return $this;\n    }\n\n    public function getSessionToken(): string\n    {\n        return $this->sessionToken;\n    }\n\n    public function setSessionToken(string $sessionToken): Token\n    {\n        $this->sessionToken = $sessionToken;\n        return $this;\n    }\n\n    public function getCookieToken(): ?string\n    {\n        return $this->cookieToken;\n    }\n\n    public function setCookieToken(string $cookieToken): Token\n    {\n        $this->cookieToken = $cookieToken;\n        return $this;\n    }\n\n\n    public static function getInstance(): Token\n    {\n        if (!(self::$instance instanceof Token)) {\n            self::$instance = new self();\n        }\n\n        return self::$instance;\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function getTokenInput(string $page, int $expiry = self::PMF_SESSION_EXPIRY): string\n    {\n        $token = $this->getSession($page) ?? $this->setSession($page, $expiry);\n\n        return sprintf(\n            '<input type=\"hidden\" id=\"%s\" name=\"%s\" value=\"%s\">',\n            self::PMF_SESSION_NAME,\n            self::PMF_SESSION_NAME,\n            $token->sessionToken\n        );\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function getTokenString(string $page, int $expiry = self::PMF_SESSION_EXPIRY): string\n    {\n        $token = $this->getSession($page) ?? $this->setSession($page, $expiry);\n\n        return $token->sessionToken;\n    }\n\n    /**\n     * @param string|null $requestToken\n     */\n    public function verifyToken(string $page, string $requestToken = null, bool $removeToken = false): bool\n    {\n        // if the request token has not been passed, check POST\n        $requestToken ??= $_POST[self::PMF_SESSION_NAME] ?? null;\n\n        if (is_null($requestToken)) {\n            return false;\n        }\n\n        $token = $this->getSession($page);\n\n        // if the time is greater than the expiry form submission window\n        if (empty($token) || time() > $token->getExpiry()) {\n            $this->removeToken($page);\n            return false;\n        }\n\n        // check the hash matches the Session / Cookie\n        $sessionConfirm = hash_equals($token->getSessionToken(), $requestToken);\n        $cookieConfirm  = hash_equals($token->getCookieToken(), $this->getCookie($page));\n\n        // remove the token\n        if ($removeToken) {\n            $this->removeToken($page);\n        }\n\n        // both session and cookie match\n        if ($sessionConfirm && $cookieConfirm) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function removeToken(string $page): bool\n    {\n        unset($_COOKIE[$this->getCookie($page)], $_SESSION[self::PMF_SESSION_NAME][$page]);\n\n        return true;\n    }\n\n    private function getSession(string $page): ?Token\n    {\n        return !empty($_SESSION[self::PMF_SESSION_NAME][$page]) ? $_SESSION[self::PMF_SESSION_NAME][$page] : null;\n    }\n\n    private function getCookie(string $page): string\n    {\n        return !empty($_COOKIE[$this->getCookieName($page)]) ? $_COOKIE[$this->getCookieName($page)] : '';\n    }\n\n    /**\n     * @throws Exception\n     */\n    private function setSession(string $page, int $expiry): Token\n    {\n        $token = new self();\n        $token\n            ->setPage($page)\n            ->setExpiry(time() + $expiry)\n            ->setSessionToken(md5(base64_encode(random_bytes(32))))\n            ->setCookieToken(md5(base64_encode(random_bytes(32))));\n\n        setcookie($token->getCookieName($page), $token->getCookieToken(), ['expires' => $token->getExpiry()]);\n\n        return $_SESSION[self::PMF_SESSION_NAME][$page] = $token;\n    }\n\n    private function getCookieName(string $page): string\n    {\n        return sprintf('%s-%s', self::PMF_SESSION_NAME, substr(md5($page), 0, 10));\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * The main Session class.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n * obtain one at https://mozilla.org/MPL/2.0/.\n *\n * @package   phpMyFAQ\n * @author    Thorsten Rinne <thorsten@phpmyfaq.de>\n * @copyright 2007-2023 phpMyFAQ Team\n * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0\n * @link      https://www.phpmyfaq.de\n * @since     2007-03-31\n */\n\nnamespace phpMyFAQ;\n\nuse phpMyFAQ\\Core\\Exception;\nuse phpMyFAQ\\User\\CurrentUser;\nuse stdClass;\nuse Symfony\\Component\\HttpFoundation\\IpUtils;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Class Session\n *\n * @package phpMyFAQ\n */\nclass Session\n{\n    /** @var string Name of the \"remember me\" cookie */\n    final public const PMF_COOKIE_NAME_REMEMBERME = 'pmf_rememberme';\n\n    /** @var string Name of the session cookie */\n    final public const PMF_COOKIE_NAME_SESSIONID = 'pmf_sid';\n\n    /** @var string Name of the session GET parameter */\n    final public const PMF_GET_KEY_NAME_SESSIONID = 'sid';\n\n    /** @var string Azure AD session key */\n    final public const PMF_AZURE_AD_SESSIONKEY = 'phpmyfaq_aad_sessionkey';\n\n    /** @var string */\n    final public const PMF_AZURE_AD_OAUTH_VERIFIER = 'phpmyfaq_azure_ad_oauth_verifier';\n\n    /** @var string */\n    final public const PMF_AZURE_AD_JWT = 'phpmyfaq_azure_ad_jwt';\n\n    private ?int $currentSessionId = null;\n\n    private string $currentSessionKey;\n\n    private readonly string $currentToken;\n\n    private ?CurrentUser $currentUser = null;\n\n    /** @var string[] List of bots we don't track */\n    private array $botIgnoreList = [\n        'nustcrape',\n        'webpost',\n        'GoogleBot',\n        'msnbot',\n        'crawler',\n        'scooter',\n        'bravobrian',\n        'archiver',\n        'w3c',\n        'control',\n        'wget',\n        'bot',\n        'spider',\n        'Yahoo! Slurp',\n        'htdig',\n        'gsa-crawler',\n        'AirControl'\n    ];\n\n    /**\n     * Constructor.\n     */\n    public function __construct(private readonly Configuration $config)\n    {\n    }\n\n    /**\n     * Returns the current session ID.\n     */\n    public function getCurrentSessionId(): ?int\n    {\n        return $this->currentSessionId;\n    }\n\n    /**\n     * Sets the current session ID.\n     */\n    public function setCurrentSessionId(int $currentSessionId): Session\n    {\n        $this->currentSessionId = $currentSessionId;\n        return $this;\n    }\n\n    /**\n     * Sets current User object\n     */\n    public function setCurrentUser(CurrentUser $currentUser): Session\n    {\n        $this->currentUser = $currentUser;\n        return $this;\n    }\n\n    /**\n     * Returns the current UUID session key\n     */\n    public function getCurrentSessionKey(): ?string\n    {\n        return $this->currentSessionKey ?? $_SESSION[self::PMF_AZURE_AD_SESSIONKEY];\n    }\n\n    public function getCurrentToken(): ?string\n    {\n        return $this->currentToken ?? $_SESSION[self::PMF_AZURE_AD_JWT];\n    }\n\n    /**\n     * Sets the current UUID session key\n     */\n    public function setCurrentSessionKey(): Session\n    {\n        if (!isset($this->currentSessionKey)) {\n            $this->createCurrentSessionKey();\n        }\n\n        $_SESSION[self::PMF_AZURE_AD_SESSIONKEY] = $this->getCurrentSessionKey();\n        return $this;\n    }\n\n    /**\n     * Creates the current UUID session key\n     */\n    public function createCurrentSessionKey(): void\n    {\n        $this->currentSessionKey = $this->uuid();\n    }\n\n    public function set(string $key, string $value): void\n    {\n        $_SESSION[$key] = $value;\n    }\n\n    public function get(string $key): string\n    {\n        return $_SESSION[$key];\n    }\n\n    /**\n     * Returns the timestamp of a session.\n     *\n     * @param int $sessionId Session ID\n     */\n    public function getTimeFromSessionId(int $sessionId): int\n    {\n        $timestamp = 0;\n\n        $query = sprintf('SELECT time FROM %sfaqsessions WHERE sid = %d', Database::getTablePrefix(), $sessionId);\n\n        $result = $this->config->getDb()->query($query);\n\n        if ($result) {\n            $res = $this->config->getDb()->fetchObject($result);\n            $timestamp = $res->time;\n        }\n\n        return $timestamp;\n    }\n\n    /**\n     * Returns all session from a date.\n     *\n     * @param int $firstHour First hour\n     * @param int $lastHour Last hour\n     *\n     * @return array<int, string[]>\n     */\n    public function getSessionsByDate(int $firstHour, int $lastHour): array\n    {\n        $sessions = [];\n\n        $query = sprintf(\n            'SELECT sid, ip, time FROM %sfaqsessions WHERE time > %d AND time < %d ORDER BY time',\n            Database::getTablePrefix(),\n            $firstHour,\n            $lastHour\n        );\n\n        $result = $this->config->getDb()->query($query);\n        while ($row = $this->config->getDb()->fetchObject($result)) {\n            $sessions[$row->sid] = [\n                'ip' => $row->ip,\n                'time' => $row->time,\n            ];\n        }\n\n        return $sessions;\n    }\n\n    /**\n     * Returns the number of sessions.\n     */\n    public function getNumberOfSessions(): int\n    {\n        $num = 0;\n\n        $query = sprintf('SELECT COUNT(sid) as num_sessions FROM %sfaqsessions', Database::getTablePrefix());\n\n        $result = $this->config->getDb()->query($query);\n        if ($result) {\n            $row = $this->config->getDb()->fetchObject($result);\n            $num = $row->num_sessions;\n        }\n\n        return $num;\n    }\n\n    /**\n     * Deletes the sessions for a given timespan.\n     *\n     * @param int $first First session ID\n     * @param int $last Last session ID\n     */\n    public function deleteSessions(int $first, int $last): bool\n    {\n        $query = sprintf(\n            'DELETE FROM %sfaqsessions WHERE time >= %d AND time <= %d',\n            Database::getTablePrefix(),\n            $first,\n            $last\n        );\n\n        $this->config->getDb()->query($query);\n\n        return true;\n    }\n\n    /**\n     * Deletes all entries in the table.\n     */\n    public function deleteAllSessions(): mixed\n    {\n        $query = sprintf('DELETE FROM %sfaqsessions', Database::getTablePrefix());\n\n        return $this->config->getDb()->query($query);\n    }\n\n    /**\n     * Checks the Session ID.\n     *\n     * @param int $sessionIdToCheck Session ID\n     * @param string $ip IP\n     * @throws Exception\n     */\n    public function checkSessionId(int $sessionIdToCheck, string $ip): void\n    {\n        $query = sprintf(\n            \"SELECT sid FROM %sfaqsessions WHERE sid = %d AND ip = '%s' AND time > %d\",\n            Database::getTablePrefix(),\n            $sessionIdToCheck,\n            $ip,\n            $_SERVER['REQUEST_TIME'] - 86400\n        );\n        $result = $this->config->getDb()->query($query);\n\n        if ($this->config->getDb()->numRows($result) == 0) {\n            $this->userTracking('old_session', $sessionIdToCheck);\n        } else {\n            // Update global session id\n            $this->setCurrentSessionId($sessionIdToCheck);\n            // Update db tracking\n            $query = sprintf(\n                \"UPDATE %sfaqsessions SET time = %d, user_id = %d WHERE sid = %d AND ip = '%s'\",\n                Database::getTablePrefix(),\n                $_SERVER['REQUEST_TIME'],\n                $this->currentUser->getUserId(),\n                $sessionIdToCheck,\n                $ip\n            );\n            $this->config->getDb()->query($query);\n        }\n    }\n\n    /**\n     * Tracks the user and log what he did.\n     *\n     * @param string          $action Action string\n     * @param int|string|null $data\n     * @throws Exception\n     */\n    public function userTracking(string $action, int|string $data = null): void\n    {\n        if ($this->config->get('main.enableUserTracking')) {\n            $request = Request::createFromGlobals();\n            $bots = 0;\n            $banned = false;\n            $this->currentSessionId = Filter::filterVar(\n                $request->query->get(self::PMF_GET_KEY_NAME_SESSIONID),\n                FILTER_VALIDATE_INT\n            );\n            $cookieId = Filter::filterVar($request->query->get(self::PMF_COOKIE_NAME_SESSIONID), FILTER_VALIDATE_INT);\n\n            if (!is_null($cookieId)) {\n                $this->setCurrentSessionId($cookieId);\n            }\n            if ($action === 'old_session') {\n                $this->setCurrentSessionId(0);\n            }\n\n            foreach ($this->botIgnoreList as $bot) {\n                if (Strings::strstr($request->headers->get('user-agent'), $bot)) {\n                    ++$bots;\n                }\n            }\n\n            // if we're running behind a reverse proxy like nginx/varnish, fix the client IP\n            $remoteAddress = Request::createFromGlobals()->getClientIp();\n            $localAddresses = ['127.0.0.1', '::1'];\n\n            if (in_array($remoteAddress, $localAddresses) && isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n                $remoteAddress = $_SERVER['HTTP_X_FORWARDED_FOR'];\n            }\n\n            // clean up as well\n            $remoteAddress = preg_replace('([^0-9a-z:\\.]+)i', '', (string) $remoteAddress);\n\n            // Anonymize IP address\n            $remoteAddress = IpUtils::anonymize($remoteAddress);\n\n            $network = new Network($this->config);\n            if ($network->isBanned($remoteAddress)) {\n                $banned = true;\n            }\n\n            if (0 === $bots && false === $banned) {\n                if (!isset($this->currentSessionId)) {\n                    $this->currentSessionId = $this->config->getDb()->nextId(\n                        Database::getTablePrefix() . 'faqsessions',\n                        'sid'\n                    );\n                    // Check: force the session cookie to contains the current $sid\n                    if (!is_null($cookieId) && (!$cookieId != $this->getCurrentSessionId())) {\n                        self::setCookie(self::PMF_COOKIE_NAME_SESSIONID, $this->getCurrentSessionId());\n                    }\n\n                    $query = sprintf(\n                        \"INSERT INTO %sfaqsessions (sid, user_id, ip, time) VALUES (%d, %d, '%s', %d)\",\n                        Database::getTablePrefix(),\n                        $this->getCurrentSessionId(),\n                        $this->currentUser->getUserId(),\n                        $remoteAddress,\n                        $_SERVER['REQUEST_TIME']\n                    );\n\n                    $this->config->getDb()->query($query);\n                }\n\n                $data = $this->getCurrentSessionId() . ';' .\n                    str_replace(';', ',', $action) . ';' .\n                    $data . ';' .\n                    $remoteAddress . ';' .\n                    str_replace(';', ',', $_SERVER['QUERY_STRING'] ?? '') . ';' .\n                    str_replace(';', ',', $_SERVER['HTTP_REFERER'] ?? '') . ';' .\n                    str_replace(';', ',', urldecode((string) $_SERVER['HTTP_USER_AGENT'])) . ';' .\n                    $_SERVER['REQUEST_TIME'] . \";\\n\";\n\n                $file = PMF_ROOT_DIR . '/data/tracking' . date('dmY');\n\n                if (!is_file($file)) {\n                    touch($file);\n                }\n\n                if (is_writeable($file)) {\n                    file_put_contents($file, $data, FILE_APPEND | LOCK_EX);\n                } else {\n                    throw new Exception('Cannot write to ' . $file);\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the Session ID into a persistent cookie expiring\n     * 3600 seconds after the page request.\n     *\n     * @param string          $name Cookie name\n     * @param int|string|null $sessionId Session ID\n     * @param int             $timeout Cookie timeout\n     */\n    public function setCookie(string $name, int|string|null $sessionId, int $timeout = 3600): bool\n    {\n        $secure = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') || $_SERVER['SERVER_PORT'] === 443;\n\n        return setcookie(\n            $name,\n            $sessionId ?? '',\n            [\n                'expires' => $_SERVER['REQUEST_TIME'] + $timeout,\n                'path' => dirname((string) $_SERVER['SCRIPT_NAME']),\n                'domain' => parse_url($this->config->getDefaultUrl(), PHP_URL_HOST),\n                'samesite' => 'strict',\n                'secure' => $secure,\n                'httponly' => true,\n            ]\n        );\n    }\n\n    /**\n     * Returns the number of anonymous users and registered ones.\n     * These are the numbers of unique users who have performed\n     * some activities within the last five minutes.\n     *\n     * @param int $activityTimeWindow Optionally set the time window size in sec.\n     *                                Default: 300sec, 5 minutes\n     *\n     * @return array<int>\n     */\n    public function getUsersOnline(int $activityTimeWindow = 300): array\n    {\n        $users = [0, 0];\n\n        if ($this->config->get('main.enableUserTracking')) {\n            $timeNow = ($_SERVER['REQUEST_TIME'] - $activityTimeWindow);\n\n            if (!$this->config->get('security.enableLoginOnly')) {\n                // Count all sids within the time window for public installations\n                $query = sprintf(\n                    'SELECT count(sid) AS anonymous_users FROM %sfaqsessions WHERE user_id = -1 AND time > %d',\n                    Database::getTablePrefix(),\n                    $timeNow\n                );\n\n                $result = $this->config->getDb()->query($query);\n\n                if (isset($result)) {\n                    $row = $this->config->getDb()->fetchObject($result);\n                    $users[0] = $row->anonymous_users;\n                }\n            }\n\n            // Count all faq user records within the time window\n            $query = sprintf(\n                'SELECT count(session_id) AS registered_users FROM %sfaquser WHERE session_timestamp > %d',\n                Database::getTablePrefix(),\n                $timeNow\n            );\n\n            $result = $this->config->getDb()->query($query);\n\n            if (isset($result)) {\n                $row = $this->config->getDb()->fetchObject($result);\n                $users[1] = $row->registered_users;\n            }\n        }\n\n        return $users;\n    }\n\n    /**\n     * Calculates the number of visits per day the last 30 days.\n     *\n     * @return array<int, stdClass>\n     */\n    public function getLast30DaysVisits(): array\n    {\n        $stats = $visits = $completeData = [];\n\n        $startDate = strtotime('-1 month');\n        $endDate = $_SERVER['REQUEST_TIME'];\n\n        $query = sprintf(\n            'SELECT time FROM %sfaqsessions WHERE time > %d AND time < %d;',\n            Database::getTablePrefix(),\n            $startDate,\n            $endDate\n        );\n        $result = $this->config->getDb()->query($query);\n\n        while ($row = $this->config->getDb()->fetchObject($result)) {\n            $visits[] = $row->time;\n        }\n\n        for ($date = $startDate; $date <= $endDate; $date += 86400) {\n            $stats[date('Y-m-d', $date)] = 0;\n        }\n\n        foreach ($visits as $visitDate) {\n            isset($stats[date('Y-m-d', $visitDate)]) ? $stats[date('Y-m-d', $visitDate)]++ : null;\n        }\n\n        foreach ($stats as $date => $stat) {\n            $visit = new stdClass();\n            $visit->date = $date;\n            $visit->number = $stats[$date];\n            $completeData[] = $visit;\n        }\n\n        return $completeData;\n    }\n\n    /**\n     * Returns a UUID Version 4 compatible universally unique identifier.\n     */\n    public function uuid(): string\n    {\n        return sprintf(\n            '%04x%04x-%04x-%04x-%04x-%04x%04x%04x',\n            random_int(0, 0xffff),\n            random_int(0, 0xffff),\n            random_int(0, 0xffff),\n            random_int(0, 0x0fff) | 0x4000,\n            random_int(0, 0x3fff) | 0x8000,\n            random_int(0, 0xffff),\n            random_int(0, 0xffff),\n            random_int(0, 0xffff)\n        );\n    }\n}\n", "<?php\n\n/**\n * Token class for CSRF (Cross Site Request Forgery) protection.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n * obtain one at https://mozilla.org/MPL/2.0/.\n *\n * @package   phpMyFAQ\n * @author    Thorsten Rinne <thorsten@phpmyfaq.de>\n * @copyright 2023 phpMyFAQ Team\n * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0\n * @link      https://www.phpmyfaq.de\n * @since     2023-02-19\n */\n\nnamespace phpMyFAQ\\Session;\n\nuse Exception;\nuse phpMyFAQ\\Configuration;\nuse phpMyFAQ\\System;\n\nclass Token\n{\n    final public const PMF_SESSION_NAME = 'pmf-csrf-token';\n    private const PMF_SESSION_EXPIRY = 1800;\n\n    private string $page;\n\n    private int $expiry = 0;\n\n    private ?string $sessionToken = null;\n\n    private ?string $cookieToken = null;\n\n    private static ?Token $instance = null;\n\n    /**\n     * Constructor.\n     */\n    final private function __construct()\n    {\n    }\n\n    public function getPage(): string\n    {\n        return $this->page;\n    }\n\n    public function setPage(string $page): Token\n    {\n        $this->page = $page;\n        return $this;\n    }\n\n    public function getExpiry(): int\n    {\n        return $this->expiry;\n    }\n\n    public function setExpiry(int $expiry): Token\n    {\n        $this->expiry = $expiry;\n        return $this;\n    }\n\n    public function getSessionToken(): string\n    {\n        return $this->sessionToken;\n    }\n\n    public function setSessionToken(string $sessionToken): Token\n    {\n        $this->sessionToken = $sessionToken;\n        return $this;\n    }\n\n    public function getCookieToken(): ?string\n    {\n        return $this->cookieToken;\n    }\n\n    public function setCookieToken(string $cookieToken): Token\n    {\n        $this->cookieToken = $cookieToken;\n        return $this;\n    }\n\n\n    public static function getInstance(): Token\n    {\n        if (!(self::$instance instanceof Token)) {\n            self::$instance = new self();\n        }\n\n        return self::$instance;\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function getTokenInput(string $page, int $expiry = self::PMF_SESSION_EXPIRY): string\n    {\n        $token = $this->getSession($page) ?? $this->setSession($page, $expiry);\n\n        return sprintf(\n            '<input type=\"hidden\" id=\"%s\" name=\"%s\" value=\"%s\">',\n            self::PMF_SESSION_NAME,\n            self::PMF_SESSION_NAME,\n            $token->sessionToken\n        );\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function getTokenString(string $page, int $expiry = self::PMF_SESSION_EXPIRY): string\n    {\n        $token = $this->getSession($page) ?? $this->setSession($page, $expiry);\n\n        return $token->sessionToken;\n    }\n\n    /**\n     * @param string|null $requestToken\n     */\n    public function verifyToken(string $page, string $requestToken = null, bool $removeToken = false): bool\n    {\n        // if the request token has not been passed, check POST\n        $requestToken ??= $_POST[self::PMF_SESSION_NAME] ?? null;\n\n        if (is_null($requestToken)) {\n            return false;\n        }\n\n        $token = $this->getSession($page);\n\n        // if the time is greater than the expiry form submission window\n        if (empty($token) || time() > $token->getExpiry()) {\n            $this->removeToken($page);\n            return false;\n        }\n\n        // check the hash matches the Session / Cookie\n        $sessionConfirm = hash_equals($token->getSessionToken(), $requestToken);\n        $cookieConfirm  = hash_equals($token->getCookieToken(), $this->getCookie($page));\n\n        // remove the token\n        if ($removeToken) {\n            $this->removeToken($page);\n        }\n\n        // both session and cookie match\n        if ($sessionConfirm && $cookieConfirm) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function removeToken(string $page): bool\n    {\n        unset($_COOKIE[$this->getCookie($page)], $_SESSION[self::PMF_SESSION_NAME][$page]);\n\n        return true;\n    }\n\n    private function getSession(string $page): ?Token\n    {\n        return !empty($_SESSION[self::PMF_SESSION_NAME][$page]) ? $_SESSION[self::PMF_SESSION_NAME][$page] : null;\n    }\n\n    private function getCookie(string $page): string\n    {\n        return !empty($_COOKIE[$this->getCookieName($page)]) ? $_COOKIE[$this->getCookieName($page)] : '';\n    }\n\n    /**\n     * @throws Exception\n     */\n    private function setSession(string $page, int $expiry): Token\n    {\n        $token = new self();\n        $token\n            ->setPage($page)\n            ->setExpiry(time() + $expiry)\n            ->setSessionToken(md5(base64_encode(random_bytes(32))))\n            ->setCookieToken(md5(base64_encode(random_bytes(32))));\n\n        setcookie(\n            $token->getCookieName($page),\n            $token->getCookieToken(),\n            [\n                'expires' => $token->getExpiry(),\n                'path' => dirname((string) $_SERVER['SCRIPT_NAME']),\n                'domain' => parse_url(Configuration::getConfigurationInstance()->getDefaultUrl(), PHP_URL_HOST),\n                'samesite' => 'strict',\n                'secure' => $this->isSecure(),\n                'httponly' => true,\n            ]\n        );\n\n        return $_SESSION[self::PMF_SESSION_NAME][$page] = $token;\n    }\n\n    private function getCookieName(string $page): string\n    {\n        return sprintf('%s-%s', self::PMF_SESSION_NAME, substr(md5($page), 0, 10));\n    }\n\n    private function isSecure(): bool\n    {\n        return (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') || $_SERVER['SERVER_PORT'] === 443;\n    }\n}\n"], "filenames": ["phpmyfaq/src/phpMyFAQ/Session.php", "phpmyfaq/src/phpMyFAQ/Session/Token.php"], "buggy_code_start_loc": [400, 20], "buggy_code_end_loc": [404, 197], "fixing_code_start_loc": [400, 21], "fixing_code_end_loc": [401, 216], "type": "CWE-614", "message": "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute in GitHub repository thorsten/phpmyfaq prior to 3.2.1.", "other": {"cve": {"id": "CVE-2023-5866", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-31T01:15:07.947", "lastModified": "2023-11-08T18:09:49.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute in GitHub repository thorsten/phpmyfaq prior to 3.2.1."}, {"lang": "es", "value": "Cookie confidencial en sesi\u00f3n HTTPS sin atributo \"seguro\" en el repositorio de GitHub thorsten/phpmyfaq anterior a 3.2.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-614"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyfaq:phpmyfaq:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.1", "matchCriteriaId": "A0F6B11D-C89E-4C4F-A2CA-9CB3F83C8AD3"}]}]}], "references": [{"url": "https://github.com/thorsten/phpmyfaq/commit/fdacff14acd5e69841068f0e32b59e2d1b1d0d55", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/ec44bcba-ae7f-497a-851e-8165ecf56945", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thorsten/phpmyfaq/commit/fdacff14acd5e69841068f0e32b59e2d1b1d0d55"}}