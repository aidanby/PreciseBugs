{"buggy_code": ["/* linux/drivers/cdrom/cdrom.c\n   Copyright (c) 1996, 1997 David A. van Leeuwen.\n   Copyright (c) 1997, 1998 Erik Andersen <andersee@debian.org>\n   Copyright (c) 1998, 1999 Jens Axboe <axboe@image.dk>\n\n   May be copied or modified under the terms of the GNU General Public\n   License.  See linux/COPYING for more information.\n\n   Uniform CD-ROM driver for Linux.\n   See Documentation/cdrom/cdrom-standard.tex for usage information.\n\n   The routines in the file provide a uniform interface between the\n   software that uses CD-ROMs and the various low-level drivers that\n   actually talk to the hardware. Suggestions are welcome.\n   Patches that work are more welcome though.  ;-)\n\n To Do List:\n ----------------------------------\n\n -- Modify sysctl/proc interface. I plan on having one directory per\n drive, with entries for outputing general drive information, and sysctl\n based tunable parameters such as whether the tray should auto-close for\n that drive. Suggestions (or patches) for this welcome!\n\n\n Revision History\n ----------------------------------\n 1.00  Date Unknown -- David van Leeuwen <david@tm.tno.nl>\n -- Initial version by David A. van Leeuwen. I don't have a detailed\n  changelog for the 1.x series, David?\n\n2.00  Dec  2, 1997 -- Erik Andersen <andersee@debian.org>\n  -- New maintainer! As David A. van Leeuwen has been too busy to actively\n  maintain and improve this driver, I am now carrying on the torch. If\n  you have a problem with this driver, please feel free to contact me.\n\n  -- Added (rudimentary) sysctl interface. I realize this is really weak\n  right now, and is _very_ badly implemented. It will be improved...\n\n  -- Modified CDROM_DISC_STATUS so that it is now incorporated into\n  the Uniform CD-ROM driver via the cdrom_count_tracks function.\n  The cdrom_count_tracks function helps resolve some of the false\n  assumptions of the CDROM_DISC_STATUS ioctl, and is also used to check\n  for the correct media type when mounting or playing audio from a CD.\n\n  -- Remove the calls to verify_area and only use the copy_from_user and\n  copy_to_user stuff, since these calls now provide their own memory\n  checking with the 2.1.x kernels.\n\n  -- Major update to return codes so that errors from low-level drivers\n  are passed on through (thanks to Gerd Knorr for pointing out this\n  problem).\n\n  -- Made it so if a function isn't implemented in a low-level driver,\n  ENOSYS is now returned instead of EINVAL.\n\n  -- Simplified some complex logic so that the source code is easier to read.\n\n  -- Other stuff I probably forgot to mention (lots of changes).\n\n2.01 to 2.11 Dec 1997-Jan 1998\n  -- TO-DO!  Write changelogs for 2.01 to 2.12.\n\n2.12  Jan  24, 1998 -- Erik Andersen <andersee@debian.org>\n  -- Fixed a bug in the IOCTL_IN and IOCTL_OUT macros.  It turns out that\n  copy_*_user does not return EFAULT on error, but instead returns the number \n  of bytes not copied.  I was returning whatever non-zero stuff came back from \n  the copy_*_user functions directly, which would result in strange errors.\n\n2.13  July 17, 1998 -- Erik Andersen <andersee@debian.org>\n  -- Fixed a bug in CDROM_SELECT_SPEED where you couldn't lower the speed\n  of the drive.  Thanks to Tobias Ringstr|m <tori@prosolvia.se> for pointing\n  this out and providing a simple fix.\n  -- Fixed the procfs-unload-module bug with the fill_inode procfs callback.\n  thanks to Andrea Arcangeli\n  -- Fixed it so that the /proc entry now also shows up when cdrom is\n  compiled into the kernel.  Before it only worked when loaded as a module.\n\n  2.14 August 17, 1998 -- Erik Andersen <andersee@debian.org>\n  -- Fixed a bug in cdrom_media_changed and handling of reporting that\n  the media had changed for devices that _don't_ implement media_changed.  \n  Thanks to Grant R. Guenther <grant@torque.net> for spotting this bug.\n  -- Made a few things more pedanticly correct.\n\n2.50 Oct 19, 1998 - Jens Axboe <axboe@image.dk>\n  -- New maintainers! Erik was too busy to continue the work on the driver,\n  so now Chris Zwilling <chris@cloudnet.com> and Jens Axboe <axboe@image.dk>\n  will do their best to follow in his footsteps\n  \n  2.51 Dec 20, 1998 - Jens Axboe <axboe@image.dk>\n  -- Check if drive is capable of doing what we ask before blindly changing\n  cdi->options in various ioctl.\n  -- Added version to proc entry.\n  \n  2.52 Jan 16, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixed an error in open_for_data where we would sometimes not return\n  the correct error value. Thanks Huba Gaspar <huba@softcell.hu>.\n  -- Fixed module usage count - usage was based on /proc/sys/dev\n  instead of /proc/sys/dev/cdrom. This could lead to an oops when other\n  modules had entries in dev. Feb 02 - real bug was in sysctl.c where\n  dev would be removed even though it was used. cdrom.c just illuminated\n  that bug.\n  \n  2.53 Feb 22, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixup of several ioctl calls, in particular CDROM_SET_OPTIONS has\n  been \"rewritten\" because capabilities and options aren't in sync. They\n  should be...\n  -- Added CDROM_LOCKDOOR ioctl. Locks the door and keeps it that way.\n  -- Added CDROM_RESET ioctl.\n  -- Added CDROM_DEBUG ioctl. Enable debug messages on-the-fly.\n  -- Added CDROM_GET_CAPABILITY ioctl. This relieves userspace programs\n  from parsing /proc/sys/dev/cdrom/info.\n  \n  2.54 Mar 15, 1999 - Jens Axboe <axboe@image.dk>\n  -- Check capability mask from low level driver when counting tracks as\n  per suggestion from Corey J. Scotts <cstotts@blue.weeg.uiowa.edu>.\n  \n  2.55 Apr 25, 1999 - Jens Axboe <axboe@image.dk>\n  -- autoclose was mistakenly checked against CDC_OPEN_TRAY instead of\n  CDC_CLOSE_TRAY.\n  -- proc info didn't mask against capabilities mask.\n  \n  3.00 Aug 5, 1999 - Jens Axboe <axboe@image.dk>\n  -- Unified audio ioctl handling across CD-ROM drivers. A lot of the\n  code was duplicated before. Drives that support the generic packet\n  interface are now being fed packets from here instead.\n  -- First attempt at adding support for MMC2 commands - for DVD and\n  CD-R(W) drives. Only the DVD parts are in now - the interface used is\n  the same as for the audio ioctls.\n  -- ioctl cleanups. if a drive couldn't play audio, it didn't get\n  a change to perform device specific ioctls as well.\n  -- Defined CDROM_CAN(CDC_XXX) for checking the capabilities.\n  -- Put in sysctl files for autoclose, autoeject, check_media, debug,\n  and lock.\n  -- /proc/sys/dev/cdrom/info has been updated to also contain info about\n  CD-Rx and DVD capabilities.\n  -- Now default to checking media type.\n  -- CDROM_SEND_PACKET ioctl added. The infrastructure was in place for\n  doing this anyway, with the generic_packet addition.\n  \n  3.01 Aug 6, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fix up the sysctl handling so that the option flags get set\n  correctly.\n  -- Fix up ioctl handling so the device specific ones actually get\n  called :).\n  \n  3.02 Aug 8, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixed volume control on SCSI drives (or others with longer audio\n  page).\n  -- Fixed a couple of DVD minors. Thanks to Andrew T. Veliath\n  <andrewtv@usa.net> for telling me and for having defined the various\n  DVD structures and ioctls in the first place! He designed the original\n  DVD patches for ide-cd and while I rearranged and unified them, the\n  interface is still the same.\n  \n  3.03 Sep 1, 1999 - Jens Axboe <axboe@image.dk>\n  -- Moved the rest of the audio ioctls from the CD-ROM drivers here. Only\n  CDROMREADTOCENTRY and CDROMREADTOCHDR are left.\n  -- Moved the CDROMREADxxx ioctls in here.\n  -- Defined the cdrom_get_last_written and cdrom_get_next_block as ioctls\n  and exported functions.\n  -- Erik Andersen <andersen@xmission.com> modified all SCMD_ commands\n  to now read GPCMD_ for the new generic packet interface. All low level\n  drivers are updated as well.\n  -- Various other cleanups.\n\n  3.04 Sep 12, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixed a couple of possible memory leaks (if an operation failed and\n  we didn't free the buffer before returning the error).\n  -- Integrated Uniform CD Changer handling from Richard Sharman\n  <rsharman@pobox.com>.\n  -- Defined CD_DVD and CD_CHANGER log levels.\n  -- Fixed the CDROMREADxxx ioctls.\n  -- CDROMPLAYTRKIND uses the GPCMD_PLAY_AUDIO_MSF command - too few\n  drives supported it. We lose the index part, however.\n  -- Small modifications to accommodate opens of /dev/hdc1, required\n  for ide-cd to handle multisession discs.\n  -- Export cdrom_mode_sense and cdrom_mode_select.\n  -- init_cdrom_command() for setting up a cgc command.\n  \n  3.05 Oct 24, 1999 - Jens Axboe <axboe@image.dk>\n  -- Changed the interface for CDROM_SEND_PACKET. Before it was virtually\n  impossible to send the drive data in a sensible way.\n  -- Lowered stack usage in mmc_ioctl(), dvd_read_disckey(), and\n  dvd_read_manufact.\n  -- Added setup of write mode for packet writing.\n  -- Fixed CDDA ripping with cdda2wav - accept much larger requests of\n  number of frames and split the reads in blocks of 8.\n\n  3.06 Dec 13, 1999 - Jens Axboe <axboe@image.dk>\n  -- Added support for changing the region of DVD drives.\n  -- Added sense data to generic command.\n\n  3.07 Feb 2, 2000 - Jens Axboe <axboe@suse.de>\n  -- Do same \"read header length\" trick in cdrom_get_disc_info() as\n  we do in cdrom_get_track_info() -- some drive don't obey specs and\n  fail if they can't supply the full Mt Fuji size table.\n  -- Deleted stuff related to setting up write modes. It has a different\n  home now.\n  -- Clear header length in mode_select unconditionally.\n  -- Removed the register_disk() that was added, not needed here.\n\n  3.08 May 1, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix direction flag in setup_send_key and setup_report_key. This\n  gave some SCSI adapters problems.\n  -- Always return -EROFS for write opens\n  -- Convert to module_init/module_exit style init and remove some\n  of the #ifdef MODULE stuff\n  -- Fix several dvd errors - DVD_LU_SEND_ASF should pass agid,\n  DVD_HOST_SEND_RPC_STATE did not set buffer size in cdb, and\n  dvd_do_auth passed uninitialized data to drive because init_cdrom_command\n  did not clear a 0 sized buffer.\n  \n  3.09 May 12, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix Video-CD on SCSI drives that don't support READ_CD command. In\n  that case switch block size and issue plain READ_10 again, then switch\n  back.\n\n  3.10 Jun 10, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix volume control on CD's - old SCSI-II drives now use their own\n  code, as doing MODE6 stuff in here is really not my intention.\n  -- Use READ_DISC_INFO for more reliable end-of-disc.\n\n  3.11 Jun 12, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix bug in getting rpc phase 2 region info.\n  -- Reinstate \"correct\" CDROMPLAYTRKIND\n\n   3.12 Oct 18, 2000 - Jens Axboe <axboe@suse.de>\n  -- Use quiet bit on packet commands not known to work\n\n   3.20 Dec 17, 2003 - Jens Axboe <axboe@suse.de>\n  -- Various fixes and lots of cleanups not listed :-)\n  -- Locking fixes\n  -- Mt Rainier support\n  -- DVD-RAM write open fixes\n\n  Nov 5 2001, Aug 8 2002. Modified by Andy Polyakov\n  <appro@fy.chalmers.se> to support MMC-3 compliant DVD+RW units.\n\n  Modified by Nigel Kukard <nkukard@lbsd.net> - support DVD+RW\n  2.4.x patch by Andy Polyakov <appro@fy.chalmers.se>\n\n-------------------------------------------------------------------------*/\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define REVISION \"Revision: 3.20\"\n#define VERSION \"Id: cdrom.c 3.20 2003/12/17\"\n\n/* I use an error-log mask to give fine grain control over the type of\n   messages dumped to the system logs.  The available masks include: */\n#define CD_NOTHING      0x0\n#define CD_WARNING\t0x1\n#define CD_REG_UNREG\t0x2\n#define CD_DO_IOCTL\t0x4\n#define CD_OPEN\t\t0x8\n#define CD_CLOSE\t0x10\n#define CD_COUNT_TRACKS 0x20\n#define CD_CHANGER\t0x40\n#define CD_DVD\t\t0x80\n\n/* Define this to remove _all_ the debugging messages */\n/* #define ERRLOGMASK CD_NOTHING */\n#define ERRLOGMASK CD_WARNING\n/* #define ERRLOGMASK (CD_WARNING|CD_OPEN|CD_COUNT_TRACKS|CD_CLOSE) */\n/* #define ERRLOGMASK (CD_WARNING|CD_REG_UNREG|CD_DO_IOCTL|CD_OPEN|CD_CLOSE|CD_COUNT_TRACKS) */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/major.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h> \n#include <linux/cdrom.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/blkpg.h>\n#include <linux/init.h>\n#include <linux/fcntl.h>\n#include <linux/blkdev.h>\n#include <linux/times.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_request.h>\n\n/* used to tell the module to turn on full debugging messages */\nstatic bool debug;\n/* default compatibility mode */\nstatic bool autoclose=1;\nstatic bool autoeject;\nstatic bool lockdoor = 1;\n/* will we ever get to use this... sigh. */\nstatic bool check_media_type;\n/* automatically restart mrw format */\nstatic bool mrw_format_restart = 1;\nmodule_param(debug, bool, 0);\nmodule_param(autoclose, bool, 0);\nmodule_param(autoeject, bool, 0);\nmodule_param(lockdoor, bool, 0);\nmodule_param(check_media_type, bool, 0);\nmodule_param(mrw_format_restart, bool, 0);\n\nstatic DEFINE_MUTEX(cdrom_mutex);\n\nstatic const char *mrw_format_status[] = {\n\t\"not mrw\",\n\t\"bgformat inactive\",\n\t\"bgformat active\",\n\t\"mrw complete\",\n};\n\nstatic const char *mrw_address_space[] = { \"DMA\", \"GAA\" };\n\n#if (ERRLOGMASK != CD_NOTHING)\n#define cd_dbg(type, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif ((ERRLOGMASK & type) || debug == 1)\t\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n#else\n#define cd_dbg(type, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (0 && (ERRLOGMASK & type) || debug == 1)\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n#endif\n\n/* The (cdo->capability & ~cdi->mask & CDC_XXX) construct was used in\n   a lot of places. This macro makes the code more clear. */\n#define CDROM_CAN(type) (cdi->ops->capability & ~cdi->mask & (type))\n\n/*\n * Another popular OS uses 7 seconds as the hard timeout for default\n * commands, so it is a good choice for us as well.\n */\n#define CDROM_DEF_TIMEOUT\t(7 * HZ)\n\n/* Not-exported routines. */\n\nstatic void cdrom_sysctl_register(void);\n\nstatic LIST_HEAD(cdrom_list);\n\nint cdrom_dummy_generic_packet(struct cdrom_device_info *cdi,\n\t\t\t       struct packet_command *cgc)\n{\n\tif (cgc->sshdr) {\n\t\tcgc->sshdr->sense_key = 0x05;\n\t\tcgc->sshdr->asc = 0x20;\n\t\tcgc->sshdr->ascq = 0x00;\n\t}\n\n\tcgc->stat = -EIO;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(cdrom_dummy_generic_packet);\n\nstatic int cdrom_flush_cache(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_FLUSH_CACHE;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\n/* requires CD R/RW */\nstatic int cdrom_get_disc_info(struct cdrom_device_info *cdi,\n\t\t\t       disc_information *di)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tint ret, buflen;\n\n\t/* set up command and get the disc info */\n\tinit_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_DISC_INFO;\n\tcgc.cmd[8] = cgc.buflen = 2;\n\tcgc.quiet = 1;\n\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* not all drives have the same disc_info length, so requeue\n\t * packet with the length the drive tells us it can supply\n\t */\n\tbuflen = be16_to_cpu(di->disc_information_length) +\n\t\tsizeof(di->disc_information_length);\n\n\tif (buflen > sizeof(disc_information))\n\t\tbuflen = sizeof(disc_information);\n\n\tcgc.cmd[8] = cgc.buflen = buflen;\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* return actual fill size */\n\treturn buflen;\n}\n\n/* This macro makes sure we don't have to check on cdrom_device_ops\n * existence in the run-time routines below. Change_capability is a\n * hack to have the capability flags defined const, while we can still\n * change it here without gcc complaining at every line.\n */\n#define ENSURE(call, bits)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (cdo->call == NULL)\t\t\t\\\n\t\t*change_capability &= ~(bits);\t\\\n} while (0)\n\n/*\n * the first prototypes used 0x2c as the page code for the mrw mode page,\n * subsequently this was changed to 0x03. probe the one used by this drive\n */\nstatic int cdrom_mrw_probe_pc(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[16];\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.timeout = HZ;\n\tcgc.quiet = 1;\n\n\tif (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC, 0)) {\n\t\tcdi->mrw_mode_page = MRW_MODE_PC;\n\t\treturn 0;\n\t} else if (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC_PRE1, 0)) {\n\t\tcdi->mrw_mode_page = MRW_MODE_PC_PRE1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct packet_command cgc;\n\tstruct mrw_feature_desc *mfd;\n\tunsigned char buffer[16];\n\tint ret;\n\n\t*write = 0;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_MRW;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\n\t\treturn 1;\n\t*write = mfd->write;\n\n\tif ((ret = cdrom_mrw_probe_pc(cdi))) {\n\t\t*write = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdrom_mrw_bgformat(struct cdrom_device_info *cdi, int cont)\n{\n\tstruct packet_command cgc;\n\tunsigned char buffer[12];\n\tint ret;\n\n\tpr_info(\"%sstarting format\\n\", cont ? \"Re\" : \"\");\n\n\t/*\n\t * FmtData bit set (bit 4), format type is 1\n\t */\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_WRITE);\n\tcgc.cmd[0] = GPCMD_FORMAT_UNIT;\n\tcgc.cmd[1] = (1 << 4) | 1;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\t/*\n\t * 4 byte format list header, 8 byte format list descriptor\n\t */\n\tbuffer[1] = 1 << 1;\n\tbuffer[3] = 8;\n\n\t/*\n\t * nr_blocks field\n\t */\n\tbuffer[4] = 0xff;\n\tbuffer[5] = 0xff;\n\tbuffer[6] = 0xff;\n\tbuffer[7] = 0xff;\n\n\tbuffer[8] = 0x24 << 2;\n\tbuffer[11] = cont;\n\n\tret = cdi->ops->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\tpr_info(\"bgformat failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cdrom_mrw_bgformat_susp(struct cdrom_device_info *cdi, int immed)\n{\n\tstruct packet_command cgc;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\n\t/*\n\t * Session = 1, Track = 0\n\t */\n\tcgc.cmd[1] = !!immed;\n\tcgc.cmd[2] = 1 << 1;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_mrw_exit(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < (int)offsetof(typeof(di),disc_type))\n\t\treturn 1;\n\n\tret = 0;\n\tif (di.mrw_status == CDM_MRW_BGFORMAT_ACTIVE) {\n\t\tpr_info(\"issuing MRW background format suspend\\n\");\n\t\tret = cdrom_mrw_bgformat_susp(cdi, 0);\n\t}\n\n\tif (!ret && cdi->media_written)\n\t\tret = cdrom_flush_cache(cdi);\n\n\treturn ret;\n}\n\nstatic int cdrom_mrw_set_lba_space(struct cdrom_device_info *cdi, int space)\n{\n\tstruct packet_command cgc;\n\tstruct mode_page_header *mph;\n\tchar buffer[16];\n\tint ret, offset, size;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.buffer = buffer;\n\tcgc.buflen = sizeof(buffer);\n\n\tret = cdrom_mode_sense(cdi, &cgc, cdi->mrw_mode_page, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmph = (struct mode_page_header *)buffer;\n\toffset = be16_to_cpu(mph->desc_length);\n\tsize = be16_to_cpu(mph->mode_data_length) + 2;\n\n\tbuffer[offset + 3] = space;\n\tcgc.buflen = size;\n\n\tret = cdrom_mode_select(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"%s: mrw address space %s selected\\n\",\n\t\tcdi->name, mrw_address_space[space]);\n\treturn 0;\n}\n\nint register_cdrom(struct cdrom_device_info *cdi)\n{\n\tstatic char banner_printed;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint *change_capability = (int *)&cdo->capability; /* hack */\n\n\tcd_dbg(CD_OPEN, \"entering register_cdrom\\n\");\n\n\tif (cdo->open == NULL || cdo->release == NULL)\n\t\treturn -EINVAL;\n\tif (!banner_printed) {\n\t\tpr_info(\"Uniform CD-ROM driver \" REVISION \"\\n\");\n\t\tbanner_printed = 1;\n\t\tcdrom_sysctl_register();\n\t}\n\n\tENSURE(drive_status, CDC_DRIVE_STATUS);\n\tif (cdo->check_events == NULL && cdo->media_changed == NULL)\n\t\t*change_capability = ~(CDC_MEDIA_CHANGED | CDC_SELECT_DISC);\n\tENSURE(tray_move, CDC_CLOSE_TRAY | CDC_OPEN_TRAY);\n\tENSURE(lock_door, CDC_LOCK);\n\tENSURE(select_speed, CDC_SELECT_SPEED);\n\tENSURE(get_last_session, CDC_MULTI_SESSION);\n\tENSURE(get_mcn, CDC_MCN);\n\tENSURE(reset, CDC_RESET);\n\tENSURE(generic_packet, CDC_GENERIC_PACKET);\n\tcdi->mc_flags = 0;\n\tcdi->options = CDO_USE_FFLAGS;\n\n\tif (autoclose == 1 && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\tcdi->options |= (int) CDO_AUTO_CLOSE;\n\tif (autoeject == 1 && CDROM_CAN(CDC_OPEN_TRAY))\n\t\tcdi->options |= (int) CDO_AUTO_EJECT;\n\tif (lockdoor == 1)\n\t\tcdi->options |= (int) CDO_LOCK;\n\tif (check_media_type == 1)\n\t\tcdi->options |= (int) CDO_CHECK_TYPE;\n\n\tif (CDROM_CAN(CDC_MRW_W))\n\t\tcdi->exit = cdrom_mrw_exit;\n\n\tif (cdi->disk)\n\t\tcdi->cdda_method = CDDA_BPC_FULL;\n\telse\n\t\tcdi->cdda_method = CDDA_OLD;\n\n\tWARN_ON(!cdo->generic_packet);\n\n\tcd_dbg(CD_REG_UNREG, \"drive \\\"/dev/%s\\\" registered\\n\", cdi->name);\n\tmutex_lock(&cdrom_mutex);\n\tlist_add(&cdi->list, &cdrom_list);\n\tmutex_unlock(&cdrom_mutex);\n\treturn 0;\n}\n#undef ENSURE\n\nvoid unregister_cdrom(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_OPEN, \"entering unregister_cdrom\\n\");\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_del(&cdi->list);\n\tmutex_unlock(&cdrom_mutex);\n\n\tif (cdi->exit)\n\t\tcdi->exit(cdi);\n\n\tcd_dbg(CD_REG_UNREG, \"drive \\\"/dev/%s\\\" unregistered\\n\", cdi->name);\n}\n\nint cdrom_get_media_event(struct cdrom_device_info *cdi,\n\t\t\t  struct media_event_desc *med)\n{\n\tstruct packet_command cgc;\n\tunsigned char buffer[8];\n\tstruct event_header *eh = (struct event_header *)buffer;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_GET_EVENT_STATUS_NOTIFICATION;\n\tcgc.cmd[1] = 1;\t\t/* IMMED */\n\tcgc.cmd[4] = 1 << 4;\t/* media event */\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif (cdi->ops->generic_packet(cdi, &cgc))\n\t\treturn 1;\n\n\tif (be16_to_cpu(eh->data_len) < sizeof(*med))\n\t\treturn 1;\n\n\tif (eh->nea || eh->notification_class != 0x4)\n\t\treturn 1;\n\n\tmemcpy(med, &buffer[sizeof(*eh)], sizeof(*med));\n\treturn 0;\n}\n\nstatic int cdrom_get_random_writable(struct cdrom_device_info *cdi,\n\t\t\t      struct rwrt_feature_desc *rfd)\n{\n\tstruct packet_command cgc;\n\tchar buffer[24];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\t/* often 0x46 */\n\tcgc.cmd[3] = CDF_RWRT;\t\t\t/* often 0x0020 */\n\tcgc.cmd[8] = sizeof(buffer);\t\t/* often 0x18 */\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmemcpy(rfd, &buffer[sizeof(struct feature_header)], sizeof (*rfd));\n\treturn 0;\n}\n\nstatic int cdrom_has_defect_mgt(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[16];\n\t__be16 *feature_code;\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_HWDM;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tfeature_code = (__be16 *) &buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(*feature_code) == CDF_HWDM)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic int cdrom_is_random_writable(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\t*write = 0;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\n\tif (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\t*write = 1;\n\n\treturn 0;\n}\n\nstatic int cdrom_media_erasable(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di), n_first_track))\n\t\treturn -1;\n\n\treturn di.erasable;\n}\n\n/*\n * FIXME: check RO bit\n */\nstatic int cdrom_dvdram_open_write(struct cdrom_device_info *cdi)\n{\n\tint ret = cdrom_media_erasable(cdi);\n\n\t/*\n\t * allow writable open if media info read worked and media is\n\t * erasable, _or_ if it fails since not all drives support it\n\t */\n\tif (!ret)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cdrom_mrw_open_write(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\t/*\n\t * always reset to DMA lba space on open\n\t */\n\tif (cdrom_mrw_set_lba_space(cdi, MRW_LBA_DMA)) {\n\t\tpr_err(\"failed setting lba address space\\n\");\n\t\treturn 1;\n\t}\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di),disc_type))\n\t\treturn 1;\n\n\tif (!di.erasable)\n\t\treturn 1;\n\n\t/*\n\t * mrw_status\n\t * 0\t-\tnot MRW formatted\n\t * 1\t-\tMRW bgformat started, but not running or complete\n\t * 2\t-\tMRW bgformat in progress\n\t * 3\t-\tMRW formatting complete\n\t */\n\tret = 0;\n\tpr_info(\"open: mrw_status '%s'\\n\", mrw_format_status[di.mrw_status]);\n\tif (!di.mrw_status)\n\t\tret = 1;\n\telse if (di.mrw_status == CDM_MRW_BGFORMAT_INACTIVE &&\n\t\t\tmrw_format_restart)\n\t\tret = cdrom_mrw_bgformat(cdi, 1);\n\n\treturn ret;\n}\n\nstatic int mo_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[255];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, &buffer, 4, CGC_DATA_READ);\n\tcgc.quiet = 1;\n\n\t/*\n\t * obtain write protect information as per\n\t * drivers/scsi/sd.c:sd_read_write_protect_flag\n\t */\n\n\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\n\tif (ret)\n\t\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_VENDOR_PAGE, 0);\n\tif (ret) {\n\t\tcgc.buflen = 255;\n\t\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\n\t}\n\n\t/* drive gave us no info, let the user go ahead */\n\tif (ret)\n\t\treturn 0;\n\n\treturn buffer[3] & 0x80;\n}\n\nstatic int cdrom_ram_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\tif ((ret = cdrom_has_defect_mgt(cdi)))\n\t\treturn ret;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\telse if (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\tret = !rfd.curr;\n\n\tcd_dbg(CD_OPEN, \"can open for random write\\n\");\n\treturn ret;\n}\n\nstatic void cdrom_mmc3_profile(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[32];\n\tint ret, mmc3_profile;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[1] = 0;\n\tcgc.cmd[2] = cgc.cmd[3] = 0;\t\t/* Starting Feature Number */\n\tcgc.cmd[8] = sizeof(buffer);\t\t/* Allocation Length */\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\tmmc3_profile = 0xffff;\n\telse\n\t\tmmc3_profile = (buffer[6] << 8) | buffer[7];\n\n\tcdi->mmc3_profile = mmc3_profile;\n}\n\nstatic int cdrom_is_dvd_rw(struct cdrom_device_info *cdi)\n{\n\tswitch (cdi->mmc3_profile) {\n\tcase 0x12:\t/* DVD-RAM\t*/\n\tcase 0x1A:\t/* DVD+RW\t*/\n\tcase 0x43:\t/* BD-RE\t*/\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n/*\n * returns 0 for ok to open write, non-0 to disallow\n */\nstatic int cdrom_open_write(struct cdrom_device_info *cdi)\n{\n\tint mrw, mrw_write, ram_write;\n\tint ret = 1;\n\n\tmrw = 0;\n\tif (!cdrom_is_mrw(cdi, &mrw_write))\n\t\tmrw = 1;\n\n\tif (CDROM_CAN(CDC_MO_DRIVE))\n\t\tram_write = 1;\n\telse\n\t\t(void) cdrom_is_random_writable(cdi, &ram_write);\n\t\n\tif (mrw)\n\t\tcdi->mask &= ~CDC_MRW;\n\telse\n\t\tcdi->mask |= CDC_MRW;\n\n\tif (mrw_write)\n\t\tcdi->mask &= ~CDC_MRW_W;\n\telse\n\t\tcdi->mask |= CDC_MRW_W;\n\n\tif (ram_write)\n\t\tcdi->mask &= ~CDC_RAM;\n\telse\n\t\tcdi->mask |= CDC_RAM;\n\n\tif (CDROM_CAN(CDC_MRW_W))\n\t\tret = cdrom_mrw_open_write(cdi);\n\telse if (CDROM_CAN(CDC_DVD_RAM))\n\t\tret = cdrom_dvdram_open_write(cdi);\n \telse if (CDROM_CAN(CDC_RAM) &&\n \t\t !CDROM_CAN(CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_MRW|CDC_MO_DRIVE))\n \t\tret = cdrom_ram_open_write(cdi);\n\telse if (CDROM_CAN(CDC_MO_DRIVE))\n\t\tret = mo_open_write(cdi);\n\telse if (!cdrom_is_dvd_rw(cdi))\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void cdrom_dvd_rw_close_write(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\n\tif (cdi->mmc3_profile != 0x1a) {\n\t\tcd_dbg(CD_CLOSE, \"%s: No DVD+RW\\n\", cdi->name);\n\t\treturn;\n\t}\n\n\tif (!cdi->media_written) {\n\t\tcd_dbg(CD_CLOSE, \"%s: DVD+RW media clean\\n\", cdi->name);\n\t\treturn;\n\t}\n\n\tpr_info(\"%s: dirty DVD+RW media, \\\"finalizing\\\"\\n\", cdi->name);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_FLUSH_CACHE;\n\tcgc.timeout = 30*HZ;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.timeout = 3000*HZ;\n\tcgc.quiet = 1;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.cmd[2] = 2;\t /* Close session */\n\tcgc.quiet = 1;\n\tcgc.timeout = 3000*HZ;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tcdi->media_written = 0;\n}\n\nstatic int cdrom_close_write(struct cdrom_device_info *cdi)\n{\n#if 0\n\treturn cdrom_flush_cache(cdi);\n#else\n\treturn 0;\n#endif\n}\n\n/* badly broken, I know. Is due for a fixup anytime. */\nstatic void cdrom_count_tracks(struct cdrom_device_info *cdi, tracktype *tracks)\n{\n\tstruct cdrom_tochdr header;\n\tstruct cdrom_tocentry entry;\n\tint ret, i;\n\ttracks->data = 0;\n\ttracks->audio = 0;\n\ttracks->cdi = 0;\n\ttracks->xa = 0;\n\ttracks->error = 0;\n\tcd_dbg(CD_COUNT_TRACKS, \"entering cdrom_count_tracks\\n\");\n\t/* Grab the TOC header so we can see how many tracks there are */\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\n\tif (ret) {\n\t\tif (ret == -ENOMEDIUM)\n\t\t\ttracks->error = CDS_NO_DISC;\n\t\telse\n\t\t\ttracks->error = CDS_NO_INFO;\n\t\treturn;\n\t}\n\t/* check what type of tracks are on this disc */\n\tentry.cdte_format = CDROM_MSF;\n\tfor (i = header.cdth_trk0; i <= header.cdth_trk1; i++) {\n\t\tentry.cdte_track = i;\n\t\tif (cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry)) {\n\t\t\ttracks->error = CDS_NO_INFO;\n\t\t\treturn;\n\t\t}\n\t\tif (entry.cdte_ctrl & CDROM_DATA_TRACK) {\n\t\t\tif (entry.cdte_format == 0x10)\n\t\t\t\ttracks->cdi++;\n\t\t\telse if (entry.cdte_format == 0x20)\n\t\t\t\ttracks->xa++;\n\t\t\telse\n\t\t\t\ttracks->data++;\n\t\t} else {\n\t\t\ttracks->audio++;\n\t\t}\n\t\tcd_dbg(CD_COUNT_TRACKS, \"track %d: format=%d, ctrl=%d\\n\",\n\t\t       i, entry.cdte_format, entry.cdte_ctrl);\n\t}\n\tcd_dbg(CD_COUNT_TRACKS, \"disc has %d tracks: %d=audio %d=data %d=Cd-I %d=XA\\n\",\n\t       header.cdth_trk1, tracks->audio, tracks->data,\n\t       tracks->cdi, tracks->xa);\n}\n\nstatic\nint open_for_data(struct cdrom_device_info *cdi)\n{\n\tint ret;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering open_for_data\\n\");\n\t/* Check if the driver can report drive status.  If it can, we\n\t   can do clever things.  If it can't, well, we at least tried! */\n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t/* can/may i close it? */\n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close the tray but failed.\\n\");\n\t\t\t\t\t/* Ignore the error from the low\n\t\t\t\t\tlevel driver.  We don't care why it\n\t\t\t\t\tcouldn't close the tray.  We only care \n\t\t\t\t\tthat there is no disc in the drive, \n\t\t\t\t\tsince that is the _REAL_ problem here.*/\n\t\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\t\tgoto clean_up_and_return;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this drive can't close the tray.\\n\");\n\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\tgoto clean_up_and_return;\n\t\t\t}\n\t\t\t/* Ok, the door should be closed now.. Check again */\n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\tcd_dbg(CD_OPEN, \"tray might not contain a medium\\n\");\n\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\tgoto clean_up_and_return;\n\t\t\t}\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\n\t\t/* the door should be closed now, check for the disc */\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tif (ret!=CDS_DISC_OK) {\n\t\t\tret = -ENOMEDIUM;\n\t\t\tgoto clean_up_and_return;\n\t\t}\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error == CDS_NO_DISC) {\n\t\tcd_dbg(CD_OPEN, \"bummer. no disc.\\n\");\n\t\tret=-ENOMEDIUM;\n\t\tgoto clean_up_and_return;\n\t}\n\t/* CD-Players which don't use O_NONBLOCK, workman\n\t * for example, need bit CDO_CHECK_TYPE cleared! */\n\tif (tracks.data==0) {\n\t\tif (cdi->options & CDO_CHECK_TYPE) {\n\t\t    /* give people a warning shot, now that CDO_CHECK_TYPE\n\t\t       is the default case! */\n\t\t    cd_dbg(CD_OPEN, \"bummer. wrong media type.\\n\");\n\t\t    cd_dbg(CD_WARNING, \"pid %d must open device O_NONBLOCK!\\n\",\n\t\t\t   (unsigned int)task_pid_nr(current));\n\t\t    ret=-EMEDIUMTYPE;\n\t\t    goto clean_up_and_return;\n\t\t}\n\t\telse {\n\t\t    cd_dbg(CD_OPEN, \"wrong media type, but CDO_CHECK_TYPE not set\\n\");\n\t\t}\n\t}\n\n\tcd_dbg(CD_OPEN, \"all seems well, opening the devicen\");\n\n\t/* all seems well, we can open the device */\n\tret = cdo->open(cdi, 0); /* open for data */\n\tcd_dbg(CD_OPEN, \"opening the device gave me %d\\n\", ret);\n\t/* After all this careful checking, we shouldn't have problems\n\t   opening the device, but we don't want the device locked if \n\t   this somehow fails... */\n\tif (ret) {\n\t\tcd_dbg(CD_OPEN, \"open device failed\\n\");\n\t\tgoto clean_up_and_return;\n\t}\n\tif (CDROM_CAN(CDC_LOCK) && (cdi->options & CDO_LOCK)) {\n\t\t\tcdo->lock_door(cdi, 1);\n\t\t\tcd_dbg(CD_OPEN, \"door locked\\n\");\n\t}\n\tcd_dbg(CD_OPEN, \"device opened successfully\\n\");\n\treturn ret;\n\n\t/* Something failed.  Try to unlock the drive, because some drivers\n\t(notably ide-cd) lock the drive after every command.  This produced\n\ta nasty bug where after mount failed, the drive would remain locked!  \n\tThis ensures that the drive gets unlocked after a mount fails.  This \n\tis a goto to avoid bloating the driver with redundant code. */ \nclean_up_and_return:\n\tcd_dbg(CD_OPEN, \"open failed\\n\");\n\tif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\n\t\t\tcdo->lock_door(cdi, 0);\n\t\t\tcd_dbg(CD_OPEN, \"door unlocked\\n\");\n\t}\n\treturn ret;\n}\n\n/* We use the open-option O_NONBLOCK to indicate that the\n * purpose of opening is only for subsequent ioctl() calls; no device\n * integrity checks are performed.\n *\n * We hope that all cd-player programs will adopt this convention. It\n * is in their own interest: device control becomes a lot easier\n * this way.\n */\nint cdrom_open(struct cdrom_device_info *cdi, struct block_device *bdev,\n\t       fmode_t mode)\n{\n\tint ret;\n\n\tcd_dbg(CD_OPEN, \"entering cdrom_open\\n\");\n\n\t/* if this was a O_NONBLOCK open and we should honor the flags,\n\t * do a quick open without drive/disc integrity checks. */\n\tcdi->use_count++;\n\tif ((mode & FMODE_NDELAY) && (cdi->options & CDO_USE_FFLAGS)) {\n\t\tret = cdi->ops->open(cdi, 1);\n\t} else {\n\t\tret = open_for_data(cdi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tcdrom_mmc3_profile(cdi);\n\t\tif (mode & FMODE_WRITE) {\n\t\t\tret = -EROFS;\n\t\t\tif (cdrom_open_write(cdi))\n\t\t\t\tgoto err_release;\n\t\t\tif (!CDROM_CAN(CDC_RAM))\n\t\t\t\tgoto err_release;\n\t\t\tret = 0;\n\t\t\tcdi->media_written = 0;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\tcd_dbg(CD_OPEN, \"Use count for \\\"/dev/%s\\\" now %d\\n\",\n\t       cdi->name, cdi->use_count);\n\treturn 0;\nerr_release:\n\tif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\n\t\tcdi->ops->lock_door(cdi, 0);\n\t\tcd_dbg(CD_OPEN, \"door unlocked\\n\");\n\t}\n\tcdi->ops->release(cdi);\nerr:\n\tcdi->use_count--;\n\treturn ret;\n}\n\n/* This code is similar to that in open_for_data. The routine is called\n   whenever an audio play operation is requested.\n*/\nstatic int check_for_audio_disc(struct cdrom_device_info *cdi,\n\t\t\t\tconst struct cdrom_device_ops *cdo)\n{\n        int ret;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering check_for_audio_disc\\n\");\n\tif (!(cdi->options & CDO_CHECK_TYPE))\n\t\treturn 0;\n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t/* can/may i close it? */\n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close tray but failed.\\n\");\n\t\t\t\t\t/* Ignore the error from the low\n\t\t\t\t\tlevel driver.  We don't care why it\n\t\t\t\t\tcouldn't close the tray.  We only care \n\t\t\t\t\tthat there is no disc in the drive, \n\t\t\t\t\tsince that is the _REAL_ problem here.*/\n\t\t\t\t\treturn -ENOMEDIUM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this driver can't close the tray.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\n\t\t\t/* Ok, the door should be closed now.. Check again */\n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\t\n\t\t\tif (ret!=CDS_DISC_OK) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. disc isn't ready.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\t\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\t\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error) \n\t\treturn(tracks.error);\n\n\tif (tracks.audio==0)\n\t\treturn -EMEDIUMTYPE;\n\n\treturn 0;\n}\n\nvoid cdrom_release(struct cdrom_device_info *cdi, fmode_t mode)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint opened_for_data;\n\n\tcd_dbg(CD_CLOSE, \"entering cdrom_release\\n\");\n\n\tif (cdi->use_count > 0)\n\t\tcdi->use_count--;\n\n\tif (cdi->use_count == 0) {\n\t\tcd_dbg(CD_CLOSE, \"Use count for \\\"/dev/%s\\\" now zero\\n\",\n\t\t       cdi->name);\n\t\tcdrom_dvd_rw_close_write(cdi);\n\n\t\tif ((cdo->capability & CDC_LOCK) && !cdi->keeplocked) {\n\t\t\tcd_dbg(CD_CLOSE, \"Unlocking door!\\n\");\n\t\t\tcdo->lock_door(cdi, 0);\n\t\t}\n\t}\n\n\topened_for_data = !(cdi->options & CDO_USE_FFLAGS) ||\n\t\t!(mode & FMODE_NDELAY);\n\n\t/*\n\t * flush cache on last write release\n\t */\n\tif (CDROM_CAN(CDC_RAM) && !cdi->use_count && cdi->for_data)\n\t\tcdrom_close_write(cdi);\n\n\tcdo->release(cdi);\n\tif (cdi->use_count == 0) {      /* last process that closes dev*/\n\t\tif (opened_for_data &&\n\t\t    cdi->options & CDO_AUTO_EJECT && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdo->tray_move(cdi, 1);\n\t}\n}\n\nstatic int cdrom_read_mech_status(struct cdrom_device_info *cdi, \n\t\t\t\t  struct cdrom_changer_info *buf)\n{\n\tstruct packet_command cgc;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint length;\n\n\t/*\n\t * Sanyo changer isn't spec compliant (doesn't use regular change\n\t * LOAD_UNLOAD command, and it doesn't implement the mech status\n\t * command below\n\t */\n\tif (cdi->sanyo_slot) {\n\t\tbuf->hdr.nslots = 3;\n\t\tbuf->hdr.curslot = cdi->sanyo_slot == 3 ? 0 : cdi->sanyo_slot;\n\t\tfor (length = 0; length < 3; length++) {\n\t\t\tbuf->slots[length].disc_present = 1;\n\t\t\tbuf->slots[length].change = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlength = sizeof(struct cdrom_mechstat_header) +\n\t\t cdi->capacity * sizeof(struct cdrom_slot);\n\n\tinit_cdrom_command(&cgc, buf, length, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_MECHANISM_STATUS;\n\tcgc.cmd[8] = (length >> 8) & 0xff;\n\tcgc.cmd[9] = length & 0xff;\n\treturn cdo->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_slot_status(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_slot_status()\\n\");\n\tif (cdi->sanyo_slot)\n\t\treturn CDS_NO_INFO;\n\t\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((ret = cdrom_read_mech_status(cdi, info)))\n\t\tgoto out_free;\n\n\tif (info->slots[slot].disc_present)\n\t\tret = CDS_DISC_OK;\n\telse\n\t\tret = CDS_NO_DISC;\n\nout_free:\n\tkfree(info);\n\treturn ret;\n}\n\n/* Return the number of slots for an ATAPI/SCSI cdrom, \n * return 1 if not a changer. \n */\nint cdrom_number_of_slots(struct cdrom_device_info *cdi) \n{\n\tint status;\n\tint nslots = 1;\n\tstruct cdrom_changer_info *info;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_number_of_slots()\\n\");\n\t/* cdrom_read_mech_status requires a valid value for capacity: */\n\tcdi->capacity = 0; \n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((status = cdrom_read_mech_status(cdi, info)) == 0)\n\t\tnslots = info->hdr.nslots;\n\n\tkfree(info);\n\treturn nslots;\n}\n\n\n/* If SLOT < 0, unload the current slot.  Otherwise, try to load SLOT. */\nstatic int cdrom_load_unload(struct cdrom_device_info *cdi, int slot) \n{\n\tstruct packet_command cgc;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_load_unload()\\n\");\n\tif (cdi->sanyo_slot && slot < 0)\n\t\treturn 0;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_LOAD_UNLOAD;\n\tcgc.cmd[4] = 2 + (slot >= 0);\n\tcgc.cmd[8] = slot;\n\tcgc.timeout = 60 * HZ;\n\n\t/* The Sanyo 3 CD changer uses byte 7 of the \n\tGPCMD_TEST_UNIT_READY to command to switch CDs instead of\n\tusing the GPCMD_LOAD_UNLOAD opcode. */\n\tif (cdi->sanyo_slot && -1 < slot) {\n\t\tcgc.cmd[0] = GPCMD_TEST_UNIT_READY;\n\t\tcgc.cmd[7] = slot;\n\t\tcgc.cmd[4] = cgc.cmd[8] = 0;\n\t\tcdi->sanyo_slot = slot ? slot : 3;\n\t}\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_select_disc(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct cdrom_changer_info *info;\n\tint curslot;\n\tint ret;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_select_disc()\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tif (cdi->ops->check_events)\n\t\tcdi->ops->check_events(cdi, 0, slot);\n\telse\n\t\tcdi->ops->media_changed(cdi, slot);\n\n\tif (slot == CDSL_NONE) {\n\t\t/* set media changed bits, on both queues */\n\t\tcdi->mc_flags = 0x3;\n\t\treturn cdrom_load_unload(cdi, -1);\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((ret = cdrom_read_mech_status(cdi, info))) {\n\t\tkfree(info);\n\t\treturn ret;\n\t}\n\n\tcurslot = info->hdr.curslot;\n\tkfree(info);\n\n\tif (cdi->use_count > 1 || cdi->keeplocked) {\n\t\tif (slot == CDSL_CURRENT) {\n\t    \t\treturn curslot;\n\t\t} else {\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* Specifying CDSL_CURRENT will attempt to load the currnet slot,\n\twhich is useful if it had been previously unloaded.\n\tWhether it can or not, it returns the current slot. \n\tSimilarly,  if slot happens to be the current one, we still\n\ttry and load it. */\n\tif (slot == CDSL_CURRENT)\n\t\tslot = curslot;\n\n\t/* set media changed bits on both queues */\n\tcdi->mc_flags = 0x3;\n\tif ((ret = cdrom_load_unload(cdi, slot)))\n\t\treturn ret;\n\n\treturn slot;\n}\n\n/*\n * As cdrom implements an extra ioctl consumer for media changed\n * event, it needs to buffer ->check_events() output, such that event\n * is not lost for both the usual VFS and ioctl paths.\n * cdi->{vfs|ioctl}_events are used to buffer pending events for each\n * path.\n *\n * XXX: Locking is non-existent.  cdi->ops->check_events() can be\n * called in parallel and buffering fields are accessed without any\n * exclusion.  The original media_changed code had the same problem.\n * It might be better to simply deprecate CDROM_MEDIA_CHANGED ioctl\n * and remove this cruft altogether.  It doesn't have much usefulness\n * at this point.\n */\nstatic void cdrom_update_events(struct cdrom_device_info *cdi,\n\t\t\t\tunsigned int clearing)\n{\n\tunsigned int events;\n\n\tevents = cdi->ops->check_events(cdi, clearing, CDSL_CURRENT);\n\tcdi->vfs_events |= events;\n\tcdi->ioctl_events |= events;\n}\n\nunsigned int cdrom_check_events(struct cdrom_device_info *cdi,\n\t\t\t\tunsigned int clearing)\n{\n\tunsigned int events;\n\n\tcdrom_update_events(cdi, clearing);\n\tevents = cdi->vfs_events;\n\tcdi->vfs_events = 0;\n\treturn events;\n}\nEXPORT_SYMBOL(cdrom_check_events);\n\n/* We want to make media_changed accessible to the user through an\n * ioctl. The main problem now is that we must double-buffer the\n * low-level implementation, to assure that the VFS and the user both\n * see a medium change once.\n */\n\nstatic\nint media_changed(struct cdrom_device_info *cdi, int queue)\n{\n\tunsigned int mask = (1 << (queue & 1));\n\tint ret = !!(cdi->mc_flags & mask);\n\tbool changed;\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn ret;\n\n\t/* changed since last call? */\n\tif (cdi->ops->check_events) {\n\t\tBUG_ON(!queue);\t/* shouldn't be called from VFS path */\n\t\tcdrom_update_events(cdi, DISK_EVENT_MEDIA_CHANGE);\n\t\tchanged = cdi->ioctl_events & DISK_EVENT_MEDIA_CHANGE;\n\t\tcdi->ioctl_events = 0;\n\t} else\n\t\tchanged = cdi->ops->media_changed(cdi, CDSL_CURRENT);\n\n\tif (changed) {\n\t\tcdi->mc_flags = 0x3;    /* set bit on both queues */\n\t\tret |= 1;\n\t\tcdi->media_written = 0;\n\t}\n\n\tcdi->mc_flags &= ~mask;         /* clear bit */\n\treturn ret;\n}\n\nint cdrom_media_changed(struct cdrom_device_info *cdi)\n{\n\t/* This talks to the VFS, which doesn't like errors - just 1 or 0.  \n\t * Returning \"0\" is always safe (media hasn't been changed). Do that \n\t * if the low-level cdrom driver dosn't support media changed. */ \n\tif (cdi == NULL || cdi->ops->media_changed == NULL)\n\t\treturn 0;\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn 0;\n\treturn media_changed(cdi, 0);\n}\n\n/* Requests to the low-level drivers will /always/ be done in the\n   following format convention:\n\n   CDROM_LBA: all data-related requests.\n   CDROM_MSF: all audio-related requests.\n\n   However, a low-level implementation is allowed to refuse this\n   request, and return information in its own favorite format.\n\n   It doesn't make sense /at all/ to ask for a play_audio in LBA\n   format, or ask for multi-session info in MSF format. However, for\n   backward compatibility these format requests will be satisfied, but\n   the requests to the low-level drivers will be sanitized in the more\n   meaningful format indicated above.\n */\n\nstatic\nvoid sanitize_format(union cdrom_addr *addr,\n\t\t     u_char * curr, u_char requested)\n{\n\tif (*curr == requested)\n\t\treturn;                 /* nothing to be done! */\n\tif (requested == CDROM_LBA) {\n\t\taddr->lba = (int) addr->msf.frame +\n\t\t\t75 * (addr->msf.second - 2 + 60 * addr->msf.minute);\n\t} else {                        /* CDROM_MSF */\n\t\tint lba = addr->lba;\n\t\taddr->msf.frame = lba % 75;\n\t\tlba /= 75;\n\t\tlba += 2;\n\t\taddr->msf.second = lba % 60;\n\t\taddr->msf.minute = lba / 60;\n\t}\n\t*curr = requested;\n}\n\nvoid init_cdrom_command(struct packet_command *cgc, void *buf, int len,\n\t\t\tint type)\n{\n\tmemset(cgc, 0, sizeof(struct packet_command));\n\tif (buf)\n\t\tmemset(buf, 0, len);\n\tcgc->buffer = (char *) buf;\n\tcgc->buflen = len;\n\tcgc->data_direction = type;\n\tcgc->timeout = CDROM_DEF_TIMEOUT;\n}\n\n/* DVD handling */\n\n#define copy_key(dest,src)\tmemcpy((dest), (src), sizeof(dvd_key))\n#define copy_chal(dest,src)\tmemcpy((dest), (src), sizeof(dvd_challenge))\n\nstatic void setup_report_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_REPORT_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 0: case 8: case 5: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: case 4: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_READ;\n}\n\nstatic void setup_send_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_SEND_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t\tcase 6: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_WRITE;\n}\n\nstatic int dvd_do_auth(struct cdrom_device_info *cdi, dvd_authinfo *ai)\n{\n\tint ret;\n\tu_char buf[20];\n\tstruct packet_command cgc;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\trpc_state_t rpc_state;\n\n\tmemset(buf, 0, sizeof(buf));\n\tinit_cdrom_command(&cgc, buf, 0, CGC_DATA_READ);\n\n\tswitch (ai->type) {\n\t/* LU data send */\n\tcase DVD_LU_SEND_AGID:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_AGID\\n\");\n\t\tcgc.quiet = 1;\n\t\tsetup_report_key(&cgc, ai->lsa.agid, 0);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lsa.agid = buf[7] >> 6;\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\tcase DVD_LU_SEND_KEY1:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_KEY1\\n\");\n\t\tsetup_report_key(&cgc, ai->lsk.agid, 2);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tcopy_key(ai->lsk.key, &buf[4]);\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\tcase DVD_LU_SEND_CHALLENGE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_CHALLENGE\\n\");\n\t\tsetup_report_key(&cgc, ai->lsc.agid, 1);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tcopy_chal(ai->lsc.chal, &buf[4]);\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\t/* Post-auth key */\n\tcase DVD_LU_SEND_TITLE_KEY:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_TITLE_KEY\\n\");\n\t\tcgc.quiet = 1;\n\t\tsetup_report_key(&cgc, ai->lstk.agid, 4);\n\t\tcgc.cmd[5] = ai->lstk.lba;\n\t\tcgc.cmd[4] = ai->lstk.lba >> 8;\n\t\tcgc.cmd[3] = ai->lstk.lba >> 16;\n\t\tcgc.cmd[2] = ai->lstk.lba >> 24;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lstk.cpm = (buf[4] >> 7) & 1;\n\t\tai->lstk.cp_sec = (buf[4] >> 6) & 1;\n\t\tai->lstk.cgms = (buf[4] >> 4) & 3;\n\t\tcopy_key(ai->lstk.title_key, &buf[5]);\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\tcase DVD_LU_SEND_ASF:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_ASF\\n\");\n\t\tsetup_report_key(&cgc, ai->lsasf.agid, 5);\n\t\t\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lsasf.asf = buf[7] & 1;\n\t\tbreak;\n\n\t/* LU data receive (LU changes state) */\n\tcase DVD_HOST_SEND_CHALLENGE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_CHALLENGE\\n\");\n\t\tsetup_send_key(&cgc, ai->hsc.agid, 1);\n\t\tbuf[1] = 0xe;\n\t\tcopy_chal(&buf[4], ai->hsc.chal);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->type = DVD_LU_SEND_KEY1;\n\t\tbreak;\n\n\tcase DVD_HOST_SEND_KEY2:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_KEY2\\n\");\n\t\tsetup_send_key(&cgc, ai->hsk.agid, 3);\n\t\tbuf[1] = 0xa;\n\t\tcopy_key(&buf[4], ai->hsk.key);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc))) {\n\t\t\tai->type = DVD_AUTH_FAILURE;\n\t\t\treturn ret;\n\t\t}\n\t\tai->type = DVD_AUTH_ESTABLISHED;\n\t\tbreak;\n\n\t/* Misc */\n\tcase DVD_INVALIDATE_AGID:\n\t\tcgc.quiet = 1;\n\t\tcd_dbg(CD_DVD, \"entering DVD_INVALIDATE_AGID\\n\");\n\t\tsetup_report_key(&cgc, ai->lsa.agid, 0x3f);\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\t\tbreak;\n\n\t/* Get region settings */\n\tcase DVD_LU_SEND_RPC_STATE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_RPC_STATE\\n\");\n\t\tsetup_report_key(&cgc, 0, 8);\n\t\tmemset(&rpc_state, 0, sizeof(rpc_state_t));\n\t\tcgc.buffer = (char *) &rpc_state;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lrpcs.type = rpc_state.type_code;\n\t\tai->lrpcs.vra = rpc_state.vra;\n\t\tai->lrpcs.ucca = rpc_state.ucca;\n\t\tai->lrpcs.region_mask = rpc_state.region_mask;\n\t\tai->lrpcs.rpc_scheme = rpc_state.rpc_scheme;\n\t\tbreak;\n\n\t/* Set region settings */\n\tcase DVD_HOST_SEND_RPC_STATE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_RPC_STATE\\n\");\n\t\tsetup_send_key(&cgc, 0, 6);\n\t\tbuf[1] = 6;\n\t\tbuf[4] = ai->hrpcs.pdrc;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\tcd_dbg(CD_WARNING, \"Invalid DVD key ioctl (%d)\\n\", ai->type);\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvd_read_physical(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tunsigned char buf[21], *base;\n\tstruct dvd_layer *layer;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint ret, layer_num = s->physical.layer_num;\n\n\tif (layer_num >= DVD_LAYERS)\n\t\treturn -EINVAL;\n\n\tinit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[6] = layer_num;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\t/*\n\t * refrain from reporting errors on non-existing layers (mainly)\n\t */\n\tcgc->quiet = 1;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tbase = &buf[4];\n\tlayer = &s->physical.layer[layer_num];\n\n\t/*\n\t * place the data... really ugly, but at least we won't have to\n\t * worry about endianess in userspace.\n\t */\n\tmemset(layer, 0, sizeof(*layer));\n\tlayer->book_version = base[0] & 0xf;\n\tlayer->book_type = base[0] >> 4;\n\tlayer->min_rate = base[1] & 0xf;\n\tlayer->disc_size = base[1] >> 4;\n\tlayer->layer_type = base[2] & 0xf;\n\tlayer->track_path = (base[2] >> 4) & 1;\n\tlayer->nlayers = (base[2] >> 5) & 3;\n\tlayer->track_density = base[3] & 0xf;\n\tlayer->linear_density = base[3] >> 4;\n\tlayer->start_sector = base[5] << 16 | base[6] << 8 | base[7];\n\tlayer->end_sector = base[9] << 16 | base[10] << 8 | base[11];\n\tlayer->end_sector_l0 = base[13] << 16 | base[14] << 8 | base[15];\n\tlayer->bca = base[16] >> 7;\n\n\treturn 0;\n}\n\nstatic int dvd_read_copyright(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret;\n\tu_char buf[8];\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tinit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[6] = s->copyright.layer_num;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = cgc->buflen >> 8;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\treturn ret;\n\n\ts->copyright.cpst = buf[4];\n\ts->copyright.rmi = buf[5];\n\n\treturn 0;\n}\n\nstatic int dvd_read_disckey(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret, size;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tsize = sizeof(s->disckey.value) + 4;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = size >> 8;\n\tcgc->cmd[9] = size & 0xff;\n\tcgc->cmd[10] = s->disckey.agid << 6;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (!ret)\n\t\tmemcpy(s->disckey.value, &buf[4], sizeof(s->disckey.value));\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\tstruct packet_command *cgc)\n{\n\tint ret, size = 4 + 188;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\ts->bca.len = buf[0] << 8 | buf[1];\n\tif (s->bca.len < 12 || s->bca.len > 188) {\n\t\tcd_dbg(CD_WARNING, \"Received invalid BCA length (%d)\\n\",\n\t\t       s->bca.len);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(s->bca.value, &buf[4], s->bca.len);\n\tret = 0;\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_manufact(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret = 0, size;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tsize = sizeof(s->manufact.value) + 4;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = size >> 8;\n\tcgc->cmd[9] = size & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\ts->manufact.len = buf[0] << 8 | buf[1];\n\tif (s->manufact.len < 0) {\n\t\tcd_dbg(CD_WARNING, \"Received invalid manufacture info length (%d)\\n\",\n\t\t       s->manufact.len);\n\t\tret = -EIO;\n\t} else {\n\t\tif (s->manufact.len > 2048) {\n\t\t\tcd_dbg(CD_WARNING, \"Received invalid manufacture info length (%d): truncating to 2048\\n\",\n\t\t\t       s->manufact.len);\n\t\t\ts->manufact.len = 2048;\n\t\t}\n\t\tmemcpy(s->manufact.value, &buf[4], s->manufact.len);\n\t}\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_struct(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tswitch (s->type) {\n\tcase DVD_STRUCT_PHYSICAL:\n\t\treturn dvd_read_physical(cdi, s, cgc);\n\n\tcase DVD_STRUCT_COPYRIGHT:\n\t\treturn dvd_read_copyright(cdi, s, cgc);\n\n\tcase DVD_STRUCT_DISCKEY:\n\t\treturn dvd_read_disckey(cdi, s, cgc);\n\n\tcase DVD_STRUCT_BCA:\n\t\treturn dvd_read_bca(cdi, s, cgc);\n\n\tcase DVD_STRUCT_MANUFACT:\n\t\treturn dvd_read_manufact(cdi, s, cgc);\n\t\t\n\tdefault:\n\t\tcd_dbg(CD_WARNING, \": Invalid DVD structure read requested (%d)\\n\",\n\t\t       s->type);\n\t\treturn -EINVAL;\n\t}\n}\n\nint cdrom_mode_sense(struct cdrom_device_info *cdi,\n\t\t     struct packet_command *cgc,\n\t\t     int page_code, int page_control)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(cgc->cmd, 0, sizeof(cgc->cmd));\n\n\tcgc->cmd[0] = GPCMD_MODE_SENSE_10;\n\tcgc->cmd[2] = page_code | (page_control << 6);\n\tcgc->cmd[7] = cgc->buflen >> 8;\n\tcgc->cmd[8] = cgc->buflen & 0xff;\n\tcgc->data_direction = CGC_DATA_READ;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nint cdrom_mode_select(struct cdrom_device_info *cdi,\n\t\t      struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(cgc->cmd, 0, sizeof(cgc->cmd));\n\tmemset(cgc->buffer, 0, 2);\n\tcgc->cmd[0] = GPCMD_MODE_SELECT_10;\n\tcgc->cmd[1] = 0x10;\t\t/* PF */\n\tcgc->cmd[7] = cgc->buflen >> 8;\n\tcgc->cmd[8] = cgc->buflen & 0xff;\n\tcgc->data_direction = CGC_DATA_WRITE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic int cdrom_read_subchannel(struct cdrom_device_info *cdi,\n\t\t\t\t struct cdrom_subchnl *subchnl, int mcn)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tchar buffer[32];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, 16, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\n\tcgc.cmd[1] = subchnl->cdsc_format;/* MSF or LBA addressing */\n\tcgc.cmd[2] = 0x40;  /* request subQ data */\n\tcgc.cmd[3] = mcn ? 2 : 1;\n\tcgc.cmd[8] = 16;\n\n\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tsubchnl->cdsc_audiostatus = cgc.buffer[1];\n\tsubchnl->cdsc_ctrl = cgc.buffer[5] & 0xf;\n\tsubchnl->cdsc_trk = cgc.buffer[6];\n\tsubchnl->cdsc_ind = cgc.buffer[7];\n\n\tif (subchnl->cdsc_format == CDROM_LBA) {\n\t\tsubchnl->cdsc_absaddr.lba = ((cgc.buffer[8] << 24) |\n\t\t\t\t\t\t(cgc.buffer[9] << 16) |\n\t\t\t\t\t\t(cgc.buffer[10] << 8) |\n\t\t\t\t\t\t(cgc.buffer[11]));\n\t\tsubchnl->cdsc_reladdr.lba = ((cgc.buffer[12] << 24) |\n\t\t\t\t\t\t(cgc.buffer[13] << 16) |\n\t\t\t\t\t\t(cgc.buffer[14] << 8) |\n\t\t\t\t\t\t(cgc.buffer[15]));\n\t} else {\n\t\tsubchnl->cdsc_reladdr.msf.minute = cgc.buffer[13];\n\t\tsubchnl->cdsc_reladdr.msf.second = cgc.buffer[14];\n\t\tsubchnl->cdsc_reladdr.msf.frame = cgc.buffer[15];\n\t\tsubchnl->cdsc_absaddr.msf.minute = cgc.buffer[9];\n\t\tsubchnl->cdsc_absaddr.msf.second = cgc.buffer[10];\n\t\tsubchnl->cdsc_absaddr.msf.frame = cgc.buffer[11];\n\t}\n\n\treturn 0;\n}\n\n/*\n * Specific READ_10 interface\n */\nstatic int cdrom_read_cd(struct cdrom_device_info *cdi,\n\t\t\t struct packet_command *cgc, int lba,\n\t\t\t int blocksize, int nblocks)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\n\tcgc->cmd[0] = GPCMD_READ_10;\n\tcgc->cmd[2] = (lba >> 24) & 0xff;\n\tcgc->cmd[3] = (lba >> 16) & 0xff;\n\tcgc->cmd[4] = (lba >>  8) & 0xff;\n\tcgc->cmd[5] = lba & 0xff;\n\tcgc->cmd[6] = (nblocks >> 16) & 0xff;\n\tcgc->cmd[7] = (nblocks >>  8) & 0xff;\n\tcgc->cmd[8] = nblocks & 0xff;\n\tcgc->buflen = blocksize * nblocks;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\n/* very generic interface for reading the various types of blocks */\nstatic int cdrom_read_block(struct cdrom_device_info *cdi,\n\t\t\t    struct packet_command *cgc,\n\t\t\t    int lba, int nblocks, int format, int blksize)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\n\tcgc->cmd[0] = GPCMD_READ_CD;\n\t/* expected sector size - cdda,mode1,etc. */\n\tcgc->cmd[1] = format << 2;\n\t/* starting address */\n\tcgc->cmd[2] = (lba >> 24) & 0xff;\n\tcgc->cmd[3] = (lba >> 16) & 0xff;\n\tcgc->cmd[4] = (lba >>  8) & 0xff;\n\tcgc->cmd[5] = lba & 0xff;\n\t/* number of blocks */\n\tcgc->cmd[6] = (nblocks >> 16) & 0xff;\n\tcgc->cmd[7] = (nblocks >>  8) & 0xff;\n\tcgc->cmd[8] = nblocks & 0xff;\n\tcgc->buflen = blksize * nblocks;\n\t\n\t/* set the header info returned */\n\tswitch (blksize) {\n\tcase CD_FRAMESIZE_RAW0\t: cgc->cmd[9] = 0x58; break;\n\tcase CD_FRAMESIZE_RAW1\t: cgc->cmd[9] = 0x78; break;\n\tcase CD_FRAMESIZE_RAW\t: cgc->cmd[9] = 0xf8; break;\n\tdefault\t\t\t: cgc->cmd[9] = 0x10;\n\t}\n\t\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic int cdrom_read_cdda_old(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t       int lba, int nframes)\n{\n\tstruct packet_command cgc;\n\tint ret = 0;\n\tint nr;\n\n\tcdi->last_sense = 0;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\n\t/*\n\t * start with will ra.nframes size, back down if alloc fails\n\t */\n\tnr = nframes;\n\tdo {\n\t\tcgc.buffer = kmalloc_array(nr, CD_FRAMESIZE_RAW, GFP_KERNEL);\n\t\tif (cgc.buffer)\n\t\t\tbreak;\n\n\t\tnr >>= 1;\n\t} while (nr);\n\n\tif (!nr)\n\t\treturn -ENOMEM;\n\n\tcgc.data_direction = CGC_DATA_READ;\n\twhile (nframes > 0) {\n\t\tif (nr > nframes)\n\t\t\tnr = nframes;\n\n\t\tret = cdrom_read_block(cdi, &cgc, lba, nr, 1, CD_FRAMESIZE_RAW);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (copy_to_user(ubuf, cgc.buffer, CD_FRAMESIZE_RAW * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tubuf += CD_FRAMESIZE_RAW * nr;\n\t\tnframes -= nr;\n\t\tlba += nr;\n\t}\n\tkfree(cgc.buffer);\n\treturn ret;\n}\n\nstatic int cdrom_read_cdda_bpc(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t       int lba, int nframes)\n{\n\tstruct request_queue *q = cdi->disk->queue;\n\tstruct request *rq;\n\tstruct scsi_request *req;\n\tstruct bio *bio;\n\tunsigned int len;\n\tint nr, ret = 0;\n\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tif (!blk_queue_scsi_passthrough(q)) {\n\t\tWARN_ONCE(true,\n\t\t\t  \"Attempt read CDDA info through a non-SCSI queue\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcdi->last_sense = 0;\n\n\twhile (nframes) {\n\t\tnr = nframes;\n\t\tif (cdi->cdda_method == CDDA_BPC_SINGLE)\n\t\t\tnr = 1;\n\t\tif (nr * CD_FRAMESIZE_RAW > (queue_max_sectors(q) << 9))\n\t\t\tnr = (queue_max_sectors(q) << 9) / CD_FRAMESIZE_RAW;\n\n\t\tlen = nr * CD_FRAMESIZE_RAW;\n\n\t\trq = blk_get_request(q, REQ_OP_SCSI_IN, 0);\n\t\tif (IS_ERR(rq)) {\n\t\t\tret = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\t\treq = scsi_req(rq);\n\n\t\tret = blk_rq_map_user(q, rq, NULL, ubuf, len, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tblk_put_request(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\treq->cmd[0] = GPCMD_READ_CD;\n\t\treq->cmd[1] = 1 << 2;\n\t\treq->cmd[2] = (lba >> 24) & 0xff;\n\t\treq->cmd[3] = (lba >> 16) & 0xff;\n\t\treq->cmd[4] = (lba >>  8) & 0xff;\n\t\treq->cmd[5] = lba & 0xff;\n\t\treq->cmd[6] = (nr >> 16) & 0xff;\n\t\treq->cmd[7] = (nr >>  8) & 0xff;\n\t\treq->cmd[8] = nr & 0xff;\n\t\treq->cmd[9] = 0xf8;\n\n\t\treq->cmd_len = 12;\n\t\trq->timeout = 60 * HZ;\n\t\tbio = rq->bio;\n\n\t\tblk_execute_rq(q, cdi->disk, rq, 0);\n\t\tif (scsi_req(rq)->result) {\n\t\t\tstruct scsi_sense_hdr sshdr;\n\n\t\t\tret = -EIO;\n\t\t\tscsi_normalize_sense(req->sense, req->sense_len,\n\t\t\t\t\t     &sshdr);\n\t\t\tcdi->last_sense = sshdr.sense_key;\n\t\t}\n\n\t\tif (blk_rq_unmap_user(bio))\n\t\t\tret = -EFAULT;\n\t\tblk_put_request(rq);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnframes -= nr;\n\t\tlba += nr;\n\t\tubuf += len;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdrom_read_cdda(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t   int lba, int nframes)\n{\n\tint ret;\n\n\tif (cdi->cdda_method == CDDA_OLD)\n\t\treturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\n\nretry:\n\t/*\n\t * for anything else than success and io error, we need to retry\n\t */\n\tret = cdrom_read_cdda_bpc(cdi, ubuf, lba, nframes);\n\tif (!ret || ret != -EIO)\n\t\treturn ret;\n\n\t/*\n\t * I've seen drives get sense 4/8/3 udma crc errors on multi\n\t * frame dma, so drop to single frame dma if we need to\n\t */\n\tif (cdi->cdda_method == CDDA_BPC_FULL && nframes > 1) {\n\t\tpr_info(\"dropping to single frame dma\\n\");\n\t\tcdi->cdda_method = CDDA_BPC_SINGLE;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * so we have an io error of some sort with multi frame dma. if the\n\t * condition wasn't a hardware error\n\t * problems, not for any error\n\t */\n\tif (cdi->last_sense != 0x04 && cdi->last_sense != 0x0b)\n\t\treturn ret;\n\n\tpr_info(\"dropping to old style cdda (sense=%x)\\n\", cdi->last_sense);\n\tcdi->cdda_method = CDDA_OLD;\n\treturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\t\n}\n\nstatic int cdrom_ioctl_multisession(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_multisession ms_info;\n\tu8 requested_format;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMMULTISESSION\\n\");\n\n\tif (!(cdi->ops->capability & CDC_MULTI_SESSION))\n\t\treturn -ENOSYS;\n\n\tif (copy_from_user(&ms_info, argp, sizeof(ms_info)))\n\t\treturn -EFAULT;\n\n\trequested_format = ms_info.addr_format;\n\tif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\n\t\treturn -EINVAL;\n\tms_info.addr_format = CDROM_LBA;\n\n\tret = cdi->ops->get_last_session(cdi, &ms_info);\n\tif (ret)\n\t\treturn ret;\n\n\tsanitize_format(&ms_info.addr, &ms_info.addr_format, requested_format);\n\n\tif (copy_to_user(argp, &ms_info, sizeof(ms_info)))\n\t\treturn -EFAULT;\n\n\tcd_dbg(CD_DO_IOCTL, \"CDROMMULTISESSION successful\\n\");\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_eject(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->use_count != 1 || cdi->keeplocked)\n\t\treturn -EBUSY;\n\tif (CDROM_CAN(CDC_LOCK)) {\n\t\tint ret = cdi->ops->lock_door(cdi, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn cdi->ops->tray_move(cdi, 1);\n}\n\nstatic int cdrom_ioctl_closetray(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMCLOSETRAY\\n\");\n\n\tif (!CDROM_CAN(CDC_CLOSE_TRAY))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->tray_move(cdi, 0);\n}\n\nstatic int cdrom_ioctl_eject_sw(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT_SW\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->keeplocked)\n\t\treturn -EBUSY;\n\n\tcdi->options &= ~(CDO_AUTO_CLOSE | CDO_AUTO_EJECT);\n\tif (arg)\n\t\tcdi->options |= CDO_AUTO_CLOSE | CDO_AUTO_EJECT;\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\n\t/* cannot select disc or select current disc */\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\n\tif (arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}\n\nstatic int cdrom_ioctl_set_options(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SET_OPTIONS\\n\");\n\n\t/*\n\t * Options need to be in sync with capability.\n\t * Too late for that, so we have to check each one separately.\n\t */\n\tswitch (arg) {\n\tcase CDO_USE_FFLAGS:\n\tcase CDO_CHECK_TYPE:\n\t\tbreak;\n\tcase CDO_LOCK:\n\t\tif (!CDROM_CAN(CDC_LOCK))\n\t\t\treturn -ENOSYS;\n\t\tbreak;\n\tcase 0:\n\t\treturn cdi->options;\n\t/* default is basically CDO_[AUTO_CLOSE|AUTO_EJECT] */\n\tdefault:\n\t\tif (!CDROM_CAN(arg))\n\t\t\treturn -ENOSYS;\n\t}\n\tcdi->options |= (int) arg;\n\treturn cdi->options;\n}\n\nstatic int cdrom_ioctl_clear_options(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_CLEAR_OPTIONS\\n\");\n\n\tcdi->options &= ~(int) arg;\n\treturn cdi->options;\n}\n\nstatic int cdrom_ioctl_select_speed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_SPEED\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_SPEED))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->select_speed(cdi, arg);\n}\n\nstatic int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n\nstatic int cdrom_ioctl_reset(struct cdrom_device_info *cdi,\n\t\tstruct block_device *bdev)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_RESET\\n\");\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!CDROM_CAN(CDC_RESET))\n\t\treturn -ENOSYS;\n\tinvalidate_bdev(bdev);\n\treturn cdi->ops->reset(cdi);\n}\n\nstatic int cdrom_ioctl_lock_door(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"%socking door\\n\", arg ? \"L\" : \"Unl\");\n\n\tif (!CDROM_CAN(CDC_LOCK))\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tcdi->keeplocked = arg ? 1 : 0;\n\n\t/*\n\t * Don't unlock the door on multiple opens by default, but allow\n\t * root to do so.\n\t */\n\tif (cdi->use_count != 1 && !arg && !capable(CAP_SYS_ADMIN))\n\t\treturn -EBUSY;\n\treturn cdi->ops->lock_door(cdi, arg);\n}\n\nstatic int cdrom_ioctl_debug(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"%sabling debug\\n\", arg ? \"En\" : \"Dis\");\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tdebug = arg ? 1 : 0;\n\treturn debug;\n}\n\nstatic int cdrom_ioctl_get_capability(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_GET_CAPABILITY\\n\");\n\treturn (cdi->ops->capability & ~cdi->mask);\n}\n\n/*\n * The following function is implemented, although very few audio\n * discs give Universal Product Code information, which should just be\n * the Medium Catalog Number on the box.  Note, that the way the code\n * is written on the CD is /not/ uniform across all discs!\n */\nstatic int cdrom_ioctl_get_mcn(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_mcn mcn;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_GET_MCN\\n\");\n\n\tif (!(cdi->ops->capability & CDC_MCN))\n\t\treturn -ENOSYS;\n\tret = cdi->ops->get_mcn(cdi, &mcn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &mcn, sizeof(mcn)))\n\t\treturn -EFAULT;\n\tcd_dbg(CD_DO_IOCTL, \"CDROM_GET_MCN successful\\n\");\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}\n\n/*\n * Ok, this is where problems start.  The current interface for the\n * CDROM_DISC_STATUS ioctl is flawed.  It makes the false assumption that\n * CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.  Unfortunately, while this\n * is often the case, it is also very common for CDs to have some tracks\n * with data, and some tracks with audio.  Just because I feel like it,\n * I declare the following to be the best way to cope.  If the CD has ANY\n * data tracks on it, it will be returned as a data CD.  If it has any XA\n * tracks, I will return it as that.  Now I could simplify this interface\n * by combining these  returns with the above, but this more clearly\n * demonstrates the problem with the current interface.  Too bad this\n * wasn't designed to use bitmasks...         -Erik\n *\n * Well, now we have the option CDS_MIXED: a mixed-type CD.\n * User level programmers might feel the ioctl is not very useful.\n *\t\t\t\t\t---david\n */\nstatic int cdrom_ioctl_disc_status(struct cdrom_device_info *cdi)\n{\n\ttracktype tracks;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DISC_STATUS\\n\");\n\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error)\n\t\treturn tracks.error;\n\n\t/* Policy mode on */\n\tif (tracks.audio > 0) {\n\t\tif (!tracks.data && !tracks.cdi && !tracks.xa)\n\t\t\treturn CDS_AUDIO;\n\t\telse\n\t\t\treturn CDS_MIXED;\n\t}\n\n\tif (tracks.cdi > 0)\n\t\treturn CDS_XA_2_2;\n\tif (tracks.xa > 0)\n\t\treturn CDS_XA_2_1;\n\tif (tracks.data > 0)\n\t\treturn CDS_DATA_1;\n\t/* Policy mode off */\n\n\tcd_dbg(CD_WARNING, \"This disc doesn't have any tracks I recognize!\\n\");\n\treturn CDS_NO_INFO;\n}\n\nstatic int cdrom_ioctl_changer_nslots(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_CHANGER_NSLOTS\\n\");\n\treturn cdi->capacity;\n}\n\nstatic int cdrom_ioctl_get_subchnl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_subchnl q;\n\tu8 requested, back;\n\tint ret;\n\n\t/* cd_dbg(CD_DO_IOCTL,\"entering CDROMSUBCHNL\\n\");*/\n\n\tif (copy_from_user(&q, argp, sizeof(q)))\n\t\treturn -EFAULT;\n\n\trequested = q.cdsc_format;\n\tif (requested != CDROM_MSF && requested != CDROM_LBA)\n\t\treturn -EINVAL;\n\tq.cdsc_format = CDROM_MSF;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMSUBCHNL, &q);\n\tif (ret)\n\t\treturn ret;\n\n\tback = q.cdsc_format; /* local copy */\n\tsanitize_format(&q.cdsc_absaddr, &back, requested);\n\tsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\n\n\tif (copy_to_user(argp, &q, sizeof(q)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMSUBCHNL successful\\n\"); */\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_read_tochdr(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_tochdr header;\n\tint ret;\n\n\t/* cd_dbg(CD_DO_IOCTL, \"entering CDROMREADTOCHDR\\n\"); */\n\n\tif (copy_from_user(&header, argp, sizeof(header)))\n\t\treturn -EFAULT;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &header, sizeof(header)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMREADTOCHDR successful\\n\"); */\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_read_tocentry(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_tocentry entry;\n\tu8 requested_format;\n\tint ret;\n\n\t/* cd_dbg(CD_DO_IOCTL, \"entering CDROMREADTOCENTRY\\n\"); */\n\n\tif (copy_from_user(&entry, argp, sizeof(entry)))\n\t\treturn -EFAULT;\n\n\trequested_format = entry.cdte_format;\n\tif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\n\t\treturn -EINVAL;\n\t/* make interface to low-level uniform */\n\tentry.cdte_format = CDROM_MSF;\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry);\n\tif (ret)\n\t\treturn ret;\n\tsanitize_format(&entry.cdte_addr, &entry.cdte_format, requested_format);\n\n\tif (copy_to_user(argp, &entry, sizeof(entry)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMREADTOCENTRY successful\\n\"); */\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_play_msf(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_msf msf;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYMSF\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&msf, argp, sizeof(msf)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMPLAYMSF, &msf);\n}\n\nstatic int cdrom_ioctl_play_trkind(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_ti ti;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYTRKIND\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&ti, argp, sizeof(ti)))\n\t\treturn -EFAULT;\n\n\tret = check_for_audio_disc(cdi, cdi->ops);\n\tif (ret)\n\t\treturn ret;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMPLAYTRKIND, &ti);\n}\nstatic int cdrom_ioctl_volctrl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLCTRL\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&volume, argp, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMVOLCTRL, &volume);\n}\n\nstatic int cdrom_ioctl_volread(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLREAD\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMVOLREAD, &volume);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &volume, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_audioctl(struct cdrom_device_info *cdi,\n\t\tunsigned int cmd)\n{\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"doing audio ioctl (start/stop/pause/resume)\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tret = check_for_audio_disc(cdi, cdi->ops);\n\tif (ret)\n\t\treturn ret;\n\treturn cdi->ops->audio_ioctl(cdi, cmd, NULL);\n}\n\n/*\n * Required when we need to use READ_10 to issue other than 2048 block\n * reads\n */\nstatic int cdrom_switch_blocksize(struct cdrom_device_info *cdi, int size)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tstruct modesel_head mh;\n\n\tmemset(&mh, 0, sizeof(mh));\n\tmh.block_desc_length = 0x08;\n\tmh.block_length_med = (size >> 8) & 0xff;\n\tmh.block_length_lo = size & 0xff;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\tcgc.cmd[0] = 0x15;\n\tcgc.cmd[1] = 1 << 4;\n\tcgc.cmd[4] = 12;\n\tcgc.buflen = sizeof(mh);\n\tcgc.buffer = (char *) &mh;\n\tcgc.data_direction = CGC_DATA_WRITE;\n\tmh.block_desc_length = 0x08;\n\tmh.block_length_med = (size >> 8) & 0xff;\n\tmh.block_length_lo = size & 0xff;\n\n\treturn cdo->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_get_track_info(struct cdrom_device_info *cdi,\n\t\t\t\t__u16 track, __u8 type, track_information *ti)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tint ret, buflen;\n\n\tinit_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;\n\tcgc.cmd[1] = type & 3;\n\tcgc.cmd[4] = (track & 0xff00) >> 8;\n\tcgc.cmd[5] = track & 0xff;\n\tcgc.cmd[8] = 8;\n\tcgc.quiet = 1;\n\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tbuflen = be16_to_cpu(ti->track_information_length) +\n\t\tsizeof(ti->track_information_length);\n\n\tif (buflen > sizeof(track_information))\n\t\tbuflen = sizeof(track_information);\n\n\tcgc.cmd[8] = cgc.buflen = buflen;\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* return actual fill size */\n\treturn buflen;\n}\n\n/* return the last written block on the CD-R media. this is for the udf\n   file system. */\nint cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written)\n{\n\tstruct cdrom_tocentry toc;\n\tdisc_information di;\n\ttrack_information ti;\n\t__u32 last_track;\n\tint ret = -1, ti_size;\n\n\tif (!CDROM_CAN(CDC_GENERIC_PACKET))\n\t\tgoto use_toc;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < (int)(offsetof(typeof(di), last_track_lsb)\n\t\t\t+ sizeof(di.last_track_lsb)))\n\t\tgoto use_toc;\n\n\t/* if unit didn't return msb, it's zeroed by cdrom_get_disc_info */\n\tlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\n\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\tif (ti_size < (int)offsetof(typeof(ti), track_start))\n\t\tgoto use_toc;\n\n\t/* if this track is blank, try the previous. */\n\tif (ti.blank) {\n\t\tif (last_track == 1)\n\t\t\tgoto use_toc;\n\t\tlast_track--;\n\t\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\t}\n\n\tif (ti_size < (int)(offsetof(typeof(ti), track_size)\n\t\t\t\t+ sizeof(ti.track_size)))\n\t\tgoto use_toc;\n\n\t/* if last recorded field is valid, return it. */\n\tif (ti.lra_v && ti_size >= (int)(offsetof(typeof(ti), last_rec_address)\n\t\t\t\t+ sizeof(ti.last_rec_address))) {\n\t\t*last_written = be32_to_cpu(ti.last_rec_address);\n\t} else {\n\t\t/* make it up instead */\n\t\t*last_written = be32_to_cpu(ti.track_start) +\n\t\t\t\tbe32_to_cpu(ti.track_size);\n\t\tif (ti.free_blocks)\n\t\t\t*last_written -= (be32_to_cpu(ti.free_blocks) + 7);\n\t}\n\treturn 0;\n\n\t/* this is where we end up if the drive either can't do a\n\t   GPCMD_READ_DISC_INFO or GPCMD_READ_TRACK_RZONE_INFO or if\n\t   it doesn't give enough information or fails. then we return\n\t   the toc contents. */\nuse_toc:\n\ttoc.cdte_format = CDROM_MSF;\n\ttoc.cdte_track = CDROM_LEADOUT;\n\tif ((ret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &toc)))\n\t\treturn ret;\n\tsanitize_format(&toc.cdte_addr, &toc.cdte_format, CDROM_LBA);\n\t*last_written = toc.cdte_addr.lba;\n\treturn 0;\n}\n\n/* return the next writable block. also for udf file system. */\nstatic int cdrom_get_next_writable(struct cdrom_device_info *cdi,\n\t\t\t\t   long *next_writable)\n{\n\tdisc_information di;\n\ttrack_information ti;\n\t__u16 last_track;\n\tint ret, ti_size;\n\n\tif (!CDROM_CAN(CDC_GENERIC_PACKET))\n\t\tgoto use_last_written;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di), last_track_lsb)\n\t\t\t\t+ sizeof(di.last_track_lsb))\n\t\tgoto use_last_written;\n\n\t/* if unit didn't return msb, it's zeroed by cdrom_get_disc_info */\n\tlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\n\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\tif (ti_size < 0 || ti_size < offsetof(typeof(ti), track_start))\n\t\tgoto use_last_written;\n\n\t/* if this track is blank, try the previous. */\n\tif (ti.blank) {\n\t\tif (last_track == 1)\n\t\t\tgoto use_last_written;\n\t\tlast_track--;\n\t\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\t\tif (ti_size < 0)\n\t\t\tgoto use_last_written;\n\t}\n\n\t/* if next recordable address field is valid, use it. */\n\tif (ti.nwa_v && ti_size >= offsetof(typeof(ti), next_writable)\n\t\t\t\t+ sizeof(ti.next_writable)) {\n\t\t*next_writable = be32_to_cpu(ti.next_writable);\n\t\treturn 0;\n\t}\n\nuse_last_written:\n\tret = cdrom_get_last_written(cdi, next_writable);\n\tif (ret) {\n\t\t*next_writable = 0;\n\t\treturn ret;\n\t} else {\n\t\t*next_writable += 7;\n\t\treturn 0;\n\t}\n}\n\nstatic noinline int mmc_ioctl_cdrom_read_data(struct cdrom_device_info *cdi,\n\t\t\t\t\t      void __user *arg,\n\t\t\t\t\t      struct packet_command *cgc,\n\t\t\t\t\t      int cmd)\n{\n\tstruct scsi_sense_hdr sshdr;\n\tstruct cdrom_msf msf;\n\tint blocksize = 0, format = 0, lba;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase CDROMREADRAW:\n\t\tblocksize = CD_FRAMESIZE_RAW;\n\t\tbreak;\n\tcase CDROMREADMODE1:\n\t\tblocksize = CD_FRAMESIZE;\n\t\tformat = 2;\n\t\tbreak;\n\tcase CDROMREADMODE2:\n\t\tblocksize = CD_FRAMESIZE_RAW0;\n\t\tbreak;\n\t}\n\tif (copy_from_user(&msf, (struct cdrom_msf __user *)arg, sizeof(msf)))\n\t\treturn -EFAULT;\n\tlba = msf_to_lba(msf.cdmsf_min0, msf.cdmsf_sec0, msf.cdmsf_frame0);\n\t/* FIXME: we need upper bound checking, too!! */\n\tif (lba < 0)\n\t\treturn -EINVAL;\n\n\tcgc->buffer = kzalloc(blocksize, GFP_KERNEL);\n\tif (cgc->buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(&sshdr, 0, sizeof(sshdr));\n\tcgc->sshdr = &sshdr;\n\tcgc->data_direction = CGC_DATA_READ;\n\tret = cdrom_read_block(cdi, cgc, lba, 1, format, blocksize);\n\tif (ret && sshdr.sense_key == 0x05 &&\n\t    sshdr.asc == 0x20 &&\n\t    sshdr.ascq == 0x00) {\n\t\t/*\n\t\t * SCSI-II devices are not required to support\n\t\t * READ_CD, so let's try switching block size\n\t\t */\n\t\t/* FIXME: switch back again... */\n\t\tret = cdrom_switch_blocksize(cdi, blocksize);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcgc->sshdr = NULL;\n\t\tret = cdrom_read_cd(cdi, cgc, lba, blocksize, 1);\n\t\tret |= cdrom_switch_blocksize(cdi, blocksize);\n\t}\n\tif (!ret && copy_to_user(arg, cgc->buffer, blocksize))\n\t\tret = -EFAULT;\nout:\n\tkfree(cgc->buffer);\n\treturn ret;\n}\n\nstatic noinline int mmc_ioctl_cdrom_read_audio(struct cdrom_device_info *cdi,\n\t\t\t\t\t       void __user *arg)\n{\n\tstruct cdrom_read_audio ra;\n\tint lba;\n\n\tif (copy_from_user(&ra, (struct cdrom_read_audio __user *)arg,\n\t\t\t   sizeof(ra)))\n\t\treturn -EFAULT;\n\n\tif (ra.addr_format == CDROM_MSF)\n\t\tlba = msf_to_lba(ra.addr.msf.minute,\n\t\t\t\t ra.addr.msf.second,\n\t\t\t\t ra.addr.msf.frame);\n\telse if (ra.addr_format == CDROM_LBA)\n\t\tlba = ra.addr.lba;\n\telse\n\t\treturn -EINVAL;\n\n\t/* FIXME: we need upper bound checking, too!! */\n\tif (lba < 0 || ra.nframes <= 0 || ra.nframes > CD_FRAMES)\n\t\treturn -EINVAL;\n\n\treturn cdrom_read_cdda(cdi, ra.buf, lba, ra.nframes);\n}\n\nstatic noinline int mmc_ioctl_cdrom_subchannel(struct cdrom_device_info *cdi,\n\t\t\t\t\t       void __user *arg)\n{\n\tint ret;\n\tstruct cdrom_subchnl q;\n\tu_char requested, back;\n\tif (copy_from_user(&q, (struct cdrom_subchnl __user *)arg, sizeof(q)))\n\t\treturn -EFAULT;\n\trequested = q.cdsc_format;\n\tif (!((requested == CDROM_MSF) ||\n\t      (requested == CDROM_LBA)))\n\t\treturn -EINVAL;\n\n\tret = cdrom_read_subchannel(cdi, &q, 0);\n\tif (ret)\n\t\treturn ret;\n\tback = q.cdsc_format; /* local copy */\n\tsanitize_format(&q.cdsc_absaddr, &back, requested);\n\tsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\n\tif (copy_to_user((struct cdrom_subchnl __user *)arg, &q, sizeof(q)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMSUBCHNL successful\\n\"); */\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_play_msf(struct cdrom_device_info *cdi,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct cdrom_msf msf;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYMSF\\n\");\n\tif (copy_from_user(&msf, (struct cdrom_msf __user *)arg, sizeof(msf)))\n\t\treturn -EFAULT;\n\tcgc->cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc->cmd[3] = msf.cdmsf_min0;\n\tcgc->cmd[4] = msf.cdmsf_sec0;\n\tcgc->cmd[5] = msf.cdmsf_frame0;\n\tcgc->cmd[6] = msf.cdmsf_min1;\n\tcgc->cmd[7] = msf.cdmsf_sec1;\n\tcgc->cmd[8] = msf.cdmsf_frame1;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_play_blk(struct cdrom_device_info *cdi,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct cdrom_blk blk;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYBLK\\n\");\n\tif (copy_from_user(&blk, (struct cdrom_blk __user *)arg, sizeof(blk)))\n\t\treturn -EFAULT;\n\tcgc->cmd[0] = GPCMD_PLAY_AUDIO_10;\n\tcgc->cmd[2] = (blk.from >> 24) & 0xff;\n\tcgc->cmd[3] = (blk.from >> 16) & 0xff;\n\tcgc->cmd[4] = (blk.from >>  8) & 0xff;\n\tcgc->cmd[5] = blk.from & 0xff;\n\tcgc->cmd[7] = (blk.len >> 8) & 0xff;\n\tcgc->cmd[8] = blk.len & 0xff;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_volume(struct cdrom_device_info *cdi,\n\t\t\t\t\t   void __user *arg,\n\t\t\t\t\t   struct packet_command *cgc,\n\t\t\t\t\t   unsigned int cmd)\n{\n\tstruct cdrom_volctrl volctrl;\n\tunsigned char buffer[32];\n\tchar mask[sizeof(buffer)];\n\tunsigned short offset;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLUME\\n\");\n\n\tif (copy_from_user(&volctrl, (struct cdrom_volctrl __user *)arg,\n\t\t\t   sizeof(volctrl)))\n\t\treturn -EFAULT;\n\n\tcgc->buffer = buffer;\n\tcgc->buflen = 24;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 0);\n\tif (ret)\n\t\treturn ret;\n\t\t\n\t/* originally the code depended on buffer[1] to determine\n\t   how much data is available for transfer. buffer[1] is\n\t   unfortunately ambigious and the only reliable way seem\n\t   to be to simply skip over the block descriptor... */\n\toffset = 8 + be16_to_cpu(*(__be16 *)(buffer + 6));\n\n\tif (offset + 16 > sizeof(buffer))\n\t\treturn -E2BIG;\n\n\tif (offset + 16 > cgc->buflen) {\n\t\tcgc->buflen = offset + 16;\n\t\tret = cdrom_mode_sense(cdi, cgc,\n\t\t\t\t       GPMODE_AUDIO_CTL_PAGE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* sanity check */\n\tif ((buffer[offset] & 0x3f) != GPMODE_AUDIO_CTL_PAGE ||\n\t    buffer[offset + 1] < 14)\n\t\treturn -EINVAL;\n\n\t/* now we have the current volume settings. if it was only\n\t   a CDROMVOLREAD, return these values */\n\tif (cmd == CDROMVOLREAD) {\n\t\tvolctrl.channel0 = buffer[offset+9];\n\t\tvolctrl.channel1 = buffer[offset+11];\n\t\tvolctrl.channel2 = buffer[offset+13];\n\t\tvolctrl.channel3 = buffer[offset+15];\n\t\tif (copy_to_user((struct cdrom_volctrl __user *)arg, &volctrl,\n\t\t\t\t sizeof(volctrl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\t\t\n\t/* get the volume mask */\n\tcgc->buffer = mask;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer[offset + 9]  = volctrl.channel0 & mask[offset + 9];\n\tbuffer[offset + 11] = volctrl.channel1 & mask[offset + 11];\n\tbuffer[offset + 13] = volctrl.channel2 & mask[offset + 13];\n\tbuffer[offset + 15] = volctrl.channel3 & mask[offset + 15];\n\n\t/* set volume */\n\tcgc->buffer = buffer + offset - 8;\n\tmemset(cgc->buffer, 0, 8);\n\treturn cdrom_mode_select(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_start_stop(struct cdrom_device_info *cdi,\n\t\t\t\t\t       struct packet_command *cgc,\n\t\t\t\t\t       int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMSTART/CDROMSTOP\\n\");\n\tcgc->cmd[0] = GPCMD_START_STOP_UNIT;\n\tcgc->cmd[1] = 1;\n\tcgc->cmd[4] = (cmd == CDROMSTART) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_pause_resume(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t struct packet_command *cgc,\n\t\t\t\t\t\t int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPAUSE/CDROMRESUME\\n\");\n\tcgc->cmd[0] = GPCMD_PAUSE_RESUME;\n\tcgc->cmd[8] = (cmd == CDROMRESUME) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_dvd_read_struct(struct cdrom_device_info *cdi,\n\t\t\t\t\t      void __user *arg,\n\t\t\t\t\t      struct packet_command *cgc)\n{\n\tint ret;\n\tdvd_struct *s;\n\tint size = sizeof(dvd_struct);\n\n\tif (!CDROM_CAN(CDC_DVD))\n\t\treturn -ENOSYS;\n\n\ts = memdup_user(arg, size);\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\tcd_dbg(CD_DO_IOCTL, \"entering DVD_READ_STRUCT\\n\");\n\n\tret = dvd_read_struct(cdi, s, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(arg, s, size))\n\t\tret = -EFAULT;\nout:\n\tkfree(s);\n\treturn ret;\n}\n\nstatic noinline int mmc_ioctl_dvd_auth(struct cdrom_device_info *cdi,\n\t\t\t\t       void __user *arg)\n{\n\tint ret;\n\tdvd_authinfo ai;\n\tif (!CDROM_CAN(CDC_DVD))\n\t\treturn -ENOSYS;\n\tcd_dbg(CD_DO_IOCTL, \"entering DVD_AUTH\\n\");\n\tif (copy_from_user(&ai, (dvd_authinfo __user *)arg, sizeof(ai)))\n\t\treturn -EFAULT;\n\tret = dvd_do_auth(cdi, &ai);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((dvd_authinfo __user *)arg, &ai, sizeof(ai)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_next_writable(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t  void __user *arg)\n{\n\tint ret;\n\tlong next = 0;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_NEXT_WRITABLE\\n\");\n\tret = cdrom_get_next_writable(cdi, &next);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((long __user *)arg, &next, sizeof(next)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_last_written(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t void __user *arg)\n{\n\tint ret;\n\tlong last = 0;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_LAST_WRITTEN\\n\");\n\tret = cdrom_get_last_written(cdi, &last);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((long __user *)arg, &last, sizeof(last)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int mmc_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tstruct packet_command cgc;\n\tvoid __user *userptr = (void __user *)arg;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\n\t/* build a unified command and queue it through\n\t   cdo->generic_packet() */\n\tswitch (cmd) {\n\tcase CDROMREADRAW:\n\tcase CDROMREADMODE1:\n\tcase CDROMREADMODE2:\n\t\treturn mmc_ioctl_cdrom_read_data(cdi, userptr, &cgc, cmd);\n\tcase CDROMREADAUDIO:\n\t\treturn mmc_ioctl_cdrom_read_audio(cdi, userptr);\n\tcase CDROMSUBCHNL:\n\t\treturn mmc_ioctl_cdrom_subchannel(cdi, userptr);\n\tcase CDROMPLAYMSF:\n\t\treturn mmc_ioctl_cdrom_play_msf(cdi, userptr, &cgc);\n\tcase CDROMPLAYBLK:\n\t\treturn mmc_ioctl_cdrom_play_blk(cdi, userptr, &cgc);\n\tcase CDROMVOLCTRL:\n\tcase CDROMVOLREAD:\n\t\treturn mmc_ioctl_cdrom_volume(cdi, userptr, &cgc, cmd);\n\tcase CDROMSTART:\n\tcase CDROMSTOP:\n\t\treturn mmc_ioctl_cdrom_start_stop(cdi, &cgc, cmd);\n\tcase CDROMPAUSE:\n\tcase CDROMRESUME:\n\t\treturn mmc_ioctl_cdrom_pause_resume(cdi, &cgc, cmd);\n\tcase DVD_READ_STRUCT:\n\t\treturn mmc_ioctl_dvd_read_struct(cdi, userptr, &cgc);\n\tcase DVD_AUTH:\n\t\treturn mmc_ioctl_dvd_auth(cdi, userptr);\n\tcase CDROM_NEXT_WRITABLE:\n\t\treturn mmc_ioctl_cdrom_next_writable(cdi, userptr);\n\tcase CDROM_LAST_WRITTEN:\n\t\treturn mmc_ioctl_cdrom_last_written(cdi, userptr);\n\t}\n\n\treturn -ENOTTY;\n}\n\n/*\n * Just about every imaginable ioctl is supported in the Uniform layer\n * these days.\n * ATAPI / SCSI specific code now mainly resides in mmc_ioctl().\n */\nint cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,\n\t\tfmode_t mode, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\t/*\n\t * Try the generic SCSI command ioctl's first.\n\t */\n\tret = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);\n\tif (ret != -ENOTTY)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase CDROMMULTISESSION:\n\t\treturn cdrom_ioctl_multisession(cdi, argp);\n\tcase CDROMEJECT:\n\t\treturn cdrom_ioctl_eject(cdi);\n\tcase CDROMCLOSETRAY:\n\t\treturn cdrom_ioctl_closetray(cdi);\n\tcase CDROMEJECT_SW:\n\t\treturn cdrom_ioctl_eject_sw(cdi, arg);\n\tcase CDROM_MEDIA_CHANGED:\n\t\treturn cdrom_ioctl_media_changed(cdi, arg);\n\tcase CDROM_SET_OPTIONS:\n\t\treturn cdrom_ioctl_set_options(cdi, arg);\n\tcase CDROM_CLEAR_OPTIONS:\n\t\treturn cdrom_ioctl_clear_options(cdi, arg);\n\tcase CDROM_SELECT_SPEED:\n\t\treturn cdrom_ioctl_select_speed(cdi, arg);\n\tcase CDROM_SELECT_DISC:\n\t\treturn cdrom_ioctl_select_disc(cdi, arg);\n\tcase CDROMRESET:\n\t\treturn cdrom_ioctl_reset(cdi, bdev);\n\tcase CDROM_LOCKDOOR:\n\t\treturn cdrom_ioctl_lock_door(cdi, arg);\n\tcase CDROM_DEBUG:\n\t\treturn cdrom_ioctl_debug(cdi, arg);\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn cdrom_ioctl_get_capability(cdi);\n\tcase CDROM_GET_MCN:\n\t\treturn cdrom_ioctl_get_mcn(cdi, argp);\n\tcase CDROM_DRIVE_STATUS:\n\t\treturn cdrom_ioctl_drive_status(cdi, arg);\n\tcase CDROM_DISC_STATUS:\n\t\treturn cdrom_ioctl_disc_status(cdi);\n\tcase CDROM_CHANGER_NSLOTS:\n\t\treturn cdrom_ioctl_changer_nslots(cdi);\n\t}\n\n\t/*\n\t * Use the ioctls that are implemented through the generic_packet()\n\t * interface. this may look at bit funny, but if -ENOTTY is\n\t * returned that particular ioctl is not implemented and we\n\t * let it go through the device specific ones.\n\t */\n\tif (CDROM_CAN(CDC_GENERIC_PACKET)) {\n\t\tret = mmc_ioctl(cdi, cmd, arg);\n\t\tif (ret != -ENOTTY)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Note: most of the cd_dbg() calls are commented out here,\n\t * because they fill up the sys log when CD players poll\n\t * the drive.\n\t */\n\tswitch (cmd) {\n\tcase CDROMSUBCHNL:\n\t\treturn cdrom_ioctl_get_subchnl(cdi, argp);\n\tcase CDROMREADTOCHDR:\n\t\treturn cdrom_ioctl_read_tochdr(cdi, argp);\n\tcase CDROMREADTOCENTRY:\n\t\treturn cdrom_ioctl_read_tocentry(cdi, argp);\n\tcase CDROMPLAYMSF:\n\t\treturn cdrom_ioctl_play_msf(cdi, argp);\n\tcase CDROMPLAYTRKIND:\n\t\treturn cdrom_ioctl_play_trkind(cdi, argp);\n\tcase CDROMVOLCTRL:\n\t\treturn cdrom_ioctl_volctrl(cdi, argp);\n\tcase CDROMVOLREAD:\n\t\treturn cdrom_ioctl_volread(cdi, argp);\n\tcase CDROMSTART:\n\tcase CDROMSTOP:\n\tcase CDROMPAUSE:\n\tcase CDROMRESUME:\n\t\treturn cdrom_ioctl_audioctl(cdi, cmd);\n\t}\n\n\treturn -ENOSYS;\n}\n\nEXPORT_SYMBOL(cdrom_get_last_written);\nEXPORT_SYMBOL(register_cdrom);\nEXPORT_SYMBOL(unregister_cdrom);\nEXPORT_SYMBOL(cdrom_open);\nEXPORT_SYMBOL(cdrom_release);\nEXPORT_SYMBOL(cdrom_ioctl);\nEXPORT_SYMBOL(cdrom_media_changed);\nEXPORT_SYMBOL(cdrom_number_of_slots);\nEXPORT_SYMBOL(cdrom_mode_select);\nEXPORT_SYMBOL(cdrom_mode_sense);\nEXPORT_SYMBOL(init_cdrom_command);\nEXPORT_SYMBOL(cdrom_get_media_event);\n\n#ifdef CONFIG_SYSCTL\n\n#define CDROM_STR_SIZE 1000\n\nstatic struct cdrom_sysctl_settings {\n\tchar\tinfo[CDROM_STR_SIZE];\t/* general info */\n\tint\tautoclose;\t\t/* close tray upon mount, etc */\n\tint\tautoeject;\t\t/* eject on umount */\n\tint\tdebug;\t\t\t/* turn on debugging messages */\n\tint\tlock;\t\t\t/* lock the door on device open */\n\tint\tcheck;\t\t\t/* check media type */\n} cdrom_sysctl_settings;\n\nenum cdrom_print_option {\n\tCTL_NAME,\n\tCTL_SPEED,\n\tCTL_SLOTS,\n\tCTL_CAPABILITY\n};\n\nstatic int cdrom_print_info(const char *header, int val, char *info,\n\t\t\t\tint *pos, enum cdrom_print_option option)\n{\n\tconst int max_size = sizeof(cdrom_sysctl_settings.info);\n\tstruct cdrom_device_info *cdi;\n\tint ret;\n\n\tret = scnprintf(info + *pos, max_size - *pos, header);\n\tif (!ret)\n\t\treturn 1;\n\n\t*pos += ret;\n\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tswitch (option) {\n\t\tcase CTL_NAME:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%s\", cdi->name);\n\t\t\tbreak;\n\t\tcase CTL_SPEED:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", cdi->speed);\n\t\t\tbreak;\n\t\tcase CTL_SLOTS:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", cdi->capacity);\n\t\t\tbreak;\n\t\tcase CTL_CAPABILITY:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", CDROM_CAN(val) != 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"invalid option%d\\n\", option);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ret)\n\t\t\treturn 1;\n\t\t*pos += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdrom_sysctl_info(struct ctl_table *ctl, int write,\n                           void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint pos;\n\tchar *info = cdrom_sysctl_settings.info;\n\tconst int max_size = sizeof(cdrom_sysctl_settings.info);\n\t\n\tif (!*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&cdrom_mutex);\n\n\tpos = sprintf(info, \"CD-ROM information, \" VERSION \"\\n\");\n\t\n\tif (cdrom_print_info(\"\\ndrive name:\\t\", 0, info, &pos, CTL_NAME))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\ndrive speed:\\t\", 0, info, &pos, CTL_SPEED))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\ndrive # of slots:\", 0, info, &pos, CTL_SLOTS))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan close tray:\\t\",\n\t\t\t\tCDC_CLOSE_TRAY, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan open tray:\\t\",\n\t\t\t\tCDC_OPEN_TRAY, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan lock tray:\\t\",\n\t\t\t\tCDC_LOCK, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan change speed:\",\n\t\t\t\tCDC_SELECT_SPEED, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan select disk:\",\n\t\t\t\tCDC_SELECT_DISC, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read multisession:\",\n\t\t\t\tCDC_MULTI_SESSION, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read MCN:\\t\",\n\t\t\t\tCDC_MCN, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nReports media changed:\",\n\t\t\t\tCDC_MEDIA_CHANGED, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan play audio:\\t\",\n\t\t\t\tCDC_PLAY_AUDIO, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write CD-R:\\t\",\n\t\t\t\tCDC_CD_R, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write CD-RW:\",\n\t\t\t\tCDC_CD_RW, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read DVD:\\t\",\n\t\t\t\tCDC_DVD, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write DVD-R:\",\n\t\t\t\tCDC_DVD_R, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write DVD-RAM:\",\n\t\t\t\tCDC_DVD_RAM, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read MRW:\\t\",\n\t\t\t\tCDC_MRW, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write MRW:\\t\",\n\t\t\t\tCDC_MRW_W, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write RAM:\\t\",\n\t\t\t\tCDC_RAM, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (!scnprintf(info + pos, max_size - pos, \"\\n\\n\"))\n\t\tgoto done;\ndoit:\n\tmutex_unlock(&cdrom_mutex);\n\treturn proc_dostring(ctl, write, buffer, lenp, ppos);\ndone:\n\tpr_info(\"info buffer too small\\n\");\n\tgoto doit;\n}\n\n/* Unfortunately, per device settings are not implemented through\n   procfs/sysctl yet. When they are, this will naturally disappear. For now\n   just update all drives. Later this will become the template on which\n   new registered drives will be based. */\nstatic void cdrom_update_settings(void)\n{\n\tstruct cdrom_device_info *cdi;\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tif (autoclose && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_CLOSE;\n\t\telse if (!autoclose)\n\t\t\tcdi->options &= ~CDO_AUTO_CLOSE;\n\t\tif (autoeject && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_EJECT;\n\t\telse if (!autoeject)\n\t\t\tcdi->options &= ~CDO_AUTO_EJECT;\n\t\tif (lockdoor && CDROM_CAN(CDC_LOCK))\n\t\t\tcdi->options |= CDO_LOCK;\n\t\telse if (!lockdoor)\n\t\t\tcdi->options &= ~CDO_LOCK;\n\t\tif (check_media_type)\n\t\t\tcdi->options |= CDO_CHECK_TYPE;\n\t\telse\n\t\t\tcdi->options &= ~CDO_CHECK_TYPE;\n\t}\n\tmutex_unlock(&cdrom_mutex);\n}\n\nstatic int cdrom_sysctl_handler(struct ctl_table *ctl, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\t\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\n\t\t/* we only care for 1 or 0. */\n\t\tautoclose        = !!cdrom_sysctl_settings.autoclose;\n\t\tautoeject        = !!cdrom_sysctl_settings.autoeject;\n\t\tdebug\t         = !!cdrom_sysctl_settings.debug;\n\t\tlockdoor         = !!cdrom_sysctl_settings.lock;\n\t\tcheck_media_type = !!cdrom_sysctl_settings.check;\n\n\t\t/* update the option flags according to the changes. we\n\t\t   don't have per device options through sysctl yet,\n\t\t   but we will have and then this will disappear. */\n\t\tcdrom_update_settings();\n\t}\n\n        return ret;\n}\n\n/* Place files in /proc/sys/dev/cdrom */\nstatic struct ctl_table cdrom_table[] = {\n\t{\n\t\t.procname\t= \"info\",\n\t\t.data\t\t= &cdrom_sysctl_settings.info, \n\t\t.maxlen\t\t= CDROM_STR_SIZE,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= cdrom_sysctl_info,\n\t},\n\t{\n\t\t.procname\t= \"autoclose\",\n\t\t.data\t\t= &cdrom_sysctl_settings.autoclose,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"autoeject\",\n\t\t.data\t\t= &cdrom_sysctl_settings.autoeject,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"debug\",\n\t\t.data\t\t= &cdrom_sysctl_settings.debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"lock\",\n\t\t.data\t\t= &cdrom_sysctl_settings.lock,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"check_media\",\n\t\t.data\t\t= &cdrom_sysctl_settings.check,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler\n\t},\n\t{ }\n};\n\nstatic struct ctl_table cdrom_cdrom_table[] = {\n\t{\n\t\t.procname\t= \"cdrom\",\n\t\t.maxlen\t\t= 0,\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= cdrom_table,\n\t},\n\t{ }\n};\n\n/* Make sure that /proc/sys/dev is there */\nstatic struct ctl_table cdrom_root_table[] = {\n\t{\n\t\t.procname\t= \"dev\",\n\t\t.maxlen\t\t= 0,\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= cdrom_cdrom_table,\n\t},\n\t{ }\n};\nstatic struct ctl_table_header *cdrom_sysctl_header;\n\nstatic void cdrom_sysctl_register(void)\n{\n\tstatic int initialized;\n\n\tif (initialized == 1)\n\t\treturn;\n\n\tcdrom_sysctl_header = register_sysctl_table(cdrom_root_table);\n\n\t/* set the defaults */\n\tcdrom_sysctl_settings.autoclose = autoclose;\n\tcdrom_sysctl_settings.autoeject = autoeject;\n\tcdrom_sysctl_settings.debug = debug;\n\tcdrom_sysctl_settings.lock = lockdoor;\n\tcdrom_sysctl_settings.check = check_media_type;\n\n\tinitialized = 1;\n}\n\nstatic void cdrom_sysctl_unregister(void)\n{\n\tif (cdrom_sysctl_header)\n\t\tunregister_sysctl_table(cdrom_sysctl_header);\n}\n\n#else /* CONFIG_SYSCTL */\n\nstatic void cdrom_sysctl_register(void)\n{\n}\n\nstatic void cdrom_sysctl_unregister(void)\n{\n}\n\n#endif /* CONFIG_SYSCTL */\n\nstatic int __init cdrom_init(void)\n{\n\tcdrom_sysctl_register();\n\n\treturn 0;\n}\n\nstatic void __exit cdrom_exit(void)\n{\n\tpr_info(\"Uniform CD-ROM driver unloaded\\n\");\n\tcdrom_sysctl_unregister();\n}\n\nmodule_init(cdrom_init);\nmodule_exit(cdrom_exit);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/* linux/drivers/cdrom/cdrom.c\n   Copyright (c) 1996, 1997 David A. van Leeuwen.\n   Copyright (c) 1997, 1998 Erik Andersen <andersee@debian.org>\n   Copyright (c) 1998, 1999 Jens Axboe <axboe@image.dk>\n\n   May be copied or modified under the terms of the GNU General Public\n   License.  See linux/COPYING for more information.\n\n   Uniform CD-ROM driver for Linux.\n   See Documentation/cdrom/cdrom-standard.tex for usage information.\n\n   The routines in the file provide a uniform interface between the\n   software that uses CD-ROMs and the various low-level drivers that\n   actually talk to the hardware. Suggestions are welcome.\n   Patches that work are more welcome though.  ;-)\n\n To Do List:\n ----------------------------------\n\n -- Modify sysctl/proc interface. I plan on having one directory per\n drive, with entries for outputing general drive information, and sysctl\n based tunable parameters such as whether the tray should auto-close for\n that drive. Suggestions (or patches) for this welcome!\n\n\n Revision History\n ----------------------------------\n 1.00  Date Unknown -- David van Leeuwen <david@tm.tno.nl>\n -- Initial version by David A. van Leeuwen. I don't have a detailed\n  changelog for the 1.x series, David?\n\n2.00  Dec  2, 1997 -- Erik Andersen <andersee@debian.org>\n  -- New maintainer! As David A. van Leeuwen has been too busy to actively\n  maintain and improve this driver, I am now carrying on the torch. If\n  you have a problem with this driver, please feel free to contact me.\n\n  -- Added (rudimentary) sysctl interface. I realize this is really weak\n  right now, and is _very_ badly implemented. It will be improved...\n\n  -- Modified CDROM_DISC_STATUS so that it is now incorporated into\n  the Uniform CD-ROM driver via the cdrom_count_tracks function.\n  The cdrom_count_tracks function helps resolve some of the false\n  assumptions of the CDROM_DISC_STATUS ioctl, and is also used to check\n  for the correct media type when mounting or playing audio from a CD.\n\n  -- Remove the calls to verify_area and only use the copy_from_user and\n  copy_to_user stuff, since these calls now provide their own memory\n  checking with the 2.1.x kernels.\n\n  -- Major update to return codes so that errors from low-level drivers\n  are passed on through (thanks to Gerd Knorr for pointing out this\n  problem).\n\n  -- Made it so if a function isn't implemented in a low-level driver,\n  ENOSYS is now returned instead of EINVAL.\n\n  -- Simplified some complex logic so that the source code is easier to read.\n\n  -- Other stuff I probably forgot to mention (lots of changes).\n\n2.01 to 2.11 Dec 1997-Jan 1998\n  -- TO-DO!  Write changelogs for 2.01 to 2.12.\n\n2.12  Jan  24, 1998 -- Erik Andersen <andersee@debian.org>\n  -- Fixed a bug in the IOCTL_IN and IOCTL_OUT macros.  It turns out that\n  copy_*_user does not return EFAULT on error, but instead returns the number \n  of bytes not copied.  I was returning whatever non-zero stuff came back from \n  the copy_*_user functions directly, which would result in strange errors.\n\n2.13  July 17, 1998 -- Erik Andersen <andersee@debian.org>\n  -- Fixed a bug in CDROM_SELECT_SPEED where you couldn't lower the speed\n  of the drive.  Thanks to Tobias Ringstr|m <tori@prosolvia.se> for pointing\n  this out and providing a simple fix.\n  -- Fixed the procfs-unload-module bug with the fill_inode procfs callback.\n  thanks to Andrea Arcangeli\n  -- Fixed it so that the /proc entry now also shows up when cdrom is\n  compiled into the kernel.  Before it only worked when loaded as a module.\n\n  2.14 August 17, 1998 -- Erik Andersen <andersee@debian.org>\n  -- Fixed a bug in cdrom_media_changed and handling of reporting that\n  the media had changed for devices that _don't_ implement media_changed.  \n  Thanks to Grant R. Guenther <grant@torque.net> for spotting this bug.\n  -- Made a few things more pedanticly correct.\n\n2.50 Oct 19, 1998 - Jens Axboe <axboe@image.dk>\n  -- New maintainers! Erik was too busy to continue the work on the driver,\n  so now Chris Zwilling <chris@cloudnet.com> and Jens Axboe <axboe@image.dk>\n  will do their best to follow in his footsteps\n  \n  2.51 Dec 20, 1998 - Jens Axboe <axboe@image.dk>\n  -- Check if drive is capable of doing what we ask before blindly changing\n  cdi->options in various ioctl.\n  -- Added version to proc entry.\n  \n  2.52 Jan 16, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixed an error in open_for_data where we would sometimes not return\n  the correct error value. Thanks Huba Gaspar <huba@softcell.hu>.\n  -- Fixed module usage count - usage was based on /proc/sys/dev\n  instead of /proc/sys/dev/cdrom. This could lead to an oops when other\n  modules had entries in dev. Feb 02 - real bug was in sysctl.c where\n  dev would be removed even though it was used. cdrom.c just illuminated\n  that bug.\n  \n  2.53 Feb 22, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixup of several ioctl calls, in particular CDROM_SET_OPTIONS has\n  been \"rewritten\" because capabilities and options aren't in sync. They\n  should be...\n  -- Added CDROM_LOCKDOOR ioctl. Locks the door and keeps it that way.\n  -- Added CDROM_RESET ioctl.\n  -- Added CDROM_DEBUG ioctl. Enable debug messages on-the-fly.\n  -- Added CDROM_GET_CAPABILITY ioctl. This relieves userspace programs\n  from parsing /proc/sys/dev/cdrom/info.\n  \n  2.54 Mar 15, 1999 - Jens Axboe <axboe@image.dk>\n  -- Check capability mask from low level driver when counting tracks as\n  per suggestion from Corey J. Scotts <cstotts@blue.weeg.uiowa.edu>.\n  \n  2.55 Apr 25, 1999 - Jens Axboe <axboe@image.dk>\n  -- autoclose was mistakenly checked against CDC_OPEN_TRAY instead of\n  CDC_CLOSE_TRAY.\n  -- proc info didn't mask against capabilities mask.\n  \n  3.00 Aug 5, 1999 - Jens Axboe <axboe@image.dk>\n  -- Unified audio ioctl handling across CD-ROM drivers. A lot of the\n  code was duplicated before. Drives that support the generic packet\n  interface are now being fed packets from here instead.\n  -- First attempt at adding support for MMC2 commands - for DVD and\n  CD-R(W) drives. Only the DVD parts are in now - the interface used is\n  the same as for the audio ioctls.\n  -- ioctl cleanups. if a drive couldn't play audio, it didn't get\n  a change to perform device specific ioctls as well.\n  -- Defined CDROM_CAN(CDC_XXX) for checking the capabilities.\n  -- Put in sysctl files for autoclose, autoeject, check_media, debug,\n  and lock.\n  -- /proc/sys/dev/cdrom/info has been updated to also contain info about\n  CD-Rx and DVD capabilities.\n  -- Now default to checking media type.\n  -- CDROM_SEND_PACKET ioctl added. The infrastructure was in place for\n  doing this anyway, with the generic_packet addition.\n  \n  3.01 Aug 6, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fix up the sysctl handling so that the option flags get set\n  correctly.\n  -- Fix up ioctl handling so the device specific ones actually get\n  called :).\n  \n  3.02 Aug 8, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixed volume control on SCSI drives (or others with longer audio\n  page).\n  -- Fixed a couple of DVD minors. Thanks to Andrew T. Veliath\n  <andrewtv@usa.net> for telling me and for having defined the various\n  DVD structures and ioctls in the first place! He designed the original\n  DVD patches for ide-cd and while I rearranged and unified them, the\n  interface is still the same.\n  \n  3.03 Sep 1, 1999 - Jens Axboe <axboe@image.dk>\n  -- Moved the rest of the audio ioctls from the CD-ROM drivers here. Only\n  CDROMREADTOCENTRY and CDROMREADTOCHDR are left.\n  -- Moved the CDROMREADxxx ioctls in here.\n  -- Defined the cdrom_get_last_written and cdrom_get_next_block as ioctls\n  and exported functions.\n  -- Erik Andersen <andersen@xmission.com> modified all SCMD_ commands\n  to now read GPCMD_ for the new generic packet interface. All low level\n  drivers are updated as well.\n  -- Various other cleanups.\n\n  3.04 Sep 12, 1999 - Jens Axboe <axboe@image.dk>\n  -- Fixed a couple of possible memory leaks (if an operation failed and\n  we didn't free the buffer before returning the error).\n  -- Integrated Uniform CD Changer handling from Richard Sharman\n  <rsharman@pobox.com>.\n  -- Defined CD_DVD and CD_CHANGER log levels.\n  -- Fixed the CDROMREADxxx ioctls.\n  -- CDROMPLAYTRKIND uses the GPCMD_PLAY_AUDIO_MSF command - too few\n  drives supported it. We lose the index part, however.\n  -- Small modifications to accommodate opens of /dev/hdc1, required\n  for ide-cd to handle multisession discs.\n  -- Export cdrom_mode_sense and cdrom_mode_select.\n  -- init_cdrom_command() for setting up a cgc command.\n  \n  3.05 Oct 24, 1999 - Jens Axboe <axboe@image.dk>\n  -- Changed the interface for CDROM_SEND_PACKET. Before it was virtually\n  impossible to send the drive data in a sensible way.\n  -- Lowered stack usage in mmc_ioctl(), dvd_read_disckey(), and\n  dvd_read_manufact.\n  -- Added setup of write mode for packet writing.\n  -- Fixed CDDA ripping with cdda2wav - accept much larger requests of\n  number of frames and split the reads in blocks of 8.\n\n  3.06 Dec 13, 1999 - Jens Axboe <axboe@image.dk>\n  -- Added support for changing the region of DVD drives.\n  -- Added sense data to generic command.\n\n  3.07 Feb 2, 2000 - Jens Axboe <axboe@suse.de>\n  -- Do same \"read header length\" trick in cdrom_get_disc_info() as\n  we do in cdrom_get_track_info() -- some drive don't obey specs and\n  fail if they can't supply the full Mt Fuji size table.\n  -- Deleted stuff related to setting up write modes. It has a different\n  home now.\n  -- Clear header length in mode_select unconditionally.\n  -- Removed the register_disk() that was added, not needed here.\n\n  3.08 May 1, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix direction flag in setup_send_key and setup_report_key. This\n  gave some SCSI adapters problems.\n  -- Always return -EROFS for write opens\n  -- Convert to module_init/module_exit style init and remove some\n  of the #ifdef MODULE stuff\n  -- Fix several dvd errors - DVD_LU_SEND_ASF should pass agid,\n  DVD_HOST_SEND_RPC_STATE did not set buffer size in cdb, and\n  dvd_do_auth passed uninitialized data to drive because init_cdrom_command\n  did not clear a 0 sized buffer.\n  \n  3.09 May 12, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix Video-CD on SCSI drives that don't support READ_CD command. In\n  that case switch block size and issue plain READ_10 again, then switch\n  back.\n\n  3.10 Jun 10, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix volume control on CD's - old SCSI-II drives now use their own\n  code, as doing MODE6 stuff in here is really not my intention.\n  -- Use READ_DISC_INFO for more reliable end-of-disc.\n\n  3.11 Jun 12, 2000 - Jens Axboe <axboe@suse.de>\n  -- Fix bug in getting rpc phase 2 region info.\n  -- Reinstate \"correct\" CDROMPLAYTRKIND\n\n   3.12 Oct 18, 2000 - Jens Axboe <axboe@suse.de>\n  -- Use quiet bit on packet commands not known to work\n\n   3.20 Dec 17, 2003 - Jens Axboe <axboe@suse.de>\n  -- Various fixes and lots of cleanups not listed :-)\n  -- Locking fixes\n  -- Mt Rainier support\n  -- DVD-RAM write open fixes\n\n  Nov 5 2001, Aug 8 2002. Modified by Andy Polyakov\n  <appro@fy.chalmers.se> to support MMC-3 compliant DVD+RW units.\n\n  Modified by Nigel Kukard <nkukard@lbsd.net> - support DVD+RW\n  2.4.x patch by Andy Polyakov <appro@fy.chalmers.se>\n\n-------------------------------------------------------------------------*/\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define REVISION \"Revision: 3.20\"\n#define VERSION \"Id: cdrom.c 3.20 2003/12/17\"\n\n/* I use an error-log mask to give fine grain control over the type of\n   messages dumped to the system logs.  The available masks include: */\n#define CD_NOTHING      0x0\n#define CD_WARNING\t0x1\n#define CD_REG_UNREG\t0x2\n#define CD_DO_IOCTL\t0x4\n#define CD_OPEN\t\t0x8\n#define CD_CLOSE\t0x10\n#define CD_COUNT_TRACKS 0x20\n#define CD_CHANGER\t0x40\n#define CD_DVD\t\t0x80\n\n/* Define this to remove _all_ the debugging messages */\n/* #define ERRLOGMASK CD_NOTHING */\n#define ERRLOGMASK CD_WARNING\n/* #define ERRLOGMASK (CD_WARNING|CD_OPEN|CD_COUNT_TRACKS|CD_CLOSE) */\n/* #define ERRLOGMASK (CD_WARNING|CD_REG_UNREG|CD_DO_IOCTL|CD_OPEN|CD_CLOSE|CD_COUNT_TRACKS) */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/major.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h> \n#include <linux/cdrom.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/blkpg.h>\n#include <linux/init.h>\n#include <linux/fcntl.h>\n#include <linux/blkdev.h>\n#include <linux/times.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_request.h>\n\n/* used to tell the module to turn on full debugging messages */\nstatic bool debug;\n/* default compatibility mode */\nstatic bool autoclose=1;\nstatic bool autoeject;\nstatic bool lockdoor = 1;\n/* will we ever get to use this... sigh. */\nstatic bool check_media_type;\n/* automatically restart mrw format */\nstatic bool mrw_format_restart = 1;\nmodule_param(debug, bool, 0);\nmodule_param(autoclose, bool, 0);\nmodule_param(autoeject, bool, 0);\nmodule_param(lockdoor, bool, 0);\nmodule_param(check_media_type, bool, 0);\nmodule_param(mrw_format_restart, bool, 0);\n\nstatic DEFINE_MUTEX(cdrom_mutex);\n\nstatic const char *mrw_format_status[] = {\n\t\"not mrw\",\n\t\"bgformat inactive\",\n\t\"bgformat active\",\n\t\"mrw complete\",\n};\n\nstatic const char *mrw_address_space[] = { \"DMA\", \"GAA\" };\n\n#if (ERRLOGMASK != CD_NOTHING)\n#define cd_dbg(type, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif ((ERRLOGMASK & type) || debug == 1)\t\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n#else\n#define cd_dbg(type, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (0 && (ERRLOGMASK & type) || debug == 1)\t\\\n\t\tpr_debug(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n#endif\n\n/* The (cdo->capability & ~cdi->mask & CDC_XXX) construct was used in\n   a lot of places. This macro makes the code more clear. */\n#define CDROM_CAN(type) (cdi->ops->capability & ~cdi->mask & (type))\n\n/*\n * Another popular OS uses 7 seconds as the hard timeout for default\n * commands, so it is a good choice for us as well.\n */\n#define CDROM_DEF_TIMEOUT\t(7 * HZ)\n\n/* Not-exported routines. */\n\nstatic void cdrom_sysctl_register(void);\n\nstatic LIST_HEAD(cdrom_list);\n\nint cdrom_dummy_generic_packet(struct cdrom_device_info *cdi,\n\t\t\t       struct packet_command *cgc)\n{\n\tif (cgc->sshdr) {\n\t\tcgc->sshdr->sense_key = 0x05;\n\t\tcgc->sshdr->asc = 0x20;\n\t\tcgc->sshdr->ascq = 0x00;\n\t}\n\n\tcgc->stat = -EIO;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(cdrom_dummy_generic_packet);\n\nstatic int cdrom_flush_cache(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_FLUSH_CACHE;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\n/* requires CD R/RW */\nstatic int cdrom_get_disc_info(struct cdrom_device_info *cdi,\n\t\t\t       disc_information *di)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tint ret, buflen;\n\n\t/* set up command and get the disc info */\n\tinit_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_DISC_INFO;\n\tcgc.cmd[8] = cgc.buflen = 2;\n\tcgc.quiet = 1;\n\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* not all drives have the same disc_info length, so requeue\n\t * packet with the length the drive tells us it can supply\n\t */\n\tbuflen = be16_to_cpu(di->disc_information_length) +\n\t\tsizeof(di->disc_information_length);\n\n\tif (buflen > sizeof(disc_information))\n\t\tbuflen = sizeof(disc_information);\n\n\tcgc.cmd[8] = cgc.buflen = buflen;\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* return actual fill size */\n\treturn buflen;\n}\n\n/* This macro makes sure we don't have to check on cdrom_device_ops\n * existence in the run-time routines below. Change_capability is a\n * hack to have the capability flags defined const, while we can still\n * change it here without gcc complaining at every line.\n */\n#define ENSURE(call, bits)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (cdo->call == NULL)\t\t\t\\\n\t\t*change_capability &= ~(bits);\t\\\n} while (0)\n\n/*\n * the first prototypes used 0x2c as the page code for the mrw mode page,\n * subsequently this was changed to 0x03. probe the one used by this drive\n */\nstatic int cdrom_mrw_probe_pc(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[16];\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.timeout = HZ;\n\tcgc.quiet = 1;\n\n\tif (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC, 0)) {\n\t\tcdi->mrw_mode_page = MRW_MODE_PC;\n\t\treturn 0;\n\t} else if (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC_PRE1, 0)) {\n\t\tcdi->mrw_mode_page = MRW_MODE_PC_PRE1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct packet_command cgc;\n\tstruct mrw_feature_desc *mfd;\n\tunsigned char buffer[16];\n\tint ret;\n\n\t*write = 0;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_MRW;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\n\t\treturn 1;\n\t*write = mfd->write;\n\n\tif ((ret = cdrom_mrw_probe_pc(cdi))) {\n\t\t*write = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdrom_mrw_bgformat(struct cdrom_device_info *cdi, int cont)\n{\n\tstruct packet_command cgc;\n\tunsigned char buffer[12];\n\tint ret;\n\n\tpr_info(\"%sstarting format\\n\", cont ? \"Re\" : \"\");\n\n\t/*\n\t * FmtData bit set (bit 4), format type is 1\n\t */\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_WRITE);\n\tcgc.cmd[0] = GPCMD_FORMAT_UNIT;\n\tcgc.cmd[1] = (1 << 4) | 1;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\t/*\n\t * 4 byte format list header, 8 byte format list descriptor\n\t */\n\tbuffer[1] = 1 << 1;\n\tbuffer[3] = 8;\n\n\t/*\n\t * nr_blocks field\n\t */\n\tbuffer[4] = 0xff;\n\tbuffer[5] = 0xff;\n\tbuffer[6] = 0xff;\n\tbuffer[7] = 0xff;\n\n\tbuffer[8] = 0x24 << 2;\n\tbuffer[11] = cont;\n\n\tret = cdi->ops->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\tpr_info(\"bgformat failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cdrom_mrw_bgformat_susp(struct cdrom_device_info *cdi, int immed)\n{\n\tstruct packet_command cgc;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\n\t/*\n\t * Session = 1, Track = 0\n\t */\n\tcgc.cmd[1] = !!immed;\n\tcgc.cmd[2] = 1 << 1;\n\n\tcgc.timeout = 5 * 60 * HZ;\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_mrw_exit(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < (int)offsetof(typeof(di),disc_type))\n\t\treturn 1;\n\n\tret = 0;\n\tif (di.mrw_status == CDM_MRW_BGFORMAT_ACTIVE) {\n\t\tpr_info(\"issuing MRW background format suspend\\n\");\n\t\tret = cdrom_mrw_bgformat_susp(cdi, 0);\n\t}\n\n\tif (!ret && cdi->media_written)\n\t\tret = cdrom_flush_cache(cdi);\n\n\treturn ret;\n}\n\nstatic int cdrom_mrw_set_lba_space(struct cdrom_device_info *cdi, int space)\n{\n\tstruct packet_command cgc;\n\tstruct mode_page_header *mph;\n\tchar buffer[16];\n\tint ret, offset, size;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.buffer = buffer;\n\tcgc.buflen = sizeof(buffer);\n\n\tret = cdrom_mode_sense(cdi, &cgc, cdi->mrw_mode_page, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmph = (struct mode_page_header *)buffer;\n\toffset = be16_to_cpu(mph->desc_length);\n\tsize = be16_to_cpu(mph->mode_data_length) + 2;\n\n\tbuffer[offset + 3] = space;\n\tcgc.buflen = size;\n\n\tret = cdrom_mode_select(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"%s: mrw address space %s selected\\n\",\n\t\tcdi->name, mrw_address_space[space]);\n\treturn 0;\n}\n\nint register_cdrom(struct cdrom_device_info *cdi)\n{\n\tstatic char banner_printed;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint *change_capability = (int *)&cdo->capability; /* hack */\n\n\tcd_dbg(CD_OPEN, \"entering register_cdrom\\n\");\n\n\tif (cdo->open == NULL || cdo->release == NULL)\n\t\treturn -EINVAL;\n\tif (!banner_printed) {\n\t\tpr_info(\"Uniform CD-ROM driver \" REVISION \"\\n\");\n\t\tbanner_printed = 1;\n\t\tcdrom_sysctl_register();\n\t}\n\n\tENSURE(drive_status, CDC_DRIVE_STATUS);\n\tif (cdo->check_events == NULL && cdo->media_changed == NULL)\n\t\t*change_capability = ~(CDC_MEDIA_CHANGED | CDC_SELECT_DISC);\n\tENSURE(tray_move, CDC_CLOSE_TRAY | CDC_OPEN_TRAY);\n\tENSURE(lock_door, CDC_LOCK);\n\tENSURE(select_speed, CDC_SELECT_SPEED);\n\tENSURE(get_last_session, CDC_MULTI_SESSION);\n\tENSURE(get_mcn, CDC_MCN);\n\tENSURE(reset, CDC_RESET);\n\tENSURE(generic_packet, CDC_GENERIC_PACKET);\n\tcdi->mc_flags = 0;\n\tcdi->options = CDO_USE_FFLAGS;\n\n\tif (autoclose == 1 && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\tcdi->options |= (int) CDO_AUTO_CLOSE;\n\tif (autoeject == 1 && CDROM_CAN(CDC_OPEN_TRAY))\n\t\tcdi->options |= (int) CDO_AUTO_EJECT;\n\tif (lockdoor == 1)\n\t\tcdi->options |= (int) CDO_LOCK;\n\tif (check_media_type == 1)\n\t\tcdi->options |= (int) CDO_CHECK_TYPE;\n\n\tif (CDROM_CAN(CDC_MRW_W))\n\t\tcdi->exit = cdrom_mrw_exit;\n\n\tif (cdi->disk)\n\t\tcdi->cdda_method = CDDA_BPC_FULL;\n\telse\n\t\tcdi->cdda_method = CDDA_OLD;\n\n\tWARN_ON(!cdo->generic_packet);\n\n\tcd_dbg(CD_REG_UNREG, \"drive \\\"/dev/%s\\\" registered\\n\", cdi->name);\n\tmutex_lock(&cdrom_mutex);\n\tlist_add(&cdi->list, &cdrom_list);\n\tmutex_unlock(&cdrom_mutex);\n\treturn 0;\n}\n#undef ENSURE\n\nvoid unregister_cdrom(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_OPEN, \"entering unregister_cdrom\\n\");\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_del(&cdi->list);\n\tmutex_unlock(&cdrom_mutex);\n\n\tif (cdi->exit)\n\t\tcdi->exit(cdi);\n\n\tcd_dbg(CD_REG_UNREG, \"drive \\\"/dev/%s\\\" unregistered\\n\", cdi->name);\n}\n\nint cdrom_get_media_event(struct cdrom_device_info *cdi,\n\t\t\t  struct media_event_desc *med)\n{\n\tstruct packet_command cgc;\n\tunsigned char buffer[8];\n\tstruct event_header *eh = (struct event_header *)buffer;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_GET_EVENT_STATUS_NOTIFICATION;\n\tcgc.cmd[1] = 1;\t\t/* IMMED */\n\tcgc.cmd[4] = 1 << 4;\t/* media event */\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif (cdi->ops->generic_packet(cdi, &cgc))\n\t\treturn 1;\n\n\tif (be16_to_cpu(eh->data_len) < sizeof(*med))\n\t\treturn 1;\n\n\tif (eh->nea || eh->notification_class != 0x4)\n\t\treturn 1;\n\n\tmemcpy(med, &buffer[sizeof(*eh)], sizeof(*med));\n\treturn 0;\n}\n\nstatic int cdrom_get_random_writable(struct cdrom_device_info *cdi,\n\t\t\t      struct rwrt_feature_desc *rfd)\n{\n\tstruct packet_command cgc;\n\tchar buffer[24];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\t/* often 0x46 */\n\tcgc.cmd[3] = CDF_RWRT;\t\t\t/* often 0x0020 */\n\tcgc.cmd[8] = sizeof(buffer);\t\t/* often 0x18 */\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmemcpy(rfd, &buffer[sizeof(struct feature_header)], sizeof (*rfd));\n\treturn 0;\n}\n\nstatic int cdrom_has_defect_mgt(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[16];\n\t__be16 *feature_code;\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_HWDM;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tfeature_code = (__be16 *) &buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(*feature_code) == CDF_HWDM)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic int cdrom_is_random_writable(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\t*write = 0;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\n\tif (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\t*write = 1;\n\n\treturn 0;\n}\n\nstatic int cdrom_media_erasable(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di), n_first_track))\n\t\treturn -1;\n\n\treturn di.erasable;\n}\n\n/*\n * FIXME: check RO bit\n */\nstatic int cdrom_dvdram_open_write(struct cdrom_device_info *cdi)\n{\n\tint ret = cdrom_media_erasable(cdi);\n\n\t/*\n\t * allow writable open if media info read worked and media is\n\t * erasable, _or_ if it fails since not all drives support it\n\t */\n\tif (!ret)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cdrom_mrw_open_write(struct cdrom_device_info *cdi)\n{\n\tdisc_information di;\n\tint ret;\n\n\t/*\n\t * always reset to DMA lba space on open\n\t */\n\tif (cdrom_mrw_set_lba_space(cdi, MRW_LBA_DMA)) {\n\t\tpr_err(\"failed setting lba address space\\n\");\n\t\treturn 1;\n\t}\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di),disc_type))\n\t\treturn 1;\n\n\tif (!di.erasable)\n\t\treturn 1;\n\n\t/*\n\t * mrw_status\n\t * 0\t-\tnot MRW formatted\n\t * 1\t-\tMRW bgformat started, but not running or complete\n\t * 2\t-\tMRW bgformat in progress\n\t * 3\t-\tMRW formatting complete\n\t */\n\tret = 0;\n\tpr_info(\"open: mrw_status '%s'\\n\", mrw_format_status[di.mrw_status]);\n\tif (!di.mrw_status)\n\t\tret = 1;\n\telse if (di.mrw_status == CDM_MRW_BGFORMAT_INACTIVE &&\n\t\t\tmrw_format_restart)\n\t\tret = cdrom_mrw_bgformat(cdi, 1);\n\n\treturn ret;\n}\n\nstatic int mo_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[255];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, &buffer, 4, CGC_DATA_READ);\n\tcgc.quiet = 1;\n\n\t/*\n\t * obtain write protect information as per\n\t * drivers/scsi/sd.c:sd_read_write_protect_flag\n\t */\n\n\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\n\tif (ret)\n\t\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_VENDOR_PAGE, 0);\n\tif (ret) {\n\t\tcgc.buflen = 255;\n\t\tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\n\t}\n\n\t/* drive gave us no info, let the user go ahead */\n\tif (ret)\n\t\treturn 0;\n\n\treturn buffer[3] & 0x80;\n}\n\nstatic int cdrom_ram_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\tif ((ret = cdrom_has_defect_mgt(cdi)))\n\t\treturn ret;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\telse if (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\tret = !rfd.curr;\n\n\tcd_dbg(CD_OPEN, \"can open for random write\\n\");\n\treturn ret;\n}\n\nstatic void cdrom_mmc3_profile(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\tchar buffer[32];\n\tint ret, mmc3_profile;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[1] = 0;\n\tcgc.cmd[2] = cgc.cmd[3] = 0;\t\t/* Starting Feature Number */\n\tcgc.cmd[8] = sizeof(buffer);\t\t/* Allocation Length */\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\tmmc3_profile = 0xffff;\n\telse\n\t\tmmc3_profile = (buffer[6] << 8) | buffer[7];\n\n\tcdi->mmc3_profile = mmc3_profile;\n}\n\nstatic int cdrom_is_dvd_rw(struct cdrom_device_info *cdi)\n{\n\tswitch (cdi->mmc3_profile) {\n\tcase 0x12:\t/* DVD-RAM\t*/\n\tcase 0x1A:\t/* DVD+RW\t*/\n\tcase 0x43:\t/* BD-RE\t*/\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n/*\n * returns 0 for ok to open write, non-0 to disallow\n */\nstatic int cdrom_open_write(struct cdrom_device_info *cdi)\n{\n\tint mrw, mrw_write, ram_write;\n\tint ret = 1;\n\n\tmrw = 0;\n\tif (!cdrom_is_mrw(cdi, &mrw_write))\n\t\tmrw = 1;\n\n\tif (CDROM_CAN(CDC_MO_DRIVE))\n\t\tram_write = 1;\n\telse\n\t\t(void) cdrom_is_random_writable(cdi, &ram_write);\n\t\n\tif (mrw)\n\t\tcdi->mask &= ~CDC_MRW;\n\telse\n\t\tcdi->mask |= CDC_MRW;\n\n\tif (mrw_write)\n\t\tcdi->mask &= ~CDC_MRW_W;\n\telse\n\t\tcdi->mask |= CDC_MRW_W;\n\n\tif (ram_write)\n\t\tcdi->mask &= ~CDC_RAM;\n\telse\n\t\tcdi->mask |= CDC_RAM;\n\n\tif (CDROM_CAN(CDC_MRW_W))\n\t\tret = cdrom_mrw_open_write(cdi);\n\telse if (CDROM_CAN(CDC_DVD_RAM))\n\t\tret = cdrom_dvdram_open_write(cdi);\n \telse if (CDROM_CAN(CDC_RAM) &&\n \t\t !CDROM_CAN(CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_MRW|CDC_MO_DRIVE))\n \t\tret = cdrom_ram_open_write(cdi);\n\telse if (CDROM_CAN(CDC_MO_DRIVE))\n\t\tret = mo_open_write(cdi);\n\telse if (!cdrom_is_dvd_rw(cdi))\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void cdrom_dvd_rw_close_write(struct cdrom_device_info *cdi)\n{\n\tstruct packet_command cgc;\n\n\tif (cdi->mmc3_profile != 0x1a) {\n\t\tcd_dbg(CD_CLOSE, \"%s: No DVD+RW\\n\", cdi->name);\n\t\treturn;\n\t}\n\n\tif (!cdi->media_written) {\n\t\tcd_dbg(CD_CLOSE, \"%s: DVD+RW media clean\\n\", cdi->name);\n\t\treturn;\n\t}\n\n\tpr_info(\"%s: dirty DVD+RW media, \\\"finalizing\\\"\\n\", cdi->name);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_FLUSH_CACHE;\n\tcgc.timeout = 30*HZ;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.timeout = 3000*HZ;\n\tcgc.quiet = 1;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_CLOSE_TRACK;\n\tcgc.cmd[2] = 2;\t /* Close session */\n\tcgc.quiet = 1;\n\tcgc.timeout = 3000*HZ;\n\tcdi->ops->generic_packet(cdi, &cgc);\n\n\tcdi->media_written = 0;\n}\n\nstatic int cdrom_close_write(struct cdrom_device_info *cdi)\n{\n#if 0\n\treturn cdrom_flush_cache(cdi);\n#else\n\treturn 0;\n#endif\n}\n\n/* badly broken, I know. Is due for a fixup anytime. */\nstatic void cdrom_count_tracks(struct cdrom_device_info *cdi, tracktype *tracks)\n{\n\tstruct cdrom_tochdr header;\n\tstruct cdrom_tocentry entry;\n\tint ret, i;\n\ttracks->data = 0;\n\ttracks->audio = 0;\n\ttracks->cdi = 0;\n\ttracks->xa = 0;\n\ttracks->error = 0;\n\tcd_dbg(CD_COUNT_TRACKS, \"entering cdrom_count_tracks\\n\");\n\t/* Grab the TOC header so we can see how many tracks there are */\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\n\tif (ret) {\n\t\tif (ret == -ENOMEDIUM)\n\t\t\ttracks->error = CDS_NO_DISC;\n\t\telse\n\t\t\ttracks->error = CDS_NO_INFO;\n\t\treturn;\n\t}\n\t/* check what type of tracks are on this disc */\n\tentry.cdte_format = CDROM_MSF;\n\tfor (i = header.cdth_trk0; i <= header.cdth_trk1; i++) {\n\t\tentry.cdte_track = i;\n\t\tif (cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry)) {\n\t\t\ttracks->error = CDS_NO_INFO;\n\t\t\treturn;\n\t\t}\n\t\tif (entry.cdte_ctrl & CDROM_DATA_TRACK) {\n\t\t\tif (entry.cdte_format == 0x10)\n\t\t\t\ttracks->cdi++;\n\t\t\telse if (entry.cdte_format == 0x20)\n\t\t\t\ttracks->xa++;\n\t\t\telse\n\t\t\t\ttracks->data++;\n\t\t} else {\n\t\t\ttracks->audio++;\n\t\t}\n\t\tcd_dbg(CD_COUNT_TRACKS, \"track %d: format=%d, ctrl=%d\\n\",\n\t\t       i, entry.cdte_format, entry.cdte_ctrl);\n\t}\n\tcd_dbg(CD_COUNT_TRACKS, \"disc has %d tracks: %d=audio %d=data %d=Cd-I %d=XA\\n\",\n\t       header.cdth_trk1, tracks->audio, tracks->data,\n\t       tracks->cdi, tracks->xa);\n}\n\nstatic\nint open_for_data(struct cdrom_device_info *cdi)\n{\n\tint ret;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering open_for_data\\n\");\n\t/* Check if the driver can report drive status.  If it can, we\n\t   can do clever things.  If it can't, well, we at least tried! */\n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t/* can/may i close it? */\n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close the tray but failed.\\n\");\n\t\t\t\t\t/* Ignore the error from the low\n\t\t\t\t\tlevel driver.  We don't care why it\n\t\t\t\t\tcouldn't close the tray.  We only care \n\t\t\t\t\tthat there is no disc in the drive, \n\t\t\t\t\tsince that is the _REAL_ problem here.*/\n\t\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\t\tgoto clean_up_and_return;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this drive can't close the tray.\\n\");\n\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\tgoto clean_up_and_return;\n\t\t\t}\n\t\t\t/* Ok, the door should be closed now.. Check again */\n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\tcd_dbg(CD_OPEN, \"tray might not contain a medium\\n\");\n\t\t\t\tret=-ENOMEDIUM;\n\t\t\t\tgoto clean_up_and_return;\n\t\t\t}\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\n\t\t/* the door should be closed now, check for the disc */\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tif (ret!=CDS_DISC_OK) {\n\t\t\tret = -ENOMEDIUM;\n\t\t\tgoto clean_up_and_return;\n\t\t}\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error == CDS_NO_DISC) {\n\t\tcd_dbg(CD_OPEN, \"bummer. no disc.\\n\");\n\t\tret=-ENOMEDIUM;\n\t\tgoto clean_up_and_return;\n\t}\n\t/* CD-Players which don't use O_NONBLOCK, workman\n\t * for example, need bit CDO_CHECK_TYPE cleared! */\n\tif (tracks.data==0) {\n\t\tif (cdi->options & CDO_CHECK_TYPE) {\n\t\t    /* give people a warning shot, now that CDO_CHECK_TYPE\n\t\t       is the default case! */\n\t\t    cd_dbg(CD_OPEN, \"bummer. wrong media type.\\n\");\n\t\t    cd_dbg(CD_WARNING, \"pid %d must open device O_NONBLOCK!\\n\",\n\t\t\t   (unsigned int)task_pid_nr(current));\n\t\t    ret=-EMEDIUMTYPE;\n\t\t    goto clean_up_and_return;\n\t\t}\n\t\telse {\n\t\t    cd_dbg(CD_OPEN, \"wrong media type, but CDO_CHECK_TYPE not set\\n\");\n\t\t}\n\t}\n\n\tcd_dbg(CD_OPEN, \"all seems well, opening the devicen\");\n\n\t/* all seems well, we can open the device */\n\tret = cdo->open(cdi, 0); /* open for data */\n\tcd_dbg(CD_OPEN, \"opening the device gave me %d\\n\", ret);\n\t/* After all this careful checking, we shouldn't have problems\n\t   opening the device, but we don't want the device locked if \n\t   this somehow fails... */\n\tif (ret) {\n\t\tcd_dbg(CD_OPEN, \"open device failed\\n\");\n\t\tgoto clean_up_and_return;\n\t}\n\tif (CDROM_CAN(CDC_LOCK) && (cdi->options & CDO_LOCK)) {\n\t\t\tcdo->lock_door(cdi, 1);\n\t\t\tcd_dbg(CD_OPEN, \"door locked\\n\");\n\t}\n\tcd_dbg(CD_OPEN, \"device opened successfully\\n\");\n\treturn ret;\n\n\t/* Something failed.  Try to unlock the drive, because some drivers\n\t(notably ide-cd) lock the drive after every command.  This produced\n\ta nasty bug where after mount failed, the drive would remain locked!  \n\tThis ensures that the drive gets unlocked after a mount fails.  This \n\tis a goto to avoid bloating the driver with redundant code. */ \nclean_up_and_return:\n\tcd_dbg(CD_OPEN, \"open failed\\n\");\n\tif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\n\t\t\tcdo->lock_door(cdi, 0);\n\t\t\tcd_dbg(CD_OPEN, \"door unlocked\\n\");\n\t}\n\treturn ret;\n}\n\n/* We use the open-option O_NONBLOCK to indicate that the\n * purpose of opening is only for subsequent ioctl() calls; no device\n * integrity checks are performed.\n *\n * We hope that all cd-player programs will adopt this convention. It\n * is in their own interest: device control becomes a lot easier\n * this way.\n */\nint cdrom_open(struct cdrom_device_info *cdi, struct block_device *bdev,\n\t       fmode_t mode)\n{\n\tint ret;\n\n\tcd_dbg(CD_OPEN, \"entering cdrom_open\\n\");\n\n\t/* if this was a O_NONBLOCK open and we should honor the flags,\n\t * do a quick open without drive/disc integrity checks. */\n\tcdi->use_count++;\n\tif ((mode & FMODE_NDELAY) && (cdi->options & CDO_USE_FFLAGS)) {\n\t\tret = cdi->ops->open(cdi, 1);\n\t} else {\n\t\tret = open_for_data(cdi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tcdrom_mmc3_profile(cdi);\n\t\tif (mode & FMODE_WRITE) {\n\t\t\tret = -EROFS;\n\t\t\tif (cdrom_open_write(cdi))\n\t\t\t\tgoto err_release;\n\t\t\tif (!CDROM_CAN(CDC_RAM))\n\t\t\t\tgoto err_release;\n\t\t\tret = 0;\n\t\t\tcdi->media_written = 0;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\tcd_dbg(CD_OPEN, \"Use count for \\\"/dev/%s\\\" now %d\\n\",\n\t       cdi->name, cdi->use_count);\n\treturn 0;\nerr_release:\n\tif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\n\t\tcdi->ops->lock_door(cdi, 0);\n\t\tcd_dbg(CD_OPEN, \"door unlocked\\n\");\n\t}\n\tcdi->ops->release(cdi);\nerr:\n\tcdi->use_count--;\n\treturn ret;\n}\n\n/* This code is similar to that in open_for_data. The routine is called\n   whenever an audio play operation is requested.\n*/\nstatic int check_for_audio_disc(struct cdrom_device_info *cdi,\n\t\t\t\tconst struct cdrom_device_ops *cdo)\n{\n        int ret;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering check_for_audio_disc\\n\");\n\tif (!(cdi->options & CDO_CHECK_TYPE))\n\t\treturn 0;\n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t/* can/may i close it? */\n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close tray but failed.\\n\");\n\t\t\t\t\t/* Ignore the error from the low\n\t\t\t\t\tlevel driver.  We don't care why it\n\t\t\t\t\tcouldn't close the tray.  We only care \n\t\t\t\t\tthat there is no disc in the drive, \n\t\t\t\t\tsince that is the _REAL_ problem here.*/\n\t\t\t\t\treturn -ENOMEDIUM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this driver can't close the tray.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\n\t\t\t/* Ok, the door should be closed now.. Check again */\n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\t\n\t\t\tif (ret!=CDS_DISC_OK) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. disc isn't ready.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\t\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\t\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error) \n\t\treturn(tracks.error);\n\n\tif (tracks.audio==0)\n\t\treturn -EMEDIUMTYPE;\n\n\treturn 0;\n}\n\nvoid cdrom_release(struct cdrom_device_info *cdi, fmode_t mode)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint opened_for_data;\n\n\tcd_dbg(CD_CLOSE, \"entering cdrom_release\\n\");\n\n\tif (cdi->use_count > 0)\n\t\tcdi->use_count--;\n\n\tif (cdi->use_count == 0) {\n\t\tcd_dbg(CD_CLOSE, \"Use count for \\\"/dev/%s\\\" now zero\\n\",\n\t\t       cdi->name);\n\t\tcdrom_dvd_rw_close_write(cdi);\n\n\t\tif ((cdo->capability & CDC_LOCK) && !cdi->keeplocked) {\n\t\t\tcd_dbg(CD_CLOSE, \"Unlocking door!\\n\");\n\t\t\tcdo->lock_door(cdi, 0);\n\t\t}\n\t}\n\n\topened_for_data = !(cdi->options & CDO_USE_FFLAGS) ||\n\t\t!(mode & FMODE_NDELAY);\n\n\t/*\n\t * flush cache on last write release\n\t */\n\tif (CDROM_CAN(CDC_RAM) && !cdi->use_count && cdi->for_data)\n\t\tcdrom_close_write(cdi);\n\n\tcdo->release(cdi);\n\tif (cdi->use_count == 0) {      /* last process that closes dev*/\n\t\tif (opened_for_data &&\n\t\t    cdi->options & CDO_AUTO_EJECT && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdo->tray_move(cdi, 1);\n\t}\n}\n\nstatic int cdrom_read_mech_status(struct cdrom_device_info *cdi, \n\t\t\t\t  struct cdrom_changer_info *buf)\n{\n\tstruct packet_command cgc;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint length;\n\n\t/*\n\t * Sanyo changer isn't spec compliant (doesn't use regular change\n\t * LOAD_UNLOAD command, and it doesn't implement the mech status\n\t * command below\n\t */\n\tif (cdi->sanyo_slot) {\n\t\tbuf->hdr.nslots = 3;\n\t\tbuf->hdr.curslot = cdi->sanyo_slot == 3 ? 0 : cdi->sanyo_slot;\n\t\tfor (length = 0; length < 3; length++) {\n\t\t\tbuf->slots[length].disc_present = 1;\n\t\t\tbuf->slots[length].change = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlength = sizeof(struct cdrom_mechstat_header) +\n\t\t cdi->capacity * sizeof(struct cdrom_slot);\n\n\tinit_cdrom_command(&cgc, buf, length, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_MECHANISM_STATUS;\n\tcgc.cmd[8] = (length >> 8) & 0xff;\n\tcgc.cmd[9] = length & 0xff;\n\treturn cdo->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_slot_status(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_slot_status()\\n\");\n\tif (cdi->sanyo_slot)\n\t\treturn CDS_NO_INFO;\n\t\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((ret = cdrom_read_mech_status(cdi, info)))\n\t\tgoto out_free;\n\n\tif (info->slots[slot].disc_present)\n\t\tret = CDS_DISC_OK;\n\telse\n\t\tret = CDS_NO_DISC;\n\nout_free:\n\tkfree(info);\n\treturn ret;\n}\n\n/* Return the number of slots for an ATAPI/SCSI cdrom, \n * return 1 if not a changer. \n */\nint cdrom_number_of_slots(struct cdrom_device_info *cdi) \n{\n\tint status;\n\tint nslots = 1;\n\tstruct cdrom_changer_info *info;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_number_of_slots()\\n\");\n\t/* cdrom_read_mech_status requires a valid value for capacity: */\n\tcdi->capacity = 0; \n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((status = cdrom_read_mech_status(cdi, info)) == 0)\n\t\tnslots = info->hdr.nslots;\n\n\tkfree(info);\n\treturn nslots;\n}\n\n\n/* If SLOT < 0, unload the current slot.  Otherwise, try to load SLOT. */\nstatic int cdrom_load_unload(struct cdrom_device_info *cdi, int slot) \n{\n\tstruct packet_command cgc;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_load_unload()\\n\");\n\tif (cdi->sanyo_slot && slot < 0)\n\t\treturn 0;\n\n\tinit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\n\tcgc.cmd[0] = GPCMD_LOAD_UNLOAD;\n\tcgc.cmd[4] = 2 + (slot >= 0);\n\tcgc.cmd[8] = slot;\n\tcgc.timeout = 60 * HZ;\n\n\t/* The Sanyo 3 CD changer uses byte 7 of the \n\tGPCMD_TEST_UNIT_READY to command to switch CDs instead of\n\tusing the GPCMD_LOAD_UNLOAD opcode. */\n\tif (cdi->sanyo_slot && -1 < slot) {\n\t\tcgc.cmd[0] = GPCMD_TEST_UNIT_READY;\n\t\tcgc.cmd[7] = slot;\n\t\tcgc.cmd[4] = cgc.cmd[8] = 0;\n\t\tcdi->sanyo_slot = slot ? slot : 3;\n\t}\n\n\treturn cdi->ops->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_select_disc(struct cdrom_device_info *cdi, int slot)\n{\n\tstruct cdrom_changer_info *info;\n\tint curslot;\n\tint ret;\n\n\tcd_dbg(CD_CHANGER, \"entering cdrom_select_disc()\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tif (cdi->ops->check_events)\n\t\tcdi->ops->check_events(cdi, 0, slot);\n\telse\n\t\tcdi->ops->media_changed(cdi, slot);\n\n\tif (slot == CDSL_NONE) {\n\t\t/* set media changed bits, on both queues */\n\t\tcdi->mc_flags = 0x3;\n\t\treturn cdrom_load_unload(cdi, -1);\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif ((ret = cdrom_read_mech_status(cdi, info))) {\n\t\tkfree(info);\n\t\treturn ret;\n\t}\n\n\tcurslot = info->hdr.curslot;\n\tkfree(info);\n\n\tif (cdi->use_count > 1 || cdi->keeplocked) {\n\t\tif (slot == CDSL_CURRENT) {\n\t    \t\treturn curslot;\n\t\t} else {\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* Specifying CDSL_CURRENT will attempt to load the currnet slot,\n\twhich is useful if it had been previously unloaded.\n\tWhether it can or not, it returns the current slot. \n\tSimilarly,  if slot happens to be the current one, we still\n\ttry and load it. */\n\tif (slot == CDSL_CURRENT)\n\t\tslot = curslot;\n\n\t/* set media changed bits on both queues */\n\tcdi->mc_flags = 0x3;\n\tif ((ret = cdrom_load_unload(cdi, slot)))\n\t\treturn ret;\n\n\treturn slot;\n}\n\n/*\n * As cdrom implements an extra ioctl consumer for media changed\n * event, it needs to buffer ->check_events() output, such that event\n * is not lost for both the usual VFS and ioctl paths.\n * cdi->{vfs|ioctl}_events are used to buffer pending events for each\n * path.\n *\n * XXX: Locking is non-existent.  cdi->ops->check_events() can be\n * called in parallel and buffering fields are accessed without any\n * exclusion.  The original media_changed code had the same problem.\n * It might be better to simply deprecate CDROM_MEDIA_CHANGED ioctl\n * and remove this cruft altogether.  It doesn't have much usefulness\n * at this point.\n */\nstatic void cdrom_update_events(struct cdrom_device_info *cdi,\n\t\t\t\tunsigned int clearing)\n{\n\tunsigned int events;\n\n\tevents = cdi->ops->check_events(cdi, clearing, CDSL_CURRENT);\n\tcdi->vfs_events |= events;\n\tcdi->ioctl_events |= events;\n}\n\nunsigned int cdrom_check_events(struct cdrom_device_info *cdi,\n\t\t\t\tunsigned int clearing)\n{\n\tunsigned int events;\n\n\tcdrom_update_events(cdi, clearing);\n\tevents = cdi->vfs_events;\n\tcdi->vfs_events = 0;\n\treturn events;\n}\nEXPORT_SYMBOL(cdrom_check_events);\n\n/* We want to make media_changed accessible to the user through an\n * ioctl. The main problem now is that we must double-buffer the\n * low-level implementation, to assure that the VFS and the user both\n * see a medium change once.\n */\n\nstatic\nint media_changed(struct cdrom_device_info *cdi, int queue)\n{\n\tunsigned int mask = (1 << (queue & 1));\n\tint ret = !!(cdi->mc_flags & mask);\n\tbool changed;\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn ret;\n\n\t/* changed since last call? */\n\tif (cdi->ops->check_events) {\n\t\tBUG_ON(!queue);\t/* shouldn't be called from VFS path */\n\t\tcdrom_update_events(cdi, DISK_EVENT_MEDIA_CHANGE);\n\t\tchanged = cdi->ioctl_events & DISK_EVENT_MEDIA_CHANGE;\n\t\tcdi->ioctl_events = 0;\n\t} else\n\t\tchanged = cdi->ops->media_changed(cdi, CDSL_CURRENT);\n\n\tif (changed) {\n\t\tcdi->mc_flags = 0x3;    /* set bit on both queues */\n\t\tret |= 1;\n\t\tcdi->media_written = 0;\n\t}\n\n\tcdi->mc_flags &= ~mask;         /* clear bit */\n\treturn ret;\n}\n\nint cdrom_media_changed(struct cdrom_device_info *cdi)\n{\n\t/* This talks to the VFS, which doesn't like errors - just 1 or 0.  \n\t * Returning \"0\" is always safe (media hasn't been changed). Do that \n\t * if the low-level cdrom driver dosn't support media changed. */ \n\tif (cdi == NULL || cdi->ops->media_changed == NULL)\n\t\treturn 0;\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn 0;\n\treturn media_changed(cdi, 0);\n}\n\n/* Requests to the low-level drivers will /always/ be done in the\n   following format convention:\n\n   CDROM_LBA: all data-related requests.\n   CDROM_MSF: all audio-related requests.\n\n   However, a low-level implementation is allowed to refuse this\n   request, and return information in its own favorite format.\n\n   It doesn't make sense /at all/ to ask for a play_audio in LBA\n   format, or ask for multi-session info in MSF format. However, for\n   backward compatibility these format requests will be satisfied, but\n   the requests to the low-level drivers will be sanitized in the more\n   meaningful format indicated above.\n */\n\nstatic\nvoid sanitize_format(union cdrom_addr *addr,\n\t\t     u_char * curr, u_char requested)\n{\n\tif (*curr == requested)\n\t\treturn;                 /* nothing to be done! */\n\tif (requested == CDROM_LBA) {\n\t\taddr->lba = (int) addr->msf.frame +\n\t\t\t75 * (addr->msf.second - 2 + 60 * addr->msf.minute);\n\t} else {                        /* CDROM_MSF */\n\t\tint lba = addr->lba;\n\t\taddr->msf.frame = lba % 75;\n\t\tlba /= 75;\n\t\tlba += 2;\n\t\taddr->msf.second = lba % 60;\n\t\taddr->msf.minute = lba / 60;\n\t}\n\t*curr = requested;\n}\n\nvoid init_cdrom_command(struct packet_command *cgc, void *buf, int len,\n\t\t\tint type)\n{\n\tmemset(cgc, 0, sizeof(struct packet_command));\n\tif (buf)\n\t\tmemset(buf, 0, len);\n\tcgc->buffer = (char *) buf;\n\tcgc->buflen = len;\n\tcgc->data_direction = type;\n\tcgc->timeout = CDROM_DEF_TIMEOUT;\n}\n\n/* DVD handling */\n\n#define copy_key(dest,src)\tmemcpy((dest), (src), sizeof(dvd_key))\n#define copy_chal(dest,src)\tmemcpy((dest), (src), sizeof(dvd_challenge))\n\nstatic void setup_report_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_REPORT_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 0: case 8: case 5: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: case 4: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_READ;\n}\n\nstatic void setup_send_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_SEND_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t\tcase 6: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_WRITE;\n}\n\nstatic int dvd_do_auth(struct cdrom_device_info *cdi, dvd_authinfo *ai)\n{\n\tint ret;\n\tu_char buf[20];\n\tstruct packet_command cgc;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\trpc_state_t rpc_state;\n\n\tmemset(buf, 0, sizeof(buf));\n\tinit_cdrom_command(&cgc, buf, 0, CGC_DATA_READ);\n\n\tswitch (ai->type) {\n\t/* LU data send */\n\tcase DVD_LU_SEND_AGID:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_AGID\\n\");\n\t\tcgc.quiet = 1;\n\t\tsetup_report_key(&cgc, ai->lsa.agid, 0);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lsa.agid = buf[7] >> 6;\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\tcase DVD_LU_SEND_KEY1:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_KEY1\\n\");\n\t\tsetup_report_key(&cgc, ai->lsk.agid, 2);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tcopy_key(ai->lsk.key, &buf[4]);\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\tcase DVD_LU_SEND_CHALLENGE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_CHALLENGE\\n\");\n\t\tsetup_report_key(&cgc, ai->lsc.agid, 1);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tcopy_chal(ai->lsc.chal, &buf[4]);\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\t/* Post-auth key */\n\tcase DVD_LU_SEND_TITLE_KEY:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_TITLE_KEY\\n\");\n\t\tcgc.quiet = 1;\n\t\tsetup_report_key(&cgc, ai->lstk.agid, 4);\n\t\tcgc.cmd[5] = ai->lstk.lba;\n\t\tcgc.cmd[4] = ai->lstk.lba >> 8;\n\t\tcgc.cmd[3] = ai->lstk.lba >> 16;\n\t\tcgc.cmd[2] = ai->lstk.lba >> 24;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lstk.cpm = (buf[4] >> 7) & 1;\n\t\tai->lstk.cp_sec = (buf[4] >> 6) & 1;\n\t\tai->lstk.cgms = (buf[4] >> 4) & 3;\n\t\tcopy_key(ai->lstk.title_key, &buf[5]);\n\t\t/* Returning data, let host change state */\n\t\tbreak;\n\n\tcase DVD_LU_SEND_ASF:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_ASF\\n\");\n\t\tsetup_report_key(&cgc, ai->lsasf.agid, 5);\n\t\t\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lsasf.asf = buf[7] & 1;\n\t\tbreak;\n\n\t/* LU data receive (LU changes state) */\n\tcase DVD_HOST_SEND_CHALLENGE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_CHALLENGE\\n\");\n\t\tsetup_send_key(&cgc, ai->hsc.agid, 1);\n\t\tbuf[1] = 0xe;\n\t\tcopy_chal(&buf[4], ai->hsc.chal);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->type = DVD_LU_SEND_KEY1;\n\t\tbreak;\n\n\tcase DVD_HOST_SEND_KEY2:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_KEY2\\n\");\n\t\tsetup_send_key(&cgc, ai->hsk.agid, 3);\n\t\tbuf[1] = 0xa;\n\t\tcopy_key(&buf[4], ai->hsk.key);\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc))) {\n\t\t\tai->type = DVD_AUTH_FAILURE;\n\t\t\treturn ret;\n\t\t}\n\t\tai->type = DVD_AUTH_ESTABLISHED;\n\t\tbreak;\n\n\t/* Misc */\n\tcase DVD_INVALIDATE_AGID:\n\t\tcgc.quiet = 1;\n\t\tcd_dbg(CD_DVD, \"entering DVD_INVALIDATE_AGID\\n\");\n\t\tsetup_report_key(&cgc, ai->lsa.agid, 0x3f);\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\t\tbreak;\n\n\t/* Get region settings */\n\tcase DVD_LU_SEND_RPC_STATE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_LU_SEND_RPC_STATE\\n\");\n\t\tsetup_report_key(&cgc, 0, 8);\n\t\tmemset(&rpc_state, 0, sizeof(rpc_state_t));\n\t\tcgc.buffer = (char *) &rpc_state;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\n\t\tai->lrpcs.type = rpc_state.type_code;\n\t\tai->lrpcs.vra = rpc_state.vra;\n\t\tai->lrpcs.ucca = rpc_state.ucca;\n\t\tai->lrpcs.region_mask = rpc_state.region_mask;\n\t\tai->lrpcs.rpc_scheme = rpc_state.rpc_scheme;\n\t\tbreak;\n\n\t/* Set region settings */\n\tcase DVD_HOST_SEND_RPC_STATE:\n\t\tcd_dbg(CD_DVD, \"entering DVD_HOST_SEND_RPC_STATE\\n\");\n\t\tsetup_send_key(&cgc, 0, 6);\n\t\tbuf[1] = 6;\n\t\tbuf[4] = ai->hrpcs.pdrc;\n\n\t\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\tcd_dbg(CD_WARNING, \"Invalid DVD key ioctl (%d)\\n\", ai->type);\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvd_read_physical(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tunsigned char buf[21], *base;\n\tstruct dvd_layer *layer;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tint ret, layer_num = s->physical.layer_num;\n\n\tif (layer_num >= DVD_LAYERS)\n\t\treturn -EINVAL;\n\n\tinit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[6] = layer_num;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\t/*\n\t * refrain from reporting errors on non-existing layers (mainly)\n\t */\n\tcgc->quiet = 1;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tbase = &buf[4];\n\tlayer = &s->physical.layer[layer_num];\n\n\t/*\n\t * place the data... really ugly, but at least we won't have to\n\t * worry about endianess in userspace.\n\t */\n\tmemset(layer, 0, sizeof(*layer));\n\tlayer->book_version = base[0] & 0xf;\n\tlayer->book_type = base[0] >> 4;\n\tlayer->min_rate = base[1] & 0xf;\n\tlayer->disc_size = base[1] >> 4;\n\tlayer->layer_type = base[2] & 0xf;\n\tlayer->track_path = (base[2] >> 4) & 1;\n\tlayer->nlayers = (base[2] >> 5) & 3;\n\tlayer->track_density = base[3] & 0xf;\n\tlayer->linear_density = base[3] >> 4;\n\tlayer->start_sector = base[5] << 16 | base[6] << 8 | base[7];\n\tlayer->end_sector = base[9] << 16 | base[10] << 8 | base[11];\n\tlayer->end_sector_l0 = base[13] << 16 | base[14] << 8 | base[15];\n\tlayer->bca = base[16] >> 7;\n\n\treturn 0;\n}\n\nstatic int dvd_read_copyright(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret;\n\tu_char buf[8];\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tinit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[6] = s->copyright.layer_num;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = cgc->buflen >> 8;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\treturn ret;\n\n\ts->copyright.cpst = buf[4];\n\ts->copyright.rmi = buf[5];\n\n\treturn 0;\n}\n\nstatic int dvd_read_disckey(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret, size;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tsize = sizeof(s->disckey.value) + 4;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = size >> 8;\n\tcgc->cmd[9] = size & 0xff;\n\tcgc->cmd[10] = s->disckey.agid << 6;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (!ret)\n\t\tmemcpy(s->disckey.value, &buf[4], sizeof(s->disckey.value));\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\tstruct packet_command *cgc)\n{\n\tint ret, size = 4 + 188;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[9] = cgc->buflen & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\ts->bca.len = buf[0] << 8 | buf[1];\n\tif (s->bca.len < 12 || s->bca.len > 188) {\n\t\tcd_dbg(CD_WARNING, \"Received invalid BCA length (%d)\\n\",\n\t\t       s->bca.len);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(s->bca.value, &buf[4], s->bca.len);\n\tret = 0;\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_manufact(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tint ret = 0, size;\n\tu_char *buf;\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tsize = sizeof(s->manufact.value) + 4;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tinit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\n\tcgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\n\tcgc->cmd[7] = s->type;\n\tcgc->cmd[8] = size >> 8;\n\tcgc->cmd[9] = size & 0xff;\n\n\tret = cdo->generic_packet(cdi, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\ts->manufact.len = buf[0] << 8 | buf[1];\n\tif (s->manufact.len < 0) {\n\t\tcd_dbg(CD_WARNING, \"Received invalid manufacture info length (%d)\\n\",\n\t\t       s->manufact.len);\n\t\tret = -EIO;\n\t} else {\n\t\tif (s->manufact.len > 2048) {\n\t\t\tcd_dbg(CD_WARNING, \"Received invalid manufacture info length (%d): truncating to 2048\\n\",\n\t\t\t       s->manufact.len);\n\t\t\ts->manufact.len = 2048;\n\t\t}\n\t\tmemcpy(s->manufact.value, &buf[4], s->manufact.len);\n\t}\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dvd_read_struct(struct cdrom_device_info *cdi, dvd_struct *s,\n\t\t\t\tstruct packet_command *cgc)\n{\n\tswitch (s->type) {\n\tcase DVD_STRUCT_PHYSICAL:\n\t\treturn dvd_read_physical(cdi, s, cgc);\n\n\tcase DVD_STRUCT_COPYRIGHT:\n\t\treturn dvd_read_copyright(cdi, s, cgc);\n\n\tcase DVD_STRUCT_DISCKEY:\n\t\treturn dvd_read_disckey(cdi, s, cgc);\n\n\tcase DVD_STRUCT_BCA:\n\t\treturn dvd_read_bca(cdi, s, cgc);\n\n\tcase DVD_STRUCT_MANUFACT:\n\t\treturn dvd_read_manufact(cdi, s, cgc);\n\t\t\n\tdefault:\n\t\tcd_dbg(CD_WARNING, \": Invalid DVD structure read requested (%d)\\n\",\n\t\t       s->type);\n\t\treturn -EINVAL;\n\t}\n}\n\nint cdrom_mode_sense(struct cdrom_device_info *cdi,\n\t\t     struct packet_command *cgc,\n\t\t     int page_code, int page_control)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(cgc->cmd, 0, sizeof(cgc->cmd));\n\n\tcgc->cmd[0] = GPCMD_MODE_SENSE_10;\n\tcgc->cmd[2] = page_code | (page_control << 6);\n\tcgc->cmd[7] = cgc->buflen >> 8;\n\tcgc->cmd[8] = cgc->buflen & 0xff;\n\tcgc->data_direction = CGC_DATA_READ;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nint cdrom_mode_select(struct cdrom_device_info *cdi,\n\t\t      struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(cgc->cmd, 0, sizeof(cgc->cmd));\n\tmemset(cgc->buffer, 0, 2);\n\tcgc->cmd[0] = GPCMD_MODE_SELECT_10;\n\tcgc->cmd[1] = 0x10;\t\t/* PF */\n\tcgc->cmd[7] = cgc->buflen >> 8;\n\tcgc->cmd[8] = cgc->buflen & 0xff;\n\tcgc->data_direction = CGC_DATA_WRITE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic int cdrom_read_subchannel(struct cdrom_device_info *cdi,\n\t\t\t\t struct cdrom_subchnl *subchnl, int mcn)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tchar buffer[32];\n\tint ret;\n\n\tinit_cdrom_command(&cgc, buffer, 16, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\n\tcgc.cmd[1] = subchnl->cdsc_format;/* MSF or LBA addressing */\n\tcgc.cmd[2] = 0x40;  /* request subQ data */\n\tcgc.cmd[3] = mcn ? 2 : 1;\n\tcgc.cmd[8] = 16;\n\n\tif ((ret = cdo->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tsubchnl->cdsc_audiostatus = cgc.buffer[1];\n\tsubchnl->cdsc_ctrl = cgc.buffer[5] & 0xf;\n\tsubchnl->cdsc_trk = cgc.buffer[6];\n\tsubchnl->cdsc_ind = cgc.buffer[7];\n\n\tif (subchnl->cdsc_format == CDROM_LBA) {\n\t\tsubchnl->cdsc_absaddr.lba = ((cgc.buffer[8] << 24) |\n\t\t\t\t\t\t(cgc.buffer[9] << 16) |\n\t\t\t\t\t\t(cgc.buffer[10] << 8) |\n\t\t\t\t\t\t(cgc.buffer[11]));\n\t\tsubchnl->cdsc_reladdr.lba = ((cgc.buffer[12] << 24) |\n\t\t\t\t\t\t(cgc.buffer[13] << 16) |\n\t\t\t\t\t\t(cgc.buffer[14] << 8) |\n\t\t\t\t\t\t(cgc.buffer[15]));\n\t} else {\n\t\tsubchnl->cdsc_reladdr.msf.minute = cgc.buffer[13];\n\t\tsubchnl->cdsc_reladdr.msf.second = cgc.buffer[14];\n\t\tsubchnl->cdsc_reladdr.msf.frame = cgc.buffer[15];\n\t\tsubchnl->cdsc_absaddr.msf.minute = cgc.buffer[9];\n\t\tsubchnl->cdsc_absaddr.msf.second = cgc.buffer[10];\n\t\tsubchnl->cdsc_absaddr.msf.frame = cgc.buffer[11];\n\t}\n\n\treturn 0;\n}\n\n/*\n * Specific READ_10 interface\n */\nstatic int cdrom_read_cd(struct cdrom_device_info *cdi,\n\t\t\t struct packet_command *cgc, int lba,\n\t\t\t int blocksize, int nblocks)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\n\tcgc->cmd[0] = GPCMD_READ_10;\n\tcgc->cmd[2] = (lba >> 24) & 0xff;\n\tcgc->cmd[3] = (lba >> 16) & 0xff;\n\tcgc->cmd[4] = (lba >>  8) & 0xff;\n\tcgc->cmd[5] = lba & 0xff;\n\tcgc->cmd[6] = (nblocks >> 16) & 0xff;\n\tcgc->cmd[7] = (nblocks >>  8) & 0xff;\n\tcgc->cmd[8] = nblocks & 0xff;\n\tcgc->buflen = blocksize * nblocks;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\n/* very generic interface for reading the various types of blocks */\nstatic int cdrom_read_block(struct cdrom_device_info *cdi,\n\t\t\t    struct packet_command *cgc,\n\t\t\t    int lba, int nblocks, int format, int blksize)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\n\tmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\n\tcgc->cmd[0] = GPCMD_READ_CD;\n\t/* expected sector size - cdda,mode1,etc. */\n\tcgc->cmd[1] = format << 2;\n\t/* starting address */\n\tcgc->cmd[2] = (lba >> 24) & 0xff;\n\tcgc->cmd[3] = (lba >> 16) & 0xff;\n\tcgc->cmd[4] = (lba >>  8) & 0xff;\n\tcgc->cmd[5] = lba & 0xff;\n\t/* number of blocks */\n\tcgc->cmd[6] = (nblocks >> 16) & 0xff;\n\tcgc->cmd[7] = (nblocks >>  8) & 0xff;\n\tcgc->cmd[8] = nblocks & 0xff;\n\tcgc->buflen = blksize * nblocks;\n\t\n\t/* set the header info returned */\n\tswitch (blksize) {\n\tcase CD_FRAMESIZE_RAW0\t: cgc->cmd[9] = 0x58; break;\n\tcase CD_FRAMESIZE_RAW1\t: cgc->cmd[9] = 0x78; break;\n\tcase CD_FRAMESIZE_RAW\t: cgc->cmd[9] = 0xf8; break;\n\tdefault\t\t\t: cgc->cmd[9] = 0x10;\n\t}\n\t\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic int cdrom_read_cdda_old(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t       int lba, int nframes)\n{\n\tstruct packet_command cgc;\n\tint ret = 0;\n\tint nr;\n\n\tcdi->last_sense = 0;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\n\t/*\n\t * start with will ra.nframes size, back down if alloc fails\n\t */\n\tnr = nframes;\n\tdo {\n\t\tcgc.buffer = kmalloc_array(nr, CD_FRAMESIZE_RAW, GFP_KERNEL);\n\t\tif (cgc.buffer)\n\t\t\tbreak;\n\n\t\tnr >>= 1;\n\t} while (nr);\n\n\tif (!nr)\n\t\treturn -ENOMEM;\n\n\tcgc.data_direction = CGC_DATA_READ;\n\twhile (nframes > 0) {\n\t\tif (nr > nframes)\n\t\t\tnr = nframes;\n\n\t\tret = cdrom_read_block(cdi, &cgc, lba, nr, 1, CD_FRAMESIZE_RAW);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (copy_to_user(ubuf, cgc.buffer, CD_FRAMESIZE_RAW * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tubuf += CD_FRAMESIZE_RAW * nr;\n\t\tnframes -= nr;\n\t\tlba += nr;\n\t}\n\tkfree(cgc.buffer);\n\treturn ret;\n}\n\nstatic int cdrom_read_cdda_bpc(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t       int lba, int nframes)\n{\n\tstruct request_queue *q = cdi->disk->queue;\n\tstruct request *rq;\n\tstruct scsi_request *req;\n\tstruct bio *bio;\n\tunsigned int len;\n\tint nr, ret = 0;\n\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tif (!blk_queue_scsi_passthrough(q)) {\n\t\tWARN_ONCE(true,\n\t\t\t  \"Attempt read CDDA info through a non-SCSI queue\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcdi->last_sense = 0;\n\n\twhile (nframes) {\n\t\tnr = nframes;\n\t\tif (cdi->cdda_method == CDDA_BPC_SINGLE)\n\t\t\tnr = 1;\n\t\tif (nr * CD_FRAMESIZE_RAW > (queue_max_sectors(q) << 9))\n\t\t\tnr = (queue_max_sectors(q) << 9) / CD_FRAMESIZE_RAW;\n\n\t\tlen = nr * CD_FRAMESIZE_RAW;\n\n\t\trq = blk_get_request(q, REQ_OP_SCSI_IN, 0);\n\t\tif (IS_ERR(rq)) {\n\t\t\tret = PTR_ERR(rq);\n\t\t\tbreak;\n\t\t}\n\t\treq = scsi_req(rq);\n\n\t\tret = blk_rq_map_user(q, rq, NULL, ubuf, len, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tblk_put_request(rq);\n\t\t\tbreak;\n\t\t}\n\n\t\treq->cmd[0] = GPCMD_READ_CD;\n\t\treq->cmd[1] = 1 << 2;\n\t\treq->cmd[2] = (lba >> 24) & 0xff;\n\t\treq->cmd[3] = (lba >> 16) & 0xff;\n\t\treq->cmd[4] = (lba >>  8) & 0xff;\n\t\treq->cmd[5] = lba & 0xff;\n\t\treq->cmd[6] = (nr >> 16) & 0xff;\n\t\treq->cmd[7] = (nr >>  8) & 0xff;\n\t\treq->cmd[8] = nr & 0xff;\n\t\treq->cmd[9] = 0xf8;\n\n\t\treq->cmd_len = 12;\n\t\trq->timeout = 60 * HZ;\n\t\tbio = rq->bio;\n\n\t\tblk_execute_rq(q, cdi->disk, rq, 0);\n\t\tif (scsi_req(rq)->result) {\n\t\t\tstruct scsi_sense_hdr sshdr;\n\n\t\t\tret = -EIO;\n\t\t\tscsi_normalize_sense(req->sense, req->sense_len,\n\t\t\t\t\t     &sshdr);\n\t\t\tcdi->last_sense = sshdr.sense_key;\n\t\t}\n\n\t\tif (blk_rq_unmap_user(bio))\n\t\t\tret = -EFAULT;\n\t\tblk_put_request(rq);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnframes -= nr;\n\t\tlba += nr;\n\t\tubuf += len;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdrom_read_cdda(struct cdrom_device_info *cdi, __u8 __user *ubuf,\n\t\t\t   int lba, int nframes)\n{\n\tint ret;\n\n\tif (cdi->cdda_method == CDDA_OLD)\n\t\treturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\n\nretry:\n\t/*\n\t * for anything else than success and io error, we need to retry\n\t */\n\tret = cdrom_read_cdda_bpc(cdi, ubuf, lba, nframes);\n\tif (!ret || ret != -EIO)\n\t\treturn ret;\n\n\t/*\n\t * I've seen drives get sense 4/8/3 udma crc errors on multi\n\t * frame dma, so drop to single frame dma if we need to\n\t */\n\tif (cdi->cdda_method == CDDA_BPC_FULL && nframes > 1) {\n\t\tpr_info(\"dropping to single frame dma\\n\");\n\t\tcdi->cdda_method = CDDA_BPC_SINGLE;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * so we have an io error of some sort with multi frame dma. if the\n\t * condition wasn't a hardware error\n\t * problems, not for any error\n\t */\n\tif (cdi->last_sense != 0x04 && cdi->last_sense != 0x0b)\n\t\treturn ret;\n\n\tpr_info(\"dropping to old style cdda (sense=%x)\\n\", cdi->last_sense);\n\tcdi->cdda_method = CDDA_OLD;\n\treturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\t\n}\n\nstatic int cdrom_ioctl_multisession(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_multisession ms_info;\n\tu8 requested_format;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMMULTISESSION\\n\");\n\n\tif (!(cdi->ops->capability & CDC_MULTI_SESSION))\n\t\treturn -ENOSYS;\n\n\tif (copy_from_user(&ms_info, argp, sizeof(ms_info)))\n\t\treturn -EFAULT;\n\n\trequested_format = ms_info.addr_format;\n\tif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\n\t\treturn -EINVAL;\n\tms_info.addr_format = CDROM_LBA;\n\n\tret = cdi->ops->get_last_session(cdi, &ms_info);\n\tif (ret)\n\t\treturn ret;\n\n\tsanitize_format(&ms_info.addr, &ms_info.addr_format, requested_format);\n\n\tif (copy_to_user(argp, &ms_info, sizeof(ms_info)))\n\t\treturn -EFAULT;\n\n\tcd_dbg(CD_DO_IOCTL, \"CDROMMULTISESSION successful\\n\");\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_eject(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->use_count != 1 || cdi->keeplocked)\n\t\treturn -EBUSY;\n\tif (CDROM_CAN(CDC_LOCK)) {\n\t\tint ret = cdi->ops->lock_door(cdi, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn cdi->ops->tray_move(cdi, 1);\n}\n\nstatic int cdrom_ioctl_closetray(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMCLOSETRAY\\n\");\n\n\tif (!CDROM_CAN(CDC_CLOSE_TRAY))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->tray_move(cdi, 0);\n}\n\nstatic int cdrom_ioctl_eject_sw(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT_SW\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->keeplocked)\n\t\treturn -EBUSY;\n\n\tcdi->options &= ~(CDO_AUTO_CLOSE | CDO_AUTO_EJECT);\n\tif (arg)\n\t\tcdi->options |= CDO_AUTO_CLOSE | CDO_AUTO_EJECT;\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\n\t/* cannot select disc or select current disc */\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\n\tif (arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}\n\nstatic int cdrom_ioctl_set_options(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SET_OPTIONS\\n\");\n\n\t/*\n\t * Options need to be in sync with capability.\n\t * Too late for that, so we have to check each one separately.\n\t */\n\tswitch (arg) {\n\tcase CDO_USE_FFLAGS:\n\tcase CDO_CHECK_TYPE:\n\t\tbreak;\n\tcase CDO_LOCK:\n\t\tif (!CDROM_CAN(CDC_LOCK))\n\t\t\treturn -ENOSYS;\n\t\tbreak;\n\tcase 0:\n\t\treturn cdi->options;\n\t/* default is basically CDO_[AUTO_CLOSE|AUTO_EJECT] */\n\tdefault:\n\t\tif (!CDROM_CAN(arg))\n\t\t\treturn -ENOSYS;\n\t}\n\tcdi->options |= (int) arg;\n\treturn cdi->options;\n}\n\nstatic int cdrom_ioctl_clear_options(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_CLEAR_OPTIONS\\n\");\n\n\tcdi->options &= ~(int) arg;\n\treturn cdi->options;\n}\n\nstatic int cdrom_ioctl_select_speed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_SPEED\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_SPEED))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->select_speed(cdi, arg);\n}\n\nstatic int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n\nstatic int cdrom_ioctl_reset(struct cdrom_device_info *cdi,\n\t\tstruct block_device *bdev)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_RESET\\n\");\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!CDROM_CAN(CDC_RESET))\n\t\treturn -ENOSYS;\n\tinvalidate_bdev(bdev);\n\treturn cdi->ops->reset(cdi);\n}\n\nstatic int cdrom_ioctl_lock_door(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"%socking door\\n\", arg ? \"L\" : \"Unl\");\n\n\tif (!CDROM_CAN(CDC_LOCK))\n\t\treturn -EDRIVE_CANT_DO_THIS;\n\n\tcdi->keeplocked = arg ? 1 : 0;\n\n\t/*\n\t * Don't unlock the door on multiple opens by default, but allow\n\t * root to do so.\n\t */\n\tif (cdi->use_count != 1 && !arg && !capable(CAP_SYS_ADMIN))\n\t\treturn -EBUSY;\n\treturn cdi->ops->lock_door(cdi, arg);\n}\n\nstatic int cdrom_ioctl_debug(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"%sabling debug\\n\", arg ? \"En\" : \"Dis\");\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tdebug = arg ? 1 : 0;\n\treturn debug;\n}\n\nstatic int cdrom_ioctl_get_capability(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_GET_CAPABILITY\\n\");\n\treturn (cdi->ops->capability & ~cdi->mask);\n}\n\n/*\n * The following function is implemented, although very few audio\n * discs give Universal Product Code information, which should just be\n * the Medium Catalog Number on the box.  Note, that the way the code\n * is written on the CD is /not/ uniform across all discs!\n */\nstatic int cdrom_ioctl_get_mcn(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_mcn mcn;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_GET_MCN\\n\");\n\n\tif (!(cdi->ops->capability & CDC_MCN))\n\t\treturn -ENOSYS;\n\tret = cdi->ops->get_mcn(cdi, &mcn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &mcn, sizeof(mcn)))\n\t\treturn -EFAULT;\n\tcd_dbg(CD_DO_IOCTL, \"CDROM_GET_MCN successful\\n\");\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}\n\n/*\n * Ok, this is where problems start.  The current interface for the\n * CDROM_DISC_STATUS ioctl is flawed.  It makes the false assumption that\n * CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.  Unfortunately, while this\n * is often the case, it is also very common for CDs to have some tracks\n * with data, and some tracks with audio.  Just because I feel like it,\n * I declare the following to be the best way to cope.  If the CD has ANY\n * data tracks on it, it will be returned as a data CD.  If it has any XA\n * tracks, I will return it as that.  Now I could simplify this interface\n * by combining these  returns with the above, but this more clearly\n * demonstrates the problem with the current interface.  Too bad this\n * wasn't designed to use bitmasks...         -Erik\n *\n * Well, now we have the option CDS_MIXED: a mixed-type CD.\n * User level programmers might feel the ioctl is not very useful.\n *\t\t\t\t\t---david\n */\nstatic int cdrom_ioctl_disc_status(struct cdrom_device_info *cdi)\n{\n\ttracktype tracks;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DISC_STATUS\\n\");\n\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error)\n\t\treturn tracks.error;\n\n\t/* Policy mode on */\n\tif (tracks.audio > 0) {\n\t\tif (!tracks.data && !tracks.cdi && !tracks.xa)\n\t\t\treturn CDS_AUDIO;\n\t\telse\n\t\t\treturn CDS_MIXED;\n\t}\n\n\tif (tracks.cdi > 0)\n\t\treturn CDS_XA_2_2;\n\tif (tracks.xa > 0)\n\t\treturn CDS_XA_2_1;\n\tif (tracks.data > 0)\n\t\treturn CDS_DATA_1;\n\t/* Policy mode off */\n\n\tcd_dbg(CD_WARNING, \"This disc doesn't have any tracks I recognize!\\n\");\n\treturn CDS_NO_INFO;\n}\n\nstatic int cdrom_ioctl_changer_nslots(struct cdrom_device_info *cdi)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_CHANGER_NSLOTS\\n\");\n\treturn cdi->capacity;\n}\n\nstatic int cdrom_ioctl_get_subchnl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_subchnl q;\n\tu8 requested, back;\n\tint ret;\n\n\t/* cd_dbg(CD_DO_IOCTL,\"entering CDROMSUBCHNL\\n\");*/\n\n\tif (copy_from_user(&q, argp, sizeof(q)))\n\t\treturn -EFAULT;\n\n\trequested = q.cdsc_format;\n\tif (requested != CDROM_MSF && requested != CDROM_LBA)\n\t\treturn -EINVAL;\n\tq.cdsc_format = CDROM_MSF;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMSUBCHNL, &q);\n\tif (ret)\n\t\treturn ret;\n\n\tback = q.cdsc_format; /* local copy */\n\tsanitize_format(&q.cdsc_absaddr, &back, requested);\n\tsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\n\n\tif (copy_to_user(argp, &q, sizeof(q)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMSUBCHNL successful\\n\"); */\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_read_tochdr(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_tochdr header;\n\tint ret;\n\n\t/* cd_dbg(CD_DO_IOCTL, \"entering CDROMREADTOCHDR\\n\"); */\n\n\tif (copy_from_user(&header, argp, sizeof(header)))\n\t\treturn -EFAULT;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &header, sizeof(header)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMREADTOCHDR successful\\n\"); */\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_read_tocentry(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_tocentry entry;\n\tu8 requested_format;\n\tint ret;\n\n\t/* cd_dbg(CD_DO_IOCTL, \"entering CDROMREADTOCENTRY\\n\"); */\n\n\tif (copy_from_user(&entry, argp, sizeof(entry)))\n\t\treturn -EFAULT;\n\n\trequested_format = entry.cdte_format;\n\tif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\n\t\treturn -EINVAL;\n\t/* make interface to low-level uniform */\n\tentry.cdte_format = CDROM_MSF;\n\tret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry);\n\tif (ret)\n\t\treturn ret;\n\tsanitize_format(&entry.cdte_addr, &entry.cdte_format, requested_format);\n\n\tif (copy_to_user(argp, &entry, sizeof(entry)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMREADTOCENTRY successful\\n\"); */\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_play_msf(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_msf msf;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYMSF\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&msf, argp, sizeof(msf)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMPLAYMSF, &msf);\n}\n\nstatic int cdrom_ioctl_play_trkind(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_ti ti;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYTRKIND\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&ti, argp, sizeof(ti)))\n\t\treturn -EFAULT;\n\n\tret = check_for_audio_disc(cdi, cdi->ops);\n\tif (ret)\n\t\treturn ret;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMPLAYTRKIND, &ti);\n}\nstatic int cdrom_ioctl_volctrl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLCTRL\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&volume, argp, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMVOLCTRL, &volume);\n}\n\nstatic int cdrom_ioctl_volread(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLREAD\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\n\tret = cdi->ops->audio_ioctl(cdi, CDROMVOLREAD, &volume);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &volume, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int cdrom_ioctl_audioctl(struct cdrom_device_info *cdi,\n\t\tunsigned int cmd)\n{\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"doing audio ioctl (start/stop/pause/resume)\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tret = check_for_audio_disc(cdi, cdi->ops);\n\tif (ret)\n\t\treturn ret;\n\treturn cdi->ops->audio_ioctl(cdi, cmd, NULL);\n}\n\n/*\n * Required when we need to use READ_10 to issue other than 2048 block\n * reads\n */\nstatic int cdrom_switch_blocksize(struct cdrom_device_info *cdi, int size)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tstruct modesel_head mh;\n\n\tmemset(&mh, 0, sizeof(mh));\n\tmh.block_desc_length = 0x08;\n\tmh.block_length_med = (size >> 8) & 0xff;\n\tmh.block_length_lo = size & 0xff;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\tcgc.cmd[0] = 0x15;\n\tcgc.cmd[1] = 1 << 4;\n\tcgc.cmd[4] = 12;\n\tcgc.buflen = sizeof(mh);\n\tcgc.buffer = (char *) &mh;\n\tcgc.data_direction = CGC_DATA_WRITE;\n\tmh.block_desc_length = 0x08;\n\tmh.block_length_med = (size >> 8) & 0xff;\n\tmh.block_length_lo = size & 0xff;\n\n\treturn cdo->generic_packet(cdi, &cgc);\n}\n\nstatic int cdrom_get_track_info(struct cdrom_device_info *cdi,\n\t\t\t\t__u16 track, __u8 type, track_information *ti)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct packet_command cgc;\n\tint ret, buflen;\n\n\tinit_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);\n\tcgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;\n\tcgc.cmd[1] = type & 3;\n\tcgc.cmd[4] = (track & 0xff00) >> 8;\n\tcgc.cmd[5] = track & 0xff;\n\tcgc.cmd[8] = 8;\n\tcgc.quiet = 1;\n\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\tbuflen = be16_to_cpu(ti->track_information_length) +\n\t\tsizeof(ti->track_information_length);\n\n\tif (buflen > sizeof(track_information))\n\t\tbuflen = sizeof(track_information);\n\n\tcgc.cmd[8] = cgc.buflen = buflen;\n\tret = cdo->generic_packet(cdi, &cgc);\n\tif (ret)\n\t\treturn ret;\n\n\t/* return actual fill size */\n\treturn buflen;\n}\n\n/* return the last written block on the CD-R media. this is for the udf\n   file system. */\nint cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written)\n{\n\tstruct cdrom_tocentry toc;\n\tdisc_information di;\n\ttrack_information ti;\n\t__u32 last_track;\n\tint ret = -1, ti_size;\n\n\tif (!CDROM_CAN(CDC_GENERIC_PACKET))\n\t\tgoto use_toc;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < (int)(offsetof(typeof(di), last_track_lsb)\n\t\t\t+ sizeof(di.last_track_lsb)))\n\t\tgoto use_toc;\n\n\t/* if unit didn't return msb, it's zeroed by cdrom_get_disc_info */\n\tlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\n\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\tif (ti_size < (int)offsetof(typeof(ti), track_start))\n\t\tgoto use_toc;\n\n\t/* if this track is blank, try the previous. */\n\tif (ti.blank) {\n\t\tif (last_track == 1)\n\t\t\tgoto use_toc;\n\t\tlast_track--;\n\t\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\t}\n\n\tif (ti_size < (int)(offsetof(typeof(ti), track_size)\n\t\t\t\t+ sizeof(ti.track_size)))\n\t\tgoto use_toc;\n\n\t/* if last recorded field is valid, return it. */\n\tif (ti.lra_v && ti_size >= (int)(offsetof(typeof(ti), last_rec_address)\n\t\t\t\t+ sizeof(ti.last_rec_address))) {\n\t\t*last_written = be32_to_cpu(ti.last_rec_address);\n\t} else {\n\t\t/* make it up instead */\n\t\t*last_written = be32_to_cpu(ti.track_start) +\n\t\t\t\tbe32_to_cpu(ti.track_size);\n\t\tif (ti.free_blocks)\n\t\t\t*last_written -= (be32_to_cpu(ti.free_blocks) + 7);\n\t}\n\treturn 0;\n\n\t/* this is where we end up if the drive either can't do a\n\t   GPCMD_READ_DISC_INFO or GPCMD_READ_TRACK_RZONE_INFO or if\n\t   it doesn't give enough information or fails. then we return\n\t   the toc contents. */\nuse_toc:\n\ttoc.cdte_format = CDROM_MSF;\n\ttoc.cdte_track = CDROM_LEADOUT;\n\tif ((ret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &toc)))\n\t\treturn ret;\n\tsanitize_format(&toc.cdte_addr, &toc.cdte_format, CDROM_LBA);\n\t*last_written = toc.cdte_addr.lba;\n\treturn 0;\n}\n\n/* return the next writable block. also for udf file system. */\nstatic int cdrom_get_next_writable(struct cdrom_device_info *cdi,\n\t\t\t\t   long *next_writable)\n{\n\tdisc_information di;\n\ttrack_information ti;\n\t__u16 last_track;\n\tint ret, ti_size;\n\n\tif (!CDROM_CAN(CDC_GENERIC_PACKET))\n\t\tgoto use_last_written;\n\n\tret = cdrom_get_disc_info(cdi, &di);\n\tif (ret < 0 || ret < offsetof(typeof(di), last_track_lsb)\n\t\t\t\t+ sizeof(di.last_track_lsb))\n\t\tgoto use_last_written;\n\n\t/* if unit didn't return msb, it's zeroed by cdrom_get_disc_info */\n\tlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\n\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\tif (ti_size < 0 || ti_size < offsetof(typeof(ti), track_start))\n\t\tgoto use_last_written;\n\n\t/* if this track is blank, try the previous. */\n\tif (ti.blank) {\n\t\tif (last_track == 1)\n\t\t\tgoto use_last_written;\n\t\tlast_track--;\n\t\tti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\n\t\tif (ti_size < 0)\n\t\t\tgoto use_last_written;\n\t}\n\n\t/* if next recordable address field is valid, use it. */\n\tif (ti.nwa_v && ti_size >= offsetof(typeof(ti), next_writable)\n\t\t\t\t+ sizeof(ti.next_writable)) {\n\t\t*next_writable = be32_to_cpu(ti.next_writable);\n\t\treturn 0;\n\t}\n\nuse_last_written:\n\tret = cdrom_get_last_written(cdi, next_writable);\n\tif (ret) {\n\t\t*next_writable = 0;\n\t\treturn ret;\n\t} else {\n\t\t*next_writable += 7;\n\t\treturn 0;\n\t}\n}\n\nstatic noinline int mmc_ioctl_cdrom_read_data(struct cdrom_device_info *cdi,\n\t\t\t\t\t      void __user *arg,\n\t\t\t\t\t      struct packet_command *cgc,\n\t\t\t\t\t      int cmd)\n{\n\tstruct scsi_sense_hdr sshdr;\n\tstruct cdrom_msf msf;\n\tint blocksize = 0, format = 0, lba;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase CDROMREADRAW:\n\t\tblocksize = CD_FRAMESIZE_RAW;\n\t\tbreak;\n\tcase CDROMREADMODE1:\n\t\tblocksize = CD_FRAMESIZE;\n\t\tformat = 2;\n\t\tbreak;\n\tcase CDROMREADMODE2:\n\t\tblocksize = CD_FRAMESIZE_RAW0;\n\t\tbreak;\n\t}\n\tif (copy_from_user(&msf, (struct cdrom_msf __user *)arg, sizeof(msf)))\n\t\treturn -EFAULT;\n\tlba = msf_to_lba(msf.cdmsf_min0, msf.cdmsf_sec0, msf.cdmsf_frame0);\n\t/* FIXME: we need upper bound checking, too!! */\n\tif (lba < 0)\n\t\treturn -EINVAL;\n\n\tcgc->buffer = kzalloc(blocksize, GFP_KERNEL);\n\tif (cgc->buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(&sshdr, 0, sizeof(sshdr));\n\tcgc->sshdr = &sshdr;\n\tcgc->data_direction = CGC_DATA_READ;\n\tret = cdrom_read_block(cdi, cgc, lba, 1, format, blocksize);\n\tif (ret && sshdr.sense_key == 0x05 &&\n\t    sshdr.asc == 0x20 &&\n\t    sshdr.ascq == 0x00) {\n\t\t/*\n\t\t * SCSI-II devices are not required to support\n\t\t * READ_CD, so let's try switching block size\n\t\t */\n\t\t/* FIXME: switch back again... */\n\t\tret = cdrom_switch_blocksize(cdi, blocksize);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tcgc->sshdr = NULL;\n\t\tret = cdrom_read_cd(cdi, cgc, lba, blocksize, 1);\n\t\tret |= cdrom_switch_blocksize(cdi, blocksize);\n\t}\n\tif (!ret && copy_to_user(arg, cgc->buffer, blocksize))\n\t\tret = -EFAULT;\nout:\n\tkfree(cgc->buffer);\n\treturn ret;\n}\n\nstatic noinline int mmc_ioctl_cdrom_read_audio(struct cdrom_device_info *cdi,\n\t\t\t\t\t       void __user *arg)\n{\n\tstruct cdrom_read_audio ra;\n\tint lba;\n\n\tif (copy_from_user(&ra, (struct cdrom_read_audio __user *)arg,\n\t\t\t   sizeof(ra)))\n\t\treturn -EFAULT;\n\n\tif (ra.addr_format == CDROM_MSF)\n\t\tlba = msf_to_lba(ra.addr.msf.minute,\n\t\t\t\t ra.addr.msf.second,\n\t\t\t\t ra.addr.msf.frame);\n\telse if (ra.addr_format == CDROM_LBA)\n\t\tlba = ra.addr.lba;\n\telse\n\t\treturn -EINVAL;\n\n\t/* FIXME: we need upper bound checking, too!! */\n\tif (lba < 0 || ra.nframes <= 0 || ra.nframes > CD_FRAMES)\n\t\treturn -EINVAL;\n\n\treturn cdrom_read_cdda(cdi, ra.buf, lba, ra.nframes);\n}\n\nstatic noinline int mmc_ioctl_cdrom_subchannel(struct cdrom_device_info *cdi,\n\t\t\t\t\t       void __user *arg)\n{\n\tint ret;\n\tstruct cdrom_subchnl q;\n\tu_char requested, back;\n\tif (copy_from_user(&q, (struct cdrom_subchnl __user *)arg, sizeof(q)))\n\t\treturn -EFAULT;\n\trequested = q.cdsc_format;\n\tif (!((requested == CDROM_MSF) ||\n\t      (requested == CDROM_LBA)))\n\t\treturn -EINVAL;\n\n\tret = cdrom_read_subchannel(cdi, &q, 0);\n\tif (ret)\n\t\treturn ret;\n\tback = q.cdsc_format; /* local copy */\n\tsanitize_format(&q.cdsc_absaddr, &back, requested);\n\tsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\n\tif (copy_to_user((struct cdrom_subchnl __user *)arg, &q, sizeof(q)))\n\t\treturn -EFAULT;\n\t/* cd_dbg(CD_DO_IOCTL, \"CDROMSUBCHNL successful\\n\"); */\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_play_msf(struct cdrom_device_info *cdi,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct cdrom_msf msf;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYMSF\\n\");\n\tif (copy_from_user(&msf, (struct cdrom_msf __user *)arg, sizeof(msf)))\n\t\treturn -EFAULT;\n\tcgc->cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc->cmd[3] = msf.cdmsf_min0;\n\tcgc->cmd[4] = msf.cdmsf_sec0;\n\tcgc->cmd[5] = msf.cdmsf_frame0;\n\tcgc->cmd[6] = msf.cdmsf_min1;\n\tcgc->cmd[7] = msf.cdmsf_sec1;\n\tcgc->cmd[8] = msf.cdmsf_frame1;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_play_blk(struct cdrom_device_info *cdi,\n\t\t\t\t\t     void __user *arg,\n\t\t\t\t\t     struct packet_command *cgc)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tstruct cdrom_blk blk;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPLAYBLK\\n\");\n\tif (copy_from_user(&blk, (struct cdrom_blk __user *)arg, sizeof(blk)))\n\t\treturn -EFAULT;\n\tcgc->cmd[0] = GPCMD_PLAY_AUDIO_10;\n\tcgc->cmd[2] = (blk.from >> 24) & 0xff;\n\tcgc->cmd[3] = (blk.from >> 16) & 0xff;\n\tcgc->cmd[4] = (blk.from >>  8) & 0xff;\n\tcgc->cmd[5] = blk.from & 0xff;\n\tcgc->cmd[7] = (blk.len >> 8) & 0xff;\n\tcgc->cmd[8] = blk.len & 0xff;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_volume(struct cdrom_device_info *cdi,\n\t\t\t\t\t   void __user *arg,\n\t\t\t\t\t   struct packet_command *cgc,\n\t\t\t\t\t   unsigned int cmd)\n{\n\tstruct cdrom_volctrl volctrl;\n\tunsigned char buffer[32];\n\tchar mask[sizeof(buffer)];\n\tunsigned short offset;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLUME\\n\");\n\n\tif (copy_from_user(&volctrl, (struct cdrom_volctrl __user *)arg,\n\t\t\t   sizeof(volctrl)))\n\t\treturn -EFAULT;\n\n\tcgc->buffer = buffer;\n\tcgc->buflen = 24;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 0);\n\tif (ret)\n\t\treturn ret;\n\t\t\n\t/* originally the code depended on buffer[1] to determine\n\t   how much data is available for transfer. buffer[1] is\n\t   unfortunately ambigious and the only reliable way seem\n\t   to be to simply skip over the block descriptor... */\n\toffset = 8 + be16_to_cpu(*(__be16 *)(buffer + 6));\n\n\tif (offset + 16 > sizeof(buffer))\n\t\treturn -E2BIG;\n\n\tif (offset + 16 > cgc->buflen) {\n\t\tcgc->buflen = offset + 16;\n\t\tret = cdrom_mode_sense(cdi, cgc,\n\t\t\t\t       GPMODE_AUDIO_CTL_PAGE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* sanity check */\n\tif ((buffer[offset] & 0x3f) != GPMODE_AUDIO_CTL_PAGE ||\n\t    buffer[offset + 1] < 14)\n\t\treturn -EINVAL;\n\n\t/* now we have the current volume settings. if it was only\n\t   a CDROMVOLREAD, return these values */\n\tif (cmd == CDROMVOLREAD) {\n\t\tvolctrl.channel0 = buffer[offset+9];\n\t\tvolctrl.channel1 = buffer[offset+11];\n\t\tvolctrl.channel2 = buffer[offset+13];\n\t\tvolctrl.channel3 = buffer[offset+15];\n\t\tif (copy_to_user((struct cdrom_volctrl __user *)arg, &volctrl,\n\t\t\t\t sizeof(volctrl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\t\t\n\t/* get the volume mask */\n\tcgc->buffer = mask;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer[offset + 9]  = volctrl.channel0 & mask[offset + 9];\n\tbuffer[offset + 11] = volctrl.channel1 & mask[offset + 11];\n\tbuffer[offset + 13] = volctrl.channel2 & mask[offset + 13];\n\tbuffer[offset + 15] = volctrl.channel3 & mask[offset + 15];\n\n\t/* set volume */\n\tcgc->buffer = buffer + offset - 8;\n\tmemset(cgc->buffer, 0, 8);\n\treturn cdrom_mode_select(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_start_stop(struct cdrom_device_info *cdi,\n\t\t\t\t\t       struct packet_command *cgc,\n\t\t\t\t\t       int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMSTART/CDROMSTOP\\n\");\n\tcgc->cmd[0] = GPCMD_START_STOP_UNIT;\n\tcgc->cmd[1] = 1;\n\tcgc->cmd[4] = (cmd == CDROMSTART) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_cdrom_pause_resume(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t struct packet_command *cgc,\n\t\t\t\t\t\t int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPAUSE/CDROMRESUME\\n\");\n\tcgc->cmd[0] = GPCMD_PAUSE_RESUME;\n\tcgc->cmd[8] = (cmd == CDROMRESUME) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}\n\nstatic noinline int mmc_ioctl_dvd_read_struct(struct cdrom_device_info *cdi,\n\t\t\t\t\t      void __user *arg,\n\t\t\t\t\t      struct packet_command *cgc)\n{\n\tint ret;\n\tdvd_struct *s;\n\tint size = sizeof(dvd_struct);\n\n\tif (!CDROM_CAN(CDC_DVD))\n\t\treturn -ENOSYS;\n\n\ts = memdup_user(arg, size);\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\tcd_dbg(CD_DO_IOCTL, \"entering DVD_READ_STRUCT\\n\");\n\n\tret = dvd_read_struct(cdi, s, cgc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(arg, s, size))\n\t\tret = -EFAULT;\nout:\n\tkfree(s);\n\treturn ret;\n}\n\nstatic noinline int mmc_ioctl_dvd_auth(struct cdrom_device_info *cdi,\n\t\t\t\t       void __user *arg)\n{\n\tint ret;\n\tdvd_authinfo ai;\n\tif (!CDROM_CAN(CDC_DVD))\n\t\treturn -ENOSYS;\n\tcd_dbg(CD_DO_IOCTL, \"entering DVD_AUTH\\n\");\n\tif (copy_from_user(&ai, (dvd_authinfo __user *)arg, sizeof(ai)))\n\t\treturn -EFAULT;\n\tret = dvd_do_auth(cdi, &ai);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((dvd_authinfo __user *)arg, &ai, sizeof(ai)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_next_writable(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t  void __user *arg)\n{\n\tint ret;\n\tlong next = 0;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_NEXT_WRITABLE\\n\");\n\tret = cdrom_get_next_writable(cdi, &next);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((long __user *)arg, &next, sizeof(next)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic noinline int mmc_ioctl_cdrom_last_written(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t void __user *arg)\n{\n\tint ret;\n\tlong last = 0;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_LAST_WRITTEN\\n\");\n\tret = cdrom_get_last_written(cdi, &last);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user((long __user *)arg, &last, sizeof(last)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int mmc_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tstruct packet_command cgc;\n\tvoid __user *userptr = (void __user *)arg;\n\n\tmemset(&cgc, 0, sizeof(cgc));\n\n\t/* build a unified command and queue it through\n\t   cdo->generic_packet() */\n\tswitch (cmd) {\n\tcase CDROMREADRAW:\n\tcase CDROMREADMODE1:\n\tcase CDROMREADMODE2:\n\t\treturn mmc_ioctl_cdrom_read_data(cdi, userptr, &cgc, cmd);\n\tcase CDROMREADAUDIO:\n\t\treturn mmc_ioctl_cdrom_read_audio(cdi, userptr);\n\tcase CDROMSUBCHNL:\n\t\treturn mmc_ioctl_cdrom_subchannel(cdi, userptr);\n\tcase CDROMPLAYMSF:\n\t\treturn mmc_ioctl_cdrom_play_msf(cdi, userptr, &cgc);\n\tcase CDROMPLAYBLK:\n\t\treturn mmc_ioctl_cdrom_play_blk(cdi, userptr, &cgc);\n\tcase CDROMVOLCTRL:\n\tcase CDROMVOLREAD:\n\t\treturn mmc_ioctl_cdrom_volume(cdi, userptr, &cgc, cmd);\n\tcase CDROMSTART:\n\tcase CDROMSTOP:\n\t\treturn mmc_ioctl_cdrom_start_stop(cdi, &cgc, cmd);\n\tcase CDROMPAUSE:\n\tcase CDROMRESUME:\n\t\treturn mmc_ioctl_cdrom_pause_resume(cdi, &cgc, cmd);\n\tcase DVD_READ_STRUCT:\n\t\treturn mmc_ioctl_dvd_read_struct(cdi, userptr, &cgc);\n\tcase DVD_AUTH:\n\t\treturn mmc_ioctl_dvd_auth(cdi, userptr);\n\tcase CDROM_NEXT_WRITABLE:\n\t\treturn mmc_ioctl_cdrom_next_writable(cdi, userptr);\n\tcase CDROM_LAST_WRITTEN:\n\t\treturn mmc_ioctl_cdrom_last_written(cdi, userptr);\n\t}\n\n\treturn -ENOTTY;\n}\n\n/*\n * Just about every imaginable ioctl is supported in the Uniform layer\n * these days.\n * ATAPI / SCSI specific code now mainly resides in mmc_ioctl().\n */\nint cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,\n\t\tfmode_t mode, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\t/*\n\t * Try the generic SCSI command ioctl's first.\n\t */\n\tret = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);\n\tif (ret != -ENOTTY)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase CDROMMULTISESSION:\n\t\treturn cdrom_ioctl_multisession(cdi, argp);\n\tcase CDROMEJECT:\n\t\treturn cdrom_ioctl_eject(cdi);\n\tcase CDROMCLOSETRAY:\n\t\treturn cdrom_ioctl_closetray(cdi);\n\tcase CDROMEJECT_SW:\n\t\treturn cdrom_ioctl_eject_sw(cdi, arg);\n\tcase CDROM_MEDIA_CHANGED:\n\t\treturn cdrom_ioctl_media_changed(cdi, arg);\n\tcase CDROM_SET_OPTIONS:\n\t\treturn cdrom_ioctl_set_options(cdi, arg);\n\tcase CDROM_CLEAR_OPTIONS:\n\t\treturn cdrom_ioctl_clear_options(cdi, arg);\n\tcase CDROM_SELECT_SPEED:\n\t\treturn cdrom_ioctl_select_speed(cdi, arg);\n\tcase CDROM_SELECT_DISC:\n\t\treturn cdrom_ioctl_select_disc(cdi, arg);\n\tcase CDROMRESET:\n\t\treturn cdrom_ioctl_reset(cdi, bdev);\n\tcase CDROM_LOCKDOOR:\n\t\treturn cdrom_ioctl_lock_door(cdi, arg);\n\tcase CDROM_DEBUG:\n\t\treturn cdrom_ioctl_debug(cdi, arg);\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn cdrom_ioctl_get_capability(cdi);\n\tcase CDROM_GET_MCN:\n\t\treturn cdrom_ioctl_get_mcn(cdi, argp);\n\tcase CDROM_DRIVE_STATUS:\n\t\treturn cdrom_ioctl_drive_status(cdi, arg);\n\tcase CDROM_DISC_STATUS:\n\t\treturn cdrom_ioctl_disc_status(cdi);\n\tcase CDROM_CHANGER_NSLOTS:\n\t\treturn cdrom_ioctl_changer_nslots(cdi);\n\t}\n\n\t/*\n\t * Use the ioctls that are implemented through the generic_packet()\n\t * interface. this may look at bit funny, but if -ENOTTY is\n\t * returned that particular ioctl is not implemented and we\n\t * let it go through the device specific ones.\n\t */\n\tif (CDROM_CAN(CDC_GENERIC_PACKET)) {\n\t\tret = mmc_ioctl(cdi, cmd, arg);\n\t\tif (ret != -ENOTTY)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Note: most of the cd_dbg() calls are commented out here,\n\t * because they fill up the sys log when CD players poll\n\t * the drive.\n\t */\n\tswitch (cmd) {\n\tcase CDROMSUBCHNL:\n\t\treturn cdrom_ioctl_get_subchnl(cdi, argp);\n\tcase CDROMREADTOCHDR:\n\t\treturn cdrom_ioctl_read_tochdr(cdi, argp);\n\tcase CDROMREADTOCENTRY:\n\t\treturn cdrom_ioctl_read_tocentry(cdi, argp);\n\tcase CDROMPLAYMSF:\n\t\treturn cdrom_ioctl_play_msf(cdi, argp);\n\tcase CDROMPLAYTRKIND:\n\t\treturn cdrom_ioctl_play_trkind(cdi, argp);\n\tcase CDROMVOLCTRL:\n\t\treturn cdrom_ioctl_volctrl(cdi, argp);\n\tcase CDROMVOLREAD:\n\t\treturn cdrom_ioctl_volread(cdi, argp);\n\tcase CDROMSTART:\n\tcase CDROMSTOP:\n\tcase CDROMPAUSE:\n\tcase CDROMRESUME:\n\t\treturn cdrom_ioctl_audioctl(cdi, cmd);\n\t}\n\n\treturn -ENOSYS;\n}\n\nEXPORT_SYMBOL(cdrom_get_last_written);\nEXPORT_SYMBOL(register_cdrom);\nEXPORT_SYMBOL(unregister_cdrom);\nEXPORT_SYMBOL(cdrom_open);\nEXPORT_SYMBOL(cdrom_release);\nEXPORT_SYMBOL(cdrom_ioctl);\nEXPORT_SYMBOL(cdrom_media_changed);\nEXPORT_SYMBOL(cdrom_number_of_slots);\nEXPORT_SYMBOL(cdrom_mode_select);\nEXPORT_SYMBOL(cdrom_mode_sense);\nEXPORT_SYMBOL(init_cdrom_command);\nEXPORT_SYMBOL(cdrom_get_media_event);\n\n#ifdef CONFIG_SYSCTL\n\n#define CDROM_STR_SIZE 1000\n\nstatic struct cdrom_sysctl_settings {\n\tchar\tinfo[CDROM_STR_SIZE];\t/* general info */\n\tint\tautoclose;\t\t/* close tray upon mount, etc */\n\tint\tautoeject;\t\t/* eject on umount */\n\tint\tdebug;\t\t\t/* turn on debugging messages */\n\tint\tlock;\t\t\t/* lock the door on device open */\n\tint\tcheck;\t\t\t/* check media type */\n} cdrom_sysctl_settings;\n\nenum cdrom_print_option {\n\tCTL_NAME,\n\tCTL_SPEED,\n\tCTL_SLOTS,\n\tCTL_CAPABILITY\n};\n\nstatic int cdrom_print_info(const char *header, int val, char *info,\n\t\t\t\tint *pos, enum cdrom_print_option option)\n{\n\tconst int max_size = sizeof(cdrom_sysctl_settings.info);\n\tstruct cdrom_device_info *cdi;\n\tint ret;\n\n\tret = scnprintf(info + *pos, max_size - *pos, header);\n\tif (!ret)\n\t\treturn 1;\n\n\t*pos += ret;\n\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tswitch (option) {\n\t\tcase CTL_NAME:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%s\", cdi->name);\n\t\t\tbreak;\n\t\tcase CTL_SPEED:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", cdi->speed);\n\t\t\tbreak;\n\t\tcase CTL_SLOTS:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", cdi->capacity);\n\t\t\tbreak;\n\t\tcase CTL_CAPABILITY:\n\t\t\tret = scnprintf(info + *pos, max_size - *pos,\n\t\t\t\t\t\"\\t%d\", CDROM_CAN(val) != 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"invalid option%d\\n\", option);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!ret)\n\t\t\treturn 1;\n\t\t*pos += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdrom_sysctl_info(struct ctl_table *ctl, int write,\n                           void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint pos;\n\tchar *info = cdrom_sysctl_settings.info;\n\tconst int max_size = sizeof(cdrom_sysctl_settings.info);\n\t\n\tif (!*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&cdrom_mutex);\n\n\tpos = sprintf(info, \"CD-ROM information, \" VERSION \"\\n\");\n\t\n\tif (cdrom_print_info(\"\\ndrive name:\\t\", 0, info, &pos, CTL_NAME))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\ndrive speed:\\t\", 0, info, &pos, CTL_SPEED))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\ndrive # of slots:\", 0, info, &pos, CTL_SLOTS))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan close tray:\\t\",\n\t\t\t\tCDC_CLOSE_TRAY, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan open tray:\\t\",\n\t\t\t\tCDC_OPEN_TRAY, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan lock tray:\\t\",\n\t\t\t\tCDC_LOCK, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan change speed:\",\n\t\t\t\tCDC_SELECT_SPEED, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan select disk:\",\n\t\t\t\tCDC_SELECT_DISC, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read multisession:\",\n\t\t\t\tCDC_MULTI_SESSION, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read MCN:\\t\",\n\t\t\t\tCDC_MCN, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nReports media changed:\",\n\t\t\t\tCDC_MEDIA_CHANGED, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan play audio:\\t\",\n\t\t\t\tCDC_PLAY_AUDIO, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write CD-R:\\t\",\n\t\t\t\tCDC_CD_R, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write CD-RW:\",\n\t\t\t\tCDC_CD_RW, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read DVD:\\t\",\n\t\t\t\tCDC_DVD, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write DVD-R:\",\n\t\t\t\tCDC_DVD_R, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write DVD-RAM:\",\n\t\t\t\tCDC_DVD_RAM, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan read MRW:\\t\",\n\t\t\t\tCDC_MRW, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write MRW:\\t\",\n\t\t\t\tCDC_MRW_W, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (cdrom_print_info(\"\\nCan write RAM:\\t\",\n\t\t\t\tCDC_RAM, info, &pos, CTL_CAPABILITY))\n\t\tgoto done;\n\tif (!scnprintf(info + pos, max_size - pos, \"\\n\\n\"))\n\t\tgoto done;\ndoit:\n\tmutex_unlock(&cdrom_mutex);\n\treturn proc_dostring(ctl, write, buffer, lenp, ppos);\ndone:\n\tpr_info(\"info buffer too small\\n\");\n\tgoto doit;\n}\n\n/* Unfortunately, per device settings are not implemented through\n   procfs/sysctl yet. When they are, this will naturally disappear. For now\n   just update all drives. Later this will become the template on which\n   new registered drives will be based. */\nstatic void cdrom_update_settings(void)\n{\n\tstruct cdrom_device_info *cdi;\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tif (autoclose && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_CLOSE;\n\t\telse if (!autoclose)\n\t\t\tcdi->options &= ~CDO_AUTO_CLOSE;\n\t\tif (autoeject && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_EJECT;\n\t\telse if (!autoeject)\n\t\t\tcdi->options &= ~CDO_AUTO_EJECT;\n\t\tif (lockdoor && CDROM_CAN(CDC_LOCK))\n\t\t\tcdi->options |= CDO_LOCK;\n\t\telse if (!lockdoor)\n\t\t\tcdi->options &= ~CDO_LOCK;\n\t\tif (check_media_type)\n\t\t\tcdi->options |= CDO_CHECK_TYPE;\n\t\telse\n\t\t\tcdi->options &= ~CDO_CHECK_TYPE;\n\t}\n\tmutex_unlock(&cdrom_mutex);\n}\n\nstatic int cdrom_sysctl_handler(struct ctl_table *ctl, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\t\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\n\t\t/* we only care for 1 or 0. */\n\t\tautoclose        = !!cdrom_sysctl_settings.autoclose;\n\t\tautoeject        = !!cdrom_sysctl_settings.autoeject;\n\t\tdebug\t         = !!cdrom_sysctl_settings.debug;\n\t\tlockdoor         = !!cdrom_sysctl_settings.lock;\n\t\tcheck_media_type = !!cdrom_sysctl_settings.check;\n\n\t\t/* update the option flags according to the changes. we\n\t\t   don't have per device options through sysctl yet,\n\t\t   but we will have and then this will disappear. */\n\t\tcdrom_update_settings();\n\t}\n\n        return ret;\n}\n\n/* Place files in /proc/sys/dev/cdrom */\nstatic struct ctl_table cdrom_table[] = {\n\t{\n\t\t.procname\t= \"info\",\n\t\t.data\t\t= &cdrom_sysctl_settings.info, \n\t\t.maxlen\t\t= CDROM_STR_SIZE,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= cdrom_sysctl_info,\n\t},\n\t{\n\t\t.procname\t= \"autoclose\",\n\t\t.data\t\t= &cdrom_sysctl_settings.autoclose,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"autoeject\",\n\t\t.data\t\t= &cdrom_sysctl_settings.autoeject,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"debug\",\n\t\t.data\t\t= &cdrom_sysctl_settings.debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"lock\",\n\t\t.data\t\t= &cdrom_sysctl_settings.lock,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"check_media\",\n\t\t.data\t\t= &cdrom_sysctl_settings.check,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= cdrom_sysctl_handler\n\t},\n\t{ }\n};\n\nstatic struct ctl_table cdrom_cdrom_table[] = {\n\t{\n\t\t.procname\t= \"cdrom\",\n\t\t.maxlen\t\t= 0,\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= cdrom_table,\n\t},\n\t{ }\n};\n\n/* Make sure that /proc/sys/dev is there */\nstatic struct ctl_table cdrom_root_table[] = {\n\t{\n\t\t.procname\t= \"dev\",\n\t\t.maxlen\t\t= 0,\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= cdrom_cdrom_table,\n\t},\n\t{ }\n};\nstatic struct ctl_table_header *cdrom_sysctl_header;\n\nstatic void cdrom_sysctl_register(void)\n{\n\tstatic int initialized;\n\n\tif (initialized == 1)\n\t\treturn;\n\n\tcdrom_sysctl_header = register_sysctl_table(cdrom_root_table);\n\n\t/* set the defaults */\n\tcdrom_sysctl_settings.autoclose = autoclose;\n\tcdrom_sysctl_settings.autoeject = autoeject;\n\tcdrom_sysctl_settings.debug = debug;\n\tcdrom_sysctl_settings.lock = lockdoor;\n\tcdrom_sysctl_settings.check = check_media_type;\n\n\tinitialized = 1;\n}\n\nstatic void cdrom_sysctl_unregister(void)\n{\n\tif (cdrom_sysctl_header)\n\t\tunregister_sysctl_table(cdrom_sysctl_header);\n}\n\n#else /* CONFIG_SYSCTL */\n\nstatic void cdrom_sysctl_register(void)\n{\n}\n\nstatic void cdrom_sysctl_unregister(void)\n{\n}\n\n#endif /* CONFIG_SYSCTL */\n\nstatic int __init cdrom_init(void)\n{\n\tcdrom_sysctl_register();\n\n\treturn 0;\n}\n\nstatic void __exit cdrom_exit(void)\n{\n\tpr_info(\"Uniform CD-ROM driver unloaded\\n\");\n\tcdrom_sysctl_unregister();\n}\n\nmodule_init(cdrom_init);\nmodule_exit(cdrom_exit);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/cdrom/cdrom.c"], "buggy_code_start_loc": [2549], "buggy_code_end_loc": [2550], "fixing_code_start_loc": [2549], "fixing_code_end_loc": [2550], "type": "CWE-200", "message": "An issue was discovered in the Linux kernel before 4.18.6. An information leak in cdrom_ioctl_drive_status in drivers/cdrom/cdrom.c could be used by local attackers to read kernel memory because a cast from unsigned long to int interferes with bounds checking. This is similar to CVE-2018-10940.", "other": {"cve": {"id": "CVE-2018-16658", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-07T14:29:03.523", "lastModified": "2019-08-06T17:15:28.507", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.18.6. An information leak in cdrom_ioctl_drive_status in drivers/cdrom/cdrom.c could be used by local attackers to read kernel memory because a cast from unsigned long to int interferes with bounds checking. This is similar to CVE-2018-10940."}, {"lang": "es", "value": "Se ha descubierto un problema en el kernel de Linux hasta antes de la versi\u00f3n 4.18.6. Una fuga de informaci\u00f3n en cdrom_ioctl_drive_status en drivers/cdrom/cdrom.c podr\u00eda ser empleada por atacantes locales para leer memoria del kernel debido a que una conversi\u00f3n de un long no firmado a int interfiere con la comprobaci\u00f3n de l\u00edmites. Esto es similar a CVE-2018-10940."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.18.6", "matchCriteriaId": "C4256A5D-D418-4CB8-AEA8-D3DD12E96CA6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/105334", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4154", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.18.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Technical Description"]}, {"url": "https://github.com/torvalds/linux/commit/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3797-1/", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3797-2/", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3820-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3820-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3820-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3822-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3822-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4308", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4"}}