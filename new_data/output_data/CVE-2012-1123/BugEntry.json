{"buggy_code": ["<?php\n# MantisConnect - A webservice interface to Mantis Bug Tracker\n# Copyright (C) 2004-2012  Victor Boctor - vboctor@users.sourceforge.net\n# This program is distributed under dual licensing.  These include\n# GPL and a commercial licenses.  Victor Boctor reserves the right to\n# change the license of future releases.\n# See docs/ folder for more details\n\n# set up error_handler() as the new default error handling function\nset_error_handler( 'mc_error_handler' );\n\n# override some MantisBT configurations\n$g_show_detailed_errors = OFF;\n$g_stop_on_errors = ON;\n$g_display_errors = array(\n\tE_WARNING => 'halt',\n\tE_NOTICE => 'halt',\n\tE_USER_ERROR => 'halt',\n\tE_USER_WARNING => 'halt',\n\tE_USER_NOTICE => 'halt',\n);\n\n/**\n * Get the MantisConnect webservice version.\n */\nfunction mc_version() {\n\treturn MANTIS_VERSION;\n}\n\n# Checks if MantisBT installation is marked as offline by the administrator.\n# true: offline, false: online\nfunction mci_is_mantis_offline() {\n\t$t_offline_file = dirname( dirname( __FILE__ ) ) . DIRECTORY_SEPARATOR . 'mantis_offline.php';\n\treturn file_exists( $t_offline_file );\n}\n\n# return user_id if successful, otherwise false.\nfunction mci_check_login( $p_username, $p_password ) {\n\tif( mci_is_mantis_offline() ) {\n\t\treturn false;\n\t}\n\n\t# if no user name supplied, then attempt to login as anonymous user.\n\tif( is_blank( $p_username ) ) {\n\t\t$t_anon_allowed = config_get( 'allow_anonymous_login' );\n\t\tif( OFF == $t_anon_allowed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$p_username = config_get( 'anonymous_account' );\n\n\t\t# do not use password validation.\n\t\t$p_password = null;\n\t}\n\n\tif( false === auth_attempt_script_login( $p_username, $p_password ) ) {\n\t\treturn false;\n\t}\n\n\treturn auth_get_current_user_id();\n}\n\nfunction mci_has_readonly_access( $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= config_get( 'mc_readonly_access_level_threshold' ) );\n}\n\nfunction mci_has_readwrite_access( $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= config_get( 'mc_readwrite_access_level_threshold' ) );\n}\n\nfunction mci_has_access( $p_access_level, $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= (int) $p_access_level );\n}\n\nfunction mci_has_administrator_access( $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= config_get( 'mc_admin_access_level_threshold' ) );\n}\n\nfunction mci_get_project_id( $p_project ) {\n\tif( (int) $p_project['id'] != 0 ) {\n\t\t$t_project_id = (int) $p_project['id'];\n\t} else {\n\t\t$t_project_id = project_get_id_by_name( $p_project['name'] );\n\t}\n\n\treturn $t_project_id;\n}\n\nfunction mci_get_project_status_id( $p_status ) {\n\treturn mci_get_enum_id_from_objectref( 'project_status', $p_status );\n}\n\nfunction mci_get_project_view_state_id( $p_view_state ) {\n\treturn mci_get_enum_id_from_objectref( 'project_view_state', $p_view_state );\n}\n\nfunction mci_get_user_id( $p_user ) {\n\t$t_user_id = 0;\n\n\tif ( isset( $p_user['id'] ) && (int) $p_user['id'] != 0 ) {\n\t\t$t_user_id = (int) $p_user['id'];\n\t} elseif ( isset( $p_user['name'] ) ) {\n\t\t$t_user_id = user_get_id_by_name( $p_user['name'] );\n\t} elseif ( isset( $p_user['email'] ) ) {\n\t\t$t_user_id = user_get_id_by_email( $p_user['email'] );\n\t}\n\n\treturn $t_user_id;\n}\n\nfunction mci_get_user_lang( $p_user_id ) {\n\t$t_lang = user_pref_get_pref( $p_user_id, 'language' );\n\tif( $t_lang == 'auto' ) {\n\t\t$t_lang = config_get( 'fallback_language' );\n\t}\n\treturn $t_lang;\n}\n\nfunction mci_get_status_id( $p_status ) {\n\treturn mci_get_enum_id_from_objectref( 'status', $p_status );\n}\n\nfunction mci_get_severity_id( $p_severity ) {\n\treturn mci_get_enum_id_from_objectref( 'severity', $p_severity );\n}\n\nfunction mci_get_priority_id( $p_priority ) {\n\n\treturn mci_get_enum_id_from_objectref( 'priority', $p_priority );\n}\n\nfunction mci_get_reproducibility_id( $p_reproducibility ) {\n\treturn mci_get_enum_id_from_objectref( 'reproducibility', $p_reproducibility );\n}\n\nfunction mci_get_resolution_id( $p_resolution ) {\n\treturn mci_get_enum_id_from_objectref( 'resolution', $p_resolution );\n}\n\nfunction mci_get_projection_id( $p_projection ) {\n\treturn mci_get_enum_id_from_objectref( 'projection', $p_projection );\n}\n\nfunction mci_get_eta_id( $p_eta ) {\n\treturn mci_get_enum_id_from_objectref( 'eta', $p_eta );\n}\n\nfunction mci_get_view_state_id( $p_view_state ) {\n\treturn mci_get_enum_id_from_objectref( 'view_state', $p_view_state );\n}\n\n# Get null on empty value.\n#\n# @param Object $p_value  The value\n# @return Object  The value if not empty; null otherwise.\n#\nfunction mci_null_if_empty( $p_value ) {\n\tif( !is_blank( $p_value ) ) {\n\t\treturn $p_value;\n\t}\n\n\treturn null;\n}\n\n/**\n * Gets the url for MantisBT.\n *\n * @return MantisBT URL terminated by a /.\n */\nfunction mci_get_mantis_path() {\n    \n\treturn config_get( 'path' );\n}\n\n# Given a enum string and num, return the appropriate localized string\nfunction mci_get_enum_element( $p_enum_name, $p_val, $p_lang ) {\n\t$t_enum_string = config_get( $p_enum_name . '_enum_string' );\n\t$t_localized_enum_string = lang_get( $p_enum_name . '_enum_string', $p_lang );\n\n\treturn MantisEnum::getLocalizedLabel( $t_enum_string, $t_localized_enum_string, $p_val );\n}\n\n# Gets the sub-projects that are accessible to the specified user / project.\nfunction mci_user_get_accessible_subprojects( $p_user_id, $p_parent_project_id, $p_lang = null ) {\n\tif( $p_lang === null ) {\n\t\t$t_lang = mci_get_user_lang( $p_user_id );\n\t} else {\n\t\t$t_lang = $p_lang;\n\t}\n\n\t$t_result = array();\n\tforeach( user_get_accessible_subprojects( $p_user_id, $p_parent_project_id ) as $t_subproject_id ) {\n\t\t$t_subproject_row = project_cache_row( $t_subproject_id );\n\t\t$t_subproject = array();\n\t\t$t_subproject['id'] = $t_subproject_id;\n\t\t$t_subproject['name'] = $t_subproject_row['name'];\n\t\t$t_subproject['status'] = mci_enum_get_array_by_id( $t_subproject_row['status'], 'project_status', $t_lang );\n\t\t$t_subproject['enabled'] = $t_subproject_row['enabled'];\n\t\t$t_subproject['view_state'] = mci_enum_get_array_by_id( $t_subproject_row['view_state'], 'project_view_state', $t_lang );\n\t\t$t_subproject['access_min'] = mci_enum_get_array_by_id( $t_subproject_row['access_min'], 'access_levels', $t_lang );\n\t\t$t_subproject['file_path'] = array_key_exists( 'file_path', $t_subproject_row ) ? $t_subproject_row['file_path'] : \"\";\n\t\t$t_subproject['description'] = array_key_exists( 'description', $t_subproject_row ) ? $t_subproject_row['description'] : \"\";\n\t\t$t_subproject['subprojects'] = mci_user_get_accessible_subprojects( $p_user_id, $t_subproject_id, $t_lang );\n\t\t$t_result[] = $t_subproject;\n\t}\n\n\treturn $t_result;\n}\n\nfunction translate_category_name_to_id( $p_category_name, $p_project_id ) {\n\tif ( !isset( $p_category_name ) ) {\n\t\treturn 0;\n\t}\n\n\t$t_cat_array = category_get_all_rows( $p_project_id );\n\tforeach( $t_cat_array as $t_category_row ) {\n\t\tif( $t_category_row['name'] == $p_category_name ) {\n\t\t\treturn $t_category_row['id'];\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * Basically this is a copy of core/filter_api.php#filter_db_get_available_queries().\n * The only difference is that the result of this function is not an array of filter\n * names but an array of filter structures.\n */\nfunction mci_filter_db_get_available_queries( $p_project_id = null, $p_user_id = null ) {\n\t$t_filters_table = db_get_table( 'filters' );\n\t$t_overall_query_arr = array();\n\n\tif( null === $p_project_id ) {\n\t\t$t_project_id = helper_get_current_project();\n\t} else {\n\t\t$t_project_id = db_prepare_int( $p_project_id );\n\t}\n\n\tif( null === $p_user_id ) {\n\t\t$t_user_id = auth_get_current_user_id();\n\t} else {\n\t\t$t_user_id = db_prepare_int( $p_user_id );\n\t}\n\n\t# If the user doesn't have access rights to stored queries, just return\n\tif( !access_has_project_level( config_get( 'stored_query_use_threshold' ) ) ) {\n\t\treturn $t_overall_query_arr;\n\t}\n\n\t# Get the list of available queries. By sorting such that public queries are\n\t# first, we can override any query that has the same name as a private query\n\t# with that private one\n\t$query = \"SELECT * FROM $t_filters_table\n\t\t\t\tWHERE (project_id='$t_project_id'\n\t\t\t\tOR project_id='0')\n\t\t\t\tAND name!=''\n\t\t\t\tORDER BY is_public DESC, name ASC\";\n\t$result = db_query( $query );\n\t$query_count = db_num_rows( $result );\n\n\tfor( $i = 0;$i < $query_count;$i++ ) {\n\t\t$row = db_fetch_array( $result );\n\t\tif(( $row['user_id'] == $t_user_id ) || db_prepare_bool( $row['is_public'] ) ) {\n\n\t\t    $t_filter_detail = explode( '#', $row['filter_string'], 2 );\n\t\t    if ( !isset($t_filter_detail[1]) ) {\n\t\t    \tcontinue;\n\t\t    }\n        \t$t_filter = unserialize( $t_filter_detail[1] );\n\t        $t_filter = filter_ensure_valid_filter( $t_filter );\n\t\t    $row['url'] = filter_get_url( $t_filter );\n\t\t\t$t_overall_query_arr[$row['name']] = $row;\n\t\t}\n\t}\n\n\treturn array_values( $t_overall_query_arr );\n}\n\n/**\n * Get a category definition.\n *\n * @param integer $p_category_id  The id of the category to retrieve.\n * @return Array an Array containing the id and the name of the category.\n */\nfunction mci_category_as_array_by_id( $p_category_id ) {\n\t$t_result = array();\n\t$t_result['id'] = $p_category_id;\n\t$t_result['name'] = category_get_name( $p_category_id );\n\treturn $t_result;\n}\n\n/**\n * Transforms a version array into an array suitable for marshalling into ProjectVersionData\n * \n * @param array $p_version\n */\nfunction mci_project_version_as_array( $p_version ) {\n    \n    return array(\n\t\t\t'id' => $p_version['id'],\n\t\t\t'name' => $p_version['version'],\n\t\t\t'project_id' => $p_version['project_id'],\n\t\t\t'date_order' => timestamp_to_iso8601( $p_version['date_order'], false ),\n\t\t\t'description' => mci_null_if_empty( $p_version['description'] ),\n\t\t\t'released' => $p_version['released'],\n\t\t    'obsolete' => $p_version['obsolete']\n\t\t);\n}\n\n/**\n * Returns time tracking information from a bug note.\n *\n * @param int $p_issue_id The id of the issue\n * @param Array $p_note A note as passed to the soap api methods\n *\n * @return String the string time entry to be added to the bugnote, in 'HH:mm' format\n */\nfunction mci_get_time_tracking_from_note( $p_issue_id, $p_note) {\n\n\tif ( !access_has_bug_level( config_get( 'time_tracking_view_threshold' ), $p_issue_id ) )\n\t\treturn '00:00';\n\n\tif ( !isset( $p_note['time_tracking'] ))\n\t\treturn '00:00';\n\n\treturn db_minutes_to_hhmm($p_note['time_tracking']);\n}\n\n/**\n * SECURITY NOTE: these globals are initialized here to prevent them\n * being spoofed if register_globals is turned on\n */\n$g_error_parameters = array();\n$g_error_handled = false;\n$g_error_proceed_url = null;\n\n# Default error handler\n#\n# This handler will not receive E_ERROR, E_PARSE, E_CORE_*, or E_COMPILE_*\n#  errors.\n#\n# E_USER_* are triggered by us and will contain an error constant in $p_error\n# The others, being system errors, will come with a string in $p_error\n#\nfunction mc_error_handler( $p_type, $p_error, $p_file, $p_line, $p_context ) {\n\tglobal $g_error_parameters, $g_error_handled, $g_error_proceed_url;\n\tglobal $g_lang_overrides;\n\tglobal $g_error_send_page_header;\n\tglobal $l_oServer;\n\n\t# check if errors were disabled with @ somewhere in this call chain\n\t# also suppress php 5 strict warnings\n\tif( 0 == error_reporting() || 2048 == $p_type ) {\n\t\treturn;\n\t}\n\n\t$t_lang_pushed = false;\n\n\t# flush any language overrides to return to user's natural default\n\tif( function_exists( 'db_is_connected' ) ) {\n\t\tif( db_is_connected() ) {\n\t\t\tlang_push( lang_get_default() );\n\t\t\t$t_lang_pushed = true;\n\t\t}\n\t}\n\n\t$t_short_file = basename( $p_file );\n\t$t_method_array = config_get( 'display_errors' );\n\tif( isset( $t_method_array[$p_type] ) ) {\n\t\t$t_method = $t_method_array[$p_type];\n\t} else {\n\t\t$t_method = 'none';\n\t}\n\n\t# build an appropriate error string\n\tswitch( $p_type ) {\n\t\tcase E_WARNING:\n\t\t\t$t_error_type = 'SYSTEM WARNING';\n\t\t\t$t_error_description = $p_error;\n\t\t\tbreak;\n\t\tcase E_NOTICE:\n\t\t\t$t_error_type = 'SYSTEM NOTICE';\n\t\t\t$t_error_description = $p_error;\n\t\t\tbreak;\n\t\tcase E_USER_ERROR:\n\t\t\t$t_error_type = \"APPLICATION ERROR #$p_error\";\n\t\t\t$t_error_description = error_string( $p_error );\n\t\t\tbreak;\n\t\tcase E_USER_WARNING:\n\t\t\t$t_error_type = \"APPLICATION WARNING #$p_error\";\n\t\t\t$t_error_description = error_string( $p_error );\n\t\t\tbreak;\n\t\tcase E_USER_NOTICE:\n\n\t\t\t# used for debugging\n\t\t\t$t_error_type = 'DEBUG';\n\t\t\t$t_error_description = $p_error;\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t#shouldn't happen, just display the error just in case\n\t\t\t$t_error_type = '';\n\t\t\t$t_error_description = $p_error;\n\t}\n\n\t$t_error_description = $t_error_description;\n\t$t_error_stack = error_get_stack_trace();\n\n\t$l_oServer->fault( 'Server', \"Error Type: $t_error_type,\\nError Description:\\n$t_error_description,\\nStack Trace:\\n$t_error_stack\" );\n\t$l_oServer->send_response();\n\texit();\n}\n\n# Get a stack trace if PHP provides the facility or xdebug is present\nfunction error_get_stack_trace() {\n\t$t_trace = '';\n\n\tif ( extension_loaded( 'xdebug' ) ) {\n\n\t\t#check for xdebug presence\n\t\t$t_stack = xdebug_get_function_stack();\n\n\t\t# reverse the array in a separate line of code so the\n\t\t#  array_reverse() call doesn't appear in the stack\n\t\t$t_stack = array_reverse( $t_stack );\n\t\tarray_shift( $t_stack );\n\n\t\t#remove the call to this function from the stack trace\n\t\tforeach( $t_stack as $t_frame ) {\n\t\t\t$t_trace .= ( isset( $t_frame['file'] ) ? basename( $t_frame['file'] ) : 'UnknownFile' ) . ' L' . ( isset( $t_frame['line'] ) ? $t_frame['line'] : '?' ) . ' ' . ( isset( $t_frame['function'] ) ? $t_frame['function'] : 'UnknownFunction' );\n\n\t\t\t$t_args = array();\n\t\t\tif ( isset( $t_frame['params'] ) && ( count( $t_frame['params'] ) > 0 ) ) {\n\t\t\t\t$t_trace .= ' Params: ';\n\t\t\t\tforeach( $t_frame['params'] as $t_value ) {\n\t\t\t\t\t$t_args[] = error_build_parameter_string( $t_value );\n\t\t\t\t}\n\n\t\t\t\t$t_trace .= '(' . implode( $t_args, ', ' ) . ')';\n\t\t\t} else {\n\t\t\t\t$t_trace .= '()';\n\t\t\t}\n\n\t\t\t$t_trace .= \"\\n\";\n\t\t}\n\t} else {\n\t\t$t_stack = debug_backtrace();\n\n\t\tarray_shift( $t_stack ); #remove the call to this function from the stack trace\n\t\tarray_shift( $t_stack ); #remove the call to the error handler from the stack trace\n\n\t\tforeach( $t_stack as $t_frame ) {\n\t\t\t$t_trace .= ( isset( $t_frame['file'] ) ? basename( $t_frame['file'] ) : 'UnknownFile' ) . ' L' . ( isset( $t_frame['line'] ) ? $t_frame['line'] : '?' ) . ' ' . ( isset( $t_frame['function'] ) ? $t_frame['function'] : 'UnknownFunction' );\n\n\t\t\t$t_args = array();\n\t\t\tif( isset( $t_frame['args'] ) ) {\n\t\t\t\tforeach( $t_frame['args'] as $t_value ) {\n\t\t\t\t\t$t_args[] = error_build_parameter_string( $t_value );\n\t\t\t\t}\n\n\t\t\t\t$t_trace .= '(' . implode( $t_args, ', ' ) . ')';\n\t\t\t} else {\n\t\t\t\t$t_trace .= '()';\n\t\t\t}\n\n\t\t\t$t_trace .= \"\\n\";\n\t\t}\n\t}\n\n\treturn $t_trace;\n}\n\n/**\n * Returns a soap_fault signalling corresponding to a failed login\n * situation\n *\n * @return soap_fault\n */\nfunction mci_soap_fault_login_failed() {\n\treturn new soap_fault('Client', '', 'Access denied.');\n}\n\n/**\n * Returns a soap_fault signalling that the user does not have\n * access rights for the specific action.\n *\n * @param int $p_user_id a valid user id\n * @param string $p_detail The optional details to append to the error message\n * @return soap_fault\n */\nfunction mci_soap_fault_access_denied( $p_user_id, $p_detail = '' ) {\n\t$t_user_name = user_get_name( $p_user_id );\n\t$t_reason = 'Access denied for user '. $t_user_name . '.';\n\tif ( !is_blank( $p_detail ))\n\t\t$t_reason .= ' Reason: ' . $p_detail . '.';\n\n\treturn new soap_fault( 'Client', '',  $t_reason );\n}\n"], "fixing_code": ["<?php\n# MantisConnect - A webservice interface to Mantis Bug Tracker\n# Copyright (C) 2004-2012  Victor Boctor - vboctor@users.sourceforge.net\n# This program is distributed under dual licensing.  These include\n# GPL and a commercial licenses.  Victor Boctor reserves the right to\n# change the license of future releases.\n# See docs/ folder for more details\n\n# set up error_handler() as the new default error handling function\nset_error_handler( 'mc_error_handler' );\n\n# override some MantisBT configurations\n$g_show_detailed_errors = OFF;\n$g_stop_on_errors = ON;\n$g_display_errors = array(\n\tE_WARNING => 'halt',\n\tE_NOTICE => 'halt',\n\tE_USER_ERROR => 'halt',\n\tE_USER_WARNING => 'halt',\n\tE_USER_NOTICE => 'halt',\n);\n\n/**\n * Get the MantisConnect webservice version.\n */\nfunction mc_version() {\n\treturn MANTIS_VERSION;\n}\n\n# Checks if MantisBT installation is marked as offline by the administrator.\n# true: offline, false: online\nfunction mci_is_mantis_offline() {\n\t$t_offline_file = dirname( dirname( __FILE__ ) ) . DIRECTORY_SEPARATOR . 'mantis_offline.php';\n\treturn file_exists( $t_offline_file );\n}\n\n# return user_id if successful, otherwise false.\nfunction mci_check_login( $p_username, $p_password ) {\n\tif( mci_is_mantis_offline() ) {\n\t\treturn false;\n\t}\n\n\t# if no user name supplied, then attempt to login as anonymous user.\n\tif( is_blank( $p_username ) ) {\n\t\t$t_anon_allowed = config_get( 'allow_anonymous_login' );\n\t\tif( OFF == $t_anon_allowed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$p_username = config_get( 'anonymous_account' );\n\n\t\t# do not use password validation.\n\t\t$p_password = null;\n\t} else {\n\t\tif( is_blank( $p_password ) ) {\n\t\t\t# require password for authenticated access\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif( false === auth_attempt_script_login( $p_username, $p_password ) ) {\n\t\treturn false;\n\t}\n\n\treturn auth_get_current_user_id();\n}\n\nfunction mci_has_readonly_access( $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= config_get( 'mc_readonly_access_level_threshold' ) );\n}\n\nfunction mci_has_readwrite_access( $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= config_get( 'mc_readwrite_access_level_threshold' ) );\n}\n\nfunction mci_has_access( $p_access_level, $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= (int) $p_access_level );\n}\n\nfunction mci_has_administrator_access( $p_user_id, $p_project_id = ALL_PROJECTS ) {\n\t$t_access_level = user_get_access_level( $p_user_id, $p_project_id );\n\treturn( $t_access_level >= config_get( 'mc_admin_access_level_threshold' ) );\n}\n\nfunction mci_get_project_id( $p_project ) {\n\tif( (int) $p_project['id'] != 0 ) {\n\t\t$t_project_id = (int) $p_project['id'];\n\t} else {\n\t\t$t_project_id = project_get_id_by_name( $p_project['name'] );\n\t}\n\n\treturn $t_project_id;\n}\n\nfunction mci_get_project_status_id( $p_status ) {\n\treturn mci_get_enum_id_from_objectref( 'project_status', $p_status );\n}\n\nfunction mci_get_project_view_state_id( $p_view_state ) {\n\treturn mci_get_enum_id_from_objectref( 'project_view_state', $p_view_state );\n}\n\nfunction mci_get_user_id( $p_user ) {\n\t$t_user_id = 0;\n\n\tif ( isset( $p_user['id'] ) && (int) $p_user['id'] != 0 ) {\n\t\t$t_user_id = (int) $p_user['id'];\n\t} elseif ( isset( $p_user['name'] ) ) {\n\t\t$t_user_id = user_get_id_by_name( $p_user['name'] );\n\t} elseif ( isset( $p_user['email'] ) ) {\n\t\t$t_user_id = user_get_id_by_email( $p_user['email'] );\n\t}\n\n\treturn $t_user_id;\n}\n\nfunction mci_get_user_lang( $p_user_id ) {\n\t$t_lang = user_pref_get_pref( $p_user_id, 'language' );\n\tif( $t_lang == 'auto' ) {\n\t\t$t_lang = config_get( 'fallback_language' );\n\t}\n\treturn $t_lang;\n}\n\nfunction mci_get_status_id( $p_status ) {\n\treturn mci_get_enum_id_from_objectref( 'status', $p_status );\n}\n\nfunction mci_get_severity_id( $p_severity ) {\n\treturn mci_get_enum_id_from_objectref( 'severity', $p_severity );\n}\n\nfunction mci_get_priority_id( $p_priority ) {\n\n\treturn mci_get_enum_id_from_objectref( 'priority', $p_priority );\n}\n\nfunction mci_get_reproducibility_id( $p_reproducibility ) {\n\treturn mci_get_enum_id_from_objectref( 'reproducibility', $p_reproducibility );\n}\n\nfunction mci_get_resolution_id( $p_resolution ) {\n\treturn mci_get_enum_id_from_objectref( 'resolution', $p_resolution );\n}\n\nfunction mci_get_projection_id( $p_projection ) {\n\treturn mci_get_enum_id_from_objectref( 'projection', $p_projection );\n}\n\nfunction mci_get_eta_id( $p_eta ) {\n\treturn mci_get_enum_id_from_objectref( 'eta', $p_eta );\n}\n\nfunction mci_get_view_state_id( $p_view_state ) {\n\treturn mci_get_enum_id_from_objectref( 'view_state', $p_view_state );\n}\n\n# Get null on empty value.\n#\n# @param Object $p_value  The value\n# @return Object  The value if not empty; null otherwise.\n#\nfunction mci_null_if_empty( $p_value ) {\n\tif( !is_blank( $p_value ) ) {\n\t\treturn $p_value;\n\t}\n\n\treturn null;\n}\n\n/**\n * Gets the url for MantisBT.\n *\n * @return MantisBT URL terminated by a /.\n */\nfunction mci_get_mantis_path() {\n    \n\treturn config_get( 'path' );\n}\n\n# Given a enum string and num, return the appropriate localized string\nfunction mci_get_enum_element( $p_enum_name, $p_val, $p_lang ) {\n\t$t_enum_string = config_get( $p_enum_name . '_enum_string' );\n\t$t_localized_enum_string = lang_get( $p_enum_name . '_enum_string', $p_lang );\n\n\treturn MantisEnum::getLocalizedLabel( $t_enum_string, $t_localized_enum_string, $p_val );\n}\n\n# Gets the sub-projects that are accessible to the specified user / project.\nfunction mci_user_get_accessible_subprojects( $p_user_id, $p_parent_project_id, $p_lang = null ) {\n\tif( $p_lang === null ) {\n\t\t$t_lang = mci_get_user_lang( $p_user_id );\n\t} else {\n\t\t$t_lang = $p_lang;\n\t}\n\n\t$t_result = array();\n\tforeach( user_get_accessible_subprojects( $p_user_id, $p_parent_project_id ) as $t_subproject_id ) {\n\t\t$t_subproject_row = project_cache_row( $t_subproject_id );\n\t\t$t_subproject = array();\n\t\t$t_subproject['id'] = $t_subproject_id;\n\t\t$t_subproject['name'] = $t_subproject_row['name'];\n\t\t$t_subproject['status'] = mci_enum_get_array_by_id( $t_subproject_row['status'], 'project_status', $t_lang );\n\t\t$t_subproject['enabled'] = $t_subproject_row['enabled'];\n\t\t$t_subproject['view_state'] = mci_enum_get_array_by_id( $t_subproject_row['view_state'], 'project_view_state', $t_lang );\n\t\t$t_subproject['access_min'] = mci_enum_get_array_by_id( $t_subproject_row['access_min'], 'access_levels', $t_lang );\n\t\t$t_subproject['file_path'] = array_key_exists( 'file_path', $t_subproject_row ) ? $t_subproject_row['file_path'] : \"\";\n\t\t$t_subproject['description'] = array_key_exists( 'description', $t_subproject_row ) ? $t_subproject_row['description'] : \"\";\n\t\t$t_subproject['subprojects'] = mci_user_get_accessible_subprojects( $p_user_id, $t_subproject_id, $t_lang );\n\t\t$t_result[] = $t_subproject;\n\t}\n\n\treturn $t_result;\n}\n\nfunction translate_category_name_to_id( $p_category_name, $p_project_id ) {\n\tif ( !isset( $p_category_name ) ) {\n\t\treturn 0;\n\t}\n\n\t$t_cat_array = category_get_all_rows( $p_project_id );\n\tforeach( $t_cat_array as $t_category_row ) {\n\t\tif( $t_category_row['name'] == $p_category_name ) {\n\t\t\treturn $t_category_row['id'];\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * Basically this is a copy of core/filter_api.php#filter_db_get_available_queries().\n * The only difference is that the result of this function is not an array of filter\n * names but an array of filter structures.\n */\nfunction mci_filter_db_get_available_queries( $p_project_id = null, $p_user_id = null ) {\n\t$t_filters_table = db_get_table( 'filters' );\n\t$t_overall_query_arr = array();\n\n\tif( null === $p_project_id ) {\n\t\t$t_project_id = helper_get_current_project();\n\t} else {\n\t\t$t_project_id = db_prepare_int( $p_project_id );\n\t}\n\n\tif( null === $p_user_id ) {\n\t\t$t_user_id = auth_get_current_user_id();\n\t} else {\n\t\t$t_user_id = db_prepare_int( $p_user_id );\n\t}\n\n\t# If the user doesn't have access rights to stored queries, just return\n\tif( !access_has_project_level( config_get( 'stored_query_use_threshold' ) ) ) {\n\t\treturn $t_overall_query_arr;\n\t}\n\n\t# Get the list of available queries. By sorting such that public queries are\n\t# first, we can override any query that has the same name as a private query\n\t# with that private one\n\t$query = \"SELECT * FROM $t_filters_table\n\t\t\t\tWHERE (project_id='$t_project_id'\n\t\t\t\tOR project_id='0')\n\t\t\t\tAND name!=''\n\t\t\t\tORDER BY is_public DESC, name ASC\";\n\t$result = db_query( $query );\n\t$query_count = db_num_rows( $result );\n\n\tfor( $i = 0;$i < $query_count;$i++ ) {\n\t\t$row = db_fetch_array( $result );\n\t\tif(( $row['user_id'] == $t_user_id ) || db_prepare_bool( $row['is_public'] ) ) {\n\n\t\t    $t_filter_detail = explode( '#', $row['filter_string'], 2 );\n\t\t    if ( !isset($t_filter_detail[1]) ) {\n\t\t    \tcontinue;\n\t\t    }\n        \t$t_filter = unserialize( $t_filter_detail[1] );\n\t        $t_filter = filter_ensure_valid_filter( $t_filter );\n\t\t    $row['url'] = filter_get_url( $t_filter );\n\t\t\t$t_overall_query_arr[$row['name']] = $row;\n\t\t}\n\t}\n\n\treturn array_values( $t_overall_query_arr );\n}\n\n/**\n * Get a category definition.\n *\n * @param integer $p_category_id  The id of the category to retrieve.\n * @return Array an Array containing the id and the name of the category.\n */\nfunction mci_category_as_array_by_id( $p_category_id ) {\n\t$t_result = array();\n\t$t_result['id'] = $p_category_id;\n\t$t_result['name'] = category_get_name( $p_category_id );\n\treturn $t_result;\n}\n\n/**\n * Transforms a version array into an array suitable for marshalling into ProjectVersionData\n * \n * @param array $p_version\n */\nfunction mci_project_version_as_array( $p_version ) {\n    \n    return array(\n\t\t\t'id' => $p_version['id'],\n\t\t\t'name' => $p_version['version'],\n\t\t\t'project_id' => $p_version['project_id'],\n\t\t\t'date_order' => timestamp_to_iso8601( $p_version['date_order'], false ),\n\t\t\t'description' => mci_null_if_empty( $p_version['description'] ),\n\t\t\t'released' => $p_version['released'],\n\t\t    'obsolete' => $p_version['obsolete']\n\t\t);\n}\n\n/**\n * Returns time tracking information from a bug note.\n *\n * @param int $p_issue_id The id of the issue\n * @param Array $p_note A note as passed to the soap api methods\n *\n * @return String the string time entry to be added to the bugnote, in 'HH:mm' format\n */\nfunction mci_get_time_tracking_from_note( $p_issue_id, $p_note) {\n\n\tif ( !access_has_bug_level( config_get( 'time_tracking_view_threshold' ), $p_issue_id ) )\n\t\treturn '00:00';\n\n\tif ( !isset( $p_note['time_tracking'] ))\n\t\treturn '00:00';\n\n\treturn db_minutes_to_hhmm($p_note['time_tracking']);\n}\n\n/**\n * SECURITY NOTE: these globals are initialized here to prevent them\n * being spoofed if register_globals is turned on\n */\n$g_error_parameters = array();\n$g_error_handled = false;\n$g_error_proceed_url = null;\n\n# Default error handler\n#\n# This handler will not receive E_ERROR, E_PARSE, E_CORE_*, or E_COMPILE_*\n#  errors.\n#\n# E_USER_* are triggered by us and will contain an error constant in $p_error\n# The others, being system errors, will come with a string in $p_error\n#\nfunction mc_error_handler( $p_type, $p_error, $p_file, $p_line, $p_context ) {\n\tglobal $g_error_parameters, $g_error_handled, $g_error_proceed_url;\n\tglobal $g_lang_overrides;\n\tglobal $g_error_send_page_header;\n\tglobal $l_oServer;\n\n\t# check if errors were disabled with @ somewhere in this call chain\n\t# also suppress php 5 strict warnings\n\tif( 0 == error_reporting() || 2048 == $p_type ) {\n\t\treturn;\n\t}\n\n\t$t_lang_pushed = false;\n\n\t# flush any language overrides to return to user's natural default\n\tif( function_exists( 'db_is_connected' ) ) {\n\t\tif( db_is_connected() ) {\n\t\t\tlang_push( lang_get_default() );\n\t\t\t$t_lang_pushed = true;\n\t\t}\n\t}\n\n\t$t_short_file = basename( $p_file );\n\t$t_method_array = config_get( 'display_errors' );\n\tif( isset( $t_method_array[$p_type] ) ) {\n\t\t$t_method = $t_method_array[$p_type];\n\t} else {\n\t\t$t_method = 'none';\n\t}\n\n\t# build an appropriate error string\n\tswitch( $p_type ) {\n\t\tcase E_WARNING:\n\t\t\t$t_error_type = 'SYSTEM WARNING';\n\t\t\t$t_error_description = $p_error;\n\t\t\tbreak;\n\t\tcase E_NOTICE:\n\t\t\t$t_error_type = 'SYSTEM NOTICE';\n\t\t\t$t_error_description = $p_error;\n\t\t\tbreak;\n\t\tcase E_USER_ERROR:\n\t\t\t$t_error_type = \"APPLICATION ERROR #$p_error\";\n\t\t\t$t_error_description = error_string( $p_error );\n\t\t\tbreak;\n\t\tcase E_USER_WARNING:\n\t\t\t$t_error_type = \"APPLICATION WARNING #$p_error\";\n\t\t\t$t_error_description = error_string( $p_error );\n\t\t\tbreak;\n\t\tcase E_USER_NOTICE:\n\n\t\t\t# used for debugging\n\t\t\t$t_error_type = 'DEBUG';\n\t\t\t$t_error_description = $p_error;\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t#shouldn't happen, just display the error just in case\n\t\t\t$t_error_type = '';\n\t\t\t$t_error_description = $p_error;\n\t}\n\n\t$t_error_description = $t_error_description;\n\t$t_error_stack = error_get_stack_trace();\n\n\t$l_oServer->fault( 'Server', \"Error Type: $t_error_type,\\nError Description:\\n$t_error_description,\\nStack Trace:\\n$t_error_stack\" );\n\t$l_oServer->send_response();\n\texit();\n}\n\n# Get a stack trace if PHP provides the facility or xdebug is present\nfunction error_get_stack_trace() {\n\t$t_trace = '';\n\n\tif ( extension_loaded( 'xdebug' ) ) {\n\n\t\t#check for xdebug presence\n\t\t$t_stack = xdebug_get_function_stack();\n\n\t\t# reverse the array in a separate line of code so the\n\t\t#  array_reverse() call doesn't appear in the stack\n\t\t$t_stack = array_reverse( $t_stack );\n\t\tarray_shift( $t_stack );\n\n\t\t#remove the call to this function from the stack trace\n\t\tforeach( $t_stack as $t_frame ) {\n\t\t\t$t_trace .= ( isset( $t_frame['file'] ) ? basename( $t_frame['file'] ) : 'UnknownFile' ) . ' L' . ( isset( $t_frame['line'] ) ? $t_frame['line'] : '?' ) . ' ' . ( isset( $t_frame['function'] ) ? $t_frame['function'] : 'UnknownFunction' );\n\n\t\t\t$t_args = array();\n\t\t\tif ( isset( $t_frame['params'] ) && ( count( $t_frame['params'] ) > 0 ) ) {\n\t\t\t\t$t_trace .= ' Params: ';\n\t\t\t\tforeach( $t_frame['params'] as $t_value ) {\n\t\t\t\t\t$t_args[] = error_build_parameter_string( $t_value );\n\t\t\t\t}\n\n\t\t\t\t$t_trace .= '(' . implode( $t_args, ', ' ) . ')';\n\t\t\t} else {\n\t\t\t\t$t_trace .= '()';\n\t\t\t}\n\n\t\t\t$t_trace .= \"\\n\";\n\t\t}\n\t} else {\n\t\t$t_stack = debug_backtrace();\n\n\t\tarray_shift( $t_stack ); #remove the call to this function from the stack trace\n\t\tarray_shift( $t_stack ); #remove the call to the error handler from the stack trace\n\n\t\tforeach( $t_stack as $t_frame ) {\n\t\t\t$t_trace .= ( isset( $t_frame['file'] ) ? basename( $t_frame['file'] ) : 'UnknownFile' ) . ' L' . ( isset( $t_frame['line'] ) ? $t_frame['line'] : '?' ) . ' ' . ( isset( $t_frame['function'] ) ? $t_frame['function'] : 'UnknownFunction' );\n\n\t\t\t$t_args = array();\n\t\t\tif( isset( $t_frame['args'] ) ) {\n\t\t\t\tforeach( $t_frame['args'] as $t_value ) {\n\t\t\t\t\t$t_args[] = error_build_parameter_string( $t_value );\n\t\t\t\t}\n\n\t\t\t\t$t_trace .= '(' . implode( $t_args, ', ' ) . ')';\n\t\t\t} else {\n\t\t\t\t$t_trace .= '()';\n\t\t\t}\n\n\t\t\t$t_trace .= \"\\n\";\n\t\t}\n\t}\n\n\treturn $t_trace;\n}\n\n/**\n * Returns a soap_fault signalling corresponding to a failed login\n * situation\n *\n * @return soap_fault\n */\nfunction mci_soap_fault_login_failed() {\n\treturn new soap_fault('Client', '', 'Access denied.');\n}\n\n/**\n * Returns a soap_fault signalling that the user does not have\n * access rights for the specific action.\n *\n * @param int $p_user_id a valid user id\n * @param string $p_detail The optional details to append to the error message\n * @return soap_fault\n */\nfunction mci_soap_fault_access_denied( $p_user_id, $p_detail = '' ) {\n\t$t_user_name = user_get_name( $p_user_id );\n\t$t_reason = 'Access denied for user '. $t_user_name . '.';\n\tif ( !is_blank( $p_detail ))\n\t\t$t_reason .= ' Reason: ' . $p_detail . '.';\n\n\treturn new soap_fault( 'Client', '',  $t_reason );\n}\n"], "filenames": ["api/soap/mc_api.php"], "buggy_code_start_loc": [53], "buggy_code_end_loc": [53], "fixing_code_start_loc": [54], "fixing_code_end_loc": [59], "type": "CWE-287", "message": "The mci_check_login function in api/soap/mc_api.php in the SOAP API in MantisBT before 1.2.9 allows remote attackers to bypass authentication via a null password.", "other": {"cve": {"id": "CVE-2012-1123", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-29T19:55:03.140", "lastModified": "2021-01-12T18:05:59.507", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mci_check_login function in api/soap/mc_api.php in the SOAP API in MantisBT before 1.2.9 allows remote attackers to bypass authentication via a null password."}, {"lang": "es", "value": "La funci\u00f3n mci_check_login de api/soap/mc_api.php de la API SOAP de MantisBT anteriores a 1.2.9 permite a atacantes remotos evitar la autenticaci\u00f3n a trav\u00e9s de una contrase\u00f1a nula."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.8", "matchCriteriaId": "79367D94-9665-49D7-94E4-CC9EFC7439BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.18.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF83F757-4B62-441C-8421-15809E573A83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:*:*:*:*:*:*:*", "matchCriteriaId": "A608AFEC-B265-4143-99DA-BB2AE9D522BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:a1:*:*:*:*:*:*", "matchCriteriaId": "A826DA75-7DEE-4E96-9B00-347508BBCFE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:a2:*:*:*:*:*:*", "matchCriteriaId": "06663B16-0609-4FCF-9B42-6BF30D25E67A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7FCB56AC-4C14-49B1-BEFE-8651BC70476E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.1:*:*:*:*:*:*:*", "matchCriteriaId": "F59BAE6B-C73D-4BE2-AEF9-93F2F4A4373F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9DA5C2F-FB7C-4D95-81DE-24D8EADC5C30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.3:*:*:*:*:*:*:*", "matchCriteriaId": "85A3FBD5-163C-4990-B809-A5C9C81A3C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.4:*:*:*:*:*:*:*", "matchCriteriaId": "D3FDF456-9648-4A7C-B15A-2828A32D4962"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.5:*:*:*:*:*:*:*", "matchCriteriaId": "9EE8BCBE-D864-4311-B73A-DF92162D8DF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6B2602F7-2D93-4E1E-9425-4EDD23752029"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:a1:*:*:*:*:*:*", "matchCriteriaId": "482256A6-B213-4226-AF03-9F93164AA337"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:a2:*:*:*:*:*:*", "matchCriteriaId": "1F005474-CEBD-48FC-9C7F-861AFF771081"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:a3:*:*:*:*:*:*", "matchCriteriaId": "BEF461E5-24D2-4540-A2FC-E0D4C3488B8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "62F6B391-DDE3-4E8E-8582-85EA7287E591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "80DBD667-1FB9-4354-9150-A190D4D817A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "F27E40C0-263F-452B-8C91-E621A02EFC28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB888B14-EA67-4EDB-A3AF-ACD3F0A6227E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "1DB45A02-2522-4E10-BC81-48750ACB42DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "86DE3BE3-D6C9-4905-9E61-B70776460604"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "F128A2E2-D509-4B50-95C2-1A31C5B3B31F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "140D5F68-1CAB-458C-BC8B-4F726D657FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D25F4F5-7678-41C1-93CB-305883A08527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "D1A1316D-314B-4740-A836-D5E6319F4B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DBD27CCE-28C4-43CC-8CBD-D7FFB46171AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "97298C43-B881-4C11-ADB6-17A8E43EB84E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "7257ADD7-C9B7-4F85-AA13-615DD033FD5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "DE6A94C0-48A1-4D42-AC43-7B4E959C4E21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "02FE950B-5E29-4FAA-9BE5-79F38B4C38F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a1:*:*:*:*:*:*", "matchCriteriaId": "45FF2B45-AA64-4428-8F6E-65C5171990CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a2:*:*:*:*:*:*", "matchCriteriaId": "CC868663-1E48-4F9A-B687-5B48D016611B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a3:*:*:*:*:*:*", "matchCriteriaId": "4F04ED02-4D99-45CF-9BEC-AC0F648748EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:a4:*:*:*:*:*:*", "matchCriteriaId": "0AC08731-C4BB-4D84-ADBE-80054149BF33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "35AAF0B4-31B5-4849-813F-63D9546C2E16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "FB98EF06-7D6E-4D5F-819D-21B437E91B58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "66AB409E-5A5B-4455-8B68-22C32152681B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "D6F2BA78-D054-4E49-ABCA-637922898BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "4595B1E3-25AB-489E-A847-FDBF2554DD6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "E6A13A38-E149-42A7-9309-BC991521320B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "C11A8F17-5253-475B-89FF-A26EA7531E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "4A88B09D-CDCF-45FD-B004-13B597DA4F48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "49583BE8-B832-4E9F-B154-47A26C72489D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "E2501F40-3630-4528-BE0A-61D4BB6EC7FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "9223DAF7-D03E-4A4E-8AB5-5CEB87DFF2C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "078C0943-C27C-44A9-B00D-5A261C58D6CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "CFF77ABF-0A03-437A-B241-1EF2BBB83D24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "9DA2615A-CD65-4765-AB0A-D72C2BEB00F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "7D09CC46-DFA2-408D-8720-05C23E73C859"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "3461212B-A96B-4D38-A722-84E7418C2A7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7B6DEE14-744B-4DE4-BDCF-E4E4D37F70A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D4462BEE-39B6-47BD-B08F-5BE1FD918221"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F096CD6-534E-4ABF-B2DF-D4B55B8C5F6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "A66AB537-6FBA-4A51-B10C-BF61F54BC01B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "A50835BF-D28B-47FF-81F0-C34D95D6F2E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "BA0EB9A6-1DFD-4C17-A002-0899DA252A56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "BBA33285-3EE7-43FD-8347-E7D9A18DC134"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "8827C2B4-EBEC-4D64-9AC8-07A048467F40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "1F32DFF4-6448-46FD-9358-4FB1C310EC2E"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/092926.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093063.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093064.html", "source": "secalert@redhat.com"}, {"url": "http://security.gentoo.org/glsa/glsa-201211-01.xml", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2012/dsa-2500", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/changelog_page.php?version_id=140", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/view.php?id=13901", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/06/9", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/52313", "source": "secalert@redhat.com"}, {"url": "https://github.com/mantisbt/mantisbt/commit/f5106be52cf6aa72c521f388e4abb5f0de1f1d7f", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mantisbt/mantisbt/commit/f5106be52cf6aa72c521f388e4abb5f0de1f1d7f"}}