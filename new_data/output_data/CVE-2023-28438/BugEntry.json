{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\Tool\\CustomReport\\Adapter;\n\nuse Pimcore\\Db;\n\n/**\n * @internal\n */\nclass Sql extends AbstractAdapter\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function getData($filters, $sort, $dir, $offset, $limit, $fields = null, $drillDownFilters = null)\n    {\n        $db = Db::get();\n\n        $baseQuery = $this->getBaseQuery($filters, $fields, false, $drillDownFilters);\n        $data = [];\n        $total = 0;\n\n        if ($baseQuery) {\n            $total = $db->fetchOne($baseQuery['count']);\n\n            $order = '';\n            if ($sort && $dir) {\n                $order = ' ORDER BY ' . $db->quoteIdentifier($sort) . ' ' . $dir;\n            }\n\n            $sql = $baseQuery['data'] . $order;\n            if ($offset !== null && $limit) {\n                $sql .= \" LIMIT $offset,$limit\";\n            }\n\n            $data = $db->fetchAllAssociative($sql);\n        }\n\n        return ['data' => $data, 'total' => $total];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getColumns($configuration)\n    {\n        $sql = '';\n        if ($configuration) {\n            $sql = $this->buildQueryString($configuration);\n        }\n\n        if (!preg_match('/(ALTER|CREATE|DROP|RENAME|TRUNCATE|UPDATE|DELETE) /i', $sql, $matches)) {\n            $sql .= ' LIMIT 0,1';\n            $db = Db::get();\n            $res = $db->fetchAssociative($sql);\n            if ($res) {\n                return array_keys($res);\n            }\n\n            return [];\n        }\n\n        throw new \\Exception(\"Only 'SELECT' statements are allowed! You've used '\" . $matches[0] . \"'\");\n    }\n\n    /**\n     * @param \\stdClass $config\n     * @param bool $ignoreSelectAndGroupBy\n     * @param array|null $drillDownFilters\n     * @param string|null $selectField\n     *\n     * @return string\n     */\n    protected function buildQueryString($config, $ignoreSelectAndGroupBy = false, $drillDownFilters = null, $selectField = null)\n    {\n        $config = (array)$config;\n        $sql = '';\n        if (!empty($config['sql']) && !$ignoreSelectAndGroupBy) {\n            if (strpos(strtoupper(trim($config['sql'])), 'SELECT') !== 0) {\n                $sql .= 'SELECT ';\n            }\n            $sql .= str_replace(\"\\n\", ' ', $config['sql']);\n        } elseif ($selectField) {\n            $db = Db::get();\n            $sql .= 'SELECT ' . $db->quoteIdentifier($selectField);\n        } else {\n            $sql .= 'SELECT *';\n        }\n        if (!empty($config['from'])) {\n            if (strpos(strtoupper(trim($config['from'])), 'FROM') !== 0) {\n                $sql .= ' FROM ';\n            }\n            $sql .= ' ' . str_replace(\"\\n\", ' ', $config['from']);\n        }\n\n        if (!empty($config['where'])) {\n            if (str_starts_with(strtoupper(trim($config['where'])), 'WHERE')) {\n                $config['where'] = preg_replace('/^\\s*WHERE\\s*/', '', $config['where']);\n            }\n            $sql .= ' WHERE (' . str_replace(\"\\n\", ' ', $config['where']) . ')';\n        }\n\n        if (!empty($config['groupby']) && !$ignoreSelectAndGroupBy) {\n            if (strpos(strtoupper(trim($config['groupby'])), 'GROUP BY') !== 0) {\n                $sql .= ' GROUP BY ';\n            }\n            $sql .= ' ' . str_replace(\"\\n\", ' ', $config['groupby']);\n        }\n\n        if ($drillDownFilters) {\n            $havingParts = [];\n            $db = Db::get();\n            foreach ($drillDownFilters as $field => $value) {\n                if ($value !== '' && $value !== null) {\n                    $havingParts[] = \"$field = \" . $db->quote($value);\n                }\n            }\n\n            if ($havingParts) {\n                $sql .= ' HAVING ' . implode(' AND ', $havingParts);\n            }\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @param array $filters\n     * @param array $fields\n     * @param bool $ignoreSelectAndGroupBy\n     * @param array|null $drillDownFilters\n     * @param string|null $selectField\n     *\n     * @return array|null\n     */\n    protected function getBaseQuery($filters, $fields, $ignoreSelectAndGroupBy = false, $drillDownFilters = null, $selectField = null)\n    {\n        $db = Db::get();\n        $condition = ['1 = 1'];\n\n        $sql = $this->buildQueryString($this->config, $ignoreSelectAndGroupBy, $drillDownFilters, $selectField);\n\n        $data = '';\n        $extractAllFields = empty($fields);\n        if ($filters) {\n            if (is_array($filters)) {\n                foreach ($filters as $filter) {\n                    $value = $filter['value'] ?? null;\n                    $type = $filter['type'];\n                    $operator = $filter['operator'];\n                    $maxValue = null;\n                    if ($type == 'date') {\n                        if ($operator == 'eq') {\n                            $maxValue = strtotime($value . '+23 hours 59 minutes');\n                        }\n                        $value = strtotime($value);\n                    }\n\n                    switch ($operator) {\n                        case 'like':\n                            $fields[] = $filter['property'];\n                            $condition[] = $db->quoteIdentifier($filter['property']) . ' LIKE ' . $db->quote('%' . $value. '%');\n\n                            break;\n                        case 'lt':\n                        case 'gt':\n                        case 'eq':\n                            $compMapping = [\n                                'lt' => '<',\n                                'gt' => '>',\n                                'eq' => '=',\n                            ];\n\n                            if ($type == 'date') {\n                                if ($operator == 'eq') {\n                                    $condition[] = $db->quoteIdentifier($filter['property']) . ' BETWEEN ' . $db->quote($value) . ' AND ' . $db->quote($maxValue);\n\n                                    break;\n                                }\n                            }\n                            $fields[] = $filter['property'];\n                            $condition[] = $db->quoteIdentifier($filter['property']) . ' ' . $compMapping[$operator] . ' ' . $db->quote($value);\n\n                            break;\n                        case '=':\n                            $fields[] = $filter['property'];\n                            $condition[] = $db->quoteIdentifier($filter['property']) . ' = ' . $db->quote($value);\n\n                            break;\n                    }\n                }\n            }\n        }\n\n        if (!preg_match('/(ALTER|CREATE|DROP|RENAME|TRUNCATE|UPDATE|DELETE) /i', $sql, $matches)) {\n            $condition = implode(' AND ', $condition);\n\n            $total = 'SELECT COUNT(*) FROM (' . $sql . ') AS somerandxyz WHERE ' . $condition;\n\n            if ($fields && !$extractAllFields) {\n                $data = 'SELECT `' . implode('`,`', $fields) . '` FROM (' . $sql . ') AS somerandxyz WHERE ' . $condition;\n            } else {\n                $data = 'SELECT * FROM (' . $sql . ') AS somerandxyz WHERE ' . $condition;\n            }\n        } else {\n            return null;\n        }\n\n        return [\n            'data' => $data,\n            'count' => $total,\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAvailableOptions($filters, $field, $drillDownFilters)\n    {\n        $db = Db::get();\n        $baseQuery = $this->getBaseQuery($filters, [$field], false, $drillDownFilters);\n        $data = [];\n        if ($baseQuery) {\n            $sql = $baseQuery['data'] . ' GROUP BY ' . $db->quoteIdentifier($field);\n            $data = $db->fetchAllAssociative($sql);\n        }\n\n        $filteredData = [];\n        foreach ($data as $d) {\n            if (!empty($d[$field]) || $d[$field] === 0) {\n                $filteredData[] = ['value' => $d[$field]];\n            }\n        }\n\n        return [\n            'data' => array_merge(\n                [\n                    ['value' => null],\n                ],\n                $filteredData\n            ),\n        ];\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\Tool\\CustomReport\\Adapter;\n\nuse Pimcore\\Db;\n\n/**\n * @internal\n */\nclass Sql extends AbstractAdapter\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function getData($filters, $sort, $dir, $offset, $limit, $fields = null, $drillDownFilters = null)\n    {\n        $db = Db::get();\n\n        $baseQuery = $this->getBaseQuery($filters, $fields, false, $drillDownFilters);\n        $data = [];\n        $total = 0;\n\n        if ($baseQuery) {\n            $total = $db->fetchOne($baseQuery['count']);\n\n            $order = '';\n            if ($sort && $dir) {\n                $dir = ((strtoupper($dir) === 'ASC') ? 'ASC' : 'DESC');\n                $order = ' ORDER BY ' . $db->quoteIdentifier($sort) . ' ' .$dir;\n            }\n\n            $sql = $baseQuery['data'] . $order;\n            if ($offset !== null && $limit) {\n                $sql .= \" LIMIT $offset,$limit\";\n            }\n\n            $data = $db->fetchAllAssociative($sql);\n        }\n\n        return ['data' => $data, 'total' => $total];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getColumns($configuration)\n    {\n        $sql = '';\n        if ($configuration) {\n            $sql = $this->buildQueryString($configuration);\n        }\n\n        if (!preg_match('/(ALTER|CREATE|DROP|RENAME|TRUNCATE|UPDATE|DELETE) /i', $sql, $matches)) {\n            $sql .= ' LIMIT 0,1';\n            $db = Db::get();\n            $res = $db->fetchAssociative($sql);\n            if ($res) {\n                return array_keys($res);\n            }\n\n            return [];\n        }\n\n        throw new \\Exception(\"Only 'SELECT' statements are allowed! You've used '\" . $matches[0] . \"'\");\n    }\n\n    /**\n     * @param \\stdClass $config\n     * @param bool $ignoreSelectAndGroupBy\n     * @param array|null $drillDownFilters\n     * @param string|null $selectField\n     *\n     * @return string\n     */\n    protected function buildQueryString($config, $ignoreSelectAndGroupBy = false, $drillDownFilters = null, $selectField = null)\n    {\n        $config = (array)$config;\n        $sql = '';\n        if (!empty($config['sql']) && !$ignoreSelectAndGroupBy) {\n            if (strpos(strtoupper(trim($config['sql'])), 'SELECT') !== 0) {\n                $sql .= 'SELECT ';\n            }\n            $sql .= str_replace(\"\\n\", ' ', $config['sql']);\n        } elseif ($selectField) {\n            $db = Db::get();\n            $sql .= 'SELECT ' . $db->quoteIdentifier($selectField);\n        } else {\n            $sql .= 'SELECT *';\n        }\n        if (!empty($config['from'])) {\n            if (strpos(strtoupper(trim($config['from'])), 'FROM') !== 0) {\n                $sql .= ' FROM ';\n            }\n            $sql .= ' ' . str_replace(\"\\n\", ' ', $config['from']);\n        }\n\n        if (!empty($config['where'])) {\n            if (str_starts_with(strtoupper(trim($config['where'])), 'WHERE')) {\n                $config['where'] = preg_replace('/^\\s*WHERE\\s*/', '', $config['where']);\n            }\n            $sql .= ' WHERE (' . str_replace(\"\\n\", ' ', $config['where']) . ')';\n        }\n\n        if (!empty($config['groupby']) && !$ignoreSelectAndGroupBy) {\n            if (strpos(strtoupper(trim($config['groupby'])), 'GROUP BY') !== 0) {\n                $sql .= ' GROUP BY ';\n            }\n            $sql .= ' ' . str_replace(\"\\n\", ' ', $config['groupby']);\n        }\n\n        if ($drillDownFilters) {\n            $havingParts = [];\n            $db = Db::get();\n            foreach ($drillDownFilters as $field => $value) {\n                if ($value !== '' && $value !== null) {\n                    $havingParts[] = ($db->quoteIdentifier($field) .\" = \" . $db->quote($value));\n                }\n            }\n\n            if ($havingParts) {\n                $sql .= ' HAVING ' . implode(' AND ', $havingParts);\n            }\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @param array $filters\n     * @param array $fields\n     * @param bool $ignoreSelectAndGroupBy\n     * @param array|null $drillDownFilters\n     * @param string|null $selectField\n     *\n     * @return array|null\n     */\n    protected function getBaseQuery($filters, $fields, $ignoreSelectAndGroupBy = false, $drillDownFilters = null, $selectField = null)\n    {\n        $db = Db::get();\n        $condition = ['1 = 1'];\n\n        $sql = $this->buildQueryString($this->config, $ignoreSelectAndGroupBy, $drillDownFilters, $selectField);\n\n        $data = '';\n        $extractAllFields = empty($fields);\n        if ($filters) {\n            if (is_array($filters)) {\n                foreach ($filters as $filter) {\n                    $value = $filter['value'] ?? null;\n                    $type = $filter['type'];\n                    $operator = $filter['operator'];\n                    $maxValue = null;\n                    if ($type == 'date') {\n                        if ($operator == 'eq') {\n                            $maxValue = strtotime($value . '+23 hours 59 minutes');\n                        }\n                        $value = strtotime($value);\n                    }\n\n                    switch ($operator) {\n                        case 'like':\n                            $fields[] = $filter['property'];\n                            $condition[] = $db->quoteIdentifier($filter['property']) . ' LIKE ' . $db->quote('%' . $value. '%');\n\n                            break;\n                        case 'lt':\n                        case 'gt':\n                        case 'eq':\n                            $compMapping = [\n                                'lt' => '<',\n                                'gt' => '>',\n                                'eq' => '=',\n                            ];\n\n                            if ($type == 'date') {\n                                if ($operator == 'eq') {\n                                    $condition[] = $db->quoteIdentifier($filter['property']) . ' BETWEEN ' . $db->quote($value) . ' AND ' . $db->quote($maxValue);\n\n                                    break;\n                                }\n                            }\n                            $fields[] = $filter['property'];\n                            $condition[] = $db->quoteIdentifier($filter['property']) . ' ' . $compMapping[$operator] . ' ' . $db->quote($value);\n\n                            break;\n                        case '=':\n                            $fields[] = $filter['property'];\n                            $condition[] = $db->quoteIdentifier($filter['property']) . ' = ' . $db->quote($value);\n\n                            break;\n                    }\n                }\n            }\n        }\n\n        if (!preg_match('/(ALTER|CREATE|DROP|RENAME|TRUNCATE|UPDATE|DELETE) /i', $sql, $matches)) {\n            $condition = implode(' AND ', $condition);\n\n            $total = 'SELECT COUNT(*) FROM (' . $sql . ') AS somerandxyz WHERE ' . $condition;\n\n            if ($fields && !$extractAllFields) {\n                $data = 'SELECT `' . implode('`,`', $fields) . '` FROM (' . $sql . ') AS somerandxyz WHERE ' . $condition;\n            } else {\n                $data = 'SELECT * FROM (' . $sql . ') AS somerandxyz WHERE ' . $condition;\n            }\n        } else {\n            return null;\n        }\n\n        return [\n            'data' => $data,\n            'count' => $total,\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAvailableOptions($filters, $field, $drillDownFilters)\n    {\n        $db = Db::get();\n        $baseQuery = $this->getBaseQuery($filters, [$field], false, $drillDownFilters);\n        $data = [];\n        if ($baseQuery) {\n            $sql = $baseQuery['data'] . ' GROUP BY ' . $db->quoteIdentifier($field);\n            $data = $db->fetchAllAssociative($sql);\n        }\n\n        $filteredData = [];\n        foreach ($data as $d) {\n            if (!empty($d[$field]) || $d[$field] === 0) {\n                $filteredData[] = ['value' => $d[$field]];\n            }\n        }\n\n        return [\n            'data' => array_merge(\n                [\n                    ['value' => null],\n                ],\n                $filteredData\n            ),\n        ];\n    }\n}\n"], "filenames": ["models/Tool/CustomReport/Adapter/Sql.php"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [129], "fixing_code_start_loc": [41], "fixing_code_end_loc": [130], "type": "CWE-89", "message": "Pimcore is an open source data and experience management platform. Prior to version 10.5.19, since a user with 'report' permission can already write arbitrary SQL queries and given the fact that this endpoint is using the GET method (no CSRF protection), an attacker can inject an arbitrary query by manipulating a user to click on a link. Users should upgrade to version 10.5.19 to receive a patch or, as a workaround, may apply the patch manually.", "other": {"cve": {"id": "CVE-2023-28438", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-22T21:15:18.520", "lastModified": "2023-03-27T22:13:52.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pimcore is an open source data and experience management platform. Prior to version 10.5.19, since a user with 'report' permission can already write arbitrary SQL queries and given the fact that this endpoint is using the GET method (no CSRF protection), an attacker can inject an arbitrary query by manipulating a user to click on a link. Users should upgrade to version 10.5.19 to receive a patch or, as a workaround, may apply the patch manually."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.19", "matchCriteriaId": "9F355AEC-329F-43D1-A3D7-44C2481A1999"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/d1abadb181c88ebaa4bce1916f9077469d4ea2bc.patch", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pimcore/pimcore/pull/14526", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/pimcore/pimcore/security/advisories/GHSA-vf7q-g2pv-jxvx", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/d1abadb181c88ebaa4bce1916f9077469d4ea2bc.patch"}}