{"buggy_code": ["'use strict';\n\n/*\n * Request\n *\n * Copyright(c) 2014 Francois-Guillaume Ribreau <npm@fgribreau.com>\n * MIT Licensed\n *\n */\nvar extend = require('extend');\nvar request = require('request');\nvar RetryStrategies = require('./strategies');\nvar _ = require('lodash');\n\nvar DEFAULTS = {\n  maxAttempts: 5, // try 5 times\n  retryDelay: 5000, // wait for 5s before trying again\n  fullResponse: true, // resolve promise with the full response object\n  promiseFactory: defaultPromiseFactory // Function to use a different promise implementation library\n};\n\n// Default promise factory which use bluebird\nfunction defaultPromiseFactory(resolver) {\n  return new Promise(resolver);\n}\n\nfunction _cloneOptions(options) {\n  const cloned = {};\n  for (let key in options) {\n    if (options.hasOwnProperty(key)) {\n      cloned[key] = key === 'agent' ? options[key] : _.cloneDeep(options[key]);\n    }\n  }\n  return cloned;\n}\n\n/**\n * It calls the promiseFactory function passing it the resolver for the promise\n *\n * @param {Object} requestInstance - The Request Retry instance\n * @param {Function} promiseFactoryFn - The Request Retry instance\n * @return {Object} - The promise instance\n */\nfunction makePromise(requestInstance, promiseFactoryFn) {\n\n  // Resolver function wich assigns the promise (resolve, reject) functions\n  // to the requestInstance\n  function Resolver(resolve, reject) {\n    this._resolve = resolve;\n    this._reject = reject;\n  }\n\n  return promiseFactoryFn(Resolver.bind(requestInstance));\n}\n\nfunction Request(url, options, f, retryConfig) {\n  // ('url')\n  if(_.isString(url)){\n    // ('url', f)\n    if(_.isFunction(options)){\n      f = options;\n    }\n\n    if(!_.isObject(options)){\n      options = {};\n    }\n\n    // ('url', {object})\n    options.url = url;\n  }\n\n  if(_.isObject(url)){\n    if(_.isFunction(options)){\n      f = options;\n    }\n    options = url;\n  }\n\n  this.maxAttempts = retryConfig.maxAttempts;\n  this.retryDelay = retryConfig.retryDelay;\n  this.fullResponse = retryConfig.fullResponse;\n  this.attempts = 0;\n\n  /**\n   * Option object\n   * @type {Object}\n   */\n  this.options = options;\n\n  /**\n   * Return true if the request should be retried\n   * @type {Function} (err, response, body, options) -> [Boolean, Object (optional)]\n   */\n  this.retryStrategy = _.isFunction(options.retryStrategy) ? options.retryStrategy : RetryStrategies.HTTPOrNetworkError;\n\n  /**\n   * Return a number representing how long request-retry should wait before trying again the request\n   * @type {Boolean} (err, response, body) -> Number\n   */\n  this.delayStrategy = _.isFunction(options.delayStrategy) ? options.delayStrategy : function() { return this.retryDelay; };\n\n  this._timeout = null;\n  this._req = null;\n\n  this._callback = _.isFunction(f) ? _.once(f) : null;\n\n  // create the promise only when no callback was provided\n  if (!this._callback) {\n    this._promise = makePromise(this, retryConfig.promiseFactory);\n  }\n\n  this.reply = function requestRetryReply(err, response, body) {\n    if (this._callback) {\n      return this._callback(err, response, body);\n    }\n\n    if (err) {\n      return this._reject(err);\n    }\n\n    // resolve with the full response or just the body\n    response = this.fullResponse ? response : body;\n    this._resolve(response);\n  };\n}\n\nRequest.request = request;\n\nRequest.prototype._tryUntilFail = function () {\n  this.maxAttempts--;\n  this.attempts++;\n\n  this._req = Request.request(this.options, async function (err, response, body) {\n    if (response) {\n      response.attempts = this.attempts;\n    }\n\n    if (err) {\n      err.attempts = this.attempts;\n    }\n\n    var mustRetry = await Promise.resolve(this.retryStrategy(err, response, body, _cloneOptions(this.options)));\n    if (_.isObject(mustRetry) && _.has(mustRetry, 'mustRetry')) {\n      if (_.isObject(mustRetry.options)) {\n        this.options = mustRetry.options; //if retryStrategy supposes different request options for retry\n      }\n      mustRetry = mustRetry.mustRetry;\n    }\n\n    if (mustRetry && this.maxAttempts > 0) {\n      this._timeout = setTimeout(this._tryUntilFail.bind(this), this.delayStrategy.call(this, err, response, body));\n      return;\n    }\n\n    this.reply(err, response, body);\n  }.bind(this));\n};\n\nRequest.prototype.abort = function () {\n  if (this._req) {\n    this._req.abort();\n  }\n  clearTimeout(this._timeout);\n  this.reply(new Error('Aborted'));\n};\n\n// expose request methods from RequestRetry\n['end', 'on', 'emit', 'once', 'setMaxListeners', 'start', 'removeListener', 'pipe', 'write', 'auth'].forEach(function (requestMethod) {\n  Request.prototype[requestMethod] = function exposedRequestMethod () {\n    return this._req[requestMethod].apply(this._req, arguments);\n  };\n});\n\n// expose promise methods\n['then', 'catch', 'finally', 'fail', 'done'].forEach(function (promiseMethod) {\n  Request.prototype[promiseMethod] = function exposedPromiseMethod () {\n    if (this._callback) {\n      throw new Error('A callback was provided but waiting a promise, use only one pattern');\n    }\n    return this._promise[promiseMethod].apply(this._promise, arguments);\n  };\n});\n\nfunction Factory(url, options, f) {\n  var retryConfig = _.chain(_.isObject(url) ? url : options || {}).defaults(DEFAULTS).pick(Object.keys(DEFAULTS)).value();\n  var req = new Factory.Request(url, options, f, retryConfig);\n  req._tryUntilFail();\n  return req;\n}\n\n// adds a helper for HTTP method `verb` to object `obj`\nfunction makeHelper(obj, verb) {\n  obj[verb] = function helper(url, options, f) {\n    // ('url')\n    if(_.isString(url)){\n      // ('url', f)\n      if(_.isFunction(options)){\n        f = options;\n      }\n\n      if(!_.isObject(options)){\n        options = {};\n      }\n\n      // ('url', {object})\n      options.url = url;\n    }\n\n    if(_.isObject(url)){\n      if(_.isFunction(options)){\n        f = options;\n      }\n      options = url;\n    }\n\n    options.method = verb.toUpperCase();\n    return obj(options, f);\n  };\n}\n\nfunction defaults(defaultOptions, defaultF) {\n  var factory = function (options, f) {\n    if (typeof options === \"string\") {\n      options = { uri: options };\n    }\n    return Factory.apply(null, [ extend(true, {}, defaultOptions, options), f || defaultF ]);\n  };\n\n  factory.defaults = function (newDefaultOptions, newDefaultF) {\n    return defaults.apply(null, [ extend(true, {}, defaultOptions, newDefaultOptions), newDefaultF || defaultF ]);\n  };\n\n  factory.Request = Request;\n  factory.RetryStrategies = RetryStrategies;\n\n  ['get', 'head', 'post', 'put', 'patch', 'delete'].forEach(function (verb) {\n    makeHelper(factory, verb);\n  });\n  factory.del = factory['delete'];\n\n  ['jar', 'cookie'].forEach(function (method) {\n    factory[method] = factory.Request.request[method];\n  });\n\n  return factory;\n}\n\nmodule.exports = Factory;\n\nFactory.defaults = defaults;\nFactory.Request = Request;\nFactory.RetryStrategies = RetryStrategies;\n\n// define .get/.post/... helpers\n['get', 'head', 'post', 'put', 'patch', 'delete'].forEach(function (verb) {\n  makeHelper(Factory, verb);\n});\nFactory.del = Factory['delete'];\n\n['jar', 'cookie'].forEach(function (method) {\n  Factory[method] = Factory.Request.request[method];\n});\n"], "fixing_code": ["'use strict';\n\n/*\n * Request\n *\n * Copyright(c) 2014 Francois-Guillaume Ribreau <npm@fgribreau.com>\n * MIT Licensed\n *\n */\nvar extend = require('extend');\nvar request = require('request');\nvar RetryStrategies = require('./strategies');\nvar _ = require('lodash');\nvar url = require('url');\nvar querystring = require(\"querystring\");\n\nvar DEFAULTS = {\n  maxAttempts: 5, // try 5 times\n  retryDelay: 5000, // wait for 5s before trying again\n  fullResponse: true, // resolve promise with the full response object\n  promiseFactory: defaultPromiseFactory // Function to use a different promise implementation library\n};\n\n// Default promise factory which use bluebird\nfunction defaultPromiseFactory(resolver) {\n  return new Promise(resolver);\n}\n\n// Prevent Cookie & Authorization Headers from being forwarded \n// when the URL redirects to another domain (information leak) #137 \nfunction sanitizeHeaders(options) {\n  \n  const HEADERS_TO_IGNORE = [\"cookie\", \"authorization\"];\n\n  const urlObject = url.parse(options.url)\n  const queryObject = querystring.parse(urlObject.query);\n  \n  const hasExternalLink = Object.keys(queryObject).reduce(function(acc, cur) {\n    \n    let qUrl = url.parse(queryObject[cur]);\n\n    // external link if protocol || host || port is different\n    if(!!qUrl.host && (qUrl.protocol !== urlObject.protocol || qUrl.host !== urlObject.host || qUrl.port !== urlObject.port) ) {\n      acc = true;\n    }\n    \n    return acc;\n\n  }, false);\n\n  if (hasExternalLink && options.hasOwnProperty(\"headers\") && typeof(options.headers) === \"object\") {\n    \n    // if External Link: remove Cookie and Authorization from Headers\n    Object.keys(options.headers).filter(function(key) {\n      return HEADERS_TO_IGNORE.includes(key.toLowerCase())\n    }).map(function(key) {\n      return delete options.headers[key]\n    });\n\n  }\n\n  return options;\n}\n\nfunction _cloneOptions(options) {\n  const cloned = {};\n  for (let key in options) {\n    if (options.hasOwnProperty(key)) {\n      cloned[key] = key === 'agent' ? options[key] : _.cloneDeep(options[key]);\n    }\n  }\n  return cloned;\n}\n\n/**\n * It calls the promiseFactory function passing it the resolver for the promise\n *\n * @param {Object} requestInstance - The Request Retry instance\n * @param {Function} promiseFactoryFn - The Request Retry instance\n * @return {Object} - The promise instance\n */\nfunction makePromise(requestInstance, promiseFactoryFn) {\n\n  // Resolver function wich assigns the promise (resolve, reject) functions\n  // to the requestInstance\n  function Resolver(resolve, reject) {\n    this._resolve = resolve;\n    this._reject = reject;\n  }\n\n  return promiseFactoryFn(Resolver.bind(requestInstance));\n}\n\nfunction Request(url, options, f, retryConfig) {\n  // ('url')\n  if(_.isString(url)){\n    // ('url', f)\n    if(_.isFunction(options)){\n      f = options;\n    }\n\n    if(!_.isObject(options)){\n      options = {};\n    }\n\n    // ('url', {object})\n    options.url = url;\n  }\n\n  if(_.isObject(url)){\n    if(_.isFunction(options)){\n      f = options;\n    }\n    options = url;\n  }\n\n  this.maxAttempts = retryConfig.maxAttempts;\n  this.retryDelay = retryConfig.retryDelay;\n  this.fullResponse = retryConfig.fullResponse;\n  this.attempts = 0;\n\n  /**\n   * Option object\n   * @type {Object}\n   */\n  this.options = sanitizeHeaders(options);\n\n  /**\n   * Return true if the request should be retried\n   * @type {Function} (err, response, body, options) -> [Boolean, Object (optional)]\n   */\n  this.retryStrategy = _.isFunction(options.retryStrategy) ? options.retryStrategy : RetryStrategies.HTTPOrNetworkError;\n\n  /**\n   * Return a number representing how long request-retry should wait before trying again the request\n   * @type {Boolean} (err, response, body) -> Number\n   */\n  this.delayStrategy = _.isFunction(options.delayStrategy) ? options.delayStrategy : function() { return this.retryDelay; };\n\n  this._timeout = null;\n  this._req = null;\n\n  this._callback = _.isFunction(f) ? _.once(f) : null;\n\n  // create the promise only when no callback was provided\n  if (!this._callback) {\n    this._promise = makePromise(this, retryConfig.promiseFactory);\n  }\n\n  this.reply = function requestRetryReply(err, response, body) {\n    if (this._callback) {\n      return this._callback(err, response, body);\n    }\n\n    if (err) {\n      return this._reject(err);\n    }\n\n    // resolve with the full response or just the body\n    response = this.fullResponse ? response : body;\n    this._resolve(response);\n  };\n}\n\nRequest.request = request;\n\nRequest.prototype._tryUntilFail = function () {\n  this.maxAttempts--;\n  this.attempts++;\n\n  this._req = Request.request(this.options, async function (err, response, body) {\n    if (response) {\n      response.attempts = this.attempts;\n    }\n\n    if (err) {\n      err.attempts = this.attempts;\n    }\n\n    var mustRetry = await Promise.resolve(this.retryStrategy(err, response, body, _cloneOptions(this.options)));\n    if (_.isObject(mustRetry) && _.has(mustRetry, 'mustRetry')) {\n      if (_.isObject(mustRetry.options)) {\n        this.options = mustRetry.options; //if retryStrategy supposes different request options for retry\n      }\n      mustRetry = mustRetry.mustRetry;\n    }\n\n    if (mustRetry && this.maxAttempts > 0) {\n      this._timeout = setTimeout(this._tryUntilFail.bind(this), this.delayStrategy.call(this, err, response, body));\n      return;\n    }\n\n    this.reply(err, response, body);\n  }.bind(this));\n};\n\nRequest.prototype.abort = function () {\n  if (this._req) {\n    this._req.abort();\n  }\n  clearTimeout(this._timeout);\n  this.reply(new Error('Aborted'));\n};\n\n// expose request methods from RequestRetry\n['end', 'on', 'emit', 'once', 'setMaxListeners', 'start', 'removeListener', 'pipe', 'write', 'auth'].forEach(function (requestMethod) {\n  Request.prototype[requestMethod] = function exposedRequestMethod () {\n    return this._req[requestMethod].apply(this._req, arguments);\n  };\n});\n\n// expose promise methods\n['then', 'catch', 'finally', 'fail', 'done'].forEach(function (promiseMethod) {\n  Request.prototype[promiseMethod] = function exposedPromiseMethod () {\n    if (this._callback) {\n      throw new Error('A callback was provided but waiting a promise, use only one pattern');\n    }\n    return this._promise[promiseMethod].apply(this._promise, arguments);\n  };\n});\n\nfunction Factory(url, options, f) {\n  var retryConfig = _.chain(_.isObject(url) ? url : options || {}).defaults(DEFAULTS).pick(Object.keys(DEFAULTS)).value();\n  var req = new Factory.Request(url, options, f, retryConfig);\n  req._tryUntilFail();\n  return req;\n}\n\n// adds a helper for HTTP method `verb` to object `obj`\nfunction makeHelper(obj, verb) {\n  obj[verb] = function helper(url, options, f) {\n    // ('url')\n    if(_.isString(url)){\n      // ('url', f)\n      if(_.isFunction(options)){\n        f = options;\n      }\n\n      if(!_.isObject(options)){\n        options = {};\n      }\n\n      // ('url', {object})\n      options.url = url;\n    }\n\n    if(_.isObject(url)){\n      if(_.isFunction(options)){\n        f = options;\n      }\n      options = url;\n    }\n\n    options.method = verb.toUpperCase();\n    return obj(options, f);\n  };\n}\n\nfunction defaults(defaultOptions, defaultF) {\n  var factory = function (options, f) {\n    if (typeof options === \"string\") {\n      options = { uri: options };\n    }\n    return Factory.apply(null, [ extend(true, {}, defaultOptions, options), f || defaultF ]);\n  };\n\n  factory.defaults = function (newDefaultOptions, newDefaultF) {\n    return defaults.apply(null, [ extend(true, {}, defaultOptions, newDefaultOptions), newDefaultF || defaultF ]);\n  };\n\n  factory.Request = Request;\n  factory.RetryStrategies = RetryStrategies;\n\n  ['get', 'head', 'post', 'put', 'patch', 'delete'].forEach(function (verb) {\n    makeHelper(factory, verb);\n  });\n  factory.del = factory['delete'];\n\n  ['jar', 'cookie'].forEach(function (method) {\n    factory[method] = factory.Request.request[method];\n  });\n\n  return factory;\n}\n\nmodule.exports = Factory;\n\nFactory.defaults = defaults;\nFactory.Request = Request;\nFactory.RetryStrategies = RetryStrategies;\n\n// define .get/.post/... helpers\n['get', 'head', 'post', 'put', 'patch', 'delete'].forEach(function (verb) {\n  makeHelper(Factory, verb);\n});\nFactory.del = Factory['delete'];\n\n['jar', 'cookie'].forEach(function (method) {\n  Factory[method] = Factory.Request.request[method];\n});\n"], "filenames": ["index.js"], "buggy_code_start_loc": [13], "buggy_code_end_loc": [89], "fixing_code_start_loc": [14], "fixing_code_end_loc": [127], "type": "NVD-CWE-noinfo", "message": "Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository fgribreau/node-request-retry prior to 7.0.0.", "other": {"cve": {"id": "CVE-2022-0654", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-23T00:15:07.587", "lastModified": "2022-03-02T03:16:11.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository fgribreau/node-request-retry prior to 7.0.0."}, {"lang": "es", "value": "Una Exposici\u00f3n de Informaci\u00f3n Confidencial a un Actor no Autorizado en el repositorio de GitHub fgribreau/node-request-retry versiones anteriores a 7.0.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:node-request-retry_project:node-request-retry:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "7.0.0", "matchCriteriaId": "2FD9D3CC-6C8D-48AA-B657-2B28DCAD32A8"}]}]}], "references": [{"url": "https://github.com/fgribreau/node-request-retry/commit/0979c6001d9d57c2aac3157c11b007397158922a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a779faf5-c2cc-48be-a31d-4ddfac357afc", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fgribreau/node-request-retry/commit/0979c6001d9d57c2aac3157c11b007397158922a"}}