{"buggy_code": ["var Utils = require(\"./util\");\nvar fs = Utils.FileSystem.require(),\n    pth = require(\"path\");\n\nfs.existsSync = fs.existsSync || pth.existsSync;\n\nvar ZipEntry = require(\"./zipEntry\"),\n    ZipFile =  require(\"./zipFile\");\n\nvar isWin = /^win/.test(process.platform);\n\n\nmodule.exports = function(/*String*/input) {\n    var _zip = undefined,\n        _filename = \"\";\n\n    if (input && typeof input === \"string\") { // load zip file\n        if (fs.existsSync(input)) {\n            _filename = input;\n            _zip = new ZipFile(input, Utils.Constants.FILE);\n        } else {\n           throw Utils.Errors.INVALID_FILENAME;\n        }\n    } else if(input && Buffer.isBuffer(input)) { // load buffer\n        _zip = new ZipFile(input, Utils.Constants.BUFFER);\n    } else { // create new zip file\n        _zip = new ZipFile(null, Utils.Constants.NONE);\n    }\n\n    function escapeFileName(/*String*/filename){\n        return filename.replace(/[\\:,\\/,\\>,\\<,\\\",\\\\,\\|,\\?,\\*\"]/g, '_');\n    }\n\n\n    function getEntry(/*Object*/entry) {\n        if (entry && _zip) {\n            var item;\n            // If entry was given as a file name\n            if (typeof entry === \"string\")\n                item = _zip.getEntry(entry);\n            // if entry was given as a ZipEntry object\n            if (typeof entry === \"object\" && entry.entryName != undefined && entry.header != undefined)\n                item =  _zip.getEntry(entry.entryName);\n\n            if (item) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    return {\n        /**\n         * Extracts the given entry from the archive and returns the content as a Buffer object\n         * @param entry ZipEntry object or String with the full path of the entry\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFile : function(/*Object*/entry) {\n            var item = getEntry(entry);\n            return item && item.getData() || null;\n        },\n\n        /**\n         * Asynchronous readFile\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFileAsync : function(/*Object*/entry, /*Function*/callback) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(callback);\n            } else {\n                callback(null,\"getEntry failed for:\" + entry)\n            }\n        },\n\n        /**\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsText : function(/*Object*/entry, /*String - Optional*/encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                var data = item.getData();\n                if (data && data.length) {\n                    return data.toString(encoding || \"utf8\");\n                }\n            }\n            return \"\";\n        },\n\n        /**\n         * Asynchronous readAsText\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsTextAsync : function(/*Object*/entry, /*Function*/callback, /*String - Optional*/encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(function(data) {\n                    if (data && data.length) {\n                        callback(data.toString(encoding || \"utf8\"));\n                    } else {\n                        callback(\"\");\n                    }\n                })\n            } else {\n                callback(\"\");\n            }\n        },\n\n        /**\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n         *\n         * @param entry\n         */\n        deleteFile : function(/*Object*/entry) { // @TODO: test deleteFile\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteEntry(item.entryName);\n            }\n        },\n\n        /**\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n         *\n         * @param comment\n         */\n        addZipComment : function(/*String*/comment) { // @TODO: test addZipComment\n            _zip.comment = comment;\n        },\n\n        /**\n         * Returns the zip comment\n         *\n         * @return String\n         */\n        getZipComment : function() {\n            return _zip.comment || '';\n        },\n\n        /**\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n         * The comment cannot exceed 65535 characters in length\n         *\n         * @param entry\n         * @param comment\n         */\n        addZipEntryComment : function(/*Object*/entry,/*String*/comment) {\n            var item = getEntry(entry);\n            if (item) {\n                item.comment = comment;\n            }\n        },\n\n        /**\n         * Returns the comment of the specified entry\n         *\n         * @param entry\n         * @return String\n         */\n        getZipEntryComment : function(/*Object*/entry) {\n            var item = getEntry(entry);\n            if (item) {\n                return item.comment || '';\n            }\n            return ''\n        },\n\n        /**\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n         *\n         * @param entry\n         * @param content\n         */\n        updateFile : function(/*Object*/entry, /*Buffer*/content) {\n            var item = getEntry(entry);\n            if (item) {\n                item.setData(content);\n            }\n        },\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param localPath\n         */\n        addLocalFile : function(/*String*/localPath, /*String*/zipPath, /*String*/zipName) {\n             if (fs.existsSync(localPath)) {\n                if(zipPath){\n                    zipPath=zipPath.split(\"\\\\\").join(\"/\");\n                    if(zipPath.charAt(zipPath.length - 1) != \"/\"){\n                        zipPath += \"/\";\n                    }\n                }else{\n                    zipPath=\"\";\n                }\n                 var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n\n                 if(zipName){\n                    this.addFile(zipPath+zipName, fs.readFileSync(localPath), \"\", 0)\n                 }else{\n                    this.addFile(zipPath+p, fs.readFileSync(localPath), \"\", 0)\n                 }\n             } else {\n                 throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\n             }\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param localPath\n         * @param zipPath optional path inside zip\n         * @param filter optional RegExp or Function if files match will\n         *               be included.\n         */\n        addLocalFolder : function(/*String*/localPath, /*String*/zipPath, /*RegExp|Function*/filter) {\n            if (filter === undefined) {\n              filter = function() { return true; };\n            } else if (filter instanceof RegExp) {\n              filter = function(filter) {\n                return function(filename) {\n                  return filter.test(filename);\n                }\n              }(filter);\n            }\n\n            if(zipPath){\n                zipPath=zipPath.split(\"\\\\\").join(\"/\");\n                if(zipPath.charAt(zipPath.length - 1) != \"/\"){\n                    zipPath += \"/\";\n                }\n            }else{\n                zipPath=\"\";\n            }\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\t    localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n            if (localPath.charAt(localPath.length - 1) != \"/\")\n                localPath += \"/\";\n\n            if (fs.existsSync(localPath)) {\n\n                var items = Utils.findFiles(localPath),\n                    self = this;\n\n                if (items.length) {\n                    items.forEach(function(path) {\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace( new RegExp(localPath.replace(/(\\(|\\))/g,'\\\\$1'), 'i'), \"\"); //windows fix\n                        if (filter(p)) {\n                            if (p.charAt(p.length - 1) !== \"/\") {\n                                self.addFile(zipPath+p, fs.readFileSync(path), \"\", 0)\n                            } else {\n                                self.addFile(zipPath+p, new Buffer(0), \"\", 0)\n                            }\n                        }\n                    });\n                }\n            } else {\n                throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\n            }\n        },\n\n        /**\n         * Allows you to create a entry (file or directory) in the zip file.\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n         * Comment and attributes are optional\n         *\n         * @param entryName\n         * @param content\n         * @param comment\n         * @param attr\n         */\n        addFile : function(/*String*/entryName, /*Buffer*/content, /*String*/comment, /*Number*/attr) {\n            var entry = new ZipEntry();\n            entry.entryName = entryName;\n            entry.comment = comment || \"\";\n\n            if (!attr) {\n                if (entry.isDirectory) {\n                    attr = (040755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\n                } else {\n                    attr = 0644 << 16; // permissions -r-wr--r--\n                }\n            }\n\n            entry.attr = attr;\n\n            entry.setData(content);\n            _zip.setEntry(entry);\n        },\n\n        /**\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n         *\n         * @return Array\n         */\n        getEntries : function() {\n            if (_zip) {\n               return _zip.entries;\n            } else {\n                return [];\n            }\n        },\n\n        /**\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n         *\n         * @param name\n         * @return ZipEntry\n         */\n        getEntry : function(/*String*/name) {\n            return getEntry(name);\n        },\n\n        /**\n         * Extracts the given entry to the given targetPath\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n         *\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param targetPath Target folder where to write the file\n         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\n         *                          will be created in targetPath as well. Default is TRUE\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         *\n         * @return Boolean\n         */\n        extractEntryTo : function(/*Object*/entry, /*String*/targetPath, /*Boolean*/maintainEntryPath, /*Boolean*/overwrite) {\n            overwrite = overwrite || false;\n            maintainEntryPath = typeof maintainEntryPath == \"undefined\" ? true : maintainEntryPath;\n\n            var item = getEntry(entry);\n            if (!item) {\n                throw Utils.Errors.NO_ENTRY;\n            }\n\n            var entryName = item.entryName;\n\n            if(isWin){\n                entryName = escapeFileName(entryName)\n            }\n\n\n\n            var target = pth.resolve(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\n\n            if (item.isDirectory) {\n                target = pth.resolve(target, \"..\");\n                var children = _zip.getEntryChildren(item);\n                children.forEach(function(child) {\n                    if (child.isDirectory) return;\n                    var content = child.getData();\n                    if (!content) {\n                        throw Utils.Errors.CANT_EXTRACT_FILE;\n                    }\n\n                    childName = child.entryName;\n\n                    if(isWin){\n                        childName = escapeFileName(childName)\n                    }\n\n                    Utils.writeFileTo(pth.resolve(targetPath, maintainEntryPath ? childName : childName.substr(entryName.length)), content, overwrite);\n                });\n                return true;\n            }\n\n            var content = item.getData();\n            if (!content) throw Utils.Errors.CANT_EXTRACT_FILE;\n\n            if (fs.existsSync(target) && !overwrite) {\n                throw Utils.Errors.CANT_OVERRIDE;\n            }\n            Utils.writeFileTo(target, content, overwrite);\n\n            return true;\n        },\n\n        /**\n         * Test the archive\n         *\n         */\n        test : function() {\n            if (!_zip) {\n                return false;\n            }\n\n            for(var entry in _zip.entries) {\n                try{\n                    if (entry.isDirectory) {\n                        continue;\n                    }\n                    var content = _zip.entries[entry].getData();\n                    if (!content) {\n                        return false;\n                    }\n                } catch (err) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Extracts the entire archive to the given location\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         */\n        extractAllTo : function(/*String*/targetPath, /*Boolean*/overwrite) {\n            overwrite = overwrite || false;\n            if (!_zip) {\n                throw Utils.Errors.NO_ZIP;\n            }\n\n\n            _zip.entries.forEach(function(entry) {\n                entryName = entry.entryName.toString();\n\n                if(isWin){\n                    entryName = escapeFileName(entryName)\n                }\n\n                if (entry.isDirectory) {\n                    Utils.makeDir(pth.resolve(targetPath, entryName));\n                    return;\n                }\n                var content = entry.getData();\n                if (!content) {\n                    throw Utils.Errors.CANT_EXTRACT_FILE + \"2\";\n                }\n                Utils.writeFileTo(pth.resolve(targetPath, entryName), content, overwrite);\n            })\n        },\n\n        /**\n         * Asynchronous extractAllTo\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param callback\n         */\n        extractAllToAsync : function(/*String*/targetPath, /*Boolean*/overwrite, /*Function*/callback) {\n            overwrite = overwrite || false;\n            if (!_zip) {\n                callback(new Error(Utils.Errors.NO_ZIP));\n                return;\n            }\n\n            var entries = _zip.entries;\n            var i = entries.length;\n            entries.forEach(function(entry) {\n                if(i <= 0) return; // Had an error already\n\n                entryName = entry.entryName.toString();\n\n                if(isWin){\n                    entryName = escapeFileName(entryName)\n                }\n\n                if (entry.isDirectory) {\n                    Utils.makeDir(pth.resolve(targetPath, entryName));\n                    if(--i == 0)\n                        callback(undefined);\n                    return;\n                }\n                entry.getDataAsync(function(content) {\n                    if(i <= 0) return;\n                    if (!content) {\n                        i = 0;\n                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE + \"2\"));\n                        return;\n                    }\n\n                    Utils.writeFileToAsync(pth.resolve(targetPath, entryName), content, overwrite, function(succ) {\n                        if(i <= 0) return;\n\n                        if(!succ) {\n                            i = 0;\n                            callback(new Error('Unable to write'));\n                            return;\n                        }\n\n                        if(--i == 0)\n                            callback(undefined);\n                    });\n\n                });\n            })\n        },\n\n        /**\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n         *\n         * @param targetFileName\n         * @param callback\n         */\n        writeZip : function(/*String*/targetFileName, /*Function*/callback) {\n            if (arguments.length == 1) {\n                if (typeof targetFileName == \"function\") {\n                    callback = targetFileName;\n                    targetFileName = \"\";\n                }\n            }\n\n            if (!targetFileName && _filename) {\n                targetFileName = _filename;\n            }\n            if (!targetFileName) return;\n\n            var zipData = _zip.compressToBuffer();\n            if (zipData) {\n                var ok = Utils.writeFileTo(targetFileName, zipData, true);\n                if (typeof callback == 'function') callback(!ok? new Error(\"failed\"): null, \"\");\n            }\n        },\n\n        /**\n         * Returns the content of the entire zip file as a Buffer object\n         *\n         * @return Buffer\n         */\n        toBuffer : function(/*Function*/onSuccess,/*Function*/onFail,/*Function*/onItemStart,/*Function*/onItemEnd) {\n            this.valueOf = 2;\n            if (typeof onSuccess == \"function\") {\n                _zip.toAsyncBuffer(onSuccess,onFail,onItemStart,onItemEnd);\n                return null;\n            }\n            return _zip.compressToBuffer()\n        }\n    }\n};\n"], "fixing_code": ["var Utils = require(\"./util\");\nvar fs = Utils.FileSystem.require(),\n    pth = require(\"path\");\n\nfs.existsSync = fs.existsSync || pth.existsSync;\n\nvar ZipEntry = require(\"./zipEntry\"),\n    ZipFile =  require(\"./zipFile\");\n\nvar isWin = /^win/.test(process.platform);\n\n\nmodule.exports = function(/*String*/input) {\n    var _zip = undefined,\n        _filename = \"\";\n\n    if (input && typeof input === \"string\") { // load zip file\n        if (fs.existsSync(input)) {\n            _filename = input;\n            _zip = new ZipFile(input, Utils.Constants.FILE);\n        } else {\n           throw Utils.Errors.INVALID_FILENAME;\n        }\n    } else if(input && Buffer.isBuffer(input)) { // load buffer\n        _zip = new ZipFile(input, Utils.Constants.BUFFER);\n    } else { // create new zip file\n        _zip = new ZipFile(null, Utils.Constants.NONE);\n    }\n\n    function escapeFileName(/*String*/filename){\n        return filename.replace(/[\\:,\\/,\\>,\\<,\\\",\\\\,\\|,\\?,\\*\"]/g, '_');\n    }\n\n\n    function getEntry(/*Object*/entry) {\n        if (entry && _zip) {\n            var item;\n            // If entry was given as a file name\n            if (typeof entry === \"string\")\n                item = _zip.getEntry(entry);\n            // if entry was given as a ZipEntry object\n            if (typeof entry === \"object\" && entry.entryName != undefined && entry.header != undefined)\n                item =  _zip.getEntry(entry.entryName);\n\n            if (item) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    return {\n        /**\n         * Extracts the given entry from the archive and returns the content as a Buffer object\n         * @param entry ZipEntry object or String with the full path of the entry\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFile : function(/*Object*/entry) {\n            var item = getEntry(entry);\n            return item && item.getData() || null;\n        },\n\n        /**\n         * Asynchronous readFile\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFileAsync : function(/*Object*/entry, /*Function*/callback) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(callback);\n            } else {\n                callback(null,\"getEntry failed for:\" + entry)\n            }\n        },\n\n        /**\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsText : function(/*Object*/entry, /*String - Optional*/encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                var data = item.getData();\n                if (data && data.length) {\n                    return data.toString(encoding || \"utf8\");\n                }\n            }\n            return \"\";\n        },\n\n        /**\n         * Asynchronous readAsText\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsTextAsync : function(/*Object*/entry, /*Function*/callback, /*String - Optional*/encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(function(data) {\n                    if (data && data.length) {\n                        callback(data.toString(encoding || \"utf8\"));\n                    } else {\n                        callback(\"\");\n                    }\n                })\n            } else {\n                callback(\"\");\n            }\n        },\n\n        /**\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n         *\n         * @param entry\n         */\n        deleteFile : function(/*Object*/entry) { // @TODO: test deleteFile\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteEntry(item.entryName);\n            }\n        },\n\n        /**\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n         *\n         * @param comment\n         */\n        addZipComment : function(/*String*/comment) { // @TODO: test addZipComment\n            _zip.comment = comment;\n        },\n\n        /**\n         * Returns the zip comment\n         *\n         * @return String\n         */\n        getZipComment : function() {\n            return _zip.comment || '';\n        },\n\n        /**\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n         * The comment cannot exceed 65535 characters in length\n         *\n         * @param entry\n         * @param comment\n         */\n        addZipEntryComment : function(/*Object*/entry,/*String*/comment) {\n            var item = getEntry(entry);\n            if (item) {\n                item.comment = comment;\n            }\n        },\n\n        /**\n         * Returns the comment of the specified entry\n         *\n         * @param entry\n         * @return String\n         */\n        getZipEntryComment : function(/*Object*/entry) {\n            var item = getEntry(entry);\n            if (item) {\n                return item.comment || '';\n            }\n            return ''\n        },\n\n        /**\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n         *\n         * @param entry\n         * @param content\n         */\n        updateFile : function(/*Object*/entry, /*Buffer*/content) {\n            var item = getEntry(entry);\n            if (item) {\n                item.setData(content);\n            }\n        },\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param localPath\n         */\n        addLocalFile : function(/*String*/localPath, /*String*/zipPath, /*String*/zipName) {\n             if (fs.existsSync(localPath)) {\n                if(zipPath){\n                    zipPath=zipPath.split(\"\\\\\").join(\"/\");\n                    if(zipPath.charAt(zipPath.length - 1) != \"/\"){\n                        zipPath += \"/\";\n                    }\n                }else{\n                    zipPath=\"\";\n                }\n                 var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n\n                 if(zipName){\n                    this.addFile(zipPath+zipName, fs.readFileSync(localPath), \"\", 0)\n                 }else{\n                    this.addFile(zipPath+p, fs.readFileSync(localPath), \"\", 0)\n                 }\n             } else {\n                 throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\n             }\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param localPath\n         * @param zipPath optional path inside zip\n         * @param filter optional RegExp or Function if files match will\n         *               be included.\n         */\n        addLocalFolder : function(/*String*/localPath, /*String*/zipPath, /*RegExp|Function*/filter) {\n            if (filter === undefined) {\n              filter = function() { return true; };\n            } else if (filter instanceof RegExp) {\n              filter = function(filter) {\n                return function(filename) {\n                  return filter.test(filename);\n                }\n              }(filter);\n            }\n\n            if(zipPath){\n                zipPath=zipPath.split(\"\\\\\").join(\"/\");\n                if(zipPath.charAt(zipPath.length - 1) != \"/\"){\n                    zipPath += \"/\";\n                }\n            }else{\n                zipPath=\"\";\n            }\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\t    localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n            if (localPath.charAt(localPath.length - 1) != \"/\")\n                localPath += \"/\";\n\n            if (fs.existsSync(localPath)) {\n\n                var items = Utils.findFiles(localPath),\n                    self = this;\n\n                if (items.length) {\n                    items.forEach(function(path) {\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace( new RegExp(localPath.replace(/(\\(|\\))/g,'\\\\$1'), 'i'), \"\"); //windows fix\n                        if (filter(p)) {\n                            if (p.charAt(p.length - 1) !== \"/\") {\n                                self.addFile(zipPath+p, fs.readFileSync(path), \"\", 0)\n                            } else {\n                                self.addFile(zipPath+p, new Buffer(0), \"\", 0)\n                            }\n                        }\n                    });\n                }\n            } else {\n                throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\n            }\n        },\n\n        /**\n         * Allows you to create a entry (file or directory) in the zip file.\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n         * Comment and attributes are optional\n         *\n         * @param entryName\n         * @param content\n         * @param comment\n         * @param attr\n         */\n        addFile : function(/*String*/entryName, /*Buffer*/content, /*String*/comment, /*Number*/attr) {\n            var entry = new ZipEntry();\n            entry.entryName = entryName;\n            entry.comment = comment || \"\";\n\n            if (!attr) {\n                if (entry.isDirectory) {\n                    attr = (040755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\n                } else {\n                    attr = 0644 << 16; // permissions -r-wr--r--\n                }\n            }\n\n            entry.attr = attr;\n\n            entry.setData(content);\n            _zip.setEntry(entry);\n        },\n\n        /**\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n         *\n         * @return Array\n         */\n        getEntries : function() {\n            if (_zip) {\n               return _zip.entries;\n            } else {\n                return [];\n            }\n        },\n\n        /**\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n         *\n         * @param name\n         * @return ZipEntry\n         */\n        getEntry : function(/*String*/name) {\n            return getEntry(name);\n        },\n\n        /**\n         * Extracts the given entry to the given targetPath\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n         *\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param targetPath Target folder where to write the file\n         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\n         *                          will be created in targetPath as well. Default is TRUE\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         *\n         * @return Boolean\n         */\n        extractEntryTo : function(/*Object*/entry, /*String*/targetPath, /*Boolean*/maintainEntryPath, /*Boolean*/overwrite) {\n            overwrite = overwrite || false;\n            maintainEntryPath = typeof maintainEntryPath == \"undefined\" ? true : maintainEntryPath;\n\n            var item = getEntry(entry);\n            if (!item) {\n                throw Utils.Errors.NO_ENTRY;\n            }\n\n            var entryName = item.entryName;\n\n            if(isWin){\n                entryName = escapeFileName(entryName)\n            }\n\n\n\n            var target = pth.resolve(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\n            if(!target.startsWith(targetPath)) {\n                throw Utils.Errors.INVALID_FILENAME + \": \" + entryName;\n            }\n\n            if (item.isDirectory) {\n                target = pth.resolve(target, \"..\");\n                var children = _zip.getEntryChildren(item);\n                children.forEach(function(child) {\n                    if (child.isDirectory) return;\n                    var content = child.getData();\n                    if (!content) {\n                        throw Utils.Errors.CANT_EXTRACT_FILE;\n                    }\n\n                    childName = child.entryName;\n\n                    if(isWin){\n                        childName = escapeFileName(childName)\n                    }\n\n                    Utils.writeFileTo(pth.resolve(targetPath, maintainEntryPath ? childName : childName.substr(entryName.length)), content, overwrite);\n                });\n                return true;\n            }\n\n            var content = item.getData();\n            if (!content) throw Utils.Errors.CANT_EXTRACT_FILE;\n\n            if (fs.existsSync(target) && !overwrite) {\n                throw Utils.Errors.CANT_OVERRIDE;\n            }\n            Utils.writeFileTo(target, content, overwrite);\n\n            return true;\n        },\n\n        /**\n         * Test the archive\n         *\n         */\n        test : function() {\n            if (!_zip) {\n                return false;\n            }\n\n            for(var entry in _zip.entries) {\n                try{\n                    if (entry.isDirectory) {\n                        continue;\n                    }\n                    var content = _zip.entries[entry].getData();\n                    if (!content) {\n                        return false;\n                    }\n                } catch (err) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Extracts the entire archive to the given location\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         */\n        extractAllTo : function(/*String*/targetPath, /*Boolean*/overwrite) {\n            overwrite = overwrite || false;\n            if (!_zip) {\n                throw Utils.Errors.NO_ZIP;\n            }\n\n\n            _zip.entries.forEach(function(entry) {\n                entryName = entry.entryName.toString();\n\n                if(!pth.resolve(targetPath, entryName).startsWith(targetPath)) {\n                    throw Utils.Errors.INVALID_FILENAME + \": \" + entryName;\n                }\n\n                if(isWin){\n                    entryName = escapeFileName(entryName)\n                }\n\n                if (entry.isDirectory) {\n                    Utils.makeDir(pth.resolve(targetPath, entryName));\n                    return;\n                }\n                var content = entry.getData();\n                if (!content) {\n                    throw Utils.Errors.CANT_EXTRACT_FILE + \"2\";\n                }\n                Utils.writeFileTo(pth.resolve(targetPath, entryName), content, overwrite);\n            })\n        },\n\n        /**\n         * Asynchronous extractAllTo\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param callback\n         */\n        extractAllToAsync : function(/*String*/targetPath, /*Boolean*/overwrite, /*Function*/callback) {\n            overwrite = overwrite || false;\n            if (!_zip) {\n                callback(new Error(Utils.Errors.NO_ZIP));\n                return;\n            }\n\n            var entries = _zip.entries;\n            var i = entries.length;\n            entries.forEach(function(entry) {\n                if(i <= 0) return; // Had an error already\n\n                entryName = entry.entryName.toString();\n\n                if(isWin){\n                    entryName = escapeFileName(entryName)\n                }\n\n                if(!pth.resolve(targetPath, entryName).startsWith(targetPath)) {\n                  throw Utils.Errors.INVALID_FILENAME + \": \" + entryName;\n                }\n\n                if (entry.isDirectory) {\n                    Utils.makeDir(pth.resolve(targetPath, entryName));\n                    if(--i == 0)\n                        callback(undefined);\n                    return;\n                }\n                entry.getDataAsync(function(content) {\n                    if(i <= 0) return;\n                    if (!content) {\n                        i = 0;\n                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE + \"2\"));\n                        return;\n                    }\n\n                    Utils.writeFileToAsync(pth.resolve(targetPath, entryName), content, overwrite, function(succ) {\n                        if(i <= 0) return;\n\n                        if(!succ) {\n                            i = 0;\n                            callback(new Error('Unable to write'));\n                            return;\n                        }\n\n                        if(--i == 0)\n                            callback(undefined);\n                    });\n\n                });\n            })\n        },\n\n        /**\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n         *\n         * @param targetFileName\n         * @param callback\n         */\n        writeZip : function(/*String*/targetFileName, /*Function*/callback) {\n            if (arguments.length == 1) {\n                if (typeof targetFileName == \"function\") {\n                    callback = targetFileName;\n                    targetFileName = \"\";\n                }\n            }\n\n            if (!targetFileName && _filename) {\n                targetFileName = _filename;\n            }\n            if (!targetFileName) return;\n\n            var zipData = _zip.compressToBuffer();\n            if (zipData) {\n                var ok = Utils.writeFileTo(targetFileName, zipData, true);\n                if (typeof callback == 'function') callback(!ok? new Error(\"failed\"): null, \"\");\n            }\n        },\n\n        /**\n         * Returns the content of the entire zip file as a Buffer object\n         *\n         * @return Buffer\n         */\n        toBuffer : function(/*Function*/onSuccess,/*Function*/onFail,/*Function*/onItemStart,/*Function*/onItemEnd) {\n            this.valueOf = 2;\n            if (typeof onSuccess == \"function\") {\n                _zip.toAsyncBuffer(onSuccess,onFail,onItemStart,onItemEnd);\n                return null;\n            }\n            return _zip.compressToBuffer()\n        }\n    }\n};\n"], "filenames": ["adm-zip.js"], "buggy_code_start_loc": [356], "buggy_code_end_loc": [471], "fixing_code_start_loc": [357], "fixing_code_end_loc": [483], "type": "CWE-22", "message": "adm-zip npm library before 0.4.9 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.", "other": {"cve": {"id": "CVE-2018-1002204", "sourceIdentifier": "report@snyk.io", "published": "2018-07-25T17:29:01.657", "lastModified": "2019-10-16T19:32:18.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "adm-zip npm library before 0.4.9 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'."}, {"lang": "es", "value": "La biblioteca adm-zip en versiones anteriores a la 0.4.9 es vulnerable a un salto de directorio, lo que permite que los atacantes escriban en archivos arbitrarios mediante un ../ (punto punto barra) en una entrada de archivo Zip que se gestiona de manera incorrecta durante la extracci\u00f3n. Esta vulnerabilidad tambi\u00e9n se conoce como \"Zip-Slip\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:adm-zip_project:adm-zip:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.4.9", "matchCriteriaId": "EA5F4447-2ED9-4006-A597-3C83E1E1DA1E"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/107001", "source": "report@snyk.io", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/cthackers/adm-zip/commit/62f64004fefb894c523a7143e8a88ebe6c84df25", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/cthackers/adm-zip/pull/212", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/snyk/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/research/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/npm:adm-zip:20180415", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cthackers/adm-zip/commit/62f64004fefb894c523a7143e8a88ebe6c84df25"}}