{"buggy_code": ["<?php\n\n/**\n * elFinder - file manager for web.\n * Core class.\n *\n * @package elfinder\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n **/\nclass elFinder {\n\t\n\t/**\n\t * API version number\n\t *\n\t * @var float\n\t **/\n\tprotected static $ApiVersion = 2.1;\n\t\n\t/**\n\t * API version number\n\t *\n\t * @deprecated\n\t * @var string\n\t **/\n\tprotected $version;\n\t\n\t/**\n\t * API revision that this connector supports all functions\n\t * \n\t * @var integer\n\t */\n\tprotected static $ApiRevision = 35;\n\t\n\t/**\n\t * Storages (root dirs)\n\t *\n\t * @var array\n\t **/\n\tprotected $volumes = array();\n\t\n\t/**\n\t * elFinder instance\n\t * \n\t * @var object\n\t */\n\tpublic static $instance = null;\n\t\n\t/**\n\t * Current request args\n\t *\n\t * @var array\n\t */\n\tpublic static $currentArgs = array();\n\t\n\t/**\n\t * Network mount drivers\n\t * \n\t * @var array\n\t */\n\tpublic static $netDrivers = array();\n\t\n\t/**\n\t * elFinder global locale\n\t * \n\t * @var string\n\t */\n\tpublic static $locale = '';\n\t\n\t/**\n\t * elFinderVolumeDriver default mime.type file path\n\t * \n\t * @var string\n\t */\n\tpublic static $defaultMimefile = '';\n\t\n\t/**\n\t * A file save destination path when a temporary content URL is required\n\t * on a network volume or the like\n\t * It can be overwritten by volume route setting\n\t * \n\t * @var string\n\t */\n\tpublic static $tmpLinkPath = '';\n\t\n\t/**\n\t * A file save destination URL when a temporary content URL is required\n\t * on a network volume or the like\n\t * It can be overwritten by volume route setting\n\t *\n\t * @var string\n\t */\n\tpublic static $tmpLinkUrl = '';\n\t\n\t/**\n\t * Temporary content URL lifetime (seconds)\n\t * \n\t * @var integer\n\t */\n\tpublic static $tmpLinkLifeTime = 3600;\n\t\n\t/**\n\t * MIME type list handled as a text file\n\t *\n\t * @var array\n\t */\n\tpublic static $textMimes = array(\n\t\t'application/x-empty',\n\t\t'application/javascript',\n\t\t'application/json',\n\t\t'application/xhtml+xml',\n\t\t'audio/x-mp3-playlist',\n\t\t'application/x-web-config',\n\t\t'application/docbook+xml',\n\t\t'application/x-php',\n\t\t'application/x-perl',\n\t\t'application/x-awk',\n\t\t'application/x-config',\n\t\t'application/x-csh',\n\t\t'application/xml',\n\t\t'application/sql'\n\t);\n\t\n\t/**\n\t * Maximum memory size to be extended during GD processing\n\t * (0: not expanded, -1: unlimited or memory size notation)\n\t *\n\t * @var integer|string\n\t */\n\tpublic static $memoryLimitGD = 0;\n\n\t/**\n\t * Path of current request flag file for abort check\n\t * \n\t * @var string\n\t */\n\tprotected static $abortCheckFile = null;\n\t\n\t/**\n\t * elFinder session wrapper object\n\t * \n\t * @var elFinderSessionInterface\n\t */\n\tprotected $session;\n\t\n\t/**\n\t * elFinder global sessionCacheKey\n\t * \n\t * @deprecated\n\t * @var string\n\t */\n\tpublic static $sessionCacheKey = '';\n\t\n\t/**\n\t * Is session closed\n\t * \n\t * @deprecated\n\t * @var bool\n\t */\n\tprivate static $sessionClosed = false;\n\t\n\t/**\n\t * elFinder base64encodeSessionData\n\t * elFinder save session data as `UTF-8`\n\t * If the session storage mechanism of the system does not allow `UTF-8`\n\t * And it must be `true` option 'base64encodeSessionData' of elFinder\n\t * \n\t * WARNING: When enabling this option, if saving the data passed from the user directly to the session variable,\n\t * it make vulnerable to the object injection attack, so use it carefully.\n\t * see https://github.com/Studio-42/elFinder/issues/2345\n\t * \n\t * @var bool\n\t */\n\tprotected static $base64encodeSessionData = false;\n\t\n\t/**\n\t * elFinder common tempraly path\n\t *\n\t * @var string\n\t * @default \"./.tmp\" or sys_get_temp_dir()\n\t **/\n\tprotected static $commonTempPath = '';\n\t\n\t/**\n\t * Connection flag files path that connection check of current request\n\t * \n\t * @var string\n\t * @default value of $commonTempPath\n\t */\n\tprotected static $connectionFlagsPath = '';\n\t\n\t/**\n\t * Additional volume root options for network mounting volume\n\t * \n\t * @var array\n\t */\n\tprotected $optionsNetVolumes = array();\n\t\n\t/**\n\t * Session key of net mount volumes\n\t *\n\t * @deprecated\n\t * @var string\n\t */\n\tprotected $netVolumesSessionKey = '';\n\t\n\t/**\n\t * Mounted volumes count\n\t * Required to create unique volume id\n\t *\n\t * @var int\n\t **/\n\tpublic static $volumesCnt = 1;\n\t\n\t/**\n\t * Default root (storage)\n\t *\n\t * @var elFinderStorageDriver\n\t **/\n\tprotected $default = null;\n\t\n\t/**\n\t * Commands and required arguments list\n\t *\n\t * @var array\n\t **/\n\tprotected $commands = array(\n\t\t'open'      => array('target' => false, 'tree' => false, 'init' => false, 'mimes' => false, 'compare' => false),\n\t\t'ls'        => array('target' => true, 'mimes' => false, 'intersect' => false),\n\t\t'tree'      => array('target' => true),\n\t\t'parents'   => array('target' => true, 'until' => false),\n\t\t'tmb'       => array('targets' => true),\n\t\t'file'      => array('target' => true, 'download' => false),\n\t\t'zipdl'     => array('targets' => true, 'download' => false),\n\t\t'size'      => array('targets' => true),\n\t\t'mkdir'     => array('target' => true, 'name' => false, 'dirs' => false),\n\t\t'mkfile'    => array('target' => true, 'name' => true, 'mimes' => false),\n\t\t'rm'        => array('targets' => true),\n\t\t'rename'    => array('target' => true, 'name' => true, 'mimes' => false, 'targets' => false, 'q' => false),\n\t\t'duplicate' => array('targets' => true, 'suffix' => false),\n\t\t'paste'     => array('dst' => true, 'targets' => true, 'cut' => false, 'mimes' => false, 'renames' => false, 'hashes' => false, 'suffix' => false),\n\t\t'upload'    => array('target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false),\n\t\t'get'       => array('target' => true, 'conv' => false),\n\t\t'put'       => array('target' => true, 'content' => '', 'mimes' => false, 'encoding' => false),\n\t\t'archive'   => array('targets' => true, 'type' => true, 'mimes' => false, 'name' => false),\n\t\t'extract'   => array('target' => true, 'mimes' => false, 'makedir' => false),\n\t\t'search'    => array('q' => true, 'mimes' => false, 'target' => false),\n\t\t'info'      => array('targets' => true, 'compare' => false),\n\t\t'dim'       => array('target' => true, 'substitute' => false),\n\t\t'resize'    => array('target' => true, 'width' => false, 'height' => false, 'mode' => false, 'x' => false, 'y' => false, 'degree' => false, 'quality' => false, 'bg' => false),\n\t\t'netmount'  => array('protocol' => true, 'host' => true, 'path' => false, 'port' => false, 'user' => false, 'pass' => false, 'alias' => false, 'options' => false),\n\t\t'url'       => array('target' => true, 'options' => false),\n\t\t'callback'  => array('node' => true, 'json' => false, 'bind' => false, 'done' => false),\n\t\t'chmod'     => array('targets' => true, 'mode' => true),\n\t\t'subdirs'   => array('targets' => true),\n\t\t'abort'     => array('id' => true),\n\t\t'editor'    => array('name' => true, 'method' => true, 'args' => false)\n\t);\n\t\n\t/**\n\t * Plugins instance\n\t *\n\t * @var array\n\t **/\n\tprotected $plugins = array();\n\t\n\t/**\n\t * Commands listeners\n\t *\n\t * @var array\n\t **/\n\tprotected $listeners = array();\n\t\n\t/**\n\t * script work time for debug\n\t *\n\t * @var string\n\t **/\n\tprotected $time = 0;\n\t/**\n\t * Is elFinder init correctly?\n\t *\n\t * @var bool\n\t **/\n\tprotected $loaded = false;\n\t/**\n\t * Send debug to client?\n\t *\n\t * @var string\n\t **/\n\tprotected $debug = false;\n\t\n\t/**\n\t * Call `session_write_close()` before exec command?\n\t * \n\t * @var bool\n\t */\n\tprotected $sessionCloseEarlier = true;\n\n\t/**\n\t * SESSION use commands @see __construct()\n\t * \n\t * @var array\n\t */\n\tprotected $sessionUseCmds = array();\n\t\n\t/**\n\t * session expires timeout\n\t *\n\t * @var int\n\t **/\n\tprotected $timeout = 0;\n\t\n\t/**\n\t * Temp dir path for Upload\n\t * \n\t * @var string\n\t */\n\tprotected $uploadTempPath = '';\n\t\n\t/**\n\t * Max allowed archive files size (0 - no limit)\n\t * \n\t * @var integer\n\t */\n\tprotected $maxArcFilesSize = 0;\n\t\n\t/**\n\t * undocumented class variable\n\t *\n\t * @var string\n\t **/\n\tprotected $uploadDebug = '';\n\t\n\t/**\n\t * Max allowed numbar of @var targets (0 - no limit)\n\t * \n\t * @var integer\n\t */\n\tpublic $maxTargets = 1000;\n\t\n\t/**\n\t * Errors from PHP\n\t *\n\t * @var array\n\t **/\n\tpublic static $phpErrors = array();\n\t\n\t/**\n\t * Errors from not mounted volumes\n\t *\n\t * @var array\n\t **/\n\tpublic $mountErrors = array();\n\t\n\t/**\n\t * URL for callback output window for CORS\n\t * redirect to this URL when callback output\n\t * \n\t * @var string URL\n\t */\n\tprotected $callbackWindowURL = '';\n\t\n\t/**\n\t * hash of items to unlock on command completion\n\t * \n\t * @var array hashes\n\t */\n\tprotected $autoUnlocks = array();\n\t\n\t/**\n\t * Item locking expiration (seconds)\n\t * Default: 3600 secs\n\t * \n\t * @var integer\n\t */\n\tprotected $itemLockExpire = 3600;\n\n\t/**\n\t * Additional request querys\n\t * \n\t * @var array|null\n\t */\n\tprotected $customData = null;\n\n\t// Errors messages\n\tconst ERROR_UNKNOWN           = 'errUnknown';\n\tconst ERROR_UNKNOWN_CMD       = 'errUnknownCmd';\n\tconst ERROR_CONF              = 'errConf';\n\tconst ERROR_CONF_NO_JSON      = 'errJSON';\n\tconst ERROR_CONF_NO_VOL       = 'errNoVolumes';\n\tconst ERROR_INV_PARAMS        = 'errCmdParams';\n\tconst ERROR_OPEN              = 'errOpen';\n\tconst ERROR_DIR_NOT_FOUND     = 'errFolderNotFound';\n\tconst ERROR_FILE_NOT_FOUND    = 'errFileNotFound';     // 'File not found.'\n\tconst ERROR_TRGDIR_NOT_FOUND  = 'errTrgFolderNotFound'; // 'Target folder \"$1\" not found.'\n\tconst ERROR_NOT_DIR           = 'errNotFolder';\n\tconst ERROR_NOT_FILE          = 'errNotFile';\n\tconst ERROR_PERM_DENIED       = 'errPerm';\n\tconst ERROR_LOCKED            = 'errLocked';        // '\"$1\" is locked and can not be renamed, moved or removed.'\n\tconst ERROR_EXISTS            = 'errExists';        // 'File named \"$1\" already exists.'\n\tconst ERROR_INVALID_NAME      = 'errInvName';       // 'Invalid file name.'\n\tconst ERROR_INVALID_DIRNAME   = 'errInvDirname';    // 'Invalid folder name.'\n\tconst ERROR_MKDIR             = 'errMkdir';\n\tconst ERROR_MKFILE            = 'errMkfile';\n\tconst ERROR_RENAME            = 'errRename';\n\tconst ERROR_COPY              = 'errCopy';\n\tconst ERROR_MOVE              = 'errMove';\n\tconst ERROR_COPY_FROM         = 'errCopyFrom';\n\tconst ERROR_COPY_TO           = 'errCopyTo';\n\tconst ERROR_COPY_ITSELF       = 'errCopyInItself';\n\tconst ERROR_REPLACE           = 'errReplace';          // 'Unable to replace \"$1\".'\n\tconst ERROR_RM                = 'errRm';               // 'Unable to remove \"$1\".'\n\tconst ERROR_RM_SRC            = 'errRmSrc';            // 'Unable remove source file(s)'\n\tconst ERROR_MKOUTLINK         = 'errMkOutLink';        // 'Unable to create a link to outside the volume root.'\n\tconst ERROR_UPLOAD            = 'errUpload';           // 'Upload error.'\n\tconst ERROR_UPLOAD_FILE       = 'errUploadFile';       // 'Unable to upload \"$1\".'\n\tconst ERROR_UPLOAD_NO_FILES   = 'errUploadNoFiles';    // 'No files found for upload.'\n\tconst ERROR_UPLOAD_TOTAL_SIZE = 'errUploadTotalSize';  // 'Data exceeds the maximum allowed size.'\n\tconst ERROR_UPLOAD_FILE_SIZE  = 'errUploadFileSize';   // 'File exceeds maximum allowed size.'\n\tconst ERROR_UPLOAD_FILE_MIME  = 'errUploadMime';       // 'File type not allowed.'\n\tconst ERROR_UPLOAD_TRANSFER   = 'errUploadTransfer';   // '\"$1\" transfer error.'\n\tconst ERROR_UPLOAD_TEMP       = 'errUploadTemp';       // 'Unable to make temporary file for upload.'\n\tconst ERROR_ACCESS_DENIED     = 'errAccess';\n\tconst ERROR_NOT_REPLACE       = 'errNotReplace';       // Object \"$1\" already exists at this location and can not be replaced with object of another type.\n\tconst ERROR_SAVE              = 'errSave';\n\tconst ERROR_EXTRACT           = 'errExtract';\n\tconst ERROR_ARCHIVE           = 'errArchive';\n\tconst ERROR_NOT_ARCHIVE       = 'errNoArchive';\n\tconst ERROR_ARCHIVE_TYPE      = 'errArcType';\n\tconst ERROR_ARC_SYMLINKS      = 'errArcSymlinks';\n\tconst ERROR_ARC_MAXSIZE       = 'errArcMaxSize';\n\tconst ERROR_RESIZE            = 'errResize';\n\tconst ERROR_RESIZESIZE        = 'errResizeSize';\n\tconst ERROR_UNSUPPORT_TYPE    = 'errUsupportType';\n\tconst ERROR_CONV_UTF8         = 'errConvUTF8';\n\tconst ERROR_NOT_UTF8_CONTENT  = 'errNotUTF8Content';\n\tconst ERROR_NETMOUNT          = 'errNetMount';\n\tconst ERROR_NETUNMOUNT        = 'errNetUnMount';\n\tconst ERROR_NETMOUNT_NO_DRIVER = 'errNetMountNoDriver';\n\tconst ERROR_NETMOUNT_FAILED   = 'errNetMountFailed';\n\tconst ERROR_SESSION_EXPIRES   = 'errSessionExpires';\n\tconst ERROR_CREATING_TEMP_DIR = 'errCreatingTempDir';\n\tconst ERROR_FTP_DOWNLOAD_FILE = 'errFtpDownloadFile';\n\tconst ERROR_FTP_UPLOAD_FILE   = 'errFtpUploadFile';\n\tconst ERROR_FTP_MKDIR         = 'errFtpMkdir';\n\tconst ERROR_ARCHIVE_EXEC      = 'errArchiveExec';\n\tconst ERROR_EXTRACT_EXEC      = 'errExtractExec';\n\tconst ERROR_SEARCH_TIMEOUT    = 'errSearchTimeout';    // 'Timed out while searching \"$1\". Search result is partial.'\n\tconst ERROR_REAUTH_REQUIRE    = 'errReauthRequire';  // 'Re-authorization is required.'\n\tconst ERROR_MAX_TARGTES       = 'errMaxTargets'; // 'Max number of selectable items is $1.'\n\n\t/**\n\t * Constructor\n\t *\n\t * @param  array  elFinder and roots configurations\n\t * @author Dmitry (dio) Levashov\n\t */\n\tpublic function __construct($opts) {\n\t\t// set default_charset\n\t\tif (version_compare(PHP_VERSION, '5.6', '>=')) {\n\t\t\tif (($_val = ini_get('iconv.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n\t\t\t\tini_set('iconv.internal_encoding', '');\n\t\t\t}\n\t\t\tif (($_val = ini_get('mbstring.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n\t\t\t\tini_set('mbstring.internal_encoding', '');\n\t\t\t}\n\t\t\tif (($_val = ini_get('internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n\t\t\t\tini_set('internal_encoding', '');\n\t\t\t}\n\t\t} else {\n\t\t\tif (function_exists('iconv_set_encoding') && strtoupper(iconv_get_encoding('internal_encoding')) !== 'UTF-8') {\n\t\t\t\ticonv_set_encoding('internal_encoding', 'UTF-8');\n\t\t\t}\n\t\t\tif (function_exists('mb_internal_encoding') && strtoupper(mb_internal_encoding()) !== 'UTF-8') {\n\t\t\t\tmb_internal_encoding('UTF-8');\n\t\t\t}\n\t\t}\n\t\tini_set('default_charset', 'UTF-8');\n\t\t\n\t\t// define accept constant of server commands path\n\t\t! defined('ELFINDER_TAR_PATH')      && define('ELFINDER_TAR_PATH',      'tar');\n\t\t! defined('ELFINDER_GZIP_PATH')     && define('ELFINDER_GZIP_PATH',     'gzip');\n\t\t! defined('ELFINDER_BZIP2_PATH')    && define('ELFINDER_BZIP2_PATH',    'bzip2');\n\t\t! defined('ELFINDER_XZ_PATH')       && define('ELFINDER_XZ_PATH',       'xz');\n\t\t! defined('ELFINDER_ZIP_PATH')      && define('ELFINDER_ZIP_PATH',      'zip');\n\t\t! defined('ELFINDER_UNZIP_PATH')    && define('ELFINDER_UNZIP_PATH',    'unzip');\n\t\t! defined('ELFINDER_RAR_PATH')      && define('ELFINDER_RAR_PATH',      'rar');\n\t\t! defined('ELFINDER_UNRAR_PATH')    && define('ELFINDER_UNRAR_PATH',    'unrar');\n\t\t! defined('ELFINDER_7Z_PATH')       && define('ELFINDER_7Z_PATH', (substr(PHP_OS, 0, 3) === 'WIN')? '7z' : '7za');\n\t\t! defined('ELFINDER_CONVERT_PATH')  && define('ELFINDER_CONVERT_PATH',  'convert');\n\t\t! defined('ELFINDER_EXIFTRAN_PATH') && define('ELFINDER_EXIFTRAN_PATH', 'exiftran');\n\t\t! defined('ELFINDER_JPEGTRAN_PATH') && define('ELFINDER_JPEGTRAN_PATH', 'jpegtran');\n\t\t! defined('ELFINDER_FFMPEG_PATH')   && define('ELFINDER_FFMPEG_PATH',   'ffmpeg');\n\t\t\n\t\t! defined('ELFINDER_DISABLE_ZIPEDITOR') && define('ELFINDER_DISABLE_ZIPEDITOR', false);\n\n\t\t// for backward compat\n\t\t$this->version = (string)self::$ApiVersion;\n\t\t\n\t\t// set error handler of WARNING, NOTICE\n\t\t$errLevel = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_STRICT | E_RECOVERABLE_ERROR;\n\t\tif (defined('E_DEPRECATED')) {\n\t\t\t$errLevel |= E_DEPRECATED | E_USER_DEPRECATED;\n\t\t}\n\t\tset_error_handler('elFinder::phpErrorHandler', $errLevel);\n\t\t\n\t\t// Associative array of files to delete at the end of script: ['temp file path' => true]\n\t\t$GLOBALS['elFinderTempFiles'] = array();\n\t\t// regist Shutdown function\n\t\tregister_shutdown_function(array('elFinder', 'onShutdown'));\n\t\t\n\t\t// convert PATH_INFO to GET query\n\t\tif (! empty($_SERVER['PATH_INFO'])) {\n\t\t\t$_ps = explode('/', trim($_SERVER['PATH_INFO'], '/'));\n\t\t\tif (! isset($_GET['cmd'])) {\n\t\t\t\t$_cmd = $_ps[0];\n\t\t\t\tif (isset($this->commands[$_cmd])) {\n\t\t\t\t\t$_GET['cmd'] = $_cmd;\n\t\t\t\t\t$_i = 1;\n\t\t\t\t\tforeach(array_keys($this->commands[$_cmd]) as $_k) {\n\t\t\t\t\t\tif (isset($_ps[$_i])) {\n\t\t\t\t\t\t\tif (! isset($_GET[$_k])) {\n\t\t\t\t\t\t\t\t$_GET[$_k] = $_ps[$_i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set elFinder instance\n\t\telFinder::$instance = $this;\n\t\t\n\t\t// setup debug mode\n\t\t$this->debug = (isset($opts['debug']) && $opts['debug'] ? true : false);\n\t\tif ($this->debug) {\n\t\t\terror_reporting(defined('ELFINDER_DEBUG_ERRORLEVEL')? ELFINDER_DEBUG_ERRORLEVEL : -1);\n\t\t\tini_set('display_errors', '1');\n\t\t\t// clear output buffer and stop output filters\n\t\t\twhile(ob_get_level() && ob_end_clean()){}\n\t\t}\n\n\t\tif (! interface_exists('elFinderSessionInterface')) {\n\t\t\tinclude_once dirname(__FILE__).'/elFinderSessionInterface.php';\n\t\t}\n\t\t\n\t\t// session handler\n\t\tif (!empty($opts['session']) && $opts['session'] instanceof elFinderSessionInterface) {\n\t\t\t$this->session = $opts['session'];\n\t\t} else {\n\t\t\t$sessionOpts = array(\n\t\t\t\t'base64encode' => !empty($opts['base64encodeSessionData']),\n\t\t\t\t'keys' => array(\n\t\t\t\t\t'default'   => !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches',\n\t\t\t\t\t'netvolume' => !empty($opts['netVolumesSessionKey'])? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes'\n\t\t\t\t)\n\t\t\t);\n\t\t\tif (! class_exists('elFinderSession')) {\n\t\t\t\tinclude_once dirname(__FILE__) . '/elFinderSession.php';\n\t\t\t}\n\t\t\t$this->session = new elFinderSession($sessionOpts);\n\t\t}\n\t\t// try session start | restart\n\t\t$this->session->start();\n\t\t\n\t\t// 'netmount' added to handle requests synchronously on unmount\n\t\t$sessionUseCmds = array('netmount');\n\t\tif (isset($opts['sessionUseCmds']) && is_array($opts['sessionUseCmds'])) {\n\t\t\t$sessionUseCmds = array_merge($sessionUseCmds, $opts['sessionUseCmds']);\n\t\t}\n\n\t\t// set self::$volumesCnt by HTTP header \"X-elFinder-VolumesCntStart\"\n\t\tif (isset($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']) && ($volumesCntStart = intval($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']))) {\n\t\t\tself::$volumesCnt = $volumesCntStart;\n\t\t}\n\t\t\n\t\t$this->time  = $this->utime();\n\t\t$this->sessionCloseEarlier = isset($opts['sessionCloseEarlier'])? (bool)$opts['sessionCloseEarlier'] : true;\n\t\t$this->sessionUseCmds = array_flip($sessionUseCmds);\n\t\t$this->timeout = (isset($opts['timeout']) ? $opts['timeout'] : 0);\n\t\t$this->uploadTempPath = (isset($opts['uploadTempPath']) ? $opts['uploadTempPath'] : '');\n\t\t$this->callbackWindowURL = (isset($opts['callbackWindowURL']) ? $opts['callbackWindowURL'] : '');\n\t\t$this->maxTargets = (isset($opts['maxTargets']) ? intval($opts['maxTargets']) : $this->maxTargets);\n\t\telFinder::$commonTempPath = (isset($opts['commonTempPath']) ? $opts['commonTempPath'] : './.tmp');\n\t\tif (!is_writable(elFinder::$commonTempPath)) {\n\t\t\telFinder::$commonTempPath = sys_get_temp_dir();\n\t\t\tif (!is_writable(elFinder::$commonTempPath)) {\n\t\t\t\telFinder::$commonTempPath = '';\n\t\t\t}\n\t\t}\n\t\tif (isset($opts['connectionFlagsPath']) && is_writable($opts['connectionFlagsPath'])) {\n\t\t\telFinder::$connectionFlagsPath = $opts['connectionFlagsPath'];\n\t\t} else {\n\t\t\telFinder::$connectionFlagsPath = elFinder::$commonTempPath;\n\t\t}\n\t\t\n\t\tif (! empty($opts['tmpLinkPath'])) {\n\t\t\telFinder::$tmpLinkPath = $opts['tmpLinkPath'];\n\t\t}\n\t\tif (! empty($opts['tmpLinkUrl'])) {\n\t\t\telFinder::$tmpLinkUrl = $opts['tmpLinkUrl'];\n\t\t}\n\t\tif (! empty($opts['tmpLinkLifeTime'])) {\n\t\t\telFinder::$tmpLinkLifeTime = $opts['tmpLinkLifeTime'];\n\t\t}\n\t\tif (! empty($opts['textMimes']) && is_array($opts['textMimes'])) {\n\t\t\telfinder::$textMimes = $opts['textMimes'];\n\t\t}\n\t\t$this->maxArcFilesSize = isset($opts['maxArcFilesSize'])? intval($opts['maxArcFilesSize']) : 0;\n\t\t$this->optionsNetVolumes = (isset($opts['optionsNetVolumes']) && is_array($opts['optionsNetVolumes']))? $opts['optionsNetVolumes'] : array();\n\t\tif (isset($opts['itemLockExpire'])) {\n\t\t\t$this->itemLockExpire = intval($opts['itemLockExpire']);\n\t\t}\n\t\t\n\t\t// deprecated settings\n\t\t$this->netVolumesSessionKey = !empty($opts['netVolumesSessionKey'])? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes';\n\t\tself::$sessionCacheKey = !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches';\n\t\t\n\t\t// check session cache\n\t\t$_optsMD5 = md5(json_encode($opts['roots']));\n\t\tif ($this->session->get('_optsMD5') !== $_optsMD5) {\n\t\t\t$this->session->set('_optsMD5', $_optsMD5);\n\t\t}\n\t\t\n\t\t// setlocale and global locale regists to elFinder::locale\n\t\tself::$locale = !empty($opts['locale']) ? $opts['locale'] : (substr(PHP_OS, 0, 3) === 'WIN'? 'C' : 'en_US.UTF-8');\n\t\tif (false === setlocale(LC_ALL, self::$locale)) {\n\t\t\tself::$locale = setlocale(LC_ALL, '0');\n\t\t}\n\n\t\t// set defaultMimefile\n\t\telFinder::$defaultMimefile = isset($opts['defaultMimefile'])? $opts['defaultMimefile'] : '';\n\n\t\t// set memoryLimitGD\n\t\telFinder::$memoryLimitGD = isset($opts['memoryLimitGD'])? $opts['memoryLimitGD'] : 0;\n\n\t\t// bind events listeners\n\t\tif (!empty($opts['bind']) && is_array($opts['bind'])) {\n\t\t\t$_req = $_SERVER[\"REQUEST_METHOD\"] == 'POST' ? $_POST : $_GET;\n\t\t\t$_reqCmd = isset($_req['cmd']) ? $_req['cmd'] : '';\n\t\t\tforeach ($opts['bind'] as $cmd => $handlers) {\n\t\t\t\t$doRegist = (strpos($cmd, '*') !== false);\n\t\t\t\tif (! $doRegist) {\n\t\t\t\t\t$doRegist = ($_reqCmd && in_array($_reqCmd, array_map('self::getCmdOfBind', explode(' ', $cmd))));\n\t\t\t\t}\n\t\t\t\tif ($doRegist) {\n\t\t\t\t\t// for backward compatibility\n\t\t\t\t\tif (! is_array($handlers)) {\n\t\t\t\t\t\t$handlers = array($handlers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (count($handlers) === 2 && is_object($handlers[0])) {\n\t\t\t\t\t\t\t$handlers = array($handlers);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tforeach($handlers as $handler) {\n\t\t\t\t\t\tif ($handler) {\n\t\t\t\t\t\t\tif (is_string($handler) && strpos($handler, '.')) {\n\t\t\t\t\t\t\t\tlist($_domain, $_name, $_method) = array_pad(explode('.', $handler), 3, '');\n\t\t\t\t\t\t\t\tif (strcasecmp($_domain, 'plugin') === 0) {\n\t\t\t\t\t\t\t\t\tif ($plugin = $this->getPluginInstance($_name, isset($opts['plugin'][$_name])? $opts['plugin'][$_name] : array())\n\t\t\t\t\t\t\t\t\t\t\tand method_exists($plugin, $_method)) {\n\t\t\t\t\t\t\t\t\t\t$this->bind($cmd, array($plugin, $_method));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->bind($cmd, $handler);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isset($opts['roots']) || !is_array($opts['roots'])) {\n\t\t\t$opts['roots'] = array();\n\t\t}\n\n\t\t// try to enable elFinderVolumeFlysystemZipArchiveNetmount to zip editing\n\t\tif (empty(elFinder::$netDrivers['ziparchive'])) {\n\t\t\telFinder::$netDrivers['ziparchive'] = 'FlysystemZipArchiveNetmount';\n\t\t}\n\n\t\t// check for net volumes stored in session\n\t\t$netVolumes = $this->getNetVolumes();\n\t\tforeach ($netVolumes as $key => $root) {\n\t\t\tif (! isset($root['id'])) {\n\t\t\t\t// given fixed unique id\n\t\t\t\tif (! $root['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n\t\t\t\t\t$this->mountErrors[] = 'Netmount Driver \"'.$root['driver'].'\" : Could\\'t given volume id.';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$opts['roots'][$key] = $root;\n\t\t}\n\n\t\t// \"mount\" volumes\n\t\tforeach ($opts['roots'] as $i => $o) {\n\t\t\t$class = 'elFinderVolume'.(isset($o['driver']) ? $o['driver'] : '');\n\n\t\t\tif (class_exists($class)) {\n\t\t\t\t$volume = new $class();\n\n\t\t\t\ttry {\n\t\t\t\t\tif ($this->maxArcFilesSize && (empty($o['maxArcFilesSize']) || $this->maxArcFilesSize < $o['maxArcFilesSize'])) {\n\t\t\t\t\t\t$o['maxArcFilesSize'] = $this->maxArcFilesSize;\n\t\t\t\t\t}\n\t\t\t\t\t// pass session handler\n\t\t\t\t\t$volume->setSession($this->session);\n\t\t\t\t\tif ($volume->mount($o)) {\n\t\t\t\t\t\t// unique volume id (ends on \"_\") - used as prefix to files hash\n\t\t\t\t\t\t$id = $volume->id();\n\t\t\t\t\t\t\n\t\t\t\t\t\t$this->volumes[$id] = $volume;\n\t\t\t\t\t\tif ((!$this->default || $volume->root() !== $volume->defaultPath()) && $volume->isReadable()) {\n\t\t\t\t\t\t\t$this->default = $this->volumes[$id]; \n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->removeNetVolume($i, $volume);\n\t\t\t\t\t\t$this->mountErrors[] = 'Driver \"'.$class.'\" : '.implode(' ', $volume->error());\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\t$this->removeNetVolume($i, $volume);\n\t\t\t\t\t$this->mountErrors[] = 'Driver \"'.$class.'\" : '.$e->getMessage();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->removeNetVolume($i, $volume);\n\t\t\t\t$this->mountErrors[] = 'Driver \"'.$class.'\" does not exist';\n\t\t\t}\n\t\t}\n\n\t\t// if at least one readable volume - ii desu >_<\n\t\t$this->loaded = !empty($this->default);\n\t\t\n\t\t// restore error handler for now\n\t\trestore_error_handler();\n\t}\n\t\n\t/**\n\t * Return elFinder session wrapper instance\n\t *\n\t * @return  object  elFinderSessionInterface\n\t **/\n\tpublic function getSession() {\n\t\treturn $this->session;\n\t}\n\t\n\t/**\n\t * Return true if fm init correctly\n\t *\n\t * @return bool\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function loaded() {\n\t\treturn $this->loaded;\n\t}\n\t\n\t/**\n\t * Return version (api) number\n\t *\n\t * @return string\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function version() {\n\t\treturn self::$ApiVersion;\n\t}\n\t\n\t/**\n\t * Return revision (api) number\n\t *\n\t * @return string\n\t * @author Naoki Sawada\n\t **/\n\tpublic function revision() {\n\t\treturn self::$ApiRevision;\n\t}\n\t\n\t/**\n\t * Add handler to elFinder command\n\t *\n\t * @param  string  command name\n\t * @param  string|array  callback name or array(object, method)\n\t * @return elFinder\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function bind($cmd, $handler) {\n\t\t$allCmds = array_keys($this->commands);\n\t\t$cmds = array();\n\t\tforeach(explode(' ', $cmd) as $_cmd) {\n\t\t\tif ($_cmd !== '') {\n\t\t\t\tif ($all = strpos($_cmd, '*') !== false) {\n\t\t\t\t\tlist(, $sub) = array_pad(explode('.', $_cmd), 2, '');\n\t\t\t\t\tif ($sub) {\n\t\t\t\t\t\t$sub = str_replace('\\'', '\\\\\\'', $sub);\n\t\t\t\t\t\t$subs = array_fill(0, count($allCmds), $sub);\n\t\t\t\t\t\t$cmds = array_merge($cmds, array_map(array('elFinder', 'addSubToBindName'), $allCmds, $subs));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$cmds = array_merge($cmds, $allCmds);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$cmds[] = $_cmd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$cmds = array_unique($cmds);\n\t\t\n\t\tforeach ($cmds as $cmd) {\n\t\t\tif (!isset($this->listeners[$cmd])) {\n\t\t\t\t$this->listeners[$cmd] = array();\n\t\t\t}\n\n\t\t\tif (is_callable($handler)) {\n\t\t\t\t$this->listeners[$cmd][] = $handler;\n\t\t\t}\n\t\t}\n\n\t\treturn $this;\n\t}\n\t\n\t/**\n\t * Remove event (command exec) handler\n\t *\n\t * @param  string  command name\n\t * @param  string|array  callback name or array(object, method)\n\t * @return elFinder\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function unbind($cmd, $handler) {\n\t\tif (!empty($this->listeners[$cmd])) {\n\t\t\tforeach ($this->listeners[$cmd] as $i => $h) {\n\t\t\t\tif ($h === $handler) {\n\t\t\t\t\tunset($this->listeners[$cmd][$i]);\n\t\t\t\t\treturn $this;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $this;\n\t}\n\t\n\t/**\n\t * Return true if command exists\n\t *\n\t * @param  string  command name\n\t * @return bool\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function commandExists($cmd) {\n\t\treturn $this->loaded && isset($this->commands[$cmd]) && method_exists($this, $cmd);\n\t}\n\t\n\t/**\n\t * Return root - file's owner (public func of volume())\n\t *\n\t * @param  string  file hash\n\t * @return elFinderStorageDriver\n\t * @author Naoki Sawada\n\t */\n\tpublic function getVolume($hash) {\n\t\treturn $this->volume($hash);\n\t}\n\t\n\t/**\n\t * Return command required arguments info\n\t *\n\t * @param  string  command name\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function commandArgsList($cmd) {\n\t\tif ($this->commandExists($cmd)) {\n\t\t\t$list = $this->commands[$cmd];\n\t\t\t$list['reqid'] = false;\n\t\t} else {\n\t\t\t$list = array();\n\t\t}\n\t\treturn $list;\n\t}\n\n\tprivate function session_expires() {\n\t\t\n\t\tif (! $last = $this->session->get(':LAST_ACTIVITY')) {\n\t\t\t$this->session->set(':LAST_ACTIVITY', time());\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ($this->timeout > 0) && (time() - $last > $this->timeout) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$this->session->set(':LAST_ACTIVITY', time());\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Exec command and return result\n\t *\n\t * @param  string  $cmd  command name\n\t * @param  array   $args command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function exec($cmd, $args) {\n\t\t// set error handler of WARNING, NOTICE\n\t\tset_error_handler('elFinder::phpErrorHandler', E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE);\n\t\t\n\t\t// set current request args\n\t\tself::$currentArgs = $args;\n\t\t\n\t\tif (!$this->loaded) {\n\t\t\treturn array('error' => $this->error(self::ERROR_CONF, self::ERROR_CONF_NO_VOL));\n\t\t}\n\n\t\tif ($this->session_expires()) {\n\t\t\treturn array('error' => $this->error(self::ERROR_SESSION_EXPIRES));\n\t\t}\n\t\t\n\t\tif (!$this->commandExists($cmd)) {\n\t\t\treturn array('error' => $this->error(self::ERROR_UNKNOWN_CMD));\n\t\t}\n\t\t\n\t\t// check request id\n\t\t$args['reqid'] = preg_replace('[^0-9a-fA-F]', '', ! empty($args['reqid'])? $args['reqid'] : (! empty($_SERVER['HTTP_X_ELFINDERREQID'])? $_SERVER['HTTP_X_ELFINDERREQID'] : ''));\n\t\t\n\t\t// to abort this request\n\t\tif ($cmd === 'abort') {\n\t\t\t$this->abort($args);\n\t\t\treturn array('error' => 0);\n\t\t}\n\t\t\n\t\t// make flag file and set self::$abortCheckFile\n\t\tif ($args['reqid']) {\n\t\t\t$this->abort(array('makeFile' => $args['reqid']));\n\t\t}\n\t\t\n\t\tif (!empty($args['mimes']) && is_array($args['mimes'])) {\n\t\t\tforeach ($this->volumes as $id => $v) {\n\t\t\t\t$this->volumes[$id]->setMimesFilter($args['mimes']);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// regist shutdown function as fallback\n\t\tregister_shutdown_function(array($this, 'itemAutoUnlock'));\n\t\t\n\t\t// detect destination dirHash and volume\n\t\t$dstVolume = false;\n\t\t$dst = ! empty($args['target'])? $args['target'] : (! empty($args['dst'])? $args['dst'] : '');\n\t\tif ($dst) {\n\t\t\t$dstVolume = $this->volume($dst);\n\t\t} else if (isset($args['targets']) && is_array($args['targets']) && isset($args['targets'][0])) {\n\t\t\t$dst = $args['targets'][0];\n\t\t\t$dstVolume = $this->volume($dst);\n\t\t\tif ($dstVolume && ($_stat = $dstVolume->file($dst)) && ! empty($_stat['phash'])) {\n\t\t\t\t$dst = $_stat['phash'];\n\t\t\t} else {\n\t\t\t\t$dst = '';\n\t\t\t}\n\t\t} else if ($cmd === 'open') {\n\t\t\t// for initial open without args `target`\n\t\t\t$dstVolume = $this->default;\n\t\t\t$dst = $dstVolume->defaultPath();\n\t\t}\n\t\t\n\t\t$result = null;\n\t\t\n\t\t// call pre handlers for this command\n\t\t$args['sessionCloseEarlier'] = isset($this->sessionUseCmds[$cmd])? false : $this->sessionCloseEarlier;\n\t\tif (!empty($this->listeners[$cmd.'.pre'])) {\n\t\t\tforeach ($this->listeners[$cmd.'.pre'] as $handler) {\n\t\t\t\t$_res = call_user_func_array($handler, array($cmd, &$args, $this, $dstVolume));\n\t\t\t\tif (is_array($_res)) {\n\t\t\t\t\tif (! empty($_res['preventexec'])) {\n\t\t\t\t\t\t$result = array('error' => true);\n\t\t\t\t\t\tif ($cmd === 'upload' & ! empty($args['node'])) {\n\t\t\t\t\t\t\t$result['callback'] = array(\n\t\t\t\t\t\t\t\t'node' => $args['node'],\n\t\t\t\t\t\t\t\t'bind' => $cmd\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! empty($_res['results']) && is_array($_res['results'])) {\n\t\t\t\t\t\t\t$result = array_merge($result, $_res['results']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// unlock session data for multiple access\n\t\tif ($this->sessionCloseEarlier && $args['sessionCloseEarlier']) {\n\t\t\t$this->session->close();\n\t\t\t// deprecated property\n\t\t\telFinder::$sessionClosed = true;\n\t\t}\n\t\t\n\t\tif (substr(PHP_OS,0,3) === 'WIN') {\n\t\t\t// set time out\n\t\t\telFinder::extendTimeLimit(300);\n\t\t}\n\t\t\n\t\tif (! is_array($result)) {\n\t\t\ttry {\n\t\t\t\t$result = $this->$cmd($args);\n\t\t\t} catch (elFinderAbortException $e) {\n\t\t\t\tthrow $e;\n\t\t\t} catch (Exception $e) {\n\t\t\t\t$result = array(\n\t\t\t\t\t'error' => htmlspecialchars($e->getMessage()),\n\t\t\t\t\t'sync' => true\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// check change dstDir\n\t\t$changeDst = false;\n\t\tif ($dst && $dstVolume && (! empty($result['added']) || ! empty($result['removed']))) {\n\t\t\t$changeDst = true;\n\t\t}\n\t\t\n\t\tforeach ($this->volumes as $volume) {\n\t\t\t$removed = $volume->removed();\n\t\t\tif (! empty($removed)) {\n\t\t\t\tif (! isset($result['removed'])) {\n\t\t\t\t\t$result['removed'] = array();\n\t\t\t\t}\n\t\t\t\t$result['removed'] = array_merge($result['removed'], $removed);\n\t\t\t\tif (! $changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n\t\t\t\t\t$changeDst = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$added = $volume->added();\n\t\t\tif (! empty($added)) {\n\t\t\t\tif (! isset($result['added'])) {\n\t\t\t\t\t$result['added'] = array();\n\t\t\t\t}\n\t\t\t\t$result['added'] = array_merge($result['added'], $added);\n\t\t\t\tif (! $changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n\t\t\t\t\t$changeDst = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$volume->resetResultStat();\n\t\t}\n\t\t\n\t\t// dstDir is changed\n\t\tif ($changeDst) {\n\t\t\tif ($dstDir = $dstVolume->dir($dst)) {\n\t\t\t\tif (! isset($result['changed'])) {\n\t\t\t\t\t$result['changed'] = array();\n\t\t\t\t}\n\t\t\t\t$result['changed'][] = $dstDir;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// call handlers for this command\n\t\tif (!empty($this->listeners[$cmd])) {\n\t\t\tforeach ($this->listeners[$cmd] as $handler) {\n\t\t\t\tif (call_user_func_array($handler,array($cmd, &$result, $args, $this, $dstVolume))) {\n\t\t\t\t\t// handler return true to force sync client after command completed\n\t\t\t\t\t$result['sync'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// replace removed files info with removed files hashes\n\t\tif (!empty($result['removed'])) {\n\t\t\t$removed = array();\n\t\t\tforeach ($result['removed'] as $file) {\n\t\t\t\t$removed[] = $file['hash'];\n\t\t\t}\n\t\t\t$result['removed'] = array_unique($removed);\n\t\t}\n\t\t// remove hidden files and filter files by mimetypes\n\t\tif (!empty($result['added'])) {\n\t\t\t$result['added'] = $this->filter($result['added']);\n\t\t}\n\t\t// remove hidden files and filter files by mimetypes\n\t\tif (!empty($result['changed'])) {\n\t\t\t$result['changed'] = $this->filter($result['changed']);\n\t\t}\n\t\t\n\t\tif ($this->debug || !empty($args['debug'])) {\n\t\t\t$result['debug'] = array(\n\t\t\t\t'connector' => 'php', \n\t\t\t\t'phpver'    => PHP_VERSION,\n\t\t\t\t'time'      => $this->utime() - $this->time,\n\t\t\t\t'memory'    => (function_exists('memory_get_peak_usage') ? ceil(memory_get_peak_usage()/1024).'Kb / ' : '').ceil(memory_get_usage()/1024).'Kb / '.ini_get('memory_limit'),\n\t\t\t\t'upload'    => $this->uploadDebug,\n\t\t\t\t'volumes'   => array(),\n\t\t\t\t'mountErrors' => $this->mountErrors,\n\t\t\t\t'phpErrors' => elFinder::$phpErrors\n\t\t\t);\n\t\t\telFinder::$phpErrors = array();\n\t\t\t\n\t\t\tforeach ($this->volumes as $id => $volume) {\n\t\t\t\t$result['debug']['volumes'][] = $volume->debug();\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach ($this->volumes as $volume) {\n\t\t\t$volume->saveSessionCache();\n\t\t\t$volume->umount();\n\t\t}\n\t\t\n\t\t// unlock locked items\n\t\t$this->itemAutoUnlock();\n\t\t\n\t\t// custom data\n\t\tif ($this->customData !== null) {\n\t\t\t$result['customData'] = $this->customData? json_encode($this->customData) : '';\n\t\t}\n\n\t\tif (!empty($result['callback'])) {\n\t\t\t$result['callback']['json'] = json_encode($result);\n\t\t\t$this->callback($result['callback']);\n\t\t} else {\n\t\t\treturn $result;\n\t\t}\n\t}\n\t\n\t/**\n\t * Return file real path\n\t *\n\t * @param  string  $hash  file hash\n\t * @return string\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function realpath($hash)\t{\n\t\tif (($volume = $this->volume($hash)) == false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn $volume->realpath($hash);\n\t}\n\t\n\t/**\n\t * Sets custom data(s).\n\t *\n\t * @param  string|array  $key    The key or data array\n\t * @param  mixed         $val    The value\n\t * \n\t * @return self    ( elFinder instance )\n\t */\n\tpublic function setCustomData($key, $val = null) {\n\t\tif (is_array($key)) {\n\t\t\tforeach($key as $k => $v) {\n\t\t\t\t$this->customData[$k] = $v;\n\t\t\t}\n\t\t} else {\n\t\t\t$this->customData[$key] = $val;\n\t\t}\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Removes a custom data.\n\t *\n\t * @param  string  $key    The key\n\t * \n\t * @return self    ( elFinder instance )\n\t */\n\tpublic function removeCustomData($key) {\n\t\t$this->customData[$key] = null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Update sesstion value of a NetVolume option\n\t * \n\t * @param string $netKey\n\t * @param string $optionKey\n\t * @param mixed  $val\n\t */\n\tpublic function updateNetVolumeOption($netKey, $optionKey, $val) {\n\t\t$netVolumes = $this->getNetVolumes();\n\t\tif (is_string($netKey) && isset($netVolumes[$netKey]) && is_string($optionKey)) {\n\t\t\t$netVolumes[$netKey][$optionKey] = $val;\n\t\t}\n\t}\n\t\n\t/**\n\t * Return network volumes config.\n\t *\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t */\n\tprotected function getNetVolumes() {\n\t\tif ($data = $this->session->get('netvolume', array())) {\n\t\t\treturn $data;\n\t\t}\n\t\treturn array();\n\t}\n\n\t/**\n\t * Save network volumes config.\n\t *\n\t * @param  array  $volumes  volumes config\n\t * @return void\n\t * @author Dmitry (dio) Levashov\n\t */\n\tprotected function saveNetVolumes($volumes) {\n\t\t$this->session->set('netvolume', $volumes);\n\t}\n\n\t/**\n\t * Remove netmount volume\n\t *\n\t * @param string $key netvolume key\n\t * @param object $volume volume driver instance\n\t * @return bool\n\t */\n\tprotected function removeNetVolume($key, $volume) {\n\t\t$netVolumes = $this->getNetVolumes();\n\t\t$res = true;\n\t\tif (is_object($volume) && method_exists($volume, 'netunmount')) {\n\t\t\t$res = $volume->netunmount($netVolumes, $key);\n\t\t\t$volume->clearSessionCache();\n\t\t}\n\t\tif ($res) {\n\t\t\tif (is_string($key) && isset($netVolumes[$key])) {\n\t\t\t\tunset($netVolumes[$key]);\n\t\t\t\t$this->saveNetVolumes($netVolumes);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get plugin instance & set to $this->plugins\n\t * \n\t * @param  string $name   Plugin name (dirctory name)\n\t * @param  array  $opts   Plugin options (optional)\n\t * @return object | bool Plugin object instance Or false\n\t * @author Naoki Sawada\n\t */\n\tprotected function getPluginInstance($name, $opts = array()) {\n\t\t$key = strtolower($name);\n\t\tif (! isset($this->plugins[$key])) {\n\t\t\t$class = 'elFinderPlugin' . $name;\n\t\t\t// to try auto load\n\t\t\tif (! class_exists($class)) {\n\t\t\t\t$p_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'plugins' . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'plugin.php';\n\t\t\t\tif (is_file($p_file)) {\n\t\t\t\t\tinclude_once $p_file;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (class_exists($class, false)) {\n\t\t\t\t$this->plugins[$key] = new $class($opts);\n\t\t\t} else {\n\t\t\t\t$this->plugins[$key] = false;\n\t\t\t}\n\t\t}\n\t\treturn $this->plugins[$key];\n\t}\n\n\t/***************************************************************************/\n\t/*                                 commands                                */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Normalize error messages\n\t *\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function error() {\n\t\t$errors = array();\n\n\t\tforeach (func_get_args() as $msg) {\n\t\t\tif (is_array($msg)) {\n\t\t\t\t$errors = array_merge($errors, $msg);\n\t\t\t} else {\n\t\t\t\t$errors[] = $msg;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn count($errors) ? $errors : array(self::ERROR_UNKNOWN);\n\t}\n\t\n\tprotected function netmount($args) {\n\t\t$options  = array();\n\t\t$protocol = $args['protocol'];\n\t\t$toast = '';\n\t\t\n\t\tif ($protocol === 'netunmount') {\n\t\t\tif (! empty($args['user']) && $volume = $this->volume($args['user'])) {\n\t\t\t\tif ($this->removeNetVolume($args['host'], $volume)) {\n\t\t\t\t\treturn array('removed' => array(array('hash' => $volume->root())));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn array('sync' => true, 'error' => $this->error(self::ERROR_NETUNMOUNT));\n\t\t}\n\t\t\n\t\t$driver   = isset(self::$netDrivers[$protocol]) ? self::$netDrivers[$protocol] : '';\n\t\t$class    = 'elFinderVolume'.$driver;\n\n\t\tif (!class_exists($class)) {\n\t\t\treturn array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], self::ERROR_NETMOUNT_NO_DRIVER));\n\t\t}\n\n\t\tif (!$args['path']) {\n\t\t\t$args['path'] = '/';\n\t\t}\n\n\t\tforeach ($args as $k => $v) {\n\t\t\tif ($k != 'options' && $k != 'protocol' && $v) {\n\t\t\t\t$options[$k] = $v;\n\t\t\t}\n\t\t}\n\n\t\tif (is_array($args['options'])) {\n\t\t\tforeach ($args['options'] as $key => $value) {\n\t\t\t\t$options[$key] = $value;\n\t\t\t}\n\t\t}\n\n\t\t$volume = new $class();\n\t\t\n\t\t// pass session handler\n\t\t$volume->setSession($this->session);\n\t\t\n\t\tif (is_callable(array($volume, 'netmountPrepare'))) {\n\t\t\t$options = $volume->netmountPrepare($options);\n\t\t\tif (isset($options['exit'])) {\n\t\t\t\tif ($options['exit'] === 'callback') {\n\t\t\t\t\t$this->callback($options['out']);\n\t\t\t\t}\n\t\t\t\treturn $options;\n\t\t\t}\n\t\t\tif (!empty($options['toast'])) {\n\t\t\t\t$toast = $options['toast'];\n\t\t\t\tunset($options['toast']);\n\t\t\t}\n\t\t}\n\t\t\n\t\t$netVolumes = $this->getNetVolumes();\n\t\t\n\t\tif (! isset($options['id'])) {\n\t\t\t// given fixed unique id\n\t\t\tif (! $options['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], 'Could\\'t given volume id.'));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// load additional volume root options\n\t\tif (! empty($this->optionsNetVolumes['*'])) {\n\t\t\t$options = array_merge($this->optionsNetVolumes['*'], $options);\n\t\t}\n\t\tif (! empty($this->optionsNetVolumes[$protocol])) {\n\t\t\t$options = array_merge($this->optionsNetVolumes[$protocol], $options);\n\t\t}\n\t\t\n\t\tif (! $key =  $volume->netMountKey) {\n\t\t\t$key = md5($protocol . '-' . serialize($options));\n\t\t}\n\t\t$options['netkey'] = $key;\n\t\t\n\t\tif (!isset($netVolumes[$key]) && $volume->mount($options)) {\n\t\t\t// call post-process function of netmount\n\t\t\tif (is_callable(array($volume, 'postNetmount'))) {\n\t\t\t\t$volume->postNetmount($options);\n\t\t\t}\n\t\t\t$options['driver'] = $driver;\n\t\t\t$netVolumes[$key]  = $options;\n\t\t\t$this->saveNetVolumes($netVolumes);\n\t\t\t$rootstat = $volume->file($volume->root());\n\t\t\t$res = array('added' => array($rootstat));\n\t\t\tif ($toast) {\n\t\t\t\t$res['toast'] = $toast;\n\t\t\t}\n\t\t\treturn $res;\n\t\t} else {\n\t\t\t$this->removeNetVolume(null, $volume);\n\t\t\treturn array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], implode(' ', $volume->error())));\n\t\t}\n\t}\n\n\t/**\n\t * \"Open\" directory\n\t * Return array with following elements\n\t *  - cwd          - opened dir info\n\t *  - files        - opened dir content [and dirs tree if $args[tree]]\n\t *  - api          - api version (if $args[init])\n\t *  - uplMaxSize   - if $args[init]\n\t *  - error        - on failed\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function open($args) {\n\t\t$target = $args['target'];\n\t\t$init   = !empty($args['init']);\n\t\t$tree   = !empty($args['tree']);\n\t\t$volume = $this->volume($target);\n\t\t$cwd    = $volume ? $volume->dir($target) : false;\n\t\t$hash   = $init ? 'default folder' : '#'.$target;\n\t\t$sleep  = 0;\n\t\t$compare = '';\n\n\t\t// on init request we can get invalid dir hash -\n\t\t// dir which can not be opened now, but remembered by client,\n\t\t// so open default dir\n\t\tif ((!$cwd || !$cwd['read']) && $init) {\n\t\t\t$volume = $this->default;\n\t\t\t$target = $volume->defaultPath();\n\t\t\t$cwd    = $volume->dir($target);\n\t\t}\n\t\t\n\t\tif (!$cwd) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_DIR_NOT_FOUND));\n\t\t}\n\t\tif (!$cwd['read']) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_PERM_DENIED));\n\t\t}\n\n\t\t$files = array();\n\n\t\t// get current working directory files list\n\t\tif (($ls = $volume->scandir($cwd['hash'])) === false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n\t\t}\n\t\t\n\t\tif (isset($cwd['dirs']) && $cwd['dirs'] != 1) {\n\t\t\t$cwd = $volume->dir($target);\n\t\t}\n\t\t\n\t\t// get other volume root\n\t\tif ($tree) {\n\t\t\tforeach ($this->volumes as $id => $v) {\n\t\t\t\t$files[] = $v->file($v->root());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// long polling mode\n\t\tif ($args['compare']) {\n\t\t\t$sleep = max(1, (int)$volume->getOption('lsPlSleep'));\n\t\t\t$standby = (int)$volume->getOption('plStandby');\n\t\t\tif ($standby > 0 && $sleep > $standby) {\n\t\t\t\t$standby = $sleep;\n\t\t\t}\n\t\t\t$limit = max(0, floor($standby / $sleep)) + 1;\n\t\t\tdo {\n\t\t\t\telFinder::extendTimeLimit(30 + $sleep);\n\t\t\t\t$_mtime = 0;\n\t\t\t\tforeach($ls as $_f) {\n\t\t\t\t\t$_mtime = max($_mtime, $_f['ts']);\n\t\t\t\t}\n\t\t\t\t$compare = strval(count($ls)).':'.strval($_mtime);\n\t\t\t\tif ($compare !== $args['compare']) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (--$limit) {\n\t\t\t\t\tsleep($sleep);\n\t\t\t\t\t$volume->clearstatcache();\n\t\t\t\t\tif (($ls = $volume->scandir($cwd['hash'])) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while($limit);\n\t\t\tif ($ls === false) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($ls) {\n\t\t\tif ($files) {\n\t\t\t\t$files = array_merge($files, $ls);\n\t\t\t} else {\n\t\t\t\t$files = $ls;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array(\n\t\t\t'cwd'     => $cwd,\n\t\t\t'options' => $volume->options($cwd['hash']),\n\t\t\t'files'   => $files\n\t\t);\n\t\t\n\t\tif ($compare) {\n\t\t\t$result['cwd']['compare'] = $compare;\n\t\t}\n\t\t\n\t\tif (!empty($args['init'])) {\n\t\t\t$result['api'] = sprintf('%.1F%03d', self::$ApiVersion, self::$ApiRevision);\n\t\t\t$result['uplMaxSize'] = ini_get('upload_max_filesize');\n\t\t\t$result['uplMaxFile'] = ini_get('max_file_uploads');\n\t\t\t$result['netDrivers'] = array_keys(self::$netDrivers);\n\t\t\t$result['maxTargets'] = $this->maxTargets;\n\t\t\tif ($volume) {\n\t\t\t\t$result['cwd']['root'] = $volume->root();\n\t\t\t}\n\t\t\tif (elfinder::$textMimes) {\n\t\t\t\t$result['textMimes'] = elfinder::$textMimes;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return dir files names list\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function ls($args) {\n\t\t$target = $args['target'];\n\t\t$intersect = isset($args['intersect'])? $args['intersect'] : array();\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($list = $volume->ls($target, $intersect)) === false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t}\n\t\treturn array('list' => $list);\n\t}\n\t\n\t/**\n\t * Return subdirs for required directory\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function tree($args) {\n\t\t$target = $args['target'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($tree = $volume->tree($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t}\n\n\t\treturn array('tree' => $tree);\n\t}\n\t\n\t/**\n\t * Return parents dir for required directory\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function parents($args) {\n\t\t$target = $args['target'];\n\t\t$until = $args['until'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($tree = $volume->parents($target, false, $until)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t}\n\n\t\treturn array('tree' => $tree);\n\t}\n\t\n\t/**\n\t * Return new created thumbnails list\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function tmb($args) {\n\t\t\n\t\t$result  = array('images' => array());\n\t\t$targets = $args['targets'];\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($volume = $this->volume($target)) != false\n\t\t\t&& (($tmb = $volume->tmb($target)) != false)) {\n\t\t\t\t$result['images'][$target] = $tmb;\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Download files/folders as an archive file\n\t * \n\t * 1st: Return srrsy contains download archive file info\n\t * 2nd: Return array contains opened file pointer, root itself and required headers\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Naoki Sawada\n\t **/\n\tprotected function zipdl($args) {\n\t\t$targets = $args['targets'];\n\t\t$download = !empty($args['download']);\n\t\t$h404    = 'HTTP/1.x 404 Not Found';\n\t\t\n\t\tif (!$download) {\n\t\t\t//1st: Return srrsy contains download archive file info\n\t\t\t$error = array(self::ERROR_ARCHIVE);\n\t\t\tif (($volume = $this->volume($targets[0])) !== false) {\n\t\t\t\tif ($dlres = $volume->zipdl($targets)) {\n\t\t\t\t\t$path = $dlres['path'];\n\t\t\t\t\tregister_shutdown_function(array('elFinder', 'rmFileInDisconnected'), $path);\n\t\t\t\t\tif (count($targets) === 1) {\n\t\t\t\t\t\t$name = basename($volume->path($targets[0]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$name = $dlres['prefix'].'_Files';\n\t\t\t\t\t}\n\t\t\t\t\t$name .= '.'.$dlres['ext'];\n\t\t\t\t\t$result = array(\n\t\t\t\t\t\t'zipdl' => array(\n\t\t\t\t\t\t\t'file' => basename($path),\n\t\t\t\t\t\t\t'name' => $name,\n\t\t\t\t\t\t\t'mime' => $dlres['mime']\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn $result;\n\t\t\t\t}\n\t\t\t\t$error = array_merge($error, $volume->error());\n\t\t\t}\n\t\t\treturn array('error' => $error);\n\t\t} else {\n\t\t\t// 2nd: Return array contains opened file pointer, root itself and required headers\n\t\t\tif (count($targets) !== 4 || ($volume = $this->volume($targets[0])) == false) {\n\t\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t\t}\n\t\t\t$file = $targets[1];\n\t\t\t$path = $volume->getTempPath().DIRECTORY_SEPARATOR.$file;\n\t\t\t// register auto delete on shutdown\n\t\t\t$GLOBALS['elFinderTempFiles'][$path] = true;\n\t\t\tif (!is_readable($path)) {\n\t\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t\t}\n\t\t\t$name = $targets[2];\n\t\t\t$mime = $targets[3];\n\t\t\t\n\t\t\t$filenameEncoded = rawurlencode($name);\n\t\t\tif (strpos($filenameEncoded, '%') === false) { // ASCII only\n\t\t\t\t$filename = 'filename=\"'.$name.'\"';\n\t\t\t} else {\n\t\t\t\t$ua = $_SERVER['HTTP_USER_AGENT'];\n\t\t\t\tif (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t\t$filename = 'filename=\"'.$filenameEncoded.'\"';\n\t\t\t\t} elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n\t\t\t\t\t$filename = 'filename=\"'.str_replace('\"', '', $name).'\"';\n\t\t\t\t} else { // RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t\t$filename = 'filename*=UTF-8\\'\\''.$filenameEncoded;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$fp = fopen($path, 'rb');\n\t\t\t$file = fstat($fp);\n\t\t\t$result = array(\n\t\t\t\t'pointer' => $fp,\n\t\t\t\t'header'  => array(\n\t\t\t\t\t'Content-Type: '.$mime, \n\t\t\t\t\t'Content-Disposition: attachment; '.$filename,\n\t\t\t\t\t'Content-Transfer-Encoding: binary',\n\t\t\t\t\t'Content-Length: '.$file['size'],\n\t\t\t\t\t'Accept-Ranges: none',\n\t\t\t\t\t'Connection: close'\n\t\t\t\t)\n\t\t\t);\n\t\t\treturn $result;\n\t\t}\n\t}\n\t\n\t/**\n\t * Required to output file in browser when volume URL is not set \n\t * Return array contains opened file pointer, root itself and required headers\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function file($args) {\n\t\t$target   = $args['target'];\n\t\t$download = !empty($args['download']);\n\t\t$h403     = 'HTTP/1.0 403 Access Denied';\n\t\t$h404     = 'HTTP/1.0 404 Not Found';\n\t\t$h304     = 'HTTP/1.1 304 Not Modified';\n\n\t\tif (($volume = $this->volume($target)) == false) { \n\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t}\n\t\t\n\t\tif (($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t}\n\t\t\n\t\tif (!$file['read']) {\n\t\t\treturn array('error' => 'Access denied', 'header' => $h403, 'raw' => true);\n\t\t}\n\t\t\n\t\tif (($fp = $volume->open($target)) == false) {\n\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t}\n\n\t\t// allow change MIME type by 'file.pre' callback functions\n\t\t$mime = isset($args['mime'])? $args['mime'] : $file['mime'];\n\t\tif ($download) {\n\t\t\t$disp = 'attachment';\n\t\t} else {\n\t\t\t$dispInlineRegex = $volume->getOption('dispInlineRegex');\n\t\t\t$inlineRegex = false;\n\t\t\tif ($dispInlineRegex) {\n\t\t\t\t$inlineRegex = '#' . str_replace('#', '\\\\#', $dispInlineRegex) . '#';\n\t\t\t\ttry {\n\t\t\t\t\tpreg_match($inlineRegex, '');\n\t\t\t\t} catch(Exception $e) {\n\t\t\t\t\t$inlineRegex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!$inlineRegex) {\n\t\t\t\t$inlineRegex = '#^(?:(?:image|text)|application/x-shockwave-flash$)#';\n\t\t\t}\n\t\t\t$disp  = preg_match($inlineRegex, $mime)? 'inline' : 'attachment';\n\t\t}\n\t\t\n\t\t$filenameEncoded = rawurlencode($file['name']);\n\t\tif (strpos($filenameEncoded, '%') === false) { // ASCII only\n\t\t\t$filename = 'filename=\"'.$file['name'].'\"';\n\t\t} else {\n\t\t\t$ua = $_SERVER['HTTP_USER_AGENT'];\n\t\t\tif (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t$filename = 'filename=\"'.$filenameEncoded.'\"';\n\t\t\t} elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n\t\t\t\t$filename = 'filename=\"'.str_replace('\"', '', $file['name']).'\"';\n\t\t\t} else { // RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t$filename = 'filename*=UTF-8\\'\\''.$filenameEncoded;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array(\n\t\t\t'volume'  => $volume,\n\t\t\t'pointer' => $fp,\n\t\t\t'info'    => $file,\n\t\t\t'header'  => array(\n\t\t\t\t'Content-Type: '.$mime, \n\t\t\t\t'Content-Disposition: '.$disp.'; '.$filename,\n\t\t\t\t'Content-Transfer-Encoding: binary',\n\t\t\t\t'Content-Length: '.$file['size'],\n\t\t\t\t'Last-Modified: '.gmdate('D, d M Y H:i:s T', $file['ts']),\n\t\t\t\t'Connection: close'\n\t\t\t)\n\t\t);\n\t\t\n\t\t// add cache control headers\n\t\tif ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n\t\t\t$result['header'] = array_merge($result['header'], $cacheHeaders);\n\t\t}\n\t\t\n\t\t// check 'xsendfile'\n\t\t$xsendfile = $volume->getOption('xsendfile');\n\t\t$path = null;\n\t\tif ($xsendfile) {\n\t\t\t$info = stream_get_meta_data($fp);\n\t\t\tif ($path = empty($info['uri'])? null : $info['uri']) {\n\t\t\t\t$basePath = rtrim($volume->getOption('xsendfilePath'), DIRECTORY_SEPARATOR);\n\t\t\t\tif ($basePath) {\n\t\t\t\t\t$root = rtrim($volume->getRootPath(), DIRECTORY_SEPARATOR);\n\t\t\t\t\tif (strpos($path, $root) === 0) {\n\t\t\t\t\t\t$path = $basePath . substr($path, strlen($root));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$path = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($path) {\n\t\t\t$result['header'][] = $xsendfile . ': ' . $path;\n\t\t\t$result['info']['xsendfile'] = $xsendfile;\n\t\t}\n\t\t\n\t\t// add \"Content-Location\" if file has url data\n\t\tif (isset($file['url']) && $file['url'] && $file['url'] != 1) {\n\t\t\t$result['header'][] = 'Content-Location: '.$file['url'];\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Count total files size\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function size($args) {\n\t\t$size = 0;\n\t\t$files = 0;\n\t\t$dirs = 0;\n\t\t$itemCount = true;\n\t\t$sizes = array();\n\t\t\n\t\tforeach ($args['targets'] as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\tif (($volume = $this->volume($target)) == false\n\t\t\t|| ($file = $volume->file($target)) == false\n\t\t\t|| !$file['read']) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t\t}\n\t\t\t\n\t\t\t$volRes = $volume->size($target);\n\t\t\tif (is_array($volRes)) {\n\t\t\t\t$sizeInfo = array('size' => 0, 'fileCnt' => 0, 'dirCnt' => 0);\n\t\t\t\tif (! empty($volRes['size'])) {\n\t\t\t\t\t$sizeInfo['size'] = $volRes['size'];\n\t\t\t\t\t$size += $volRes['size'];\n\t\t\t\t}\n\t\t\t\tif (! empty($volRes['files'])) {\n\t\t\t\t\t$sizeInfo['fileCnt'] = $volRes['files'];\n\t\t\t\t}\n\t\t\t\tif (! empty($volRes['dirs'])) {\n\t\t\t\t\t$sizeInfo['dirCnt'] = $volRes['dirs'];\n\t\t\t\t}\n\t\t\t\tif ($itemCount) {\n\t\t\t\t\t$files += $sizeInfo['fileCnt'];\n\t\t\t\t\t$dirs += $sizeInfo['dirCnt'];\n\t\t\t\t}\n\t\t\t\t$sizes[$target] = $sizeInfo;\n\t\t\t} else if (is_numeric($volRes)) {\n\t\t\t\t$size += $volRes;\n\t\t\t\t$files = $dirs = 'unknown';\n\t\t\t\t$itemCount = false;\n\t\t\t}\n\t\t}\n\t\treturn array('size' => $size, 'fileCnt' => $files, 'dirCnt' => $dirs, 'sizes' => $sizes);\n\t}\n\t\n\t/**\n\t * Create directory\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function mkdir($args) {\n\t\t$target = $args['target'];\n\t\t$name   = $args['name'];\n\t\t$dirs   = $args['dirs'];\n\t\tif ($name === '' && !$dirs) {\n\t\t\treturn array('error' => $this->error(self::ERROR_INV_PARAMS, 'mkdir'));\n\t\t}\n\t\t\n\t\tif (($volume = $this->volume($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_MKDIR, $name, self::ERROR_TRGDIR_NOT_FOUND, '#'.$target));\n\t\t}\n\t\tif ($dirs) {\n\t\t\tsort($dirs);\n\t\t\t$reset = null;\n\t\t\t$mkdirs = array();\n\t\t\tforeach($dirs as $dir) {\n\t\t\t\t$tgt =& $mkdirs;\n\t\t\t\t$_names = explode('/', trim($dir, '/'));\n\t\t\t\tforeach($_names as $_key => $_name) {\n\t\t\t\t\tif (! isset($tgt[$_name])) {\n\t\t\t\t\t\t$tgt[$_name] = array();\n\t\t\t\t\t}\n\t\t\t\t\t$tgt =& $tgt[$_name];\n\t\t\t\t}\n\t\t\t\t$tgt =& $reset;\n\t\t\t}\n\t\t\t$res = $this->ensureDirsRecursively($volume, $target, $mkdirs);\n\t\t\tif ($res['error']) {\n\t\t\t\t$errors = $volume->error();\n\t\t\t\tif ($res['makes']) {\n\t\t\t\t\t$this->rm(array('targets' => $res['makes']));\n\t\t\t\t}\n\t\t\t\treturn array('error' => $this->error(self::ERROR_MKDIR, $res['error'][0], $errors));\n\t\t\t} else {\n\t\t\t\treturn array('added' => $res['stats'], 'hashes' => $res['hashes']);\n\t\t\t}\n\t\t} else {\n\t\t\treturn ($dir = $volume->mkdir($target, $name)) == false\n\t\t\t\t? array('error' => $this->error(self::ERROR_MKDIR, $name, $volume->error()))\n\t\t\t\t: array('added' => array($dir));\n\t\t}\n\t}\n\t\n\t/**\n\t * Create empty file\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function mkfile($args) {\n\t\t$target = $args['target'];\n\t\t$name   = $args['name'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_MKFILE, $name, self::ERROR_TRGDIR_NOT_FOUND, '#'.$target));\n\t\t}\n\n\t\treturn ($file = $volume->mkfile($target, $args['name'])) == false\n\t\t\t? array('error' => $this->error(self::ERROR_MKFILE, $name, $volume->error()))\n\t\t\t: array('added' => array($file));\n\t}\n\t\n\t/**\n\t * Rename file, Accept multiple items >= API 2.1031\n\t *\n\t * @param  array  $args\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t * @author Naoki Sawada\n\t **/\n\tprotected function rename($args) {\n\t\t$target = $args['target'];\n\t\t$name = $args['name'];\n\t\t$query = (strpos($args['q'], '*') !== false)? $args['q'] : '';\n\t\t$targets = $args['targets'];\n\t\t$rms = array();\n\t\t$notfounds = array();\n\t\t$locked = array();\n\t\t$errs = array();\n\t\t$files = array();\n\t\t$removed = array();\n\t\t$res = array();\n\t\t$type = 'normal';\n\t\t\n\t\tif (!($volume = $this->volume($target))) {\n\t\t\treturn array('error' => $this->error(self::ERROR_RENAME, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\tif ($targets) {\n\t\t\tarray_unshift($targets, $target);\n\t\t\tforeach($targets as $h) {\n\t\t\t\tif ($rm = $volume->file($h)) {\n\t\t\t\t\tif ($this->itemLocked($h)) {\n\t\t\t\t\t\t$locked[] = $rm['name'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$rm['realpath'] = $volume->realpath($h);\n\t\t\t\t\t\t$rms[] = $rm;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$notfounds[] = '#'.$h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!$rms) {\n\t\t\t\t$res['error'] = array();\n\t\t\t\tif ($notfounds) {\n\t\t\t\t\t$res['error'] = array(self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n\t\t\t\t}\n\t\t\t\tif ($locked) {\n\t\t\t\t\tarray_push($res['error'], self::ERROR_LOCKED, join(', ',$locked));\n\t\t\t\t}\n\t\t\t\treturn $res;\n\t\t\t}\n\t\t\t\n\t\t\t$res['warning'] = array();\n\t\t\tif ($notfounds) {\n\t\t\t\tarray_push($res['warning'], self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n\t\t\t}\n\t\t\tif ($locked) {\n\t\t\t\tarray_push($res['warning'], self::ERROR_LOCKED, join(', ',$locked));\n\t\t\t}\n\t\t\t\n\t\t\tif ($query) {\n\t\t\t\t// batch rename\n\t\t\t\t$splits = elFinder::splitFileExtention($query);\n\t\t\t\tif ($splits[1] && $splits[0] === '*') {\n\t\t\t\t\t$type = 'extention';\n\t\t\t\t\t$name = $splits[1];\n\t\t\t\t} else if (strlen($splits[0]) > 1) {\n\t\t\t\t\tif (substr($splits[0], -1) === '*') {\n\t\t\t\t\t\t$type = 'prefix';\n\t\t\t\t\t\t$name = substr($splits[0], 0 ,strlen($splits[0]) - 1);\n\t\t\t\t\t} else if (substr($splits[0], 0, 1) === '*') {\n\t\t\t\t\t\t$type = 'suffix';\n\t\t\t\t\t\t$name = substr($splits[0], 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($type !== 'normal') {\n\t\t\t\t\tif (!empty($this->listeners['rename.pre'])) {\n\t\t\t\t\t\t$_args = array('name' => $name);\n\t\t\t\t\t\tforeach ($this->listeners['rename.pre'] as $handler) {\n\t\t\t\t\t\t\t$_res = call_user_func_array($handler, array('rename', &$_args, $this, $volume));\n\t\t\t\t\t\t\tif (! empty($_res['preventexec'])) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$name = $_args['name'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach($rms as $rm) {\n\t\t\t\tif ($type === 'normal') {\n\t\t\t\t\t$rname = $volume->uniqueName($volume->realpath($rm['phash']), $name, '', false);\n\t\t\t\t} else {\n\t\t\t\t\tif ($type === 'extention') {\n\t\t\t\t\t\t$splits = elFinder::splitFileExtention($rm['name']);\n\t\t\t\t\t\t$rname = $splits[0] . '.' . $name;\n\t\t\t\t\t} else if ($type === 'prefix') {\n\t\t\t\t\t\t$rname = $name . $rm['name'];\n\t\t\t\t\t} else if ($type === 'suffix') {\n\t\t\t\t\t\t$splits = elFinder::splitFileExtention($rm['name']);\n\t\t\t\t\t\t$rname = $splits[0]. $name . ($splits[1]? ('.' . $splits[1]) : '');\n\t\t\t\t\t}\n\t\t\t\t\t$rname = $volume->uniqueName($volume->realpath($rm['phash']), $rname, '', true);\n\t\t\t\t}\n\t\t\t\tif ($file = $volume->rename($rm['hash'], $rname)) {\n\t\t\t\t\t$files[] = $file;\n\t\t\t\t\t$removed[] = $rm;\n\t\t\t\t} else {\n\t\t\t\t\t$errs[] = $rm['name'];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!$files) {\n\t\t\t\t$res['error'] = $this->error(self::ERROR_RENAME, join(', ', $errs), $volume->error());\n\t\t\t\tif (!$res['warning']) {\n\t\t\t\t\tunset($res['warning']);\n\t\t\t\t}\n\t\t\t\treturn $res;\n\t\t\t}\n\t\t\tif ($errs) {\n\t\t\t\tarray_push($res['warning'], self::ERROR_RENAME, join(', ', $errs), $volume->error());\n\t\t\t}\n\t\t\tif (!$res['warning']) {\n\t\t\t\tunset($res['warning']);\n\t\t\t}\n\t\t\t$res['added'] = $files;\n\t\t\t$res['removed'] = $removed;\n\t\t\treturn $res;\n\t\t} else {\n\t\t\tif (!($rm = $volume->file($target))) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_RENAME, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t\t}\n\t\t\tif ($this->itemLocked($target)) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_LOCKED, $rm['name']));\n\t\t\t}\n\t\t\t$rm['realpath'] = $volume->realpath($target);\n\t\t\t\n\t\t\treturn ($file = $volume->rename($target, $name)) == false\n\t\t\t\t? array('error' => $this->error(self::ERROR_RENAME, $rm['name'], $volume->error()))\n\t\t\t\t: array('added' => array($file), 'removed' => array($rm));\n\t\t}\n\t}\n\t\n\t/**\n\t * Duplicate file - create copy with \"copy %d\" suffix\n\t *\n\t * @param array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function duplicate($args) {\n\t\t$targets = is_array($args['targets']) ? $args['targets'] : array();\n\t\t$result  = array('added' => array());\n\t\t$suffix  = empty($args['suffix']) ? 'copy' : $args['suffix'];\n\t\t\n\t\t$this->itemLock($targets);\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($volume = $this->volume($target)) == false\n\t\t\t|| ($src = $volume->file($target)) == false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_COPY, '#'.$target, self::ERROR_FILE_NOT_FOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (($file = $volume->duplicate($target, $suffix)) == false) {\n\t\t\t\t$result['warning'] = $this->error($volume->error());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t$result['added'][] = $file;\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\t\n\t/**\n\t * Remove dirs/files\n\t *\n\t * @param array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function rm($args) {\n\t\t$targets = is_array($args['targets']) ? $args['targets'] : array();\n\t\t$result  = array('removed' => array());\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($volume = $this->volume($target)) == false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_RM, '#'.$target, self::ERROR_FILE_NOT_FOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->itemLocked($target)) {\n\t\t\t\t$rm = $volume->file($target);\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_LOCKED, $rm['name']);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (!$volume->rm($target)) {\n\t\t\t\t$result['warning'] = $this->error($volume->error());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Return has subdirs\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry Naoki Sawada\n\t **/\n\tprotected function subdirs($args) {\n\t\n\t\t$result  = array('subdirs' => array());\n\t\t$targets = $args['targets'];\n\t\n\t\tforeach ($targets as $target) {\n\t\t\tif (($volume = $this->volume($target)) !== false) {\n\t\t\t\t$result['subdirs'][$target] = $volume->subdirs($target)? 1 : 0;\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Gateway for custom contents editor\n\t * \n\t * @param  array $args command arguments\n\t * @return array\n\t * @author Naoki Sawada\n\t */\n\tprotected function editor($args = array()) {\n\t\t$name = $args['name'];\n\t\tif (is_array($name)) {\n\t\t\t$res = array();\n\t\t\tforeach($name as $c) {\n\t\t\t\t$class = 'elFinderEditor' . $c;\n\t\t\t\tif (class_exists($class)) {\n\t\t\t\t\t$editor = new $class($this, $args['args']);\n\t\t\t\t\t$res[$c] = $editor->enabled();\n\t\t\t\t} else {\n\t\t\t\t\t$res[$c] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $res;\n\t\t} else {\n\t\t\t$class = 'elFinderEditor' . $name;\n\t\t\tif (class_exists($class)) {\n\t\t\t\t$editor = new $class($this, $args['args']);\n\t\t\t\t$method = $args['method'];\n\t\t\t\tif ($editor->isAllowedMethod($method) && method_exists($editor, $method)) {\n\t\t\t\t\treturn $editor->$method();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn array('error', $this->error(self::ERROR_UNKNOWN_CMD, 'editor.'.$name.'.'.$method));\n\t\t}\n\t}\n\n\t/**\n\t * Abort current request and make flag file to running check\n\t * \n\t * @param array $args\n\t * @return void\n\t */\n\tprotected function abort($args = array()) {\n\t\tif (! elFinder::$connectionFlagsPath || $_SERVER['REQUEST_METHOD'] === 'HEAD') {\n\t\t\treturn;\n\t\t}\n\t\t$flagFile = elFinder::$connectionFlagsPath . DIRECTORY_SEPARATOR . 'elfreq%s';\n\t\tif (! empty($args['makeFile'])) {\n\t\t\tself::$abortCheckFile = sprintf($flagFile, $args['makeFile']);\n\t\t\ttouch(self::$abortCheckFile);\n\t\t\t$GLOBALS['elFinderTempFiles'][self::$abortCheckFile] = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$file = ! empty($args['id'])? sprintf($flagFile, $args['id']) : self::$abortCheckFile;\n\t\t$file && is_file($file) && unlink($file);\n\t}\n\t\n\t/**\n\t* Get remote contents\n\t*\n\t* @param  string   $url     target url\n\t* @param  int      $timeout timeout (sec)\n\t* @param  int      $redirect_max redirect max count\n\t* @param  string   $ua\n\t* @param  resource $fp\n\t* @return string or bool(false)\n\t* @retval string contents\n\t* @rettval false  error\n\t* @author Naoki Sawada\n\t**/\n\tprotected function get_remote_contents( &$url, $timeout = 30, $redirect_max = 5, $ua = 'Mozilla/5.0', $fp = null ) {\n\t\t$method = (function_exists('curl_exec') && !ini_get('safe_mode') && !ini_get('open_basedir'))? 'curl_get_contents' : 'fsock_get_contents'; \n\t\treturn $this->$method( $url, $timeout, $redirect_max, $ua, $fp );\n\t}\n\t\n\t/**\n\t * Get remote contents with cURL\n\t *\n\t * @param  string   $url     target url\n\t * @param  int      $timeout timeout (sec)\n\t * @param  int      $redirect_max redirect max count\n\t * @param  string   $ua\n\t * @param  resource $outfp\n\t * @return string or bool(false)\n\t * @retval string contents\n\t * @retval false  error\n\t * @author Naoki Sawada\n\t **/\n\t protected function curl_get_contents( &$url, $timeout, $redirect_max, $ua, $outfp ){\n\t\t$ch = curl_init();\n\t\tcurl_setopt( $ch, CURLOPT_URL, $url );\n\t\tcurl_setopt( $ch, CURLOPT_HEADER, false );\n\t\tif ($outfp) {\n\t\t\tcurl_setopt( $ch, CURLOPT_FILE, $outfp );\n\t\t} else {\n\t\t\tcurl_setopt( $ch, CURLOPT_RETURNTRANSFER, true );\n\t\t\tcurl_setopt( $ch, CURLOPT_BINARYTRANSFER, true );\n\t\t}\n\t\tcurl_setopt( $ch, CURLOPT_LOW_SPEED_LIMIT, 1 );\n\t\tcurl_setopt( $ch, CURLOPT_LOW_SPEED_TIME, $timeout );\n\t\tcurl_setopt( $ch, CURLOPT_SSL_VERIFYPEER, false );\n\t\tcurl_setopt( $ch, CURLOPT_FOLLOWLOCATION, 1);\n\t\tcurl_setopt( $ch, CURLOPT_MAXREDIRS, $redirect_max);\n\t\tcurl_setopt( $ch, CURLOPT_USERAGENT, $ua);\n\t\t$result = curl_exec( $ch );\n\t\t$url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);\n\t\tcurl_close( $ch );\n\t\treturn $outfp? $outfp : $result;\n\t}\n\t\n\t/**\n\t * Get remote contents with fsockopen()\n\t *\n\t * @param  string   $url          url\n\t * @param  int      $timeout      timeout (sec)\n\t * @param  int      $redirect_max redirect max count\n\t * @param  string   $ua\n\t * @param  resource $outfp\n\t * @return string or bool(false)\n\t * @retval string contents\n\t * @retval false  error\n\t * @author Naoki Sawada\n\t */\n\tprotected function fsock_get_contents( &$url, $timeout, $redirect_max, $ua, $outfp ) {\n\t\t$connect_timeout = 3;\n\t\t$connect_try = 3;\n\t\t$method = 'GET';\n\t\t$readsize = 4096;\n\t\t$ssl = '';\n\n\t\t$getSize = null;\n\t\t$headers = '';\n\t\t\n\t\t$arr = parse_url($url);\n\t\tif (!$arr){\n\t\t\t// Bad request\n\t\t\treturn false;\n\t\t}\n\t\tif ($arr['scheme'] === 'https') {\n\t\t\t$ssl = 'ssl://';\n\t\t}\n\t\t\n\t\t// query\n\t\t$arr['query'] = isset($arr['query']) ? '?'.$arr['query'] : '';\n\t\t// port\n\t\t$port = isset($arr['port']) ? $arr['port'] : '';\n\t\t$arr['port'] = $port? $port : ($ssl? 443 : 80);\n\t\t\n\t\t$url_base = $arr['scheme'].'://'.$arr['host'].($port? (':'.$port) : '');\n\t\t$url_path = isset($arr['path']) ? $arr['path'] : '/';\n\t\t$uri = $url_path.$arr['query'];\n\t\t\n\t\t$query = $method.' '.$uri.\" HTTP/1.0\\r\\n\";\n\t\t$query .= \"Host: \".$arr['host'].\"\\r\\n\";\n\t\t$query .= \"Accept: */*\\r\\n\";\n\t\t$query .= \"Connection: close\\r\\n\";\n\t\tif (!empty($ua)) $query .= \"User-Agent: \".$ua.\"\\r\\n\";\n\t\tif (!is_null($getSize)) $query .= 'Range: bytes=0-' . ($getSize - 1) . \"\\r\\n\";\n\t\t\n\t\t$query .= $headers;\n\n\t\t$query .= \"\\r\\n\";\n\n\t\t$fp = $connect_try_count = 0;\n\t\twhile( !$fp && $connect_try_count < $connect_try ) {\n\t\n\t\t\t$errno = 0;\n\t\t\t$errstr = \"\";\n\t\t\t$fp =  fsockopen(\n\t\t\t\t$ssl.$arr['host'],\n\t\t\t\t$arr['port'],\n\t\t\t\t$errno,$errstr,$connect_timeout);\n\t\t\tif ($fp) break;\n\t\t\t$connect_try_count++;\n\t\t\tif (connection_aborted()) {\n\t\t\t\tthrow new elFinderAbortException();\n\t\t\t}\n\t\t\tsleep(1); // wait 1sec\n\t\t}\n\t\t\n\t\t$fwrite = 0;\n\t\tfor ($written = 0; $written < strlen($query); $written += $fwrite) {\n\t\t\t$fwrite = fwrite($fp, substr($query, $written));\n\t\t\tif (!$fwrite) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$response = '';\n\t\t\n\t\tif ($timeout) {\n\t\t\tsocket_set_timeout($fp, $timeout);\n\t\t}\n\t\t\n\t\t$_response = '';\n\t\t$header = '';\n\t\twhile($_response !== \"\\r\\n\"){\n\t\t\t$_response = fgets($fp, $readsize);\n\t\t\t$header .= $_response;\n\t\t};\n\t\t\n\t\t$rccd = array_pad(explode(' ',$header,2), 2, ''); // array('HTTP/1.1','200')\n\t\t$rc = (int)$rccd[1];\n\t\t\n\t\t$ret = false;\n\t\t// Redirect\n\t\tswitch ($rc) {\n\t\t\tcase 307: // Temporary Redirect\n\t\t\tcase 303: // See Other\n\t\t\tcase 302: // Moved Temporarily\n\t\t\tcase 301: // Moved Permanently\n\t\t\t\t$matches = array();\n\t\t\t\tif (preg_match('/^Location: (.+?)(#.+)?$/im',$header,$matches) && --$redirect_max > 0) {\n\t\t\t\t\t$_url = $url;\n\t\t\t\t\t$url = trim($matches[1]);\n\t\t\t\t\t$hash = isset($matches[2])? trim($matches[2]) : '';\n\t\t\t\t\tif (!preg_match('/^https?:\\//',$url)) { // no scheme\n\t\t\t\t\t\tif ($url{0} != '/') { // Relative path\n\t\t\t\t\t\t\t// to Absolute path\n\t\t\t\t\t\t\t$url = substr($url_path,0,strrpos($url_path,'/')).'/'.$url;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// add sheme,host\n\t\t\t\t\t\t$url = $url_base.$url;\n\t\t\t\t\t}\n\t\t\t\t\tif ($_url === $url) {\n\t\t\t\t\t\tsleep(1);\n\t\t\t\t\t}\n\t\t\t\t\tfclose($fp);\n\t\t\t\t\treturn $this->fsock_get_contents( $url, $timeout, $redirect_max, $ua, $outfp );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 200:\n\t\t\t\t$ret = true;\n\t\t}\n\t\tif (! $ret) {\n\t\t\tfclose($fp);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$body = '';\n\t\tif (!$outfp) {\n\t\t\t$outfp = fopen('php://temp', 'rwb');\n\t\t\t$body = true;\n\t\t}\n\t\twhile(fwrite($outfp, fread($fp, $readsize))) {\n\t\t\tif ($timeout) {\n\t\t\t\t$_status = socket_get_status($fp);\n\t\t\t\tif ($_status['timed_out']) {\n\t\t\t\t\tfclose($outfp);\n\t\t\t\t\tfclose($fp);\n\t\t\t\t\treturn false; // Request Time-out\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($body) {\n\t\t\trewind($outfp);\n\t\t\t$body = stream_get_contents($outfp);\n\t\t\tfclose($outfp);\n\t\t\t$outfp = null;\n\t\t}\n\t\t\n\t\tfclose($fp);\n\t\t\n\t\treturn $outfp? $outfp : $body; // Data\n\t}\n\t\n\t/**\n\t * Parse Data URI scheme\n\t * \n\t * @param  string $str\n\t * @param  array  $extTable\n\t * @param  array  $args\n\t * @return array\n\t * @author Naoki Sawada\n\t */\n\tprotected function parse_data_scheme($str, $extTable, $args = null) {\n\t\t$data = $name = '';\n\t\t// Scheme 'data://' require `allow_url_fopen` and `allow_url_include`\n\t\tif ($fp = fopen('data://'.substr($str, 5), 'rb')) {\n\t\t\tif ($data = stream_get_contents($fp)) {\n\t\t\t\t$meta = stream_get_meta_data($fp);\n\t\t\t\t$mime = $meta['mediatype'];\n\t\t\t}\n\t\t\tfclose($fp);\n\t\t} else if (preg_match('~^data:(.+?/.+?)?(?:;charset=.+?)?;base64,~', substr($str, 0, 128), $m)) {\n\t\t\t$data = base64_decode(substr($str, strlen($m[0])));\n\t\t\tif ($m[1]) {\n\t\t\t\t$mime = $m[1];\n\t\t\t}\n\t\t}\n\t\tif ($data) {\n\t\t\t$ext = ($mime && isset($extTable[$mime]))? '.' . $extTable[$mime] : '';\n\t\t\t// Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n\t\t\tif (is_array($args['name']) && isset($args['name'][0])) {\n\t\t\t\t$name = $args['name'][0];\n\t\t\t\tif ($ext) {\n\t\t\t\t\t$name = preg_replace('/\\.[^.]*$/', '', $name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$name = substr(md5($data), 0, 8);\n\t\t\t}\n\t\t\t$name .= $ext;\n\t\t} else {\n\t\t\t$data = $name = '';\n\t\t}\n\t\treturn array($data, $name);\n\t}\n\t\n\t/**\n\t * Detect file MIME Type by local path\n\t * \n\t * @param  string $path Local path\n\t * @return string file MIME Type\n\t * @author Naoki Sawada\n\t */\n\tprotected function detectMimeType($path) {\n\t\tstatic $type, $finfo, $volume;\n\t\tif (!$type) {\n\t\t\t$keys = array_keys($this->volumes);\n\t\t\t$volume = $this->volumes[$keys[0]];\n\t\t\t\t\n\t\t\tif (class_exists('finfo', false)) {\n\t\t\t\t$tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n\t\t\t} else {\n\t\t\t\t$tmpFileInfo = false;\n\t\t\t}\n\t\t\t$regexp = '/text\\/x\\-(php|c\\+\\+)/';\n\t\t\tif ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n\t\t\t\t$type = 'finfo';\n\t\t\t\t$finfo = finfo_open(FILEINFO_MIME);\n\t\t\t} elseif (function_exists('mime_content_type')\n\t\t\t\t\t&& preg_match($regexp, array_shift(explode(';', mime_content_type(__FILE__))))) {\n\t\t\t\t\t\t$type = 'mime_content_type';\n\t\t\t} elseif (function_exists('getimagesize')) {\n\t\t\t\t$type = 'getimagesize';\n\t\t\t} else {\n\t\t\t\t$type = 'none';\n\t\t\t}\n\t\t}\n\t\t\n\t\t$mime = '';\n\t\tif ($type === 'finfo') {\n\t\t\t$mime = finfo_file($finfo, $path);\n\t\t} elseif ($type === 'mime_content_type') {\n\t\t\t$mime = mime_content_type($path);\n\t\t} elseif ($type === 'getimagesize') {\n\t\t\tif ($img = getimagesize($path)) {\n\t\t\t\t$mime = $img['mime'];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($mime) {\n\t\t\t$mime = explode(';', $mime);\n\t\t\t$mime = trim($mime[0]);\n\t\t\t\t\n\t\t\tif (in_array($mime, array('application/x-empty', 'inode/x-empty'))) {\n\t\t\t\t// finfo return this mime for empty files\n\t\t\t\t$mime = 'text/plain';\n\t\t\t} elseif ($mime == 'application/x-zip') {\n\t\t\t\t// http://elrte.org/redmine/issues/163\n\t\t\t\t$mime = 'application/zip';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $mime? $mime : 'unknown';\n\t}\n\t\n\t/**\n\t * Detect file type extension by local path\n\t * \n\t * @param  object $volume elFinderVolumeDriver instance\n\t * @param  string $path Local path\n\t * @return string file type extension with dot\n\t * @author Naoki Sawada\n\t */\n\tprotected function detectFileExtension($volume, $path) {\n\t\t$mime = $this->detectMimeType($path);\n\t\t$ext = $mime !== 'unknown'? $volume->getExtentionByMime($mime) : '';\n\t\treturn $ext? ('.' . $ext) : '';\n\t}\n\t\n\t/**\n\t * Get temporary directory path\n\t * \n\t * @param  string $volumeTempPath\n\t * @return string\n\t * @author Naoki Sawada\n\t */\n\tprivate function getTempDir($volumeTempPath = null) {\n\t\t$testDirs = array();\n\t\tif ($this->uploadTempPath) {\n\t\t\t$testDirs[] = rtrim(realpath($this->uploadTempPath), DIRECTORY_SEPARATOR);\n\t\t}\n\t\tif ($volumeTempPath) {\n\t\t\t$testDirs[] = rtrim(realpath($volumeTempPath), DIRECTORY_SEPARATOR);\n\t\t}\n\t\tif (function_exists('sys_get_temp_dir')) {\n\t\t\t$testDirs[] = sys_get_temp_dir();\n\t\t}\n\t\t$tempDir = '';\n\t\tforeach($testDirs as $testDir) {\n\t\t\tif (!$testDir || !is_dir($testDir)) continue;\n\t\t\tif (is_writable($testDir)) {\n\t\t\t\t$tempDir = $testDir;\n\t\t\t\t$gc = time() - 3600;\n\t\t\t\tforeach(glob($tempDir . DIRECTORY_SEPARATOR .'ELF*') as $cf) {\n\t\t\t\t\tif (filemtime($cf) < $gc) {\n\t\t\t\t\t\tunlink($cf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $tempDir;\n\t}\n\t\n\t/**\n\t * chmod\n\t *\n\t * @param array  command arguments\n\t * @return array\n\t * @author David Bartle\n\t **/\n\tprotected function chmod($args) {\n\t\t$targets = $args['targets'];\n\t\t$mode    = intval((string)$args['mode'], 8);\n\n\t\tif (!is_array($targets)) {\n\t\t\t$targets = array($targets);\n\t\t}\n\t\t\n\t\t$result = array();\n\t\t\n\t\tif (($volume = $this->volume($targets[0])) == false) {\n\t\t\t$result['error'] = $this->error(self::ERROR_CONF_NO_VOL);\n\t\t\treturn $result;\n\t\t}\n\n\t\t$this->itemLock($targets);\n\t\t\n\t\t$files = array();\n\t\t$errors = array();\n\t\tforeach($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\t$file = $volume->chmod($target, $mode);\n\t\t\tif ($file) {\n\t\t\t\t$files = array_merge($files, is_array($file)? $file : array($file));\n\t\t\t} else {\n\t\t\t\t$errors = array_merge($errors, $volume->error());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($files) {\n\t\t\t$result['changed'] = $files;\n\t\t\tif ($errors) {\n\t\t\t\t$result['warning'] = $this->error($errors);\n\t\t\t}\n\t\t} else {\n\t\t\t$result['error'] = $this->error($errors);\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Check chunked upload files\n\t *\n\t * @param string $tmpname uploaded temporary file path\n\t * @param string $chunk uploaded chunk file name\n\t * @param string $cid uploaded chunked file id\n\t * @param string $tempDir temporary dirctroy path\n\t * @param null $volume\n\t * @return array or (empty, empty)\n\t * @author Naoki Sawada\n\t */\n\tprivate function checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume = null) {\n\t\tif (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n\t\t\t$fname = $m[1];\n\t\t\t$encname = md5($cid . '_' . $fname);\n\t\t\t$base = $tempDir . DIRECTORY_SEPARATOR . 'ELF' . $encname;\n\t\t\t$clast = intval($m[3]);\n\t\t\tif (is_null($tmpname)) {\n\t\t\t\tignore_user_abort(true);\n\t\t\t\t// chunked file upload fail\n\t\t\t\tforeach(glob($base . '*') as $cf) {\n\t\t\t\t\tunlink($cf);\n\t\t\t\t}\n\t\t\t\tignore_user_abort(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$range = isset($_POST['range'])? trim($_POST['range']) : '';\n\t\t\tif ($range && preg_match('/^(\\d+),(\\d+),(\\d+)$/', $range, $ranges)) {\n\t\t\t\t$start = $ranges[1];\n\t\t\t\t$len   = $ranges[2];\n\t\t\t\t$size  = $ranges[3];\n\t\t\t\t$tmp = $base . '.part';\n\t\t\t\t$csize = filesize($tmpname);\n\t\t\t\t\n\t\t\t\t$tmpExists = is_file($tmp);\n\t\t\t\tif (!$tmpExists) {\n\t\t\t\t\t// check upload max size\n\t\t\t\t\t$uploadMaxSize = $volume->getUploadMaxSize();\n\t\t\t\t\tif ($uploadMaxSize > 0 && $size > $uploadMaxSize) {\n\t\t\t\t\t\treturn array(self::ERROR_UPLOAD_FILE_SIZE, false);\n\t\t\t\t\t}\n\t\t\t\t\t// make temp file\n\t\t\t\t\t$ok = false;\n\t\t\t\t\tif ($fp = fopen($tmp, 'wb')) {\n\t\t\t\t\t\tflock($fp, LOCK_EX);\n\t\t\t\t\t\t$ok = ftruncate($fp, $size);\n\t\t\t\t\t\tflock($fp, LOCK_UN);\n\t\t\t\t\t\tfclose($fp);\n\t\t\t\t\t\ttouch($base);\n\t\t\t\t\t}\n\t\t\t\t\tif (!$ok) {\n\t\t\t\t\t\tunlink($tmp);\n\t\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// wait until makeing temp file (for anothor session)\n\t\t\t\t\t$cnt = 1200; // Time limit 120 sec\n\t\t\t\t\twhile(!is_file($base) && --$cnt) {\n\t\t\t\t\t\tusleep(100000); // wait 100ms\n\t\t\t\t\t}\n\t\t\t\t\tif (!$cnt) {\n\t\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// check size info\n\t\t\t\tif ($len != $csize || $start + $len > $size || ($tmpExists && $size != filesize($tmp))) {\n\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// write chunk data\n\t\t\t\t$writelen = 0;\n\t\t\t\t$src = fopen($tmpname, 'rb');\n\t\t\t\t$fp = fopen($tmp, 'cb');\n\t\t\t\tfseek($fp, $start);\n\t\t\t\t$writelen = stream_copy_to_stream($src, $fp, $len);\n\t\t\t\tfclose($fp);\n\t\t\t\tfclose($src);\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\t// to check connection is aborted\n\t\t\t\t\telFinder::checkAborted();\n\t\t\t\t} catch (elFinderAbortException $e) {\n\t\t\t\t\tunlink($tmpname);\n\t\t\t\t\tis_file($tmp) && unlink($tmp);\n\t\t\t\t\tis_file($base) && unlink($base);\n\t\t\t\t\tthrow $e;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($writelen != $len) {\n\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// write counts\n\t\t\t\tfile_put_contents($base, \"\\0\", FILE_APPEND | LOCK_EX);\n\t\t\t\t\n\t\t\t\tif (filesize($base) >= $clast + 1) {\n\t\t\t\t\t// Completion\n\t\t\t\t\tunlink($base);\n\t\t\t\t\treturn array($tmp, $fname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// old way\n\t\t\t\t$part = $base . $m[2];\n\t\t\t\tif (move_uploaded_file($tmpname, $part)) {\n\t\t\t\t\tchmod($part, 0600);\n\t\t\t\t\tif ($clast < count(glob($base . '*'))) {\n\t\t\t\t\t\t$parts = array();\n\t\t\t\t\t\tfor ($i = 0; $i <= $clast; $i++) {\n\t\t\t\t\t\t\t$name = $base . '.' . $i . '_' . $clast;\n\t\t\t\t\t\t\tif (is_readable($name)) {\n\t\t\t\t\t\t\t\t$parts[] = $name;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$parts = null;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($parts) {\n\t\t\t\t\t\t\tif (!is_file($base)) {\n\t\t\t\t\t\t\t\ttouch($base);\n\t\t\t\t\t\t\t\tif ($resfile = tempnam($tempDir, 'ELF')) {\n\t\t\t\t\t\t\t\t\t$target = fopen($resfile, 'wb');\n\t\t\t\t\t\t\t\t\tforeach($parts as $f) {\n\t\t\t\t\t\t\t\t\t\t$fp = fopen($f, 'rb');\n\t\t\t\t\t\t\t\t\t\twhile (!feof($fp)) {\n\t\t\t\t\t\t\t\t\t\t\tfwrite($target, fread($fp, 8192));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfclose($fp);\n\t\t\t\t\t\t\t\t\t\tunlink($f);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfclose($target);\n\t\t\t\t\t\t\t\t\tunlink($base);\n\t\t\t\t\t\t\t\t\treturn array($resfile, $fname);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tunlink($base);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array('', '');\n\t}\n\t\n\t/**\n\t * Save uploaded files\n\t *\n\t * @param  array\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function upload($args) {\n\t\t$ngReg  = '/[\\/\\\\?*:|\"<>]/';\n\t\t$target = $args['target'];\n\t\t$volume = $this->volume($target);\n\t\t$files  = isset($args['FILES']['upload']) && is_array($args['FILES']['upload']) ? $args['FILES']['upload'] : array();\n\t\t$header = empty($args['html']) ? array() : array('header' => 'Content-Type: text/html; charset=utf-8');\n\t\t$result = array_merge(array('added' => array()), $header);\n\t\t$paths  = $args['upload_path']? $args['upload_path'] : array();\n\t\t$chunk  = $args['chunk']? $args['chunk'] : '';\n\t\t$cid    = $args['cid']? (int)$args['cid'] : '';\n\t\t$mtimes = $args['mtime']? $args['mtime'] : array();\n\t\t\n\t\tif (!$volume) {\n\t\t\treturn array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, '#'.$target)), $header);\n\t\t}\n\t\t\n\t\t// check $chunk\n\t\tif (strpos($chunk, '/') !== false || strpos($chunk, '\\\\') !== false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_UPLOAD));\n\t\t}\n\t\t\n\t\tif ($args['overwrite'] !== '') {\n\t\t\t$volume->setUploadOverwrite($args['overwrite']);\n\t\t}\n\t\t\n\t\t$renames = $hashes = array();\n\t\t$suffix = '~';\n\t\tif ($args['renames'] && is_array($args['renames'])) {\n\t\t\t$renames = array_flip($args['renames']);\n\t\t\tif (is_string($args['suffix']) && ! preg_match($ngReg, $args['suffix'])) {\n\t\t\t\t$suffix = $args['suffix'];\n\t\t\t}\n\t\t}\n\t\tif ($args['hashes'] && is_array($args['hashes'])) {\n\t\t\t$hashes = array_flip($args['hashes']);\n\t\t}\n\t\t\n\t\t$this->itemLock($target);\n\t\t\n\t\t// file extentions table by MIME\n\t\t$extTable = array_flip(array_unique($volume->getMimeTable()));\n\t\t\n\t\tif (empty($files)) {\n\t\t\tif (isset($args['upload']) && is_array($args['upload']) && ($tempDir = $this->getTempDir($volume->getTempPath()))) {\n\t\t\t\t$names = array();\n\t\t\t\tforeach($args['upload'] as $i => $url) {\n\t\t\t\t\t// check chunked file upload commit\n\t\t\t\t\tif ($chunk) {\n\t\t\t\t\t\tif ($url === 'chunkfail' && $args['mimes'] === 'chunkfail') {\n\t\t\t\t\t\t\t$this->checkChunkedFile(null, $chunk, $cid, $tempDir);\n\t\t\t\t\t\t\tif (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n\t\t\t\t\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn $result;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$tmpfname = $tempDir . '/' . $chunk;\n\t\t\t\t\t\t\t$files['tmp_name'][$i] = $tmpfname;\n\t\t\t\t\t\t\t$files['name'][$i] = $url;\n\t\t\t\t\t\t\t$files['error'][$i] = 0;\n\t\t\t\t\t\t\t$GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$tmpfname = $tempDir . DIRECTORY_SEPARATOR . 'ELF_FATCH_' . md5($url.microtime(true));\n\t\t\t\t\t$GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\t\t\t\t\t\n\t\t\t\t\t$_name = '';\n\t\t\t\t\t// check is data:\n\t\t\t\t\tif (substr($url, 0, 5) === 'data:') {\n\t\t\t\t\t\tlist($data, $args['name'][$i]) = $this->parse_data_scheme($url, $extTable, $args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$fp = fopen($tmpfname, 'wb');\n\t\t\t\t\t\t$data = $this->get_remote_contents($url, 30, 5, 'Mozilla/5.0', $fp);\n\t\t\t\t\t\t// to check connection is aborted\n\t\t\t\t\t\telFinder::checkAborted();\n\t\t\t\t\t\t$_name = preg_replace('~^.*?([^/#?]+)(?:\\?.*)?(?:#.*)?$~', '$1', rawurldecode($url));\n\t\t\t\t\t\t// Check `Content-Disposition` response header\n\t\t\t\t\t\tif ($data && ($headers = get_headers($url, true)) && !empty($headers['Content-Disposition'])) {\n\t\t\t\t\t\t\tif (preg_match('/filename\\*?=(?:([a-zA-Z0-9_-]+?)\\'\\')?\"?([a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n\t\t\t\t\t\t\t\t$_name = rawurldecode($m[2]);\n\t\t\t\t\t\t\t\tif ($m[1] && strtoupper($m[1]) !== 'UTF-8' && function_exists('mb_convert_encoding')) {\n\t\t\t\t\t\t\t\t\t$_name = mb_convert_encoding($_name, 'UTF-8', $m[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($data) {\n\t\t\t\t\t\tif (isset($args['name'][$i])) {\n\t\t\t\t\t\t\t$_name = $args['name'][$i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($_name) {\n\t\t\t\t\t\t\t$_ext = '';\n\t\t\t\t\t\t\tif (preg_match('/(\\.[a-z0-9]{1,7})$/', $_name, $_match)) {\n\t\t\t\t\t\t\t\t$_ext = $_match[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((is_resource($data) && fclose($data)) || file_put_contents($tmpfname, $data)) {\n\t\t\t\t\t\t\t\t$GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\t\t\t\t\t\t\t\t$_name = preg_replace($ngReg, '_', $_name);\n\t\t\t\t\t\t\t\tlist($_a, $_b) = array_pad(explode('.', $_name, 2), 2, '');\n\t\t\t\t\t\t\t\tif ($_b === '') {\n\t\t\t\t\t\t\t\t\tif ($_ext) {\n\t\t\t\t\t\t\t\t\t\trename($tmpfname, $tmpfname . $_ext);\n\t\t\t\t\t\t\t\t\t\t$tmpfname = $tmpfname . $_ext;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$_b = $this->detectFileExtension($volume, $tmpfname);\n\t\t\t\t\t\t\t\t\t$_name = $_a.$_b;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$_b = '.'.$_b;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($names[$_name])) {\n\t\t\t\t\t\t\t\t\t$_name = $_a.'_'.$names[$_name]++.$_b;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$names[$_name] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$files['tmp_name'][$i] = $tmpfname;\n\t\t\t\t\t\t\t\t$files['name'][$i] = $_name;\n\t\t\t\t\t\t\t\t$files['error'][$i] = 0;\n\t\t\t\t\t\t\t\t// set to auto rename\n\t\t\t\t\t\t\t\t$volume->setUploadOverwrite(false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tunlink($tmpfname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (empty($files)) {\n\t\t\t\treturn array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_UPLOAD_NO_FILES)), $header);\n\t\t\t}\n\t\t}\n\n\t\t$addedDirs = array();\n\t\tforeach ($files['name'] as $i => $name) {\n\t\t\tif (($error = $files['error'][$i]) > 0) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $error == UPLOAD_ERR_INI_SIZE || $error == UPLOAD_ERR_FORM_SIZE ? self::ERROR_UPLOAD_FILE_SIZE : self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t$this->uploadDebug = 'Upload error code: '.$error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t$tmpname = $files['tmp_name'][$i];\n\t\t\t$thash = ($paths && isset($paths[$i]))? $paths[$i] : $target;\n\t\t\t$mtime = isset($mtimes[$i])? $mtimes[$i] : 0;\n\t\t\tif ($name === 'blob') {\n\t\t\t\tif ($chunk) {\n\t\t\t\t\tif ($tempDir = $this->getTempDir($volume->getTempPath())) {\n\t\t\t\t\t\tlist($tmpname, $name) = $this->checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume);\n\t\t\t\t\t\tif ($tmpname) {\n\t\t\t\t\t\t\tif ($name === false) {\n\t\t\t\t\t\t\t\tpreg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m);\n\t\t\t\t\t\t\t\t$result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], $tmpname);\n\t\t\t\t\t\t\t\t$result['_chunkfailure'] = true;\n\t\t\t\t\t\t\t\t$this->uploadDebug = 'Upload error: ' . $tmpname;\n\t\t\t\t\t\t\t} else if ($name) {\n\t\t\t\t\t\t\t\t$result['_chunkmerged'] = basename($tmpname);\n\t\t\t\t\t\t\t\t$result['_name'] = $name;\n\t\t\t\t\t\t\t\t$result['_mtime'] = $mtime;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $chunk, self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t\t\t$this->uploadDebug = 'Upload error: unable open tmp file';\n\t\t\t\t\t}\n\t\t\t\t\treturn $result;\n\t\t\t\t} else {\n\t\t\t\t\t// for form clipboard with Google Chrome or Opera\n\t\t\t\t\t$name = 'image.png';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n\t\t\tif (strtolower(substr($name, 0, 5)) === 'image' && is_array($args['name']) && isset($args['name'][$i])) {\n\t\t\t\t$type = $files['type'][$i];\n\t\t\t\t$name = $args['name'][$i];\n\t\t\t\t$ext = isset($extTable[$type])? '.' . $extTable[$type] : '';\n\t\t\t\tif ($ext) {\n\t\t\t\t\t$name = preg_replace('/\\.[^.]*$/', '', $name);\n\t\t\t\t}\n\t\t\t\t$name .= $ext;\n\t\t\t}\n\t\t\t\n\t\t\t// do hook function 'upload.presave'\n\t\t\tif (! empty($this->listeners['upload.presave'])) {\n\t\t\t\tforeach($this->listeners['upload.presave'] as $handler) {\n\t\t\t\t\tcall_user_func_array($handler, array(&$thash, &$name, $tmpname, $this, $volume));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($mtime) {\n\t\t\t\t// for keep timestamp option in the LocalFileSystem volume\n\t\t\t\ttouch($tmpname, $mtime);\n\t\t\t}\n\t\t\t\n\t\t\tif (($fp = fopen($tmpname, 'rb')) == false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t$this->uploadDebug = 'Upload error: unable open tmp file';\n\t\t\t\tif (! is_uploaded_file($tmpname)) {\n\t\t\t\t\tif (unlink($tmpname)) unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$rnres = array();\n\t\t\tif ($thash !== '' && $thash !== $target) {\n\t\t\t\tif ($dir = $volume->dir($thash)) {\n\t\t\t\t\t$_target = $thash;\n\t\t\t\t\tif (! isset($addedDirs[$thash])) {\n\t\t\t\t\t\t$addedDirs[$thash] = true;\n\t\t\t\t\t\t$result['added'][] =$dir;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$result['error'] = $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, 'hash@'.$thash);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$_target = $target;\n\t\t\t\t// file rename for backup\n\t\t\t\tif (isset($renames[$name])) {\n\t\t\t\t\t$dir = $volume->realpath($_target);\n\t\t\t\t\tif (isset($hashes[$name])) {\n\t\t\t\t\t\t$hash = $hashes[$name];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$hash = $volume->getHash($dir, $name);\n\t\t\t\t\t}\n\t\t\t\t\t$rnres = $this->rename(array('target' => $hash, 'name' => $volume->uniqueName($dir, $name, $suffix, true, 0)));\n\t\t\t\t\tif (!empty($rnres['error'])) {\n\t\t\t\t\t\t$result['warning'] = $rnres['error'];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! $_target || ($file = $volume->upload($fp, $_target, $name, $tmpname, $hashes)) === false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $volume->error());\n\t\t\t\tfclose($fp);\n\t\t\t\tif (! is_uploaded_file($tmpname)) {\n\t\t\t\t\tif (unlink($tmpname)) unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tis_resource($fp) && fclose($fp);\n\t\t\tif (! is_uploaded_file($tmpname)){\n\t\t\t\tclearstatcache();\n\t\t\t\tif (!is_file($tmpname) || unlink($tmpname)) {\n\t\t\t\t\tunset($GLOBALS['elFinderTempFiles'][$tmpname]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$result['added'][] = $file;\n\t\t\tif ($rnres) {\n\t\t\t\t$result = array_merge_recursive($result, $rnres);\n\t\t\t}\n\t\t}\n\t\tif ($GLOBALS['elFinderTempFiles']) {\n\t\t\tforeach(array_keys($GLOBALS['elFinderTempFiles']) as $_temp) {\n\t\t\t\t is_file($_temp) && unlink($_temp);\n\t\t\t}\n\t\t}\n\t\t$result['removed'] = $volume->removed();\n\t\t\n\t\tif (!empty($args['node'])) {\n\t\t\t$result['callback'] = array(\n\t\t\t\t'node' => $args['node'],\n\t\t\t\t'bind' => 'upload'\n\t\t\t);\n\t\t}\n\t\treturn $result;\n\t}\n\t\t\n\t/**\n\t * Copy/move files into new destination\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function paste($args) {\n\t\t$dst     = $args['dst'];\n\t\t$targets = is_array($args['targets']) ? $args['targets'] : array();\n\t\t$cut     = !empty($args['cut']);\n\t\t$error   = $cut ? self::ERROR_MOVE : self::ERROR_COPY;\n\t\t$result  = array('changed' => array(), 'added' => array(), 'removed' => array(), 'warning' => array());\n\t\t\n\t\tif (($dstVolume = $this->volume($dst)) == false) {\n\t\t\treturn array('error' => $this->error($error, '#'.$targets[0], self::ERROR_TRGDIR_NOT_FOUND, '#'.$dst));\n\t\t}\n\t\t\n\t\t$this->itemLock($dst);\n\t\t\n\t\t$hashes = $renames = array();\n\t\t$suffix = '~';\n\t\tif (!empty($args['renames'])) {\n\t\t\t$renames = array_flip($args['renames']);\n\t\t\tif (is_string($args['suffix']) && ! preg_match('/[\\/\\\\?*:|\"<>]/', $args['suffix'])) {\n\t\t\t\t$suffix = $args['suffix'];\n\t\t\t}\n\t\t}\n\t\tif (!empty($args['hashes'])) {\n\t\t\t$hashes = array_flip($args['hashes']);\n\t\t}\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($srcVolume = $this->volume($target)) == false) {\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error($error, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$rnres = array();\n\t\t\tif ($renames) {\n\t\t\t\t$file = $srcVolume->file($target);\n\t\t\t\tif (isset($renames[$file['name']])) {\n\t\t\t\t\t$dir = $dstVolume->realpath($dst);\n\t\t\t\t\tif (isset($hashes[$file['name']])) {\n\t\t\t\t\t\t$hash = $hashes[$file['name']];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$hash = $dstVolume->getHash($dir, $file['name']);\n\t\t\t\t\t}\n\t\t\t\t\t$rnres = $this->rename(array('target' => $hash, 'name' => $dstVolume->uniqueName($dir, $file['name'], $suffix, true, 0)));\n\t\t\t\t\tif (!empty($rnres['error'])) {\n\t\t\t\t\t\t$result['warning'] = array_merge($result['warning'], $rnres['error']);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($cut && $this->itemLocked($target)) {\n\t\t\t\t$rm = $srcVolume->file($target);\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error(self::ERROR_LOCKED, $rm['name']));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (($file = $dstVolume->paste($srcVolume, $target, $dst, $cut, $hashes)) == false) {\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error($dstVolume->error()));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif ($error = $dstVolume->error()) {\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error($error));\n\t\t\t}\n\n\t\t\t$dirChange = ! empty($file['dirChange']);\n\t\t\tunset($file['dirChange']);\n\t\t\tif ($dirChange) {\n\t\t\t\t$result['changed'][] = $file;\n\t\t\t} else {\n\t\t\t\t$result['added'][] = $file;\n\t\t\t}\n\t\t\tif ($rnres) {\n\t\t\t\t$result = array_merge_recursive($result, $rnres);\n\t\t\t}\n\t\t}\n\t\tif (count($result['warning']) < 1) {\n\t\t\tunset($result['warning']);\n\t\t} else {\n\t\t\t$result['sync'] = true;\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return file content\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function get($args) {\n\t\t$target = $args['target'];\n\t\t$volume = $this->volume($target);\n\t\t$enc = false;\n\t\t\n\t\tif (!$volume || ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\tif (($content = $volume->getContents($target)) === false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $volume->path($target), $volume->error()));\n\t\t}\n\t\t\n\t\t$mime = isset($file['mime'])? $file['mime'] : '';\n\t\tif ($mime && (strtolower(substr($mime, 0, 4)) === 'text' || in_array(strtolower($mime), self::$textMimes))) {\n\t\t\t$enc = '';\n\t\t\tif ($content !== '') {\n\t\t\t\tif (! $args['conv'] || $args['conv'] == '1') {\n\t\t\t\t\t// detect encoding\n\t\t\t\t\tif (function_exists('mb_detect_encoding')) {\n\t\t\t\t\t\tif ($enc = mb_detect_encoding($content , mb_detect_order(), true)) {\n\t\t\t\t\t\t\t$encu = strtoupper($enc);\n\t\t\t\t\t\t\tif ($encu === 'UTF-8' || $encu === 'ASCII') {\n\t\t\t\t\t\t\t\t$enc = '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (! preg_match('//u', $content)) {\n\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t}\n\t\t\t\t\tif ($enc === 'unknown') {\n\t\t\t\t\t\t$enc = $volume->getOption('encoding');\n\t\t\t\t\t\tif (! $enc || strtoupper($enc) === 'UTF-8') {\n\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($enc && $enc !== 'unknown') {\n\t\t\t\t\t\t$utf8 = iconv($enc, 'UTF-8', $content);\n\t\t\t\t\t\tif ($utf8 === false && function_exists('mb_convert_encoding')) {\n\t\t\t\t\t\t\t$utf8 = mb_convert_encoding($content, 'UTF-8', $enc);\n\t\t\t\t\t\t\tif (mb_convert_encoding($utf8, $enc, 'UTF-8') !== $content) {\n\t\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ($utf8 === false || iconv('UTF-8', $enc, $utf8) !== $content) {\n\t\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($enc !== 'unknown') {\n\t\t\t\t\t\t\t$content = $utf8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($enc) {\n\t\t\t\t\t\tif ($args['conv'] == '1') {\n\t\t\t\t\t\t\t$args['conv'] = '';\n\t\t\t\t\t\t\tif ($enc === 'unknown') {\n\t\t\t\t\t\t\t\t$content = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ($enc === 'unknown') {\n\t\t\t\t\t\t\treturn array('doconv' => $enc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($args['conv'] == '1') {\n\t\t\t\t\t\t$args['conv'] = '';\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif ($args['conv']) {\n\t\t\t\t\t$enc = $args['conv'];\n\t\t\t\t\tif (strtoupper($enc) !== 'UTF-8') {\n\t\t\t\t\t\t$_content = $content;\n\t\t\t\t\t\t$content = iconv($enc, 'UTF-8', $content);\n\t\t\t\t\t\tif ($content === false && function_exists('mb_convert_encoding')) {\n\t\t\t\t\t\t\t$content = mb_convert_encoding($_content, 'UTF-8', $enc);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$enc = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$content = 'data:' . ($mime? $mime : 'application/octet-stream') . ';base64,'.base64_encode($content);\n\t\t}\n\t\t\n\t\tif ($enc !== false) {\n\t\t\tif ($content !== false) {\n\t\t\t\t$json = json_encode($content);\n\t\t\t}\n\t\t\tif ($content === false || $json === false || strlen($json) < strlen($content)) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_CONV_UTF8, self::ERROR_NOT_UTF8_CONTENT, $volume->path($target)));\n\t\t\t}\n\t\t}\n\t\t\n\t\t$res = array(\n\t\t\t'header'  => array(\n\t\t\t\t'Content-Type: application/json'\n\t\t\t),\n\t\t\t'content' => $content\n\t\t);\n\t\t\n\t\t// add cache control headers\n\t\tif ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n\t\t\t$res['header'] = array_merge($res['header'], $cacheHeaders);\n\t\t}\n\t\t\n\t\tif ($enc) {\n\t\t\t$res['encoding'] = $enc;\n\t\t}\n\t\treturn $res;\n\t}\n\n\t/**\n\t * Save content into text file\n\t *\n\t * @param $args\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t */\n\tprotected function put($args) {\n\t\t$target = $args['target'];\n\t\t$encoding = isset($args['encoding'])? $args['encoding'] : '';\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_SAVE, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\t$this->itemLock($target);\n\t\t\n\t\tif ($encoding === 'scheme') {\n\t\t\tif (preg_match('~^https?://~i', $args['content'])) {\n\t\t\t\t$fp = $this->get_remote_contents($args['content'], 30, 5, 'Mozilla/5.0', $volume->tmpfile());\n\t\t\t\tif (! $fp) {\n\t\t\t\t\treturn  array('error' => self::ERROR_SAVE, $args['content'], self::ERROR_FILE_NOT_FOUND);\n\t\t\t\t}\n\t\t\t\t$fmeta = stream_get_meta_data($fp);\n\t\t\t\t$mime = $this->detectMimeType($fmeta['uri']);\n\t\t\t\t$args['content'] = 'data:'.$mime.';base64,'.base64_encode(file_get_contents($fmeta['uri']));\n\t\t\t}\n\t\t\t$encoding = '';\n\t\t\t$args['content'] = \"\\0\" . $args['content'];\n\t\t} else if ($encoding === 'hash') {\n\t\t\t$_hash = $args['content'];\n\t\t\tif ($_src = $this->getVolume($_hash)) {\n\t\t\t\tif ($_file = $_src->file($_hash)) {\n\t\t\t\t\tif ($_data = $_src->getContents($_hash)) {\n\t\t\t\t\t\t$args['content'] = 'data:'.$file['mime'].';base64,'.base64_encode($_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$encoding = '';\n\t\t\t$args['content'] = \"\\0\" . $args['content'];\n\t\t}\n\t\tif ($encoding) {\n\t\t\t$content = iconv('UTF-8', $encoding, $args['content']);\n\t\t\tif ($content === false && function_exists('mb_detect_encoding')) {\n\t\t\t\t$content = mb_convert_encoding($args['content'], $encoding, 'UTF-8');\n\t\t\t}\n\t\t\tif ($content !== false) {\n\t\t\t\t$args['content'] = $content;\n\t\t\t}\n\t\t}\n\t\tif (($file = $volume->putContents($target, $args['content'])) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_SAVE, $volume->path($target), $volume->error()));\n\t\t}\n\t\t\n\t\treturn array('changed' => array($file));\n\t}\n\n\t/**\n\t * Extract files from archive\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov, \n\t * @author Alexey Sukhotin\n\t **/\n\tprotected function extract($args) {\n\t\t$target = $args['target'];\n\t\t$mimes  = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n\t\t$error  = array(self::ERROR_EXTRACT, '#'.$target);\n\t\t$makedir = isset($args['makedir'])? (bool)$args['makedir'] : null;\n\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_EXTRACT, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}  \n\n\t\t$res = array();\n\t\tif ($file = $volume->extract($target, $makedir)) {\n\t\t\t$res['added'] = isset($file['read'])? array($file) : $file;\n\t\t\tif ($err = $volume->error()) {\n\t\t\t\t$res['warning'] = $err;\n\t\t\t}\n\t\t} else {\n\t\t\t$res['error'] = $this->error(self::ERROR_EXTRACT, $volume->path($target), $volume->error());\n\t\t}\n\t\treturn $res;\n\t}\n\t\n\t/**\n\t * Create archive\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov, \n\t * @author Alexey Sukhotin\n\t **/\n\tprotected function archive($args) {\n\t\t$type    = $args['type'];\n\t\t$targets = isset($args['targets']) && is_array($args['targets']) ? $args['targets'] : array();\n\t\t$name    = isset($args['name'])? $args['name'] : '';\n\t\n\t\tif (($volume = $this->volume($targets[0])) == false) {\n\t\t\treturn $this->error(self::ERROR_ARCHIVE, self::ERROR_TRGDIR_NOT_FOUND);\n\t\t}\n\t\t\n\t\tforeach($targets as $target) {\n\t\t\t$this->itemLock($target);\n\t\t}\n\t\t\n\t\treturn ($file = $volume->archive($targets, $args['type'], $name))\n\t\t\t? array('added' => array($file))\n\t\t\t: array('error' => $this->error(self::ERROR_ARCHIVE, $volume->error()));\n\t}\n\t\n\t/**\n\t * Search files\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry Levashov\n\t **/\n\tprotected function search($args) {\n\t\t$q      = trim($args['q']);\n\t\t$mimes  = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n\t\t$target = !empty($args['target'])? $args['target'] : null;\n\t\t$result = array();\n\t\t$errors = array();\n\n\t\tif ($target) {\n\t\t\tif ($volume = $this->volume($target)) {\n\t\t\t\t$result = $volume->search($q, $mimes, $target);\n\t\t\t\t$errors = array_merge($errors, $volume->error());\n\t\t\t}\n\t\t} else {\n\t\t\tforeach ($this->volumes as $volume) {\n\t\t\t\t$result = array_merge($result, $volume->search($q, $mimes));\n\t\t\t\t$errors = array_merge($errors, $volume->error());\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array('files' => $result);\n\t\tif ($errors) {\n\t\t\t$result['warning'] = $errors;\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return file info (used by client \"places\" ui)\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry Levashov\n\t **/\n\tprotected function info($args) {\n\t\t$files = array();\n\t\t$sleep = 0;\n\t\t$compare = null;\n\t\t// long polling mode\n\t\tif ($args['compare'] && count($args['targets']) === 1) {\n\t\t\t$compare = intval($args['compare']);\n\t\t\t$hash = $args['targets'][0];\n\t\t\tif ($volume = $this->volume($hash)) {\n\t\t\t\t$standby = (int)$volume->getOption('plStandby');\n\t\t\t\t$_compare = false;\n\t\t\t\tif (($syncCheckFunc = $volume->getOption('syncCheckFunc')) && is_callable($syncCheckFunc)) {\n\t\t\t\t\t$_compare = call_user_func_array($syncCheckFunc, array($volume->realpath($hash), $standby, $compare, $volume, $this));\n\t\t\t\t}\n\t\t\t\tif ($_compare !== false) {\n\t\t\t\t\t$compare = $_compare;\n\t\t\t\t} else {\n\t\t\t\t\t$sleep = max(1, (int)$volume->getOption('tsPlSleep'));\n\t\t\t\t\t$limit = max(1, $standby / $sleep) + 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\telFinder::extendTimeLimit(30 + $sleep);\n\t\t\t\t\t\t$volume->clearstatcache();\n\t\t\t\t\t\tif (($info = $volume->file($hash)) != false) {\n\t\t\t\t\t\t\tif ($info['ts'] != $compare) {\n\t\t\t\t\t\t\t\t$compare = $info['ts'];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$compare = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (--$limit) {\n\t\t\t\t\t\t\tsleep($sleep);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while($limit);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tforeach ($args['targets'] as $hash) {\n\t\t\t\telFinder::checkAborted();\n\t\t\t\tif (($volume = $this->volume($hash)) != false\n\t\t\t\t&& ($info = $volume->file($hash)) != false) {\n\t\t\t\t\t$info['path'] = $volume->path($hash);\n\t\t\t\t\t$files[] = $info;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array('files' => $files);\n\t\tif (!is_null($compare)) {\n\t\t\t$result['compare'] = strval($compare);\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return image dimensions\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function dim($args) {\n\t\t$res = array();\n\t\t$target = $args['target'];\n\t\t\n\t\tif (($volume = $this->volume($target)) != false) {\n\t\t\tif ($dim = $volume->dimensions($target, $args)) {\n\t\t\t\tif (is_array($dim) && isset($dim['dim'])) {\n\t\t\t\t\t$res = $dim;\n\t\t\t\t} else {\n\t\t\t\t\t$res = array('dim' => $dim);\n\t\t\t\t\tif ($subImgLink = $volume->getSubstituteImgLink($target, explode('x', $dim))) {\n\t\t\t\t\t\t$res['url'] = $subImgLink;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $res;\n\t}\n\t\n\t/**\n\t * Resize image\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t * @author Alexey Sukhotin\n\t **/\n\tprotected function resize($args) {\n\t\t$target = $args['target'];\n\t\t$width  = (int)$args['width'];\n\t\t$height = (int)$args['height'];\n\t\t$x      = (int)$args['x'];\n\t\t$y      = (int)$args['y'];\n\t\t$mode   = $args['mode'];\n\t\t$bg     = $args['bg'];\n\t\t$degree = (int)$args['degree'];\n\t\t$quality= (int)$args['quality'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_RESIZE, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\tif ($mode !== 'rotate' && ($width < 1 || $height < 1)) {\n\t\t\treturn array('error' => $this->error(self::ERROR_RESIZESIZE));\n\t\t}\n\t\treturn ($file = $volume->resize($target, $width, $height, $x, $y, $mode, $bg, $degree, $quality))\n\t\t\t? (!empty($file['losslessRotate'])? $file : array('changed' => array($file)))\n\t\t\t: array('error' => $this->error(self::ERROR_RESIZE, $volume->path($target), $volume->error()));\n\t}\n\t\n\t/**\n\t* Return content URL\n\t*\n\t* @param  array  $args  command arguments\n\t* @return array\n\t* @author Naoki Sawada\n\t**/\n\tprotected function url($args) {\n\t\t$target = $args['target'];\n\t\t$options = isset($args['options'])? $args['options'] : array();\n\t\tif (($volume = $this->volume($target)) != false) {\n\t\t\tif (! $volume->commandDisabled('url')) {\n\t\t\t\t$url = $volume->getContentUrl($target, $options);\n\t\t\t\treturn $url ? array('url' => $url) : array();\n\t\t\t}\n\t\t}\n\t\treturn array();\n\t}\n\n\t/**\n\t * Output callback result with JavaScript that control elFinder\n\t * or HTTP redirect to callbackWindowURL\n\t * \n\t * @param  array  command arguments\n\t * @author Naoki Sawada\n\t */\n\tprotected function callback($args) {\n\t\t$checkReg = '/[^a-zA-Z0-9;._-]/';\n\t\t$node = (isset($args['node']) && !preg_match($checkReg, $args['node']))? $args['node'] : '';\n\t\t$json = (isset($args['json']) && json_decode($args['json']))? $args['json'] : '{}';\n\t\t$bind  = (isset($args['bind']) && !preg_match($checkReg, $args['bind']))? $args['bind'] : '';\n\t\t$done = (!empty($args['done']));\n\t\t\n\t\twhile( ob_get_level() ) {\n\t\t\tif (! ob_end_clean()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($done || ! $this->callbackWindowURL) {\n\t\t\t$script = '';\n\t\t\tif ($node) {\n\t\t\t\tif ($bind) {\n\t\t\t\t\t$trigger = 'elf.trigger(\\''.$bind.'\\', data);';\n\t\t\t\t\t$triggerdone = 'elf.trigger(\\''.$bind.'done\\');';\n\t\t\t\t\t$triggerfail = 'elf.trigger(\\''.$bind.'fail\\', data);';\n\t\t\t\t} else {\n\t\t\t\t\t$trigger = $triggerdone = $triggerfail = '';\n\t\t\t\t}\n\t\t\t\t$script .= '\n\t\t\t\t\tvar w = window.opener || window.parent || window;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar elf = w.document.getElementById(\\''.$node.'\\').elfinder;\n\t\t\t\t\t\tif (elf) {\n\t\t\t\t\t\t\tvar data = '.$json.';\n\t\t\t\t\t\t\tif (data.error) {\n\t\t\t\t\t\t\t\t'.$triggerfail.'\n\t\t\t\t\t\t\t\telf.error(data.error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata.warning && elf.error(data.warning);\n\t\t\t\t\t\t\t\tdata.removed && data.removed.length && elf.remove(data);\n\t\t\t\t\t\t\t\tdata.added   && data.added.length   && elf.add(data);\n\t\t\t\t\t\t\t\tdata.changed && data.changed.length && elf.change(data);\n\t\t\t\t\t\t\t\t'.$trigger.'\n\t\t\t\t\t\t\t\t'.$triggerdone.'\n\t\t\t\t\t\t\t\tdata.sync && elf.sync();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// for CORS\n\t\t\t\t\t\tw.postMessage && w.postMessage(JSON.stringify({bind:\\''.$bind.'\\',data:'.$json.'}), \\'*\\');\n\t\t\t\t\t}';\n\t\t\t}\n\t\t\t$script .= 'window.close();';\n\t\t\t\n\t\t\t$out = '<!DOCTYPE html><html><head><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><script>'.$script.'</script></head><body><a href=\"#\" onlick=\"window.close();return false;\">Close this window</a></body></html>';\n\t\t\t\n\t\t\theader('Content-Type: text/html; charset=utf-8');\n\t\t\theader('Content-Length: '.strlen($out));\n\t\t\theader('Cache-Control: private');\n\t\t\theader('Pragma: no-cache');\n\t\t\t\n\t\t\techo $out;\n\t\t\t\n\t\t} else {\n\t\t\t$url = $this->callbackWindowURL;\n\t\t\t$url .= ((strpos($url, '?') === false)? '?' : '&')\n\t\t\t\t . '&node=' . rawurlencode($node)\n\t\t\t\t . (($json !== '{}')? ('&json=' . rawurlencode($json)) : '')\n\t\t\t\t . ($bind? ('&bind=' .  rawurlencode($bind)) : '')\n\t\t\t\t . '&done=1';\n\t\t\t\n\t\t\theader('Location: ' . $url);\n\t\t\t\n\t\t}\n\t\tthrow new elFinderAbortException();\n\t}\n\n\t/**\n\t * PHP error handler, catch error types only E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE\n\t * \n\t * @param int    $errno\n\t * @param string $errstr\n\t * @param string $errfile\n\t * @param int    $errline\n\t * @return void|boolean\n\t */\n\tpublic static function phpErrorHandler($errno, $errstr, $errfile, $errline) {\n\t\tstatic $base = null;\n\t\t\n\t\tif (is_null($base)) {\n\t\t\t$base = dirname(__FILE__) . DIRECTORY_SEPARATOR;\n\t\t}\n\t\t\n\t\tif (! (error_reporting() & $errno)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$errfile = str_replace($base, '', $errfile);\n\t\t\n\t\t$proc = false;\n\t\tswitch ($errno) {\n\t\t\tcase E_WARNING:\n\t\t\tcase E_USER_WARNING:\n\t\t\t\telFinder::$phpErrors[] = \"WARNING: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase E_NOTICE:\n\t\t\tcase E_USER_NOTICE:\n\t\t\t\telFinder::$phpErrors[] = \"NOTICE: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase E_STRICT:\n\t\t\t\telFinder::$phpErrors[] = \"STRICT: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase E_RECOVERABLE_ERROR:\n\t\t\t\telFinder::$phpErrors[] = \"RECOVERABLE_ERROR: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (defined('E_DEPRECATED')) {\n\t\t\tswitch ($errno) {\n\t\t\t\tcase E_DEPRECATED:\n\t\t\t\tcase E_USER_DEPRECATED:\n\t\t\t\t\telFinder::$phpErrors[] = \"DEPRECATED: $errstr in $errfile line $errline.\";\n\t\t\t\t\t$proc = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $proc;\n\t}\n\n\t/***************************************************************************/\n\t/*                                   utils                                 */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Return root - file's owner\n\t *\n\t * @param  string  file hash\n\t * @return elFinderStorageDriver\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function volume($hash) {\n\t\tforeach ($this->volumes as $id => $v) {\n\t\t\tif (strpos(''.$hash, $id) === 0) {\n\t\t\t\treturn $this->volumes[$id];\n\t\t\t} \n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Return files info array \n\t *\n\t * @param  array  $data  one file info or files info\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function toArray($data) {\n\t\treturn isset($data['hash']) || !is_array($data) ? array($data) : $data;\n\t}\n\t\n\t/**\n\t * Return fils hashes list\n\t *\n\t * @param  array  $files  files info\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function hashes($files) {\n\t\t$ret = array();\n\t\tforeach ($files as $file) {\n\t\t\t$ret[] = $file['hash'];\n\t\t}\n\t\treturn $ret;\n\t}\n\t\n\t/**\n\t * Remove from files list hidden files and files with required mime types\n\t *\n\t * @param  array  $files  files info\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function filter($files) {\n\t\t$exists = array();\n\t\tforeach ($files as $i => $file) {\n\t\t\tif (isset($exists[$file['hash']]) || !empty($file['hidden']) || !$this->default->mimeAccepted($file['mime'])) {\n\t\t\t\tunset($files[$i]);\n\t\t\t}\n\t\t\t$exists[$file['hash']] = true;\n\t\t}\n\t\treturn array_values($files);\n\t}\n\t\n\tprotected function utime() {\n\t\t$time = explode(\" \", microtime());\n\t\treturn (double)$time[1] + (double)$time[0];\n\t}\n\t\n\t/**\n\t * Return Network mount volume unique ID\n\t *\n\t * @param  array   $netVolumes  Saved netvolumes array\n\t * @param  string  $prefix      Id prefix\n\t * @return string|false\n\t * @author Naoki Sawada\n\t **/\n\tprotected function getNetVolumeUniqueId($netVolumes = null, $prefix = 'nm') {\n\t\t$id = false;\n\t\tif (is_null($netVolumes)) {\n\t\t\t$netVolumes = $this->getNetVolumes();\n\t\t}\n\t\t$ids = array();\n\t\tforeach($netVolumes as $vOps) {\n\t\t\tif (isset($vOps['id']) && strpos($vOps['id'], $prefix) === 0) {\n\t\t\t\t$ids[$vOps['id']] = true;\n\t\t\t}\n\t\t}\n\t\tif (! $ids) {\n\t\t\t$id = $prefix.'1';\n\t\t} else {\n\t\t\t$i = 0;\n\t\t\twhile(isset($ids[$prefix.++$i]) && $i < 10000);\n\t\t\t$id = $prefix.$i;\n\t\t\tif (isset($ids[$id])) {\n\t\t\t\t$id = false;\n\t\t\t}\n\t\t}\n\t\treturn $id;\n\t}\n\t\n\t/**\n\t * Is item locked?\n\t * \n\t * @param string $hash\n\t * @return boolean\n\t */\n\tprotected function itemLocked($hash) {\n\t\tif (! elFinder::$commonTempPath) {\n\t\t\treturn false;\n\t\t}\n\t\t$lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n\t\tif (file_exists($lock)) {\n\t\t\tif (filemtime($lock) + $this->itemLockExpire < time()) {\n\t\t\t\tunlink($lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Do lock target item\n\t * \n\t * @param array|string $hashes\n\t * @param boolean $autoUnlock\n\t * @return boolean\n\t */\n\tprotected function itemLock($hashes, $autoUnlock = true) {\n\t\tif (! elFinder::$commonTempPath) {\n\t\t\treturn false;\n\t\t}\n\t\tif (! is_array($hashes)) {\n\t\t\t$hashes = array($hashes);\n\t\t}\n\t\tforeach($hashes as $hash) {\n\t\t\t$lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n\t\t\tif ($this->itemLocked($hash)) {\n\t\t\t\t$cnt = file_get_contents($lock) + 1;\n\t\t\t} else {\n\t\t\t\t$cnt = 1;\n\t\t\t}\n\t\t\tif (file_put_contents($lock, $cnt, LOCK_EX)) {\n\t\t\t\tif ($autoUnlock) {\n\t\t\t\t\t$this->autoUnlocks[] = $hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Do unlock target item\n\t * \n\t * @param string $hash\n\t * @return boolean\n\t */\n\tprotected function itemUnlock($hash) {\n\t\tif (! $this->itemLocked($hash)) {\n\t\t\treturn true;\n\t\t}\n\t\t$lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n\t\t$cnt = file_get_contents($lock);\n\t\tif (--$cnt < 1) {\n\t\t\tunlink($lock);\n\t\t} else {\n\t\t\tfile_put_contents($lock, $cnt, LOCK_EX);\n\t\t}\n\t}\n\t\n\t/**\n\t * unlock locked items on command completion\n\t * \n\t * @return void\n\t */\n\tpublic function itemAutoUnlock() {\n\t\tif ($this->autoUnlocks) {\n\t\t\tforeach($this->autoUnlocks as $hash) {\n\t\t\t\t$this->itemUnlock($hash);\n\t\t\t}\n\t\t\t$this->autoUnlocks = array();\n\t\t}\n\t}\n\t\n\t/**\n\t * Ensure directories recursively\n\t *\n\t * @param  object  $volume  Volume object\n\t * @param  string  $target  Target hash\n\t * @param  string  $dirs    Array of directory tree to ensure\n\t * @param  string  $path    Relative path form target hash\n\t * @return array|false      array('stats' => array([stat of maked directory]), 'hashes' => array('[path]' => '[hash]'), 'makes' => array([New directory hashes]), 'error' => array([Error name]))\n\t * @author Naoki Sawada\n\t **/\n\tprotected function ensureDirsRecursively($volume, $target, $dirs, $path = '') {\n\t\t$res = array('stats' => array(), 'hashes' => array(), 'makes' => array(), 'error' => array());\n\t\tforeach($dirs as $name => $sub) {\n\t\t\t$name = (string)$name;\n\t\t\t$newDir = null;\n\t\t\tif ((($parent = $volume->realpath($target)) && ($dir = $volume->dir($volume->getHash($parent, $name)))) || ($newDir = $volume->mkdir($target, $name))) {\n\t\t\t\t$_path = $path . '/' . $name;\n\t\t\t\tif ($newDir) {\n\t\t\t\t\t$res['makes'][] = $newDir['hash'];\n\t\t\t\t\t$dir = $newDir;\n\t\t\t\t}\n\t\t\t\t$res['stats'][] = $dir;\n\t\t\t\t$res['hashes'][$_path] = $dir['hash'];\n\t\t\t\tif (count($sub)) {\n\t\t\t\t\t$res = array_merge_recursive($res, $this->ensureDirsRecursively($volume, $dir['hash'], $sub, $_path));\n\t\t\t\t\tif ($res['error']) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$res['error'][] = $name;\n\t\t\t}\n\t\t}\n\t\treturn $res;\n\t}\n\t\n\t/***************************************************************************/\n\t/*                           static  utils                                 */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Return full version of API that this connector supports all functions\n\t * \n\t * @return string\n\t */\n\tpublic static function getApiFullVersion() {\n\t\treturn (string)self::$ApiVersion . '.' . (string)self::$ApiRevision;\n\t}\n\t\n\t/**\n\t * Return Is Animation Gif\n\t * \n\t * @param  string $path server local path of target image\n\t * @return bool\n\t */\n\tpublic static function isAnimationGif($path) {\n\t\tlist($width, $height, $type, $attr) = getimagesize($path);\n\t\tswitch ($type) {\n\t\t\tcase IMAGETYPE_GIF:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\n\t\t$imgcnt = 0;\n\t\t$fp = fopen($path, 'rb');\n\t\tfread($fp, 4);\n\t\t$c = fread($fp,1);\n\t\tif (ord($c) != 0x39) {  // GIF89a\n\t\t\treturn false;\n\t\t}\n\t\n\t\twhile (!feof($fp)) {\n\t\t\tdo {\n\t\t\t\t$c = fread($fp, 1);\n\t\t\t} while(ord($c) != 0x21 && !feof($fp));\n\t\n\t\t\tif (feof($fp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\t$c2 = fread($fp,2);\n\t\t\tif (bin2hex($c2) == \"f904\") {\n\t\t\t\t$imgcnt++;\n\t\t\t\tif ($imgcnt === 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (feof($fp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\tif ($imgcnt > 1) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Return Is Animation Png\n\t *\n\t * @param  string $path server local path of target image\n\t * @return bool\n\t */\n\tpublic static function isAnimationPng($path) {\n\t\tlist($width, $height, $type, $attr) = getimagesize($path);\n\t\tswitch ($type) {\n\t\t\tcase IMAGETYPE_PNG:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$fp = fopen($path, 'rb');\n\t\t$img_bytes = fread($fp, 1024);\n\t\tfclose($fp);\n\t\tif ($img_bytes) {\n\t\t\tif (strpos(substr($img_bytes, 0, strpos($img_bytes, 'IDAT')), 'acTL') !== false) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return Is seekable stream resource\n\t * \n\t * @param resource $resource\n\t * @return bool\n\t */\n\tpublic static function isSeekableStream($resource) {\n\t\t$metadata = stream_get_meta_data($resource);\n\t\treturn $metadata['seekable'];\n\t}\n\n\t/**\n\t * Rewind stream resource\n\t * \n\t * @param resource $resource\n\t * @return void\n\t */\n\tpublic static function rewind($resource) {\n\t\tself::isSeekableStream($resource) && rewind($resource);\n\t}\n\n\t/**\n\t * serialize and base64_encode of session data (If needed)\n\t *\n\t * @deprecated\n\t * @param  mixed $var target variable\n\t * @author Naoki Sawada\n\t * @return mixed|string\n\t */\n\tpublic static function sessionDataEncode($var) {\n\t\tif (self::$base64encodeSessionData) {\n\t\t\t$var = base64_encode(serialize($var));\n\t\t}\n\t\treturn $var;\n\t}\n\n\t/**\n\t * base64_decode and unserialize of session data  (If needed)\n\t *\n\t * @deprecated\n\t * @param  mixed $var target variable\n\t * @param  bool $checkIs data type for check (array|string|object|int)\n\t * @author Naoki Sawada\n\t * @return bool|mixed\n\t */\n\tpublic static function sessionDataDecode(&$var, $checkIs = null) {\n\t\tif (self::$base64encodeSessionData) {\n\t\t\t$data = unserialize(base64_decode($var));\n\t\t} else {\n\t\t\t$data = $var;\n\t\t}\n\t\t$chk = true;\n\t\tif ($checkIs) {\n\t\t\tswitch ($checkIs) {\n\t\t\t\tcase 'array':\n\t\t\t\t\t$chk = is_array($data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'string':\n\t\t\t\t\t$chk = is_string($data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\t$chk = is_object($data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\t\t$chk = is_int($data);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!$chk) {\n\t\t\tunset($var);\n\t\t\treturn false;\n\t\t}\n\t\treturn $data;\n\t}\n\t\n\t/**\n\t * Call session_write_close() if session is restarted\n\t * \n\t * @deprecated\n\t * @return void\n\t */\n\tpublic static function sessionWrite() {\n\t\tif (session_id()) {\n\t\t\tsession_write_close();\n\t\t}\n\t}\n\n\t/**\n\t * Return elFinder static variable\n\t *\n\t * @param $key\n\t * @return mixed|null\n\t */\n\tpublic static function getStaticVar($key) {\n\t\treturn isset(elFinder::$$key)? elFinder::$$key : null;\n\t}\n\t\n\t/**\n\t * Extend PHP execution time limit and also check connection is aborted\n\t * \n\t * @param Int $time\n\t * @return void\n\t */\n\tpublic static function extendTimeLimit($time = null) {\n\t\tstatic $defLimit = null;\n\t\tif (! self::aborted()) {\n\t\t\tif (is_null($defLimit)) {\n\t\t\t\t$defLimit = ini_get('max_execution_time');\n\t\t\t}\n\t\t\tif ($defLimit != 0) {\n\t\t\t\t$time = is_null($time)? $defLimit : max($defLimit, $time);\n\t\t\t\tset_time_limit($time);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new elFinderAbortException();\n\t\t}\n\t}\n\t\n\t/**\n\t * Check connection is aborted\n\t * Script stop immediately if connection aborted\n\t *\n\t * @return void\n\t */\n\tpublic static function checkAborted() {\n\t\telFinder::extendTimeLimit();\n\t}\n\t\n\t/**\n\t * Return bytes from php.ini value\n\t * \n\t * @param string $iniName\n\t * @param string $val\n\t * @return number\n\t */\n\tpublic static function getIniBytes($iniName = '', $val = '') {\n\t\tif ($iniName !== '') {\n\t\t\t$val = ini_get($iniName);\n\t\t\tif ($val === false) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t$val = trim($val, \"bB \\t\\n\\r\\0\\x0B\");\n\t\t$last = strtolower($val[strlen($val) - 1]);\n\t\t$val = (int)$val;\n\t\tswitch($last) {\n\t\t\tcase 't':\n\t\t\t\t$val *= 1024;\n\t\t\tcase 'g':\n\t\t\t\t$val *= 1024;\n\t\t\tcase 'm':\n\t\t\t\t$val *= 1024;\n\t\t\tcase 'k':\n\t\t\t\t$val *= 1024;\n\t\t}\n\t\treturn $val;\n\t}\n\n\t/**\n\t * Get script url.\n\t * \n\t * @return string full URL\n\t * \n\t * @author Naoki Sawada\n\t */\n\tpublic static function getConnectorUrl() {\n\t\t$https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n\t\t$url = ($https ? 'https://' : 'http://')\n\t\t\t.$_SERVER['SERVER_NAME']                                              // host\n\t\t\t.(((! $https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n\t\t\t.$_SERVER['REQUEST_URI'];                                             // path & query\n\t\tlist($url) = explode('?', $url);\n\t\t\n\t\treturn $url;\n\t}\n\n\t/**\n\t * Get stream resource pointer by URL\n\t * \n\t * @param array  $data  array('target'=>'URL', 'headers' => array())\n\t * @param number $redirectLimit\n\t * @return resource|boolean\n\t * \n\t * @author Naoki Sawada\n\t */\n\tpublic static function getStreamByUrl($data, $redirectLimit = 5) {\n\t\tif (isset($data['target'])) {\n\t\t\t$data = array(\n\t\t\t\t'cnt' => 0,\n\t\t\t\t'url' => $data['target'],\n\t\t\t\t'headers' => isset($data['headers'])? $data['headers'] : array(),\n\t\t\t\t'cookies' => array(),\n\t\t\t);\n\t\t}\n\t\tif ($data['cnt'] > $redirectLimit) {\n\t\t\treturn false;\n\t\t}\n\t\t$dlurl = $data['url'];\n\t\t$data['url'] = '';\n\t\t$headers = $data['headers'];\n\t\n\t\tif ($dlurl) {\n\t\t\t$url = parse_url($dlurl);\n\t\t\t$ports = array(\n\t\t\t\t'http'  => '80',\n\t\t\t\t'ssl'   => '443',\n\t\t\t\t'ftp'   => '21'\n\t\t\t);\n\t\t\t$url['scheme'] = strtolower($url['scheme']);\n\t\t\tif ($url['scheme'] === 'https') {\n\t\t\t\t$url['scheme'] = 'ssl';\n\t\t\t}\n\t\t\tif (! isset($url['port']) && isset($ports[$url['scheme']])) {\n\t\t\t\t$url['port'] = $ports[$url['scheme']];\n\t\t\t}\n\t\t\tif (! isset($url['port'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$cookies = array();\n\t\t\tif ($data['cookies']) {\n\t\t\t\tforeach ($data['cookies'] as $d => $c) {\n\t\t\t\t\tif (strpos($url['host'], $d) !== false) {\n\t\t\t\t\t\t$cookies[] = $c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$query = isset($url['query']) ? '?'.$url['query'] : '';\n\t\t\t$stream = stream_socket_client($url['scheme'].'://'.$url['host'].':'.$url['port']);\n\t\t\tstream_set_timeout($stream, 300);\n\t\t\tfputs($stream, \"GET {$url['path']}{$query} HTTP/1.1\\r\\n\");\n\t\t\tfputs($stream, \"Host: {$url['host']}\\r\\n\");\n\t\t\tforeach($headers as $header) {\n\t\t\t\tfputs($stream, trim($header, \"\\r\\n\").\"\\r\\n\");\n\t\t\t}\n\t\t\tfputs($stream, \"Connection: Close\\r\\n\");\n\t\t\tif ($cookies) {\n\t\t\t\tfputs($stream, 'Cookie: '.implode('; ', $cookies).\"\\r\\n\");\n\t\t\t}\n\t\t\tfputs($stream, \"\\r\\n\");\n\t\t\twhile (($res = trim(fgets($stream))) !== '') {\n\t\t\t\t// find redirect\n\t\t\t\tif (preg_match('/^Location: (.+)$/', $res, $m)) {\n\t\t\t\t\t$data['url'] = $m[1];\n\t\t\t\t}\n\t\t\t\t// fetch cookie\n\t\t\t\tif (strpos($res, 'Set-Cookie:') === 0) {\n\t\t\t\t\t$domain = $url['host'];\n\t\t\t\t\tif (preg_match('/^Set-Cookie:(.+)(?:domain=\\s*([^ ;]+))?/i', $res, $c1)) {\n\t\t\t\t\t\tif (!empty($c1[2])) {\n\t\t\t\t\t\t\t$domain = trim($c1[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preg_match('/([^ ]+=[^;]+)/', $c1[1], $c2)) {\n\t\t\t\t\t\t\t$data['cookies'][$domain] = $c2[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($data['url']) {\n\t\t\t\t++$data['cnt'];\n\t\t\t\tfclose($stream);\n\n\t\t\t\treturn self::getStreamByUrl($data, $redirectLimit);\n\t\t\t}\n\n\t\t\treturn $stream;\n\t\t}\n\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Call curl_exec() with supported redirect on `safe_mode` or `open_basedir`\n\t *\n\t * @param resource    $curl\n\t * @param array       $options\n\t * @param array       $headers\n\t *\n\t * @throws \\Exception\n\t *\n\t * @return mixed\n\t * \n\t * @author Naoki Sawada\n\t */\n\tpublic static function curlExec($curl, $options = array(), $headers = array()) {\n\t\tif ($followLocation = (!ini_get('safe_mode') && !ini_get('open_basedir'))) {\n\t\t\tcurl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n\t\t}\n\t\t\n\t\tif ($options) {\n\t\t\tcurl_setopt_array($curl, $options);\n\t\t}\n\t\t\n\t\tif ($headers) {\n\t\t\tcurl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n\t\t}\n\t\t\n\t\t$result = curl_exec($curl);\n\t\t\n\t\tif (! $followLocation && $redirect = curl_getinfo($curl, CURLINFO_REDIRECT_URL)) {\n\t\t\tif ($stream = self::getStreamByUrl(array('target' => $redirect, 'headers' => $headers))) {\n\t\t\t\t$result = stream_get_contents($stream);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($result === false) {\n\t\t\tif (curl_errno($curl)) {\n\t\t\t\tthrow new \\Exception('curl_exec() failed: '.curl_error($curl));\n\t\t\t} else {\n\t\t\t\tthrow new \\Exception('curl_exec(): empty response');\n\t\t\t}\n\t\t}\n\t\t\n\t\tcurl_close($curl);\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return bool that current request was aborted by client side\n\t * \n\t * @return boolean\n\t */\n\tpublic static function aborted() {\n\t\tif ($file = self::$abortCheckFile) {\n\t\t\t(version_compare(PHP_VERSION, '5.3.0') >= 0) ? clearstatcache(true, $file) : clearstatcache();\n\t\t\tif (! is_file($file)) {\n\t\t\t\t// GC (expire 12h)\n\t\t\t\tlist($ptn) = explode('elfreq', $file);\n\t\t\t\tself::GlobGC($ptn . 'elfreq*', 43200);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Return array [\"name without extention\", \"extention\"] by filename\n\t * \n\t * @param string $name\n\t * @return array\n\t */\n\tpublic static function splitFileExtention($name) {\n\t\tif (preg_match('/^(.+?)?\\.((?:tar\\.(?:gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(?:gz|bz2)|[a-z0-9]{1,4})$/i', $name, $m)) {\n\t\t\treturn array((string)$m[1], $m[2]);\n\t\t} else {\n\t\t\treturn array($name, '');\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets the memory size by imageinfo.\n\t *\n\t * @param      array    $imgInfo   array that result of getimagesize()\n\t *\n\t * @return     integer  The memory size by imageinfo.\n\t */\n\tpublic static function getMemorySizeByImageInfo($imgInfo) {\n\t\t$width = $imgInfo[0];\n\t\t$height = $imgInfo[1];\n\t\t$bits = isset($imgInfo['bits'])? $imgInfo['bits'] : 24;\n\t\t$channels = isset($imgInfo['channels'])? $imgInfo['channels'] : 3;\n\t\treturn round(($width * $height * $bits * $channels / 8 + Pow(2, 16)) * 1.65);\n\t}\n\n\t/**\n\t * Auto expand memory for GD processing\n\t *\n\t * @param      array  $imgInfos  The image infos\n\t */\n\tpublic static function expandMemoryForGD($imgInfos) {\n\t\tif (elFinder::$memoryLimitGD != 0 && $imgInfos && is_array($imgInfos)) {\n\t\t\tif (!is_array($imgInfos[0])) {\n\t\t\t\t$imgInfos = array($imgInfos);\n\t\t\t}\n\t\t\t$limit = self::getIniBytes('', elFinder::$memoryLimitGD);\n\t\t\t$memLimit = self::getIniBytes('memory_limit');\n\t\t\t$needs = 0;\n\t\t\tforeach($imgInfos as $info) {\n\t\t\t\t$needs += self::getMemorySizeByImageInfo($info);\n\t\t\t}\n\t\t\t$needs += memory_get_usage();\n\t\t\tif ($needs > $memLimit && ($limit == -1 || $limit > $needs)) {\n\t\t\t\tini_set('memory_limit', $needs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/***************************************************************************/\n\t/*                                 callbacks                               */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Get command name of binded \"commandName.subName\"\n\t * \n\t * @param string $cmd\n\t * @return string\n\t */\n\tprotected static function getCmdOfBind($cmd) {\n\t\tlist($ret) = explode('.', $cmd);\n\t\treturn trim($ret);\n\t}\n\t\n\t/**\n\t * Add subName to commandName\n\t * \n\t * @param string $cmd\n\t * @param string $sub\n\t * @return string\n\t */\n\tprotected static function addSubToBindName($cmd, $sub) {\n\t\treturn $cmd . '.' . trim($sub);\n\t}\n\t\n\t/**\n\t * Remove a file if connection is disconnected\n\t * \n\t * @param string $file\n\t */\n\tpublic static function rmFileInDisconnected($file) {\n\t\t(connection_aborted() || connection_status() !== CONNECTION_NORMAL) && is_file($file) && unlink($file);\n\t}\n\t\n\t/**\n\t * Call back function on shutdown\n\t *  - delete files in $GLOBALS['elFinderTempFiles']\n\t * \n\t */\n\tpublic static function onShutdown() {\n\t\tself::$abortCheckFile = null;\n\t\tif (! empty($GLOBALS['elFinderTempFiles'])) {\n\t\t\tforeach(array_keys($GLOBALS['elFinderTempFiles']) as $f){\n\t\t\t\tis_file($f) && unlink($f);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Garbage collection with glob\n\t * \n\t * @param string $pattern\n\t * @param integer $time\n\t */\n\tpublic static function GlobGC($pattern, $time) {\n\t\t$now = time();\n\t\tforeach(glob($pattern) as $file) {\n\t\t\t(filemtime($file) < ($now - $time)) && unlink($file);\n\t\t}\n\t}\n\t\n} // END class\n\n/**\n * Custom exception class for aborting request\n *\n */\nclass elFinderAbortException extends Exception {}\n"], "fixing_code": ["<?php\n\n/**\n * elFinder - file manager for web.\n * Core class.\n *\n * @package elfinder\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n **/\nclass elFinder {\n\t\n\t/**\n\t * API version number\n\t *\n\t * @var float\n\t **/\n\tprotected static $ApiVersion = 2.1;\n\t\n\t/**\n\t * API version number\n\t *\n\t * @deprecated\n\t * @var string\n\t **/\n\tprotected $version;\n\t\n\t/**\n\t * API revision that this connector supports all functions\n\t * \n\t * @var integer\n\t */\n\tprotected static $ApiRevision = 35;\n\t\n\t/**\n\t * Storages (root dirs)\n\t *\n\t * @var array\n\t **/\n\tprotected $volumes = array();\n\t\n\t/**\n\t * elFinder instance\n\t * \n\t * @var object\n\t */\n\tpublic static $instance = null;\n\t\n\t/**\n\t * Current request args\n\t *\n\t * @var array\n\t */\n\tpublic static $currentArgs = array();\n\t\n\t/**\n\t * Network mount drivers\n\t * \n\t * @var array\n\t */\n\tpublic static $netDrivers = array();\n\t\n\t/**\n\t * elFinder global locale\n\t * \n\t * @var string\n\t */\n\tpublic static $locale = '';\n\t\n\t/**\n\t * elFinderVolumeDriver default mime.type file path\n\t * \n\t * @var string\n\t */\n\tpublic static $defaultMimefile = '';\n\t\n\t/**\n\t * A file save destination path when a temporary content URL is required\n\t * on a network volume or the like\n\t * It can be overwritten by volume route setting\n\t * \n\t * @var string\n\t */\n\tpublic static $tmpLinkPath = '';\n\t\n\t/**\n\t * A file save destination URL when a temporary content URL is required\n\t * on a network volume or the like\n\t * It can be overwritten by volume route setting\n\t *\n\t * @var string\n\t */\n\tpublic static $tmpLinkUrl = '';\n\t\n\t/**\n\t * Temporary content URL lifetime (seconds)\n\t * \n\t * @var integer\n\t */\n\tpublic static $tmpLinkLifeTime = 3600;\n\t\n\t/**\n\t * MIME type list handled as a text file\n\t *\n\t * @var array\n\t */\n\tpublic static $textMimes = array(\n\t\t'application/x-empty',\n\t\t'application/javascript',\n\t\t'application/json',\n\t\t'application/xhtml+xml',\n\t\t'audio/x-mp3-playlist',\n\t\t'application/x-web-config',\n\t\t'application/docbook+xml',\n\t\t'application/x-php',\n\t\t'application/x-perl',\n\t\t'application/x-awk',\n\t\t'application/x-config',\n\t\t'application/x-csh',\n\t\t'application/xml',\n\t\t'application/sql'\n\t);\n\t\n\t/**\n\t * Maximum memory size to be extended during GD processing\n\t * (0: not expanded, -1: unlimited or memory size notation)\n\t *\n\t * @var integer|string\n\t */\n\tpublic static $memoryLimitGD = 0;\n\n\t/**\n\t * Path of current request flag file for abort check\n\t * \n\t * @var string\n\t */\n\tprotected static $abortCheckFile = null;\n\t\n\t/**\n\t * elFinder session wrapper object\n\t * \n\t * @var elFinderSessionInterface\n\t */\n\tprotected $session;\n\t\n\t/**\n\t * elFinder global sessionCacheKey\n\t * \n\t * @deprecated\n\t * @var string\n\t */\n\tpublic static $sessionCacheKey = '';\n\t\n\t/**\n\t * Is session closed\n\t * \n\t * @deprecated\n\t * @var bool\n\t */\n\tprivate static $sessionClosed = false;\n\t\n\t/**\n\t * elFinder base64encodeSessionData\n\t * elFinder save session data as `UTF-8`\n\t * If the session storage mechanism of the system does not allow `UTF-8`\n\t * And it must be `true` option 'base64encodeSessionData' of elFinder\n\t * \n\t * WARNING: When enabling this option, if saving the data passed from the user directly to the session variable,\n\t * it make vulnerable to the object injection attack, so use it carefully.\n\t * see https://github.com/Studio-42/elFinder/issues/2345\n\t * \n\t * @var bool\n\t */\n\tprotected static $base64encodeSessionData = false;\n\t\n\t/**\n\t * elFinder common tempraly path\n\t *\n\t * @var string\n\t * @default \"./.tmp\" or sys_get_temp_dir()\n\t **/\n\tprotected static $commonTempPath = '';\n\t\n\t/**\n\t * Connection flag files path that connection check of current request\n\t * \n\t * @var string\n\t * @default value of $commonTempPath\n\t */\n\tprotected static $connectionFlagsPath = '';\n\t\n\t/**\n\t * Additional volume root options for network mounting volume\n\t * \n\t * @var array\n\t */\n\tprotected $optionsNetVolumes = array();\n\t\n\t/**\n\t * Session key of net mount volumes\n\t *\n\t * @deprecated\n\t * @var string\n\t */\n\tprotected $netVolumesSessionKey = '';\n\t\n\t/**\n\t * Mounted volumes count\n\t * Required to create unique volume id\n\t *\n\t * @var int\n\t **/\n\tpublic static $volumesCnt = 1;\n\t\n\t/**\n\t * Default root (storage)\n\t *\n\t * @var elFinderStorageDriver\n\t **/\n\tprotected $default = null;\n\t\n\t/**\n\t * Commands and required arguments list\n\t *\n\t * @var array\n\t **/\n\tprotected $commands = array(\n\t\t'open'      => array('target' => false, 'tree' => false, 'init' => false, 'mimes' => false, 'compare' => false),\n\t\t'ls'        => array('target' => true, 'mimes' => false, 'intersect' => false),\n\t\t'tree'      => array('target' => true),\n\t\t'parents'   => array('target' => true, 'until' => false),\n\t\t'tmb'       => array('targets' => true),\n\t\t'file'      => array('target' => true, 'download' => false),\n\t\t'zipdl'     => array('targets' => true, 'download' => false),\n\t\t'size'      => array('targets' => true),\n\t\t'mkdir'     => array('target' => true, 'name' => false, 'dirs' => false),\n\t\t'mkfile'    => array('target' => true, 'name' => true, 'mimes' => false),\n\t\t'rm'        => array('targets' => true),\n\t\t'rename'    => array('target' => true, 'name' => true, 'mimes' => false, 'targets' => false, 'q' => false),\n\t\t'duplicate' => array('targets' => true, 'suffix' => false),\n\t\t'paste'     => array('dst' => true, 'targets' => true, 'cut' => false, 'mimes' => false, 'renames' => false, 'hashes' => false, 'suffix' => false),\n\t\t'upload'    => array('target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false),\n\t\t'get'       => array('target' => true, 'conv' => false),\n\t\t'put'       => array('target' => true, 'content' => '', 'mimes' => false, 'encoding' => false),\n\t\t'archive'   => array('targets' => true, 'type' => true, 'mimes' => false, 'name' => false),\n\t\t'extract'   => array('target' => true, 'mimes' => false, 'makedir' => false),\n\t\t'search'    => array('q' => true, 'mimes' => false, 'target' => false),\n\t\t'info'      => array('targets' => true, 'compare' => false),\n\t\t'dim'       => array('target' => true, 'substitute' => false),\n\t\t'resize'    => array('target' => true, 'width' => false, 'height' => false, 'mode' => false, 'x' => false, 'y' => false, 'degree' => false, 'quality' => false, 'bg' => false),\n\t\t'netmount'  => array('protocol' => true, 'host' => true, 'path' => false, 'port' => false, 'user' => false, 'pass' => false, 'alias' => false, 'options' => false),\n\t\t'url'       => array('target' => true, 'options' => false),\n\t\t'callback'  => array('node' => true, 'json' => false, 'bind' => false, 'done' => false),\n\t\t'chmod'     => array('targets' => true, 'mode' => true),\n\t\t'subdirs'   => array('targets' => true),\n\t\t'abort'     => array('id' => true),\n\t\t'editor'    => array('name' => true, 'method' => true, 'args' => false)\n\t);\n\t\n\t/**\n\t * Plugins instance\n\t *\n\t * @var array\n\t **/\n\tprotected $plugins = array();\n\t\n\t/**\n\t * Commands listeners\n\t *\n\t * @var array\n\t **/\n\tprotected $listeners = array();\n\t\n\t/**\n\t * script work time for debug\n\t *\n\t * @var string\n\t **/\n\tprotected $time = 0;\n\t/**\n\t * Is elFinder init correctly?\n\t *\n\t * @var bool\n\t **/\n\tprotected $loaded = false;\n\t/**\n\t * Send debug to client?\n\t *\n\t * @var string\n\t **/\n\tprotected $debug = false;\n\t\n\t/**\n\t * Call `session_write_close()` before exec command?\n\t * \n\t * @var bool\n\t */\n\tprotected $sessionCloseEarlier = true;\n\n\t/**\n\t * SESSION use commands @see __construct()\n\t * \n\t * @var array\n\t */\n\tprotected $sessionUseCmds = array();\n\t\n\t/**\n\t * session expires timeout\n\t *\n\t * @var int\n\t **/\n\tprotected $timeout = 0;\n\t\n\t/**\n\t * Temp dir path for Upload\n\t * \n\t * @var string\n\t */\n\tprotected $uploadTempPath = '';\n\t\n\t/**\n\t * Max allowed archive files size (0 - no limit)\n\t * \n\t * @var integer\n\t */\n\tprotected $maxArcFilesSize = 0;\n\t\n\t/**\n\t * undocumented class variable\n\t *\n\t * @var string\n\t **/\n\tprotected $uploadDebug = '';\n\t\n\t/**\n\t * Max allowed numbar of @var targets (0 - no limit)\n\t * \n\t * @var integer\n\t */\n\tpublic $maxTargets = 1000;\n\t\n\t/**\n\t * Errors from PHP\n\t *\n\t * @var array\n\t **/\n\tpublic static $phpErrors = array();\n\t\n\t/**\n\t * Errors from not mounted volumes\n\t *\n\t * @var array\n\t **/\n\tpublic $mountErrors = array();\n\t\n\t/**\n\t * URL for callback output window for CORS\n\t * redirect to this URL when callback output\n\t * \n\t * @var string URL\n\t */\n\tprotected $callbackWindowURL = '';\n\t\n\t/**\n\t * hash of items to unlock on command completion\n\t * \n\t * @var array hashes\n\t */\n\tprotected $autoUnlocks = array();\n\t\n\t/**\n\t * Item locking expiration (seconds)\n\t * Default: 3600 secs\n\t * \n\t * @var integer\n\t */\n\tprotected $itemLockExpire = 3600;\n\n\t/**\n\t * Additional request querys\n\t * \n\t * @var array|null\n\t */\n\tprotected $customData = null;\n\n\t// Errors messages\n\tconst ERROR_UNKNOWN           = 'errUnknown';\n\tconst ERROR_UNKNOWN_CMD       = 'errUnknownCmd';\n\tconst ERROR_CONF              = 'errConf';\n\tconst ERROR_CONF_NO_JSON      = 'errJSON';\n\tconst ERROR_CONF_NO_VOL       = 'errNoVolumes';\n\tconst ERROR_INV_PARAMS        = 'errCmdParams';\n\tconst ERROR_OPEN              = 'errOpen';\n\tconst ERROR_DIR_NOT_FOUND     = 'errFolderNotFound';\n\tconst ERROR_FILE_NOT_FOUND    = 'errFileNotFound';     // 'File not found.'\n\tconst ERROR_TRGDIR_NOT_FOUND  = 'errTrgFolderNotFound'; // 'Target folder \"$1\" not found.'\n\tconst ERROR_NOT_DIR           = 'errNotFolder';\n\tconst ERROR_NOT_FILE          = 'errNotFile';\n\tconst ERROR_PERM_DENIED       = 'errPerm';\n\tconst ERROR_LOCKED            = 'errLocked';        // '\"$1\" is locked and can not be renamed, moved or removed.'\n\tconst ERROR_EXISTS            = 'errExists';        // 'File named \"$1\" already exists.'\n\tconst ERROR_INVALID_NAME      = 'errInvName';       // 'Invalid file name.'\n\tconst ERROR_INVALID_DIRNAME   = 'errInvDirname';    // 'Invalid folder name.'\n\tconst ERROR_MKDIR             = 'errMkdir';\n\tconst ERROR_MKFILE            = 'errMkfile';\n\tconst ERROR_RENAME            = 'errRename';\n\tconst ERROR_COPY              = 'errCopy';\n\tconst ERROR_MOVE              = 'errMove';\n\tconst ERROR_COPY_FROM         = 'errCopyFrom';\n\tconst ERROR_COPY_TO           = 'errCopyTo';\n\tconst ERROR_COPY_ITSELF       = 'errCopyInItself';\n\tconst ERROR_REPLACE           = 'errReplace';          // 'Unable to replace \"$1\".'\n\tconst ERROR_RM                = 'errRm';               // 'Unable to remove \"$1\".'\n\tconst ERROR_RM_SRC            = 'errRmSrc';            // 'Unable remove source file(s)'\n\tconst ERROR_MKOUTLINK         = 'errMkOutLink';        // 'Unable to create a link to outside the volume root.'\n\tconst ERROR_UPLOAD            = 'errUpload';           // 'Upload error.'\n\tconst ERROR_UPLOAD_FILE       = 'errUploadFile';       // 'Unable to upload \"$1\".'\n\tconst ERROR_UPLOAD_NO_FILES   = 'errUploadNoFiles';    // 'No files found for upload.'\n\tconst ERROR_UPLOAD_TOTAL_SIZE = 'errUploadTotalSize';  // 'Data exceeds the maximum allowed size.'\n\tconst ERROR_UPLOAD_FILE_SIZE  = 'errUploadFileSize';   // 'File exceeds maximum allowed size.'\n\tconst ERROR_UPLOAD_FILE_MIME  = 'errUploadMime';       // 'File type not allowed.'\n\tconst ERROR_UPLOAD_TRANSFER   = 'errUploadTransfer';   // '\"$1\" transfer error.'\n\tconst ERROR_UPLOAD_TEMP       = 'errUploadTemp';       // 'Unable to make temporary file for upload.'\n\tconst ERROR_ACCESS_DENIED     = 'errAccess';\n\tconst ERROR_NOT_REPLACE       = 'errNotReplace';       // Object \"$1\" already exists at this location and can not be replaced with object of another type.\n\tconst ERROR_SAVE              = 'errSave';\n\tconst ERROR_EXTRACT           = 'errExtract';\n\tconst ERROR_ARCHIVE           = 'errArchive';\n\tconst ERROR_NOT_ARCHIVE       = 'errNoArchive';\n\tconst ERROR_ARCHIVE_TYPE      = 'errArcType';\n\tconst ERROR_ARC_SYMLINKS      = 'errArcSymlinks';\n\tconst ERROR_ARC_MAXSIZE       = 'errArcMaxSize';\n\tconst ERROR_RESIZE            = 'errResize';\n\tconst ERROR_RESIZESIZE        = 'errResizeSize';\n\tconst ERROR_UNSUPPORT_TYPE    = 'errUsupportType';\n\tconst ERROR_CONV_UTF8         = 'errConvUTF8';\n\tconst ERROR_NOT_UTF8_CONTENT  = 'errNotUTF8Content';\n\tconst ERROR_NETMOUNT          = 'errNetMount';\n\tconst ERROR_NETUNMOUNT        = 'errNetUnMount';\n\tconst ERROR_NETMOUNT_NO_DRIVER = 'errNetMountNoDriver';\n\tconst ERROR_NETMOUNT_FAILED   = 'errNetMountFailed';\n\tconst ERROR_SESSION_EXPIRES   = 'errSessionExpires';\n\tconst ERROR_CREATING_TEMP_DIR = 'errCreatingTempDir';\n\tconst ERROR_FTP_DOWNLOAD_FILE = 'errFtpDownloadFile';\n\tconst ERROR_FTP_UPLOAD_FILE   = 'errFtpUploadFile';\n\tconst ERROR_FTP_MKDIR         = 'errFtpMkdir';\n\tconst ERROR_ARCHIVE_EXEC      = 'errArchiveExec';\n\tconst ERROR_EXTRACT_EXEC      = 'errExtractExec';\n\tconst ERROR_SEARCH_TIMEOUT    = 'errSearchTimeout';    // 'Timed out while searching \"$1\". Search result is partial.'\n\tconst ERROR_REAUTH_REQUIRE    = 'errReauthRequire';  // 'Re-authorization is required.'\n\tconst ERROR_MAX_TARGTES       = 'errMaxTargets'; // 'Max number of selectable items is $1.'\n\n\t/**\n\t * Constructor\n\t *\n\t * @param  array  elFinder and roots configurations\n\t * @author Dmitry (dio) Levashov\n\t */\n\tpublic function __construct($opts) {\n\t\t// set default_charset\n\t\tif (version_compare(PHP_VERSION, '5.6', '>=')) {\n\t\t\tif (($_val = ini_get('iconv.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n\t\t\t\tini_set('iconv.internal_encoding', '');\n\t\t\t}\n\t\t\tif (($_val = ini_get('mbstring.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n\t\t\t\tini_set('mbstring.internal_encoding', '');\n\t\t\t}\n\t\t\tif (($_val = ini_get('internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n\t\t\t\tini_set('internal_encoding', '');\n\t\t\t}\n\t\t} else {\n\t\t\tif (function_exists('iconv_set_encoding') && strtoupper(iconv_get_encoding('internal_encoding')) !== 'UTF-8') {\n\t\t\t\ticonv_set_encoding('internal_encoding', 'UTF-8');\n\t\t\t}\n\t\t\tif (function_exists('mb_internal_encoding') && strtoupper(mb_internal_encoding()) !== 'UTF-8') {\n\t\t\t\tmb_internal_encoding('UTF-8');\n\t\t\t}\n\t\t}\n\t\tini_set('default_charset', 'UTF-8');\n\t\t\n\t\t// define accept constant of server commands path\n\t\t! defined('ELFINDER_TAR_PATH')      && define('ELFINDER_TAR_PATH',      'tar');\n\t\t! defined('ELFINDER_GZIP_PATH')     && define('ELFINDER_GZIP_PATH',     'gzip');\n\t\t! defined('ELFINDER_BZIP2_PATH')    && define('ELFINDER_BZIP2_PATH',    'bzip2');\n\t\t! defined('ELFINDER_XZ_PATH')       && define('ELFINDER_XZ_PATH',       'xz');\n\t\t! defined('ELFINDER_ZIP_PATH')      && define('ELFINDER_ZIP_PATH',      'zip');\n\t\t! defined('ELFINDER_UNZIP_PATH')    && define('ELFINDER_UNZIP_PATH',    'unzip');\n\t\t! defined('ELFINDER_RAR_PATH')      && define('ELFINDER_RAR_PATH',      'rar');\n\t\t! defined('ELFINDER_UNRAR_PATH')    && define('ELFINDER_UNRAR_PATH',    'unrar');\n\t\t! defined('ELFINDER_7Z_PATH')       && define('ELFINDER_7Z_PATH', (substr(PHP_OS, 0, 3) === 'WIN')? '7z' : '7za');\n\t\t! defined('ELFINDER_CONVERT_PATH')  && define('ELFINDER_CONVERT_PATH',  'convert');\n\t\t! defined('ELFINDER_EXIFTRAN_PATH') && define('ELFINDER_EXIFTRAN_PATH', 'exiftran');\n\t\t! defined('ELFINDER_JPEGTRAN_PATH') && define('ELFINDER_JPEGTRAN_PATH', 'jpegtran');\n\t\t! defined('ELFINDER_FFMPEG_PATH')   && define('ELFINDER_FFMPEG_PATH',   'ffmpeg');\n\t\t\n\t\t! defined('ELFINDER_DISABLE_ZIPEDITOR') && define('ELFINDER_DISABLE_ZIPEDITOR', false);\n\n\t\t// for backward compat\n\t\t$this->version = (string)self::$ApiVersion;\n\t\t\n\t\t// set error handler of WARNING, NOTICE\n\t\t$errLevel = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_STRICT | E_RECOVERABLE_ERROR;\n\t\tif (defined('E_DEPRECATED')) {\n\t\t\t$errLevel |= E_DEPRECATED | E_USER_DEPRECATED;\n\t\t}\n\t\tset_error_handler('elFinder::phpErrorHandler', $errLevel);\n\t\t\n\t\t// Associative array of files to delete at the end of script: ['temp file path' => true]\n\t\t$GLOBALS['elFinderTempFiles'] = array();\n\t\t// regist Shutdown function\n\t\tregister_shutdown_function(array('elFinder', 'onShutdown'));\n\t\t\n\t\t// convert PATH_INFO to GET query\n\t\tif (! empty($_SERVER['PATH_INFO'])) {\n\t\t\t$_ps = explode('/', trim($_SERVER['PATH_INFO'], '/'));\n\t\t\tif (! isset($_GET['cmd'])) {\n\t\t\t\t$_cmd = $_ps[0];\n\t\t\t\tif (isset($this->commands[$_cmd])) {\n\t\t\t\t\t$_GET['cmd'] = $_cmd;\n\t\t\t\t\t$_i = 1;\n\t\t\t\t\tforeach(array_keys($this->commands[$_cmd]) as $_k) {\n\t\t\t\t\t\tif (isset($_ps[$_i])) {\n\t\t\t\t\t\t\tif (! isset($_GET[$_k])) {\n\t\t\t\t\t\t\t\t$_GET[$_k] = $_ps[$_i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set elFinder instance\n\t\telFinder::$instance = $this;\n\t\t\n\t\t// setup debug mode\n\t\t$this->debug = (isset($opts['debug']) && $opts['debug'] ? true : false);\n\t\tif ($this->debug) {\n\t\t\terror_reporting(defined('ELFINDER_DEBUG_ERRORLEVEL')? ELFINDER_DEBUG_ERRORLEVEL : -1);\n\t\t\tini_set('display_errors', '1');\n\t\t\t// clear output buffer and stop output filters\n\t\t\twhile(ob_get_level() && ob_end_clean()){}\n\t\t}\n\n\t\tif (! interface_exists('elFinderSessionInterface')) {\n\t\t\tinclude_once dirname(__FILE__).'/elFinderSessionInterface.php';\n\t\t}\n\t\t\n\t\t// session handler\n\t\tif (!empty($opts['session']) && $opts['session'] instanceof elFinderSessionInterface) {\n\t\t\t$this->session = $opts['session'];\n\t\t} else {\n\t\t\t$sessionOpts = array(\n\t\t\t\t'base64encode' => !empty($opts['base64encodeSessionData']),\n\t\t\t\t'keys' => array(\n\t\t\t\t\t'default'   => !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches',\n\t\t\t\t\t'netvolume' => !empty($opts['netVolumesSessionKey'])? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes'\n\t\t\t\t)\n\t\t\t);\n\t\t\tif (! class_exists('elFinderSession')) {\n\t\t\t\tinclude_once dirname(__FILE__) . '/elFinderSession.php';\n\t\t\t}\n\t\t\t$this->session = new elFinderSession($sessionOpts);\n\t\t}\n\t\t// try session start | restart\n\t\t$this->session->start();\n\t\t\n\t\t// 'netmount' added to handle requests synchronously on unmount\n\t\t$sessionUseCmds = array('netmount');\n\t\tif (isset($opts['sessionUseCmds']) && is_array($opts['sessionUseCmds'])) {\n\t\t\t$sessionUseCmds = array_merge($sessionUseCmds, $opts['sessionUseCmds']);\n\t\t}\n\n\t\t// set self::$volumesCnt by HTTP header \"X-elFinder-VolumesCntStart\"\n\t\tif (isset($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']) && ($volumesCntStart = intval($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']))) {\n\t\t\tself::$volumesCnt = $volumesCntStart;\n\t\t}\n\t\t\n\t\t$this->time  = $this->utime();\n\t\t$this->sessionCloseEarlier = isset($opts['sessionCloseEarlier'])? (bool)$opts['sessionCloseEarlier'] : true;\n\t\t$this->sessionUseCmds = array_flip($sessionUseCmds);\n\t\t$this->timeout = (isset($opts['timeout']) ? $opts['timeout'] : 0);\n\t\t$this->uploadTempPath = (isset($opts['uploadTempPath']) ? $opts['uploadTempPath'] : '');\n\t\t$this->callbackWindowURL = (isset($opts['callbackWindowURL']) ? $opts['callbackWindowURL'] : '');\n\t\t$this->maxTargets = (isset($opts['maxTargets']) ? intval($opts['maxTargets']) : $this->maxTargets);\n\t\telFinder::$commonTempPath = (isset($opts['commonTempPath']) ? $opts['commonTempPath'] : './.tmp');\n\t\tif (!is_writable(elFinder::$commonTempPath)) {\n\t\t\telFinder::$commonTempPath = sys_get_temp_dir();\n\t\t\tif (!is_writable(elFinder::$commonTempPath)) {\n\t\t\t\telFinder::$commonTempPath = '';\n\t\t\t}\n\t\t}\n\t\tif (isset($opts['connectionFlagsPath']) && is_writable($opts['connectionFlagsPath'])) {\n\t\t\telFinder::$connectionFlagsPath = $opts['connectionFlagsPath'];\n\t\t} else {\n\t\t\telFinder::$connectionFlagsPath = elFinder::$commonTempPath;\n\t\t}\n\t\t\n\t\tif (! empty($opts['tmpLinkPath'])) {\n\t\t\telFinder::$tmpLinkPath = $opts['tmpLinkPath'];\n\t\t}\n\t\tif (! empty($opts['tmpLinkUrl'])) {\n\t\t\telFinder::$tmpLinkUrl = $opts['tmpLinkUrl'];\n\t\t}\n\t\tif (! empty($opts['tmpLinkLifeTime'])) {\n\t\t\telFinder::$tmpLinkLifeTime = $opts['tmpLinkLifeTime'];\n\t\t}\n\t\tif (! empty($opts['textMimes']) && is_array($opts['textMimes'])) {\n\t\t\telfinder::$textMimes = $opts['textMimes'];\n\t\t}\n\t\t$this->maxArcFilesSize = isset($opts['maxArcFilesSize'])? intval($opts['maxArcFilesSize']) : 0;\n\t\t$this->optionsNetVolumes = (isset($opts['optionsNetVolumes']) && is_array($opts['optionsNetVolumes']))? $opts['optionsNetVolumes'] : array();\n\t\tif (isset($opts['itemLockExpire'])) {\n\t\t\t$this->itemLockExpire = intval($opts['itemLockExpire']);\n\t\t}\n\t\t\n\t\t// deprecated settings\n\t\t$this->netVolumesSessionKey = !empty($opts['netVolumesSessionKey'])? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes';\n\t\tself::$sessionCacheKey = !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches';\n\t\t\n\t\t// check session cache\n\t\t$_optsMD5 = md5(json_encode($opts['roots']));\n\t\tif ($this->session->get('_optsMD5') !== $_optsMD5) {\n\t\t\t$this->session->set('_optsMD5', $_optsMD5);\n\t\t}\n\t\t\n\t\t// setlocale and global locale regists to elFinder::locale\n\t\tself::$locale = !empty($opts['locale']) ? $opts['locale'] : (substr(PHP_OS, 0, 3) === 'WIN'? 'C' : 'en_US.UTF-8');\n\t\tif (false === setlocale(LC_ALL, self::$locale)) {\n\t\t\tself::$locale = setlocale(LC_ALL, '0');\n\t\t}\n\n\t\t// set defaultMimefile\n\t\telFinder::$defaultMimefile = isset($opts['defaultMimefile'])? $opts['defaultMimefile'] : '';\n\n\t\t// set memoryLimitGD\n\t\telFinder::$memoryLimitGD = isset($opts['memoryLimitGD'])? $opts['memoryLimitGD'] : 0;\n\n\t\t// bind events listeners\n\t\tif (!empty($opts['bind']) && is_array($opts['bind'])) {\n\t\t\t$_req = $_SERVER[\"REQUEST_METHOD\"] == 'POST' ? $_POST : $_GET;\n\t\t\t$_reqCmd = isset($_req['cmd']) ? $_req['cmd'] : '';\n\t\t\tforeach ($opts['bind'] as $cmd => $handlers) {\n\t\t\t\t$doRegist = (strpos($cmd, '*') !== false);\n\t\t\t\tif (! $doRegist) {\n\t\t\t\t\t$doRegist = ($_reqCmd && in_array($_reqCmd, array_map('self::getCmdOfBind', explode(' ', $cmd))));\n\t\t\t\t}\n\t\t\t\tif ($doRegist) {\n\t\t\t\t\t// for backward compatibility\n\t\t\t\t\tif (! is_array($handlers)) {\n\t\t\t\t\t\t$handlers = array($handlers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (count($handlers) === 2 && is_object($handlers[0])) {\n\t\t\t\t\t\t\t$handlers = array($handlers);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tforeach($handlers as $handler) {\n\t\t\t\t\t\tif ($handler) {\n\t\t\t\t\t\t\tif (is_string($handler) && strpos($handler, '.')) {\n\t\t\t\t\t\t\t\tlist($_domain, $_name, $_method) = array_pad(explode('.', $handler), 3, '');\n\t\t\t\t\t\t\t\tif (strcasecmp($_domain, 'plugin') === 0) {\n\t\t\t\t\t\t\t\t\tif ($plugin = $this->getPluginInstance($_name, isset($opts['plugin'][$_name])? $opts['plugin'][$_name] : array())\n\t\t\t\t\t\t\t\t\t\t\tand method_exists($plugin, $_method)) {\n\t\t\t\t\t\t\t\t\t\t$this->bind($cmd, array($plugin, $_method));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$this->bind($cmd, $handler);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isset($opts['roots']) || !is_array($opts['roots'])) {\n\t\t\t$opts['roots'] = array();\n\t\t}\n\n\t\t// try to enable elFinderVolumeFlysystemZipArchiveNetmount to zip editing\n\t\tif (empty(elFinder::$netDrivers['ziparchive'])) {\n\t\t\telFinder::$netDrivers['ziparchive'] = 'FlysystemZipArchiveNetmount';\n\t\t}\n\n\t\t// check for net volumes stored in session\n\t\t$netVolumes = $this->getNetVolumes();\n\t\tforeach ($netVolumes as $key => $root) {\n\t\t\tif (! isset($root['id'])) {\n\t\t\t\t// given fixed unique id\n\t\t\t\tif (! $root['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n\t\t\t\t\t$this->mountErrors[] = 'Netmount Driver \"'.$root['driver'].'\" : Could\\'t given volume id.';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$opts['roots'][$key] = $root;\n\t\t}\n\n\t\t// \"mount\" volumes\n\t\tforeach ($opts['roots'] as $i => $o) {\n\t\t\t$class = 'elFinderVolume'.(isset($o['driver']) ? $o['driver'] : '');\n\n\t\t\tif (class_exists($class)) {\n\t\t\t\t$volume = new $class();\n\n\t\t\t\ttry {\n\t\t\t\t\tif ($this->maxArcFilesSize && (empty($o['maxArcFilesSize']) || $this->maxArcFilesSize < $o['maxArcFilesSize'])) {\n\t\t\t\t\t\t$o['maxArcFilesSize'] = $this->maxArcFilesSize;\n\t\t\t\t\t}\n\t\t\t\t\t// pass session handler\n\t\t\t\t\t$volume->setSession($this->session);\n\t\t\t\t\tif ($volume->mount($o)) {\n\t\t\t\t\t\t// unique volume id (ends on \"_\") - used as prefix to files hash\n\t\t\t\t\t\t$id = $volume->id();\n\t\t\t\t\t\t\n\t\t\t\t\t\t$this->volumes[$id] = $volume;\n\t\t\t\t\t\tif ((!$this->default || $volume->root() !== $volume->defaultPath()) && $volume->isReadable()) {\n\t\t\t\t\t\t\t$this->default = $this->volumes[$id]; \n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->removeNetVolume($i, $volume);\n\t\t\t\t\t\t$this->mountErrors[] = 'Driver \"'.$class.'\" : '.implode(' ', $volume->error());\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception $e) {\n\t\t\t\t\t$this->removeNetVolume($i, $volume);\n\t\t\t\t\t$this->mountErrors[] = 'Driver \"'.$class.'\" : '.$e->getMessage();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->removeNetVolume($i, $volume);\n\t\t\t\t$this->mountErrors[] = 'Driver \"'.$class.'\" does not exist';\n\t\t\t}\n\t\t}\n\n\t\t// if at least one readable volume - ii desu >_<\n\t\t$this->loaded = !empty($this->default);\n\t\t\n\t\t// restore error handler for now\n\t\trestore_error_handler();\n\t}\n\t\n\t/**\n\t * Return elFinder session wrapper instance\n\t *\n\t * @return  object  elFinderSessionInterface\n\t **/\n\tpublic function getSession() {\n\t\treturn $this->session;\n\t}\n\t\n\t/**\n\t * Return true if fm init correctly\n\t *\n\t * @return bool\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function loaded() {\n\t\treturn $this->loaded;\n\t}\n\t\n\t/**\n\t * Return version (api) number\n\t *\n\t * @return string\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function version() {\n\t\treturn self::$ApiVersion;\n\t}\n\t\n\t/**\n\t * Return revision (api) number\n\t *\n\t * @return string\n\t * @author Naoki Sawada\n\t **/\n\tpublic function revision() {\n\t\treturn self::$ApiRevision;\n\t}\n\t\n\t/**\n\t * Add handler to elFinder command\n\t *\n\t * @param  string  command name\n\t * @param  string|array  callback name or array(object, method)\n\t * @return elFinder\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function bind($cmd, $handler) {\n\t\t$allCmds = array_keys($this->commands);\n\t\t$cmds = array();\n\t\tforeach(explode(' ', $cmd) as $_cmd) {\n\t\t\tif ($_cmd !== '') {\n\t\t\t\tif ($all = strpos($_cmd, '*') !== false) {\n\t\t\t\t\tlist(, $sub) = array_pad(explode('.', $_cmd), 2, '');\n\t\t\t\t\tif ($sub) {\n\t\t\t\t\t\t$sub = str_replace('\\'', '\\\\\\'', $sub);\n\t\t\t\t\t\t$subs = array_fill(0, count($allCmds), $sub);\n\t\t\t\t\t\t$cmds = array_merge($cmds, array_map(array('elFinder', 'addSubToBindName'), $allCmds, $subs));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$cmds = array_merge($cmds, $allCmds);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$cmds[] = $_cmd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$cmds = array_unique($cmds);\n\t\t\n\t\tforeach ($cmds as $cmd) {\n\t\t\tif (!isset($this->listeners[$cmd])) {\n\t\t\t\t$this->listeners[$cmd] = array();\n\t\t\t}\n\n\t\t\tif (is_callable($handler)) {\n\t\t\t\t$this->listeners[$cmd][] = $handler;\n\t\t\t}\n\t\t}\n\n\t\treturn $this;\n\t}\n\t\n\t/**\n\t * Remove event (command exec) handler\n\t *\n\t * @param  string  command name\n\t * @param  string|array  callback name or array(object, method)\n\t * @return elFinder\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function unbind($cmd, $handler) {\n\t\tif (!empty($this->listeners[$cmd])) {\n\t\t\tforeach ($this->listeners[$cmd] as $i => $h) {\n\t\t\t\tif ($h === $handler) {\n\t\t\t\t\tunset($this->listeners[$cmd][$i]);\n\t\t\t\t\treturn $this;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $this;\n\t}\n\t\n\t/**\n\t * Return true if command exists\n\t *\n\t * @param  string  command name\n\t * @return bool\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function commandExists($cmd) {\n\t\treturn $this->loaded && isset($this->commands[$cmd]) && method_exists($this, $cmd);\n\t}\n\t\n\t/**\n\t * Return root - file's owner (public func of volume())\n\t *\n\t * @param  string  file hash\n\t * @return elFinderStorageDriver\n\t * @author Naoki Sawada\n\t */\n\tpublic function getVolume($hash) {\n\t\treturn $this->volume($hash);\n\t}\n\t\n\t/**\n\t * Return command required arguments info\n\t *\n\t * @param  string  command name\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function commandArgsList($cmd) {\n\t\tif ($this->commandExists($cmd)) {\n\t\t\t$list = $this->commands[$cmd];\n\t\t\t$list['reqid'] = false;\n\t\t} else {\n\t\t\t$list = array();\n\t\t}\n\t\treturn $list;\n\t}\n\n\tprivate function session_expires() {\n\t\t\n\t\tif (! $last = $this->session->get(':LAST_ACTIVITY')) {\n\t\t\t$this->session->set(':LAST_ACTIVITY', time());\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ($this->timeout > 0) && (time() - $last > $this->timeout) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$this->session->set(':LAST_ACTIVITY', time());\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Exec command and return result\n\t *\n\t * @param  string  $cmd  command name\n\t * @param  array   $args command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function exec($cmd, $args) {\n\t\t// set error handler of WARNING, NOTICE\n\t\tset_error_handler('elFinder::phpErrorHandler', E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE);\n\t\t\n\t\t// set current request args\n\t\tself::$currentArgs = $args;\n\t\t\n\t\tif (!$this->loaded) {\n\t\t\treturn array('error' => $this->error(self::ERROR_CONF, self::ERROR_CONF_NO_VOL));\n\t\t}\n\n\t\tif ($this->session_expires()) {\n\t\t\treturn array('error' => $this->error(self::ERROR_SESSION_EXPIRES));\n\t\t}\n\t\t\n\t\tif (!$this->commandExists($cmd)) {\n\t\t\treturn array('error' => $this->error(self::ERROR_UNKNOWN_CMD));\n\t\t}\n\t\t\n\t\t// check request id\n\t\t$args['reqid'] = preg_replace('[^0-9a-fA-F]', '', ! empty($args['reqid'])? $args['reqid'] : (! empty($_SERVER['HTTP_X_ELFINDERREQID'])? $_SERVER['HTTP_X_ELFINDERREQID'] : ''));\n\t\t\n\t\t// to abort this request\n\t\tif ($cmd === 'abort') {\n\t\t\t$this->abort($args);\n\t\t\treturn array('error' => 0);\n\t\t}\n\t\t\n\t\t// make flag file and set self::$abortCheckFile\n\t\tif ($args['reqid']) {\n\t\t\t$this->abort(array('makeFile' => $args['reqid']));\n\t\t}\n\t\t\n\t\tif (!empty($args['mimes']) && is_array($args['mimes'])) {\n\t\t\tforeach ($this->volumes as $id => $v) {\n\t\t\t\t$this->volumes[$id]->setMimesFilter($args['mimes']);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// regist shutdown function as fallback\n\t\tregister_shutdown_function(array($this, 'itemAutoUnlock'));\n\t\t\n\t\t// detect destination dirHash and volume\n\t\t$dstVolume = false;\n\t\t$dst = ! empty($args['target'])? $args['target'] : (! empty($args['dst'])? $args['dst'] : '');\n\t\tif ($dst) {\n\t\t\t$dstVolume = $this->volume($dst);\n\t\t} else if (isset($args['targets']) && is_array($args['targets']) && isset($args['targets'][0])) {\n\t\t\t$dst = $args['targets'][0];\n\t\t\t$dstVolume = $this->volume($dst);\n\t\t\tif ($dstVolume && ($_stat = $dstVolume->file($dst)) && ! empty($_stat['phash'])) {\n\t\t\t\t$dst = $_stat['phash'];\n\t\t\t} else {\n\t\t\t\t$dst = '';\n\t\t\t}\n\t\t} else if ($cmd === 'open') {\n\t\t\t// for initial open without args `target`\n\t\t\t$dstVolume = $this->default;\n\t\t\t$dst = $dstVolume->defaultPath();\n\t\t}\n\t\t\n\t\t$result = null;\n\t\t\n\t\t// call pre handlers for this command\n\t\t$args['sessionCloseEarlier'] = isset($this->sessionUseCmds[$cmd])? false : $this->sessionCloseEarlier;\n\t\tif (!empty($this->listeners[$cmd.'.pre'])) {\n\t\t\tforeach ($this->listeners[$cmd.'.pre'] as $handler) {\n\t\t\t\t$_res = call_user_func_array($handler, array($cmd, &$args, $this, $dstVolume));\n\t\t\t\tif (is_array($_res)) {\n\t\t\t\t\tif (! empty($_res['preventexec'])) {\n\t\t\t\t\t\t$result = array('error' => true);\n\t\t\t\t\t\tif ($cmd === 'upload' & ! empty($args['node'])) {\n\t\t\t\t\t\t\t$result['callback'] = array(\n\t\t\t\t\t\t\t\t'node' => $args['node'],\n\t\t\t\t\t\t\t\t'bind' => $cmd\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! empty($_res['results']) && is_array($_res['results'])) {\n\t\t\t\t\t\t\t$result = array_merge($result, $_res['results']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// unlock session data for multiple access\n\t\tif ($this->sessionCloseEarlier && $args['sessionCloseEarlier']) {\n\t\t\t$this->session->close();\n\t\t\t// deprecated property\n\t\t\telFinder::$sessionClosed = true;\n\t\t}\n\t\t\n\t\tif (substr(PHP_OS,0,3) === 'WIN') {\n\t\t\t// set time out\n\t\t\telFinder::extendTimeLimit(300);\n\t\t}\n\t\t\n\t\tif (! is_array($result)) {\n\t\t\ttry {\n\t\t\t\t$result = $this->$cmd($args);\n\t\t\t} catch (elFinderAbortException $e) {\n\t\t\t\tthrow $e;\n\t\t\t} catch (Exception $e) {\n\t\t\t\t$result = array(\n\t\t\t\t\t'error' => htmlspecialchars($e->getMessage()),\n\t\t\t\t\t'sync' => true\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// check change dstDir\n\t\t$changeDst = false;\n\t\tif ($dst && $dstVolume && (! empty($result['added']) || ! empty($result['removed']))) {\n\t\t\t$changeDst = true;\n\t\t}\n\t\t\n\t\tforeach ($this->volumes as $volume) {\n\t\t\t$removed = $volume->removed();\n\t\t\tif (! empty($removed)) {\n\t\t\t\tif (! isset($result['removed'])) {\n\t\t\t\t\t$result['removed'] = array();\n\t\t\t\t}\n\t\t\t\t$result['removed'] = array_merge($result['removed'], $removed);\n\t\t\t\tif (! $changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n\t\t\t\t\t$changeDst = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$added = $volume->added();\n\t\t\tif (! empty($added)) {\n\t\t\t\tif (! isset($result['added'])) {\n\t\t\t\t\t$result['added'] = array();\n\t\t\t\t}\n\t\t\t\t$result['added'] = array_merge($result['added'], $added);\n\t\t\t\tif (! $changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n\t\t\t\t\t$changeDst = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$volume->resetResultStat();\n\t\t}\n\t\t\n\t\t// dstDir is changed\n\t\tif ($changeDst) {\n\t\t\tif ($dstDir = $dstVolume->dir($dst)) {\n\t\t\t\tif (! isset($result['changed'])) {\n\t\t\t\t\t$result['changed'] = array();\n\t\t\t\t}\n\t\t\t\t$result['changed'][] = $dstDir;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// call handlers for this command\n\t\tif (!empty($this->listeners[$cmd])) {\n\t\t\tforeach ($this->listeners[$cmd] as $handler) {\n\t\t\t\tif (call_user_func_array($handler,array($cmd, &$result, $args, $this, $dstVolume))) {\n\t\t\t\t\t// handler return true to force sync client after command completed\n\t\t\t\t\t$result['sync'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// replace removed files info with removed files hashes\n\t\tif (!empty($result['removed'])) {\n\t\t\t$removed = array();\n\t\t\tforeach ($result['removed'] as $file) {\n\t\t\t\t$removed[] = $file['hash'];\n\t\t\t}\n\t\t\t$result['removed'] = array_unique($removed);\n\t\t}\n\t\t// remove hidden files and filter files by mimetypes\n\t\tif (!empty($result['added'])) {\n\t\t\t$result['added'] = $this->filter($result['added']);\n\t\t}\n\t\t// remove hidden files and filter files by mimetypes\n\t\tif (!empty($result['changed'])) {\n\t\t\t$result['changed'] = $this->filter($result['changed']);\n\t\t}\n\t\t\n\t\tif ($this->debug || !empty($args['debug'])) {\n\t\t\t$result['debug'] = array(\n\t\t\t\t'connector' => 'php', \n\t\t\t\t'phpver'    => PHP_VERSION,\n\t\t\t\t'time'      => $this->utime() - $this->time,\n\t\t\t\t'memory'    => (function_exists('memory_get_peak_usage') ? ceil(memory_get_peak_usage()/1024).'Kb / ' : '').ceil(memory_get_usage()/1024).'Kb / '.ini_get('memory_limit'),\n\t\t\t\t'upload'    => $this->uploadDebug,\n\t\t\t\t'volumes'   => array(),\n\t\t\t\t'mountErrors' => $this->mountErrors,\n\t\t\t\t'phpErrors' => elFinder::$phpErrors\n\t\t\t);\n\t\t\telFinder::$phpErrors = array();\n\t\t\t\n\t\t\tforeach ($this->volumes as $id => $volume) {\n\t\t\t\t$result['debug']['volumes'][] = $volume->debug();\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach ($this->volumes as $volume) {\n\t\t\t$volume->saveSessionCache();\n\t\t\t$volume->umount();\n\t\t}\n\t\t\n\t\t// unlock locked items\n\t\t$this->itemAutoUnlock();\n\t\t\n\t\t// custom data\n\t\tif ($this->customData !== null) {\n\t\t\t$result['customData'] = $this->customData? json_encode($this->customData) : '';\n\t\t}\n\n\t\tif (!empty($result['callback'])) {\n\t\t\t$result['callback']['json'] = json_encode($result);\n\t\t\t$this->callback($result['callback']);\n\t\t} else {\n\t\t\treturn $result;\n\t\t}\n\t}\n\t\n\t/**\n\t * Return file real path\n\t *\n\t * @param  string  $hash  file hash\n\t * @return string\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function realpath($hash)\t{\n\t\tif (($volume = $this->volume($hash)) == false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn $volume->realpath($hash);\n\t}\n\t\n\t/**\n\t * Sets custom data(s).\n\t *\n\t * @param  string|array  $key    The key or data array\n\t * @param  mixed         $val    The value\n\t * \n\t * @return self    ( elFinder instance )\n\t */\n\tpublic function setCustomData($key, $val = null) {\n\t\tif (is_array($key)) {\n\t\t\tforeach($key as $k => $v) {\n\t\t\t\t$this->customData[$k] = $v;\n\t\t\t}\n\t\t} else {\n\t\t\t$this->customData[$key] = $val;\n\t\t}\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Removes a custom data.\n\t *\n\t * @param  string  $key    The key\n\t * \n\t * @return self    ( elFinder instance )\n\t */\n\tpublic function removeCustomData($key) {\n\t\t$this->customData[$key] = null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Update sesstion value of a NetVolume option\n\t * \n\t * @param string $netKey\n\t * @param string $optionKey\n\t * @param mixed  $val\n\t */\n\tpublic function updateNetVolumeOption($netKey, $optionKey, $val) {\n\t\t$netVolumes = $this->getNetVolumes();\n\t\tif (is_string($netKey) && isset($netVolumes[$netKey]) && is_string($optionKey)) {\n\t\t\t$netVolumes[$netKey][$optionKey] = $val;\n\t\t}\n\t}\n\t\n\t/**\n\t * Return network volumes config.\n\t *\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t */\n\tprotected function getNetVolumes() {\n\t\tif ($data = $this->session->get('netvolume', array())) {\n\t\t\treturn $data;\n\t\t}\n\t\treturn array();\n\t}\n\n\t/**\n\t * Save network volumes config.\n\t *\n\t * @param  array  $volumes  volumes config\n\t * @return void\n\t * @author Dmitry (dio) Levashov\n\t */\n\tprotected function saveNetVolumes($volumes) {\n\t\t$this->session->set('netvolume', $volumes);\n\t}\n\n\t/**\n\t * Remove netmount volume\n\t *\n\t * @param string $key netvolume key\n\t * @param object $volume volume driver instance\n\t * @return bool\n\t */\n\tprotected function removeNetVolume($key, $volume) {\n\t\t$netVolumes = $this->getNetVolumes();\n\t\t$res = true;\n\t\tif (is_object($volume) && method_exists($volume, 'netunmount')) {\n\t\t\t$res = $volume->netunmount($netVolumes, $key);\n\t\t\t$volume->clearSessionCache();\n\t\t}\n\t\tif ($res) {\n\t\t\tif (is_string($key) && isset($netVolumes[$key])) {\n\t\t\t\tunset($netVolumes[$key]);\n\t\t\t\t$this->saveNetVolumes($netVolumes);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get plugin instance & set to $this->plugins\n\t * \n\t * @param  string $name   Plugin name (dirctory name)\n\t * @param  array  $opts   Plugin options (optional)\n\t * @return object | bool Plugin object instance Or false\n\t * @author Naoki Sawada\n\t */\n\tprotected function getPluginInstance($name, $opts = array()) {\n\t\t$key = strtolower($name);\n\t\tif (! isset($this->plugins[$key])) {\n\t\t\t$class = 'elFinderPlugin' . $name;\n\t\t\t// to try auto load\n\t\t\tif (! class_exists($class)) {\n\t\t\t\t$p_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'plugins' . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'plugin.php';\n\t\t\t\tif (is_file($p_file)) {\n\t\t\t\t\tinclude_once $p_file;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (class_exists($class, false)) {\n\t\t\t\t$this->plugins[$key] = new $class($opts);\n\t\t\t} else {\n\t\t\t\t$this->plugins[$key] = false;\n\t\t\t}\n\t\t}\n\t\treturn $this->plugins[$key];\n\t}\n\n\t/***************************************************************************/\n\t/*                                 commands                                */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Normalize error messages\n\t *\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tpublic function error() {\n\t\t$errors = array();\n\n\t\tforeach (func_get_args() as $msg) {\n\t\t\tif (is_array($msg)) {\n\t\t\t\t$errors = array_merge($errors, $msg);\n\t\t\t} else {\n\t\t\t\t$errors[] = $msg;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn count($errors) ? $errors : array(self::ERROR_UNKNOWN);\n\t}\n\t\n\tprotected function netmount($args) {\n\t\t$options  = array();\n\t\t$protocol = $args['protocol'];\n\t\t$toast = '';\n\t\t\n\t\tif ($protocol === 'netunmount') {\n\t\t\tif (! empty($args['user']) && $volume = $this->volume($args['user'])) {\n\t\t\t\tif ($this->removeNetVolume($args['host'], $volume)) {\n\t\t\t\t\treturn array('removed' => array(array('hash' => $volume->root())));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn array('sync' => true, 'error' => $this->error(self::ERROR_NETUNMOUNT));\n\t\t}\n\t\t\n\t\t$driver   = isset(self::$netDrivers[$protocol]) ? self::$netDrivers[$protocol] : '';\n\t\t$class    = 'elFinderVolume'.$driver;\n\n\t\tif (!class_exists($class)) {\n\t\t\treturn array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], self::ERROR_NETMOUNT_NO_DRIVER));\n\t\t}\n\n\t\tif (!$args['path']) {\n\t\t\t$args['path'] = '/';\n\t\t}\n\n\t\tforeach ($args as $k => $v) {\n\t\t\tif ($k != 'options' && $k != 'protocol' && $v) {\n\t\t\t\t$options[$k] = $v;\n\t\t\t}\n\t\t}\n\n\t\tif (is_array($args['options'])) {\n\t\t\tforeach ($args['options'] as $key => $value) {\n\t\t\t\t$options[$key] = $value;\n\t\t\t}\n\t\t}\n\n\t\t$volume = new $class();\n\t\t\n\t\t// pass session handler\n\t\t$volume->setSession($this->session);\n\t\t\n\t\tif (is_callable(array($volume, 'netmountPrepare'))) {\n\t\t\t$options = $volume->netmountPrepare($options);\n\t\t\tif (isset($options['exit'])) {\n\t\t\t\tif ($options['exit'] === 'callback') {\n\t\t\t\t\t$this->callback($options['out']);\n\t\t\t\t}\n\t\t\t\treturn $options;\n\t\t\t}\n\t\t\tif (!empty($options['toast'])) {\n\t\t\t\t$toast = $options['toast'];\n\t\t\t\tunset($options['toast']);\n\t\t\t}\n\t\t}\n\t\t\n\t\t$netVolumes = $this->getNetVolumes();\n\t\t\n\t\tif (! isset($options['id'])) {\n\t\t\t// given fixed unique id\n\t\t\tif (! $options['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], 'Could\\'t given volume id.'));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// load additional volume root options\n\t\tif (! empty($this->optionsNetVolumes['*'])) {\n\t\t\t$options = array_merge($this->optionsNetVolumes['*'], $options);\n\t\t}\n\t\tif (! empty($this->optionsNetVolumes[$protocol])) {\n\t\t\t$options = array_merge($this->optionsNetVolumes[$protocol], $options);\n\t\t}\n\t\t\n\t\tif (! $key =  $volume->netMountKey) {\n\t\t\t$key = md5($protocol . '-' . serialize($options));\n\t\t}\n\t\t$options['netkey'] = $key;\n\t\t\n\t\tif (!isset($netVolumes[$key]) && $volume->mount($options)) {\n\t\t\t// call post-process function of netmount\n\t\t\tif (is_callable(array($volume, 'postNetmount'))) {\n\t\t\t\t$volume->postNetmount($options);\n\t\t\t}\n\t\t\t$options['driver'] = $driver;\n\t\t\t$netVolumes[$key]  = $options;\n\t\t\t$this->saveNetVolumes($netVolumes);\n\t\t\t$rootstat = $volume->file($volume->root());\n\t\t\t$res = array('added' => array($rootstat));\n\t\t\tif ($toast) {\n\t\t\t\t$res['toast'] = $toast;\n\t\t\t}\n\t\t\treturn $res;\n\t\t} else {\n\t\t\t$this->removeNetVolume(null, $volume);\n\t\t\treturn array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], implode(' ', $volume->error())));\n\t\t}\n\t}\n\n\t/**\n\t * \"Open\" directory\n\t * Return array with following elements\n\t *  - cwd          - opened dir info\n\t *  - files        - opened dir content [and dirs tree if $args[tree]]\n\t *  - api          - api version (if $args[init])\n\t *  - uplMaxSize   - if $args[init]\n\t *  - error        - on failed\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function open($args) {\n\t\t$target = $args['target'];\n\t\t$init   = !empty($args['init']);\n\t\t$tree   = !empty($args['tree']);\n\t\t$volume = $this->volume($target);\n\t\t$cwd    = $volume ? $volume->dir($target) : false;\n\t\t$hash   = $init ? 'default folder' : '#'.$target;\n\t\t$sleep  = 0;\n\t\t$compare = '';\n\n\t\t// on init request we can get invalid dir hash -\n\t\t// dir which can not be opened now, but remembered by client,\n\t\t// so open default dir\n\t\tif ((!$cwd || !$cwd['read']) && $init) {\n\t\t\t$volume = $this->default;\n\t\t\t$target = $volume->defaultPath();\n\t\t\t$cwd    = $volume->dir($target);\n\t\t}\n\t\t\n\t\tif (!$cwd) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_DIR_NOT_FOUND));\n\t\t}\n\t\tif (!$cwd['read']) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_PERM_DENIED));\n\t\t}\n\n\t\t$files = array();\n\n\t\t// get current working directory files list\n\t\tif (($ls = $volume->scandir($cwd['hash'])) === false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n\t\t}\n\t\t\n\t\tif (isset($cwd['dirs']) && $cwd['dirs'] != 1) {\n\t\t\t$cwd = $volume->dir($target);\n\t\t}\n\t\t\n\t\t// get other volume root\n\t\tif ($tree) {\n\t\t\tforeach ($this->volumes as $id => $v) {\n\t\t\t\t$files[] = $v->file($v->root());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// long polling mode\n\t\tif ($args['compare']) {\n\t\t\t$sleep = max(1, (int)$volume->getOption('lsPlSleep'));\n\t\t\t$standby = (int)$volume->getOption('plStandby');\n\t\t\tif ($standby > 0 && $sleep > $standby) {\n\t\t\t\t$standby = $sleep;\n\t\t\t}\n\t\t\t$limit = max(0, floor($standby / $sleep)) + 1;\n\t\t\tdo {\n\t\t\t\telFinder::extendTimeLimit(30 + $sleep);\n\t\t\t\t$_mtime = 0;\n\t\t\t\tforeach($ls as $_f) {\n\t\t\t\t\t$_mtime = max($_mtime, $_f['ts']);\n\t\t\t\t}\n\t\t\t\t$compare = strval(count($ls)).':'.strval($_mtime);\n\t\t\t\tif ($compare !== $args['compare']) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (--$limit) {\n\t\t\t\t\tsleep($sleep);\n\t\t\t\t\t$volume->clearstatcache();\n\t\t\t\t\tif (($ls = $volume->scandir($cwd['hash'])) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while($limit);\n\t\t\tif ($ls === false) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($ls) {\n\t\t\tif ($files) {\n\t\t\t\t$files = array_merge($files, $ls);\n\t\t\t} else {\n\t\t\t\t$files = $ls;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array(\n\t\t\t'cwd'     => $cwd,\n\t\t\t'options' => $volume->options($cwd['hash']),\n\t\t\t'files'   => $files\n\t\t);\n\t\t\n\t\tif ($compare) {\n\t\t\t$result['cwd']['compare'] = $compare;\n\t\t}\n\t\t\n\t\tif (!empty($args['init'])) {\n\t\t\t$result['api'] = sprintf('%.1F%03d', self::$ApiVersion, self::$ApiRevision);\n\t\t\t$result['uplMaxSize'] = ini_get('upload_max_filesize');\n\t\t\t$result['uplMaxFile'] = ini_get('max_file_uploads');\n\t\t\t$result['netDrivers'] = array_keys(self::$netDrivers);\n\t\t\t$result['maxTargets'] = $this->maxTargets;\n\t\t\tif ($volume) {\n\t\t\t\t$result['cwd']['root'] = $volume->root();\n\t\t\t}\n\t\t\tif (elfinder::$textMimes) {\n\t\t\t\t$result['textMimes'] = elfinder::$textMimes;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return dir files names list\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function ls($args) {\n\t\t$target = $args['target'];\n\t\t$intersect = isset($args['intersect'])? $args['intersect'] : array();\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($list = $volume->ls($target, $intersect)) === false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t}\n\t\treturn array('list' => $list);\n\t}\n\t\n\t/**\n\t * Return subdirs for required directory\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function tree($args) {\n\t\t$target = $args['target'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($tree = $volume->tree($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t}\n\n\t\treturn array('tree' => $tree);\n\t}\n\t\n\t/**\n\t * Return parents dir for required directory\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function parents($args) {\n\t\t$target = $args['target'];\n\t\t$until = $args['until'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($tree = $volume->parents($target, false, $until)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t}\n\n\t\treturn array('tree' => $tree);\n\t}\n\t\n\t/**\n\t * Return new created thumbnails list\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function tmb($args) {\n\t\t\n\t\t$result  = array('images' => array());\n\t\t$targets = $args['targets'];\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($volume = $this->volume($target)) != false\n\t\t\t&& (($tmb = $volume->tmb($target)) != false)) {\n\t\t\t\t$result['images'][$target] = $tmb;\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Download files/folders as an archive file\n\t * \n\t * 1st: Return srrsy contains download archive file info\n\t * 2nd: Return array contains opened file pointer, root itself and required headers\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Naoki Sawada\n\t **/\n\tprotected function zipdl($args) {\n\t\t$targets = $args['targets'];\n\t\t$download = !empty($args['download']);\n\t\t$h404    = 'HTTP/1.x 404 Not Found';\n\t\t\n\t\tif (!$download) {\n\t\t\t//1st: Return srrsy contains download archive file info\n\t\t\t$error = array(self::ERROR_ARCHIVE);\n\t\t\tif (($volume = $this->volume($targets[0])) !== false) {\n\t\t\t\tif ($dlres = $volume->zipdl($targets)) {\n\t\t\t\t\t$path = $dlres['path'];\n\t\t\t\t\tregister_shutdown_function(array('elFinder', 'rmFileInDisconnected'), $path);\n\t\t\t\t\tif (count($targets) === 1) {\n\t\t\t\t\t\t$name = basename($volume->path($targets[0]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$name = $dlres['prefix'].'_Files';\n\t\t\t\t\t}\n\t\t\t\t\t$name .= '.'.$dlres['ext'];\n\t\t\t\t\t$result = array(\n\t\t\t\t\t\t'zipdl' => array(\n\t\t\t\t\t\t\t'file' => basename($path),\n\t\t\t\t\t\t\t'name' => $name,\n\t\t\t\t\t\t\t'mime' => $dlres['mime']\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn $result;\n\t\t\t\t}\n\t\t\t\t$error = array_merge($error, $volume->error());\n\t\t\t}\n\t\t\treturn array('error' => $error);\n\t\t} else {\n\t\t\t// 2nd: Return array contains opened file pointer, root itself and required headers\n\t\t\tif (count($targets) !== 4 || ($volume = $this->volume($targets[0])) == false) {\n\t\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t\t}\n\t\t\t$file = $targets[1];\n\t\t\t// checking the validity of the file parameter\n\t\t\tif (strpos($file, DIRECTORY_SEPARATOR) !== false) {\n\t\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t\t}\n\t\t\t$path = $volume->getTempPath().DIRECTORY_SEPARATOR.$file;\n\t\t\t// register auto delete on shutdown\n\t\t\t$GLOBALS['elFinderTempFiles'][$path] = true;\n\t\t\tif (!is_writable($path)) {\n\t\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t\t}\n\t\t\t$name = $targets[2];\n\t\t\t$mime = $targets[3];\n\t\t\t\n\t\t\t$filenameEncoded = rawurlencode($name);\n\t\t\tif (strpos($filenameEncoded, '%') === false) { // ASCII only\n\t\t\t\t$filename = 'filename=\"'.$name.'\"';\n\t\t\t} else {\n\t\t\t\t$ua = $_SERVER['HTTP_USER_AGENT'];\n\t\t\t\tif (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t\t$filename = 'filename=\"'.$filenameEncoded.'\"';\n\t\t\t\t} elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n\t\t\t\t\t$filename = 'filename=\"'.str_replace('\"', '', $name).'\"';\n\t\t\t\t} else { // RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t\t$filename = 'filename*=UTF-8\\'\\''.$filenameEncoded;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$fp = fopen($path, 'rb');\n\t\t\t$file = fstat($fp);\n\t\t\t$result = array(\n\t\t\t\t'pointer' => $fp,\n\t\t\t\t'header'  => array(\n\t\t\t\t\t'Content-Type: '.$mime, \n\t\t\t\t\t'Content-Disposition: attachment; '.$filename,\n\t\t\t\t\t'Content-Transfer-Encoding: binary',\n\t\t\t\t\t'Content-Length: '.$file['size'],\n\t\t\t\t\t'Accept-Ranges: none',\n\t\t\t\t\t'Connection: close'\n\t\t\t\t)\n\t\t\t);\n\t\t\treturn $result;\n\t\t}\n\t}\n\t\n\t/**\n\t * Required to output file in browser when volume URL is not set \n\t * Return array contains opened file pointer, root itself and required headers\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function file($args) {\n\t\t$target   = $args['target'];\n\t\t$download = !empty($args['download']);\n\t\t$h403     = 'HTTP/1.0 403 Access Denied';\n\t\t$h404     = 'HTTP/1.0 404 Not Found';\n\t\t$h304     = 'HTTP/1.1 304 Not Modified';\n\n\t\tif (($volume = $this->volume($target)) == false) { \n\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t}\n\t\t\n\t\tif (($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t}\n\t\t\n\t\tif (!$file['read']) {\n\t\t\treturn array('error' => 'Access denied', 'header' => $h403, 'raw' => true);\n\t\t}\n\t\t\n\t\tif (($fp = $volume->open($target)) == false) {\n\t\t\treturn array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\t\t}\n\n\t\t// allow change MIME type by 'file.pre' callback functions\n\t\t$mime = isset($args['mime'])? $args['mime'] : $file['mime'];\n\t\tif ($download) {\n\t\t\t$disp = 'attachment';\n\t\t} else {\n\t\t\t$dispInlineRegex = $volume->getOption('dispInlineRegex');\n\t\t\t$inlineRegex = false;\n\t\t\tif ($dispInlineRegex) {\n\t\t\t\t$inlineRegex = '#' . str_replace('#', '\\\\#', $dispInlineRegex) . '#';\n\t\t\t\ttry {\n\t\t\t\t\tpreg_match($inlineRegex, '');\n\t\t\t\t} catch(Exception $e) {\n\t\t\t\t\t$inlineRegex = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!$inlineRegex) {\n\t\t\t\t$inlineRegex = '#^(?:(?:image|text)|application/x-shockwave-flash$)#';\n\t\t\t}\n\t\t\t$disp  = preg_match($inlineRegex, $mime)? 'inline' : 'attachment';\n\t\t}\n\t\t\n\t\t$filenameEncoded = rawurlencode($file['name']);\n\t\tif (strpos($filenameEncoded, '%') === false) { // ASCII only\n\t\t\t$filename = 'filename=\"'.$file['name'].'\"';\n\t\t} else {\n\t\t\t$ua = $_SERVER['HTTP_USER_AGENT'];\n\t\t\tif (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t$filename = 'filename=\"'.$filenameEncoded.'\"';\n\t\t\t} elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n\t\t\t\t$filename = 'filename=\"'.str_replace('\"', '', $file['name']).'\"';\n\t\t\t} else { // RFC 6266 (RFC 2231/RFC 5987)\n\t\t\t\t$filename = 'filename*=UTF-8\\'\\''.$filenameEncoded;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array(\n\t\t\t'volume'  => $volume,\n\t\t\t'pointer' => $fp,\n\t\t\t'info'    => $file,\n\t\t\t'header'  => array(\n\t\t\t\t'Content-Type: '.$mime, \n\t\t\t\t'Content-Disposition: '.$disp.'; '.$filename,\n\t\t\t\t'Content-Transfer-Encoding: binary',\n\t\t\t\t'Content-Length: '.$file['size'],\n\t\t\t\t'Last-Modified: '.gmdate('D, d M Y H:i:s T', $file['ts']),\n\t\t\t\t'Connection: close'\n\t\t\t)\n\t\t);\n\t\t\n\t\t// add cache control headers\n\t\tif ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n\t\t\t$result['header'] = array_merge($result['header'], $cacheHeaders);\n\t\t}\n\t\t\n\t\t// check 'xsendfile'\n\t\t$xsendfile = $volume->getOption('xsendfile');\n\t\t$path = null;\n\t\tif ($xsendfile) {\n\t\t\t$info = stream_get_meta_data($fp);\n\t\t\tif ($path = empty($info['uri'])? null : $info['uri']) {\n\t\t\t\t$basePath = rtrim($volume->getOption('xsendfilePath'), DIRECTORY_SEPARATOR);\n\t\t\t\tif ($basePath) {\n\t\t\t\t\t$root = rtrim($volume->getRootPath(), DIRECTORY_SEPARATOR);\n\t\t\t\t\tif (strpos($path, $root) === 0) {\n\t\t\t\t\t\t$path = $basePath . substr($path, strlen($root));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$path = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($path) {\n\t\t\t$result['header'][] = $xsendfile . ': ' . $path;\n\t\t\t$result['info']['xsendfile'] = $xsendfile;\n\t\t}\n\t\t\n\t\t// add \"Content-Location\" if file has url data\n\t\tif (isset($file['url']) && $file['url'] && $file['url'] != 1) {\n\t\t\t$result['header'][] = 'Content-Location: '.$file['url'];\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Count total files size\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function size($args) {\n\t\t$size = 0;\n\t\t$files = 0;\n\t\t$dirs = 0;\n\t\t$itemCount = true;\n\t\t$sizes = array();\n\t\t\n\t\tforeach ($args['targets'] as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\tif (($volume = $this->volume($target)) == false\n\t\t\t|| ($file = $volume->file($target)) == false\n\t\t\t|| !$file['read']) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target));\n\t\t\t}\n\t\t\t\n\t\t\t$volRes = $volume->size($target);\n\t\t\tif (is_array($volRes)) {\n\t\t\t\t$sizeInfo = array('size' => 0, 'fileCnt' => 0, 'dirCnt' => 0);\n\t\t\t\tif (! empty($volRes['size'])) {\n\t\t\t\t\t$sizeInfo['size'] = $volRes['size'];\n\t\t\t\t\t$size += $volRes['size'];\n\t\t\t\t}\n\t\t\t\tif (! empty($volRes['files'])) {\n\t\t\t\t\t$sizeInfo['fileCnt'] = $volRes['files'];\n\t\t\t\t}\n\t\t\t\tif (! empty($volRes['dirs'])) {\n\t\t\t\t\t$sizeInfo['dirCnt'] = $volRes['dirs'];\n\t\t\t\t}\n\t\t\t\tif ($itemCount) {\n\t\t\t\t\t$files += $sizeInfo['fileCnt'];\n\t\t\t\t\t$dirs += $sizeInfo['dirCnt'];\n\t\t\t\t}\n\t\t\t\t$sizes[$target] = $sizeInfo;\n\t\t\t} else if (is_numeric($volRes)) {\n\t\t\t\t$size += $volRes;\n\t\t\t\t$files = $dirs = 'unknown';\n\t\t\t\t$itemCount = false;\n\t\t\t}\n\t\t}\n\t\treturn array('size' => $size, 'fileCnt' => $files, 'dirCnt' => $dirs, 'sizes' => $sizes);\n\t}\n\t\n\t/**\n\t * Create directory\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function mkdir($args) {\n\t\t$target = $args['target'];\n\t\t$name   = $args['name'];\n\t\t$dirs   = $args['dirs'];\n\t\tif ($name === '' && !$dirs) {\n\t\t\treturn array('error' => $this->error(self::ERROR_INV_PARAMS, 'mkdir'));\n\t\t}\n\t\t\n\t\tif (($volume = $this->volume($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_MKDIR, $name, self::ERROR_TRGDIR_NOT_FOUND, '#'.$target));\n\t\t}\n\t\tif ($dirs) {\n\t\t\tsort($dirs);\n\t\t\t$reset = null;\n\t\t\t$mkdirs = array();\n\t\t\tforeach($dirs as $dir) {\n\t\t\t\t$tgt =& $mkdirs;\n\t\t\t\t$_names = explode('/', trim($dir, '/'));\n\t\t\t\tforeach($_names as $_key => $_name) {\n\t\t\t\t\tif (! isset($tgt[$_name])) {\n\t\t\t\t\t\t$tgt[$_name] = array();\n\t\t\t\t\t}\n\t\t\t\t\t$tgt =& $tgt[$_name];\n\t\t\t\t}\n\t\t\t\t$tgt =& $reset;\n\t\t\t}\n\t\t\t$res = $this->ensureDirsRecursively($volume, $target, $mkdirs);\n\t\t\tif ($res['error']) {\n\t\t\t\t$errors = $volume->error();\n\t\t\t\tif ($res['makes']) {\n\t\t\t\t\t$this->rm(array('targets' => $res['makes']));\n\t\t\t\t}\n\t\t\t\treturn array('error' => $this->error(self::ERROR_MKDIR, $res['error'][0], $errors));\n\t\t\t} else {\n\t\t\t\treturn array('added' => $res['stats'], 'hashes' => $res['hashes']);\n\t\t\t}\n\t\t} else {\n\t\t\treturn ($dir = $volume->mkdir($target, $name)) == false\n\t\t\t\t? array('error' => $this->error(self::ERROR_MKDIR, $name, $volume->error()))\n\t\t\t\t: array('added' => array($dir));\n\t\t}\n\t}\n\t\n\t/**\n\t * Create empty file\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function mkfile($args) {\n\t\t$target = $args['target'];\n\t\t$name   = $args['name'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_MKFILE, $name, self::ERROR_TRGDIR_NOT_FOUND, '#'.$target));\n\t\t}\n\n\t\treturn ($file = $volume->mkfile($target, $args['name'])) == false\n\t\t\t? array('error' => $this->error(self::ERROR_MKFILE, $name, $volume->error()))\n\t\t\t: array('added' => array($file));\n\t}\n\t\n\t/**\n\t * Rename file, Accept multiple items >= API 2.1031\n\t *\n\t * @param  array  $args\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t * @author Naoki Sawada\n\t **/\n\tprotected function rename($args) {\n\t\t$target = $args['target'];\n\t\t$name = $args['name'];\n\t\t$query = (strpos($args['q'], '*') !== false)? $args['q'] : '';\n\t\t$targets = $args['targets'];\n\t\t$rms = array();\n\t\t$notfounds = array();\n\t\t$locked = array();\n\t\t$errs = array();\n\t\t$files = array();\n\t\t$removed = array();\n\t\t$res = array();\n\t\t$type = 'normal';\n\t\t\n\t\tif (!($volume = $this->volume($target))) {\n\t\t\treturn array('error' => $this->error(self::ERROR_RENAME, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\tif ($targets) {\n\t\t\tarray_unshift($targets, $target);\n\t\t\tforeach($targets as $h) {\n\t\t\t\tif ($rm = $volume->file($h)) {\n\t\t\t\t\tif ($this->itemLocked($h)) {\n\t\t\t\t\t\t$locked[] = $rm['name'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$rm['realpath'] = $volume->realpath($h);\n\t\t\t\t\t\t$rms[] = $rm;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$notfounds[] = '#'.$h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!$rms) {\n\t\t\t\t$res['error'] = array();\n\t\t\t\tif ($notfounds) {\n\t\t\t\t\t$res['error'] = array(self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n\t\t\t\t}\n\t\t\t\tif ($locked) {\n\t\t\t\t\tarray_push($res['error'], self::ERROR_LOCKED, join(', ',$locked));\n\t\t\t\t}\n\t\t\t\treturn $res;\n\t\t\t}\n\t\t\t\n\t\t\t$res['warning'] = array();\n\t\t\tif ($notfounds) {\n\t\t\t\tarray_push($res['warning'], self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n\t\t\t}\n\t\t\tif ($locked) {\n\t\t\t\tarray_push($res['warning'], self::ERROR_LOCKED, join(', ',$locked));\n\t\t\t}\n\t\t\t\n\t\t\tif ($query) {\n\t\t\t\t// batch rename\n\t\t\t\t$splits = elFinder::splitFileExtention($query);\n\t\t\t\tif ($splits[1] && $splits[0] === '*') {\n\t\t\t\t\t$type = 'extention';\n\t\t\t\t\t$name = $splits[1];\n\t\t\t\t} else if (strlen($splits[0]) > 1) {\n\t\t\t\t\tif (substr($splits[0], -1) === '*') {\n\t\t\t\t\t\t$type = 'prefix';\n\t\t\t\t\t\t$name = substr($splits[0], 0 ,strlen($splits[0]) - 1);\n\t\t\t\t\t} else if (substr($splits[0], 0, 1) === '*') {\n\t\t\t\t\t\t$type = 'suffix';\n\t\t\t\t\t\t$name = substr($splits[0], 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($type !== 'normal') {\n\t\t\t\t\tif (!empty($this->listeners['rename.pre'])) {\n\t\t\t\t\t\t$_args = array('name' => $name);\n\t\t\t\t\t\tforeach ($this->listeners['rename.pre'] as $handler) {\n\t\t\t\t\t\t\t$_res = call_user_func_array($handler, array('rename', &$_args, $this, $volume));\n\t\t\t\t\t\t\tif (! empty($_res['preventexec'])) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$name = $_args['name'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach($rms as $rm) {\n\t\t\t\tif ($type === 'normal') {\n\t\t\t\t\t$rname = $volume->uniqueName($volume->realpath($rm['phash']), $name, '', false);\n\t\t\t\t} else {\n\t\t\t\t\tif ($type === 'extention') {\n\t\t\t\t\t\t$splits = elFinder::splitFileExtention($rm['name']);\n\t\t\t\t\t\t$rname = $splits[0] . '.' . $name;\n\t\t\t\t\t} else if ($type === 'prefix') {\n\t\t\t\t\t\t$rname = $name . $rm['name'];\n\t\t\t\t\t} else if ($type === 'suffix') {\n\t\t\t\t\t\t$splits = elFinder::splitFileExtention($rm['name']);\n\t\t\t\t\t\t$rname = $splits[0]. $name . ($splits[1]? ('.' . $splits[1]) : '');\n\t\t\t\t\t}\n\t\t\t\t\t$rname = $volume->uniqueName($volume->realpath($rm['phash']), $rname, '', true);\n\t\t\t\t}\n\t\t\t\tif ($file = $volume->rename($rm['hash'], $rname)) {\n\t\t\t\t\t$files[] = $file;\n\t\t\t\t\t$removed[] = $rm;\n\t\t\t\t} else {\n\t\t\t\t\t$errs[] = $rm['name'];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!$files) {\n\t\t\t\t$res['error'] = $this->error(self::ERROR_RENAME, join(', ', $errs), $volume->error());\n\t\t\t\tif (!$res['warning']) {\n\t\t\t\t\tunset($res['warning']);\n\t\t\t\t}\n\t\t\t\treturn $res;\n\t\t\t}\n\t\t\tif ($errs) {\n\t\t\t\tarray_push($res['warning'], self::ERROR_RENAME, join(', ', $errs), $volume->error());\n\t\t\t}\n\t\t\tif (!$res['warning']) {\n\t\t\t\tunset($res['warning']);\n\t\t\t}\n\t\t\t$res['added'] = $files;\n\t\t\t$res['removed'] = $removed;\n\t\t\treturn $res;\n\t\t} else {\n\t\t\tif (!($rm = $volume->file($target))) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_RENAME, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t\t}\n\t\t\tif ($this->itemLocked($target)) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_LOCKED, $rm['name']));\n\t\t\t}\n\t\t\t$rm['realpath'] = $volume->realpath($target);\n\t\t\t\n\t\t\treturn ($file = $volume->rename($target, $name)) == false\n\t\t\t\t? array('error' => $this->error(self::ERROR_RENAME, $rm['name'], $volume->error()))\n\t\t\t\t: array('added' => array($file), 'removed' => array($rm));\n\t\t}\n\t}\n\t\n\t/**\n\t * Duplicate file - create copy with \"copy %d\" suffix\n\t *\n\t * @param array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function duplicate($args) {\n\t\t$targets = is_array($args['targets']) ? $args['targets'] : array();\n\t\t$result  = array('added' => array());\n\t\t$suffix  = empty($args['suffix']) ? 'copy' : $args['suffix'];\n\t\t\n\t\t$this->itemLock($targets);\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($volume = $this->volume($target)) == false\n\t\t\t|| ($src = $volume->file($target)) == false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_COPY, '#'.$target, self::ERROR_FILE_NOT_FOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (($file = $volume->duplicate($target, $suffix)) == false) {\n\t\t\t\t$result['warning'] = $this->error($volume->error());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t$result['added'][] = $file;\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\t\n\t/**\n\t * Remove dirs/files\n\t *\n\t * @param array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function rm($args) {\n\t\t$targets = is_array($args['targets']) ? $args['targets'] : array();\n\t\t$result  = array('removed' => array());\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($volume = $this->volume($target)) == false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_RM, '#'.$target, self::ERROR_FILE_NOT_FOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif ($this->itemLocked($target)) {\n\t\t\t\t$rm = $volume->file($target);\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_LOCKED, $rm['name']);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (!$volume->rm($target)) {\n\t\t\t\t$result['warning'] = $this->error($volume->error());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Return has subdirs\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry Naoki Sawada\n\t **/\n\tprotected function subdirs($args) {\n\t\n\t\t$result  = array('subdirs' => array());\n\t\t$targets = $args['targets'];\n\t\n\t\tforeach ($targets as $target) {\n\t\t\tif (($volume = $this->volume($target)) !== false) {\n\t\t\t\t$result['subdirs'][$target] = $volume->subdirs($target)? 1 : 0;\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Gateway for custom contents editor\n\t * \n\t * @param  array $args command arguments\n\t * @return array\n\t * @author Naoki Sawada\n\t */\n\tprotected function editor($args = array()) {\n\t\t$name = $args['name'];\n\t\tif (is_array($name)) {\n\t\t\t$res = array();\n\t\t\tforeach($name as $c) {\n\t\t\t\t$class = 'elFinderEditor' . $c;\n\t\t\t\tif (class_exists($class)) {\n\t\t\t\t\t$editor = new $class($this, $args['args']);\n\t\t\t\t\t$res[$c] = $editor->enabled();\n\t\t\t\t} else {\n\t\t\t\t\t$res[$c] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $res;\n\t\t} else {\n\t\t\t$class = 'elFinderEditor' . $name;\n\t\t\tif (class_exists($class)) {\n\t\t\t\t$editor = new $class($this, $args['args']);\n\t\t\t\t$method = $args['method'];\n\t\t\t\tif ($editor->isAllowedMethod($method) && method_exists($editor, $method)) {\n\t\t\t\t\treturn $editor->$method();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn array('error', $this->error(self::ERROR_UNKNOWN_CMD, 'editor.'.$name.'.'.$method));\n\t\t}\n\t}\n\n\t/**\n\t * Abort current request and make flag file to running check\n\t * \n\t * @param array $args\n\t * @return void\n\t */\n\tprotected function abort($args = array()) {\n\t\tif (! elFinder::$connectionFlagsPath || $_SERVER['REQUEST_METHOD'] === 'HEAD') {\n\t\t\treturn;\n\t\t}\n\t\t$flagFile = elFinder::$connectionFlagsPath . DIRECTORY_SEPARATOR . 'elfreq%s';\n\t\tif (! empty($args['makeFile'])) {\n\t\t\tself::$abortCheckFile = sprintf($flagFile, $args['makeFile']);\n\t\t\ttouch(self::$abortCheckFile);\n\t\t\t$GLOBALS['elFinderTempFiles'][self::$abortCheckFile] = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$file = ! empty($args['id'])? sprintf($flagFile, $args['id']) : self::$abortCheckFile;\n\t\t$file && is_file($file) && unlink($file);\n\t}\n\t\n\t/**\n\t* Get remote contents\n\t*\n\t* @param  string   $url     target url\n\t* @param  int      $timeout timeout (sec)\n\t* @param  int      $redirect_max redirect max count\n\t* @param  string   $ua\n\t* @param  resource $fp\n\t* @return string or bool(false)\n\t* @retval string contents\n\t* @rettval false  error\n\t* @author Naoki Sawada\n\t**/\n\tprotected function get_remote_contents( &$url, $timeout = 30, $redirect_max = 5, $ua = 'Mozilla/5.0', $fp = null ) {\n\t\t$method = (function_exists('curl_exec') && !ini_get('safe_mode') && !ini_get('open_basedir'))? 'curl_get_contents' : 'fsock_get_contents'; \n\t\treturn $this->$method( $url, $timeout, $redirect_max, $ua, $fp );\n\t}\n\t\n\t/**\n\t * Get remote contents with cURL\n\t *\n\t * @param  string   $url     target url\n\t * @param  int      $timeout timeout (sec)\n\t * @param  int      $redirect_max redirect max count\n\t * @param  string   $ua\n\t * @param  resource $outfp\n\t * @return string or bool(false)\n\t * @retval string contents\n\t * @retval false  error\n\t * @author Naoki Sawada\n\t **/\n\t protected function curl_get_contents( &$url, $timeout, $redirect_max, $ua, $outfp ){\n\t\t$ch = curl_init();\n\t\tcurl_setopt( $ch, CURLOPT_URL, $url );\n\t\tcurl_setopt( $ch, CURLOPT_HEADER, false );\n\t\tif ($outfp) {\n\t\t\tcurl_setopt( $ch, CURLOPT_FILE, $outfp );\n\t\t} else {\n\t\t\tcurl_setopt( $ch, CURLOPT_RETURNTRANSFER, true );\n\t\t\tcurl_setopt( $ch, CURLOPT_BINARYTRANSFER, true );\n\t\t}\n\t\tcurl_setopt( $ch, CURLOPT_LOW_SPEED_LIMIT, 1 );\n\t\tcurl_setopt( $ch, CURLOPT_LOW_SPEED_TIME, $timeout );\n\t\tcurl_setopt( $ch, CURLOPT_SSL_VERIFYPEER, false );\n\t\tcurl_setopt( $ch, CURLOPT_FOLLOWLOCATION, 1);\n\t\tcurl_setopt( $ch, CURLOPT_MAXREDIRS, $redirect_max);\n\t\tcurl_setopt( $ch, CURLOPT_USERAGENT, $ua);\n\t\t$result = curl_exec( $ch );\n\t\t$url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);\n\t\tcurl_close( $ch );\n\t\treturn $outfp? $outfp : $result;\n\t}\n\t\n\t/**\n\t * Get remote contents with fsockopen()\n\t *\n\t * @param  string   $url          url\n\t * @param  int      $timeout      timeout (sec)\n\t * @param  int      $redirect_max redirect max count\n\t * @param  string   $ua\n\t * @param  resource $outfp\n\t * @return string or bool(false)\n\t * @retval string contents\n\t * @retval false  error\n\t * @author Naoki Sawada\n\t */\n\tprotected function fsock_get_contents( &$url, $timeout, $redirect_max, $ua, $outfp ) {\n\t\t$connect_timeout = 3;\n\t\t$connect_try = 3;\n\t\t$method = 'GET';\n\t\t$readsize = 4096;\n\t\t$ssl = '';\n\n\t\t$getSize = null;\n\t\t$headers = '';\n\t\t\n\t\t$arr = parse_url($url);\n\t\tif (!$arr){\n\t\t\t// Bad request\n\t\t\treturn false;\n\t\t}\n\t\tif ($arr['scheme'] === 'https') {\n\t\t\t$ssl = 'ssl://';\n\t\t}\n\t\t\n\t\t// query\n\t\t$arr['query'] = isset($arr['query']) ? '?'.$arr['query'] : '';\n\t\t// port\n\t\t$port = isset($arr['port']) ? $arr['port'] : '';\n\t\t$arr['port'] = $port? $port : ($ssl? 443 : 80);\n\t\t\n\t\t$url_base = $arr['scheme'].'://'.$arr['host'].($port? (':'.$port) : '');\n\t\t$url_path = isset($arr['path']) ? $arr['path'] : '/';\n\t\t$uri = $url_path.$arr['query'];\n\t\t\n\t\t$query = $method.' '.$uri.\" HTTP/1.0\\r\\n\";\n\t\t$query .= \"Host: \".$arr['host'].\"\\r\\n\";\n\t\t$query .= \"Accept: */*\\r\\n\";\n\t\t$query .= \"Connection: close\\r\\n\";\n\t\tif (!empty($ua)) $query .= \"User-Agent: \".$ua.\"\\r\\n\";\n\t\tif (!is_null($getSize)) $query .= 'Range: bytes=0-' . ($getSize - 1) . \"\\r\\n\";\n\t\t\n\t\t$query .= $headers;\n\n\t\t$query .= \"\\r\\n\";\n\n\t\t$fp = $connect_try_count = 0;\n\t\twhile( !$fp && $connect_try_count < $connect_try ) {\n\t\n\t\t\t$errno = 0;\n\t\t\t$errstr = \"\";\n\t\t\t$fp =  fsockopen(\n\t\t\t\t$ssl.$arr['host'],\n\t\t\t\t$arr['port'],\n\t\t\t\t$errno,$errstr,$connect_timeout);\n\t\t\tif ($fp) break;\n\t\t\t$connect_try_count++;\n\t\t\tif (connection_aborted()) {\n\t\t\t\tthrow new elFinderAbortException();\n\t\t\t}\n\t\t\tsleep(1); // wait 1sec\n\t\t}\n\t\t\n\t\t$fwrite = 0;\n\t\tfor ($written = 0; $written < strlen($query); $written += $fwrite) {\n\t\t\t$fwrite = fwrite($fp, substr($query, $written));\n\t\t\tif (!$fwrite) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t$response = '';\n\t\t\n\t\tif ($timeout) {\n\t\t\tsocket_set_timeout($fp, $timeout);\n\t\t}\n\t\t\n\t\t$_response = '';\n\t\t$header = '';\n\t\twhile($_response !== \"\\r\\n\"){\n\t\t\t$_response = fgets($fp, $readsize);\n\t\t\t$header .= $_response;\n\t\t};\n\t\t\n\t\t$rccd = array_pad(explode(' ',$header,2), 2, ''); // array('HTTP/1.1','200')\n\t\t$rc = (int)$rccd[1];\n\t\t\n\t\t$ret = false;\n\t\t// Redirect\n\t\tswitch ($rc) {\n\t\t\tcase 307: // Temporary Redirect\n\t\t\tcase 303: // See Other\n\t\t\tcase 302: // Moved Temporarily\n\t\t\tcase 301: // Moved Permanently\n\t\t\t\t$matches = array();\n\t\t\t\tif (preg_match('/^Location: (.+?)(#.+)?$/im',$header,$matches) && --$redirect_max > 0) {\n\t\t\t\t\t$_url = $url;\n\t\t\t\t\t$url = trim($matches[1]);\n\t\t\t\t\t$hash = isset($matches[2])? trim($matches[2]) : '';\n\t\t\t\t\tif (!preg_match('/^https?:\\//',$url)) { // no scheme\n\t\t\t\t\t\tif ($url{0} != '/') { // Relative path\n\t\t\t\t\t\t\t// to Absolute path\n\t\t\t\t\t\t\t$url = substr($url_path,0,strrpos($url_path,'/')).'/'.$url;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// add sheme,host\n\t\t\t\t\t\t$url = $url_base.$url;\n\t\t\t\t\t}\n\t\t\t\t\tif ($_url === $url) {\n\t\t\t\t\t\tsleep(1);\n\t\t\t\t\t}\n\t\t\t\t\tfclose($fp);\n\t\t\t\t\treturn $this->fsock_get_contents( $url, $timeout, $redirect_max, $ua, $outfp );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 200:\n\t\t\t\t$ret = true;\n\t\t}\n\t\tif (! $ret) {\n\t\t\tfclose($fp);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$body = '';\n\t\tif (!$outfp) {\n\t\t\t$outfp = fopen('php://temp', 'rwb');\n\t\t\t$body = true;\n\t\t}\n\t\twhile(fwrite($outfp, fread($fp, $readsize))) {\n\t\t\tif ($timeout) {\n\t\t\t\t$_status = socket_get_status($fp);\n\t\t\t\tif ($_status['timed_out']) {\n\t\t\t\t\tfclose($outfp);\n\t\t\t\t\tfclose($fp);\n\t\t\t\t\treturn false; // Request Time-out\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($body) {\n\t\t\trewind($outfp);\n\t\t\t$body = stream_get_contents($outfp);\n\t\t\tfclose($outfp);\n\t\t\t$outfp = null;\n\t\t}\n\t\t\n\t\tfclose($fp);\n\t\t\n\t\treturn $outfp? $outfp : $body; // Data\n\t}\n\t\n\t/**\n\t * Parse Data URI scheme\n\t * \n\t * @param  string $str\n\t * @param  array  $extTable\n\t * @param  array  $args\n\t * @return array\n\t * @author Naoki Sawada\n\t */\n\tprotected function parse_data_scheme($str, $extTable, $args = null) {\n\t\t$data = $name = '';\n\t\t// Scheme 'data://' require `allow_url_fopen` and `allow_url_include`\n\t\tif ($fp = fopen('data://'.substr($str, 5), 'rb')) {\n\t\t\tif ($data = stream_get_contents($fp)) {\n\t\t\t\t$meta = stream_get_meta_data($fp);\n\t\t\t\t$mime = $meta['mediatype'];\n\t\t\t}\n\t\t\tfclose($fp);\n\t\t} else if (preg_match('~^data:(.+?/.+?)?(?:;charset=.+?)?;base64,~', substr($str, 0, 128), $m)) {\n\t\t\t$data = base64_decode(substr($str, strlen($m[0])));\n\t\t\tif ($m[1]) {\n\t\t\t\t$mime = $m[1];\n\t\t\t}\n\t\t}\n\t\tif ($data) {\n\t\t\t$ext = ($mime && isset($extTable[$mime]))? '.' . $extTable[$mime] : '';\n\t\t\t// Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n\t\t\tif (is_array($args['name']) && isset($args['name'][0])) {\n\t\t\t\t$name = $args['name'][0];\n\t\t\t\tif ($ext) {\n\t\t\t\t\t$name = preg_replace('/\\.[^.]*$/', '', $name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$name = substr(md5($data), 0, 8);\n\t\t\t}\n\t\t\t$name .= $ext;\n\t\t} else {\n\t\t\t$data = $name = '';\n\t\t}\n\t\treturn array($data, $name);\n\t}\n\t\n\t/**\n\t * Detect file MIME Type by local path\n\t * \n\t * @param  string $path Local path\n\t * @return string file MIME Type\n\t * @author Naoki Sawada\n\t */\n\tprotected function detectMimeType($path) {\n\t\tstatic $type, $finfo, $volume;\n\t\tif (!$type) {\n\t\t\t$keys = array_keys($this->volumes);\n\t\t\t$volume = $this->volumes[$keys[0]];\n\t\t\t\t\n\t\t\tif (class_exists('finfo', false)) {\n\t\t\t\t$tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n\t\t\t} else {\n\t\t\t\t$tmpFileInfo = false;\n\t\t\t}\n\t\t\t$regexp = '/text\\/x\\-(php|c\\+\\+)/';\n\t\t\tif ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n\t\t\t\t$type = 'finfo';\n\t\t\t\t$finfo = finfo_open(FILEINFO_MIME);\n\t\t\t} elseif (function_exists('mime_content_type')\n\t\t\t\t\t&& preg_match($regexp, array_shift(explode(';', mime_content_type(__FILE__))))) {\n\t\t\t\t\t\t$type = 'mime_content_type';\n\t\t\t} elseif (function_exists('getimagesize')) {\n\t\t\t\t$type = 'getimagesize';\n\t\t\t} else {\n\t\t\t\t$type = 'none';\n\t\t\t}\n\t\t}\n\t\t\n\t\t$mime = '';\n\t\tif ($type === 'finfo') {\n\t\t\t$mime = finfo_file($finfo, $path);\n\t\t} elseif ($type === 'mime_content_type') {\n\t\t\t$mime = mime_content_type($path);\n\t\t} elseif ($type === 'getimagesize') {\n\t\t\tif ($img = getimagesize($path)) {\n\t\t\t\t$mime = $img['mime'];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($mime) {\n\t\t\t$mime = explode(';', $mime);\n\t\t\t$mime = trim($mime[0]);\n\t\t\t\t\n\t\t\tif (in_array($mime, array('application/x-empty', 'inode/x-empty'))) {\n\t\t\t\t// finfo return this mime for empty files\n\t\t\t\t$mime = 'text/plain';\n\t\t\t} elseif ($mime == 'application/x-zip') {\n\t\t\t\t// http://elrte.org/redmine/issues/163\n\t\t\t\t$mime = 'application/zip';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $mime? $mime : 'unknown';\n\t}\n\t\n\t/**\n\t * Detect file type extension by local path\n\t * \n\t * @param  object $volume elFinderVolumeDriver instance\n\t * @param  string $path Local path\n\t * @return string file type extension with dot\n\t * @author Naoki Sawada\n\t */\n\tprotected function detectFileExtension($volume, $path) {\n\t\t$mime = $this->detectMimeType($path);\n\t\t$ext = $mime !== 'unknown'? $volume->getExtentionByMime($mime) : '';\n\t\treturn $ext? ('.' . $ext) : '';\n\t}\n\t\n\t/**\n\t * Get temporary directory path\n\t * \n\t * @param  string $volumeTempPath\n\t * @return string\n\t * @author Naoki Sawada\n\t */\n\tprivate function getTempDir($volumeTempPath = null) {\n\t\t$testDirs = array();\n\t\tif ($this->uploadTempPath) {\n\t\t\t$testDirs[] = rtrim(realpath($this->uploadTempPath), DIRECTORY_SEPARATOR);\n\t\t}\n\t\tif ($volumeTempPath) {\n\t\t\t$testDirs[] = rtrim(realpath($volumeTempPath), DIRECTORY_SEPARATOR);\n\t\t}\n\t\tif (function_exists('sys_get_temp_dir')) {\n\t\t\t$testDirs[] = sys_get_temp_dir();\n\t\t}\n\t\t$tempDir = '';\n\t\tforeach($testDirs as $testDir) {\n\t\t\tif (!$testDir || !is_dir($testDir)) continue;\n\t\t\tif (is_writable($testDir)) {\n\t\t\t\t$tempDir = $testDir;\n\t\t\t\t$gc = time() - 3600;\n\t\t\t\tforeach(glob($tempDir . DIRECTORY_SEPARATOR .'ELF*') as $cf) {\n\t\t\t\t\tif (filemtime($cf) < $gc) {\n\t\t\t\t\t\tunlink($cf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $tempDir;\n\t}\n\t\n\t/**\n\t * chmod\n\t *\n\t * @param array  command arguments\n\t * @return array\n\t * @author David Bartle\n\t **/\n\tprotected function chmod($args) {\n\t\t$targets = $args['targets'];\n\t\t$mode    = intval((string)$args['mode'], 8);\n\n\t\tif (!is_array($targets)) {\n\t\t\t$targets = array($targets);\n\t\t}\n\t\t\n\t\t$result = array();\n\t\t\n\t\tif (($volume = $this->volume($targets[0])) == false) {\n\t\t\t$result['error'] = $this->error(self::ERROR_CONF_NO_VOL);\n\t\t\treturn $result;\n\t\t}\n\n\t\t$this->itemLock($targets);\n\t\t\n\t\t$files = array();\n\t\t$errors = array();\n\t\tforeach($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\t$file = $volume->chmod($target, $mode);\n\t\t\tif ($file) {\n\t\t\t\t$files = array_merge($files, is_array($file)? $file : array($file));\n\t\t\t} else {\n\t\t\t\t$errors = array_merge($errors, $volume->error());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($files) {\n\t\t\t$result['changed'] = $files;\n\t\t\tif ($errors) {\n\t\t\t\t$result['warning'] = $this->error($errors);\n\t\t\t}\n\t\t} else {\n\t\t\t$result['error'] = $this->error($errors);\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Check chunked upload files\n\t *\n\t * @param string $tmpname uploaded temporary file path\n\t * @param string $chunk uploaded chunk file name\n\t * @param string $cid uploaded chunked file id\n\t * @param string $tempDir temporary dirctroy path\n\t * @param null $volume\n\t * @return array or (empty, empty)\n\t * @author Naoki Sawada\n\t */\n\tprivate function checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume = null) {\n\t\tif (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n\t\t\t$fname = $m[1];\n\t\t\t$encname = md5($cid . '_' . $fname);\n\t\t\t$base = $tempDir . DIRECTORY_SEPARATOR . 'ELF' . $encname;\n\t\t\t$clast = intval($m[3]);\n\t\t\tif (is_null($tmpname)) {\n\t\t\t\tignore_user_abort(true);\n\t\t\t\t// chunked file upload fail\n\t\t\t\tforeach(glob($base . '*') as $cf) {\n\t\t\t\t\tunlink($cf);\n\t\t\t\t}\n\t\t\t\tignore_user_abort(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t$range = isset($_POST['range'])? trim($_POST['range']) : '';\n\t\t\tif ($range && preg_match('/^(\\d+),(\\d+),(\\d+)$/', $range, $ranges)) {\n\t\t\t\t$start = $ranges[1];\n\t\t\t\t$len   = $ranges[2];\n\t\t\t\t$size  = $ranges[3];\n\t\t\t\t$tmp = $base . '.part';\n\t\t\t\t$csize = filesize($tmpname);\n\t\t\t\t\n\t\t\t\t$tmpExists = is_file($tmp);\n\t\t\t\tif (!$tmpExists) {\n\t\t\t\t\t// check upload max size\n\t\t\t\t\t$uploadMaxSize = $volume->getUploadMaxSize();\n\t\t\t\t\tif ($uploadMaxSize > 0 && $size > $uploadMaxSize) {\n\t\t\t\t\t\treturn array(self::ERROR_UPLOAD_FILE_SIZE, false);\n\t\t\t\t\t}\n\t\t\t\t\t// make temp file\n\t\t\t\t\t$ok = false;\n\t\t\t\t\tif ($fp = fopen($tmp, 'wb')) {\n\t\t\t\t\t\tflock($fp, LOCK_EX);\n\t\t\t\t\t\t$ok = ftruncate($fp, $size);\n\t\t\t\t\t\tflock($fp, LOCK_UN);\n\t\t\t\t\t\tfclose($fp);\n\t\t\t\t\t\ttouch($base);\n\t\t\t\t\t}\n\t\t\t\t\tif (!$ok) {\n\t\t\t\t\t\tunlink($tmp);\n\t\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// wait until makeing temp file (for anothor session)\n\t\t\t\t\t$cnt = 1200; // Time limit 120 sec\n\t\t\t\t\twhile(!is_file($base) && --$cnt) {\n\t\t\t\t\t\tusleep(100000); // wait 100ms\n\t\t\t\t\t}\n\t\t\t\t\tif (!$cnt) {\n\t\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// check size info\n\t\t\t\tif ($len != $csize || $start + $len > $size || ($tmpExists && $size != filesize($tmp))) {\n\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// write chunk data\n\t\t\t\t$writelen = 0;\n\t\t\t\t$src = fopen($tmpname, 'rb');\n\t\t\t\t$fp = fopen($tmp, 'cb');\n\t\t\t\tfseek($fp, $start);\n\t\t\t\t$writelen = stream_copy_to_stream($src, $fp, $len);\n\t\t\t\tfclose($fp);\n\t\t\t\tfclose($src);\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\t// to check connection is aborted\n\t\t\t\t\telFinder::checkAborted();\n\t\t\t\t} catch (elFinderAbortException $e) {\n\t\t\t\t\tunlink($tmpname);\n\t\t\t\t\tis_file($tmp) && unlink($tmp);\n\t\t\t\t\tis_file($base) && unlink($base);\n\t\t\t\t\tthrow $e;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($writelen != $len) {\n\t\t\t\t\treturn array(self::ERROR_UPLOAD_TEMP, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// write counts\n\t\t\t\tfile_put_contents($base, \"\\0\", FILE_APPEND | LOCK_EX);\n\t\t\t\t\n\t\t\t\tif (filesize($base) >= $clast + 1) {\n\t\t\t\t\t// Completion\n\t\t\t\t\tunlink($base);\n\t\t\t\t\treturn array($tmp, $fname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// old way\n\t\t\t\t$part = $base . $m[2];\n\t\t\t\tif (move_uploaded_file($tmpname, $part)) {\n\t\t\t\t\tchmod($part, 0600);\n\t\t\t\t\tif ($clast < count(glob($base . '*'))) {\n\t\t\t\t\t\t$parts = array();\n\t\t\t\t\t\tfor ($i = 0; $i <= $clast; $i++) {\n\t\t\t\t\t\t\t$name = $base . '.' . $i . '_' . $clast;\n\t\t\t\t\t\t\tif (is_readable($name)) {\n\t\t\t\t\t\t\t\t$parts[] = $name;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$parts = null;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($parts) {\n\t\t\t\t\t\t\tif (!is_file($base)) {\n\t\t\t\t\t\t\t\ttouch($base);\n\t\t\t\t\t\t\t\tif ($resfile = tempnam($tempDir, 'ELF')) {\n\t\t\t\t\t\t\t\t\t$target = fopen($resfile, 'wb');\n\t\t\t\t\t\t\t\t\tforeach($parts as $f) {\n\t\t\t\t\t\t\t\t\t\t$fp = fopen($f, 'rb');\n\t\t\t\t\t\t\t\t\t\twhile (!feof($fp)) {\n\t\t\t\t\t\t\t\t\t\t\tfwrite($target, fread($fp, 8192));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfclose($fp);\n\t\t\t\t\t\t\t\t\t\tunlink($f);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfclose($target);\n\t\t\t\t\t\t\t\t\tunlink($base);\n\t\t\t\t\t\t\t\t\treturn array($resfile, $fname);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tunlink($base);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array('', '');\n\t}\n\t\n\t/**\n\t * Save uploaded files\n\t *\n\t * @param  array\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function upload($args) {\n\t\t$ngReg  = '/[\\/\\\\?*:|\"<>]/';\n\t\t$target = $args['target'];\n\t\t$volume = $this->volume($target);\n\t\t$files  = isset($args['FILES']['upload']) && is_array($args['FILES']['upload']) ? $args['FILES']['upload'] : array();\n\t\t$header = empty($args['html']) ? array() : array('header' => 'Content-Type: text/html; charset=utf-8');\n\t\t$result = array_merge(array('added' => array()), $header);\n\t\t$paths  = $args['upload_path']? $args['upload_path'] : array();\n\t\t$chunk  = $args['chunk']? $args['chunk'] : '';\n\t\t$cid    = $args['cid']? (int)$args['cid'] : '';\n\t\t$mtimes = $args['mtime']? $args['mtime'] : array();\n\t\t\n\t\tif (!$volume) {\n\t\t\treturn array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, '#'.$target)), $header);\n\t\t}\n\t\t\n\t\t// check $chunk\n\t\tif (strpos($chunk, '/') !== false || strpos($chunk, '\\\\') !== false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_UPLOAD));\n\t\t}\n\t\t\n\t\tif ($args['overwrite'] !== '') {\n\t\t\t$volume->setUploadOverwrite($args['overwrite']);\n\t\t}\n\t\t\n\t\t$renames = $hashes = array();\n\t\t$suffix = '~';\n\t\tif ($args['renames'] && is_array($args['renames'])) {\n\t\t\t$renames = array_flip($args['renames']);\n\t\t\tif (is_string($args['suffix']) && ! preg_match($ngReg, $args['suffix'])) {\n\t\t\t\t$suffix = $args['suffix'];\n\t\t\t}\n\t\t}\n\t\tif ($args['hashes'] && is_array($args['hashes'])) {\n\t\t\t$hashes = array_flip($args['hashes']);\n\t\t}\n\t\t\n\t\t$this->itemLock($target);\n\t\t\n\t\t// file extentions table by MIME\n\t\t$extTable = array_flip(array_unique($volume->getMimeTable()));\n\t\t\n\t\tif (empty($files)) {\n\t\t\tif (isset($args['upload']) && is_array($args['upload']) && ($tempDir = $this->getTempDir($volume->getTempPath()))) {\n\t\t\t\t$names = array();\n\t\t\t\tforeach($args['upload'] as $i => $url) {\n\t\t\t\t\t// check chunked file upload commit\n\t\t\t\t\tif ($chunk) {\n\t\t\t\t\t\tif ($url === 'chunkfail' && $args['mimes'] === 'chunkfail') {\n\t\t\t\t\t\t\t$this->checkChunkedFile(null, $chunk, $cid, $tempDir);\n\t\t\t\t\t\t\tif (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n\t\t\t\t\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn $result;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$tmpfname = $tempDir . '/' . $chunk;\n\t\t\t\t\t\t\t$files['tmp_name'][$i] = $tmpfname;\n\t\t\t\t\t\t\t$files['name'][$i] = $url;\n\t\t\t\t\t\t\t$files['error'][$i] = 0;\n\t\t\t\t\t\t\t$GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$tmpfname = $tempDir . DIRECTORY_SEPARATOR . 'ELF_FATCH_' . md5($url.microtime(true));\n\t\t\t\t\t$GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\t\t\t\t\t\n\t\t\t\t\t$_name = '';\n\t\t\t\t\t// check is data:\n\t\t\t\t\tif (substr($url, 0, 5) === 'data:') {\n\t\t\t\t\t\tlist($data, $args['name'][$i]) = $this->parse_data_scheme($url, $extTable, $args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$fp = fopen($tmpfname, 'wb');\n\t\t\t\t\t\t$data = $this->get_remote_contents($url, 30, 5, 'Mozilla/5.0', $fp);\n\t\t\t\t\t\t// to check connection is aborted\n\t\t\t\t\t\telFinder::checkAborted();\n\t\t\t\t\t\t$_name = preg_replace('~^.*?([^/#?]+)(?:\\?.*)?(?:#.*)?$~', '$1', rawurldecode($url));\n\t\t\t\t\t\t// Check `Content-Disposition` response header\n\t\t\t\t\t\tif ($data && ($headers = get_headers($url, true)) && !empty($headers['Content-Disposition'])) {\n\t\t\t\t\t\t\tif (preg_match('/filename\\*?=(?:([a-zA-Z0-9_-]+?)\\'\\')?\"?([a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n\t\t\t\t\t\t\t\t$_name = rawurldecode($m[2]);\n\t\t\t\t\t\t\t\tif ($m[1] && strtoupper($m[1]) !== 'UTF-8' && function_exists('mb_convert_encoding')) {\n\t\t\t\t\t\t\t\t\t$_name = mb_convert_encoding($_name, 'UTF-8', $m[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($data) {\n\t\t\t\t\t\tif (isset($args['name'][$i])) {\n\t\t\t\t\t\t\t$_name = $args['name'][$i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($_name) {\n\t\t\t\t\t\t\t$_ext = '';\n\t\t\t\t\t\t\tif (preg_match('/(\\.[a-z0-9]{1,7})$/', $_name, $_match)) {\n\t\t\t\t\t\t\t\t$_ext = $_match[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((is_resource($data) && fclose($data)) || file_put_contents($tmpfname, $data)) {\n\t\t\t\t\t\t\t\t$GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\t\t\t\t\t\t\t\t$_name = preg_replace($ngReg, '_', $_name);\n\t\t\t\t\t\t\t\tlist($_a, $_b) = array_pad(explode('.', $_name, 2), 2, '');\n\t\t\t\t\t\t\t\tif ($_b === '') {\n\t\t\t\t\t\t\t\t\tif ($_ext) {\n\t\t\t\t\t\t\t\t\t\trename($tmpfname, $tmpfname . $_ext);\n\t\t\t\t\t\t\t\t\t\t$tmpfname = $tmpfname . $_ext;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$_b = $this->detectFileExtension($volume, $tmpfname);\n\t\t\t\t\t\t\t\t\t$_name = $_a.$_b;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$_b = '.'.$_b;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (isset($names[$_name])) {\n\t\t\t\t\t\t\t\t\t$_name = $_a.'_'.$names[$_name]++.$_b;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$names[$_name] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$files['tmp_name'][$i] = $tmpfname;\n\t\t\t\t\t\t\t\t$files['name'][$i] = $_name;\n\t\t\t\t\t\t\t\t$files['error'][$i] = 0;\n\t\t\t\t\t\t\t\t// set to auto rename\n\t\t\t\t\t\t\t\t$volume->setUploadOverwrite(false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tunlink($tmpfname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (empty($files)) {\n\t\t\t\treturn array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_UPLOAD_NO_FILES)), $header);\n\t\t\t}\n\t\t}\n\n\t\t$addedDirs = array();\n\t\tforeach ($files['name'] as $i => $name) {\n\t\t\tif (($error = $files['error'][$i]) > 0) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $error == UPLOAD_ERR_INI_SIZE || $error == UPLOAD_ERR_FORM_SIZE ? self::ERROR_UPLOAD_FILE_SIZE : self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t$this->uploadDebug = 'Upload error code: '.$error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t$tmpname = $files['tmp_name'][$i];\n\t\t\t$thash = ($paths && isset($paths[$i]))? $paths[$i] : $target;\n\t\t\t$mtime = isset($mtimes[$i])? $mtimes[$i] : 0;\n\t\t\tif ($name === 'blob') {\n\t\t\t\tif ($chunk) {\n\t\t\t\t\tif ($tempDir = $this->getTempDir($volume->getTempPath())) {\n\t\t\t\t\t\tlist($tmpname, $name) = $this->checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume);\n\t\t\t\t\t\tif ($tmpname) {\n\t\t\t\t\t\t\tif ($name === false) {\n\t\t\t\t\t\t\t\tpreg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m);\n\t\t\t\t\t\t\t\t$result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], $tmpname);\n\t\t\t\t\t\t\t\t$result['_chunkfailure'] = true;\n\t\t\t\t\t\t\t\t$this->uploadDebug = 'Upload error: ' . $tmpname;\n\t\t\t\t\t\t\t} else if ($name) {\n\t\t\t\t\t\t\t\t$result['_chunkmerged'] = basename($tmpname);\n\t\t\t\t\t\t\t\t$result['_name'] = $name;\n\t\t\t\t\t\t\t\t$result['_mtime'] = $mtime;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $chunk, self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t\t\t$this->uploadDebug = 'Upload error: unable open tmp file';\n\t\t\t\t\t}\n\t\t\t\t\treturn $result;\n\t\t\t\t} else {\n\t\t\t\t\t// for form clipboard with Google Chrome or Opera\n\t\t\t\t\t$name = 'image.png';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n\t\t\tif (strtolower(substr($name, 0, 5)) === 'image' && is_array($args['name']) && isset($args['name'][$i])) {\n\t\t\t\t$type = $files['type'][$i];\n\t\t\t\t$name = $args['name'][$i];\n\t\t\t\t$ext = isset($extTable[$type])? '.' . $extTable[$type] : '';\n\t\t\t\tif ($ext) {\n\t\t\t\t\t$name = preg_replace('/\\.[^.]*$/', '', $name);\n\t\t\t\t}\n\t\t\t\t$name .= $ext;\n\t\t\t}\n\t\t\t\n\t\t\t// do hook function 'upload.presave'\n\t\t\tif (! empty($this->listeners['upload.presave'])) {\n\t\t\t\tforeach($this->listeners['upload.presave'] as $handler) {\n\t\t\t\t\tcall_user_func_array($handler, array(&$thash, &$name, $tmpname, $this, $volume));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($mtime) {\n\t\t\t\t// for keep timestamp option in the LocalFileSystem volume\n\t\t\t\ttouch($tmpname, $mtime);\n\t\t\t}\n\t\t\t\n\t\t\tif (($fp = fopen($tmpname, 'rb')) == false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, self::ERROR_UPLOAD_TRANSFER);\n\t\t\t\t$this->uploadDebug = 'Upload error: unable open tmp file';\n\t\t\t\tif (! is_uploaded_file($tmpname)) {\n\t\t\t\t\tif (unlink($tmpname)) unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$rnres = array();\n\t\t\tif ($thash !== '' && $thash !== $target) {\n\t\t\t\tif ($dir = $volume->dir($thash)) {\n\t\t\t\t\t$_target = $thash;\n\t\t\t\t\tif (! isset($addedDirs[$thash])) {\n\t\t\t\t\t\t$addedDirs[$thash] = true;\n\t\t\t\t\t\t$result['added'][] =$dir;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$result['error'] = $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, 'hash@'.$thash);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$_target = $target;\n\t\t\t\t// file rename for backup\n\t\t\t\tif (isset($renames[$name])) {\n\t\t\t\t\t$dir = $volume->realpath($_target);\n\t\t\t\t\tif (isset($hashes[$name])) {\n\t\t\t\t\t\t$hash = $hashes[$name];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$hash = $volume->getHash($dir, $name);\n\t\t\t\t\t}\n\t\t\t\t\t$rnres = $this->rename(array('target' => $hash, 'name' => $volume->uniqueName($dir, $name, $suffix, true, 0)));\n\t\t\t\t\tif (!empty($rnres['error'])) {\n\t\t\t\t\t\t$result['warning'] = $rnres['error'];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! $_target || ($file = $volume->upload($fp, $_target, $name, $tmpname, $hashes)) === false) {\n\t\t\t\t$result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $volume->error());\n\t\t\t\tfclose($fp);\n\t\t\t\tif (! is_uploaded_file($tmpname)) {\n\t\t\t\t\tif (unlink($tmpname)) unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tis_resource($fp) && fclose($fp);\n\t\t\tif (! is_uploaded_file($tmpname)){\n\t\t\t\tclearstatcache();\n\t\t\t\tif (!is_file($tmpname) || unlink($tmpname)) {\n\t\t\t\t\tunset($GLOBALS['elFinderTempFiles'][$tmpname]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$result['added'][] = $file;\n\t\t\tif ($rnres) {\n\t\t\t\t$result = array_merge_recursive($result, $rnres);\n\t\t\t}\n\t\t}\n\t\tif ($GLOBALS['elFinderTempFiles']) {\n\t\t\tforeach(array_keys($GLOBALS['elFinderTempFiles']) as $_temp) {\n\t\t\t\t is_file($_temp) && unlink($_temp);\n\t\t\t}\n\t\t}\n\t\t$result['removed'] = $volume->removed();\n\t\t\n\t\tif (!empty($args['node'])) {\n\t\t\t$result['callback'] = array(\n\t\t\t\t'node' => $args['node'],\n\t\t\t\t'bind' => 'upload'\n\t\t\t);\n\t\t}\n\t\treturn $result;\n\t}\n\t\t\n\t/**\n\t * Copy/move files into new destination\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function paste($args) {\n\t\t$dst     = $args['dst'];\n\t\t$targets = is_array($args['targets']) ? $args['targets'] : array();\n\t\t$cut     = !empty($args['cut']);\n\t\t$error   = $cut ? self::ERROR_MOVE : self::ERROR_COPY;\n\t\t$result  = array('changed' => array(), 'added' => array(), 'removed' => array(), 'warning' => array());\n\t\t\n\t\tif (($dstVolume = $this->volume($dst)) == false) {\n\t\t\treturn array('error' => $this->error($error, '#'.$targets[0], self::ERROR_TRGDIR_NOT_FOUND, '#'.$dst));\n\t\t}\n\t\t\n\t\t$this->itemLock($dst);\n\t\t\n\t\t$hashes = $renames = array();\n\t\t$suffix = '~';\n\t\tif (!empty($args['renames'])) {\n\t\t\t$renames = array_flip($args['renames']);\n\t\t\tif (is_string($args['suffix']) && ! preg_match('/[\\/\\\\?*:|\"<>]/', $args['suffix'])) {\n\t\t\t\t$suffix = $args['suffix'];\n\t\t\t}\n\t\t}\n\t\tif (!empty($args['hashes'])) {\n\t\t\t$hashes = array_flip($args['hashes']);\n\t\t}\n\t\t\n\t\tforeach ($targets as $target) {\n\t\t\telFinder::checkAborted();\n\t\t\t\n\t\t\tif (($srcVolume = $this->volume($target)) == false) {\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error($error, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$rnres = array();\n\t\t\tif ($renames) {\n\t\t\t\t$file = $srcVolume->file($target);\n\t\t\t\tif (isset($renames[$file['name']])) {\n\t\t\t\t\t$dir = $dstVolume->realpath($dst);\n\t\t\t\t\tif (isset($hashes[$file['name']])) {\n\t\t\t\t\t\t$hash = $hashes[$file['name']];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$hash = $dstVolume->getHash($dir, $file['name']);\n\t\t\t\t\t}\n\t\t\t\t\t$rnres = $this->rename(array('target' => $hash, 'name' => $dstVolume->uniqueName($dir, $file['name'], $suffix, true, 0)));\n\t\t\t\t\tif (!empty($rnres['error'])) {\n\t\t\t\t\t\t$result['warning'] = array_merge($result['warning'], $rnres['error']);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($cut && $this->itemLocked($target)) {\n\t\t\t\t$rm = $srcVolume->file($target);\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error(self::ERROR_LOCKED, $rm['name']));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (($file = $dstVolume->paste($srcVolume, $target, $dst, $cut, $hashes)) == false) {\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error($dstVolume->error()));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif ($error = $dstVolume->error()) {\n\t\t\t\t$result['warning'] = array_merge($result['warning'], $this->error($error));\n\t\t\t}\n\n\t\t\t$dirChange = ! empty($file['dirChange']);\n\t\t\tunset($file['dirChange']);\n\t\t\tif ($dirChange) {\n\t\t\t\t$result['changed'][] = $file;\n\t\t\t} else {\n\t\t\t\t$result['added'][] = $file;\n\t\t\t}\n\t\t\tif ($rnres) {\n\t\t\t\t$result = array_merge_recursive($result, $rnres);\n\t\t\t}\n\t\t}\n\t\tif (count($result['warning']) < 1) {\n\t\t\tunset($result['warning']);\n\t\t} else {\n\t\t\t$result['sync'] = true;\n\t\t}\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return file content\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function get($args) {\n\t\t$target = $args['target'];\n\t\t$volume = $this->volume($target);\n\t\t$enc = false;\n\t\t\n\t\tif (!$volume || ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\tif (($content = $volume->getContents($target)) === false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_OPEN, $volume->path($target), $volume->error()));\n\t\t}\n\t\t\n\t\t$mime = isset($file['mime'])? $file['mime'] : '';\n\t\tif ($mime && (strtolower(substr($mime, 0, 4)) === 'text' || in_array(strtolower($mime), self::$textMimes))) {\n\t\t\t$enc = '';\n\t\t\tif ($content !== '') {\n\t\t\t\tif (! $args['conv'] || $args['conv'] == '1') {\n\t\t\t\t\t// detect encoding\n\t\t\t\t\tif (function_exists('mb_detect_encoding')) {\n\t\t\t\t\t\tif ($enc = mb_detect_encoding($content , mb_detect_order(), true)) {\n\t\t\t\t\t\t\t$encu = strtoupper($enc);\n\t\t\t\t\t\t\tif ($encu === 'UTF-8' || $encu === 'ASCII') {\n\t\t\t\t\t\t\t\t$enc = '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (! preg_match('//u', $content)) {\n\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t}\n\t\t\t\t\tif ($enc === 'unknown') {\n\t\t\t\t\t\t$enc = $volume->getOption('encoding');\n\t\t\t\t\t\tif (! $enc || strtoupper($enc) === 'UTF-8') {\n\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($enc && $enc !== 'unknown') {\n\t\t\t\t\t\t$utf8 = iconv($enc, 'UTF-8', $content);\n\t\t\t\t\t\tif ($utf8 === false && function_exists('mb_convert_encoding')) {\n\t\t\t\t\t\t\t$utf8 = mb_convert_encoding($content, 'UTF-8', $enc);\n\t\t\t\t\t\t\tif (mb_convert_encoding($utf8, $enc, 'UTF-8') !== $content) {\n\t\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ($utf8 === false || iconv('UTF-8', $enc, $utf8) !== $content) {\n\t\t\t\t\t\t\t\t$enc = 'unknown';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($enc !== 'unknown') {\n\t\t\t\t\t\t\t$content = $utf8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($enc) {\n\t\t\t\t\t\tif ($args['conv'] == '1') {\n\t\t\t\t\t\t\t$args['conv'] = '';\n\t\t\t\t\t\t\tif ($enc === 'unknown') {\n\t\t\t\t\t\t\t\t$content = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ($enc === 'unknown') {\n\t\t\t\t\t\t\treturn array('doconv' => $enc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($args['conv'] == '1') {\n\t\t\t\t\t\t$args['conv'] = '';\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif ($args['conv']) {\n\t\t\t\t\t$enc = $args['conv'];\n\t\t\t\t\tif (strtoupper($enc) !== 'UTF-8') {\n\t\t\t\t\t\t$_content = $content;\n\t\t\t\t\t\t$content = iconv($enc, 'UTF-8', $content);\n\t\t\t\t\t\tif ($content === false && function_exists('mb_convert_encoding')) {\n\t\t\t\t\t\t\t$content = mb_convert_encoding($_content, 'UTF-8', $enc);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$enc = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$content = 'data:' . ($mime? $mime : 'application/octet-stream') . ';base64,'.base64_encode($content);\n\t\t}\n\t\t\n\t\tif ($enc !== false) {\n\t\t\tif ($content !== false) {\n\t\t\t\t$json = json_encode($content);\n\t\t\t}\n\t\t\tif ($content === false || $json === false || strlen($json) < strlen($content)) {\n\t\t\t\treturn array('error' => $this->error(self::ERROR_CONV_UTF8, self::ERROR_NOT_UTF8_CONTENT, $volume->path($target)));\n\t\t\t}\n\t\t}\n\t\t\n\t\t$res = array(\n\t\t\t'header'  => array(\n\t\t\t\t'Content-Type: application/json'\n\t\t\t),\n\t\t\t'content' => $content\n\t\t);\n\t\t\n\t\t// add cache control headers\n\t\tif ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n\t\t\t$res['header'] = array_merge($res['header'], $cacheHeaders);\n\t\t}\n\t\t\n\t\tif ($enc) {\n\t\t\t$res['encoding'] = $enc;\n\t\t}\n\t\treturn $res;\n\t}\n\n\t/**\n\t * Save content into text file\n\t *\n\t * @param $args\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t */\n\tprotected function put($args) {\n\t\t$target = $args['target'];\n\t\t$encoding = isset($args['encoding'])? $args['encoding'] : '';\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_SAVE, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\t$this->itemLock($target);\n\t\t\n\t\tif ($encoding === 'scheme') {\n\t\t\tif (preg_match('~^https?://~i', $args['content'])) {\n\t\t\t\t$fp = $this->get_remote_contents($args['content'], 30, 5, 'Mozilla/5.0', $volume->tmpfile());\n\t\t\t\tif (! $fp) {\n\t\t\t\t\treturn  array('error' => self::ERROR_SAVE, $args['content'], self::ERROR_FILE_NOT_FOUND);\n\t\t\t\t}\n\t\t\t\t$fmeta = stream_get_meta_data($fp);\n\t\t\t\t$mime = $this->detectMimeType($fmeta['uri']);\n\t\t\t\t$args['content'] = 'data:'.$mime.';base64,'.base64_encode(file_get_contents($fmeta['uri']));\n\t\t\t}\n\t\t\t$encoding = '';\n\t\t\t$args['content'] = \"\\0\" . $args['content'];\n\t\t} else if ($encoding === 'hash') {\n\t\t\t$_hash = $args['content'];\n\t\t\tif ($_src = $this->getVolume($_hash)) {\n\t\t\t\tif ($_file = $_src->file($_hash)) {\n\t\t\t\t\tif ($_data = $_src->getContents($_hash)) {\n\t\t\t\t\t\t$args['content'] = 'data:'.$file['mime'].';base64,'.base64_encode($_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$encoding = '';\n\t\t\t$args['content'] = \"\\0\" . $args['content'];\n\t\t}\n\t\tif ($encoding) {\n\t\t\t$content = iconv('UTF-8', $encoding, $args['content']);\n\t\t\tif ($content === false && function_exists('mb_detect_encoding')) {\n\t\t\t\t$content = mb_convert_encoding($args['content'], $encoding, 'UTF-8');\n\t\t\t}\n\t\t\tif ($content !== false) {\n\t\t\t\t$args['content'] = $content;\n\t\t\t}\n\t\t}\n\t\tif (($file = $volume->putContents($target, $args['content'])) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_SAVE, $volume->path($target), $volume->error()));\n\t\t}\n\t\t\n\t\treturn array('changed' => array($file));\n\t}\n\n\t/**\n\t * Extract files from archive\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov, \n\t * @author Alexey Sukhotin\n\t **/\n\tprotected function extract($args) {\n\t\t$target = $args['target'];\n\t\t$mimes  = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n\t\t$error  = array(self::ERROR_EXTRACT, '#'.$target);\n\t\t$makedir = isset($args['makedir'])? (bool)$args['makedir'] : null;\n\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_EXTRACT, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}  \n\n\t\t$res = array();\n\t\tif ($file = $volume->extract($target, $makedir)) {\n\t\t\t$res['added'] = isset($file['read'])? array($file) : $file;\n\t\t\tif ($err = $volume->error()) {\n\t\t\t\t$res['warning'] = $err;\n\t\t\t}\n\t\t} else {\n\t\t\t$res['error'] = $this->error(self::ERROR_EXTRACT, $volume->path($target), $volume->error());\n\t\t}\n\t\treturn $res;\n\t}\n\t\n\t/**\n\t * Create archive\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov, \n\t * @author Alexey Sukhotin\n\t **/\n\tprotected function archive($args) {\n\t\t$type    = $args['type'];\n\t\t$targets = isset($args['targets']) && is_array($args['targets']) ? $args['targets'] : array();\n\t\t$name    = isset($args['name'])? $args['name'] : '';\n\t\n\t\tif (($volume = $this->volume($targets[0])) == false) {\n\t\t\treturn $this->error(self::ERROR_ARCHIVE, self::ERROR_TRGDIR_NOT_FOUND);\n\t\t}\n\t\t\n\t\tforeach($targets as $target) {\n\t\t\t$this->itemLock($target);\n\t\t}\n\t\t\n\t\treturn ($file = $volume->archive($targets, $args['type'], $name))\n\t\t\t? array('added' => array($file))\n\t\t\t: array('error' => $this->error(self::ERROR_ARCHIVE, $volume->error()));\n\t}\n\t\n\t/**\n\t * Search files\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry Levashov\n\t **/\n\tprotected function search($args) {\n\t\t$q      = trim($args['q']);\n\t\t$mimes  = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n\t\t$target = !empty($args['target'])? $args['target'] : null;\n\t\t$result = array();\n\t\t$errors = array();\n\n\t\tif ($target) {\n\t\t\tif ($volume = $this->volume($target)) {\n\t\t\t\t$result = $volume->search($q, $mimes, $target);\n\t\t\t\t$errors = array_merge($errors, $volume->error());\n\t\t\t}\n\t\t} else {\n\t\t\tforeach ($this->volumes as $volume) {\n\t\t\t\t$result = array_merge($result, $volume->search($q, $mimes));\n\t\t\t\t$errors = array_merge($errors, $volume->error());\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array('files' => $result);\n\t\tif ($errors) {\n\t\t\t$result['warning'] = $errors;\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return file info (used by client \"places\" ui)\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry Levashov\n\t **/\n\tprotected function info($args) {\n\t\t$files = array();\n\t\t$sleep = 0;\n\t\t$compare = null;\n\t\t// long polling mode\n\t\tif ($args['compare'] && count($args['targets']) === 1) {\n\t\t\t$compare = intval($args['compare']);\n\t\t\t$hash = $args['targets'][0];\n\t\t\tif ($volume = $this->volume($hash)) {\n\t\t\t\t$standby = (int)$volume->getOption('plStandby');\n\t\t\t\t$_compare = false;\n\t\t\t\tif (($syncCheckFunc = $volume->getOption('syncCheckFunc')) && is_callable($syncCheckFunc)) {\n\t\t\t\t\t$_compare = call_user_func_array($syncCheckFunc, array($volume->realpath($hash), $standby, $compare, $volume, $this));\n\t\t\t\t}\n\t\t\t\tif ($_compare !== false) {\n\t\t\t\t\t$compare = $_compare;\n\t\t\t\t} else {\n\t\t\t\t\t$sleep = max(1, (int)$volume->getOption('tsPlSleep'));\n\t\t\t\t\t$limit = max(1, $standby / $sleep) + 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\telFinder::extendTimeLimit(30 + $sleep);\n\t\t\t\t\t\t$volume->clearstatcache();\n\t\t\t\t\t\tif (($info = $volume->file($hash)) != false) {\n\t\t\t\t\t\t\tif ($info['ts'] != $compare) {\n\t\t\t\t\t\t\t\t$compare = $info['ts'];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$compare = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (--$limit) {\n\t\t\t\t\t\t\tsleep($sleep);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while($limit);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tforeach ($args['targets'] as $hash) {\n\t\t\t\telFinder::checkAborted();\n\t\t\t\tif (($volume = $this->volume($hash)) != false\n\t\t\t\t&& ($info = $volume->file($hash)) != false) {\n\t\t\t\t\t$info['path'] = $volume->path($hash);\n\t\t\t\t\t$files[] = $info;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t$result = array('files' => $files);\n\t\tif (!is_null($compare)) {\n\t\t\t$result['compare'] = strval($compare);\n\t\t}\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return image dimensions\n\t *\n\t * @param  array  $args  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function dim($args) {\n\t\t$res = array();\n\t\t$target = $args['target'];\n\t\t\n\t\tif (($volume = $this->volume($target)) != false) {\n\t\t\tif ($dim = $volume->dimensions($target, $args)) {\n\t\t\t\tif (is_array($dim) && isset($dim['dim'])) {\n\t\t\t\t\t$res = $dim;\n\t\t\t\t} else {\n\t\t\t\t\t$res = array('dim' => $dim);\n\t\t\t\t\tif ($subImgLink = $volume->getSubstituteImgLink($target, explode('x', $dim))) {\n\t\t\t\t\t\t$res['url'] = $subImgLink;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $res;\n\t}\n\t\n\t/**\n\t * Resize image\n\t *\n\t * @param  array  command arguments\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t * @author Alexey Sukhotin\n\t **/\n\tprotected function resize($args) {\n\t\t$target = $args['target'];\n\t\t$width  = (int)$args['width'];\n\t\t$height = (int)$args['height'];\n\t\t$x      = (int)$args['x'];\n\t\t$y      = (int)$args['y'];\n\t\t$mode   = $args['mode'];\n\t\t$bg     = $args['bg'];\n\t\t$degree = (int)$args['degree'];\n\t\t$quality= (int)$args['quality'];\n\t\t\n\t\tif (($volume = $this->volume($target)) == false\n\t\t|| ($file = $volume->file($target)) == false) {\n\t\t\treturn array('error' => $this->error(self::ERROR_RESIZE, '#'.$target, self::ERROR_FILE_NOT_FOUND));\n\t\t}\n\t\t\n\t\tif ($mode !== 'rotate' && ($width < 1 || $height < 1)) {\n\t\t\treturn array('error' => $this->error(self::ERROR_RESIZESIZE));\n\t\t}\n\t\treturn ($file = $volume->resize($target, $width, $height, $x, $y, $mode, $bg, $degree, $quality))\n\t\t\t? (!empty($file['losslessRotate'])? $file : array('changed' => array($file)))\n\t\t\t: array('error' => $this->error(self::ERROR_RESIZE, $volume->path($target), $volume->error()));\n\t}\n\t\n\t/**\n\t* Return content URL\n\t*\n\t* @param  array  $args  command arguments\n\t* @return array\n\t* @author Naoki Sawada\n\t**/\n\tprotected function url($args) {\n\t\t$target = $args['target'];\n\t\t$options = isset($args['options'])? $args['options'] : array();\n\t\tif (($volume = $this->volume($target)) != false) {\n\t\t\tif (! $volume->commandDisabled('url')) {\n\t\t\t\t$url = $volume->getContentUrl($target, $options);\n\t\t\t\treturn $url ? array('url' => $url) : array();\n\t\t\t}\n\t\t}\n\t\treturn array();\n\t}\n\n\t/**\n\t * Output callback result with JavaScript that control elFinder\n\t * or HTTP redirect to callbackWindowURL\n\t * \n\t * @param  array  command arguments\n\t * @author Naoki Sawada\n\t */\n\tprotected function callback($args) {\n\t\t$checkReg = '/[^a-zA-Z0-9;._-]/';\n\t\t$node = (isset($args['node']) && !preg_match($checkReg, $args['node']))? $args['node'] : '';\n\t\t$json = (isset($args['json']) && json_decode($args['json']))? $args['json'] : '{}';\n\t\t$bind  = (isset($args['bind']) && !preg_match($checkReg, $args['bind']))? $args['bind'] : '';\n\t\t$done = (!empty($args['done']));\n\t\t\n\t\twhile( ob_get_level() ) {\n\t\t\tif (! ob_end_clean()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($done || ! $this->callbackWindowURL) {\n\t\t\t$script = '';\n\t\t\tif ($node) {\n\t\t\t\tif ($bind) {\n\t\t\t\t\t$trigger = 'elf.trigger(\\''.$bind.'\\', data);';\n\t\t\t\t\t$triggerdone = 'elf.trigger(\\''.$bind.'done\\');';\n\t\t\t\t\t$triggerfail = 'elf.trigger(\\''.$bind.'fail\\', data);';\n\t\t\t\t} else {\n\t\t\t\t\t$trigger = $triggerdone = $triggerfail = '';\n\t\t\t\t}\n\t\t\t\t$script .= '\n\t\t\t\t\tvar w = window.opener || window.parent || window;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar elf = w.document.getElementById(\\''.$node.'\\').elfinder;\n\t\t\t\t\t\tif (elf) {\n\t\t\t\t\t\t\tvar data = '.$json.';\n\t\t\t\t\t\t\tif (data.error) {\n\t\t\t\t\t\t\t\t'.$triggerfail.'\n\t\t\t\t\t\t\t\telf.error(data.error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata.warning && elf.error(data.warning);\n\t\t\t\t\t\t\t\tdata.removed && data.removed.length && elf.remove(data);\n\t\t\t\t\t\t\t\tdata.added   && data.added.length   && elf.add(data);\n\t\t\t\t\t\t\t\tdata.changed && data.changed.length && elf.change(data);\n\t\t\t\t\t\t\t\t'.$trigger.'\n\t\t\t\t\t\t\t\t'.$triggerdone.'\n\t\t\t\t\t\t\t\tdata.sync && elf.sync();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// for CORS\n\t\t\t\t\t\tw.postMessage && w.postMessage(JSON.stringify({bind:\\''.$bind.'\\',data:'.$json.'}), \\'*\\');\n\t\t\t\t\t}';\n\t\t\t}\n\t\t\t$script .= 'window.close();';\n\t\t\t\n\t\t\t$out = '<!DOCTYPE html><html><head><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><script>'.$script.'</script></head><body><a href=\"#\" onlick=\"window.close();return false;\">Close this window</a></body></html>';\n\t\t\t\n\t\t\theader('Content-Type: text/html; charset=utf-8');\n\t\t\theader('Content-Length: '.strlen($out));\n\t\t\theader('Cache-Control: private');\n\t\t\theader('Pragma: no-cache');\n\t\t\t\n\t\t\techo $out;\n\t\t\t\n\t\t} else {\n\t\t\t$url = $this->callbackWindowURL;\n\t\t\t$url .= ((strpos($url, '?') === false)? '?' : '&')\n\t\t\t\t . '&node=' . rawurlencode($node)\n\t\t\t\t . (($json !== '{}')? ('&json=' . rawurlencode($json)) : '')\n\t\t\t\t . ($bind? ('&bind=' .  rawurlencode($bind)) : '')\n\t\t\t\t . '&done=1';\n\t\t\t\n\t\t\theader('Location: ' . $url);\n\t\t\t\n\t\t}\n\t\tthrow new elFinderAbortException();\n\t}\n\n\t/**\n\t * PHP error handler, catch error types only E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE\n\t * \n\t * @param int    $errno\n\t * @param string $errstr\n\t * @param string $errfile\n\t * @param int    $errline\n\t * @return void|boolean\n\t */\n\tpublic static function phpErrorHandler($errno, $errstr, $errfile, $errline) {\n\t\tstatic $base = null;\n\t\t\n\t\tif (is_null($base)) {\n\t\t\t$base = dirname(__FILE__) . DIRECTORY_SEPARATOR;\n\t\t}\n\t\t\n\t\tif (! (error_reporting() & $errno)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t$errfile = str_replace($base, '', $errfile);\n\t\t\n\t\t$proc = false;\n\t\tswitch ($errno) {\n\t\t\tcase E_WARNING:\n\t\t\tcase E_USER_WARNING:\n\t\t\t\telFinder::$phpErrors[] = \"WARNING: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase E_NOTICE:\n\t\t\tcase E_USER_NOTICE:\n\t\t\t\telFinder::$phpErrors[] = \"NOTICE: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase E_STRICT:\n\t\t\t\telFinder::$phpErrors[] = \"STRICT: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase E_RECOVERABLE_ERROR:\n\t\t\t\telFinder::$phpErrors[] = \"RECOVERABLE_ERROR: $errstr in $errfile line $errline.\";\n\t\t\t\t$proc = true;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (defined('E_DEPRECATED')) {\n\t\t\tswitch ($errno) {\n\t\t\t\tcase E_DEPRECATED:\n\t\t\t\tcase E_USER_DEPRECATED:\n\t\t\t\t\telFinder::$phpErrors[] = \"DEPRECATED: $errstr in $errfile line $errline.\";\n\t\t\t\t\t$proc = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $proc;\n\t}\n\n\t/***************************************************************************/\n\t/*                                   utils                                 */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Return root - file's owner\n\t *\n\t * @param  string  file hash\n\t * @return elFinderStorageDriver\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function volume($hash) {\n\t\tforeach ($this->volumes as $id => $v) {\n\t\t\tif (strpos(''.$hash, $id) === 0) {\n\t\t\t\treturn $this->volumes[$id];\n\t\t\t} \n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Return files info array \n\t *\n\t * @param  array  $data  one file info or files info\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function toArray($data) {\n\t\treturn isset($data['hash']) || !is_array($data) ? array($data) : $data;\n\t}\n\t\n\t/**\n\t * Return fils hashes list\n\t *\n\t * @param  array  $files  files info\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function hashes($files) {\n\t\t$ret = array();\n\t\tforeach ($files as $file) {\n\t\t\t$ret[] = $file['hash'];\n\t\t}\n\t\treturn $ret;\n\t}\n\t\n\t/**\n\t * Remove from files list hidden files and files with required mime types\n\t *\n\t * @param  array  $files  files info\n\t * @return array\n\t * @author Dmitry (dio) Levashov\n\t **/\n\tprotected function filter($files) {\n\t\t$exists = array();\n\t\tforeach ($files as $i => $file) {\n\t\t\tif (isset($exists[$file['hash']]) || !empty($file['hidden']) || !$this->default->mimeAccepted($file['mime'])) {\n\t\t\t\tunset($files[$i]);\n\t\t\t}\n\t\t\t$exists[$file['hash']] = true;\n\t\t}\n\t\treturn array_values($files);\n\t}\n\t\n\tprotected function utime() {\n\t\t$time = explode(\" \", microtime());\n\t\treturn (double)$time[1] + (double)$time[0];\n\t}\n\t\n\t/**\n\t * Return Network mount volume unique ID\n\t *\n\t * @param  array   $netVolumes  Saved netvolumes array\n\t * @param  string  $prefix      Id prefix\n\t * @return string|false\n\t * @author Naoki Sawada\n\t **/\n\tprotected function getNetVolumeUniqueId($netVolumes = null, $prefix = 'nm') {\n\t\t$id = false;\n\t\tif (is_null($netVolumes)) {\n\t\t\t$netVolumes = $this->getNetVolumes();\n\t\t}\n\t\t$ids = array();\n\t\tforeach($netVolumes as $vOps) {\n\t\t\tif (isset($vOps['id']) && strpos($vOps['id'], $prefix) === 0) {\n\t\t\t\t$ids[$vOps['id']] = true;\n\t\t\t}\n\t\t}\n\t\tif (! $ids) {\n\t\t\t$id = $prefix.'1';\n\t\t} else {\n\t\t\t$i = 0;\n\t\t\twhile(isset($ids[$prefix.++$i]) && $i < 10000);\n\t\t\t$id = $prefix.$i;\n\t\t\tif (isset($ids[$id])) {\n\t\t\t\t$id = false;\n\t\t\t}\n\t\t}\n\t\treturn $id;\n\t}\n\t\n\t/**\n\t * Is item locked?\n\t * \n\t * @param string $hash\n\t * @return boolean\n\t */\n\tprotected function itemLocked($hash) {\n\t\tif (! elFinder::$commonTempPath) {\n\t\t\treturn false;\n\t\t}\n\t\t$lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n\t\tif (file_exists($lock)) {\n\t\t\tif (filemtime($lock) + $this->itemLockExpire < time()) {\n\t\t\t\tunlink($lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Do lock target item\n\t * \n\t * @param array|string $hashes\n\t * @param boolean $autoUnlock\n\t * @return boolean\n\t */\n\tprotected function itemLock($hashes, $autoUnlock = true) {\n\t\tif (! elFinder::$commonTempPath) {\n\t\t\treturn false;\n\t\t}\n\t\tif (! is_array($hashes)) {\n\t\t\t$hashes = array($hashes);\n\t\t}\n\t\tforeach($hashes as $hash) {\n\t\t\t$lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n\t\t\tif ($this->itemLocked($hash)) {\n\t\t\t\t$cnt = file_get_contents($lock) + 1;\n\t\t\t} else {\n\t\t\t\t$cnt = 1;\n\t\t\t}\n\t\t\tif (file_put_contents($lock, $cnt, LOCK_EX)) {\n\t\t\t\tif ($autoUnlock) {\n\t\t\t\t\t$this->autoUnlocks[] = $hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Do unlock target item\n\t * \n\t * @param string $hash\n\t * @return boolean\n\t */\n\tprotected function itemUnlock($hash) {\n\t\tif (! $this->itemLocked($hash)) {\n\t\t\treturn true;\n\t\t}\n\t\t$lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n\t\t$cnt = file_get_contents($lock);\n\t\tif (--$cnt < 1) {\n\t\t\tunlink($lock);\n\t\t} else {\n\t\t\tfile_put_contents($lock, $cnt, LOCK_EX);\n\t\t}\n\t}\n\t\n\t/**\n\t * unlock locked items on command completion\n\t * \n\t * @return void\n\t */\n\tpublic function itemAutoUnlock() {\n\t\tif ($this->autoUnlocks) {\n\t\t\tforeach($this->autoUnlocks as $hash) {\n\t\t\t\t$this->itemUnlock($hash);\n\t\t\t}\n\t\t\t$this->autoUnlocks = array();\n\t\t}\n\t}\n\t\n\t/**\n\t * Ensure directories recursively\n\t *\n\t * @param  object  $volume  Volume object\n\t * @param  string  $target  Target hash\n\t * @param  string  $dirs    Array of directory tree to ensure\n\t * @param  string  $path    Relative path form target hash\n\t * @return array|false      array('stats' => array([stat of maked directory]), 'hashes' => array('[path]' => '[hash]'), 'makes' => array([New directory hashes]), 'error' => array([Error name]))\n\t * @author Naoki Sawada\n\t **/\n\tprotected function ensureDirsRecursively($volume, $target, $dirs, $path = '') {\n\t\t$res = array('stats' => array(), 'hashes' => array(), 'makes' => array(), 'error' => array());\n\t\tforeach($dirs as $name => $sub) {\n\t\t\t$name = (string)$name;\n\t\t\t$newDir = null;\n\t\t\tif ((($parent = $volume->realpath($target)) && ($dir = $volume->dir($volume->getHash($parent, $name)))) || ($newDir = $volume->mkdir($target, $name))) {\n\t\t\t\t$_path = $path . '/' . $name;\n\t\t\t\tif ($newDir) {\n\t\t\t\t\t$res['makes'][] = $newDir['hash'];\n\t\t\t\t\t$dir = $newDir;\n\t\t\t\t}\n\t\t\t\t$res['stats'][] = $dir;\n\t\t\t\t$res['hashes'][$_path] = $dir['hash'];\n\t\t\t\tif (count($sub)) {\n\t\t\t\t\t$res = array_merge_recursive($res, $this->ensureDirsRecursively($volume, $dir['hash'], $sub, $_path));\n\t\t\t\t\tif ($res['error']) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$res['error'][] = $name;\n\t\t\t}\n\t\t}\n\t\treturn $res;\n\t}\n\t\n\t/***************************************************************************/\n\t/*                           static  utils                                 */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Return full version of API that this connector supports all functions\n\t * \n\t * @return string\n\t */\n\tpublic static function getApiFullVersion() {\n\t\treturn (string)self::$ApiVersion . '.' . (string)self::$ApiRevision;\n\t}\n\t\n\t/**\n\t * Return Is Animation Gif\n\t * \n\t * @param  string $path server local path of target image\n\t * @return bool\n\t */\n\tpublic static function isAnimationGif($path) {\n\t\tlist($width, $height, $type, $attr) = getimagesize($path);\n\t\tswitch ($type) {\n\t\t\tcase IMAGETYPE_GIF:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\n\t\t$imgcnt = 0;\n\t\t$fp = fopen($path, 'rb');\n\t\tfread($fp, 4);\n\t\t$c = fread($fp,1);\n\t\tif (ord($c) != 0x39) {  // GIF89a\n\t\t\treturn false;\n\t\t}\n\t\n\t\twhile (!feof($fp)) {\n\t\t\tdo {\n\t\t\t\t$c = fread($fp, 1);\n\t\t\t} while(ord($c) != 0x21 && !feof($fp));\n\t\n\t\t\tif (feof($fp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\t$c2 = fread($fp,2);\n\t\t\tif (bin2hex($c2) == \"f904\") {\n\t\t\t\t$imgcnt++;\n\t\t\t\tif ($imgcnt === 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (feof($fp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\tif ($imgcnt > 1) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Return Is Animation Png\n\t *\n\t * @param  string $path server local path of target image\n\t * @return bool\n\t */\n\tpublic static function isAnimationPng($path) {\n\t\tlist($width, $height, $type, $attr) = getimagesize($path);\n\t\tswitch ($type) {\n\t\t\tcase IMAGETYPE_PNG:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\t$fp = fopen($path, 'rb');\n\t\t$img_bytes = fread($fp, 1024);\n\t\tfclose($fp);\n\t\tif ($img_bytes) {\n\t\t\tif (strpos(substr($img_bytes, 0, strpos($img_bytes, 'IDAT')), 'acTL') !== false) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return Is seekable stream resource\n\t * \n\t * @param resource $resource\n\t * @return bool\n\t */\n\tpublic static function isSeekableStream($resource) {\n\t\t$metadata = stream_get_meta_data($resource);\n\t\treturn $metadata['seekable'];\n\t}\n\n\t/**\n\t * Rewind stream resource\n\t * \n\t * @param resource $resource\n\t * @return void\n\t */\n\tpublic static function rewind($resource) {\n\t\tself::isSeekableStream($resource) && rewind($resource);\n\t}\n\n\t/**\n\t * serialize and base64_encode of session data (If needed)\n\t *\n\t * @deprecated\n\t * @param  mixed $var target variable\n\t * @author Naoki Sawada\n\t * @return mixed|string\n\t */\n\tpublic static function sessionDataEncode($var) {\n\t\tif (self::$base64encodeSessionData) {\n\t\t\t$var = base64_encode(serialize($var));\n\t\t}\n\t\treturn $var;\n\t}\n\n\t/**\n\t * base64_decode and unserialize of session data  (If needed)\n\t *\n\t * @deprecated\n\t * @param  mixed $var target variable\n\t * @param  bool $checkIs data type for check (array|string|object|int)\n\t * @author Naoki Sawada\n\t * @return bool|mixed\n\t */\n\tpublic static function sessionDataDecode(&$var, $checkIs = null) {\n\t\tif (self::$base64encodeSessionData) {\n\t\t\t$data = unserialize(base64_decode($var));\n\t\t} else {\n\t\t\t$data = $var;\n\t\t}\n\t\t$chk = true;\n\t\tif ($checkIs) {\n\t\t\tswitch ($checkIs) {\n\t\t\t\tcase 'array':\n\t\t\t\t\t$chk = is_array($data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'string':\n\t\t\t\t\t$chk = is_string($data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\t$chk = is_object($data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\t\t$chk = is_int($data);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!$chk) {\n\t\t\tunset($var);\n\t\t\treturn false;\n\t\t}\n\t\treturn $data;\n\t}\n\t\n\t/**\n\t * Call session_write_close() if session is restarted\n\t * \n\t * @deprecated\n\t * @return void\n\t */\n\tpublic static function sessionWrite() {\n\t\tif (session_id()) {\n\t\t\tsession_write_close();\n\t\t}\n\t}\n\n\t/**\n\t * Return elFinder static variable\n\t *\n\t * @param $key\n\t * @return mixed|null\n\t */\n\tpublic static function getStaticVar($key) {\n\t\treturn isset(elFinder::$$key)? elFinder::$$key : null;\n\t}\n\t\n\t/**\n\t * Extend PHP execution time limit and also check connection is aborted\n\t * \n\t * @param Int $time\n\t * @return void\n\t */\n\tpublic static function extendTimeLimit($time = null) {\n\t\tstatic $defLimit = null;\n\t\tif (! self::aborted()) {\n\t\t\tif (is_null($defLimit)) {\n\t\t\t\t$defLimit = ini_get('max_execution_time');\n\t\t\t}\n\t\t\tif ($defLimit != 0) {\n\t\t\t\t$time = is_null($time)? $defLimit : max($defLimit, $time);\n\t\t\t\tset_time_limit($time);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new elFinderAbortException();\n\t\t}\n\t}\n\t\n\t/**\n\t * Check connection is aborted\n\t * Script stop immediately if connection aborted\n\t *\n\t * @return void\n\t */\n\tpublic static function checkAborted() {\n\t\telFinder::extendTimeLimit();\n\t}\n\t\n\t/**\n\t * Return bytes from php.ini value\n\t * \n\t * @param string $iniName\n\t * @param string $val\n\t * @return number\n\t */\n\tpublic static function getIniBytes($iniName = '', $val = '') {\n\t\tif ($iniName !== '') {\n\t\t\t$val = ini_get($iniName);\n\t\t\tif ($val === false) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t$val = trim($val, \"bB \\t\\n\\r\\0\\x0B\");\n\t\t$last = strtolower($val[strlen($val) - 1]);\n\t\t$val = (int)$val;\n\t\tswitch($last) {\n\t\t\tcase 't':\n\t\t\t\t$val *= 1024;\n\t\t\tcase 'g':\n\t\t\t\t$val *= 1024;\n\t\t\tcase 'm':\n\t\t\t\t$val *= 1024;\n\t\t\tcase 'k':\n\t\t\t\t$val *= 1024;\n\t\t}\n\t\treturn $val;\n\t}\n\n\t/**\n\t * Get script url.\n\t * \n\t * @return string full URL\n\t * \n\t * @author Naoki Sawada\n\t */\n\tpublic static function getConnectorUrl() {\n\t\t$https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n\t\t$url = ($https ? 'https://' : 'http://')\n\t\t\t.$_SERVER['SERVER_NAME']                                              // host\n\t\t\t.(((! $https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n\t\t\t.$_SERVER['REQUEST_URI'];                                             // path & query\n\t\tlist($url) = explode('?', $url);\n\t\t\n\t\treturn $url;\n\t}\n\n\t/**\n\t * Get stream resource pointer by URL\n\t * \n\t * @param array  $data  array('target'=>'URL', 'headers' => array())\n\t * @param number $redirectLimit\n\t * @return resource|boolean\n\t * \n\t * @author Naoki Sawada\n\t */\n\tpublic static function getStreamByUrl($data, $redirectLimit = 5) {\n\t\tif (isset($data['target'])) {\n\t\t\t$data = array(\n\t\t\t\t'cnt' => 0,\n\t\t\t\t'url' => $data['target'],\n\t\t\t\t'headers' => isset($data['headers'])? $data['headers'] : array(),\n\t\t\t\t'cookies' => array(),\n\t\t\t);\n\t\t}\n\t\tif ($data['cnt'] > $redirectLimit) {\n\t\t\treturn false;\n\t\t}\n\t\t$dlurl = $data['url'];\n\t\t$data['url'] = '';\n\t\t$headers = $data['headers'];\n\t\n\t\tif ($dlurl) {\n\t\t\t$url = parse_url($dlurl);\n\t\t\t$ports = array(\n\t\t\t\t'http'  => '80',\n\t\t\t\t'ssl'   => '443',\n\t\t\t\t'ftp'   => '21'\n\t\t\t);\n\t\t\t$url['scheme'] = strtolower($url['scheme']);\n\t\t\tif ($url['scheme'] === 'https') {\n\t\t\t\t$url['scheme'] = 'ssl';\n\t\t\t}\n\t\t\tif (! isset($url['port']) && isset($ports[$url['scheme']])) {\n\t\t\t\t$url['port'] = $ports[$url['scheme']];\n\t\t\t}\n\t\t\tif (! isset($url['port'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$cookies = array();\n\t\t\tif ($data['cookies']) {\n\t\t\t\tforeach ($data['cookies'] as $d => $c) {\n\t\t\t\t\tif (strpos($url['host'], $d) !== false) {\n\t\t\t\t\t\t$cookies[] = $c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$query = isset($url['query']) ? '?'.$url['query'] : '';\n\t\t\t$stream = stream_socket_client($url['scheme'].'://'.$url['host'].':'.$url['port']);\n\t\t\tstream_set_timeout($stream, 300);\n\t\t\tfputs($stream, \"GET {$url['path']}{$query} HTTP/1.1\\r\\n\");\n\t\t\tfputs($stream, \"Host: {$url['host']}\\r\\n\");\n\t\t\tforeach($headers as $header) {\n\t\t\t\tfputs($stream, trim($header, \"\\r\\n\").\"\\r\\n\");\n\t\t\t}\n\t\t\tfputs($stream, \"Connection: Close\\r\\n\");\n\t\t\tif ($cookies) {\n\t\t\t\tfputs($stream, 'Cookie: '.implode('; ', $cookies).\"\\r\\n\");\n\t\t\t}\n\t\t\tfputs($stream, \"\\r\\n\");\n\t\t\twhile (($res = trim(fgets($stream))) !== '') {\n\t\t\t\t// find redirect\n\t\t\t\tif (preg_match('/^Location: (.+)$/', $res, $m)) {\n\t\t\t\t\t$data['url'] = $m[1];\n\t\t\t\t}\n\t\t\t\t// fetch cookie\n\t\t\t\tif (strpos($res, 'Set-Cookie:') === 0) {\n\t\t\t\t\t$domain = $url['host'];\n\t\t\t\t\tif (preg_match('/^Set-Cookie:(.+)(?:domain=\\s*([^ ;]+))?/i', $res, $c1)) {\n\t\t\t\t\t\tif (!empty($c1[2])) {\n\t\t\t\t\t\t\t$domain = trim($c1[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preg_match('/([^ ]+=[^;]+)/', $c1[1], $c2)) {\n\t\t\t\t\t\t\t$data['cookies'][$domain] = $c2[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($data['url']) {\n\t\t\t\t++$data['cnt'];\n\t\t\t\tfclose($stream);\n\n\t\t\t\treturn self::getStreamByUrl($data, $redirectLimit);\n\t\t\t}\n\n\t\t\treturn $stream;\n\t\t}\n\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Call curl_exec() with supported redirect on `safe_mode` or `open_basedir`\n\t *\n\t * @param resource    $curl\n\t * @param array       $options\n\t * @param array       $headers\n\t *\n\t * @throws \\Exception\n\t *\n\t * @return mixed\n\t * \n\t * @author Naoki Sawada\n\t */\n\tpublic static function curlExec($curl, $options = array(), $headers = array()) {\n\t\tif ($followLocation = (!ini_get('safe_mode') && !ini_get('open_basedir'))) {\n\t\t\tcurl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n\t\t}\n\t\t\n\t\tif ($options) {\n\t\t\tcurl_setopt_array($curl, $options);\n\t\t}\n\t\t\n\t\tif ($headers) {\n\t\t\tcurl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n\t\t}\n\t\t\n\t\t$result = curl_exec($curl);\n\t\t\n\t\tif (! $followLocation && $redirect = curl_getinfo($curl, CURLINFO_REDIRECT_URL)) {\n\t\t\tif ($stream = self::getStreamByUrl(array('target' => $redirect, 'headers' => $headers))) {\n\t\t\t\t$result = stream_get_contents($stream);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ($result === false) {\n\t\t\tif (curl_errno($curl)) {\n\t\t\t\tthrow new \\Exception('curl_exec() failed: '.curl_error($curl));\n\t\t\t} else {\n\t\t\t\tthrow new \\Exception('curl_exec(): empty response');\n\t\t\t}\n\t\t}\n\t\t\n\t\tcurl_close($curl);\n\t\t\n\t\treturn $result;\n\t}\n\t\n\t/**\n\t * Return bool that current request was aborted by client side\n\t * \n\t * @return boolean\n\t */\n\tpublic static function aborted() {\n\t\tif ($file = self::$abortCheckFile) {\n\t\t\t(version_compare(PHP_VERSION, '5.3.0') >= 0) ? clearstatcache(true, $file) : clearstatcache();\n\t\t\tif (! is_file($file)) {\n\t\t\t\t// GC (expire 12h)\n\t\t\t\tlist($ptn) = explode('elfreq', $file);\n\t\t\t\tself::GlobGC($ptn . 'elfreq*', 43200);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Return array [\"name without extention\", \"extention\"] by filename\n\t * \n\t * @param string $name\n\t * @return array\n\t */\n\tpublic static function splitFileExtention($name) {\n\t\tif (preg_match('/^(.+?)?\\.((?:tar\\.(?:gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(?:gz|bz2)|[a-z0-9]{1,4})$/i', $name, $m)) {\n\t\t\treturn array((string)$m[1], $m[2]);\n\t\t} else {\n\t\t\treturn array($name, '');\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets the memory size by imageinfo.\n\t *\n\t * @param      array    $imgInfo   array that result of getimagesize()\n\t *\n\t * @return     integer  The memory size by imageinfo.\n\t */\n\tpublic static function getMemorySizeByImageInfo($imgInfo) {\n\t\t$width = $imgInfo[0];\n\t\t$height = $imgInfo[1];\n\t\t$bits = isset($imgInfo['bits'])? $imgInfo['bits'] : 24;\n\t\t$channels = isset($imgInfo['channels'])? $imgInfo['channels'] : 3;\n\t\treturn round(($width * $height * $bits * $channels / 8 + Pow(2, 16)) * 1.65);\n\t}\n\n\t/**\n\t * Auto expand memory for GD processing\n\t *\n\t * @param      array  $imgInfos  The image infos\n\t */\n\tpublic static function expandMemoryForGD($imgInfos) {\n\t\tif (elFinder::$memoryLimitGD != 0 && $imgInfos && is_array($imgInfos)) {\n\t\t\tif (!is_array($imgInfos[0])) {\n\t\t\t\t$imgInfos = array($imgInfos);\n\t\t\t}\n\t\t\t$limit = self::getIniBytes('', elFinder::$memoryLimitGD);\n\t\t\t$memLimit = self::getIniBytes('memory_limit');\n\t\t\t$needs = 0;\n\t\t\tforeach($imgInfos as $info) {\n\t\t\t\t$needs += self::getMemorySizeByImageInfo($info);\n\t\t\t}\n\t\t\t$needs += memory_get_usage();\n\t\t\tif ($needs > $memLimit && ($limit == -1 || $limit > $needs)) {\n\t\t\t\tini_set('memory_limit', $needs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/***************************************************************************/\n\t/*                                 callbacks                               */\n\t/***************************************************************************/\n\t\n\t/**\n\t * Get command name of binded \"commandName.subName\"\n\t * \n\t * @param string $cmd\n\t * @return string\n\t */\n\tprotected static function getCmdOfBind($cmd) {\n\t\tlist($ret) = explode('.', $cmd);\n\t\treturn trim($ret);\n\t}\n\t\n\t/**\n\t * Add subName to commandName\n\t * \n\t * @param string $cmd\n\t * @param string $sub\n\t * @return string\n\t */\n\tprotected static function addSubToBindName($cmd, $sub) {\n\t\treturn $cmd . '.' . trim($sub);\n\t}\n\t\n\t/**\n\t * Remove a file if connection is disconnected\n\t * \n\t * @param string $file\n\t */\n\tpublic static function rmFileInDisconnected($file) {\n\t\t(connection_aborted() || connection_status() !== CONNECTION_NORMAL) && is_file($file) && unlink($file);\n\t}\n\t\n\t/**\n\t * Call back function on shutdown\n\t *  - delete files in $GLOBALS['elFinderTempFiles']\n\t * \n\t */\n\tpublic static function onShutdown() {\n\t\tself::$abortCheckFile = null;\n\t\tif (! empty($GLOBALS['elFinderTempFiles'])) {\n\t\t\tforeach(array_keys($GLOBALS['elFinderTempFiles']) as $f){\n\t\t\t\tis_file($f) && unlink($f);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Garbage collection with glob\n\t * \n\t * @param string $pattern\n\t * @param integer $time\n\t */\n\tpublic static function GlobGC($pattern, $time) {\n\t\t$now = time();\n\t\tforeach(glob($pattern) as $file) {\n\t\t\t(filemtime($file) < ($now - $time)) && unlink($file);\n\t\t}\n\t}\n\t\n} // END class\n\n/**\n * Custom exception class for aborting request\n *\n */\nclass elFinderAbortException extends Exception {}\n"], "filenames": ["php/elFinder.class.php"], "buggy_code_start_loc": [1625], "buggy_code_end_loc": [1630], "fixing_code_start_loc": [1626], "fixing_code_end_loc": [1634], "type": "CWE-22", "message": "Studio 42 elFinder before 2.1.36 has a directory traversal vulnerability in elFinder.class.php with the zipdl() function that can allow a remote attacker to download files accessible by the web server process and delete files owned by the account running the web server process.", "other": {"cve": {"id": "CVE-2018-9109", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-28T06:29:00.260", "lastModified": "2021-09-09T12:51:26.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Studio 42 elFinder before 2.1.36 has a directory traversal vulnerability in elFinder.class.php with the zipdl() function that can allow a remote attacker to download files accessible by the web server process and delete files owned by the account running the web server process."}, {"lang": "es", "value": "Studio 42 elFinder en versiones anteriores a la 2.1.36 tiene una vulnerabilidad de salto de directorio en elFinder.class.php con la funci\u00f3n zipdl() que puede permitir que un atacante remoto descargue archivos accesibles por el proceso del servidor web y elimine archivos propiedad de la cuenta que ejecuta el proceso del servidor web."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:std42:elfinder:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.36", "matchCriteriaId": "65A1D02D-0AE7-4075-9AD8-8F1FC630ACA9"}]}]}], "references": [{"url": "https://github.com/Studio-42/elFinder/commit/157f471d7e48f190f74e66eb5bc73360b5352fd3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Studio-42/elFinder/releases/tag/2.1.36", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Studio-42/elFinder/wiki/Advisory-about-vulnerability-of-CVE-2018-9109-and-CVE-2018-9110", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Studio-42/elFinder/commit/157f471d7e48f190f74e66eb5bc73360b5352fd3"}}