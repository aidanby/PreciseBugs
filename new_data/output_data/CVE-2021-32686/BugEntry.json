{"buggy_code": ["/* \n * Copyright (C) 2019-2019 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pj/ssl_sock.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#include \"ssl_sock_imp_common.h\"\n\n/* Workaround for ticket #985 and #1930 */\n#ifndef PJ_SSL_SOCK_DELAYED_CLOSE_TIMEOUT\n#   define PJ_SSL_SOCK_DELAYED_CLOSE_TIMEOUT\t500\n#endif\n\nenum { MAX_BIND_RETRY = 100 };\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\nstatic pj_bool_t asock_on_data_read (pj_activesock_t *asock,\n\t\t\t\t     void *data,\n\t\t\t\t     pj_size_t size,\n\t\t\t\t     pj_status_t status,\n\t\t\t\t     pj_size_t *remainder);\n\nstatic pj_bool_t asock_on_data_sent (pj_activesock_t *asock,\n\t\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t\t     pj_ssize_t sent);\n#endif\n\n#ifdef SSL_SOCK_IMP_USE_CIRC_BUF\n/*\n *******************************************************************\n * Circular buffer functions.\n *******************************************************************\n */\n\nstatic pj_status_t circ_init(pj_pool_factory *factory,\n                             circ_buf_t *cb, pj_size_t cap)\n{\n    cb->cap    = cap;\n    cb->readp  = 0;\n    cb->writep = 0;\n    cb->size   = 0;\n\n    /* Initial pool holding the buffer elements */\n    cb->pool = pj_pool_create(factory, \"tls-circ%p\", cap, cap, NULL);\n    if (!cb->pool)\n        return PJ_ENOMEM;\n\n    /* Allocate circular buffer */\n    cb->buf = pj_pool_alloc(cb->pool, cap);\n    if (!cb->buf) {\n        pj_pool_release(cb->pool);\n        return PJ_ENOMEM;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic void circ_deinit(circ_buf_t *cb)\n{\n    if (cb->pool) {\n        pj_pool_release(cb->pool);\n        cb->pool = NULL;\n    }\n}\n\nstatic pj_bool_t circ_empty(const circ_buf_t *cb)\n{\n    return cb->size == 0;\n}\n\nstatic pj_size_t circ_size(const circ_buf_t *cb)\n{\n    return cb->size;\n}\n\nstatic pj_size_t circ_avail(const circ_buf_t *cb)\n{\n    return cb->cap - cb->size;\n}\n\nstatic void circ_read(circ_buf_t *cb, pj_uint8_t *dst, pj_size_t len)\n{\n    pj_size_t size_after = cb->cap - cb->readp;\n    pj_size_t tbc = PJ_MIN(size_after, len);\n    pj_size_t rem = len - tbc;\n\n    pj_memcpy(dst, cb->buf + cb->readp, tbc);\n    pj_memcpy(dst + tbc, cb->buf, rem);\n\n    cb->readp += len;\n    cb->readp &= (cb->cap - 1);\n\n    cb->size -= len;\n}\n\nstatic pj_status_t circ_write(circ_buf_t *cb,\n                              const pj_uint8_t *src, pj_size_t len)\n{\n    /* Overflow condition: resize */\n    if (len > circ_avail(cb)) {\n        /* Minimum required capacity */\n        pj_size_t min_cap = len + cb->size;\n\n        /* Next 32-bit power of two */\n        min_cap--;\n        min_cap |= min_cap >> 1;\n        min_cap |= min_cap >> 2;\n        min_cap |= min_cap >> 4;\n        min_cap |= min_cap >> 8;\n        min_cap |= min_cap >> 16;\n        min_cap++;\n\n        /* Create a new pool to hold a bigger buffer, using the same factory */\n        pj_pool_t *pool = pj_pool_create(cb->pool->factory, \"tls-circ%p\",\n                                         min_cap, min_cap, NULL);\n        if (!pool)\n            return PJ_ENOMEM;\n\n        /* Allocate our new buffer */\n        pj_uint8_t *buf = pj_pool_alloc(pool, min_cap);\n        if (!buf) {\n            pj_pool_release(pool);\n            return PJ_ENOMEM;\n        }\n\n        /* Save old size, which we shall restore after the next read */\n        pj_size_t old_size = cb->size;\n\n        /* Copy old data into beginning of new buffer */\n        circ_read(cb, buf, cb->size);\n\n        /* Restore old size now */\n        cb->size = old_size;\n\n        /* Release the previous pool */\n        pj_pool_release(cb->pool);\n\n        /* Update circular buffer members */\n        cb->pool = pool;\n        cb->buf = buf;\n        cb->readp = 0;\n        cb->writep = cb->size;\n        cb->cap = min_cap;\n    }\n\n    pj_size_t size_after = cb->cap - cb->writep;\n    pj_size_t tbc = PJ_MIN(size_after, len);\n    pj_size_t rem = len - tbc;\n\n    pj_memcpy(cb->buf + cb->writep, src, tbc);\n    pj_memcpy(cb->buf, src + tbc, rem);\n\n    cb->writep += len;\n    cb->writep &= (cb->cap - 1);\n\n    cb->size += len;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n/*\n *******************************************************************\n * Helper functions.\n *******************************************************************\n */\n\n/* Check IP address version. */\nstatic int get_ip_addr_ver(const pj_str_t *host)\n{\n    pj_in_addr dummy;\n    pj_in6_addr dummy6;\n\n    /* First check if this is an IPv4 address */\n    if (pj_inet_pton(pj_AF_INET(), host, &dummy) == PJ_SUCCESS)\n\treturn 4;\n\n    /* Then check if this is an IPv6 address */\n    if (pj_inet_pton(pj_AF_INET6(), host, &dummy6) == PJ_SUCCESS)\n\treturn 6;\n\n    /* Not an IP address */\n    return 0;\n}\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n/* Close sockets */\nstatic void ssl_close_sockets(pj_ssl_sock_t *ssock)\n{\n    pj_activesock_t *asock;\n    pj_sock_t sock;\n\n    /* This can happen when pj_ssl_sock_create() fails. */\n    if (!ssock->write_mutex)\n    \treturn;\n\n    pj_lock_acquire(ssock->write_mutex);\n    asock = ssock->asock;\n    if (asock) {\n        // Don't set ssock->asock to NULL, as it may trigger assertion in\n        // send operation. This should be safe as active socket will simply\n        // return PJ_EINVALIDOP on any operation if it is already closed.\n        //ssock->asock = NULL;\n        ssock->sock = PJ_INVALID_SOCKET;\n    }\n    sock = ssock->sock;\n    if (sock != PJ_INVALID_SOCKET)\n        ssock->sock = PJ_INVALID_SOCKET;\n    pj_lock_release(ssock->write_mutex);\n\n    if (asock)\n        pj_activesock_close(asock);\n\n    if (sock != PJ_INVALID_SOCKET)\n        pj_sock_close(sock);\n}\n#endif\n\n/* When handshake completed:\n * - notify application\n * - if handshake failed, reset SSL state\n * - return PJ_FALSE when SSL socket instance is destroyed by application.\n */\nstatic pj_bool_t on_handshake_complete(pj_ssl_sock_t *ssock, \n\t\t\t\t       pj_status_t status)\n{\n    /* Cancel handshake timer */\n    if (ssock->timer.id == TIMER_HANDSHAKE_TIMEOUT) {\n\tpj_timer_heap_cancel(ssock->param.timer_heap, &ssock->timer);\n\tssock->timer.id = TIMER_NONE;\n    }\n\n    /* Update certificates info on successful handshake */\n    if (status == PJ_SUCCESS)\n\tssl_update_certs_info(ssock);\n\n    /* Accepting */\n    if (ssock->is_server) {\n\tif (status != PJ_SUCCESS) {\n\t    /* Handshake failed in accepting, destroy our self silently. */\n\n\t    char buf[PJ_INET6_ADDRSTRLEN+10];\n\n\t    PJ_PERROR(3,(ssock->pool->obj_name, status,\n\t\t\t \"Handshake failed in accepting %s\",\n\t\t\t pj_sockaddr_print(&ssock->rem_addr, buf,\n\t\t\t\t\t   sizeof(buf), 3)));\n\n\t    if (ssock->param.cb.on_accept_complete2) {\n\t\t(*ssock->param.cb.on_accept_complete2) \n\t\t      (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr, \n\t\t      pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr), \n\t\t      status);\n\t    }\n\n\t    /* Originally, this is a workaround for ticket #985. However,\n\t     * a race condition may occur in multiple worker threads\n\t     * environment when we are destroying SSL objects while other\n\t     * threads are still accessing them.\n\t     * Please see ticket #1930 for more info.\n\t     */\n#if 1 //(defined(PJ_WIN32) && PJ_WIN32!=0)||(defined(PJ_WIN64) && PJ_WIN64!=0)\n\t    if (ssock->param.timer_heap) {\n\t\tpj_time_val interval = {0, PJ_SSL_SOCK_DELAYED_CLOSE_TIMEOUT};\n\t\tpj_status_t status1;\n\n\t\tssock->ssl_state = SSL_STATE_NULL;\n\t\tssl_close_sockets(ssock);\n\n\t\tif (ssock->timer.id != TIMER_NONE) {\n\t\t    pj_timer_heap_cancel(ssock->param.timer_heap,\n\t\t\t\t\t &ssock->timer);\n\t\t}\n\t\tpj_time_val_normalize(&interval);\n\t\tstatus1 = pj_timer_heap_schedule_w_grp_lock(\n\t\t\t\t\t\t ssock->param.timer_heap, \n\t\t\t\t\t\t &ssock->timer,\n\t\t\t\t\t\t &interval,\n\t\t\t\t\t\t TIMER_CLOSE,\n\t\t\t\t\t\t ssock->param.grp_lock);\n\t\tif (status1 != PJ_SUCCESS) {\n\t    \t    PJ_PERROR(3,(ssock->pool->obj_name, status,\n\t\t\t\t \"Failed to schedule a delayed close. \"\n\t\t\t\t \"Race condition may occur.\"));\n\t\t    ssock->timer.id = TIMER_NONE;\n\t\t    pj_ssl_sock_close(ssock);\n\t\t}\n\t    } else {\n\t\tpj_ssl_sock_close(ssock);\n\t    }\n#else\n\t    {\n\t\tpj_ssl_sock_close(ssock);\n\t    }\n#endif\n\n\t    return PJ_FALSE;\n\t}\n\t/* Notify application the newly accepted SSL socket */\n\tif (ssock->param.cb.on_accept_complete2) {\n\t    pj_bool_t ret;\n\t    ret = (*ssock->param.cb.on_accept_complete2) \n\t\t    (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr, \n\t\t    pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr), \n\t\t    status);\n\t    if (ret == PJ_FALSE)\n\t\treturn PJ_FALSE;\t\n\t} else if (ssock->param.cb.on_accept_complete) {\n\t    pj_bool_t ret;\n\t    ret = (*ssock->param.cb.on_accept_complete)\n\t\t      (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,\n\t\t       pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr));\n\t    if (ret == PJ_FALSE)\n\t\treturn PJ_FALSE;\n\t}\n    }\n\n    /* Connecting */\n    else {\n\t/* On failure, reset SSL socket state first, as app may try to \n\t * reconnect in the callback.\n\t */\n\tif (status != PJ_SUCCESS) {\n\t    /* Server disconnected us, possibly due to SSL nego failure */\n\t    ssl_reset_sock_state(ssock);\n\t}\n\tif (ssock->param.cb.on_connect_complete) {\n\t    pj_bool_t ret;\n\t    ret = (*ssock->param.cb.on_connect_complete)(ssock, status);\n\t    if (ret == PJ_FALSE)\n\t\treturn PJ_FALSE;\n\t}\n    }\n\n    return PJ_TRUE;\n}\n\nstatic write_data_t* alloc_send_data(pj_ssl_sock_t *ssock, pj_size_t len)\n{\n    send_buf_t *send_buf = &ssock->send_buf;\n    pj_size_t avail_len, skipped_len = 0;\n    char *reg1, *reg2;\n    pj_size_t reg1_len, reg2_len;\n    write_data_t *p;\n\n    /* Check buffer availability */\n    avail_len = send_buf->max_len - send_buf->len;\n    if (avail_len < len)\n\treturn NULL;\n\n    /* If buffer empty, reset start pointer and return it */\n    if (send_buf->len == 0) {\n\tsend_buf->start = send_buf->buf;\n\tsend_buf->len   = len;\n\tp = (write_data_t*)send_buf->start;\n\tgoto init_send_data;\n    }\n\n    /* Free space may be wrapped/splitted into two regions, so let's\n     * analyze them if any region can hold the write data.\n     */\n    reg1 = send_buf->start + send_buf->len;\n    if (reg1 >= send_buf->buf + send_buf->max_len)\n\treg1 -= send_buf->max_len;\n    reg1_len = send_buf->max_len - send_buf->len;\n    if (reg1 + reg1_len > send_buf->buf + send_buf->max_len) {\n\treg1_len = send_buf->buf + send_buf->max_len - reg1;\n\treg2 = send_buf->buf;\n\treg2_len = send_buf->start - send_buf->buf;\n    } else {\n\treg2 = NULL;\n\treg2_len = 0;\n    }\n\n    /* More buffer availability check, note that the write data must be in\n     * a contigue buffer.\n     */\n    avail_len = PJ_MAX(reg1_len, reg2_len);\n    if (avail_len < len)\n\treturn NULL;\n\n    /* Get the data slot */\n    if (reg1_len >= len) {\n\tp = (write_data_t*)reg1;\n    } else {\n\tp = (write_data_t*)reg2;\n\tskipped_len = reg1_len;\n    }\n\n    /* Update buffer length */\n    send_buf->len += len + skipped_len;\n\ninit_send_data:\n    /* Init the new send data */\n    pj_bzero(p, sizeof(*p));\n    pj_list_init(p);\n    pj_list_push_back(&ssock->send_pending, p);\n\n    return p;\n}\n\nstatic void free_send_data(pj_ssl_sock_t *ssock, write_data_t *wdata)\n{\n    send_buf_t *buf = &ssock->send_buf;\n    write_data_t *spl = &ssock->send_pending;\n\n    pj_assert(!pj_list_empty(&ssock->send_pending));\n    \n    /* Free slot from the buffer */\n    if (spl->next == wdata && spl->prev == wdata) {\n\t/* This is the only data, reset the buffer */\n\tbuf->start = buf->buf;\n\tbuf->len = 0;\n    } else if (spl->next == wdata) {\n\t/* This is the first data, shift start pointer of the buffer and\n\t * adjust the buffer length.\n\t */\n\tbuf->start = (char*)wdata->next;\n\tif (wdata->next > wdata) {\n\t    buf->len -= ((char*)wdata->next - buf->start);\n\t} else {\n\t    /* Overlapped */\n\t    pj_size_t right_len, left_len;\n\t    right_len = buf->buf + buf->max_len - (char*)wdata;\n\t    left_len  = (char*)wdata->next - buf->buf;\n\t    buf->len -= (right_len + left_len);\n\t}\n    } else if (spl->prev == wdata) {\n\t/* This is the last data, just adjust the buffer length */\n\tif (wdata->prev < wdata) {\n\t    pj_size_t jump_len;\n\t    jump_len = (char*)wdata -\n\t\t       ((char*)wdata->prev + wdata->prev->record_len);\n\t    buf->len -= (wdata->record_len + jump_len);\n\t} else {\n\t    /* Overlapped */\n\t    pj_size_t right_len, left_len;\n\t    right_len = buf->buf + buf->max_len -\n\t\t\t((char*)wdata->prev + wdata->prev->record_len);\n\t    left_len  = (char*)wdata + wdata->record_len - buf->buf;\n\t    buf->len -= (right_len + left_len);\n\t}\n    }\n    /* For data in the middle buffer, just do nothing on the buffer. The slot\n     * will be freed later when freeing the first/last data.\n     */\n    \n    /* Remove the data from send pending list */\n    pj_list_erase(wdata);\n}\n\n/* Flush write circular buffer to network socket. */\nstatic pj_status_t flush_circ_buf_output(pj_ssl_sock_t *ssock,\n                                         pj_ioqueue_op_key_t *send_key,\n                                         pj_size_t orig_len, unsigned flags)\n{\n    pj_ssize_t len;\n    write_data_t *wdata;\n    pj_size_t needed_len;\n    pj_status_t status;\n\n    pj_lock_acquire(ssock->write_mutex);\n\n    /* Check if there is data in the circular buffer, flush it if any */\n    if (io_empty(ssock, &ssock->circ_buf_output)) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_SUCCESS;\n    }\n\n    /* Get data and its length */\n    len = io_size(ssock, &ssock->circ_buf_output);\n    if (len == 0) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_SUCCESS;\n    }\n\n    /* Calculate buffer size needed, and align it to 8 */\n    needed_len = len + sizeof(write_data_t);\n    needed_len = ((needed_len + 7) >> 3) << 3;\n\n    /* Allocate buffer for send data */\n    wdata = alloc_send_data(ssock, needed_len);\n    if (wdata == NULL) {\n\t/* Oops, the send buffer is full, let's just\n\t * queue it for sending and return PJ_EPENDING.\n\t */\n\tssock->send_buf_pending.data_len = needed_len;\n\tssock->send_buf_pending.app_key = send_key;\n\tssock->send_buf_pending.flags = flags;\n\tssock->send_buf_pending.plain_data_len = orig_len;\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_EPENDING;\n    }\n\n    /* Copy the data and set its properties into the send data */\n    pj_ioqueue_op_key_init(&wdata->key, sizeof(pj_ioqueue_op_key_t));\n    wdata->key.user_data = wdata;\n    wdata->app_key = send_key;\n    wdata->record_len = needed_len;\n    wdata->data_len = len;\n    wdata->plain_data_len = orig_len;\n    wdata->flags = flags;\n    io_read(ssock, &ssock->circ_buf_output, (pj_uint8_t *)&wdata->data, len);\n\n    /* Ticket #1573: Don't hold mutex while calling PJLIB socket send(). */\n    pj_lock_release(ssock->write_mutex);\n\n    /* Send it */\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_send(ssock, &wdata->key, wdata->data.content, &len,\n\t\t\t  flags);\n#else\n    if (ssock->param.sock_type == pj_SOCK_STREAM()) {\n\tstatus = pj_activesock_send(ssock->asock, &wdata->key, \n\t\t\t\t    wdata->data.content, &len,\n\t\t\t\t    flags);\n    } else {\n\tstatus = pj_activesock_sendto(ssock->asock, &wdata->key, \n\t\t\t\t      wdata->data.content, &len,\n\t\t\t\t      flags,\n\t\t\t\t      (pj_sockaddr_t*)&ssock->rem_addr,\n\t\t\t\t      ssock->addr_len);\n    }\n#endif\n\n    if (status != PJ_EPENDING) {\n\t/* When the sending is not pending, remove the wdata from send\n\t * pending list.\n\t */\n\tpj_lock_acquire(ssock->write_mutex);\n\tfree_send_data(ssock, wdata);\n\tpj_lock_release(ssock->write_mutex);\n    }\n\n    return status;\n}\n\n#if 0\n/* Just for testing send buffer alloc/free */\n#include <pj/rand.h>\npj_status_t pj_ssl_sock_ossl_test_send_buf(pj_pool_t *pool)\n{\n    enum { MAX_CHUNK_NUM = 20 };\n    unsigned chunk_size, chunk_cnt, i;\n    write_data_t *wdata[MAX_CHUNK_NUM] = {0};\n    pj_time_val now;\n    pj_ssl_sock_t *ssock = NULL;\n    pj_ssl_sock_param param;\n    pj_status_t status;\n\n    pj_gettimeofday(&now);\n    pj_srand((unsigned)now.sec);\n\n    pj_ssl_sock_param_default(&param);\n    status = pj_ssl_sock_create(pool, &param, &ssock);\n    if (status != PJ_SUCCESS) {\n\treturn status;\n    }\n\n    if (ssock->send_buf.max_len == 0) {\n\tssock->send_buf.buf = (char*)\n\t\t\t      pj_pool_alloc(ssock->pool, \n\t\t\t\t\t    ssock->param.send_buffer_size);\n\tssock->send_buf.max_len = ssock->param.send_buffer_size;\n\tssock->send_buf.start = ssock->send_buf.buf;\n\tssock->send_buf.len = 0;\n    }\n\n    chunk_size = ssock->param.send_buffer_size / MAX_CHUNK_NUM / 2;\n    chunk_cnt = 0;\n    for (i = 0; i < MAX_CHUNK_NUM; i++) {\n\twdata[i] = alloc_send_data(ssock, pj_rand() % chunk_size + 321);\n\tif (wdata[i])\n\t    chunk_cnt++;\n\telse\n\t    break;\n    }\n\n    while (chunk_cnt) {\n\ti = pj_rand() % MAX_CHUNK_NUM;\n\tif (wdata[i]) {\n\t    free_send_data(ssock, wdata[i]);\n\t    wdata[i] = NULL;\n\t    chunk_cnt--;\n\t}\n    }\n\n    if (ssock->send_buf.len != 0)\n\tstatus = PJ_EBUG;\n\n    pj_ssl_sock_close(ssock);\n    return status;\n}\n#endif\n\nstatic void on_timer(pj_timer_heap_t *th, struct pj_timer_entry *te)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)te->user_data;\n    int timer_id = te->id;\n\n    te->id = TIMER_NONE;\n\n    PJ_UNUSED_ARG(th);\n\n    switch (timer_id) {\n    case TIMER_HANDSHAKE_TIMEOUT:\n\tPJ_LOG(1,(ssock->pool->obj_name, \"SSL timeout after %d.%ds\",\n\t\t  ssock->param.timeout.sec, ssock->param.timeout.msec));\n\n\ton_handshake_complete(ssock, PJ_ETIMEDOUT);\n\tbreak;\n    case TIMER_CLOSE:\n\tpj_ssl_sock_close(ssock);\n\tbreak;\n    default:\n\tpj_assert(!\"Unknown timer\");\n\tbreak;\n    }\n}\n\nstatic void ssl_on_destroy(void *arg)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)arg;\n\n    ssl_destroy(ssock);\n\n    if (ssock->circ_buf_input_mutex) {\n        pj_lock_destroy(ssock->circ_buf_input_mutex);\n\tssock->circ_buf_input_mutex = NULL;\n    }\n\n    if (ssock->circ_buf_output_mutex) {\n        pj_lock_destroy(ssock->circ_buf_output_mutex);\n\tssock->circ_buf_output_mutex = NULL;\n\tssock->write_mutex = NULL;\n    }\n\n    /* Secure release pool, i.e: all memory blocks will be zeroed first */\n    pj_pool_secure_release(&ssock->info_pool);\n    pj_pool_secure_release(&ssock->pool);\n}\n\n\n/*\n *******************************************************************\n * Network callbacks.\n *******************************************************************\n */\n\n/*\n * Get the offset of pointer to read-buffer of SSL socket from read-buffer\n * of active socket. Note that both SSL socket and active socket employ \n * different but correlated read-buffers (as much as async_cnt for each),\n * and to make it easier/faster to find corresponding SSL socket's read-buffer\n * from known active socket's read-buffer, the pointer of corresponding \n * SSL socket's read-buffer is stored right after the end of active socket's\n * read-buffer.\n */\n#define OFFSET_OF_READ_DATA_PTR(ssock, asock_rbuf) \\\n\t\t\t\t\t(read_data_t**) \\\n\t\t\t\t\t((pj_int8_t*)(asock_rbuf) + \\\n\t\t\t\t\tssock->param.read_buffer_size)\n\nstatic pj_bool_t ssock_on_data_read (pj_ssl_sock_t *ssock,\n\t\t\t\t     void *data,\n\t\t\t\t     pj_size_t size,\n\t\t\t\t     pj_status_t status,\n\t\t\t\t     pj_size_t *remainder)\n{\n    if (status != PJ_SUCCESS)\n    \tgoto on_error;\n\n    if (data && size > 0) {\n    \tpj_status_t status_;\n\n\t/* Consume the whole data */\n        if (ssock->circ_buf_input_mutex)\n\t    pj_lock_acquire(ssock->circ_buf_input_mutex);\n        status_ = io_write(ssock,&ssock->circ_buf_input, data, size);\n        if (ssock->circ_buf_input_mutex)\n            pj_lock_release(ssock->circ_buf_input_mutex);\n        if (status_ != PJ_SUCCESS) {\n            status = status_;\n\t    goto on_error;\n\t}\n    }\n\n    /* Check if SSL handshake hasn't finished yet */\n    if (ssock->ssl_state == SSL_STATE_HANDSHAKING) {\n\tpj_bool_t ret = PJ_TRUE;\n\n\tif (status == PJ_SUCCESS)\n\t    status = ssl_do_handshake(ssock);\n\n\t/* Not pending is either success or failed */\n\tif (status != PJ_EPENDING)\n\t    ret = on_handshake_complete(ssock, status);\n\n\treturn ret;\n    }\n\n    /* See if there is any decrypted data for the application */\n    if (ssock->read_started) {\n\tdo {\n\t    read_data_t *buf = *(OFFSET_OF_READ_DATA_PTR(ssock, data));\n\t    void *data_ = (pj_int8_t*)buf->data + buf->len;\n\t    int size_ = (int)(ssock->read_size - buf->len);\n\t    pj_status_t status_;\n\n\t    status_ = ssl_read(ssock, data_, &size_);\n\n\t    if (size_ > 0 || status != PJ_SUCCESS) {\n\t\tif (ssock->param.cb.on_data_read) {\n\t\t    pj_bool_t ret;\n\t\t    pj_size_t remainder_ = 0;\n\n\t\t    if (size_ > 0)\n\t\t\tbuf->len += size_;\n    \t\t\n                    if (status != PJ_SUCCESS) {\n                        ssock->ssl_state = SSL_STATE_ERROR;\n                    }\n\n\t\t    ret = (*ssock->param.cb.on_data_read)(ssock, buf->data,\n\t\t\t\t\t\t\t  buf->len, status,\n\t\t\t\t\t\t\t  &remainder_);\n\t\t    if (!ret) {\n\t\t\t/* We've been destroyed */\n\t\t\treturn PJ_FALSE;\n\t\t    }\n\n\t\t    /* Application may have left some data to be consumed \n\t\t     * later.\n\t\t     */\n\t\t    buf->len = remainder_;\n\t\t}\n\n\t\t/* Active socket signalled connection closed/error, this has\n\t\t * been signalled to the application along with any remaining\n\t\t * buffer. So, let's just reset SSL socket now.\n\t\t */\n\t\tif (status != PJ_SUCCESS) {\n\t\t    ssl_reset_sock_state(ssock);\n\t\t    return PJ_FALSE;\n\t\t}\n\n\t    } else if (status_ == PJ_SUCCESS) {\n\t    \tbreak;\n\t    } else if (status_ == PJ_EEOF) {\n\t\tstatus = ssl_do_handshake(ssock);\n\t\tif (status == PJ_SUCCESS) {\n\t\t    /* Renegotiation completed */\n\n\t\t    /* Update certificates */\n\t\t    ssl_update_certs_info(ssock);\n\n\t\t    // Ticket #1573: Don't hold mutex while calling\n\t\t    //               PJLIB socket send(). \n\t\t    //pj_lock_acquire(ssock->write_mutex);\n\t\t    status = flush_delayed_send(ssock);\n\t\t    //pj_lock_release(ssock->write_mutex);\n\n\t\t    /* If flushing is ongoing, treat it as success */\n\t\t    if (status == PJ_EBUSY)\n\t\t\tstatus = PJ_SUCCESS;\n\n\t\t    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\t\t\tPJ_PERROR(1,(ssock->pool->obj_name, status, \n\t\t\t\t     \"Failed to flush delayed send\"));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t} else if (status != PJ_EPENDING) {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, status, \n\t\t\t         \"Renegotiation failed\"));\n\t\t    goto on_error;\n\t\t}\n\n\t\tbreak;\n\t    } else {\n\t    \t/* Error */\n\t    \tstatus = status_;\n\t    \tgoto on_error;\n\t    }\n\n\t} while (1);\n    }\n\n    return PJ_TRUE;\n\non_error:\n    if (ssock->ssl_state == SSL_STATE_HANDSHAKING)\n\treturn on_handshake_complete(ssock, status);\n\n    if (ssock->read_started && ssock->param.cb.on_data_read) {\n\tpj_bool_t ret;\n\tret = (*ssock->param.cb.on_data_read)(ssock, NULL, 0, status,\n\t\t\t\t\t      remainder);\n\tif (!ret) {\n\t    /* We've been destroyed */\n\t    return PJ_FALSE;\n\t}\n    }\n\n    ssl_reset_sock_state(ssock);\n    return PJ_FALSE;\n}\n\nstatic pj_bool_t ssock_on_data_sent (pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t\t     pj_ssize_t sent)\n{\n    write_data_t *wdata = (write_data_t*)send_key->user_data;\n    pj_ioqueue_op_key_t *app_key = wdata->app_key;\n    pj_ssize_t sent_len;\n\n    sent_len = (sent > 0)? wdata->plain_data_len : sent;\n    \n    /* Update write buffer state */\n    pj_lock_acquire(ssock->write_mutex);\n    free_send_data(ssock, wdata);\n    pj_lock_release(ssock->write_mutex);\n    wdata = NULL;\n\n    if (ssock->ssl_state == SSL_STATE_HANDSHAKING) {\n\t/* Initial handshaking */\n\tpj_status_t status;\n\t\n\tstatus = ssl_do_handshake(ssock);\n\t/* Not pending is either success or failed */\n\tif (status != PJ_EPENDING)\n\t    return on_handshake_complete(ssock, status);\n\n    } else if (send_key != &ssock->handshake_op_key) {\n\t/* Some data has been sent, notify application */\n\tif (ssock->param.cb.on_data_sent) {\n\t    pj_bool_t ret;\n\t    ret = (*ssock->param.cb.on_data_sent)(ssock, app_key, \n\t\t\t\t\t\t  sent_len);\n\t    if (!ret) {\n\t\t/* We've been destroyed */\n\t\treturn PJ_FALSE;\n\t    }\n\t}\n    } else {\n\t/* SSL re-negotiation is on-progress, just do nothing */\n    }\n\n    /* Send buffer has been updated, let's try to send any pending data */\n    if (ssock->send_buf_pending.data_len) {\n\tpj_status_t status;\n\tstatus = flush_circ_buf_output(ssock, ssock->send_buf_pending.app_key,\n\t\t\t\t ssock->send_buf_pending.plain_data_len,\n\t\t\t\t ssock->send_buf_pending.flags);\n\tif (status == PJ_SUCCESS || status == PJ_EPENDING) {\n\t    ssock->send_buf_pending.data_len = 0;\n\t}\n    }\n\n    return PJ_TRUE;\n}\n\nstatic pj_status_t get_localaddr(pj_ssl_sock_t *ssock,\n\t\t\t\t pj_sockaddr_t *addr,\n\t\t\t\t int *namelen)\n{\n    PJ_UNUSED_ARG(addr);\n    PJ_UNUSED_ARG(namelen);\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    return network_get_localaddr(ssock, &ssock->local_addr, \n\t\t\t\t &ssock->addr_len);\n#else\n    return pj_sock_getsockname(ssock->sock, &ssock->local_addr, \n\t\t\t       &ssock->addr_len);\n#endif\n}\n\n\nstatic pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n\t\t\t\t\t   pj_sock_t newsock,\n\t\t\t\t\t   void *newconn,\n\t\t\t\t\t   const pj_sockaddr_t *src_addr,\n\t\t\t\t\t   int src_addr_len,\n\t\t\t\t\t   pj_status_t accept_status)\n{\n    pj_ssl_sock_t *ssock;\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    pj_activesock_cb asock_cb;\n#endif\n    pj_activesock_cfg asock_cfg;\n    unsigned i;\n    pj_status_t status;\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    PJ_UNUSED_ARG(newconn);\n#endif\n\n    if (accept_status != PJ_SUCCESS) {\n\tif (ssock_parent->param.cb.on_accept_complete2) {\n\t    (*ssock_parent->param.cb.on_accept_complete2)(ssock_parent, NULL,\n\t\t\t\t\t\t    \t  src_addr,\n\t\t\t\t\t\t    \t  src_addr_len,\n\t\t\t\t\t\t    \t  accept_status);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Create new SSL socket instance */\n    status = pj_ssl_sock_create(ssock_parent->pool,\n\t\t\t\t&ssock_parent->newsock_param, &ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Update new SSL socket attributes */\n    ssock->sock = newsock;\n    ssock->parent = ssock_parent;\n    ssock->is_server = PJ_TRUE;\n    if (ssock_parent->cert) {\n\tstatus = pj_ssl_sock_set_certificate(ssock, ssock->pool, \n\t\t\t\t\t     ssock_parent->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n    }\n\n    /* Set local address */\n    ssock->addr_len = src_addr_len;\n    pj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);\n\n    /* Set remote address */\n    pj_sockaddr_cp(&ssock->rem_addr, src_addr);\n\n    /* Create SSL context */\n    status = ssl_create(ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare read buffer */\n    ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(void*));\n    if (!ssock->asock_rbuf)\n        return PJ_ENOMEM;\n\n    for (i = 0; i<ssock->param.async_cnt; ++i) {\n\tssock->asock_rbuf[i] = (void*) pj_pool_alloc(\n\t\t\t\t\t    ssock->pool, \n\t\t\t\t\t    ssock->param.read_buffer_size + \n\t\t\t\t\t    sizeof(read_data_t*));\n        if (!ssock->asock_rbuf[i])\n            return PJ_ENOMEM;\n    }\n\n    /* If listener socket has group lock, automatically create group lock\n     * for the new socket.\n     */\n    if (ssock_parent->param.grp_lock) {\n\tpj_grp_lock_t *glock;\n\n\tstatus = pj_grp_lock_create(ssock->pool, NULL, &glock);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n\n\tpj_grp_lock_add_ref(glock);\n\tasock_cfg.grp_lock = ssock->param.grp_lock = glock;\n\tpj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,\n\t\t\t\tssl_on_destroy);\n    }\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_setup_connection(ssock, newconn);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n#else\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 1, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_return;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_return;\n    }\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_TRUE;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    asock_cb.on_data_read = asock_on_data_read;\n    asock_cb.on_data_sent = asock_on_data_sent;\n\n    status = pj_activesock_create(ssock->pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Start read */\n    status = pj_activesock_start_read2(ssock->asock, ssock->pool, \n\t\t\t\t       (unsigned)ssock->param.read_buffer_size,\n\t\t\t\t       ssock->asock_rbuf,\n\t\t\t\t       PJ_IOQUEUE_ALWAYS_ASYNC);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n#endif\n\n    /* Update local address */\n    status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);\n    if (status != PJ_SUCCESS) {\n\t/* This fails on few envs, e.g: win IOCP, just tolerate this and\n\t * use parent local address instead.\n\t */\n\tpj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);\n    }\n\n    /* Prepare write/send state */\n    pj_assert(ssock->send_buf.max_len == 0);\n    ssock->send_buf.buf = (char*)\n\t\t\t  pj_pool_alloc(ssock->pool, \n\t\t\t\t\tssock->param.send_buffer_size);\n    if (!ssock->send_buf.buf)\n        return PJ_ENOMEM;\n\n    ssock->send_buf.max_len = ssock->param.send_buffer_size;\n    ssock->send_buf.start = ssock->send_buf.buf;\n    ssock->send_buf.len = 0;\n\n    /* Start handshake timer */\n    if (ssock->param.timer_heap && (ssock->param.timeout.sec != 0 ||\n\tssock->param.timeout.msec != 0))\n    {\n\tpj_assert(ssock->timer.id == TIMER_NONE);\n\tstatus = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap, \n\t\t\t\t\t\t   &ssock->timer,\n\t\t\t\t\t\t   &ssock->param.timeout,\n\t\t\t\t\t\t   TIMER_HANDSHAKE_TIMEOUT,\n\t\t\t\t\t\t   ssock->param.grp_lock);\n\tif (status != PJ_SUCCESS) {\n\t    ssock->timer.id = TIMER_NONE;\n\t    status = PJ_SUCCESS;\n\t}\n    }\n\n    /* Start SSL handshake */\n    ssock->ssl_state = SSL_STATE_HANDSHAKING;\n    ssl_set_state(ssock, PJ_TRUE);\n    status = ssl_do_handshake(ssock);\n\non_return:\n    if (ssock && status != PJ_EPENDING) {\n\ton_handshake_complete(ssock, status);\n    }\n\n    /* Must return PJ_TRUE whatever happened, as we must continue listening */\n    return PJ_TRUE;\n}\n\nstatic pj_bool_t ssock_on_connect_complete (pj_ssl_sock_t *ssock,\n\t\t\t\t\t    pj_status_t status)\n{\n    unsigned i;\n\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Update local address */\n    ssock->addr_len = sizeof(pj_sockaddr);\n    status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Create SSL context */\n    status = ssl_create(ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare read buffer */\n    ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(void*));\n    if (!ssock->asock_rbuf)\n        return PJ_ENOMEM;\n\n    for (i = 0; i<ssock->param.async_cnt; ++i) {\n\tssock->asock_rbuf[i] = (void*) pj_pool_alloc(\n\t\t\t\t\t    ssock->pool, \n\t\t\t\t\t    ssock->param.read_buffer_size + \n\t\t\t\t\t    sizeof(read_data_t*));\n        if (!ssock->asock_rbuf[i])\n            return PJ_ENOMEM;\n    }\n\n    /* Start read */\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_start_read(ssock, ssock->param.async_cnt,\n    \t\t\t\t(unsigned)ssock->param.read_buffer_size,\n\t\t\t\tssock->asock_rbuf, 0);\n#else\n    status = pj_activesock_start_read2(ssock->asock, ssock->pool, \n\t\t\t\t       (unsigned)ssock->param.read_buffer_size,\n\t\t\t\t       ssock->asock_rbuf,\n\t\t\t\t       PJ_IOQUEUE_ALWAYS_ASYNC);\n#endif\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare write/send state */\n    pj_assert(ssock->send_buf.max_len == 0);\n    ssock->send_buf.buf = (char*)\n\t\t\t     pj_pool_alloc(ssock->pool, \n\t\t\t\t\t   ssock->param.send_buffer_size);\n    if (!ssock->send_buf.buf)\n        return PJ_ENOMEM;\n\n    ssock->send_buf.max_len = ssock->param.send_buffer_size;\n    ssock->send_buf.start = ssock->send_buf.buf;\n    ssock->send_buf.len = 0;\n\n    /* Set peer name */\n    ssl_set_peer_name(ssock);\n\n    /* Start SSL handshake */\n    ssock->ssl_state = SSL_STATE_HANDSHAKING;\n    ssl_set_state(ssock, PJ_FALSE);\n\n    status = ssl_do_handshake(ssock);\n    if (status != PJ_EPENDING)\n\tgoto on_return;\n\n    return PJ_TRUE;\n\non_return:\n    return on_handshake_complete(ssock, status);\n}\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\nstatic pj_bool_t asock_on_data_read (pj_activesock_t *asock,\n\t\t\t\t     void *data,\n\t\t\t\t     pj_size_t size,\n\t\t\t\t     pj_status_t status,\n\t\t\t\t     pj_size_t *remainder)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_data_read(ssock, data, size, status, remainder);\n}\n\nstatic pj_bool_t asock_on_data_sent (pj_activesock_t *asock,\n\t\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t\t     pj_ssize_t sent)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_data_sent(ssock, send_key, sent);\n}\n\nstatic pj_bool_t asock_on_accept_complete2(pj_activesock_t *asock,\n\t\t\t\t\t   pj_sock_t newsock,\n\t\t\t\t\t   const pj_sockaddr_t *src_addr,\n\t\t\t\t\t   int src_addr_len,\n\t\t\t\t\t   pj_status_t status)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_accept_complete(ssock, newsock, NULL,\n    \t\t\t\t    src_addr, src_addr_len, status);\n}\n\nstatic pj_bool_t asock_on_connect_complete (pj_activesock_t *asock,\n\t\t\t\t\t    pj_status_t status)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_connect_complete(ssock, status);\n}\n#endif\n\n/*\n *******************************************************************\n * API\n *******************************************************************\n */\n\n/* Get available ciphers. */\nPJ_DEF(pj_status_t) pj_ssl_cipher_get_availables(pj_ssl_cipher ciphers[],\n\t\t\t\t\t         unsigned *cipher_num)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(ciphers && cipher_num, PJ_EINVAL);\n\n    ssl_ciphers_populate();\n\n    if (ssl_cipher_num == 0) {\n\t*cipher_num = 0;\n\treturn PJ_ENOTFOUND;\n    }\n\n    *cipher_num = PJ_MIN(*cipher_num, ssl_cipher_num);\n\n    for (i = 0; i < *cipher_num; ++i)\n\tciphers[i] = ssl_ciphers[i].id;\n\n    return PJ_SUCCESS;\n}\n\n/* Get cipher name string */\nPJ_DEF(const char*) pj_ssl_cipher_name(pj_ssl_cipher cipher)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_cipher_num; ++i) {\n\tif (cipher == ssl_ciphers[i].id)\n\t    return ssl_ciphers[i].name;\n    }\n\n    return NULL;\n}\n\n/* Get cipher identifier */\nPJ_DEF(pj_ssl_cipher) pj_ssl_cipher_id(const char *cipher_name)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_cipher_num; ++i) {\n        if (!pj_ansi_stricmp(ssl_ciphers[i].name, cipher_name))\n            return ssl_ciphers[i].id;\n    }\n\n    return PJ_TLS_UNKNOWN_CIPHER;\n}\n\n/* Check if the specified cipher is supported by SSL/TLS backend. */\nPJ_DEF(pj_bool_t) pj_ssl_cipher_is_supported(pj_ssl_cipher cipher)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_cipher_num; ++i) {\n\tif (cipher == ssl_ciphers[i].id)\n\t    return PJ_TRUE;\n    }\n\n    return PJ_FALSE;\n}\n\n/* Get available curves. */\nPJ_DEF(pj_status_t) pj_ssl_curve_get_availables(pj_ssl_curve curves[],\n\t\t\t\t\t\tunsigned *curve_num)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(curves && curve_num, PJ_EINVAL);\n\n    ssl_ciphers_populate();\n\n    if (ssl_curves_num == 0) {\n\t*curve_num = 0;\n\treturn PJ_ENOTFOUND;\n    }\n\n    *curve_num = PJ_MIN(*curve_num, ssl_curves_num);\n\n    for (i = 0; i < *curve_num; ++i)\n\tcurves[i] = ssl_curves[i].id;\n\n    return PJ_SUCCESS;\n}\n\n/* Get curve name string. */\nPJ_DEF(const char*) pj_ssl_curve_name(pj_ssl_curve curve)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_curves_num; ++i) {\n\tif (curve == ssl_curves[i].id)\n\t    return ssl_curves[i].name;\n    }\n\n    return NULL;\n}\n\n/* Get curve ID from curve name string. */\nPJ_DEF(pj_ssl_curve) pj_ssl_curve_id(const char *curve_name)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_curves_num; ++i) {\n        if (ssl_curves[i].name &&\n        \t!pj_ansi_stricmp(ssl_curves[i].name, curve_name))\n        {\n            return ssl_curves[i].id;\n        }\n    }\n\n    return PJ_TLS_UNKNOWN_CURVE;\n}\n\n/* Check if the specified curve is supported by SSL/TLS backend. */\nPJ_DEF(pj_bool_t) pj_ssl_curve_is_supported(pj_ssl_curve curve)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_curves_num; ++i) {\n\tif (curve == ssl_curves[i].id)\n\t    return PJ_TRUE;\n    }\n\n    return PJ_FALSE;\n}\n\n/*\n * Create SSL socket instance. \n */\nPJ_DEF(pj_status_t) pj_ssl_sock_create (pj_pool_t *pool,\n\t\t\t\t\tconst pj_ssl_sock_param *param,\n\t\t\t\t\tpj_ssl_sock_t **p_ssock)\n{\n    pj_ssl_sock_t *ssock;\n    pj_status_t status;\n    pj_pool_t *info_pool;\n\n    PJ_ASSERT_RETURN(pool && param && p_ssock, PJ_EINVAL);\n    PJ_ASSERT_RETURN(param->sock_type == pj_SOCK_STREAM(), PJ_ENOTSUP);\n\n    info_pool = pj_pool_create(pool->factory, \"ssl_chain%p\", 512, 512, NULL);\n    pool = pj_pool_create(pool->factory, \"ssl%p\", 512, 512, NULL);\n\n    /* Create secure socket */\n    ssock = ssl_alloc(pool);\n    if (!ssock)\n    \treturn PJ_ENOMEM;\n    ssock->pool = pool;\n    ssock->info_pool = info_pool;\n    ssock->sock = PJ_INVALID_SOCKET;\n    ssock->ssl_state = SSL_STATE_NULL;\n    ssock->circ_buf_input.owner = ssock;\n    ssock->circ_buf_output.owner = ssock;\n    pj_list_init(&ssock->write_pending);\n    pj_list_init(&ssock->write_pending_empty);\n    pj_list_init(&ssock->send_pending);\n    pj_timer_entry_init(&ssock->timer, 0, ssock, &on_timer);\n    pj_ioqueue_op_key_init(&ssock->handshake_op_key,\n\t\t\t   sizeof(pj_ioqueue_op_key_t));\n    pj_ioqueue_op_key_init(&ssock->shutdown_op_key,\n\t\t\t   sizeof(pj_ioqueue_op_key_t));\n\n    /* Create secure socket mutex */\n    status = pj_lock_create_recursive_mutex(pool, pool->obj_name,\n                                            &ssock->circ_buf_output_mutex);\n    ssock->write_mutex = ssock->circ_buf_output_mutex;\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Create input circular buffer mutex */\n    status = pj_lock_create_simple_mutex(pool, pool->obj_name,\n                                         &ssock->circ_buf_input_mutex);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Init secure socket param */\n    pj_ssl_sock_param_copy(pool, &ssock->param, param);\n\n    if (ssock->param.grp_lock) {\n\tpj_grp_lock_add_ref(ssock->param.grp_lock);\n\tpj_grp_lock_add_handler(ssock->param.grp_lock, pool, ssock,\n\t\t\t\tssl_on_destroy);\n    }\n\n    ssock->param.read_buffer_size = ((ssock->param.read_buffer_size+7)>>3)<<3;\n    if (!ssock->param.timer_heap) {\n\tPJ_LOG(3,(ssock->pool->obj_name, \"Warning: timer heap is not \"\n\t\t  \"available. It is recommended to supply one to avoid \"\n\t          \"a race condition if more than one worker threads \"\n\t          \"are used.\"));\n    }\n\n    /* Finally */\n    *p_ssock = ssock;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Close the secure socket. This will unregister the socket from the\n * ioqueue and ultimately close the socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_close(pj_ssl_sock_t *ssock)\n{\n    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);\n\n    if (!ssock->pool)\n\treturn PJ_SUCCESS;\n\n    if (ssock->timer.id != TIMER_NONE) {\n\tpj_timer_heap_cancel(ssock->param.timer_heap, &ssock->timer);\n\tssock->timer.id = TIMER_NONE;\n    }\n\n    ssl_reset_sock_state(ssock);\n\n    /* Wipe out cert & key buffer. */\n    if (ssock->cert) {\n\tpj_ssl_cert_wipe_keys(ssock->cert);\n\tssock->cert = NULL;\n    }\n\n    if (ssock->param.grp_lock) {\n\tpj_grp_lock_dec_ref(ssock->param.grp_lock);\n    } else {\n\tssl_on_destroy(ssock);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Associate arbitrary data with the secure socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_set_user_data(pj_ssl_sock_t *ssock,\n\t\t\t\t\t      void *user_data)\n{\n    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);\n\n    ssock->param.user_data = user_data;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Retrieve the user data previously associated with this secure\n * socket.\n */\nPJ_DEF(void*) pj_ssl_sock_get_user_data(pj_ssl_sock_t *ssock)\n{\n    PJ_ASSERT_RETURN(ssock, NULL);\n\n    return ssock->param.user_data;\n}\n\n/*\n * Retrieve the local address and port used by specified SSL socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_get_info (pj_ssl_sock_t *ssock,\n\t\t\t\t\t  pj_ssl_sock_info *info)\n{\n    pj_bzero(info, sizeof(*info));\n\n    /* Established flag */\n    info->established = (ssock->ssl_state == SSL_STATE_ESTABLISHED);\n\n    /* Protocol */\n    info->proto = ssock->param.proto;\n\n    /* Local address */\n    pj_sockaddr_cp(&info->local_addr, &ssock->local_addr);\n    \n    if (info->established) {\n\tinfo->cipher = ssl_get_cipher(ssock);\n\n\t/* Remote address */\n\tpj_sockaddr_cp(&info->remote_addr, &ssock->rem_addr);\n\n\t/* Certificates info */\n\tinfo->local_cert_info = &ssock->local_cert_info;\n\tinfo->remote_cert_info = &ssock->remote_cert_info;\n\n\t/* Verification status */\n\tinfo->verify_status = ssock->verify_status;\n    }\n\n    /* Last known SSL error code */\n    info->last_native_err = ssock->last_err;\n\n    /* Group lock */\n    info->grp_lock = ssock->param.grp_lock;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Starts read operation on this secure socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_read (pj_ssl_sock_t *ssock,\n\t\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t\t    unsigned buff_size,\n\t\t\t\t\t    pj_uint32_t flags)\n{\n    void **readbuf;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(ssock && pool && buff_size, PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    readbuf = (void**) pj_pool_calloc(pool, ssock->param.async_cnt, \n\t\t\t\t      sizeof(void*));\n    if (!readbuf)\n        return PJ_ENOMEM;\n\n    for (i=0; i<ssock->param.async_cnt; ++i) {\n\treadbuf[i] = pj_pool_alloc(pool, buff_size);\n        if (!readbuf[i])\n            return PJ_ENOMEM;\n    }\n\n    return pj_ssl_sock_start_read2(ssock, pool, buff_size, \n\t\t\t\t   readbuf, flags);\n}\n\n\n/*\n * Same as #pj_ssl_sock_start_read(), except that the application\n * supplies the buffers for the read operation so that the acive socket\n * does not have to allocate the buffers.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_read2 (pj_ssl_sock_t *ssock,\n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     unsigned buff_size,\n\t\t\t\t\t     void *readbuf[],\n\t\t\t\t\t     pj_uint32_t flags)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(ssock && pool && buff_size && readbuf, PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    /* Create SSL socket read buffer */\n    ssock->ssock_rbuf = (read_data_t*)pj_pool_calloc(pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(read_data_t));\n    if (!ssock->ssock_rbuf)\n        return PJ_ENOMEM;\n\n    /* Store SSL socket read buffer pointer in the activesock read buffer */\n    for (i=0; i<ssock->param.async_cnt; ++i) {\n\tread_data_t **p_ssock_rbuf = \n\t\t\tOFFSET_OF_READ_DATA_PTR(ssock, ssock->asock_rbuf[i]);\n\n\tssock->ssock_rbuf[i].data = readbuf[i];\n\tssock->ssock_rbuf[i].len = 0;\n\n\t*p_ssock_rbuf = &ssock->ssock_rbuf[i];\n    }\n\n    ssock->read_size = buff_size;\n    ssock->read_started = PJ_TRUE;\n    ssock->read_flags = flags;\n\n    for (i=0; i<ssock->param.async_cnt; ++i) {\n\tif (ssock->asock_rbuf[i]) {\n\t    pj_size_t remainder = 0;\n\t    ssock_on_data_read(ssock, ssock->asock_rbuf[i], 0,\n\t\t\t       PJ_SUCCESS, &remainder);\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Same as pj_ssl_sock_start_read(), except that this function is used\n * only for datagram sockets, and it will trigger \\a on_data_recvfrom()\n * callback instead.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_recvfrom (pj_ssl_sock_t *ssock,\n\t\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\t\tunsigned buff_size,\n\t\t\t\t\t\tpj_uint32_t flags)\n{\n    PJ_UNUSED_ARG(ssock);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(buff_size);\n    PJ_UNUSED_ARG(flags);\n\n    return PJ_ENOTSUP;\n}\n\n\n/*\n * Same as #pj_ssl_sock_start_recvfrom() except that the recvfrom() \n * operation takes the buffer from the argument rather than creating\n * new ones.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_recvfrom2 (pj_ssl_sock_t *ssock,\n\t\t\t\t\t\t pj_pool_t *pool,\n\t\t\t\t\t\t unsigned buff_size,\n\t\t\t\t\t\t void *readbuf[],\n\t\t\t\t\t\t pj_uint32_t flags)\n{\n    PJ_UNUSED_ARG(ssock);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(buff_size);\n    PJ_UNUSED_ARG(readbuf);\n    PJ_UNUSED_ARG(flags);\n\n    return PJ_ENOTSUP;\n}\n\n\n/* Write plain data to SSL and flush the buffer. */\nstatic pj_status_t ssl_send (pj_ssl_sock_t *ssock, \n\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t     const void *data,\n\t\t\t     pj_ssize_t size,\n\t\t\t     unsigned flags)\n{\n    pj_status_t status;\n    int nwritten;\n\n    /* Write the plain data to SSL, after SSL encrypts it, the buffer will\n     * contain the secured data to be sent via socket. Note that re-\n     * negotitation may be on progress, so sending data should be delayed\n     * until re-negotiation is completed.\n     */\n    pj_lock_acquire(ssock->write_mutex);\n    /* Don't write to SSL if send buffer is full and some data is in\n     * write buffer already, just return PJ_ENOMEM.\n     */\n    if (ssock->send_buf_pending.data_len) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_ENOMEM;\n    }\n    status = ssl_write(ssock, data, size, &nwritten);\n    pj_lock_release(ssock->write_mutex);\n    \n    if (status == PJ_SUCCESS && nwritten == size) {\n\t/* All data written, flush write buffer to network socket */\n\tstatus = flush_circ_buf_output(ssock, send_key, size, flags);\n    } else if (status == PJ_EEOF) {\n        /* Re-negotiation is on progress, flush re-negotiation data */\n\tstatus = flush_circ_buf_output(ssock, &ssock->handshake_op_key, 0, 0);\n\tif (status == PJ_SUCCESS || status == PJ_EPENDING) {\n\t    /* Just return PJ_EBUSY when re-negotiation is on progress */\n\t    status = PJ_EBUSY;\n\t}\n    }\n\n    return status;\n}\n\n/* Flush delayed data sending in the write pending list. */\nstatic pj_status_t flush_delayed_send(pj_ssl_sock_t *ssock)\n{\n    /* Check for another ongoing flush */\n    if (ssock->flushing_write_pend)\n\treturn PJ_EBUSY;\n\n    pj_lock_acquire(ssock->write_mutex);\n\n    /* Again, check for another ongoing flush */\n    if (ssock->flushing_write_pend) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_EBUSY;\n    }\n\n    /* Set ongoing flush flag */\n    ssock->flushing_write_pend = PJ_TRUE;\n\n    while (!pj_list_empty(&ssock->write_pending)) {\n        write_data_t *wp;\n\tpj_status_t status;\n\n\twp = ssock->write_pending.next;\n\n\t/* Ticket #1573: Don't hold mutex while calling socket send. */\n\tpj_lock_release(ssock->write_mutex);\n\n\tstatus = ssl_send (ssock, &wp->key, wp->data.ptr, \n\t\t\t   wp->plain_data_len, wp->flags);\n\tif (status != PJ_SUCCESS) {\n\t    /* Reset ongoing flush flag first. */\n\t    ssock->flushing_write_pend = PJ_FALSE;\n\t    return status;\n\t}\n\n\tpj_lock_acquire(ssock->write_mutex);\n\tpj_list_erase(wp);\n\tpj_list_push_back(&ssock->write_pending_empty, wp);\n    }\n\n    /* Reset ongoing flush flag */\n    ssock->flushing_write_pend = PJ_FALSE;\n\n    pj_lock_release(ssock->write_mutex);\n\n    return PJ_SUCCESS;\n}\n\n/* Sending is delayed, push back the sending data into pending list. */\nstatic pj_status_t delay_send (pj_ssl_sock_t *ssock,\n\t\t\t       pj_ioqueue_op_key_t *send_key,\n\t\t\t       const void *data,\n\t\t\t       pj_ssize_t size,\n\t\t\t       unsigned flags)\n{\n    write_data_t *wp;\n\n    pj_lock_acquire(ssock->write_mutex);\n\n    /* Init write pending instance */\n    if (!pj_list_empty(&ssock->write_pending_empty)) {\n\twp = ssock->write_pending_empty.next;\n\tpj_list_erase(wp);\n    } else {\n\twp = PJ_POOL_ZALLOC_T(ssock->pool, write_data_t);\n    }\n\n    wp->app_key = send_key;\n    wp->plain_data_len = size;\n    wp->data.ptr = data;\n    wp->flags = flags;\n\n    pj_list_push_back(&ssock->write_pending, wp);\n    \n    pj_lock_release(ssock->write_mutex);\n\n    /* Must return PJ_EPENDING */\n    return PJ_EPENDING;\n}\n\n\n/**\n * Send data using the socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_send (pj_ssl_sock_t *ssock,\n\t\t\t\t      pj_ioqueue_op_key_t *send_key,\n\t\t\t\t      const void *data,\n\t\t\t\t      pj_ssize_t *size,\n\t\t\t\t      unsigned flags)\n{\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(ssock && data && size && (*size>0), PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    // Ticket #1573: Don't hold mutex while calling PJLIB socket send().\n    //pj_lock_acquire(ssock->write_mutex);\n\n    /* Flush delayed send first. Sending data might be delayed when \n     * re-negotiation is on-progress.\n     */\n    status = flush_delayed_send(ssock);\n    if (status == PJ_EBUSY) {\n\t/* Re-negotiation or flushing is on progress, delay sending */\n\tstatus = delay_send(ssock, send_key, data, *size, flags);\n\tgoto on_return;\n    } else if (status != PJ_SUCCESS) {\n\tgoto on_return;\n    }\n\n    /* Write data to SSL */\n    status = ssl_send(ssock, send_key, data, *size, flags);\n    if (status == PJ_EBUSY) {\n\t/* Re-negotiation is on progress, delay sending */\n\tstatus = delay_send(ssock, send_key, data, *size, flags);\n    }\n\non_return:\n    //pj_lock_release(ssock->write_mutex);\n    return status;\n}\n\n\n/**\n * Send datagram using the socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_sendto (pj_ssl_sock_t *ssock,\n\t\t\t\t\tpj_ioqueue_op_key_t *send_key,\n\t\t\t\t\tconst void *data,\n\t\t\t\t\tpj_ssize_t *size,\n\t\t\t\t\tunsigned flags,\n\t\t\t\t\tconst pj_sockaddr_t *addr,\n\t\t\t\t\tint addr_len)\n{\n    PJ_UNUSED_ARG(ssock);\n    PJ_UNUSED_ARG(send_key);\n    PJ_UNUSED_ARG(data);\n    PJ_UNUSED_ARG(size);\n    PJ_UNUSED_ARG(flags);\n    PJ_UNUSED_ARG(addr);\n    PJ_UNUSED_ARG(addr_len);\n\n    return PJ_ENOTSUP;\n}\n\n\n/**\n * Starts asynchronous socket accept() operations on this secure socket. \n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_accept (pj_ssl_sock_t *ssock,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      const pj_sockaddr_t *localaddr,\n\t\t\t\t\t      int addr_len)\n{\n    return pj_ssl_sock_start_accept2(ssock, pool, localaddr, addr_len,\n    \t\t\t\t     &ssock->param);\n}\n\n\n/**\n * Same as #pj_ssl_sock_start_accept(), but application provides parameter\n * for new accepted secure sockets.\n */\nPJ_DEF(pj_status_t)\npj_ssl_sock_start_accept2(pj_ssl_sock_t *ssock,\n\t\t\t  pj_pool_t *pool,\n\t\t\t  const pj_sockaddr_t *localaddr,\n\t\t\t  int addr_len,\n\t\t\t  const pj_ssl_sock_param *newsock_param)\n{\n    pj_status_t status;\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    pj_activesock_cb asock_cb;\n    pj_activesock_cfg asock_cfg;\n#endif\n\n    PJ_ASSERT_RETURN(ssock && pool && localaddr && addr_len, PJ_EINVAL);\n\n    /* Verify new socket parameters */\n    if (newsock_param->grp_lock != ssock->param.grp_lock ||\n        newsock_param->sock_af != ssock->param.sock_af ||\n        newsock_param->sock_type != ssock->param.sock_type)\n    {\n        return PJ_EINVAL;\n    }\n\n    ssock->is_server = PJ_TRUE;\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_start_accept(ssock, pool, localaddr, addr_len,\n    \t\t\t\t  newsock_param);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#else\n    /* Create socket */\n    status = pj_sock_socket(ssock->param.sock_af, ssock->param.sock_type, 0, \n\t\t\t    &ssock->sock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Apply SO_REUSEADDR */\n    if (ssock->param.reuse_addr) {\n\tint enabled = 1;\n\tstatus = pj_sock_setsockopt(ssock->sock, pj_SOL_SOCKET(),\n\t\t\t\t    pj_SO_REUSEADDR(),\n\t\t\t\t    &enabled, sizeof(enabled));\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4,(ssock->pool->obj_name, status,\n\t\t         \"Warning: error applying SO_REUSEADDR\"));\n\t}\n    }\n\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 2, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_error;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_error;\n    }\n\n    /* Bind socket */\n    status = pj_sock_bind(ssock->sock, localaddr, addr_len);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Start listening to the address */\n    status = pj_sock_listen(ssock->sock, PJ_SOMAXCONN);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_FALSE;\n    asock_cfg.grp_lock = ssock->param.grp_lock;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    //asock_cb.on_accept_complete = asock_on_accept_complete;\n    asock_cb.on_accept_complete2 = asock_on_accept_complete2;\n\n    status = pj_activesock_create(pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Start accepting */\n    pj_ssl_sock_param_copy(pool, &ssock->newsock_param, newsock_param);\n    ssock->newsock_param.grp_lock = NULL;\n    status = pj_activesock_start_accept(ssock->asock, pool);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Update local address */\n    ssock->addr_len = addr_len;\n    status = pj_sock_getsockname(ssock->sock, &ssock->local_addr, \n\t\t\t\t &ssock->addr_len);\n    if (status != PJ_SUCCESS)\n\tpj_sockaddr_cp(&ssock->local_addr, localaddr);\n#endif\n\n    return PJ_SUCCESS;\n\non_error:\n    ssl_reset_sock_state(ssock);\n    return status;\n}\n\n\n/**\n * Starts asynchronous socket connect() operation.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_connect(pj_ssl_sock_t *ssock,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      const pj_sockaddr_t *localaddr,\n\t\t\t\t\t      const pj_sockaddr_t *remaddr,\n\t\t\t\t\t      int addr_len)\n{\n    pj_ssl_start_connect_param param;    \n    param.pool = pool;\n    param.localaddr = localaddr;\n    param.local_port_range = 0;\n    param.remaddr = remaddr;\n    param.addr_len = addr_len;\n\n    return pj_ssl_sock_start_connect2(ssock, &param);\n}\n\nPJ_DEF(pj_status_t) pj_ssl_sock_start_connect2(\n\t\t\t       pj_ssl_sock_t *ssock,\n\t\t\t       pj_ssl_start_connect_param *connect_param)\n{\n    pj_status_t status;\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_start_connect(ssock, connect_param);\n    if (status != PJ_EPENDING)\n\tgoto on_error;\n#else\n    pj_activesock_cb asock_cb;\n    pj_activesock_cfg asock_cfg;\n    \n    pj_pool_t *pool = connect_param->pool;\n    const pj_sockaddr_t *localaddr = connect_param->localaddr;\n    pj_uint16_t port_range = connect_param->local_port_range;\n    const pj_sockaddr_t *remaddr = connect_param->remaddr;\n    int addr_len = connect_param->addr_len;\n\n    PJ_ASSERT_RETURN(ssock && pool && localaddr && remaddr && addr_len,\n\t\t     PJ_EINVAL);\n\n    /* Create socket */\n    status = pj_sock_socket(ssock->param.sock_af, ssock->param.sock_type, 0, \n\t\t\t    &ssock->sock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 2, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_error;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_error;\n    }\n\n    /* Bind socket */\n    if (port_range) {\n\tpj_uint16_t max_bind_retry = MAX_BIND_RETRY;\n\tif (port_range && port_range < max_bind_retry)\n\t{\n\t    max_bind_retry = port_range;\n\t}\n\tstatus = pj_sock_bind_random(ssock->sock, localaddr, port_range,\n\t\t\t\t     max_bind_retry);\n    } else {\n\tstatus = pj_sock_bind(ssock->sock, localaddr, addr_len);\n    }\n\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_TRUE;\n    asock_cfg.grp_lock = ssock->param.grp_lock;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    asock_cb.on_connect_complete = asock_on_connect_complete;\n    asock_cb.on_data_read = asock_on_data_read;\n    asock_cb.on_data_sent = asock_on_data_sent;\n\n    status = pj_activesock_create(pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Save remote address */\n    pj_sockaddr_cp(&ssock->rem_addr, remaddr);\n\n    status = pj_activesock_start_connect(ssock->asock, pool, remaddr,\n\t\t\t\t\t addr_len);\n\n    if (status == PJ_SUCCESS)\n\tasock_on_connect_complete(ssock->asock, PJ_SUCCESS);\n    else if (status != PJ_EPENDING)\n\tgoto on_error;\n\n    /* Update local address */\n    ssock->addr_len = addr_len;\n    status = pj_sock_getsockname(ssock->sock, &ssock->local_addr,\n\t\t\t\t &ssock->addr_len);\n    /* Note that we may not get an IP address here. This can\n     * happen for example on Windows, where getsockname()\n     * would return 0.0.0.0 if socket has just started the\n     * async connect. In this case, just leave the local\n     * address with 0.0.0.0 for now; it will be updated\n     * once the socket is established.\n     */\n\n#endif\n\n    /* Start timer */\n    if (ssock->param.timer_heap &&\n        (ssock->param.timeout.sec != 0 || ssock->param.timeout.msec != 0))\n    {\n\tpj_assert(ssock->timer.id == TIMER_NONE);\n\tstatus = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap,\n\t\t\t\t\t\t   &ssock->timer,\n\t\t\t\t\t\t   &ssock->param.timeout,\n\t\t\t\t\t\t   TIMER_HANDSHAKE_TIMEOUT,\n\t\t\t\t\t\t   ssock->param.grp_lock);\n\tif (status != PJ_SUCCESS) {\n\t    ssock->timer.id = TIMER_NONE;\n\t    status = PJ_SUCCESS;\n\t}\n    }\n\n    /* Update SSL state */\n    ssock->is_server = PJ_FALSE;\n\n    return PJ_EPENDING;\n\non_error:\n    ssl_reset_sock_state(ssock);\n    return status;\n}\n\n\nPJ_DEF(pj_status_t) pj_ssl_sock_renegotiate(pj_ssl_sock_t *ssock)\n{\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    status = ssl_renegotiate(ssock);\n    if (status == PJ_SUCCESS) {\n\tstatus = ssl_do_handshake(ssock);\n    }\n\n    return status;\n}\n\nstatic void wipe_buf(pj_str_t *buf)\n{\n    volatile char *p = buf->ptr;\n    pj_ssize_t len = buf->slen;\n    while (len--) *p++ = 0;\n    buf->slen = 0;\n}\n\nPJ_DEF(void) pj_ssl_cert_wipe_keys(pj_ssl_cert_t *cert)\n{    \n    if (cert) {\n\twipe_buf(&cert->CA_file);\n\twipe_buf(&cert->CA_path);\n\twipe_buf(&cert->cert_file);\n\twipe_buf(&cert->privkey_file);\n\twipe_buf(&cert->privkey_pass);\n\twipe_buf(&cert->CA_buf);\n\twipe_buf(&cert->cert_buf);\n\twipe_buf(&cert->privkey_buf);\n    }\n}\n\n/* Load credentials from files. */\nPJ_DEF(pj_status_t) pj_ssl_cert_load_from_files (pj_pool_t *pool,\n\t\t\t\t\t\t const pj_str_t *CA_file,\n\t\t\t\t\t\t const pj_str_t *cert_file,\n\t\t\t\t\t\t const pj_str_t *privkey_file,\n\t\t\t\t\t\t const pj_str_t *privkey_pass,\n\t\t\t\t\t\t pj_ssl_cert_t **p_cert)\n{\n    return pj_ssl_cert_load_from_files2(pool, CA_file, NULL, cert_file,\n\t\t\t\t\tprivkey_file, privkey_pass, p_cert);\n}\n\nPJ_DEF(pj_status_t) pj_ssl_cert_load_from_files2(pj_pool_t *pool,\n\t\t\t\t\t\t const pj_str_t *CA_file,\n\t\t\t\t\t\t const pj_str_t *CA_path,\n\t\t\t\t\t\t const pj_str_t *cert_file,\n\t\t\t\t\t\t const pj_str_t *privkey_file,\n\t\t\t\t\t\t const pj_str_t *privkey_pass,\n\t\t\t\t\t\t pj_ssl_cert_t **p_cert)\n{\n    pj_ssl_cert_t *cert;\n\n    PJ_ASSERT_RETURN(pool && (CA_file || CA_path) && cert_file &&\n\t\t     privkey_file,\n\t\t     PJ_EINVAL);\n\n    cert = PJ_POOL_ZALLOC_T(pool, pj_ssl_cert_t);\n    if (CA_file) {\n    \tpj_strdup_with_null(pool, &cert->CA_file, CA_file);\n    }\n    if (CA_path) {\n    \tpj_strdup_with_null(pool, &cert->CA_path, CA_path);\n    }\n    pj_strdup_with_null(pool, &cert->cert_file, cert_file);\n    pj_strdup_with_null(pool, &cert->privkey_file, privkey_file);\n    pj_strdup_with_null(pool, &cert->privkey_pass, privkey_pass);\n\n    *p_cert = cert;\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_ssl_cert_load_from_buffer(pj_pool_t *pool,\n\t\t\t\t\tconst pj_ssl_cert_buffer *CA_buf,\n\t\t\t\t\tconst pj_ssl_cert_buffer *cert_buf,\n\t\t\t\t\tconst pj_ssl_cert_buffer *privkey_buf,\n\t\t\t\t\tconst pj_str_t *privkey_pass,\n\t\t\t\t\tpj_ssl_cert_t **p_cert)\n{\n    pj_ssl_cert_t *cert;\n\n    PJ_ASSERT_RETURN(pool && CA_buf && cert_buf && privkey_buf, PJ_EINVAL);\n\n    cert = PJ_POOL_ZALLOC_T(pool, pj_ssl_cert_t);\n    pj_strdup(pool, &cert->CA_buf, CA_buf);\n    pj_strdup(pool, &cert->cert_buf, cert_buf);\n    pj_strdup(pool, &cert->privkey_buf, privkey_buf);\n    pj_strdup_with_null(pool, &cert->privkey_pass, privkey_pass);\n\n    *p_cert = cert;\n\n    return PJ_SUCCESS;\n}\n\n/* Set SSL socket credentials. */\nPJ_DEF(pj_status_t) pj_ssl_sock_set_certificate(\n\t\t\t\t\t    pj_ssl_sock_t *ssock,\n\t\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t\t    const pj_ssl_cert_t *cert)\n{\n    pj_ssl_cert_t *cert_;\n\n    PJ_ASSERT_RETURN(ssock && pool && cert, PJ_EINVAL);\n\n    cert_ = PJ_POOL_ZALLOC_T(pool, pj_ssl_cert_t);\n    pj_memcpy(cert_, cert, sizeof(pj_ssl_cert_t));\n    pj_strdup_with_null(pool, &cert_->CA_file, &cert->CA_file);\n    pj_strdup_with_null(pool, &cert_->CA_path, &cert->CA_path);\n    pj_strdup_with_null(pool, &cert_->cert_file, &cert->cert_file);\n    pj_strdup_with_null(pool, &cert_->privkey_file, &cert->privkey_file);\n    pj_strdup_with_null(pool, &cert_->privkey_pass, &cert->privkey_pass);\n\n    pj_strdup(pool, &cert_->CA_buf, &cert->CA_buf);\n    pj_strdup(pool, &cert_->cert_buf, &cert->cert_buf);\n    pj_strdup(pool, &cert_->privkey_buf, &cert->privkey_buf);\n\n    ssock->cert = cert_;\n\n    return PJ_SUCCESS;\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2009-2011 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pj/ssl_sock.h>\n#include <pj/activesock.h>\n#include <pj/compat/socket.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/file_access.h>\n#include <pj/list.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/timer.h>\n\n/* Only build when PJ_HAS_SSL_SOCK is enabled and when the backend is\n * OpenSSL.\n */\n#if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\\n    (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_OPENSSL)\n\n#include \"ssl_sock_imp_common.c\"\n\n#define THIS_FILE\t\t\"ssl_sock_ossl.c\"\n\n/* \n * Include OpenSSL headers \n */\n#include <openssl/asn1.h>\n#include <openssl/bio.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/x509v3.h>\n#if !defined(OPENSSL_NO_DH)\n#   include <openssl/dh.h>\n#endif\n\n#include <openssl/rand.h>\n#include <openssl/opensslconf.h>\n#include <openssl/opensslv.h>\n\n#if defined(LIBRESSL_VERSION_NUMBER)\n#\tdefine USING_LIBRESSL 1\n#else\n#\tdefine USING_LIBRESSL 0\n#endif\n\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n\t&& OPENSSL_VERSION_NUMBER >= 0x1000200fL\n\n#   include <openssl/obj_mac.h>\n\nstatic const unsigned nid_cid_map[] = {\n    NID_sect163k1,              /* sect163k1 (1) */\n    NID_sect163r1,              /* sect163r1 (2) */\n    NID_sect163r2,              /* sect163r2 (3) */\n    NID_sect193r1,              /* sect193r1 (4) */\n    NID_sect193r2,              /* sect193r2 (5) */\n    NID_sect233k1,              /* sect233k1 (6) */\n    NID_sect233r1,              /* sect233r1 (7) */\n    NID_sect239k1,              /* sect239k1 (8) */\n    NID_sect283k1,              /* sect283k1 (9) */\n    NID_sect283r1,              /* sect283r1 (10) */\n    NID_sect409k1,              /* sect409k1 (11) */\n    NID_sect409r1,              /* sect409r1 (12) */\n    NID_sect571k1,              /* sect571k1 (13) */\n    NID_sect571r1,              /* sect571r1 (14) */\n    NID_secp160k1,              /* secp160k1 (15) */\n    NID_secp160r1,              /* secp160r1 (16) */\n    NID_secp160r2,              /* secp160r2 (17) */\n    NID_secp192k1,              /* secp192k1 (18) */\n    NID_X9_62_prime192v1,       /* secp192r1 (19) */\n    NID_secp224k1,              /* secp224k1 (20) */\n    NID_secp224r1,              /* secp224r1 (21) */\n    NID_secp256k1,              /* secp256k1 (22) */\n    NID_X9_62_prime256v1,       /* secp256r1 (23) */\n    NID_secp384r1,              /* secp384r1 (24) */\n    NID_secp521r1,              /* secp521r1 (25) */\n    NID_brainpoolP256r1,        /* brainpoolP256r1 (26) */\n    NID_brainpoolP384r1,        /* brainpoolP384r1 (27) */\n    NID_brainpoolP512r1         /* brainpoolP512r1 (28) */\n};\n\nstatic unsigned get_cid_from_nid(unsigned nid)\n{\n    unsigned i, cid = 0;\n    for (i=0; i<PJ_ARRAY_SIZE(nid_cid_map); ++i) {\n\tif (nid == nid_cid_map[i]) {\n\t    cid = i+1;\n\t    break;\n\t}\n    }\n    return cid;\n}\n\nstatic unsigned get_nid_from_cid(unsigned cid)\n{\n    if ((cid == 0) || (cid > PJ_ARRAY_SIZE(nid_cid_map)))\n\treturn 0;\n\n    return nid_cid_map[cid-1];\n}\n\n#endif\n\n\n#if !USING_LIBRESSL && OPENSSL_VERSION_NUMBER >= 0x10100000L\n#  define OPENSSL_NO_SSL2\t    /* seems to be removed in 1.1.0 */\n#  define M_ASN1_STRING_data(x)\t    ASN1_STRING_get0_data(x)\n#  define M_ASN1_STRING_length(x)   ASN1_STRING_length(x)\n#  if defined(OPENSSL_API_COMPAT) && OPENSSL_API_COMPAT >= 0x10100000L\n#     define X509_get_notBefore(x)  X509_get0_notBefore(x)\n#     define X509_get_notAfter(x)   X509_get0_notAfter(x)\n#  endif\n#elif !USING_LIBRESSL\n#  define SSL_CIPHER_get_id(c)\t    (c)->id\n#  define SSL_set_session(ssl, s)   (ssl)->session = (s)\n#endif\n\n\n#ifdef _MSC_VER\n#  if OPENSSL_VERSION_NUMBER >= 0x10100000L\n#    pragma comment(lib, \"libcrypto\")\n#    pragma comment(lib, \"libssl\")\n#    pragma comment(lib, \"crypt32\")\n#  else\n#    pragma comment(lib, \"libeay32\")\n#    pragma comment(lib, \"ssleay32\")\n#  endif\n#endif\n\n\n#if defined(PJ_WIN32) && PJ_WIN32 != 0 || \\\n    defined(PJ_WIN64) && PJ_WIN64 != 0\n#  ifdef _MSC_VER\n#    define strerror_r(err,buf,len) strerror_s(buf,len,err)\n#  else\n#    define strerror_r(err,buf,len) pj_ansi_strncpy(buf,strerror(err),len)\n#  endif\n#endif\n\n\n/* Suppress compile warning of OpenSSL deprecation (OpenSSL is deprecated\n * since MacOSX 10.7).\n */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n\n/*\n * Secure socket structure definition.\n */\ntypedef struct ossl_sock_t\n{\n    pj_ssl_sock_t  \t  base;\n\n    SSL_CTX\t\t *ossl_ctx;\n    SSL\t\t\t *ossl_ssl;\n    BIO\t\t\t *ossl_rbio;\n    BIO\t\t\t *ossl_wbio;\n} ossl_sock_t;\n\n/**\n * Mapping from OpenSSL error codes to pjlib error space.\n */\n\n#define PJ_SSL_ERRNO_START\t\t(PJ_ERRNO_START_USER + \\\n\t\t\t\t\t PJ_ERRNO_SPACE_SIZE*6)\n\n#define PJ_SSL_ERRNO_SPACE_SIZE\t\tPJ_ERRNO_SPACE_SIZE\n\n/* Expected maximum value of reason component in OpenSSL error code */\n#define MAX_OSSL_ERR_REASON\t\t1200\n\n\nstatic char *SSLErrorString (int err)\n{\n    switch (err) {\n    case SSL_ERROR_NONE:\n\treturn \"SSL_ERROR_NONE\";\n    case SSL_ERROR_ZERO_RETURN:\n\treturn \"SSL_ERROR_ZERO_RETURN\";\n    case SSL_ERROR_WANT_READ:\n\treturn \"SSL_ERROR_WANT_READ\";\n    case SSL_ERROR_WANT_WRITE:\n\treturn \"SSL_ERROR_WANT_WRITE\";\n    case SSL_ERROR_WANT_CONNECT:\n\treturn \"SSL_ERROR_WANT_CONNECT\";\n    case SSL_ERROR_WANT_ACCEPT:\n\treturn \"SSL_ERROR_WANT_ACCEPT\";\n    case SSL_ERROR_WANT_X509_LOOKUP:\n\treturn \"SSL_ERROR_WANT_X509_LOOKUP\";\n    case SSL_ERROR_SYSCALL:\n\treturn \"SSL_ERROR_SYSCALL\";\n    case SSL_ERROR_SSL:\n\treturn \"SSL_ERROR_SSL\";\n    default:\n\treturn \"SSL_ERROR_UNKNOWN\";\n    }\n}\n\n#define ERROR_LOG(msg, err, ssock) \\\n{ \\\n    char buf[PJ_INET6_ADDRSTRLEN+10]; \\\n    PJ_LOG(2,(\"SSL\", \"%s (%s): Level: %d err: <%lu> <%s-%s-%s> len: %d \" \\\n\t   \"peer: %s\", \\\n\t   msg, action, level, err, \\\n\t   (ERR_lib_error_string(err)? ERR_lib_error_string(err): \"???\"), \\\n\t   (ERR_func_error_string(err)? ERR_func_error_string(err):\"???\"),\\\n\t   (ERR_reason_error_string(err)? \\\n\t    ERR_reason_error_string(err): \"???\"), len, \\\n\t   (ssock && pj_sockaddr_has_addr(&ssock->rem_addr)? \\\n\t    pj_sockaddr_print(&ssock->rem_addr, buf, sizeof(buf), 3):\"???\")));\\\n}\n\nstatic void SSLLogErrors(char * action, int ret, int ssl_err, int len, \n\t\t\t pj_ssl_sock_t *ssock)\n{\n    char *ssl_err_str = SSLErrorString(ssl_err);\n\n    if (!action) {\n\taction = \"UNKNOWN\";\n    }\n\n    switch (ssl_err) {\n    case SSL_ERROR_SYSCALL:\n    {\n\tunsigned long err2 = ERR_get_error();\n\tif (err2) {\n\t    int level = 0;\n\t    while (err2) {\n\t        ERROR_LOG(\"SSL_ERROR_SYSCALL\", err2, ssock);\n\t\tlevel++;\n\t\terr2 = ERR_get_error();\n\t    }\n\t} else if (ret == 0) {\n\t    /* An EOF was observed that violates the protocol */\n\n\t    /* The TLS/SSL handshake was not successful but was shut down\n\t     * controlled and by the specifications of the TLS/SSL protocol.\n\t     */\n\t} else if (ret == -1) {\n\t    /* BIO error - look for more info in errno... */\n\t    char errStr[250] = \"\";\n\t    strerror_r(errno, errStr, sizeof(errStr));\n\t    /* for now - continue logging these if they occur.... */\n\t    PJ_LOG(4,(\"SSL\", \"BIO error, SSL_ERROR_SYSCALL (%s): \"\n\t    \t\t     \"errno: <%d> <%s> len: %d\",\n\t\t      \t     action, errno, errStr, len));\n\t} else {\n\t    /* ret!=0 & ret!=-1 & nothing on error stack - is this valid??? */\n\t    PJ_LOG(2,(\"SSL\", \"SSL_ERROR_SYSCALL (%s) ret: %d len: %d\",\n\t\t      action, ret, len));\n\t}\n\tbreak;\n    }\n    case SSL_ERROR_SSL:\n    {\n\tunsigned long err2 = ERR_get_error();\n\tint level = 0;\n\n\twhile (err2) {\n\t    ERROR_LOG(\"SSL_ERROR_SSL\", err2, ssock);\n\t    level++;\n\t    err2 = ERR_get_error();\n\t}\n\tbreak;\n    }\n    default:\n\tPJ_LOG(2,(\"SSL\", \"%lu [%s] (%s) ret: %d len: %d\",\n\t\t  ssl_err, ssl_err_str, action, ret, len));\n\tbreak;\n    }\n}\n\n\nstatic pj_status_t GET_STATUS_FROM_SSL_ERR(unsigned long err)\n{\n    pj_status_t status;\n\n    /* OpenSSL error range is much wider than PJLIB errno space, so\n     * if it exceeds the space, only the error reason will be kept.\n     * Note that the last native error will be kept as is and can be\n     * retrieved via SSL socket info.\n     */\n    status = ERR_GET_LIB(err)*MAX_OSSL_ERR_REASON + ERR_GET_REASON(err);\n    if (status > PJ_SSL_ERRNO_SPACE_SIZE)\n\tstatus = ERR_GET_REASON(err);\n\n    status += PJ_SSL_ERRNO_START;\n    return status;\n}\n\n/* err contains ERR_get_error() status */\nstatic pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; //dummy\n\n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n\n    /* General SSL error, dig more from OpenSSL error queue */\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}\n\n/* err contains SSL_get_error() status */\nstatic pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}\n\nstatic pj_status_t GET_SSL_STATUS(pj_ssl_sock_t *ssock)\n{\n    return STATUS_FROM_SSL_ERR(\"status\", ssock, ERR_get_error());\n}\n\n\n/*\n * Get error string of OpenSSL.\n */\nstatic pj_str_t ssl_strerror(pj_status_t status, \n\t\t\t     char *buf, pj_size_t bufsize)\n{\n    pj_str_t errstr;\n    unsigned long ssl_err = status;\n\n    if (ssl_err) {\n\tunsigned long l, r;\n\tssl_err -= PJ_SSL_ERRNO_START;\n\tl = ssl_err / MAX_OSSL_ERR_REASON;\n\tr = ssl_err % MAX_OSSL_ERR_REASON;\n\tssl_err = ERR_PACK(l, 0, r);\n    }\n\n#if defined(PJ_HAS_ERROR_STRING) && (PJ_HAS_ERROR_STRING != 0)\n\n    {\n\tconst char *tmp = NULL;\n\ttmp = ERR_reason_error_string(ssl_err);\n\tif (tmp) {\n\t    pj_ansi_strncpy(buf, tmp, bufsize);\n\t    errstr = pj_str(buf);\n\t    return errstr;\n\t}\n    }\n\n#endif\t/* PJ_HAS_ERROR_STRING */\n\n    errstr.ptr = buf;\n    errstr.slen = pj_ansi_snprintf(buf, bufsize, \n\t\t\t\t   \"Unknown OpenSSL error %lu\",\n\t\t\t\t   ssl_err);\n    if (errstr.slen < 1 || errstr.slen >= (int)bufsize)\n\terrstr.slen = bufsize - 1;\n    return errstr;\n}\n\n/* Additional ciphers recognized by SSL_set_cipher_list()\n   but not returned from SSL_get_ciphers().\n   NOTE: ids are designed to not conflict with those from\n         SSL_get_cipher() which get masked to the lower 24\n         bits before use. \n*/\nstatic const struct ssl_ciphers_t ADDITIONAL_CIPHERS[] = {\n        {0xFF000000, \"DEFAULT\"},\n        {0xFF000001, \"@SECLEVEL=1\"},\n        {0xFF000002, \"@SECLEVEL=2\"},\n        {0xFF000003, \"@SECLEVEL=3\"},\n        {0xFF000004, \"@SECLEVEL=4\"},\n        {0xFF000005, \"@SECLEVEL=5\"}\n};\nstatic const unsigned int ADDITIONAL_CIPHER_COUNT = \n    sizeof (ADDITIONAL_CIPHERS) / sizeof (ADDITIONAL_CIPHERS[0]);\n\n/*\n *******************************************************************\n * I/O functions.\n *******************************************************************\n */\n\nstatic pj_bool_t io_empty(pj_ssl_sock_t *ssock, circ_buf_t *cb)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    PJ_UNUSED_ARG(cb);\n\n    return !BIO_pending(ossock->ossl_wbio);\n}\n\nstatic pj_size_t io_size(pj_ssl_sock_t *ssock, circ_buf_t *cb)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    char *data;\n\n    PJ_UNUSED_ARG(cb);\n\n    return BIO_get_mem_data(ossock->ossl_wbio, &data);\n}\n\nstatic void io_read(pj_ssl_sock_t *ssock, circ_buf_t *cb,\n\t\t    pj_uint8_t *dst, pj_size_t len)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    char *data;\n\n    PJ_UNUSED_ARG(cb);\n\n    BIO_get_mem_data(ossock->ossl_wbio, &data);\n    pj_memcpy(dst, data, len);\n\n    /* Reset write BIO */\n    (void)BIO_reset(ossock->ossl_wbio);\n}\n\nstatic pj_status_t io_write(pj_ssl_sock_t *ssock, circ_buf_t *cb,\n                            const pj_uint8_t *src, pj_size_t len)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int nwritten;\n\n    nwritten = BIO_write(ossock->ossl_rbio, src, (int)len);\n    return (nwritten < (int)len)? GET_SSL_STATUS(cb->owner): PJ_SUCCESS;\n}\n\n/*\n *******************************************************************\n */\n\n/* OpenSSL library initialization counter */\nstatic int openssl_init_count;\n\n/* OpenSSL application data index */\nstatic int sslsock_idx;\n\n#if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n    PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n/* Thread lock pool.*/\nstatic pj_caching_pool \t cp;\nstatic pj_pool_t \t*lock_pool;\n\n/* OpenSSL locking list. */\nstatic pj_lock_t **ossl_locks;\n\n/* OpenSSL number locks. */\nstatic unsigned ossl_num_locks;\n\n#if     OPENSSL_VERSION_NUMBER >= 0x10000000\nstatic void ossl_set_thread_id(CRYPTO_THREADID *id)\n{\n    CRYPTO_THREADID_set_numeric(id,\n                     (unsigned long)pj_thread_get_os_handle(pj_thread_this()));\n}\n\n#else\n\nstatic unsigned long ossl_thread_id(void)\n{\n    return ((unsigned long)pj_thread_get_os_handle(pj_thread_this()));\n}\n#endif\n\nstatic void ossl_lock(int mode, int id, const char *file, int line)\n{\n    PJ_UNUSED_ARG(file);\n    PJ_UNUSED_ARG(line);\n\n    if (openssl_init_count == 0)\n        return;\n\n    if (mode & CRYPTO_LOCK) {\n        if (ossl_locks[id]) {\n            //PJ_LOG(6, (THIS_FILE, \"Lock File (%s) Line(%d)\", file, line));\n            pj_lock_acquire(ossl_locks[id]);\n        }\n    } else {\n        if (ossl_locks[id]) {\n            //PJ_LOG(6, (THIS_FILE, \"Unlock File (%s) Line(%d)\", file, line));\n            pj_lock_release(ossl_locks[id]);\n        }\n    }\n}\n\nstatic void release_thread_cb(void)\n{\n    unsigned i = 0;\n\n#if     OPENSSL_VERSION_NUMBER >= 0x10000000\n    CRYPTO_THREADID_set_callback(NULL);\n#else\n    CRYPTO_set_id_callback(NULL);\n#endif\n    CRYPTO_set_locking_callback(NULL);\n\n    for (; i < ossl_num_locks; ++i) {\n        if (ossl_locks[i]) {\n            pj_lock_destroy(ossl_locks[i]);\n            ossl_locks[i] = NULL;\n        }\n    }\n    if (lock_pool) {\n        pj_pool_release(lock_pool);\n        lock_pool = NULL;\n        pj_caching_pool_destroy(&cp);\n    }\n    ossl_locks = NULL;\n    ossl_num_locks = 0;\n}\n\nstatic pj_status_t init_ossl_lock()\n{\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_caching_pool_init(&cp, NULL, 0);\n\n    lock_pool = pj_pool_create(&cp.factory,\n                               \"ossl-lock\",\n                               64,\n                               64,\n                               NULL);\n\n    if (!lock_pool) {\n        status = PJ_ENOMEM;\n        PJ_PERROR(1, (THIS_FILE, status,\"Fail creating OpenSSL lock pool\"));\n        pj_caching_pool_destroy(&cp);\n        return status;\n    }\n\n    ossl_num_locks = CRYPTO_num_locks();\n    ossl_locks = (pj_lock_t **)pj_pool_calloc(lock_pool,\n                                              ossl_num_locks,\n                                              sizeof(pj_lock_t*));\n\n    if (ossl_locks) {\n        unsigned i = 0;\n        for (; (i < ossl_num_locks) && (status == PJ_SUCCESS); ++i) {\n            status = pj_lock_create_simple_mutex(lock_pool, \"ossl_lock%p\",\n                                                 &ossl_locks[i]);\n        }\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(1, (THIS_FILE, status,\n                          \"Fail creating mutex for OpenSSL lock\"));\n            release_thread_cb();\n            return status;\n        }\n\n#if     OPENSSL_VERSION_NUMBER >= 0x10000000\n        CRYPTO_THREADID_set_callback(ossl_set_thread_id);\n#else\n        CRYPTO_set_id_callback(ossl_thread_id);\n#endif\n        CRYPTO_set_locking_callback(ossl_lock);\n        status = pj_atexit(&release_thread_cb);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(1, (THIS_FILE, status, \"Warning! Unable to set OpenSSL \"\n                          \"lock thread callback unrelease method.\"));\n        }\n    } else {\n        status = PJ_ENOMEM;\n        PJ_PERROR(1, (THIS_FILE, status,\"Fail creating OpenSSL locks\"));\n        release_thread_cb();\n    }\n    return status;\n}\n\n#endif\n\n/* Initialize OpenSSL */\nstatic pj_status_t init_openssl(void)\n{\n    pj_status_t status;\n\n    if (openssl_init_count)\n\treturn PJ_SUCCESS;\n\n    openssl_init_count = 1;\n\n    /* Register error subsystem */\n    status = pj_register_strerror(PJ_SSL_ERRNO_START, \n\t\t\t\t  PJ_SSL_ERRNO_SPACE_SIZE, \n\t\t\t\t  &ssl_strerror);\n    pj_assert(status == PJ_SUCCESS);\n\n    /* Init OpenSSL lib */\n#if USING_LIBRESSL || OPENSSL_VERSION_NUMBER < 0x10100000L\n    SSL_library_init();\n    SSL_load_error_strings();\n#else\n    OPENSSL_init_ssl(0, NULL);\n#endif\n#if OPENSSL_VERSION_NUMBER < 0x009080ffL\n    /* This is now synonym of SSL_library_init() */\n    OpenSSL_add_all_algorithms();\n#endif\n\n    /* Init available ciphers */\n    if (ssl_cipher_num == 0 || ssl_curves_num == 0) {\n\tSSL_METHOD *meth = NULL;\n\tSSL_CTX *ctx;\n\tSSL *ssl;\n\tSTACK_OF(SSL_CIPHER) *sk_cipher;\n\tSSL_SESSION *ssl_sess;\n\tunsigned i, n;\n\tint nid;\n\tconst char *cname;\n\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n\n\tmeth = (SSL_METHOD*)SSLv23_server_method();\n\tif (!meth)\n\t    meth = (SSL_METHOD*)TLSv1_server_method();\n#ifndef OPENSSL_NO_SSL3_METHOD\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv3_server_method();\n#endif\n#ifndef OPENSSL_NO_SSL2\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv2_server_method();\n#endif\n\n#else\n\t/* Specific version methods are deprecated in 1.1.0 */\n\tmeth = (SSL_METHOD*)TLS_method();\n#endif\n\n\tpj_assert(meth);\n\n\tctx=SSL_CTX_new(meth);\n\tSSL_CTX_set_cipher_list(ctx, \"ALL:COMPLEMENTOFALL\");\n\n\tssl = SSL_new(ctx);\n\n\tsk_cipher = SSL_get_ciphers(ssl);\n\n\tn = sk_SSL_CIPHER_num(sk_cipher);\n\tif (n > PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT)\n\t    n = PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT;\n\n\tfor (i = 0; i < n; ++i) {\n\t    const SSL_CIPHER *c;\n\t    c = sk_SSL_CIPHER_value(sk_cipher,i);\n\t    ssl_ciphers[i].id = (pj_ssl_cipher)\n\t\t\t\t    (pj_uint32_t)SSL_CIPHER_get_id(c) &\n\t\t\t\t    0x00FFFFFF;\n\t    ssl_ciphers[i].name = SSL_CIPHER_get_name(c);\n\t}\n\n\t/* Add cipher aliases not returned from SSL_get_ciphers() */\n\tfor (i = 0; i < ADDITIONAL_CIPHER_COUNT; ++i) {\n\t    ssl_ciphers[n++] = ADDITIONAL_CIPHERS[i];\n\t}\n\tssl_cipher_num = n;\n\n\tssl_sess = SSL_SESSION_new();\n\tSSL_set_session(ssl, ssl_sess);\n\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n    && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\tssl_curves_num = EC_get_builtin_curves(NULL, 0);\n#else\n\tssl_curves_num = SSL_get_shared_curve(ssl,-1);\n\n\tif (ssl_curves_num > PJ_ARRAY_SIZE(ssl_curves))\n\t    ssl_curves_num = PJ_ARRAY_SIZE(ssl_curves);\n#endif\n\n\tif( ssl_curves_num > 0 ) {\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\t    EC_builtin_curve * curves = NULL;\n\n\t    curves = OPENSSL_malloc((int)sizeof(*curves) * ssl_curves_num);\n\t    if (!EC_get_builtin_curves(curves, ssl_curves_num)) {\n\t\tOPENSSL_free(curves);\n\t\tcurves = NULL;\n\t\tssl_curves_num = 0;\n\t    }\n\n\t    n = ssl_curves_num;\n\t    ssl_curves_num = 0;\n\n\t    for (i = 0; i < n; i++) {\n\t\tnid = curves[i].nid;\n\n\t\tif ( 0 != get_cid_from_nid(nid) ) {\n\t\t    cname = OBJ_nid2sn(nid);\n\n\t\t    if (!cname)\n\t\t\tcname = OBJ_nid2sn(nid);\n\n\t\t    if (cname) {\n\t\t\tssl_curves[ssl_curves_num].id = get_cid_from_nid(nid);\n\t\t\tssl_curves[ssl_curves_num].name = cname;\n\n\t\t\tssl_curves_num++;\n\n\t\t\tif (ssl_curves_num >= PJ_SSL_SOCK_MAX_CURVES )\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if(curves)\n\t\tOPENSSL_free(curves);\n#else\n\tfor (i = 0; i < ssl_curves_num; i++) {\n\t    nid = SSL_get_shared_curve(ssl, i);\n\n\t    if (nid & TLSEXT_nid_unknown) {\n\t\tcname = \"curve unknown\";\n\t\tnid &= 0xFFFF;\n\t    } else {\n\t\tcname = EC_curve_nid2nist(nid);\n\t\tif (!cname)\n\t\t    cname = OBJ_nid2sn(nid);\n\t    }\n\n\t    ssl_curves[i].id   = get_cid_from_nid(nid);\n\t    ssl_curves[i].name = cname;\n\t}\n#endif\n\n\t}\n#else\n\tPJ_UNUSED_ARG(nid);\n\tPJ_UNUSED_ARG(cname);\n\tssl_curves_num = 0;\n#endif\n\n\tSSL_free(ssl);\n\n\t/* On OpenSSL 1.1.1, omitting SSL_SESSION_free() will cause \n\t * memory leak (e.g: as reported by Address Sanitizer). But using\n\t * SSL_SESSION_free() may cause crash (due to double free?) on 1.0.x.\n\t * As OpenSSL docs specifies to not calling SSL_SESSION_free() after\n\t * SSL_free(), perhaps it is safer to obey this, the leak amount seems\n\t * to be relatively small (<500 bytes) and should occur once only in\n\t * the library lifetime.\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n\tSSL_SESSION_free(ssl_sess);\n#endif\n\t */\n\n\tSSL_CTX_free(ctx);\n    }\n\n    /* Create OpenSSL application data index for SSL socket */\n    sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n\n#if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n    PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n    status = init_ossl_lock();\n    if (status != PJ_SUCCESS)\n        return status;\n#endif\n\n    return status;\n}\n\n/* Shutdown OpenSSL */\nstatic void shutdown_openssl(void)\n{\n    PJ_UNUSED_ARG(openssl_init_count);\n}\n\n/* SSL password callback. */\nstatic int password_cb(char *buf, int num, int rwflag, void *user_data)\n{\n    pj_ssl_cert_t *cert = (pj_ssl_cert_t*) user_data;\n\n    PJ_UNUSED_ARG(rwflag);\n\n    if(num < cert->privkey_pass.slen)\n\treturn 0;\n    \n    pj_memcpy(buf, cert->privkey_pass.ptr, cert->privkey_pass.slen);\n    return (int)cert->privkey_pass.slen;\n}\n\n\n/* SSL password callback. */\nstatic int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock;\n    SSL *ossl_ssl;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    pj_assert(ossl_ssl);\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    pj_assert(ssock);\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n\n    case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\n    case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\n    case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\n    case X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\n\tssock->verify_status |= PJ_SSL_CERT_EINVALID_FORMAT;\n\tbreak;\n\n    case X509_V_ERR_CERT_NOT_YET_VALID:\n    case X509_V_ERR_CERT_HAS_EXPIRED:\n\tssock->verify_status |= PJ_SSL_CERT_EVALIDITY_PERIOD;\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_CRL:\n    case X509_V_ERR_CRL_NOT_YET_VALID:\n    case X509_V_ERR_CRL_HAS_EXPIRED:\n    case X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\n    case X509_V_ERR_CRL_SIGNATURE_FAILURE:\n    case X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\n    case X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\n\tssock->verify_status |= PJ_SSL_CERT_ECRL_FAILURE;\n\tbreak;\t\n\n    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n    case X509_V_ERR_CERT_UNTRUSTED:\n    case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n\tssock->verify_status |= PJ_SSL_CERT_EUNTRUSTED;\n\tbreak;\t\n\n    case X509_V_ERR_CERT_SIGNATURE_FAILURE:\n    case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n    case X509_V_ERR_SUBJECT_ISSUER_MISMATCH:\n    case X509_V_ERR_AKID_SKID_MISMATCH:\n    case X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH:\n    case X509_V_ERR_KEYUSAGE_NO_CERTSIGN:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_MISMATCH;\n\tbreak;\n\n    case X509_V_ERR_CERT_REVOKED:\n\tssock->verify_status |= PJ_SSL_CERT_EREVOKED;\n\tbreak;\t\n\n    case X509_V_ERR_INVALID_PURPOSE:\n    case X509_V_ERR_CERT_REJECTED:\n    case X509_V_ERR_INVALID_CA:\n\tssock->verify_status |= PJ_SSL_CERT_EINVALID_PURPOSE;\n\tbreak;\n\n    case X509_V_ERR_CERT_CHAIN_TOO_LONG: /* not really used */\n    case X509_V_ERR_PATH_LENGTH_EXCEEDED:\n\tssock->verify_status |= PJ_SSL_CERT_ECHAIN_TOO_LONG;\n\tbreak;\n\n    /* Unknown errors */\n    case X509_V_ERR_OUT_OF_MEM:\n    default:\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    /* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\n    return preverify_ok;\n}\n\n/* Setting SSL sock cipher list */\nstatic pj_status_t set_cipher_list(pj_ssl_sock_t *ssock);\n/* Setting SSL sock curves list */\nstatic pj_status_t set_curves_list(pj_ssl_sock_t *ssock);\n/* Setting sigalgs list */\nstatic pj_status_t set_sigalgs(pj_ssl_sock_t *ssock);\n/* Setting entropy for rng */\nstatic void set_entropy(pj_ssl_sock_t *ssock);\n\n\nstatic pj_ssl_sock_t *ssl_alloc(pj_pool_t *pool)\n{\n    return (pj_ssl_sock_t *)PJ_POOL_ZALLOC_T(pool, ossl_sock_t);\n}\n\nstatic int xname_cmp(const X509_NAME * const *a, const X509_NAME * const *b) {\n  return X509_NAME_cmp(*a, *b);\n}\n\n/* Create and initialize new SSL context and instance */\nstatic pj_status_t ssl_create(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n#if !defined(OPENSSL_NO_DH)\n    BIO *bio;\n    DH *dh;\n    long options;\n#endif\n    SSL_METHOD *ssl_method = NULL;\n    SSL_CTX *ctx;\n    pj_uint32_t ssl_opt = 0;\n    pj_ssl_cert_t *cert;\n    int mode, rc;\n    pj_status_t status;\n        \n    pj_assert(ssock);\n\n    cert = ssock->cert;\n\n    /* Make sure OpenSSL library has been initialized */\n    init_openssl();\n\n    set_entropy(ssock);\n\n    if (ssock->param.proto == PJ_SSL_SOCK_PROTO_DEFAULT)\n\tssock->param.proto = PJ_SSL_SOCK_PROTO_SSL23;\n\n    /* Determine SSL method to use */\n    /* Specific version methods are deprecated since 1.1.0 */\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n    switch (ssock->param.proto) {\n    case PJ_SSL_SOCK_PROTO_TLS1:\n\tssl_method = (SSL_METHOD*)TLSv1_method();\n\tbreak;\n#ifndef OPENSSL_NO_SSL2\n    case PJ_SSL_SOCK_PROTO_SSL2:\n\tssl_method = (SSL_METHOD*)SSLv2_method();\n\tbreak;\n#endif\n#ifndef OPENSSL_NO_SSL3_METHOD\n    case PJ_SSL_SOCK_PROTO_SSL3:\n\tssl_method = (SSL_METHOD*)SSLv3_method();\n#endif\n\tbreak;\n    }\n#endif\n\n    if (!ssl_method) {\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n\tssl_method = (SSL_METHOD*)SSLv23_method();\n#else\n\tssl_method = (SSL_METHOD*)TLS_method();\n#endif\n\n#ifdef SSL_OP_NO_SSLv2\n\t/** Check if SSLv2 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL2)==0)?\n\t\t    SSL_OP_NO_SSLv2:0;\n#endif\n\n#ifdef SSL_OP_NO_SSLv3\n\t/** Check if SSLv3 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL3)==0)?\n\t\t    SSL_OP_NO_SSLv3:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1\n\t/** Check if TLSv1 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1)==0)?\n\t\t    SSL_OP_NO_TLSv1:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1_1\n\t/** Check if TLSv1_1 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1)==0)?\n\t\t    SSL_OP_NO_TLSv1_1:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1_2\n\t/** Check if TLSv1_2 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2)==0)?\n\t\t    SSL_OP_NO_TLSv1_2:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1_3\n\t/** Check if TLSv1_3 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_3)==0)?\n\t\t    SSL_OP_NO_TLSv1_3:0;\n#endif\n\n    }\n\n    /* Create SSL context */\n    ctx = SSL_CTX_new(ssl_method);\n    if (ctx == NULL) {\n\treturn GET_SSL_STATUS(ssock);\n    }\n    ossock->ossl_ctx = ctx;\n\n    if (ssl_opt)\n\tSSL_CTX_set_options(ctx, ssl_opt);\n\n    /* Set cipher list */\n    status = set_cipher_list(ssock);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Apply credentials */\n    if (cert) {\n\t/* Load CA list if one is specified. */\n\tif (cert->CA_file.slen || cert->CA_path.slen) {\n\n\t    rc = SSL_CTX_load_verify_locations(\n\t\t\tctx,\n\t\t\tcert->CA_file.slen == 0 ? NULL : cert->CA_file.ptr,\n\t\t\tcert->CA_path.slen == 0 ? NULL : cert->CA_path.ptr);\n\n\t    if (rc != 1) {\n\t\tstatus = GET_SSL_STATUS(ssock);\n\t\tif (cert->CA_file.slen) {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t\t \"Error loading CA list file '%s'\",\n\t\t\t\t cert->CA_file.ptr));\n\t\t}\n\t\tif (cert->CA_path.slen) {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t\t \"Error loading CA path '%s'\",\n\t\t\t\t cert->CA_path.ptr));\n\t\t}\n\t\tSSL_CTX_free(ctx);\n\t\treturn status;\n\t    } else {\n\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t  \"CA certificates loaded from '%s%s%s'\",\n\t\t\t  cert->CA_file.ptr,\n\t\t\t  ((cert->CA_file.slen && cert->CA_path.slen)?\n\t\t\t\t\" + \":\"\"),\n\t\t\t  cert->CA_path.ptr));\n\t    }\n\t}\n    \n\t/* Set password callback */\n\tif (cert->privkey_pass.slen) {\n\t    SSL_CTX_set_default_passwd_cb(ctx, password_cb);\n\t    SSL_CTX_set_default_passwd_cb_userdata(ctx, cert);\n\t}\n\n\n\t/* Load certificate if one is specified */\n\tif (cert->cert_file.slen) {\n\n\t    /* Load certificate chain from file into ctx */\n\t    rc = SSL_CTX_use_certificate_chain_file(ctx, cert->cert_file.ptr);\n\n\t    if(rc != 1) {\n\t\tstatus = GET_SSL_STATUS(ssock);\n\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t     \"Error loading certificate chain file '%s'\",\n\t\t\t     cert->cert_file.ptr));\n\t\tSSL_CTX_free(ctx);\n\t\treturn status;\n\t    } else {\n\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t  \"Certificate chain loaded from '%s'\",\n\t\t\t  cert->cert_file.ptr));\n\t    }\n\t}\n\n\n\t/* Load private key if one is specified */\n\tif (cert->privkey_file.slen) {\n\t    /* Adds the first private key found in file to ctx */\n\t    rc = SSL_CTX_use_PrivateKey_file(ctx, cert->privkey_file.ptr, \n\t\t\t\t\t     SSL_FILETYPE_PEM);\n\n\t    if(rc != 1) {\n\t\tstatus = GET_SSL_STATUS(ssock);\n\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t     \"Error adding private key from '%s'\",\n\t\t\t     cert->privkey_file.ptr));\n\t\tSSL_CTX_free(ctx);\n\t\treturn status;\n\t    } else {\n\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t  \"Private key loaded from '%s'\",\n\t\t\t  cert->privkey_file.ptr));\n\t    }\n\n#if !defined(OPENSSL_NO_DH)\n\t    if (ssock->is_server) {\n\t\tbio = BIO_new_file(cert->privkey_file.ptr, \"r\");\n\t\tif (bio != NULL) {\n\t\t    dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\t\t    if (dh != NULL) {\n\t\t\tif (SSL_CTX_set_tmp_dh(ctx, dh)) {\n\t\t\t    options = SSL_OP_CIPHER_SERVER_PREFERENCE |\n    #if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x10000000L\n\t\t\t\t      SSL_OP_SINGLE_ECDH_USE |\n    #endif\n\t\t\t\t      SSL_OP_SINGLE_DH_USE;\n\t\t\t    options = SSL_CTX_set_options(ctx, options);\n\t\t\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL DH \"\n\t\t\t\t     \"initialized, PFS cipher-suites enabled\"));\n\t\t\t}\n\t\t\tDH_free(dh);\n\t\t    }\n\t\t    BIO_free(bio);\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/* Load from buffer. */\n\tif (cert->cert_buf.slen) {\n\t    BIO *cbio;\n\t    X509 *xcert = NULL;\n\t    \n\t    cbio = BIO_new_mem_buf((void*)cert->cert_buf.ptr,\n\t\t\t\t   cert->cert_buf.slen);\n\t    if (cbio != NULL) {\n\t\txcert = PEM_read_bio_X509(cbio, NULL, 0, NULL);\n\t\tif (xcert != NULL) {\n\t\t    rc = SSL_CTX_use_certificate(ctx, xcert);\n\t\t    if (rc != 1) {\n\t\t\tstatus = GET_SSL_STATUS(ssock);\n\t\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t      \"Error loading chain certificate from buffer\"));\n\t\t\tX509_free(xcert);\n\t\t\tBIO_free(cbio);\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn status;\n\t\t    } else {\n\t\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t\t  \"Certificate chain loaded from buffer\"));\n\t\t    }\n\t\t    X509_free(xcert);\n\t\t}\n\t\tBIO_free(cbio);\n\t    }\t    \n\t}\n\n\tif (cert->CA_buf.slen) {\n\t    BIO *cbio = BIO_new_mem_buf((void*)cert->CA_buf.ptr,\n\t\t\t\t\tcert->CA_buf.slen);\n\t    X509_STORE *cts = SSL_CTX_get_cert_store(ctx);\n\n\t    if (cbio && cts) {\n\t\tSTACK_OF(X509_INFO) *inf = PEM_X509_INFO_read_bio(cbio, NULL, \n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n\t\tif (inf != NULL) {\n\t\t    int i = 0, cnt = 0;\n\t\t    for (; i < sk_X509_INFO_num(inf); i++) {\n\t\t\tX509_INFO *itmp = sk_X509_INFO_value(inf, i);\n\t\t\tif (!itmp->x509)\n\t\t\t    continue;\n\n\t\t\trc = X509_STORE_add_cert(cts, itmp->x509);\n\t\t\tif (rc == 1) {\n\t\t\t    ++cnt;\n\t\t\t} else {\n#if PJ_LOG_MAX_LEVEL >= 4\n\t\t\t    char buf[256];\n\t\t\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t\t      \"Error adding CA cert: %s\",\n\t\t\t\t      X509_NAME_oneline(\n\t\t\t\t\tX509_get_subject_name(itmp->x509),\n\t\t\t\t\tbuf, sizeof(buf))));\n#endif\n\t\t\t}\n\t\t    }\n\t\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t      \"CA certificates loaded from buffer (cnt=%d)\",\n\t\t\t      cnt));\n\t\t}\n\t\tsk_X509_INFO_pop_free(inf, X509_INFO_free);\n\t\tBIO_free(cbio);\n\t    }\n\t}\n\n\tif (cert->privkey_buf.slen) {\n\t    BIO *kbio;\t    \n\t    EVP_PKEY *pkey = NULL;\n\n\t    kbio = BIO_new_mem_buf((void*)cert->privkey_buf.ptr,\n\t\t\t\t   cert->privkey_buf.slen);\n\t    if (kbio != NULL) {\n\t\tpkey = PEM_read_bio_PrivateKey(kbio, NULL, &password_cb,\n\t\t\t\t\t       cert);\n\t\tif (pkey) {\n\t\t    rc = SSL_CTX_use_PrivateKey(ctx, pkey);\n\t\t    if (rc != 1) {\n\t\t\tstatus = GET_SSL_STATUS(ssock);\n\t\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t\t     \"Error adding private key from buffer\"));\n\t\t\tEVP_PKEY_free(pkey);\n\t\t\tBIO_free(kbio);\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn status;\n\t\t    } else {\n\t\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t\t  \"Private key loaded from buffer\"));\n\t\t    }\n\t\t    EVP_PKEY_free(pkey);\n\t\t} else {\n\t\t    PJ_LOG(1,(ssock->pool->obj_name,\n\t\t\t      \"Error reading private key from buffer\"));\n\t\t}\n\n\t\tif (ssock->is_server) {\n\t\t    dh = PEM_read_bio_DHparams(kbio, NULL, NULL, NULL);\n\t\t    if (dh != NULL) {\n\t\t\tif (SSL_CTX_set_tmp_dh(ctx, dh)) {\n\t\t\t    options = SSL_OP_CIPHER_SERVER_PREFERENCE |\n    #if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x10000000L\n\t\t\t\t      SSL_OP_SINGLE_ECDH_USE |\n    #endif\n\t\t\t\t      SSL_OP_SINGLE_DH_USE;\n\t\t\t    options = SSL_CTX_set_options(ctx, options);\n\t\t\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL DH \"\n\t\t\t\t     \"initialized, PFS cipher-suites enabled\"));\n\t\t\t}\n\t\t\tDH_free(dh);\n\t\t    }\n\t\t}\n\t\tBIO_free(kbio);\n\t    }\t    \n\t}\n    }\n\n    if (ssock->is_server) {\n\tchar *p = NULL;\n\n\t/* If certificate file name contains \"_rsa.\", let's check if there are\n\t * ecc and dsa certificates too.\n\t */\n\tif (cert && cert->cert_file.slen) {\n\t    const pj_str_t RSA = {\"_rsa.\", 5};\n\t    p = pj_strstr(&cert->cert_file, &RSA);\n\t    if (p) p++; /* Skip underscore */\n\t}\n\tif (p) {\n\t    /* Certificate type string length must be exactly 3 */\n\t    enum { CERT_TYPE_LEN = 3 };\n\t    const char* cert_types[] = { \"ecc\", \"dsa\" };\n\t    char *cf = cert->cert_file.ptr;\n\t    int i;\n\n\t    /* Check and load ECC & DSA certificates & private keys */\n\t    for (i = 0; i < PJ_ARRAY_SIZE(cert_types); ++i) {\n\t\tint err;\n\n\t\tpj_memcpy(p, cert_types[i], CERT_TYPE_LEN);\n\t\tif (!pj_file_exists(cf))\n\t\t    continue;\n\n\t\terr = SSL_CTX_use_certificate_chain_file(ctx, cf);\n\t\tif (err == 1)\n\t\t    err = SSL_CTX_use_PrivateKey_file(ctx, cf,\n\t\t\t\t\t\t      SSL_FILETYPE_PEM);\n\t\tif (err == 1) {\n\t\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t      \"Additional certificate '%s' loaded.\", cf));\n\t\t} else {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, GET_SSL_STATUS(ssock),\n\t\t\t\t \"Error loading certificate file '%s'\", cf));\n\t\t    ERR_clear_error();\n\t\t}\n\t    }\n\n\t    /* Put back original name */\n\t    pj_memcpy(p, \"rsa\", CERT_TYPE_LEN);\n\t}\n\n    #ifndef SSL_CTRL_SET_ECDH_AUTO\n\t#define SSL_CTRL_SET_ECDH_AUTO 94\n    #endif\n\n\t/* SSL_CTX_set_ecdh_auto(ctx,on) requires OpenSSL 1.0.2 which wraps: */\n\tif (SSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, 1, NULL)) {\n\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL ECDH initialized \"\n\t\t      \"(automatic), faster PFS ciphers enabled\"));\n    #if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n\tOPENSSL_VERSION_NUMBER < 0x10100000L\n\t} else {\n\t    /* enables AES-128 ciphers, to get AES-256 use NID_secp384r1 */\n\t    EC_KEY *ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\t    if (ecdh != NULL) {\n\t\tif (SSL_CTX_set_tmp_ecdh(ctx, ecdh)) {\n\t\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL ECDH initialized \"\n\t\t\t      \"(secp256r1), faster PFS cipher-suites enabled\"));\n\t\t}\n\t\tEC_KEY_free(ecdh);\n\t    }\n    #endif\n\t}\n    } else {\n\tX509_STORE *pkix_validation_store = SSL_CTX_get_cert_store(ctx);\n\tif (NULL != pkix_validation_store) {\n#if defined(X509_V_FLAG_TRUSTED_FIRST)\n\t    X509_STORE_set_flags(pkix_validation_store, \n\t\t\t\t X509_V_FLAG_TRUSTED_FIRST);\n#endif\n#if defined(X509_V_FLAG_PARTIAL_CHAIN)\n\t    X509_STORE_set_flags(pkix_validation_store, \n\t\t\t\t X509_V_FLAG_PARTIAL_CHAIN);\n#endif\n\t}\n    }\n\n    /* Add certificate authorities for clients from CA.\n     * Needed for certificate request during handshake.\n     */\n    if (cert && ssock->is_server) {\n        STACK_OF(X509_NAME) *ca_dn = NULL;\n\n        if (cert->CA_file.slen > 0) {\n            ca_dn = SSL_load_client_CA_file(cert->CA_file.ptr);\n        } else if (cert->CA_buf.slen > 0) {\n            X509      *x  = NULL;\n            X509_NAME *xn = NULL;\n            STACK_OF(X509_NAME) *sk = NULL;\n            BIO *new_bio = BIO_new_mem_buf((void*)cert->CA_buf.ptr,\n\t\t\t\t\t   cert->CA_buf.slen);\n\n            sk = sk_X509_NAME_new(xname_cmp);\n\n            if (sk != NULL && new_bio != NULL) {\n                for (;;) {\n                    if (PEM_read_bio_X509(new_bio, &x, NULL, NULL) == NULL)\n                        break;\n\n                    if ((xn = X509_get_subject_name(x)) == NULL)\n                        break;\n\n                    if ((xn = X509_NAME_dup(xn)) == NULL )\n                        break;\n\n                    if (sk_X509_NAME_find(sk, xn) >= 0) {\n                        X509_NAME_free(xn);\n                    } else {\n                        sk_X509_NAME_push(sk, xn);\n                    }\n                    X509_free(x);\n                    x = NULL;\n                }\n            }\n            if (sk != NULL)\n            \tca_dn = sk;\n            if (new_bio != NULL)\n                BIO_free(new_bio);\n        }\n\n\tif (ca_dn != NULL) {\n\t    SSL_CTX_set_client_CA_list(ctx, ca_dn);\n\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t      \"CA certificates loaded from %s\",\n\t\t      (cert->CA_file.slen?cert->CA_file.ptr:\"buffer\")));\n\t} else {\n\t    PJ_LOG(1,(ssock->pool->obj_name,\n\t\t      \"Error reading CA certificates from %s\",\n\t\t      (cert->CA_file.slen?cert->CA_file.ptr:\"buffer\")));\n\t}\n    }\n\n    /* Early sensitive data cleanup after OpenSSL context setup. However,\n     * this cannot be done for listener sockets, as the data will still\n     * be needed by accepted sockets.\n     */\n    if (cert && (!ssock->is_server || ssock->parent)) {\n\tpj_ssl_cert_wipe_keys(cert);\t\n    }\n\n    /* Create SSL instance */\n    ossock->ossl_ssl = SSL_new(ossock->ossl_ctx);\n    if (ossock->ossl_ssl == NULL) {\n\treturn GET_SSL_STATUS(ssock);\n    }\n\n    /* Set SSL sock as application data of SSL instance */\n    SSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, ssock);\n\n    /* SSL verification options */\n    mode = SSL_VERIFY_PEER;\n    if (ssock->is_server && ssock->param.require_client_cert)\n\tmode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n    SSL_set_verify(ossock->ossl_ssl, mode, &verify_cb);\n\n    /* Set curve list */\n    status = set_curves_list(ssock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set sigalg list */\n    status = set_sigalgs(ssock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Setup SSL BIOs */\n    ossock->ossl_rbio = BIO_new(BIO_s_mem());\n    ossock->ossl_wbio = BIO_new(BIO_s_mem());\n    (void)BIO_set_close(ossock->ossl_rbio, BIO_CLOSE);\n    (void)BIO_set_close(ossock->ossl_wbio, BIO_CLOSE);\n    SSL_set_bio(ossock->ossl_ssl, ossock->ossl_rbio, ossock->ossl_wbio);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Destroy SSL context and instance */\nstatic void ssl_destroy(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    /* Destroy SSL instance */\n    if (ossock->ossl_ssl) {\n\tSSL_free(ossock->ossl_ssl); /* this will also close BIOs */\n\tossock->ossl_ssl = NULL;\n    }\n\n    /* Destroy SSL context */\n    if (ossock->ossl_ctx) {\n\tSSL_CTX_free(ossock->ossl_ctx);\n\tossock->ossl_ctx = NULL;\n    }\n\n    /* Potentially shutdown OpenSSL library if this is the last\n     * context exists.\n     */\n    shutdown_openssl();\n}\n\n\n/* Reset SSL socket state */\nstatic void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    /**\n     * Avoid calling SSL_shutdown() if handshake wasn't completed.\n     * OpenSSL 1.0.2f complains if SSL_shutdown() is called during an\n     * SSL handshake, while previous versions always return 0.\n     */\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    /* Flush data to send close notify. */\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n\n    ssl_close_sockets(ssock);\n\n    /* Upon error, OpenSSL may leave any error description in the thread \n     * error queue, which sometime may cause next call to SSL API returning\n     * false error alarm, e.g: in Linux, SSL_CTX_use_certificate_chain_file()\n     * returning false error after a handshake error (in different SSL_CTX!).\n     * For now, just clear thread error queue here.\n     */\n    ERR_clear_error();\n}\n\n\nstatic void ssl_ciphers_populate()\n{\n    if (ssl_cipher_num == 0 || ssl_curves_num == 0) {\n\tinit_openssl();\n\tshutdown_openssl();\n    }\n}\n\nstatic pj_ssl_cipher ssl_get_cipher(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    const SSL_CIPHER *cipher;\n\n    /* Current cipher */\n    cipher = SSL_get_current_cipher(ossock->ossl_ssl);\n    if (cipher) {\n\treturn (SSL_CIPHER_get_id(cipher) & 0x00FFFFFF);\n    } else {\n\treturn PJ_TLS_UNKNOWN_CIPHER;\n    }\n}\n\n/* Generate cipher list with user preference order in OpenSSL format */\nstatic pj_status_t set_cipher_list(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_pool_t *tmp_pool = NULL;\n    char *buf = NULL;\n    enum { BUF_SIZE = 8192 };\n    pj_str_t cipher_list;\n    unsigned i, j;\n    int ret;\n\n    if (ssock->param.ciphers_num == 0) {\n\tret = SSL_CTX_set_cipher_list(ossock->ossl_ctx, PJ_SSL_SOCK_OSSL_CIPHERS);\n    \tif (ret < 1) {\n\t    return GET_SSL_STATUS(ssock);\n    \t}    \n\t\n\treturn PJ_SUCCESS;\n    }\n\n    /* Create temporary pool. */\n    tmp_pool = pj_pool_create(ssock->pool->factory, \"ciphpool\", BUF_SIZE, \n\t\t\t      BUF_SIZE/2 , NULL);\n    if (!tmp_pool)\n\treturn PJ_ENOMEM;\n\n    buf = (char *)pj_pool_zalloc(tmp_pool, BUF_SIZE);\n\n    pj_strset(&cipher_list, buf, 0);\n\n    /* Generate user specified cipher list in OpenSSL format */\n    for (i = 0; i < ssock->param.ciphers_num; ++i) {\n\tfor (j = 0; j < ssl_cipher_num; ++j) {\n\t    if (ssock->param.ciphers[i] == ssl_ciphers[j].id)\n\t    {\n\t\tconst char *c_name = ssl_ciphers[j].name;\n\n\t\t/* Check buffer size */\n\t\tif (cipher_list.slen + pj_ansi_strlen(c_name) + 2 >\n\t\t    BUF_SIZE)\n\t\t{\n\t\t    pj_assert(!\"Insufficient temporary buffer for cipher\");\n\t\t    return PJ_ETOOMANY;\n\t\t}\n\n\t\t/* Add colon separator */\n\t\tif (cipher_list.slen)\n\t\t    pj_strcat2(&cipher_list, \":\");\n\n\t\t/* Add the cipher */\n\t\tpj_strcat2(&cipher_list, c_name);\n\t\tbreak;\n\t    }\n\t}\t\n    }\n\n    /* Put NULL termination in the generated cipher list */\n    cipher_list.ptr[cipher_list.slen] = '\\0';\n\n    /* Finally, set chosen cipher list */\n    ret = SSL_CTX_set_cipher_list(ossock->ossl_ctx, buf);\n    if (ret < 1) {\n\tpj_pool_release(tmp_pool);\n\treturn GET_SSL_STATUS(ssock);\n    }\n\n    pj_pool_release(tmp_pool);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t set_curves_list(pj_ssl_sock_t *ssock)\n{\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n    && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int ret;\n    int curves[PJ_SSL_SOCK_MAX_CURVES];\n    unsigned cnt;\n\n    if (ssock->param.curves_num == 0)\n\treturn PJ_SUCCESS;\n\n    for (cnt = 0; cnt < ssock->param.curves_num; cnt++) {\n\tcurves[cnt] = get_nid_from_cid(ssock->param.curves[cnt]);\n    }\n\n    if( SSL_is_server(ossock->ossl_ssl) ) {\n\tret = SSL_set1_curves(ossock->ossl_ssl, curves,\n\t\t\t      ssock->param.curves_num);\n\tif (ret < 1)\n\t    return GET_SSL_STATUS(ssock);\n    } else {\n\tret = SSL_CTX_set1_curves(ossock->ossl_ctx, curves,\n\t\t\t\t  ssock->param.curves_num);\n\tif (ret < 1)\n\t    return GET_SSL_STATUS(ssock);\n    }\n#else\n    PJ_UNUSED_ARG(ssock);\n#endif\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t set_sigalgs(pj_ssl_sock_t *ssock)\n{\n#if !USING_LIBRESSL && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int ret;\n\n    if (ssock->param.sigalgs.ptr && ssock->param.sigalgs.slen) {\n\tif (ssock->is_server) {\n\t    ret = SSL_set1_client_sigalgs_list(ossock->ossl_ssl,\n\t    \t\t\t\t       ssock->param.sigalgs.ptr);\n\t} else {\n\t    ret = SSL_set1_sigalgs_list(ossock->ossl_ssl,\n\t    \t\t\t\tssock->param.sigalgs.ptr);\n\t}\n\n\tif (ret < 1)\n\t    return GET_SSL_STATUS(ssock);\n    }\n#else\n    PJ_UNUSED_ARG(ssock);\n#endif\n    return PJ_SUCCESS;\n}\n\nstatic void set_entropy(pj_ssl_sock_t *ssock)\n{\n    int ret = 0;\n\n    switch (ssock->param.entropy_type) {\n#ifndef OPENSSL_NO_EGD\n\tcase PJ_SSL_ENTROPY_EGD:\n\t    ret = RAND_egd(ssock->param.entropy_path.ptr);\n\t    break;\n#endif\n\tcase PJ_SSL_ENTROPY_RANDOM:\n\t    ret = RAND_load_file(\"/dev/random\",255);\n\t    break;\n\tcase PJ_SSL_ENTROPY_URANDOM:\n\t    ret = RAND_load_file(\"/dev/urandom\",255);\n\t    break;\n\tcase PJ_SSL_ENTROPY_FILE:\n\t    ret = RAND_load_file(ssock->param.entropy_path.ptr,255);\n\t    break;\n\tcase PJ_SSL_ENTROPY_NONE:\n\tdefault:\n\t    break;\n    }\n\n    if (ret < 0) {\n\tPJ_LOG(3, (ssock->pool->obj_name,\n\t\t   \"SSL failed to reseed with entropy type %d \"\n\t\t   \"[native err=%d]\",\n\t\t   ssock->param.entropy_type, ret));\n    }\n}\n\n/* Parse OpenSSL ASN1_TIME to pj_time_val and GMT info */\nstatic pj_bool_t parse_ossl_asn1_time(pj_time_val *tv, pj_bool_t *gmt,\n\t\t\t\t      const ASN1_TIME *tm)\n{\n    unsigned long parts[7] = {0};\n    char *p, *end;\n    unsigned len;\n    pj_bool_t utc;\n    pj_parsed_time pt;\n    int i;\n\n    utc = tm->type == V_ASN1_UTCTIME;\n    p = (char*)tm->data;\n    len = tm->length;\n    end = p + len - 1;\n\n    /* GMT */\n    *gmt = (*end == 'Z');\n\n    /* parse parts */\n    for (i = 0; i < 7 && p < end; ++i) {\n\tpj_str_t st;\n\n\tif (i==0 && !utc) {\n\t    /* 4 digits year part for non-UTC time format */\n\t    st.slen = 4;\n\t} else if (i==6) {\n\t    /* fraction of seconds */\n\t    if (*p == '.') ++p;\n\t    st.slen = end - p + 1;\n\t} else {\n\t    /* other parts always 2 digits length */\n\t    st.slen = 2;\n\t}\n\tst.ptr = p;\n\n\tparts[i] = pj_strtoul(&st);\n\tp += st.slen;\n    }\n\n    /* encode parts to pj_time_val */\n    pt.year = parts[0];\n    if (utc)\n\tpt.year += (pt.year < 50)? 2000:1900;\n    pt.mon = parts[1] - 1;\n    pt.day = parts[2];\n    pt.hour = parts[3];\n    pt.min = parts[4];\n    pt.sec = parts[5];\n    pt.msec = parts[6];\n\n    pj_time_encode(&pt, tv);\n\n    return PJ_TRUE;\n}\n\n\n/* Get Common Name field string from a general name string */\nstatic void get_cn_from_gen_name(const pj_str_t *gen_name, pj_str_t *cn)\n{\n    pj_str_t CN_sign = {\"/CN=\", 4};\n    char *p, *q;\n\n    pj_bzero(cn, sizeof(pj_str_t));\n\n    if (!gen_name->slen)\n\treturn;\n\n    p = pj_strstr(gen_name, &CN_sign);\n    if (!p)\n\treturn;\n\n    p += 4; /* shift pointer to value part */\n    pj_strset(cn, p, gen_name->slen - (p - gen_name->ptr));\n    q = pj_strchr(cn, '/');\n    if (q)\n\tcn->slen = q - p;\n}\n\n\n/* Get certificate info from OpenSSL X509, in case the certificate info\n * hal already populated, this function will check if the contents need \n * to be updated by inspecting the issuer and the serial number.\n */\nstatic void get_cert_info(pj_pool_t *pool, pj_ssl_cert_info *ci, X509 *x,\n\t\t\t  pj_bool_t get_pem)\n{\n    pj_bool_t update_needed;\n    char buf[512];\n    pj_uint8_t serial_no[64] = {0}; /* should be >= sizeof(ci->serial_no) */\n    const pj_uint8_t *q;\n    unsigned len;\n    GENERAL_NAMES *names = NULL;\n\n    pj_assert(pool && ci && x);\n\n    /* Get issuer */\n    X509_NAME_oneline(X509_get_issuer_name(x), buf, sizeof(buf));\n\n    /* Get serial no */\n    q = (const pj_uint8_t*) M_ASN1_STRING_data(X509_get_serialNumber(x));\n    len = M_ASN1_STRING_length(X509_get_serialNumber(x));\n    if (len > sizeof(ci->serial_no)) \n\tlen = sizeof(ci->serial_no);\n    pj_memcpy(serial_no + sizeof(ci->serial_no) - len, q, len);\n\n    /* Check if the contents need to be updated. */\n    update_needed = pj_strcmp2(&ci->issuer.info, buf) || \n\t            pj_memcmp(ci->serial_no, serial_no, sizeof(ci->serial_no));\n    if (!update_needed)\n\treturn;\n\n    /* Update cert info */\n\n    pj_bzero(ci, sizeof(pj_ssl_cert_info));\n\n    /* Version */\n    ci->version = X509_get_version(x) + 1;\n\n    /* Issuer */\n    pj_strdup2(pool, &ci->issuer.info, buf);\n    get_cn_from_gen_name(&ci->issuer.info, &ci->issuer.cn);\n\n    /* Serial number */\n    pj_memcpy(ci->serial_no, serial_no, sizeof(ci->serial_no));\n\n    /* Subject */\n    pj_strdup2(pool, &ci->subject.info, \n\t       X509_NAME_oneline(X509_get_subject_name(x),\n\t\t\t\t buf, sizeof(buf)));\n    get_cn_from_gen_name(&ci->subject.info, &ci->subject.cn);\n\n    /* Validity */\n    parse_ossl_asn1_time(&ci->validity.start, &ci->validity.gmt,\n\t\t\t X509_get_notBefore(x));\n    parse_ossl_asn1_time(&ci->validity.end, &ci->validity.gmt,\n\t\t\t X509_get_notAfter(x));\n\n    /* Subject Alternative Name extension */\n    if (ci->version >= 3) {\n\tnames = (GENERAL_NAMES*) X509_get_ext_d2i(x, NID_subject_alt_name,\n\t\t\t\t\t\t  NULL, NULL);\n    }\n    if (names) {\n        unsigned i, cnt;\n\n        cnt = sk_GENERAL_NAME_num(names);\n\tci->subj_alt_name.entry = pj_pool_calloc(pool, cnt, \n\t\t\t\t\t    sizeof(*ci->subj_alt_name.entry));\n\n        for (i = 0; i < cnt; ++i) {\n\t    unsigned char *p = 0;\n\t    pj_ssl_cert_name_type type = PJ_SSL_CERT_NAME_UNKNOWN;\n            const GENERAL_NAME *name;\n\t    \n\t    name = sk_GENERAL_NAME_value(names, i);\n\n            switch (name->type) {\n                case GEN_EMAIL:\n                    len = ASN1_STRING_to_UTF8(&p, name->d.ia5);\n\t\t    type = PJ_SSL_CERT_NAME_RFC822;\n                    break;\n                case GEN_DNS:\n                    len = ASN1_STRING_to_UTF8(&p, name->d.ia5);\n\t\t    type = PJ_SSL_CERT_NAME_DNS;\n                    break;\n                case GEN_URI:\n                    len = ASN1_STRING_to_UTF8(&p, name->d.ia5);\n\t\t    type = PJ_SSL_CERT_NAME_URI;\n                    break;\n                case GEN_IPADD:\n\t\t    p = (unsigned char*)M_ASN1_STRING_data(name->d.ip);\n\t\t    len = M_ASN1_STRING_length(name->d.ip);\n\t\t    type = PJ_SSL_CERT_NAME_IP;\n                    break;\n\t\tdefault:\n\t\t    break;\n            }\n\n\t    if (p && len && type != PJ_SSL_CERT_NAME_UNKNOWN) {\n\t\tci->subj_alt_name.entry[ci->subj_alt_name.cnt].type = type;\n\t\tif (type == PJ_SSL_CERT_NAME_IP) {\n\t\t    int af = pj_AF_INET();\n\t\t    if (len == sizeof(pj_in6_addr)) af = pj_AF_INET6();\n\t\t    pj_inet_ntop2(af, p, buf, sizeof(buf));\n\t\t    pj_strdup2(pool, \n\t\t          &ci->subj_alt_name.entry[ci->subj_alt_name.cnt].name,\n\t\t          buf);\n\t\t} else {\n\t\t    pj_strdup2(pool, \n\t\t\t  &ci->subj_alt_name.entry[ci->subj_alt_name.cnt].name, \n\t\t\t  (char*)p);\n\t\t    OPENSSL_free(p);\n\t\t}\n\t\tci->subj_alt_name.cnt++;\n\t    }\n        }\n        GENERAL_NAMES_free(names);\n        names = NULL;\n    }\n\n    if (get_pem) {\n\t/* Update raw Certificate info in PEM format. */\n\tBIO *bio;\t\n\tBUF_MEM *ptr;\n\t\n\tbio = BIO_new(BIO_s_mem());\n\tif (!PEM_write_bio_X509(bio, x)) {\n\t    PJ_LOG(3,(THIS_FILE, \"Error retrieving raw certificate info\"));\n\t    ci->raw.ptr = NULL;\n\t    ci->raw.slen = 0;\n\t} else {\n\t    BIO_write(bio, \"\\0\", 1);\n\t    BIO_get_mem_ptr(bio, &ptr);\n\t    pj_strdup2(pool, &ci->raw, ptr->data);\t\n\t}\t\n\tBIO_free(bio);\t    \n    }\t \n}\n\n/* Update remote certificates chain info. This function should be\n * called after handshake or renegotiation successfully completed.\n */\nstatic void ssl_update_remote_cert_chain_info(pj_pool_t *pool,\n\t\t\t\t\t      pj_ssl_cert_info *ci,\n\t\t\t\t\t      STACK_OF(X509) *chain,\n\t\t\t\t\t      pj_bool_t get_pem)\n{\n    int i;\n\n    /* For now, get_pem has to be PJ_TRUE */\n    pj_assert(get_pem);\n    PJ_UNUSED_ARG(get_pem);\n\n    ci->raw_chain.cert_raw = (pj_str_t *)pj_pool_calloc(pool,\n       \t\t\t\t    \t\t\tsk_X509_num(chain),\n       \t\t\t\t    \t\t\tsizeof(pj_str_t));\n    ci->raw_chain.cnt = sk_X509_num(chain);\n\n    for (i = 0; i < sk_X509_num(chain); i++) {\n        BIO *bio;\n        BUF_MEM *ptr;\n\tX509 *x = sk_X509_value(chain, i);\n\n        bio = BIO_new(BIO_s_mem());\n        \n        if (!PEM_write_bio_X509(bio, x)) {\n            PJ_LOG(3, (THIS_FILE, \"Error retrieving raw certificate info\"));\n            ci->raw_chain.cert_raw[i].ptr  = NULL;\n            ci->raw_chain.cert_raw[i].slen = 0;\n        } else {\n            BIO_write(bio, \"\\0\", 1);\n            BIO_get_mem_ptr(bio, &ptr);\n            pj_strdup2(pool, &ci->raw_chain.cert_raw[i], ptr->data );\n        }\n        \n        BIO_free(bio);\n    }\n}\n\n/* Update local & remote certificates info. This function should be\n * called after handshake or renegotiation successfully completed.\n */\nstatic void ssl_update_certs_info(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    X509 *x;\n    STACK_OF(X509) *chain;\n\n    pj_assert(ssock->ssl_state == SSL_STATE_ESTABLISHED);\n\n    /* Active local certificate */\n    x = SSL_get_certificate(ossock->ossl_ssl);\n    if (x) {\n\tget_cert_info(ssock->pool, &ssock->local_cert_info, x, PJ_FALSE);\n\t/* Don't free local's X509! */\n    } else {\n\tpj_bzero(&ssock->local_cert_info, sizeof(pj_ssl_cert_info));\n    }\n\n    /* Active remote certificate */\n    x = SSL_get_peer_certificate(ossock->ossl_ssl);\n    if (x) {\n\tget_cert_info(ssock->pool, &ssock->remote_cert_info, x, PJ_TRUE);\n\t/* Free peer's X509 */\n\tX509_free(x);\n    } else {\n\tpj_bzero(&ssock->remote_cert_info, sizeof(pj_ssl_cert_info));\n    }\n\n    chain = SSL_get_peer_cert_chain(ossock->ossl_ssl);\n    if (chain) {\n\tpj_pool_reset(ssock->info_pool);\n\tssl_update_remote_cert_chain_info(ssock->info_pool,\n       \t\t\t\t\t  &ssock->remote_cert_info,\n       \t\t\t\t\t  chain, PJ_TRUE);\n    } else {\n\tssock->remote_cert_info.raw_chain.cnt = 0;\n    }\n}\n\n\n/* Flush write BIO to network socket. Note that any access to write BIO\n * MUST be serialized, so mutex protection must cover any call to OpenSSL\n * API (that possibly generate data for write BIO) along with the call to\n * this function (flushing all data in write BIO generated by above \n * OpenSSL API call).\n */\nstatic pj_status_t flush_circ_buf_output(pj_ssl_sock_t *ssock,\n                                         pj_ioqueue_op_key_t *send_key,\n                                         pj_size_t orig_len, unsigned flags);\n\n\nstatic void ssl_set_state(pj_ssl_sock_t *ssock, pj_bool_t is_server)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    if (is_server) {\n        SSL_set_accept_state(ossock->ossl_ssl);\n    } else {\n\tSSL_set_connect_state(ossock->ossl_ssl);\n    }\n}\n\n\nstatic void ssl_set_peer_name(pj_ssl_sock_t *ssock)\n{\n#ifdef SSL_set_tlsext_host_name\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    /* Set server name to connect */\n    if (ssock->param.server_name.slen &&\n        get_ip_addr_ver(&ssock->param.server_name) == 0)\n    {\n\t/* Server name is null terminated already */\n\tif (!SSL_set_tlsext_host_name(ossock->ossl_ssl, \n\t\t\t\t      ssock->param.server_name.ptr))\n\t{\n\t    char err_str[PJ_ERR_MSG_SIZE];\n\n\t    ERR_error_string_n(ERR_get_error(), err_str, sizeof(err_str));\n\t    PJ_LOG(3,(ssock->pool->obj_name, \"SSL_set_tlsext_host_name() \"\n\t\t\"failed: %s\", err_str));\n\t}\n    }\n#endif\n}\n\n\n/* Asynchronouse handshake */\nstatic pj_status_t ssl_do_handshake(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_status_t status;\n    int err;\n\n    /* Perform SSL handshake */\n    pj_lock_acquire(ssock->write_mutex);\n    err = SSL_do_handshake(ossock->ossl_ssl);\n    pj_lock_release(ssock->write_mutex);\n\n    /* SSL_do_handshake() may put some pending data into SSL write BIO, \n     * flush it if any.\n     */\n    status = flush_circ_buf_output(ssock, &ssock->handshake_op_key, 0, 0);\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\treturn status;\n    }\n\n    if (err < 0) {\n\tint err2 = SSL_get_error(ossock->ossl_ssl, err);\n\tif (err2 != SSL_ERROR_NONE && err2 != SSL_ERROR_WANT_READ)\n\t{\n\t    /* Handshake fails */\n\t    status = STATUS_FROM_SSL_ERR2(\"Handshake\", ssock, err, err2, 0);\n\t    return status;\n\t}\n    }\n\n    /* Check if handshake has been completed */\n    if (SSL_is_init_finished(ossock->ossl_ssl)) {\n\tssock->ssl_state = SSL_STATE_ESTABLISHED;\n\treturn PJ_SUCCESS;\n    }\n\n    return PJ_EPENDING;\n}\n\n\nstatic pj_status_t ssl_read(pj_ssl_sock_t *ssock, void *data, int *size)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int size_ = *size;\n    int len = size_;\n\n    /* SSL_read() may write some data to write buffer when re-negotiation\n     * is on progress, so let's protect it with write mutex.\n     */\n    pj_lock_acquire(ssock->write_mutex);\n    *size = size_ = SSL_read(ossock->ossl_ssl, data, size_);\n    pj_lock_release(ssock->write_mutex);\n\n    if (size_ <= 0) {\n\tpj_status_t status;\n\tint err = SSL_get_error(ossock->ossl_ssl, size_);\n\n\t/* SSL might just return SSL_ERROR_WANT_READ in \n\t * re-negotiation.\n\t */\n\tif (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ) {\n\t    if (err == SSL_ERROR_SYSCALL && size_ == -1 &&\n\t\tERR_peek_error() == 0 && errno == 0)\n\t    {\n\t\tstatus = STATUS_FROM_SSL_ERR2(\"Read\", ssock, size_,\n\t\t\t\t\t      err, len);\n\t\tPJ_LOG(4,(\"SSL\", \"SSL_read() = -1, with \"\n\t\t\t\t \"SSL_ERROR_SYSCALL, no SSL error, \"\n\t\t\t\t \"and errno = 0 - skip BIO error\"));\n\t\t/* Ignore these errors */\n\t    } else {\n\t\t/* Reset SSL socket state, then return PJ_FALSE */\n\t\tstatus = STATUS_FROM_SSL_ERR2(\"Read\", ssock, size_,\n\t\t        \t\t      err, len);\n\t\tssl_reset_sock_state(ssock);\n\t\treturn status;\n\t    }\n\t}\n\t\n\t/* Need renegotiation */\n\treturn PJ_EEOF;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Write plain data to SSL and flush write BIO. */\nstatic pj_status_t ssl_write(pj_ssl_sock_t *ssock, const void *data,\n\t\t\t     pj_ssize_t size, int *nwritten)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_status_t status = PJ_SUCCESS;\n\n    *nwritten = SSL_write(ossock->ossl_ssl, data, (int)size);\n    if (*nwritten <= 0) {\n\t/* SSL failed to process the data, it may just that re-negotiation\n\t * is on progress.\n\t */\n\tint err;\n\terr = SSL_get_error(ossock->ossl_ssl, *nwritten);\n\tif (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_NONE) {\n\t    status = PJ_EEOF;\n\t} else {\n\t    /* Some problem occured */\n\t    status = STATUS_FROM_SSL_ERR2(\"Write\", ssock, *nwritten,\n\t    \t\t\t\t  err, size);\n\t}\n    } else if (*nwritten < size) {\n\t/* nwritten < size, shouldn't happen, unless write BIO cannot hold \n\t * the whole secured data, perhaps because of insufficient memory.\n\t */\n\tstatus = PJ_ENOMEM;\n    }\n\n    return status;\n}\n\n\nstatic pj_status_t ssl_renegotiate(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_status_t status = PJ_SUCCESS;\n    int ret;\n\n    if (SSL_renegotiate_pending(ossock->ossl_ssl))\n\treturn PJ_EPENDING;\n\n    ret = SSL_renegotiate(ossock->ossl_ssl);\n    if (ret <= 0) {\n\tstatus = GET_SSL_STATUS(ssock);\n    }\n    \n    return status;\n}\n\n\n/* Put back deprecation warning setting */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic pop\n#endif\n\n\n#endif  /* PJ_HAS_SSL_SOCK */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2009-2011 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjsip/sip_transport_tls.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pj/compat/socket.h>\n#include <pj/addr_resolv.h>\n#include <pj/ssl_sock.h>\n#include <pj/assert.h>\n#include <pj/hash.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n\n#define THIS_FILE\t\"sip_transport_tls.c\"\n\n#define MAX_ASYNC_CNT\t16\n#define POOL_LIS_INIT\t512\n#define POOL_LIS_INC\t512\n#define POOL_TP_INIT\t512\n#define POOL_TP_INC\t512\n\nstruct tls_listener;\nstruct tls_transport;\n\n/*\n * Definition of TLS/SSL transport listener, and it's descendant of\n * pjsip_tpfactory.\n */\nstruct tls_listener\n{\n    pjsip_tpfactory\t     factory;\n    pj_bool_t\t\t     is_registered;\n    pjsip_endpoint\t    *endpt;\n    pjsip_tpmgr\t\t    *tpmgr;\n    pj_ssl_sock_t\t    *ssock;\n    pj_sockaddr\t\t     bound_addr;\n    pj_ssl_cert_t\t    *cert;\n    pjsip_tls_setting\t     tls_setting;    \n    unsigned\t\t     async_cnt;    \n\n    /* Group lock to be used by TLS transport and ioqueue key */\n    pj_grp_lock_t\t    *grp_lock;\n};\n\n\n/*\n * This structure is used to keep delayed transmit operation in a list.\n * A delayed transmission occurs when application sends tx_data when\n * the TLS connect/establishment is still in progress. These delayed\n * transmission will be \"flushed\" once the socket is connected (either\n * successfully or with errors).\n */\nstruct delayed_tdata\n{\n    PJ_DECL_LIST_MEMBER(struct delayed_tdata);\n    pjsip_tx_data_op_key    *tdata_op_key;\n    pj_time_val              timeout;\n};\n\n\n/*\n * TLS/SSL transport, and it's descendant of pjsip_transport.\n */\nstruct tls_transport\n{\n    pjsip_transport\t     base;\n    pj_bool_t\t\t     is_server;\n    pj_str_t\t\t     remote_name;\n\n    pj_bool_t\t\t     is_registered;\n    pj_bool_t\t\t     is_closing;\n    pj_status_t\t\t     close_reason;\n    pj_ssl_sock_t\t    *ssock;\n    pj_bool_t\t\t     has_pending_connect;\n    pj_bool_t\t\t     verify_server;\n\n    /* Keep-alive timer. */\n    pj_timer_entry\t     ka_timer;\n    pj_time_val\t\t     last_activity;\n    pjsip_tx_data_op_key     ka_op_key;\n    pj_str_t\t\t     ka_pkt;\n\n    /* TLS transport can only have  one rdata!\n     * Otherwise chunks of incoming PDU may be received on different\n     * buffer.\n     */\n    pjsip_rx_data\t     rdata;\n\n    /* Pending transmission list. */\n    struct delayed_tdata     delayed_list;\n\n    /* Group lock to be used by TLS transport and ioqueue key */\n    pj_grp_lock_t\t    *grp_lock;\n};\n\n\n/****************************************************************************\n * PROTOTYPES\n */\n\n/* This callback is called when pending accept() operation completes. */\nstatic pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n\t\t\t\t    pj_ssl_sock_t *new_ssock,\n\t\t\t\t    const pj_sockaddr_t *src_addr,\n\t\t\t\t    int src_addr_len,\n\t\t\t\t    pj_status_t status);\n\n/* Callback on incoming data */\nstatic pj_bool_t on_data_read(pj_ssl_sock_t *ssock,\n\t\t\t      void *data,\n\t\t\t      pj_size_t size,\n\t\t\t      pj_status_t status,\n\t\t\t      pj_size_t *remainder);\n\n/* Callback when packet is sent */\nstatic pj_bool_t on_data_sent(pj_ssl_sock_t *ssock,\n\t\t\t      pj_ioqueue_op_key_t *send_key,\n\t\t\t      pj_ssize_t sent);\n\n/* This callback is called by transport manager to destroy listener */\nstatic pj_status_t lis_destroy(pjsip_tpfactory *factory);\n\n/* Clean up listener resources (group lock handler) */\nstatic void lis_on_destroy(void *arg);\n\n/* This callback is called by transport manager to create transport */\nstatic pj_status_t lis_create_transport(pjsip_tpfactory *factory,\n\t\t\t\t\tpjsip_tpmgr *mgr,\n\t\t\t\t\tpjsip_endpoint *endpt,\n\t\t\t\t\tconst pj_sockaddr *rem_addr,\n\t\t\t\t\tint addr_len,\n\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\tpjsip_transport **transport);\n\n/* Common function to create and initialize transport */\nstatic pj_status_t tls_create(struct tls_listener *listener,\n\t\t\t      pj_pool_t *pool,\n\t\t\t      pj_ssl_sock_t *ssock, \n\t\t\t      pj_bool_t is_server,\n\t\t\t      const pj_sockaddr *local,\n\t\t\t      const pj_sockaddr *remote,\n\t\t\t      const pj_str_t *remote_name,\n\t\t\t      pj_grp_lock_t *glock,\n\t\t\t      struct tls_transport **p_tls);\n\n\n/* Clean up TLS resources */\nstatic void tls_on_destroy(void *arg);\n\nstatic void wipe_buf(pj_str_t *buf);\n\n\nstatic void tls_perror(const char *sender, const char *title,\n\t\t       pj_status_t status, pj_str_t *remote_name)\n{\n    PJ_PERROR(3,(sender, status, \"%s: [code=%d]%s%.*s\", title, status,\n        remote_name ? \" peer: \" : \"\", remote_name ? remote_name->slen : 0,\n\tremote_name ? remote_name->ptr : \"\"));\n}\n\n\nstatic void sockaddr_to_host_port( pj_pool_t *pool,\n\t\t\t\t   pjsip_host_port *host_port,\n\t\t\t\t   const pj_sockaddr *addr )\n{\n    host_port->host.ptr = (char*) pj_pool_alloc(pool, PJ_INET6_ADDRSTRLEN+4);\n    pj_sockaddr_print(addr, host_port->host.ptr, PJ_INET6_ADDRSTRLEN+4, 0);\n    host_port->host.slen = pj_ansi_strlen(host_port->host.ptr);\n    host_port->port = pj_sockaddr_get_port(addr);\n}\n\n\nstatic pj_uint32_t ssl_get_proto(pjsip_ssl_method ssl_method, pj_uint32_t proto)\n{\n    pj_uint32_t out_proto;\n\n    if (proto)\n\treturn proto;\n\n    if (ssl_method == PJSIP_SSL_UNSPECIFIED_METHOD)\n\tssl_method = PJSIP_SSL_DEFAULT_METHOD;\n\n    switch(ssl_method) {\n    case PJSIP_SSLV2_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_SSL2;\n\tbreak;\n    case PJSIP_SSLV3_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_SSL3;\n\tbreak;\n    case PJSIP_TLSV1_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1;\n\tbreak;\n    case PJSIP_TLSV1_1_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1_1;\n\tbreak;\n    case PJSIP_TLSV1_2_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1_2;\n\tbreak;\n    case PJSIP_TLSV1_3_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1_3;\n\tbreak;\n    case PJSIP_SSLV23_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_SSL23;\n\tbreak;\n    default:\n\tout_proto = PJ_SSL_SOCK_PROTO_DEFAULT;\n\tbreak;\n    }   \n    return out_proto;\n}\n\n\nstatic void tls_init_shutdown(struct tls_transport *tls, pj_status_t status)\n{\n    pjsip_tp_state_callback state_cb;\n\n    if (tls->close_reason == PJ_SUCCESS)\n\ttls->close_reason = status;\n\n    if (tls->base.is_shutdown || tls->base.is_destroying)\n\treturn;\n\n    /* Prevent immediate transport destroy by application, as transport\n     * state notification callback may be stacked and transport instance\n     * must remain valid at any point in the callback.\n     */\n    pjsip_transport_add_ref(&tls->base);\n\n    /* Notify application of transport disconnected state */\n    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpj_ssl_sock_info ssl_info;\n\t\n\t/* Init transport state info */\n\tpj_bzero(&state_info, sizeof(state_info));\n\tstate_info.status = tls->close_reason;\n\n\tif (tls->ssock && \n\t    pj_ssl_sock_get_info(tls->ssock, &ssl_info) == PJ_SUCCESS)\n\t{\n\t    pj_bzero(&tls_info, sizeof(tls_info));\n\t    tls_info.ssl_sock_info = &ssl_info;\n\t    state_info.ext_info = &tls_info;\n\t}\n\n\t(*state_cb)(&tls->base, PJSIP_TP_STATE_DISCONNECTED, &state_info);\n    }\n\n    /* check again */\n    if (tls->base.is_shutdown || tls->base.is_destroying) {\n        pjsip_transport_dec_ref(&tls->base);\n\treturn;\n    }\n\n    /* We can not destroy the transport since high level objects may\n     * still keep reference to this transport. So we can only \n     * instruct transport manager to gracefully start the shutdown\n     * procedure for this transport.\n     */\n    pjsip_transport_shutdown(&tls->base);\n\n    /* Now, it is ok to destroy the transport. */\n    pjsip_transport_dec_ref(&tls->base);\n}\n\n\n/****************************************************************************\n * The TLS listener/transport factory.\n */\n\n\nstatic void set_ssock_param(pj_ssl_sock_param *ssock_param,\n    struct tls_listener *listener)\n{\n    int af, sip_ssl_method;\n    pj_uint32_t sip_ssl_proto;\n\n    /* Build SSL socket param */\n    af = pjsip_transport_type_get_af(listener->factory.type);\n    pj_ssl_sock_param_default(ssock_param);\n    ssock_param->sock_af = af;\n    ssock_param->cb.on_accept_complete2 = &on_accept_complete2;\n    ssock_param->async_cnt = listener->async_cnt;\n    ssock_param->ioqueue = pjsip_endpt_get_ioqueue(listener->endpt);\n    ssock_param->timer_heap = pjsip_endpt_get_timer_heap(listener->endpt);\n    ssock_param->require_client_cert = listener->tls_setting.require_client_cert;\n    ssock_param->timeout = listener->tls_setting.timeout;\n    ssock_param->user_data = listener;\n    ssock_param->verify_peer = PJ_FALSE; /* avoid SSL socket closing the socket\n\t\t\t\t\t  * due to verification error */\n    if (ssock_param->send_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param->send_buffer_size = PJSIP_MAX_PKT_LEN;\n    if (ssock_param->read_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param->read_buffer_size = PJSIP_MAX_PKT_LEN;\n    ssock_param->ciphers_num = listener->tls_setting.ciphers_num;\n    ssock_param->ciphers = listener->tls_setting.ciphers;\n    ssock_param->curves_num = listener->tls_setting.curves_num;\n    ssock_param->curves = listener->tls_setting.curves;\n    ssock_param->sigalgs = listener->tls_setting.sigalgs;\n    ssock_param->entropy_type = listener->tls_setting.entropy_type;\n    ssock_param->entropy_path = listener->tls_setting.entropy_path;\n    ssock_param->reuse_addr = listener->tls_setting.reuse_addr;\n    ssock_param->qos_type = listener->tls_setting.qos_type;\n    ssock_param->qos_ignore_error = listener->tls_setting.qos_ignore_error;\n    pj_memcpy(&ssock_param->qos_params, &listener->tls_setting.qos_params,\n\t      sizeof(ssock_param->qos_params));\n\n    ssock_param->sockopt_ignore_error =\n\t\t\t\t    listener->tls_setting.sockopt_ignore_error;\n    /* Copy the sockopt */\n    pj_memcpy(&ssock_param->sockopt_params,\n\t      &listener->tls_setting.sockopt_params,\n\t      sizeof(listener->tls_setting.sockopt_params));\n\n    sip_ssl_method = listener->tls_setting.method;\n    sip_ssl_proto = listener->tls_setting.proto;\n    ssock_param->proto = ssl_get_proto(sip_ssl_method, sip_ssl_proto);\n}\n\nstatic void update_bound_addr(struct tls_listener *listener,\n\t\t\t      const pj_sockaddr *local)\n{\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n    int af = pjsip_transport_type_get_af(listener->factory.type);\n\n    /* Bind address may be different than factory.local_addr because\n     * factory.local_addr will be resolved.\n     */\n    if (local) {\n\tpj_sockaddr_cp(&listener->bound_addr, local);\n    } else {\n\tpj_sockaddr_init(af, &listener->bound_addr, NULL, 0);\n    }\n    pj_sockaddr_cp(listener_addr, &listener->bound_addr);    \n}\n\nstatic pj_status_t update_factory_addr(struct tls_listener *listener,\n\t\t\t\t       const pjsip_host_port *addr_name)\n{\n    pj_status_t status = PJ_SUCCESS;\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n\n    if (addr_name && addr_name->host.slen) {\n\tpj_sockaddr tmp;\n\tint af = pjsip_transport_type_get_af(listener->factory.type);\n\n\tstatus = pj_sockaddr_init(af, &tmp, &addr_name->host,\n\t\t\t\t  (pj_uint16_t)addr_name->port);\n\tif (status != PJ_SUCCESS || !pj_sockaddr_has_addr(&tmp) ||\n\t    (af == pj_AF_INET() && tmp.ipv4.sin_addr.s_addr == PJ_INADDR_NONE))\n\t{\n\t    /* Invalid address */\n\t    return PJ_EINVAL;\n\t}\n\n\t/* Copy the address */\n\tlistener->factory.addr_name = *addr_name;\n\tpj_strdup(listener->factory.pool, &listener->factory.addr_name.host,\n\t\t  &addr_name->host);\n\tlistener->factory.addr_name.port = addr_name->port;\n\n    }\n    else {\n\t/* No published address is given, use the bound address */\n\n\t/* If the address returns 0.0.0.0, use the default\n\t* interface address as the transport's address.\n\t*/\n\tif (!pj_sockaddr_has_addr(listener_addr)) {\n\t    pj_sockaddr hostip;\n\n\t    status = pj_gethostip(listener->bound_addr.addr.sa_family,\n\t\t\t\t  &hostip);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    pj_sockaddr_copy_addr(listener_addr, &hostip);\n\t}\n\n\t/* Save the address name */\n\tsockaddr_to_host_port(listener->factory.pool,\n\t\t\t      &listener->factory.addr_name, listener_addr);\n    }\n\n    /* If port is zero, get the bound port */\n    if (listener->factory.addr_name.port == 0) {\n\tlistener->factory.addr_name.port = pj_sockaddr_get_port(listener_addr);\n    }\n\n    pj_ansi_snprintf(listener->factory.obj_name,\n\t\t     sizeof(listener->factory.obj_name),\n\t\t     \"tlstp:%d\", listener->factory.addr_name.port);\n    return status;\n}\n\nstatic void update_transport_info(struct tls_listener *listener)\n{\n    enum { INFO_LEN = 100 };\n    char local_addr[PJ_INET6_ADDRSTRLEN + 10];\n    char pub_addr[PJ_INET6_ADDRSTRLEN + 10];\n    int len;\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n\n    if (listener->factory.info == NULL) {\n\tlistener->factory.info = (char*)pj_pool_alloc(listener->factory.pool,\n\t\t\t\t\t\t      INFO_LEN);\n    }\n    pj_sockaddr_print(listener_addr, local_addr, sizeof(local_addr), 3);\n    pj_addr_str_print(&listener->factory.addr_name.host, \n\t\t      listener->factory.addr_name.port, pub_addr, \n\t\t      sizeof(pub_addr), 1);\n    len = pj_ansi_snprintf(\n\t    listener->factory.info, INFO_LEN, \"tls %s [published as %s]\",\n\t    local_addr, pub_addr);\n    PJ_CHECK_TRUNC_STR(len, listener->factory.info, INFO_LEN);\n\n    if (listener->ssock) {\n\tchar addr[PJ_INET6_ADDRSTRLEN+10];\n\n\tPJ_LOG(4, (listener->factory.obj_name,\n\t       \"SIP TLS listener is ready for incoming connections at %s\",\n\t       pj_addr_str_print(&listener->factory.addr_name.host,\n\t\t\t         listener->factory.addr_name.port, addr,\n\t\t\t\t sizeof(addr), 1)));\n    } else {\n\tPJ_LOG(4, (listener->factory.obj_name, \"SIP TLS is ready \"\n\t       \"(client only)\"));\n    }\n}\n\n\n/*\n * This is the public API to create, initialize, register, and start the\n * TLS listener.\n */\nPJ_DEF(pj_status_t) pjsip_tls_transport_start(pjsip_endpoint *endpt,\n    const pjsip_tls_setting *opt,\n    const pj_sockaddr_in *local_in,\n    const pjsip_host_port *a_name,\n    unsigned async_cnt,\n    pjsip_tpfactory **p_factory)\n{\n    pj_sockaddr local;\n\n    if (local_in)\n\tpj_sockaddr_cp(&local, local_in);\n\n    return pjsip_tls_transport_start2(endpt, opt, (local_in ? &local : NULL),\n\t\t\t\t      a_name, async_cnt, p_factory);\n}\n\n\nPJ_DEF(pj_status_t) pjsip_tls_transport_lis_start(pjsip_tpfactory *factory,\n\t\t\t\t\t\tconst pj_sockaddr *local,\n\t\t\t\t\t\tconst pjsip_host_port *a_name)\n{\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssl_sock_param ssock_param, newsock_param;\n    struct tls_listener *listener = (struct tls_listener *)factory;\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n\n    if (listener->ssock)\n\treturn PJ_SUCCESS;\n\n    set_ssock_param(&ssock_param, listener);\n    update_bound_addr(listener, local);\n    ssock_param.grp_lock = listener->grp_lock;\n\n    /* Create SSL socket */\n    status = pj_ssl_sock_create(listener->factory.pool, &ssock_param, \n\t\t\t\t&listener->ssock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    if (listener->cert) {\n\tstatus = pj_ssl_sock_set_certificate(listener->ssock, \n\t\t\t\t       listener->factory.pool, listener->cert);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Start accepting incoming connections. Note that some TLS/SSL\n     * backends may not support for SSL socket server.\n     */    \n    pj_memcpy(&newsock_param, &ssock_param, sizeof(newsock_param));\n    newsock_param.async_cnt = 1;\n    newsock_param.cb.on_data_read = &on_data_read;\n    newsock_param.cb.on_data_sent = &on_data_sent;\n    status = pj_ssl_sock_start_accept2(listener->ssock, listener->factory.pool,\n\t\t\t    (pj_sockaddr_t*)listener_addr,\n\t\t\t    pj_sockaddr_get_len((pj_sockaddr_t*)listener_addr),\n\t\t\t    &newsock_param);\n\n    if (status == PJ_SUCCESS || status == PJ_EPENDING) {\n\tpj_ssl_sock_info info;\t\n\n\t/* Retrieve the bound address */\n\tstatus = pj_ssl_sock_get_info(listener->ssock, &info);\n\tif (status == PJ_SUCCESS)\n\t    pj_sockaddr_cp(listener_addr, (pj_sockaddr_t*)&info.local_addr);\n\n    }\n    status = update_factory_addr(listener, a_name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    update_transport_info(listener);\n\n    return status;    \n}\n\n\nPJ_DEF(pj_status_t) pjsip_tls_transport_start2( pjsip_endpoint *endpt,\n \t\t\t\t\t        const pjsip_tls_setting *opt,\n\t\t\t\t\t        const pj_sockaddr *local,\n\t\t\t\t\t        const pjsip_host_port *a_name,\n\t\t\t\t\t        unsigned async_cnt,\n\t\t\t\t\t        pjsip_tpfactory **p_factory)\n{        \n    pj_pool_t *pool;\n    pj_bool_t is_ipv6;    \n    struct tls_listener *listener;    \n    pj_status_t status;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && async_cnt, PJ_EINVAL);\n\n    is_ipv6 = (local && local->addr.sa_family == pj_AF_INET6());    \n\n    pool = pjsip_endpt_create_pool(endpt, \"tlstp\", POOL_LIS_INIT, \n\t\t\t\t   POOL_LIS_INC);\n    PJ_ASSERT_RETURN(pool, PJ_ENOMEM);\n\n    listener = PJ_POOL_ZALLOC_T(pool, struct tls_listener);\n    listener->factory.pool = pool;\n    if (is_ipv6)\n\tlistener->factory.type = PJSIP_TRANSPORT_TLS6;\n    else\n\tlistener->factory.type = PJSIP_TRANSPORT_TLS;\n    listener->factory.type_name = (char*)\n\t\tpjsip_transport_get_type_name(listener->factory.type);\n    listener->factory.flag = \n\t\tpjsip_transport_get_flag_from_type(listener->factory.type);\n    listener->endpt = endpt;\n\n    pj_ansi_strcpy(listener->factory.obj_name, \"tlstp\");\n    if (is_ipv6)\n\tpj_ansi_strcat(listener->factory.obj_name, \"6\");\n\n    if (opt)\n\tpjsip_tls_setting_copy(pool, &listener->tls_setting, opt);\n    else\n\tpjsip_tls_setting_default(&listener->tls_setting);\n\n    status = pj_lock_create_recursive_mutex(pool, listener->factory.obj_name,\n\t\t\t\t\t    &listener->factory.lock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    if (async_cnt > MAX_ASYNC_CNT) \n\tasync_cnt = MAX_ASYNC_CNT;\n\n    listener->async_cnt = async_cnt;    \n\n    /* Create group lock */\n    status = pj_grp_lock_create(pool, NULL, &listener->grp_lock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Setup group lock handler */\n    pj_grp_lock_add_ref(listener->grp_lock);\n    pj_grp_lock_add_handler(listener->grp_lock, pool, listener,\n\t\t\t    &lis_on_destroy);\n\n    /* Check if certificate/CA list for SSL socket is set */\n    if (listener->tls_setting.cert_file.slen ||\n\tlistener->tls_setting.ca_list_file.slen ||\n\tlistener->tls_setting.ca_list_path.slen || \n\tlistener->tls_setting.privkey_file.slen) \n    {\n\tstatus = pj_ssl_cert_load_from_files2(pool,\n\t\t\t&listener->tls_setting.ca_list_file,\n\t\t\t&listener->tls_setting.ca_list_path,\n\t\t\t&listener->tls_setting.cert_file,\n\t\t\t&listener->tls_setting.privkey_file,\n\t\t\t&listener->tls_setting.password,\n\t\t\t&listener->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n    } else if (listener->tls_setting.ca_buf.slen ||\n\t       listener->tls_setting.cert_buf.slen||\n\t       listener->tls_setting.privkey_buf.slen)\n    {\n\tstatus = pj_ssl_cert_load_from_buffer(pool,\n\t\t\t&listener->tls_setting.ca_buf,\n\t\t\t&listener->tls_setting.cert_buf,\n\t\t\t&listener->tls_setting.privkey_buf,\n\t\t\t&listener->tls_setting.password,\n\t\t\t&listener->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;    \n    }\n\n    /* Register to transport manager */\n    listener->endpt = endpt;\n    listener->tpmgr = pjsip_endpt_get_tpmgr(endpt);\n    listener->factory.create_transport2 = lis_create_transport;\n    listener->factory.destroy = lis_destroy;\n\n#if !(defined(PJSIP_TLS_TRANSPORT_DONT_CREATE_LISTENER) && \\\n    PJSIP_TLS_TRANSPORT_DONT_CREATE_LISTENER != 0)\n    /* Start listener. */\n    status = pjsip_tls_transport_lis_start(&listener->factory, local, a_name);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#else\n    update_bound_addr(listener, local);\n    /* If published host/IP is specified, then use that address as the\n     * listener advertised address.\n     */\n    status = update_factory_addr(listener, a_name);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Set transport info. */\n    update_transport_info(listener);\n#endif\n\n    listener->is_registered = PJ_TRUE;\n    status = pjsip_tpmgr_register_tpfactory(listener->tpmgr,\n\t\t\t\t\t    &listener->factory);\n    if (status != PJ_SUCCESS) {\n\tlistener->is_registered = PJ_FALSE;\n\tgoto on_error;\n    }\n\n    /* Return the pointer to user */\n    if (p_factory) *p_factory = &listener->factory;\n\n    return PJ_SUCCESS;\n\non_error:\n    lis_destroy(&listener->factory);\n    return status;\n}\n\n\n/* Clean up listener resources */\nstatic void lis_on_destroy(void *arg)\n{\n    struct tls_listener *listener = (struct tls_listener*)arg;\n\n    if (listener->cert) {\n\tpj_ssl_cert_wipe_keys(listener->cert);\n\tlistener->cert = NULL;\n    }\n\n    if (listener->factory.lock) {\n\tpj_lock_destroy(listener->factory.lock);\n\tlistener->factory.lock = NULL;\n    }\n\n    if (listener->factory.pool) {\n\tPJ_LOG(4,(listener->factory.obj_name,  \"SIP TLS transport destroyed\"));\n\tpj_pool_secure_release(&listener->factory.pool);\n    }\n}\n\n\nstatic void lis_close(struct tls_listener *listener)\n{\n    if (listener->is_registered) {\n\tpjsip_tpmgr_unregister_tpfactory(listener->tpmgr, &listener->factory);\n\tlistener->is_registered = PJ_FALSE;\n    }\n\n    if (listener->ssock) {\n\tpj_ssl_sock_close(listener->ssock);\n\tlistener->ssock = NULL;\n    }\n}\n\n\n/* This callback is called by transport manager to destroy listener */\nstatic pj_status_t lis_destroy(pjsip_tpfactory *factory)\n{\n    struct tls_listener *listener = (struct tls_listener *)factory;\n\n    lis_close(listener);\n\n    if (listener->grp_lock) {\n\tpj_grp_lock_t *grp_lock = listener->grp_lock;\n\tlistener->grp_lock = NULL;\n\tpj_grp_lock_dec_ref(grp_lock);\n\t/* Listener may have been deleted at this point */\n    } else {\n\tlis_on_destroy(listener);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjsip_tls_transport_restart(pjsip_tpfactory *factory,\n\t\t\t\t\t\tconst pj_sockaddr *local,\n\t\t\t\t\t\tconst pjsip_host_port *a_name)\n{\n    pj_status_t status = PJ_SUCCESS;\n    struct tls_listener *listener = (struct tls_listener *)factory;\n\n    lis_close(listener);\n\n    status = pjsip_tls_transport_lis_start(factory, local, a_name);\n    if (status != PJ_SUCCESS) {\t\n\ttls_perror(listener->factory.obj_name, \n\t\t   \"Unable to start listener after closing it\", status, NULL);\n\n\treturn status;\n    }\n    \n    status = pjsip_tpmgr_register_tpfactory(listener->tpmgr,\n\t\t\t\t\t    &listener->factory);\n    if (status != PJ_SUCCESS) {\n\ttls_perror(listener->factory.obj_name,\n\t\t    \"Unable to register the transport listener\", status, NULL);\n\n\tlistener->is_registered = PJ_FALSE;\t\n    } else {\n\tlistener->is_registered = PJ_TRUE;\t\n    }    \n\n    return status;\n}\n\n\n/***************************************************************************/\n/*\n * TLS Transport\n */\n\n/*\n * Prototypes.\n */\n/* Called by transport manager to send message */\nstatic pj_status_t tls_send_msg(pjsip_transport *transport, \n\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\tconst pj_sockaddr_t *rem_addr,\n\t\t\t\tint addr_len,\n\t\t\t\tvoid *token,\n\t\t\t\tpjsip_transport_callback callback);\n\n/* Called by transport manager to shutdown */\nstatic pj_status_t tls_shutdown(pjsip_transport *transport);\n\n/* Called by transport manager to destroy transport */\nstatic pj_status_t tls_destroy_transport(pjsip_transport *transport);\n\n/* Utility to destroy transport */\nstatic pj_status_t tls_destroy(pjsip_transport *transport,\n\t\t\t       pj_status_t reason);\n\n/* Callback when connect completes */\nstatic pj_bool_t on_connect_complete(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_status_t status);\n\n/* TLS keep-alive timer callback */\nstatic void tls_keep_alive_timer(pj_timer_heap_t *th, pj_timer_entry *e);\n\n/*\n * Common function to create TLS transport, called when pending accept() and\n * pending connect() complete.\n */\nstatic pj_status_t tls_create( struct tls_listener *listener,\n\t\t\t       pj_pool_t *pool,\n\t\t\t       pj_ssl_sock_t *ssock,\n\t\t\t       pj_bool_t is_server,\n\t\t\t       const pj_sockaddr *local,\n\t\t\t       const pj_sockaddr *remote,\n\t\t\t       const pj_str_t *remote_name,\n\t\t\t       pj_grp_lock_t *glock,\n\t\t\t       struct tls_transport **p_tls)\n{\n    struct tls_transport *tls;\n    const pj_str_t ka_pkt = PJSIP_TLS_KEEP_ALIVE_DATA;\n    char print_addr[PJ_INET6_ADDRSTRLEN+10];\n    pj_status_t status;\n    \n\n    PJ_ASSERT_RETURN(listener && ssock && local && remote && p_tls, PJ_EINVAL);\n\n\n    if (pool == NULL) {\n\tpool = pjsip_endpt_create_pool(listener->endpt, \"tls\",\n\t\t\t\t       POOL_TP_INIT, POOL_TP_INC);\n\tPJ_ASSERT_RETURN(pool != NULL, PJ_ENOMEM);\n    }    \n\n    /*\n     * Create and initialize basic transport structure.\n     */\n    tls = PJ_POOL_ZALLOC_T(pool, struct tls_transport);\n    tls->is_server = is_server;\n    tls->verify_server = listener->tls_setting.verify_server;\n    pj_list_init(&tls->delayed_list);\n    tls->base.pool = pool;\n\n    pj_ansi_snprintf(tls->base.obj_name, PJ_MAX_OBJ_NAME, \n\t\t     (is_server ? \"tlss%p\" :\"tlsc%p\"), tls);\n\n    status = pj_atomic_create(pool, 0, &tls->base.ref_cnt);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    status = pj_lock_create_recursive_mutex(pool, \"tls\", &tls->base.lock);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    if (remote_name)\n\tpj_strdup(pool, &tls->remote_name, remote_name);\n\n    tls->base.key.type = listener->factory.type;\n    pj_sockaddr_cp(&tls->base.key.rem_addr, remote);\n    tls->base.type_name = (char*)pjsip_transport_get_type_name(\n\t\t\t\t   (pjsip_transport_type_e)tls->base.key.type);\n    tls->base.flag = pjsip_transport_get_flag_from_type(\n\t\t\t\t   (pjsip_transport_type_e)tls->base.key.type);\n\n    tls->base.info = (char*) pj_pool_alloc(pool, 64);\n    pj_ansi_snprintf(tls->base.info, 64, \"%s to %s\",\n                     tls->base.type_name,\n                     pj_sockaddr_print(remote, print_addr,\n                                       sizeof(print_addr), 3));\n\n\n    tls->base.addr_len = pj_sockaddr_get_len(remote);\n    tls->base.dir = is_server? PJSIP_TP_DIR_INCOMING : PJSIP_TP_DIR_OUTGOING;\n    \n    /* Set initial local address */\n    if (!pj_sockaddr_has_addr(local)) {\n        pj_sockaddr_cp(&tls->base.local_addr,\n                       &listener->factory.local_addr);\n    } else {\n\tpj_sockaddr_cp(&tls->base.local_addr, local);\n    }\n    \n    sockaddr_to_host_port(pool, &tls->base.local_name, &tls->base.local_addr);\n    if (tls->remote_name.slen) {\n\ttls->base.remote_name.host = tls->remote_name;\n\ttls->base.remote_name.port = pj_sockaddr_get_port(remote);\n    } else {\n\tsockaddr_to_host_port(pool, &tls->base.remote_name, remote);\n    }\n\n    tls->base.endpt = listener->endpt;\n    tls->base.tpmgr = listener->tpmgr;\n    tls->base.send_msg = &tls_send_msg;\n    tls->base.do_shutdown = &tls_shutdown;\n    tls->base.destroy = &tls_destroy_transport;\n    tls->base.factory = &listener->factory;\n\n    tls->ssock = ssock;\n\n    /* Set up the group lock */\n    tls->grp_lock = tls->base.grp_lock = glock;\n    pj_grp_lock_add_ref(tls->grp_lock);\n    pj_grp_lock_add_handler(tls->grp_lock, pool, tls, &tls_on_destroy);\n\n    /* Register transport to transport manager */\n    status = pjsip_transport_register(listener->tpmgr, &tls->base);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    tls->is_registered = PJ_TRUE;\n\n    /* Initialize keep-alive timer */\n    tls->ka_timer.user_data = (void*)tls;\n    tls->ka_timer.cb = &tls_keep_alive_timer;\n    pj_ioqueue_op_key_init(&tls->ka_op_key.key, sizeof(pj_ioqueue_op_key_t));\n    pj_strdup(tls->base.pool, &tls->ka_pkt, &ka_pkt);\n    \n    /* Done setting up basic transport. */\n    *p_tls = tls;\n\n    PJ_LOG(4,(tls->base.obj_name, \"TLS %s transport created\",\n\t      (tls->is_server ? \"server\" : \"client\")));\n\n    return PJ_SUCCESS;\n\non_error:\n    if (tls->grp_lock && pj_grp_lock_get_ref(tls->grp_lock))\n\ttls_destroy(&tls->base, status);\n    else\n    \ttls_on_destroy(tls);\n\n    return status;\n}\n\n\n/* Flush all delayed transmision once the socket is connected. */\nstatic void tls_flush_pending_tx(struct tls_transport *tls)\n{\n    pj_time_val now;\n\n    pj_gettickcount(&now);\n    pj_lock_acquire(tls->base.lock);\n    while (!pj_list_empty(&tls->delayed_list)) {\n\tstruct delayed_tdata *pending_tx;\n\tpjsip_tx_data *tdata;\n\tpj_ioqueue_op_key_t *op_key;\n\tpj_ssize_t size;\n\tpj_status_t status;\n\n\tpending_tx = tls->delayed_list.next;\n\tpj_list_erase(pending_tx);\n\n\ttdata = pending_tx->tdata_op_key->tdata;\n\top_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n        if (pending_tx->timeout.sec > 0 &&\n            PJ_TIME_VAL_GT(now, pending_tx->timeout))\n        {\n            pj_lock_release(tls->base.lock);\n\t    on_data_sent(tls->ssock, op_key, -PJ_ETIMEDOUT);\n            pj_lock_acquire(tls->base.lock);\n            continue;\n        }\n\n\t/* send! */\n\tsize = tdata->buf.cur - tdata->buf.start;\n\tstatus = pj_ssl_sock_send(tls->ssock, op_key, tdata->buf.start, \n\t\t\t\t  &size, 0);\n\n\tif (status != PJ_EPENDING) {\n            pj_lock_release(tls->base.lock);\n\t    on_data_sent(tls->ssock, op_key, size);\n            pj_lock_acquire(tls->base.lock);\n\t}\n    }\n    pj_lock_release(tls->base.lock);\n}\n\n\n/* Called by transport manager to destroy transport */\nstatic pj_status_t tls_destroy_transport(pjsip_transport *transport)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n\n    /* Transport would have been unregistered by now since this callback\n     * is called by transport manager.\n     */\n    tls->is_registered = PJ_FALSE;\n\n    return tls_destroy(transport, tls->close_reason);\n}\n\n\n/* Clean up TLS resources */\nstatic void tls_on_destroy(void *arg)\n{\n    struct tls_transport *tls = (struct tls_transport*)arg;\n\n    if (tls->rdata.tp_info.pool) {\n\tpj_pool_secure_release(&tls->rdata.tp_info.pool);\n    }\n\n    if (tls->base.lock) {\n\tpj_lock_destroy(tls->base.lock);\n\ttls->base.lock = NULL;\n    }\n\n    if (tls->base.ref_cnt) {\n\tpj_atomic_destroy(tls->base.ref_cnt);\n\ttls->base.ref_cnt = NULL;\n    }\n\n    if (tls->base.pool) {\n\tif (tls->close_reason != PJ_SUCCESS) {\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\n\t    pj_strerror(tls->close_reason, errmsg, sizeof(errmsg));\n\t    PJ_LOG(4,(tls->base.obj_name, \n\t\t      \"TLS transport destroyed with reason %d: %s\", \n\t\t      tls->close_reason, errmsg));\n\n\t} else {\n\n\t    PJ_LOG(4,(tls->base.obj_name, \n\t\t      \"TLS transport destroyed normally\"));\n\n\t}\n\tpj_pool_secure_release(&tls->base.pool);\n    }\n}\n\n/* Destroy TLS transport */\nstatic pj_status_t tls_destroy(pjsip_transport *transport, \n\t\t\t       pj_status_t reason)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n\n    if (tls->close_reason == 0)\n\ttls->close_reason = reason;\n\n    if (tls->is_registered) {\n\ttls->is_registered = PJ_FALSE;\n\tpjsip_transport_destroy(transport);\n\n\t/* pjsip_transport_destroy will recursively call this function\n\t * again.\n\t */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Mark transport as closing */\n    tls->is_closing = PJ_TRUE;\n\n    /* Stop keep-alive timer. */\n    if (tls->ka_timer.id) {\n\tpjsip_endpt_cancel_timer(tls->base.endpt, &tls->ka_timer);\n\ttls->ka_timer.id = PJ_FALSE;\n    }\n\n    /* Cancel all delayed transmits */\n    while (!pj_list_empty(&tls->delayed_list)) {\n\tstruct delayed_tdata *pending_tx;\n\tpj_ioqueue_op_key_t *op_key;\n\n\tpending_tx = tls->delayed_list.next;\n\tpj_list_erase(pending_tx);\n\n\top_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n\ton_data_sent(tls->ssock, op_key, -reason);\n    }\n\n    if (tls->ssock) {\n\tpj_ssl_sock_close(tls->ssock);\n\ttls->ssock = NULL;\n    }\n\n    if (tls->grp_lock) {\n\tpj_grp_lock_t *grp_lock = tls->grp_lock;\n\ttls->grp_lock = NULL;\n\tpj_grp_lock_dec_ref(grp_lock);\n\t/* Transport may have been deleted at this point */\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * This utility function creates receive data buffers and start\n * asynchronous recv() operations from the socket. It is called after\n * accept() or connect() operation complete.\n */\nstatic pj_status_t tls_start_read(struct tls_transport *tls)\n{\n    pj_pool_t *pool;\n    pj_uint32_t size;\n    pj_sockaddr *rem_addr;\n    void *readbuf[1];\n    pj_status_t status;\n\n    /* Init rdata */\n    pool = pjsip_endpt_create_pool(tls->base.endpt,\n\t\t\t\t   \"rtd%p\",\n\t\t\t\t   PJSIP_POOL_RDATA_LEN,\n\t\t\t\t   PJSIP_POOL_RDATA_INC);\n    if (!pool) {\n\ttls_perror(tls->base.obj_name, \"Unable to create pool\", PJ_ENOMEM,\n\t\t   NULL);\n\treturn PJ_ENOMEM;\n    }\n\n    tls->rdata.tp_info.pool = pool;\n\n    tls->rdata.tp_info.transport = &tls->base;\n    tls->rdata.tp_info.tp_data = tls;\n    tls->rdata.tp_info.op_key.rdata = &tls->rdata;\n    pj_ioqueue_op_key_init(&tls->rdata.tp_info.op_key.op_key, \n\t\t\t   sizeof(pj_ioqueue_op_key_t));\n\n    tls->rdata.pkt_info.src_addr = tls->base.key.rem_addr;\n    tls->rdata.pkt_info.src_addr_len = sizeof(tls->rdata.pkt_info.src_addr);\n    rem_addr = &tls->base.key.rem_addr;\n    pj_sockaddr_print(rem_addr, tls->rdata.pkt_info.src_name,\n                          sizeof(tls->rdata.pkt_info.src_name), 0);\n    tls->rdata.pkt_info.src_port = pj_sockaddr_get_port(rem_addr);\n\n    size = sizeof(tls->rdata.pkt_info.packet);\n    readbuf[0] = tls->rdata.pkt_info.packet;\n    status = pj_ssl_sock_start_read2(tls->ssock, tls->base.pool, size,\n\t\t\t\t     readbuf, 0);\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\tPJ_PERROR(4, (tls->base.obj_name, status,\n\t\t     \"pj_ssl_sock_start_read() error\"));\n\treturn status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* This callback is called by transport manager for the TLS factory\n * to create outgoing transport to the specified destination.\n */\nstatic pj_status_t lis_create_transport(pjsip_tpfactory *factory,\n\t\t\t\t\tpjsip_tpmgr *mgr,\n\t\t\t\t\tpjsip_endpoint *endpt,\n\t\t\t\t\tconst pj_sockaddr *rem_addr,\n\t\t\t\t\tint addr_len,\n\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\tpjsip_transport **p_transport)\n{\n    struct tls_listener *listener;\n    struct tls_transport *tls;\n    int sip_ssl_method;\n    pj_uint32_t sip_ssl_proto;\n    pj_pool_t *pool;\n    pj_grp_lock_t *glock;\n    pj_ssl_sock_t *ssock;\n    pj_ssl_sock_param ssock_param;\n    pj_sockaddr local_addr;\n    pj_str_t remote_name;\n    pj_status_t status;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(factory && mgr && endpt && rem_addr &&\n\t\t     addr_len && p_transport, PJ_EINVAL);\n\n    /* Check that address is a sockaddr_in or sockaddr_in6*/\n    PJ_ASSERT_RETURN((rem_addr->addr.sa_family == pj_AF_INET() &&\n\t\t      addr_len == sizeof(pj_sockaddr_in)) ||\n\t\t     (rem_addr->addr.sa_family == pj_AF_INET6() &&\n\t\t      addr_len == sizeof(pj_sockaddr_in6)), PJ_EINVAL);\n\n\n    listener = (struct tls_listener*)factory;\n\n    pool = pjsip_endpt_create_pool(listener->endpt, \"tls\",\n\t\t\t\t   POOL_TP_INIT, POOL_TP_INC);\n    PJ_ASSERT_RETURN(pool != NULL, PJ_ENOMEM);\n\n    /* Get remote host name from tdata */\n    if (tdata)\n\tremote_name = tdata->dest_info.name;\n    else\n\tpj_bzero(&remote_name, sizeof(remote_name));\n\n    /* Build SSL socket param */\n    pj_ssl_sock_param_default(&ssock_param);\n    ssock_param.sock_af = (factory->type & PJSIP_TRANSPORT_IPV6) ?\n\t\t\t    pj_AF_INET6() : pj_AF_INET();\n    ssock_param.cb.on_connect_complete = &on_connect_complete;\n    ssock_param.cb.on_data_read = &on_data_read;\n    ssock_param.cb.on_data_sent = &on_data_sent;\n    ssock_param.async_cnt = 1;\n    ssock_param.ioqueue = pjsip_endpt_get_ioqueue(listener->endpt);\n    ssock_param.timer_heap = pjsip_endpt_get_timer_heap(listener->endpt);\n    ssock_param.server_name = remote_name;\n    ssock_param.timeout = listener->tls_setting.timeout;\n    ssock_param.user_data = NULL; /* pending, must be set later */\n    ssock_param.verify_peer = PJ_FALSE; /* avoid SSL socket closing the socket\n\t\t\t\t\t * due to verification error */\n    if (ssock_param.send_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param.send_buffer_size = PJSIP_MAX_PKT_LEN;\n    if (ssock_param.read_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param.read_buffer_size = PJSIP_MAX_PKT_LEN;\n    ssock_param.ciphers_num = listener->tls_setting.ciphers_num;\n    ssock_param.ciphers = listener->tls_setting.ciphers;\n    ssock_param.curves_num = listener->tls_setting.curves_num;\n    ssock_param.curves = listener->tls_setting.curves;\n    ssock_param.sigalgs = listener->tls_setting.sigalgs;\n    ssock_param.entropy_type = listener->tls_setting.entropy_type;\n    ssock_param.entropy_path = listener->tls_setting.entropy_path;\n    ssock_param.qos_type = listener->tls_setting.qos_type;\n    ssock_param.qos_ignore_error = listener->tls_setting.qos_ignore_error;\n    pj_memcpy(&ssock_param.qos_params, &listener->tls_setting.qos_params,\n\t      sizeof(ssock_param.qos_params));\n\n    ssock_param.sockopt_ignore_error = \n\t\t\t\t     listener->tls_setting.sockopt_ignore_error;\n    /* Copy the sockopt */\n    pj_memcpy(&ssock_param.sockopt_params, \n\t      &listener->tls_setting.sockopt_params,\n\t      sizeof(listener->tls_setting.sockopt_params));\n\n    sip_ssl_method = listener->tls_setting.method;\n    sip_ssl_proto = listener->tls_setting.proto;\n    ssock_param.proto = ssl_get_proto(sip_ssl_method, sip_ssl_proto);\n\n    /* Create group lock */\n    status = pj_grp_lock_create(pool, NULL, &glock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    ssock_param.grp_lock = glock;\n    status = pj_ssl_sock_create(pool, &ssock_param, &ssock);\n    if (status != PJ_SUCCESS) {\n\tpj_grp_lock_destroy(glock);\n\treturn status;\n    }\n\n    /* Apply SSL certificate */\n    if (listener->cert) {\n\tstatus = pj_ssl_sock_set_certificate(ssock, pool, listener->cert);\n\tif (status != PJ_SUCCESS) {\n\t    pj_grp_lock_destroy(glock);\n\t    return status;\n\t}\n    }\n\n    /* Initially set bind address to listener's bind address */\n    pj_sockaddr_init(listener->bound_addr.addr.sa_family,\n\t\t     &local_addr, NULL, 0);\n    pj_sockaddr_copy_addr(&local_addr, &listener->bound_addr);\n\n    /* Create the transport descriptor */\n    status = tls_create(listener, pool, ssock, PJ_FALSE, &local_addr, \n\t\t\trem_addr, &remote_name, glock, &tls);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set the \"pending\" SSL socket user data */\n    pj_ssl_sock_set_user_data(tls->ssock, tls);\n\n    /* Start asynchronous connect() operation */\n    tls->has_pending_connect = PJ_TRUE;\n    status = pj_ssl_sock_start_connect(tls->ssock, tls->base.pool, \n\t\t\t\t       (pj_sockaddr_t*)&local_addr,\n\t\t\t\t       (pj_sockaddr_t*)rem_addr,\n\t\t\t\t       addr_len);\n    if (status == PJ_SUCCESS) {\n\ton_connect_complete(tls->ssock, PJ_SUCCESS);\n    } else if (status != PJ_EPENDING) {\n\ttls_destroy(&tls->base, status);\n\treturn status;\n    }\n\n    if (tls->has_pending_connect) {\n\tpj_ssl_sock_info info;\n\tchar local_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n\tchar remote_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n\n\t/* Update local address, just in case local address currently set is \n\t * different now that asynchronous connect() is started.\n\t */\n\n\t/* Retrieve the bound address */\n\tstatus = pj_ssl_sock_get_info(tls->ssock, &info);\n\tif (status == PJ_SUCCESS) {\n\t    pj_uint16_t new_port;\n\n\t    new_port = pj_sockaddr_get_port((pj_sockaddr_t*)&info.local_addr);\n\n\t    if (pj_sockaddr_has_addr((pj_sockaddr_t*)&info.local_addr)) {\n\t\t/* Update sockaddr */\n\t\tpj_sockaddr_cp((pj_sockaddr_t*)&tls->base.local_addr,\n\t\t\t       (pj_sockaddr_t*)&info.local_addr);\n\t    } else if (new_port && new_port != pj_sockaddr_get_port(\n\t\t\t\t\t(pj_sockaddr_t*)&tls->base.local_addr))\n\t    {\n\t\t/* Update port only */\n\t\tpj_sockaddr_set_port(&tls->base.local_addr, \n\t\t\t\t     new_port);\n\t    }\n\n\t    sockaddr_to_host_port(tls->base.pool, &tls->base.local_name,\n\t\t\t\t  &tls->base.local_addr);\n\t}\n\n\tPJ_LOG(4,(tls->base.obj_name, \n\t\t  \"TLS transport %s is connecting to %s...\",\n\t\t  pj_addr_str_print(&tls->base.local_name.host, \n\t\t\t\t    tls->base.local_name.port, \n\t\t\t\t    local_addr_buf, sizeof(local_addr_buf), 1),\n\t\t  pj_addr_str_print(&tls->base.remote_name.host, \n\t\t\t        tls->base.remote_name.port, \n\t\t\t\tremote_addr_buf, sizeof(remote_addr_buf), 1)));\n    }\n\n    /* Done */\n    *p_transport = &tls->base;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_ssl_sock_t *new_ssock,\n\t\t\t\t     const pj_sockaddr_t *src_addr,\n\t\t\t\t     int src_addr_len, \n\t\t\t\t     pj_status_t accept_status)\n{    \n    struct tls_listener *listener;\n    struct tls_transport *tls;\n    pj_ssl_sock_info ssl_info;\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pjsip_tp_state_callback state_cb;\n    pj_sockaddr tmp_src_addr;\n    pj_bool_t is_shutdown;\n    pj_status_t status;\n    char addr_buf[PJ_INET6_ADDRSTRLEN+10];        \n\n    PJ_UNUSED_ARG(src_addr_len);\n\n    listener = (struct tls_listener*) pj_ssl_sock_get_user_data(ssock);\n\n    if (accept_status != PJ_SUCCESS) {\n\tif (listener && listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_ssl_sock_info ssi;\n\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = accept_status;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    if (new_ssock &&\n\t\tpj_ssl_sock_get_info(new_ssock, &ssi) == PJ_SUCCESS)\n\t    {\n\t\tparam.last_native_err = ssi.last_native_err;\n\t    }\n\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\n\treturn PJ_FALSE;\n    }\n\n    PJ_ASSERT_RETURN(new_ssock, PJ_TRUE);\n\n    if (!listener->is_registered) {\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = PJSIP_TLS_EACCEPT;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\treturn PJ_FALSE;\n    }\t\n\n    PJ_LOG(4,(listener->factory.obj_name, \n\t      \"TLS listener %s: got incoming TLS connection \"\n\t      \"from %s, sock=%d\",\n\t      pj_addr_str_print(&listener->factory.addr_name.host, \n\t\t\t\tlistener->factory.addr_name.port, addr_buf, \n\t\t\t\tsizeof(addr_buf), 1),\n\t      pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),\n\t      new_ssock));\n\n    /* Retrieve SSL socket info, close the socket if this is failed\n     * as the SSL socket info availability is rather critical here.\n     */\n    status = pj_ssl_sock_get_info(new_ssock, &ssl_info);\n    if (status != PJ_SUCCESS) {\n\tpj_ssl_sock_close(new_ssock);\n\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = status;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Copy to larger buffer, just in case */\n    pj_bzero(&tmp_src_addr, sizeof(tmp_src_addr));\n    pj_sockaddr_cp(&tmp_src_addr, src_addr);\n\n    /* \n     * Incoming connection!\n     * Create TLS transport for the new socket.\n     */\n    status = tls_create( listener, NULL, new_ssock, PJ_TRUE,\n\t\t\t &ssl_info.local_addr, &tmp_src_addr, NULL,\n\t\t\t ssl_info.grp_lock, &tls);\n    \n    if (status != PJ_SUCCESS) {\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = status;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Set the \"pending\" SSL socket user data */\n    pj_ssl_sock_set_user_data(new_ssock, tls);\n\n    /* Prevent immediate transport destroy as application may access it \n     * (getting info, etc) in transport state notification callback.\n     */\n    pjsip_transport_add_ref(&tls->base);\n\n    /* If there is verification error and verification is mandatory, shutdown\n     * and destroy the transport.\n     */\n    if (ssl_info.verify_status && listener->tls_setting.verify_client) {\n\tif (tls->close_reason == PJ_SUCCESS) \n\t    tls->close_reason = PJSIP_TLS_ECERTVERIF;\n\tpjsip_transport_shutdown(&tls->base);\n    }\n    /* Notify transport state to application */\n    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpjsip_transport_state tp_state;\n\n\t/* Init transport state info */\n\tpj_bzero(&tls_info, sizeof(tls_info));\n\tpj_bzero(&state_info, sizeof(state_info));\n\ttls_info.ssl_sock_info = &ssl_info;\n\tstate_info.ext_info = &tls_info;\n\n\t/* Set transport state based on verification status */\n\tif (ssl_info.verify_status && listener->tls_setting.verify_client)\n\t{\n\t    tp_state = PJSIP_TP_STATE_DISCONNECTED;\n\t    state_info.status = PJSIP_TLS_ECERTVERIF;\n\t} else {\n\t    tp_state = PJSIP_TP_STATE_CONNECTED;\n\t    state_info.status = PJ_SUCCESS;\n\t}\n\n\t(*state_cb)(&tls->base, tp_state, &state_info);\n    }\n\n    /* Release transport reference. If transport is shutting down, it may\n     * get destroyed here.\n     */\n    is_shutdown = tls->base.is_shutdown;\n    pjsip_transport_dec_ref(&tls->base);\n    if (is_shutdown)\n\treturn PJ_TRUE;\n\n\n    status = tls_start_read(tls);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(3,(tls->base.obj_name, \"New transport cancelled\"));\n\ttls_init_shutdown(tls, status);\n\ttls_destroy(&tls->base, status);\n    } else {\n\t/* Start keep-alive timer */\n\tif (pjsip_cfg()->tls.keep_alive_interval) {\n\t    pj_time_val delay = {0};\t    \n\t    delay.sec = pjsip_cfg()->tls.keep_alive_interval;\n\t    pjsip_endpt_schedule_timer(listener->endpt, \n\t\t\t\t       &tls->ka_timer, \n\t\t\t\t       &delay);\n\t    tls->ka_timer.id = PJ_TRUE;\n\t    pj_gettimeofday(&tls->last_activity);\n\t}\n    }\n\n    return PJ_TRUE;\n}\n\n/*\n * This callback is called by SSL socket when pending accept() operation\n * has completed.\n */\n//static pj_bool_t on_accept_complete(pj_ssl_sock_t *ssock,\n//\t\t\t\t    pj_ssl_sock_t *new_ssock,\n//\t\t\t\t    const pj_sockaddr_t *src_addr,\n//\t\t\t\t    int src_addr_len)\n//{\n//    PJ_UNUSED_ARG(src_addr_len);\n//}\n\n\n/* \n * Callback from ioqueue when packet is sent.\n */\nstatic pj_bool_t on_data_sent(pj_ssl_sock_t *ssock,\n\t\t\t      pj_ioqueue_op_key_t *op_key,\n\t\t\t      pj_ssize_t bytes_sent)\n{\n    struct tls_transport *tls = (struct tls_transport*) \n    \t\t\t\tpj_ssl_sock_get_user_data(ssock);\n    pjsip_tx_data_op_key *tdata_op_key = (pjsip_tx_data_op_key*)op_key;\n\n    /* Note that op_key may be the op_key from keep-alive, thus\n     * it will not have tdata etc.\n     */\n\n    tdata_op_key->tdata = NULL;\n\n    if (tdata_op_key->callback) {\n\t/*\n\t * Notify sip_transport.c that packet has been sent.\n\t */\n\tif (bytes_sent == 0)\n\t    bytes_sent = -PJ_RETURN_OS_ERROR(OSERR_ENOTCONN);\n\n\ttdata_op_key->callback(&tls->base, tdata_op_key->token, bytes_sent);\n\n\t/* Mark last activity time */\n\tpj_gettimeofday(&tls->last_activity);\n\n    }\n\n    /* Check for error/closure */\n    if (bytes_sent <= 0) {\n\tpj_status_t status;\n\n\tPJ_LOG(5,(tls->base.obj_name, \"TLS send() error, sent=%d\", \n\t\t  bytes_sent));\n\n\tstatus = (bytes_sent == 0) ? PJ_RETURN_OS_ERROR(OSERR_ENOTCONN) :\n\t\t\t\t     (pj_status_t)-bytes_sent;\n\n\ttls_init_shutdown(tls, status);\n\n\treturn PJ_FALSE;\n    }\n    \n    return PJ_TRUE;\n}\n\n\n/* \n * This callback is called by transport manager to send SIP message \n */\nstatic pj_status_t tls_send_msg(pjsip_transport *transport, \n\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\tconst pj_sockaddr_t *rem_addr,\n\t\t\t\tint addr_len,\n\t\t\t\tvoid *token,\n\t\t\t\tpjsip_transport_callback callback)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n    pj_ssize_t size;\n    pj_bool_t delayed = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(transport && tdata, PJ_EINVAL);\n\n    /* Check that there's no pending operation associated with the tdata */\n    PJ_ASSERT_RETURN(tdata->op_key.tdata == NULL, PJSIP_EPENDINGTX);\n    \n    /* Check the address is supported */\n    PJ_ASSERT_RETURN(rem_addr && (addr_len==sizeof(pj_sockaddr_in) ||\n\t                          addr_len==sizeof(pj_sockaddr_in6)),\n\t             PJ_EINVAL);\n\n    /* Init op key. */\n    tdata->op_key.tdata = tdata;\n    tdata->op_key.token = token;\n    tdata->op_key.callback = callback;\n\n    /* If asynchronous connect() has not completed yet, just put the\n     * transmit data in the pending transmission list since we can not\n     * use the socket yet.\n     */\n    if (tls->has_pending_connect) {\n\n\t/*\n\t * Looks like connect() is still in progress. Check again (this time\n\t * with holding the lock) to be sure.\n\t */\n\tpj_lock_acquire(tls->base.lock);\n\n\tif (tls->has_pending_connect) {\n\t    struct delayed_tdata *delayed_tdata;\n\n\t    /*\n\t     * connect() is still in progress. Put the transmit data to\n\t     * the delayed list.\n             * Starting from #1583 (https://trac.pjsip.org/repos/ticket/1583),\n             * we also add timeout value for the transmit data. When the\n             * connect() is completed, the timeout value will be checked to\n             * determine whether the transmit data needs to be sent.\n\t     */\n\t    delayed_tdata = PJ_POOL_ZALLOC_T(tdata->pool, \n\t\t\t\t\t     struct delayed_tdata);\n\t    delayed_tdata->tdata_op_key = &tdata->op_key;\n            if (tdata->msg && tdata->msg->type == PJSIP_REQUEST_MSG) {\n                pj_gettickcount(&delayed_tdata->timeout);\n                delayed_tdata->timeout.msec += pjsip_cfg()->tsx.td;\n                pj_time_val_normalize(&delayed_tdata->timeout);\n            }\n\n\t    pj_list_push_back(&tls->delayed_list, delayed_tdata);\n\t    status = PJ_EPENDING;\n\n\t    /* Prevent pj_ioqueue_send() to be called below */\n\t    delayed = PJ_TRUE;\n\t}\n\n\tpj_lock_release(tls->base.lock);\n    } \n    \n    if (!delayed) {\n\t/*\n\t * Transport is ready to go. Send the packet to ioqueue to be\n\t * sent asynchronously.\n\t */\n\tsize = tdata->buf.cur - tdata->buf.start;\n\tstatus = pj_ssl_sock_send(tls->ssock, \n\t\t\t\t    (pj_ioqueue_op_key_t*)&tdata->op_key,\n\t\t\t\t    tdata->buf.start, &size, 0);\n\n\tif (status != PJ_EPENDING) {\n\t    /* Not pending (could be immediate success or error) */\n\t    tdata->op_key.tdata = NULL;\n\n\t    /* Shutdown transport on closure/errors */\n\t    if (size <= 0) {\n\n\t\tPJ_LOG(5,(tls->base.obj_name, \"TLS send() error, sent=%d\", \n\t\t\t  size));\n\n\t\tif (status == PJ_SUCCESS) \n\t\t    status = PJ_RETURN_OS_ERROR(OSERR_ENOTCONN);\n\n\t\ttls_init_shutdown(tls, status);\n\t    }\n\t}\n    }\n\n    return status;\n}\n\n\n/* \n * This callback is called by transport manager to shutdown transport.\n */\nstatic pj_status_t tls_shutdown(pjsip_transport *transport)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n    \n    /* Stop keep-alive timer. */\n    if (tls->ka_timer.id) {\n\tpjsip_endpt_cancel_timer(tls->base.endpt, &tls->ka_timer);\n\ttls->ka_timer.id = PJ_FALSE;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* \n * Callback from ioqueue that an incoming data is received from the socket.\n */\nstatic pj_bool_t on_data_read(pj_ssl_sock_t *ssock,\n\t\t\t      void *data,\n\t\t\t      pj_size_t size,\n\t\t\t      pj_status_t status,\n\t\t\t      pj_size_t *remainder)\n{\n    enum { MAX_IMMEDIATE_PACKET = 10 };\n    struct tls_transport *tls;\n    pjsip_rx_data *rdata;\n\n    PJ_UNUSED_ARG(data);\n\n    tls = (struct tls_transport*) pj_ssl_sock_get_user_data(ssock);\n    rdata = &tls->rdata;\n\n    /* Don't do anything if transport is closing. */\n    if (tls->is_closing) {\n\ttls->is_closing++;\n\treturn PJ_FALSE;\n    }\n\n    /* Houston, we have packet! Report the packet to transport manager\n     * to be parsed.\n     */\n    if (status == PJ_SUCCESS) {\n\tpj_size_t size_eaten;\n\n\t/* Mark this as an activity */\n\tpj_gettimeofday(&tls->last_activity);\n\n\tpj_assert((void*)rdata->pkt_info.packet == data);\n\n\t/* Init pkt_info part. */\n\trdata->pkt_info.len = size;\n\trdata->pkt_info.zero = 0;\n\tpj_gettimeofday(&rdata->pkt_info.timestamp);\n\n\t/* Report to transport manager.\n\t * The transport manager will tell us how many bytes of the packet\n\t * have been processed (as valid SIP message).\n\t */\n\tsize_eaten = \n\t    pjsip_tpmgr_receive_packet(rdata->tp_info.transport->tpmgr, \n\t\t\t\t       rdata);\n\n\tpj_assert(size_eaten <= (pj_size_t)rdata->pkt_info.len);\n\n\t/* Move unprocessed data to the front of the buffer */\n\t*remainder = size - size_eaten;\n\tif (*remainder > 0 && *remainder != size) {\n\t    pj_memmove(rdata->pkt_info.packet,\n\t\t       rdata->pkt_info.packet + size_eaten,\n\t\t       *remainder);\n\t}\n\n    } else {\n\n\t/* Transport is closed */\n\tPJ_LOG(4,(tls->base.obj_name, \"TLS connection closed\"));\n\n\ttls_init_shutdown(tls, status);\n\n\treturn PJ_FALSE;\n\n    }\n\n    /* Reset pool. */\n    pj_pool_reset(rdata->tp_info.pool);\n\n    return PJ_TRUE;\n}\n\n\n/* \n * Callback from ioqueue when asynchronous connect() operation completes.\n */\nstatic pj_bool_t on_connect_complete(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_status_t status)\n{\n    struct tls_transport *tls;\n    pj_ssl_sock_info ssl_info;\n    pj_sockaddr addr, *tp_addr;\n    pjsip_tp_state_callback state_cb;\n    pj_bool_t is_shutdown;\n    char local_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n    char remote_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n\n    tls = (struct tls_transport*) pj_ssl_sock_get_user_data(ssock);\n\n    /* If transport is being shutdown/destroyed, proceed as error connect.\n     * Note that it is important to notify application via on_data_sent()\n     * as otherwise the transport reference counter may never reach zero\n     * (see #1898).\n     */\n    if ((tls->base.is_shutdown || tls->base.is_destroying) &&\n\tstatus == PJ_SUCCESS)\n    {\n\tstatus = PJ_ECANCELLED;\n    }\n\n    /* Check connect() status */\n    if (status != PJ_SUCCESS) {\n\n\ttls_perror(tls->base.obj_name, \"TLS connect() error\", status,\n\t\t   &tls->remote_name);\n\n\t/* Cancel all delayed transmits */\n\twhile (!pj_list_empty(&tls->delayed_list)) {\n\t    struct delayed_tdata *pending_tx;\n\t    pj_ioqueue_op_key_t *op_key;\n\n\t    pending_tx = tls->delayed_list.next;\n\t    pj_list_erase(pending_tx);\n\n\t    op_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n\t    on_data_sent(tls->ssock, op_key, -status);\n\t}\n\n\tgoto on_error;\n    }\n\n    /* Retrieve SSL socket info, shutdown the transport if this is failed\n     * as the SSL socket info availability is rather critical here.\n     */\n    status = pj_ssl_sock_get_info(tls->ssock, &ssl_info);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Update (again) local address, just in case local address currently\n     * set is different now that the socket is connected (could happen\n     * on some systems, like old Win32 probably?).\n     */\n    tp_addr = &tls->base.local_addr;\n    pj_sockaddr_cp((pj_sockaddr_t*)&addr, \n\t\t   (pj_sockaddr_t*)&ssl_info.local_addr);\n    if (pj_sockaddr_cmp(tp_addr, &addr) != 0) {\n\tpj_sockaddr_cp(tp_addr, &addr);\n\tsockaddr_to_host_port(tls->base.pool, &tls->base.local_name,\n\t\t\t      tp_addr);\n    }\n\n    /* Server identity verification based on server certificate. */\n    if (ssl_info.remote_cert_info->version) {\n\tpj_str_t *remote_name;\n\tpj_ssl_cert_info *serv_cert = ssl_info.remote_cert_info;\n\tpj_bool_t matched = PJ_FALSE;\n\tunsigned i;\n\n\t/* Remote name may be hostname or IP address */\n\tif (tls->remote_name.slen)\n\t    remote_name = &tls->remote_name;\n\telse\n\t    remote_name = &tls->base.remote_name.host;\n\n\t/* Start matching remote name with SubjectAltName fields of \n\t * server certificate.\n\t */\n\tfor (i = 0; i < serv_cert->subj_alt_name.cnt && !matched; ++i) {\n\t    pj_str_t *cert_name = &serv_cert->subj_alt_name.entry[i].name;\n\n\t    switch (serv_cert->subj_alt_name.entry[i].type) {\n\t    case PJ_SSL_CERT_NAME_DNS:\n\t    case PJ_SSL_CERT_NAME_IP:\n\t\tmatched = !pj_stricmp(remote_name, cert_name);\n\t\tbreak;\n\t    case PJ_SSL_CERT_NAME_URI:\n\t\tif (pj_strnicmp2(cert_name, \"sip:\", 4) == 0 ||\n\t\t    pj_strnicmp2(cert_name, \"sips:\", 5) == 0)\n\t\t{\n\t\t    pj_str_t host_part;\n\t\t    char *p;\n\n\t\t    p = pj_strchr(cert_name, ':') + 1;\n\t\t    pj_strset(&host_part, p, cert_name->slen - \n\t\t\t\t\t     (p - cert_name->ptr));\n\t\t    matched = !pj_stricmp(remote_name, &host_part);\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    \t\n\t/* When still not matched or no SubjectAltName fields in server\n\t * certificate, try with Common Name of Subject field.\n\t */\n\tif (!matched) {\n\t    matched = !pj_stricmp(remote_name, &serv_cert->subject.cn);\n\t}\n\n\tif (!matched) {\n\t    if (pj_strnicmp2(&serv_cert->subject.cn, \"*.\", 2) == 0) {\n\t\tPJ_LOG(1,(tls->base.obj_name,\n\t\t    \"RFC 5922 (section 7.2) does not allow TLS wildcard \"\n\t\t\t\"certificates. Advise your SIP provider, please!\"));\n\t    }\n\t    ssl_info.verify_status |= PJ_SSL_CERT_EIDENTITY_NOT_MATCH;\n\t}\n    }\n\n    /* Prevent immediate transport destroy as application may access it \n     * (getting info, etc) in transport state notification callback.\n     */\n    pjsip_transport_add_ref(&tls->base);\n\n    /* If there is verification error and verification is mandatory, shutdown\n     * and destroy the transport.\n     */\n    if (ssl_info.verify_status && tls->verify_server) {\n\tif (tls->close_reason == PJ_SUCCESS) \n\t    tls->close_reason = PJSIP_TLS_ECERTVERIF;\n\tpjsip_transport_shutdown(&tls->base);\n    }\n\n    /* Notify transport state to application */\n    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpjsip_transport_state tp_state;\n\n\t/* Init transport state info */\n\tpj_bzero(&state_info, sizeof(state_info));\n\tpj_bzero(&tls_info, sizeof(tls_info));\n\tstate_info.ext_info = &tls_info;\n\ttls_info.ssl_sock_info = &ssl_info;\n\n\t/* Set transport state based on verification status */\n\tif (ssl_info.verify_status && tls->verify_server)\n\t{\n\t    tp_state = PJSIP_TP_STATE_DISCONNECTED;\n\t    state_info.status = PJSIP_TLS_ECERTVERIF;\n\t} else {\n\t    tp_state = PJSIP_TP_STATE_CONNECTED;\n\t    state_info.status = PJ_SUCCESS;\n\t}\n\n\t(*state_cb)(&tls->base, tp_state, &state_info);\n    }\n\n    /* Release transport reference. If transport is shutting down, it may\n     * get destroyed here.\n     */\n    is_shutdown = tls->base.is_shutdown;\n    pjsip_transport_dec_ref(&tls->base);\n    if (is_shutdown) {\n\tstatus = tls->close_reason;\n\ttls_perror(tls->base.obj_name, \"TLS connect() error\", status, \n\t\t   &tls->remote_name);\n\n\t/* Cancel all delayed transmits */\n\twhile (!pj_list_empty(&tls->delayed_list)) {\n\t    struct delayed_tdata *pending_tx;\n\t    pj_ioqueue_op_key_t *op_key;\n\n\t    pending_tx = tls->delayed_list.next;\n\t    pj_list_erase(pending_tx);\n\n\t    op_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n\t    on_data_sent(tls->ssock, op_key, -status);\n\t}\n\n\treturn PJ_FALSE;\n    }\n\n\n    /* Mark that pending connect() operation has completed. */\n    tls->has_pending_connect = PJ_FALSE;\n\n    PJ_LOG(4,(tls->base.obj_name, \n\t      \"TLS transport %s is connected to %s\",\n\t      pj_addr_str_print(&tls->base.local_name.host, \n\t\t\t\ttls->base.local_name.port, local_addr_buf, \n\t\t\t\tsizeof(local_addr_buf), 1),\n\t      pj_addr_str_print(&tls->base.remote_name.host, \n\t\t\t\ttls->base.remote_name.port, remote_addr_buf, \n\t\t\t\tsizeof(remote_addr_buf), 1)));\n\n    /* Start pending read */\n    status = tls_start_read(tls);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Flush all pending send operations */\n    tls_flush_pending_tx(tls);\n\n    /* Start keep-alive timer */\n    if (pjsip_cfg()->tls.keep_alive_interval) {\n\tpj_time_val delay = {0};\t    \n\tdelay.sec = pjsip_cfg()->tls.keep_alive_interval;\n\tpjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, \n\t\t\t\t   &delay);\n\ttls->ka_timer.id = PJ_TRUE;\n\tpj_gettimeofday(&tls->last_activity);\n    }\n\n    return PJ_TRUE;\n\non_error:\n    tls_init_shutdown(tls, status);\n\n    return PJ_FALSE;\n}\n\n\n/* Transport keep-alive timer callback */\nstatic void tls_keep_alive_timer(pj_timer_heap_t *th, pj_timer_entry *e)\n{\n    struct tls_transport *tls = (struct tls_transport*) e->user_data;\n    pj_time_val delay;\n    pj_time_val now;\n    pj_ssize_t size;\n    pj_status_t status;\n    char addr[PJ_INET6_ADDRSTRLEN+10];    \n\n    PJ_UNUSED_ARG(th);\n\n    tls->ka_timer.id = PJ_TRUE;\n\n    pj_gettimeofday(&now);\n    PJ_TIME_VAL_SUB(now, tls->last_activity);\n\n    if (now.sec > 0 && now.sec < pjsip_cfg()->tls.keep_alive_interval) {\n\t/* There has been activity, so don't send keep-alive */\n\tdelay.sec = pjsip_cfg()->tls.keep_alive_interval - now.sec;\n\tdelay.msec = 0;\n\n\tpjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, \n\t\t\t\t   &delay);\n\ttls->ka_timer.id = PJ_TRUE;\n\treturn;\n    }\n\n    PJ_LOG(5,(tls->base.obj_name, \"Sending %d byte(s) keep-alive to %s\", \n\t      (int)tls->ka_pkt.slen, \n\t      pj_addr_str_print(&tls->base.remote_name.host, \n\t\t\t\ttls->base.remote_name.port, addr, \n\t\t\t\tsizeof(addr), 1)));\n\n    /* Send the data */\n    size = tls->ka_pkt.slen;\n    status = pj_ssl_sock_send(tls->ssock, &tls->ka_op_key.key,\n\t\t\t      tls->ka_pkt.ptr, &size, 0);\n\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\ttls_perror(tls->base.obj_name, \n\t\t   \"Error sending keep-alive packet\", status,\n\t\t   &tls->remote_name);\n\n\ttls_init_shutdown(tls, status);\n\treturn;\n    }\n\n    /* Register next keep-alive */\n    delay.sec = pjsip_cfg()->tls.keep_alive_interval;\n    delay.msec = 0;\n\n    pjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, \n\t\t\t       &delay);\n    tls->ka_timer.id = PJ_TRUE;\n}\n\n\nstatic void wipe_buf(pj_str_t *buf)\n{\n    volatile char *p = buf->ptr;\n    pj_ssize_t len = buf->slen;\n    while (len--) *p++ = 0;\n    buf->slen = 0;\n}\n\n/*\n * Wipe out certificates and keys in the TLS setting buffer.\n */\nPJ_DEF(void) pjsip_tls_setting_wipe_keys(pjsip_tls_setting *opt)\n{\n    wipe_buf(&opt->ca_list_file);\n    wipe_buf(&opt->ca_list_path);\n    wipe_buf(&opt->cert_file);\n    wipe_buf(&opt->privkey_file);\n    wipe_buf(&opt->password);\n    wipe_buf(&opt->sigalgs);\n    wipe_buf(&opt->entropy_path);\n    wipe_buf(&opt->ca_buf);\n    wipe_buf(&opt->cert_buf);\n    wipe_buf(&opt->privkey_buf);    \n}\n\n#endif /* PJSIP_HAS_TLS_TRANSPORT */\n"], "fixing_code": ["/* \n * Copyright (C) 2019-2019 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pj/ssl_sock.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#include \"ssl_sock_imp_common.h\"\n\n/* Workaround for ticket #985 and #1930 */\n#ifndef PJ_SSL_SOCK_DELAYED_CLOSE_TIMEOUT\n#   define PJ_SSL_SOCK_DELAYED_CLOSE_TIMEOUT\t500\n#endif\n\nenum { MAX_BIND_RETRY = 100 };\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\nstatic pj_bool_t asock_on_data_read (pj_activesock_t *asock,\n\t\t\t\t     void *data,\n\t\t\t\t     pj_size_t size,\n\t\t\t\t     pj_status_t status,\n\t\t\t\t     pj_size_t *remainder);\n\nstatic pj_bool_t asock_on_data_sent (pj_activesock_t *asock,\n\t\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t\t     pj_ssize_t sent);\n#endif\n\n#ifdef SSL_SOCK_IMP_USE_CIRC_BUF\n/*\n *******************************************************************\n * Circular buffer functions.\n *******************************************************************\n */\n\nstatic pj_status_t circ_init(pj_pool_factory *factory,\n                             circ_buf_t *cb, pj_size_t cap)\n{\n    cb->cap    = cap;\n    cb->readp  = 0;\n    cb->writep = 0;\n    cb->size   = 0;\n\n    /* Initial pool holding the buffer elements */\n    cb->pool = pj_pool_create(factory, \"tls-circ%p\", cap, cap, NULL);\n    if (!cb->pool)\n        return PJ_ENOMEM;\n\n    /* Allocate circular buffer */\n    cb->buf = pj_pool_alloc(cb->pool, cap);\n    if (!cb->buf) {\n        pj_pool_release(cb->pool);\n        return PJ_ENOMEM;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic void circ_deinit(circ_buf_t *cb)\n{\n    if (cb->pool) {\n        pj_pool_release(cb->pool);\n        cb->pool = NULL;\n    }\n}\n\nstatic pj_bool_t circ_empty(const circ_buf_t *cb)\n{\n    return cb->size == 0;\n}\n\nstatic pj_size_t circ_size(const circ_buf_t *cb)\n{\n    return cb->size;\n}\n\nstatic pj_size_t circ_avail(const circ_buf_t *cb)\n{\n    return cb->cap - cb->size;\n}\n\nstatic void circ_read(circ_buf_t *cb, pj_uint8_t *dst, pj_size_t len)\n{\n    pj_size_t size_after = cb->cap - cb->readp;\n    pj_size_t tbc = PJ_MIN(size_after, len);\n    pj_size_t rem = len - tbc;\n\n    pj_memcpy(dst, cb->buf + cb->readp, tbc);\n    pj_memcpy(dst + tbc, cb->buf, rem);\n\n    cb->readp += len;\n    cb->readp &= (cb->cap - 1);\n\n    cb->size -= len;\n}\n\nstatic pj_status_t circ_write(circ_buf_t *cb,\n                              const pj_uint8_t *src, pj_size_t len)\n{\n    /* Overflow condition: resize */\n    if (len > circ_avail(cb)) {\n        /* Minimum required capacity */\n        pj_size_t min_cap = len + cb->size;\n\n        /* Next 32-bit power of two */\n        min_cap--;\n        min_cap |= min_cap >> 1;\n        min_cap |= min_cap >> 2;\n        min_cap |= min_cap >> 4;\n        min_cap |= min_cap >> 8;\n        min_cap |= min_cap >> 16;\n        min_cap++;\n\n        /* Create a new pool to hold a bigger buffer, using the same factory */\n        pj_pool_t *pool = pj_pool_create(cb->pool->factory, \"tls-circ%p\",\n                                         min_cap, min_cap, NULL);\n        if (!pool)\n            return PJ_ENOMEM;\n\n        /* Allocate our new buffer */\n        pj_uint8_t *buf = pj_pool_alloc(pool, min_cap);\n        if (!buf) {\n            pj_pool_release(pool);\n            return PJ_ENOMEM;\n        }\n\n        /* Save old size, which we shall restore after the next read */\n        pj_size_t old_size = cb->size;\n\n        /* Copy old data into beginning of new buffer */\n        circ_read(cb, buf, cb->size);\n\n        /* Restore old size now */\n        cb->size = old_size;\n\n        /* Release the previous pool */\n        pj_pool_release(cb->pool);\n\n        /* Update circular buffer members */\n        cb->pool = pool;\n        cb->buf = buf;\n        cb->readp = 0;\n        cb->writep = cb->size;\n        cb->cap = min_cap;\n    }\n\n    pj_size_t size_after = cb->cap - cb->writep;\n    pj_size_t tbc = PJ_MIN(size_after, len);\n    pj_size_t rem = len - tbc;\n\n    pj_memcpy(cb->buf + cb->writep, src, tbc);\n    pj_memcpy(cb->buf, src + tbc, rem);\n\n    cb->writep += len;\n    cb->writep &= (cb->cap - 1);\n\n    cb->size += len;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n/*\n *******************************************************************\n * Helper functions.\n *******************************************************************\n */\n\n/* Check IP address version. */\nstatic int get_ip_addr_ver(const pj_str_t *host)\n{\n    pj_in_addr dummy;\n    pj_in6_addr dummy6;\n\n    /* First check if this is an IPv4 address */\n    if (pj_inet_pton(pj_AF_INET(), host, &dummy) == PJ_SUCCESS)\n\treturn 4;\n\n    /* Then check if this is an IPv6 address */\n    if (pj_inet_pton(pj_AF_INET6(), host, &dummy6) == PJ_SUCCESS)\n\treturn 6;\n\n    /* Not an IP address */\n    return 0;\n}\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n/* Close sockets */\nstatic void ssl_close_sockets(pj_ssl_sock_t *ssock)\n{\n    pj_activesock_t *asock;\n    pj_sock_t sock;\n\n    /* This can happen when pj_ssl_sock_create() fails. */\n    if (!ssock->write_mutex)\n    \treturn;\n\n    pj_lock_acquire(ssock->write_mutex);\n    asock = ssock->asock;\n    if (asock) {\n        // Don't set ssock->asock to NULL, as it may trigger assertion in\n        // send operation. This should be safe as active socket will simply\n        // return PJ_EINVALIDOP on any operation if it is already closed.\n        //ssock->asock = NULL;\n        ssock->sock = PJ_INVALID_SOCKET;\n    }\n    sock = ssock->sock;\n    if (sock != PJ_INVALID_SOCKET)\n        ssock->sock = PJ_INVALID_SOCKET;\n    pj_lock_release(ssock->write_mutex);\n\n    if (asock)\n        pj_activesock_close(asock);\n\n    if (sock != PJ_INVALID_SOCKET)\n        pj_sock_close(sock);\n}\n#endif\n\n/* When handshake completed:\n * - notify application\n * - if handshake failed, reset SSL state\n * - return PJ_FALSE when SSL socket instance is destroyed by application.\n */\nstatic pj_bool_t on_handshake_complete(pj_ssl_sock_t *ssock, \n\t\t\t\t       pj_status_t status)\n{\n    /* Cancel handshake timer */\n    if (ssock->timer.id == TIMER_HANDSHAKE_TIMEOUT) {\n\tpj_timer_heap_cancel(ssock->param.timer_heap, &ssock->timer);\n\tssock->timer.id = TIMER_NONE;\n    }\n\n    /* Update certificates info on successful handshake */\n    if (status == PJ_SUCCESS)\n\tssl_update_certs_info(ssock);\n\n    /* Accepting */\n    if (ssock->is_server) {\n\tpj_bool_t ret = PJ_TRUE;\n\n\tif (status != PJ_SUCCESS) {\n\t    /* Handshake failed in accepting, destroy our self silently. */\n\n\t    char buf[PJ_INET6_ADDRSTRLEN+10];\n\n\t    PJ_PERROR(3,(ssock->pool->obj_name, status,\n\t\t\t \"Handshake failed in accepting %s\",\n\t\t\t pj_sockaddr_print(&ssock->rem_addr, buf,\n\t\t\t\t\t   sizeof(buf), 3)));\n\n\t    if (ssock->param.cb.on_accept_complete2) {\n\t\t(*ssock->param.cb.on_accept_complete2) \n\t\t      (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr, \n\t\t      pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr), \n\t\t      status);\n\t    }\n\n\t    /* Decrement ref count of parent */\n\t    if (ssock->parent->param.grp_lock) {\n\t\tpj_grp_lock_dec_ref(ssock->parent->param.grp_lock);\n\t\tssock->parent = NULL;\n\t    }\n\n\t    /* Originally, this is a workaround for ticket #985. However,\n\t     * a race condition may occur in multiple worker threads\n\t     * environment when we are destroying SSL objects while other\n\t     * threads are still accessing them.\n\t     * Please see ticket #1930 for more info.\n\t     */\n#if 1 //(defined(PJ_WIN32) && PJ_WIN32!=0)||(defined(PJ_WIN64) && PJ_WIN64!=0)\n\t    if (ssock->param.timer_heap) {\n\t\tpj_time_val interval = {0, PJ_SSL_SOCK_DELAYED_CLOSE_TIMEOUT};\n\t\tpj_status_t status1;\n\n\t\tssock->ssl_state = SSL_STATE_NULL;\n\t\tssl_close_sockets(ssock);\n\n\t\tif (ssock->timer.id != TIMER_NONE) {\n\t\t    pj_timer_heap_cancel(ssock->param.timer_heap,\n\t\t\t\t\t &ssock->timer);\n\t\t}\n\t\tpj_time_val_normalize(&interval);\n\t\tstatus1 = pj_timer_heap_schedule_w_grp_lock(\n\t\t\t\t\t\t ssock->param.timer_heap, \n\t\t\t\t\t\t &ssock->timer,\n\t\t\t\t\t\t &interval,\n\t\t\t\t\t\t TIMER_CLOSE,\n\t\t\t\t\t\t ssock->param.grp_lock);\n\t\tif (status1 != PJ_SUCCESS) {\n\t    \t    PJ_PERROR(3,(ssock->pool->obj_name, status,\n\t\t\t\t \"Failed to schedule a delayed close. \"\n\t\t\t\t \"Race condition may occur.\"));\n\t\t    ssock->timer.id = TIMER_NONE;\n\t\t    pj_ssl_sock_close(ssock);\n\t\t}\n\t    } else {\n\t\tpj_ssl_sock_close(ssock);\n\t    }\n#else\n\t    {\n\t\tpj_ssl_sock_close(ssock);\n\t    }\n#endif\n\n\t    return PJ_FALSE;\n\t}\n\n\t/* Notify application the newly accepted SSL socket */\n\tif (ssock->param.cb.on_accept_complete2) {\n\t    ret = (*ssock->param.cb.on_accept_complete2) \n\t\t    (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr, \n\t\t    pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr), \n\t\t    status);\n\t} else if (ssock->param.cb.on_accept_complete) {\n\t    ret = (*ssock->param.cb.on_accept_complete)\n\t\t      (ssock->parent, ssock, (pj_sockaddr_t*)&ssock->rem_addr,\n\t\t       pj_sockaddr_get_len((pj_sockaddr_t*)&ssock->rem_addr));\n\t}\n\n\t/* Decrement ref count of parent and reset parent (we don't need it\n\t * anymore, right?).\n\t */\n\tif (ssock->parent->param.grp_lock) {\n\t    pj_grp_lock_dec_ref(ssock->parent->param.grp_lock);\n\t    ssock->parent = NULL;\n\t}\n\n\tif (ret == PJ_FALSE)\n\t    return PJ_FALSE;\n    }\n\n    /* Connecting */\n    else {\n\t/* On failure, reset SSL socket state first, as app may try to \n\t * reconnect in the callback.\n\t */\n\tif (status != PJ_SUCCESS) {\n\t    /* Server disconnected us, possibly due to SSL nego failure */\n\t    ssl_reset_sock_state(ssock);\n\t}\n\tif (ssock->param.cb.on_connect_complete) {\n\t    pj_bool_t ret;\n\t    ret = (*ssock->param.cb.on_connect_complete)(ssock, status);\n\t    if (ret == PJ_FALSE)\n\t\treturn PJ_FALSE;\n\t}\n    }\n\n    return PJ_TRUE;\n}\n\nstatic write_data_t* alloc_send_data(pj_ssl_sock_t *ssock, pj_size_t len)\n{\n    send_buf_t *send_buf = &ssock->send_buf;\n    pj_size_t avail_len, skipped_len = 0;\n    char *reg1, *reg2;\n    pj_size_t reg1_len, reg2_len;\n    write_data_t *p;\n\n    /* Check buffer availability */\n    avail_len = send_buf->max_len - send_buf->len;\n    if (avail_len < len)\n\treturn NULL;\n\n    /* If buffer empty, reset start pointer and return it */\n    if (send_buf->len == 0) {\n\tsend_buf->start = send_buf->buf;\n\tsend_buf->len   = len;\n\tp = (write_data_t*)send_buf->start;\n\tgoto init_send_data;\n    }\n\n    /* Free space may be wrapped/splitted into two regions, so let's\n     * analyze them if any region can hold the write data.\n     */\n    reg1 = send_buf->start + send_buf->len;\n    if (reg1 >= send_buf->buf + send_buf->max_len)\n\treg1 -= send_buf->max_len;\n    reg1_len = send_buf->max_len - send_buf->len;\n    if (reg1 + reg1_len > send_buf->buf + send_buf->max_len) {\n\treg1_len = send_buf->buf + send_buf->max_len - reg1;\n\treg2 = send_buf->buf;\n\treg2_len = send_buf->start - send_buf->buf;\n    } else {\n\treg2 = NULL;\n\treg2_len = 0;\n    }\n\n    /* More buffer availability check, note that the write data must be in\n     * a contigue buffer.\n     */\n    avail_len = PJ_MAX(reg1_len, reg2_len);\n    if (avail_len < len)\n\treturn NULL;\n\n    /* Get the data slot */\n    if (reg1_len >= len) {\n\tp = (write_data_t*)reg1;\n    } else {\n\tp = (write_data_t*)reg2;\n\tskipped_len = reg1_len;\n    }\n\n    /* Update buffer length */\n    send_buf->len += len + skipped_len;\n\ninit_send_data:\n    /* Init the new send data */\n    pj_bzero(p, sizeof(*p));\n    pj_list_init(p);\n    pj_list_push_back(&ssock->send_pending, p);\n\n    return p;\n}\n\nstatic void free_send_data(pj_ssl_sock_t *ssock, write_data_t *wdata)\n{\n    send_buf_t *buf = &ssock->send_buf;\n    write_data_t *spl = &ssock->send_pending;\n\n    pj_assert(!pj_list_empty(&ssock->send_pending));\n    \n    /* Free slot from the buffer */\n    if (spl->next == wdata && spl->prev == wdata) {\n\t/* This is the only data, reset the buffer */\n\tbuf->start = buf->buf;\n\tbuf->len = 0;\n    } else if (spl->next == wdata) {\n\t/* This is the first data, shift start pointer of the buffer and\n\t * adjust the buffer length.\n\t */\n\tbuf->start = (char*)wdata->next;\n\tif (wdata->next > wdata) {\n\t    buf->len -= ((char*)wdata->next - buf->start);\n\t} else {\n\t    /* Overlapped */\n\t    pj_size_t right_len, left_len;\n\t    right_len = buf->buf + buf->max_len - (char*)wdata;\n\t    left_len  = (char*)wdata->next - buf->buf;\n\t    buf->len -= (right_len + left_len);\n\t}\n    } else if (spl->prev == wdata) {\n\t/* This is the last data, just adjust the buffer length */\n\tif (wdata->prev < wdata) {\n\t    pj_size_t jump_len;\n\t    jump_len = (char*)wdata -\n\t\t       ((char*)wdata->prev + wdata->prev->record_len);\n\t    buf->len -= (wdata->record_len + jump_len);\n\t} else {\n\t    /* Overlapped */\n\t    pj_size_t right_len, left_len;\n\t    right_len = buf->buf + buf->max_len -\n\t\t\t((char*)wdata->prev + wdata->prev->record_len);\n\t    left_len  = (char*)wdata + wdata->record_len - buf->buf;\n\t    buf->len -= (right_len + left_len);\n\t}\n    }\n    /* For data in the middle buffer, just do nothing on the buffer. The slot\n     * will be freed later when freeing the first/last data.\n     */\n    \n    /* Remove the data from send pending list */\n    pj_list_erase(wdata);\n}\n\n/* Flush write circular buffer to network socket. */\nstatic pj_status_t flush_circ_buf_output(pj_ssl_sock_t *ssock,\n                                         pj_ioqueue_op_key_t *send_key,\n                                         pj_size_t orig_len, unsigned flags)\n{\n    pj_ssize_t len;\n    write_data_t *wdata;\n    pj_size_t needed_len;\n    pj_status_t status;\n\n    pj_lock_acquire(ssock->write_mutex);\n\n    /* Check if there is data in the circular buffer, flush it if any */\n    if (io_empty(ssock, &ssock->circ_buf_output)) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_SUCCESS;\n    }\n\n    /* Get data and its length */\n    len = io_size(ssock, &ssock->circ_buf_output);\n    if (len == 0) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_SUCCESS;\n    }\n\n    /* Calculate buffer size needed, and align it to 8 */\n    needed_len = len + sizeof(write_data_t);\n    needed_len = ((needed_len + 7) >> 3) << 3;\n\n    /* Allocate buffer for send data */\n    wdata = alloc_send_data(ssock, needed_len);\n    if (wdata == NULL) {\n\t/* Oops, the send buffer is full, let's just\n\t * queue it for sending and return PJ_EPENDING.\n\t */\n\tssock->send_buf_pending.data_len = needed_len;\n\tssock->send_buf_pending.app_key = send_key;\n\tssock->send_buf_pending.flags = flags;\n\tssock->send_buf_pending.plain_data_len = orig_len;\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_EPENDING;\n    }\n\n    /* Copy the data and set its properties into the send data */\n    pj_ioqueue_op_key_init(&wdata->key, sizeof(pj_ioqueue_op_key_t));\n    wdata->key.user_data = wdata;\n    wdata->app_key = send_key;\n    wdata->record_len = needed_len;\n    wdata->data_len = len;\n    wdata->plain_data_len = orig_len;\n    wdata->flags = flags;\n    io_read(ssock, &ssock->circ_buf_output, (pj_uint8_t *)&wdata->data, len);\n\n    /* Ticket #1573: Don't hold mutex while calling PJLIB socket send(). */\n    pj_lock_release(ssock->write_mutex);\n\n    /* Send it */\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_send(ssock, &wdata->key, wdata->data.content, &len,\n\t\t\t  flags);\n#else\n    if (ssock->param.sock_type == pj_SOCK_STREAM()) {\n\tstatus = pj_activesock_send(ssock->asock, &wdata->key, \n\t\t\t\t    wdata->data.content, &len,\n\t\t\t\t    flags);\n    } else {\n\tstatus = pj_activesock_sendto(ssock->asock, &wdata->key, \n\t\t\t\t      wdata->data.content, &len,\n\t\t\t\t      flags,\n\t\t\t\t      (pj_sockaddr_t*)&ssock->rem_addr,\n\t\t\t\t      ssock->addr_len);\n    }\n#endif\n\n    if (status != PJ_EPENDING) {\n\t/* When the sending is not pending, remove the wdata from send\n\t * pending list.\n\t */\n\tpj_lock_acquire(ssock->write_mutex);\n\tfree_send_data(ssock, wdata);\n\tpj_lock_release(ssock->write_mutex);\n    }\n\n    return status;\n}\n\n#if 0\n/* Just for testing send buffer alloc/free */\n#include <pj/rand.h>\npj_status_t pj_ssl_sock_ossl_test_send_buf(pj_pool_t *pool)\n{\n    enum { MAX_CHUNK_NUM = 20 };\n    unsigned chunk_size, chunk_cnt, i;\n    write_data_t *wdata[MAX_CHUNK_NUM] = {0};\n    pj_time_val now;\n    pj_ssl_sock_t *ssock = NULL;\n    pj_ssl_sock_param param;\n    pj_status_t status;\n\n    pj_gettimeofday(&now);\n    pj_srand((unsigned)now.sec);\n\n    pj_ssl_sock_param_default(&param);\n    status = pj_ssl_sock_create(pool, &param, &ssock);\n    if (status != PJ_SUCCESS) {\n\treturn status;\n    }\n\n    if (ssock->send_buf.max_len == 0) {\n\tssock->send_buf.buf = (char*)\n\t\t\t      pj_pool_alloc(ssock->pool, \n\t\t\t\t\t    ssock->param.send_buffer_size);\n\tssock->send_buf.max_len = ssock->param.send_buffer_size;\n\tssock->send_buf.start = ssock->send_buf.buf;\n\tssock->send_buf.len = 0;\n    }\n\n    chunk_size = ssock->param.send_buffer_size / MAX_CHUNK_NUM / 2;\n    chunk_cnt = 0;\n    for (i = 0; i < MAX_CHUNK_NUM; i++) {\n\twdata[i] = alloc_send_data(ssock, pj_rand() % chunk_size + 321);\n\tif (wdata[i])\n\t    chunk_cnt++;\n\telse\n\t    break;\n    }\n\n    while (chunk_cnt) {\n\ti = pj_rand() % MAX_CHUNK_NUM;\n\tif (wdata[i]) {\n\t    free_send_data(ssock, wdata[i]);\n\t    wdata[i] = NULL;\n\t    chunk_cnt--;\n\t}\n    }\n\n    if (ssock->send_buf.len != 0)\n\tstatus = PJ_EBUG;\n\n    pj_ssl_sock_close(ssock);\n    return status;\n}\n#endif\n\nstatic void on_timer(pj_timer_heap_t *th, struct pj_timer_entry *te)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)te->user_data;\n    int timer_id = te->id;\n\n    te->id = TIMER_NONE;\n\n    PJ_UNUSED_ARG(th);\n\n    switch (timer_id) {\n    case TIMER_HANDSHAKE_TIMEOUT:\n\tPJ_LOG(1,(ssock->pool->obj_name, \"SSL timeout after %d.%ds\",\n\t\t  ssock->param.timeout.sec, ssock->param.timeout.msec));\n\n\ton_handshake_complete(ssock, PJ_ETIMEDOUT);\n\tbreak;\n    case TIMER_CLOSE:\n\tpj_ssl_sock_close(ssock);\n\tbreak;\n    default:\n\tpj_assert(!\"Unknown timer\");\n\tbreak;\n    }\n}\n\nstatic void ssl_on_destroy(void *arg)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)arg;\n\n    ssl_destroy(ssock);\n\n    if (ssock->circ_buf_input_mutex) {\n        pj_lock_destroy(ssock->circ_buf_input_mutex);\n\tssock->circ_buf_input_mutex = NULL;\n    }\n\n    if (ssock->circ_buf_output_mutex) {\n        pj_lock_destroy(ssock->circ_buf_output_mutex);\n\tssock->circ_buf_output_mutex = NULL;\n\tssock->write_mutex = NULL;\n    }\n\n    /* Secure release pool, i.e: all memory blocks will be zeroed first */\n    pj_pool_secure_release(&ssock->info_pool);\n    pj_pool_secure_release(&ssock->pool);\n}\n\n\n/*\n *******************************************************************\n * Network callbacks.\n *******************************************************************\n */\n\n/*\n * Get the offset of pointer to read-buffer of SSL socket from read-buffer\n * of active socket. Note that both SSL socket and active socket employ \n * different but correlated read-buffers (as much as async_cnt for each),\n * and to make it easier/faster to find corresponding SSL socket's read-buffer\n * from known active socket's read-buffer, the pointer of corresponding \n * SSL socket's read-buffer is stored right after the end of active socket's\n * read-buffer.\n */\n#define OFFSET_OF_READ_DATA_PTR(ssock, asock_rbuf) \\\n\t\t\t\t\t(read_data_t**) \\\n\t\t\t\t\t((pj_int8_t*)(asock_rbuf) + \\\n\t\t\t\t\tssock->param.read_buffer_size)\n\nstatic pj_bool_t ssock_on_data_read (pj_ssl_sock_t *ssock,\n\t\t\t\t     void *data,\n\t\t\t\t     pj_size_t size,\n\t\t\t\t     pj_status_t status,\n\t\t\t\t     pj_size_t *remainder)\n{\n    if (status != PJ_SUCCESS)\n    \tgoto on_error;\n\n    if (data && size > 0) {\n    \tpj_status_t status_;\n\n\t/* Consume the whole data */\n        if (ssock->circ_buf_input_mutex)\n\t    pj_lock_acquire(ssock->circ_buf_input_mutex);\n        status_ = io_write(ssock,&ssock->circ_buf_input, data, size);\n        if (ssock->circ_buf_input_mutex)\n            pj_lock_release(ssock->circ_buf_input_mutex);\n        if (status_ != PJ_SUCCESS) {\n            status = status_;\n\t    goto on_error;\n\t}\n    }\n\n    /* Check if SSL handshake hasn't finished yet */\n    if (ssock->ssl_state == SSL_STATE_HANDSHAKING) {\n\tpj_bool_t ret = PJ_TRUE;\n\n\tif (status == PJ_SUCCESS)\n\t    status = ssl_do_handshake(ssock);\n\n\t/* Not pending is either success or failed */\n\tif (status != PJ_EPENDING)\n\t    ret = on_handshake_complete(ssock, status);\n\n\treturn ret;\n    }\n\n    /* See if there is any decrypted data for the application */\n    if (ssock->read_started) {\n\tdo {\n\t    read_data_t *buf = *(OFFSET_OF_READ_DATA_PTR(ssock, data));\n\t    void *data_ = (pj_int8_t*)buf->data + buf->len;\n\t    int size_ = (int)(ssock->read_size - buf->len);\n\t    pj_status_t status_;\n\n\t    status_ = ssl_read(ssock, data_, &size_);\n\n\t    if (size_ > 0 || status != PJ_SUCCESS) {\n\t\tif (ssock->param.cb.on_data_read) {\n\t\t    pj_bool_t ret;\n\t\t    pj_size_t remainder_ = 0;\n\n\t\t    if (size_ > 0)\n\t\t\tbuf->len += size_;\n    \t\t\n                    if (status != PJ_SUCCESS) {\n                        ssock->ssl_state = SSL_STATE_ERROR;\n                    }\n\n\t\t    ret = (*ssock->param.cb.on_data_read)(ssock, buf->data,\n\t\t\t\t\t\t\t  buf->len, status,\n\t\t\t\t\t\t\t  &remainder_);\n\t\t    if (!ret) {\n\t\t\t/* We've been destroyed */\n\t\t\treturn PJ_FALSE;\n\t\t    }\n\n\t\t    /* Application may have left some data to be consumed \n\t\t     * later.\n\t\t     */\n\t\t    buf->len = remainder_;\n\t\t}\n\n\t\t/* Active socket signalled connection closed/error, this has\n\t\t * been signalled to the application along with any remaining\n\t\t * buffer. So, let's just reset SSL socket now.\n\t\t */\n\t\tif (status != PJ_SUCCESS) {\n\t\t    ssl_reset_sock_state(ssock);\n\t\t    return PJ_FALSE;\n\t\t}\n\n\t    } else if (status_ == PJ_SUCCESS) {\n\t    \tbreak;\n\t    } else if (status_ == PJ_EEOF) {\n\t\tstatus = ssl_do_handshake(ssock);\n\t\tif (status == PJ_SUCCESS) {\n\t\t    /* Renegotiation completed */\n\n\t\t    /* Update certificates */\n\t\t    ssl_update_certs_info(ssock);\n\n\t\t    // Ticket #1573: Don't hold mutex while calling\n\t\t    //               PJLIB socket send(). \n\t\t    //pj_lock_acquire(ssock->write_mutex);\n\t\t    status = flush_delayed_send(ssock);\n\t\t    //pj_lock_release(ssock->write_mutex);\n\n\t\t    /* If flushing is ongoing, treat it as success */\n\t\t    if (status == PJ_EBUSY)\n\t\t\tstatus = PJ_SUCCESS;\n\n\t\t    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\t\t\tPJ_PERROR(1,(ssock->pool->obj_name, status, \n\t\t\t\t     \"Failed to flush delayed send\"));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t} else if (status != PJ_EPENDING) {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, status, \n\t\t\t         \"Renegotiation failed\"));\n\t\t    goto on_error;\n\t\t}\n\n\t\tbreak;\n\t    } else {\n\t    \t/* Error */\n\t    \tstatus = status_;\n\t    \tgoto on_error;\n\t    }\n\n\t} while (1);\n    }\n\n    return PJ_TRUE;\n\non_error:\n    if (ssock->ssl_state == SSL_STATE_HANDSHAKING)\n\treturn on_handshake_complete(ssock, status);\n\n    if (ssock->read_started && ssock->param.cb.on_data_read) {\n\tpj_bool_t ret;\n\tret = (*ssock->param.cb.on_data_read)(ssock, NULL, 0, status,\n\t\t\t\t\t      remainder);\n\tif (!ret) {\n\t    /* We've been destroyed */\n\t    return PJ_FALSE;\n\t}\n    }\n\n    ssl_reset_sock_state(ssock);\n    return PJ_FALSE;\n}\n\nstatic pj_bool_t ssock_on_data_sent (pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t\t     pj_ssize_t sent)\n{\n    write_data_t *wdata = (write_data_t*)send_key->user_data;\n    pj_ioqueue_op_key_t *app_key = wdata->app_key;\n    pj_ssize_t sent_len;\n\n    sent_len = (sent > 0)? wdata->plain_data_len : sent;\n    \n    /* Update write buffer state */\n    pj_lock_acquire(ssock->write_mutex);\n    free_send_data(ssock, wdata);\n    pj_lock_release(ssock->write_mutex);\n    wdata = NULL;\n\n    if (ssock->ssl_state == SSL_STATE_HANDSHAKING) {\n\t/* Initial handshaking */\n\tpj_status_t status;\n\t\n\tstatus = ssl_do_handshake(ssock);\n\t/* Not pending is either success or failed */\n\tif (status != PJ_EPENDING)\n\t    return on_handshake_complete(ssock, status);\n\n    } else if (send_key != &ssock->handshake_op_key) {\n\t/* Some data has been sent, notify application */\n\tif (ssock->param.cb.on_data_sent) {\n\t    pj_bool_t ret;\n\t    ret = (*ssock->param.cb.on_data_sent)(ssock, app_key, \n\t\t\t\t\t\t  sent_len);\n\t    if (!ret) {\n\t\t/* We've been destroyed */\n\t\treturn PJ_FALSE;\n\t    }\n\t}\n    } else {\n\t/* SSL re-negotiation is on-progress, just do nothing */\n    }\n\n    /* Send buffer has been updated, let's try to send any pending data */\n    if (ssock->send_buf_pending.data_len) {\n\tpj_status_t status;\n\tstatus = flush_circ_buf_output(ssock, ssock->send_buf_pending.app_key,\n\t\t\t\t ssock->send_buf_pending.plain_data_len,\n\t\t\t\t ssock->send_buf_pending.flags);\n\tif (status == PJ_SUCCESS || status == PJ_EPENDING) {\n\t    ssock->send_buf_pending.data_len = 0;\n\t}\n    }\n\n    return PJ_TRUE;\n}\n\nstatic pj_status_t get_localaddr(pj_ssl_sock_t *ssock,\n\t\t\t\t pj_sockaddr_t *addr,\n\t\t\t\t int *namelen)\n{\n    PJ_UNUSED_ARG(addr);\n    PJ_UNUSED_ARG(namelen);\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    return network_get_localaddr(ssock, &ssock->local_addr, \n\t\t\t\t &ssock->addr_len);\n#else\n    return pj_sock_getsockname(ssock->sock, &ssock->local_addr, \n\t\t\t       &ssock->addr_len);\n#endif\n}\n\n\nstatic pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n\t\t\t\t\t   pj_sock_t newsock,\n\t\t\t\t\t   void *newconn,\n\t\t\t\t\t   const pj_sockaddr_t *src_addr,\n\t\t\t\t\t   int src_addr_len,\n\t\t\t\t\t   pj_status_t accept_status)\n{\n    pj_ssl_sock_t *ssock;\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    pj_activesock_cb asock_cb;\n#endif\n    pj_activesock_cfg asock_cfg;\n    unsigned i;\n    pj_status_t status;\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    PJ_UNUSED_ARG(newconn);\n#endif\n\n    if (accept_status != PJ_SUCCESS) {\n\tif (ssock_parent->param.cb.on_accept_complete2) {\n\t    (*ssock_parent->param.cb.on_accept_complete2)(ssock_parent, NULL,\n\t\t\t\t\t\t    \t  src_addr,\n\t\t\t\t\t\t    \t  src_addr_len,\n\t\t\t\t\t\t    \t  accept_status);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Create new SSL socket instance */\n    status = pj_ssl_sock_create(ssock_parent->pool,\n\t\t\t\t&ssock_parent->newsock_param, &ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Set parent and add ref count (avoid parent destroy during handshake) */\n    ssock->parent = ssock_parent;\n    if (ssock->parent->param.grp_lock)\n\tpj_grp_lock_add_ref(ssock->parent->param.grp_lock);\n\n    /* Update new SSL socket attributes */\n    ssock->sock = newsock;\n    ssock->is_server = PJ_TRUE;\n    if (ssock_parent->cert) {\n\tstatus = pj_ssl_sock_set_certificate(ssock, ssock->pool, \n\t\t\t\t\t     ssock_parent->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n    }\n\n    /* Set local address */\n    ssock->addr_len = src_addr_len;\n    pj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);\n\n    /* Set remote address */\n    pj_sockaddr_cp(&ssock->rem_addr, src_addr);\n\n    /* Create SSL context */\n    status = ssl_create(ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare read buffer */\n    ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(void*));\n    if (!ssock->asock_rbuf) {\n\tstatus = PJ_ENOMEM;\n\tgoto on_return;\n    }\n\n    for (i = 0; i<ssock->param.async_cnt; ++i) {\n\tssock->asock_rbuf[i] = (void*) pj_pool_alloc(\n\t\t\t\t\t    ssock->pool, \n\t\t\t\t\t    ssock->param.read_buffer_size + \n\t\t\t\t\t    sizeof(read_data_t*));\n\tif (!ssock->asock_rbuf[i]) {\n\t    status = PJ_ENOMEM;\n\t    goto on_return;\n\t}\n    }\n\n    /* If listener socket has group lock, automatically create group lock\n     * for the new socket.\n     */\n    if (ssock_parent->param.grp_lock) {\n\tpj_grp_lock_t *glock;\n\n\tstatus = pj_grp_lock_create(ssock->pool, NULL, &glock);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n\n\tpj_grp_lock_add_ref(glock);\n\tssock->param.grp_lock = glock;\n\tpj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,\n\t\t\t\tssl_on_destroy);\n    }\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_setup_connection(ssock, newconn);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n#else\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 1, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_return;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_return;\n    }\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.grp_lock = ssock->param.grp_lock;\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_TRUE;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    asock_cb.on_data_read = asock_on_data_read;\n    asock_cb.on_data_sent = asock_on_data_sent;\n\n    status = pj_activesock_create(ssock->pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Start read */\n    status = pj_activesock_start_read2(ssock->asock, ssock->pool, \n\t\t\t\t       (unsigned)ssock->param.read_buffer_size,\n\t\t\t\t       ssock->asock_rbuf,\n\t\t\t\t       PJ_IOQUEUE_ALWAYS_ASYNC);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n#endif\n\n    /* Update local address */\n    status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);\n    if (status != PJ_SUCCESS) {\n\t/* This fails on few envs, e.g: win IOCP, just tolerate this and\n\t * use parent local address instead.\n\t */\n\tpj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);\n    }\n\n    /* Prepare write/send state */\n    pj_assert(ssock->send_buf.max_len == 0);\n    ssock->send_buf.buf = (char*)\n\t\t\t  pj_pool_alloc(ssock->pool, \n\t\t\t\t\tssock->param.send_buffer_size);\n    if (!ssock->send_buf.buf)\n        return PJ_ENOMEM;\n\n    ssock->send_buf.max_len = ssock->param.send_buffer_size;\n    ssock->send_buf.start = ssock->send_buf.buf;\n    ssock->send_buf.len = 0;\n\n    /* Start handshake timer */\n    if (ssock->param.timer_heap && (ssock->param.timeout.sec != 0 ||\n\tssock->param.timeout.msec != 0))\n    {\n\tpj_assert(ssock->timer.id == TIMER_NONE);\n\tstatus = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap, \n\t\t\t\t\t\t   &ssock->timer,\n\t\t\t\t\t\t   &ssock->param.timeout,\n\t\t\t\t\t\t   TIMER_HANDSHAKE_TIMEOUT,\n\t\t\t\t\t\t   ssock->param.grp_lock);\n\tif (status != PJ_SUCCESS) {\n\t    ssock->timer.id = TIMER_NONE;\n\t    status = PJ_SUCCESS;\n\t}\n    }\n\n    /* Start SSL handshake */\n    ssock->ssl_state = SSL_STATE_HANDSHAKING;\n    ssl_set_state(ssock, PJ_TRUE);\n    status = ssl_do_handshake(ssock);\n\non_return:\n    if (ssock && status != PJ_EPENDING) {\n\ton_handshake_complete(ssock, status);\n    }\n\n    /* Must return PJ_TRUE whatever happened, as we must continue listening */\n    return PJ_TRUE;\n}\n\nstatic pj_bool_t ssock_on_connect_complete (pj_ssl_sock_t *ssock,\n\t\t\t\t\t    pj_status_t status)\n{\n    unsigned i;\n\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Update local address */\n    ssock->addr_len = sizeof(pj_sockaddr);\n    status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Create SSL context */\n    status = ssl_create(ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare read buffer */\n    ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(void*));\n    if (!ssock->asock_rbuf)\n        return PJ_ENOMEM;\n\n    for (i = 0; i<ssock->param.async_cnt; ++i) {\n\tssock->asock_rbuf[i] = (void*) pj_pool_alloc(\n\t\t\t\t\t    ssock->pool, \n\t\t\t\t\t    ssock->param.read_buffer_size + \n\t\t\t\t\t    sizeof(read_data_t*));\n        if (!ssock->asock_rbuf[i])\n            return PJ_ENOMEM;\n    }\n\n    /* Start read */\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_start_read(ssock, ssock->param.async_cnt,\n    \t\t\t\t(unsigned)ssock->param.read_buffer_size,\n\t\t\t\tssock->asock_rbuf, 0);\n#else\n    status = pj_activesock_start_read2(ssock->asock, ssock->pool, \n\t\t\t\t       (unsigned)ssock->param.read_buffer_size,\n\t\t\t\t       ssock->asock_rbuf,\n\t\t\t\t       PJ_IOQUEUE_ALWAYS_ASYNC);\n#endif\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare write/send state */\n    pj_assert(ssock->send_buf.max_len == 0);\n    ssock->send_buf.buf = (char*)\n\t\t\t     pj_pool_alloc(ssock->pool, \n\t\t\t\t\t   ssock->param.send_buffer_size);\n    if (!ssock->send_buf.buf)\n        return PJ_ENOMEM;\n\n    ssock->send_buf.max_len = ssock->param.send_buffer_size;\n    ssock->send_buf.start = ssock->send_buf.buf;\n    ssock->send_buf.len = 0;\n\n    /* Set peer name */\n    ssl_set_peer_name(ssock);\n\n    /* Start SSL handshake */\n    ssock->ssl_state = SSL_STATE_HANDSHAKING;\n    ssl_set_state(ssock, PJ_FALSE);\n\n    status = ssl_do_handshake(ssock);\n    if (status != PJ_EPENDING)\n\tgoto on_return;\n\n    return PJ_TRUE;\n\non_return:\n    return on_handshake_complete(ssock, status);\n}\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\nstatic pj_bool_t asock_on_data_read (pj_activesock_t *asock,\n\t\t\t\t     void *data,\n\t\t\t\t     pj_size_t size,\n\t\t\t\t     pj_status_t status,\n\t\t\t\t     pj_size_t *remainder)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_data_read(ssock, data, size, status, remainder);\n}\n\nstatic pj_bool_t asock_on_data_sent (pj_activesock_t *asock,\n\t\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t\t     pj_ssize_t sent)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_data_sent(ssock, send_key, sent);\n}\n\nstatic pj_bool_t asock_on_accept_complete2(pj_activesock_t *asock,\n\t\t\t\t\t   pj_sock_t newsock,\n\t\t\t\t\t   const pj_sockaddr_t *src_addr,\n\t\t\t\t\t   int src_addr_len,\n\t\t\t\t\t   pj_status_t status)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_accept_complete(ssock, newsock, NULL,\n    \t\t\t\t    src_addr, src_addr_len, status);\n}\n\nstatic pj_bool_t asock_on_connect_complete (pj_activesock_t *asock,\n\t\t\t\t\t    pj_status_t status)\n{\n    pj_ssl_sock_t *ssock = (pj_ssl_sock_t*)\n\t\t\t   pj_activesock_get_user_data(asock);\n\n    return ssock_on_connect_complete(ssock, status);\n}\n#endif\n\n/*\n *******************************************************************\n * API\n *******************************************************************\n */\n\n/* Get available ciphers. */\nPJ_DEF(pj_status_t) pj_ssl_cipher_get_availables(pj_ssl_cipher ciphers[],\n\t\t\t\t\t         unsigned *cipher_num)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(ciphers && cipher_num, PJ_EINVAL);\n\n    ssl_ciphers_populate();\n\n    if (ssl_cipher_num == 0) {\n\t*cipher_num = 0;\n\treturn PJ_ENOTFOUND;\n    }\n\n    *cipher_num = PJ_MIN(*cipher_num, ssl_cipher_num);\n\n    for (i = 0; i < *cipher_num; ++i)\n\tciphers[i] = ssl_ciphers[i].id;\n\n    return PJ_SUCCESS;\n}\n\n/* Get cipher name string */\nPJ_DEF(const char*) pj_ssl_cipher_name(pj_ssl_cipher cipher)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_cipher_num; ++i) {\n\tif (cipher == ssl_ciphers[i].id)\n\t    return ssl_ciphers[i].name;\n    }\n\n    return NULL;\n}\n\n/* Get cipher identifier */\nPJ_DEF(pj_ssl_cipher) pj_ssl_cipher_id(const char *cipher_name)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_cipher_num; ++i) {\n        if (!pj_ansi_stricmp(ssl_ciphers[i].name, cipher_name))\n            return ssl_ciphers[i].id;\n    }\n\n    return PJ_TLS_UNKNOWN_CIPHER;\n}\n\n/* Check if the specified cipher is supported by SSL/TLS backend. */\nPJ_DEF(pj_bool_t) pj_ssl_cipher_is_supported(pj_ssl_cipher cipher)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_cipher_num; ++i) {\n\tif (cipher == ssl_ciphers[i].id)\n\t    return PJ_TRUE;\n    }\n\n    return PJ_FALSE;\n}\n\n/* Get available curves. */\nPJ_DEF(pj_status_t) pj_ssl_curve_get_availables(pj_ssl_curve curves[],\n\t\t\t\t\t\tunsigned *curve_num)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(curves && curve_num, PJ_EINVAL);\n\n    ssl_ciphers_populate();\n\n    if (ssl_curves_num == 0) {\n\t*curve_num = 0;\n\treturn PJ_ENOTFOUND;\n    }\n\n    *curve_num = PJ_MIN(*curve_num, ssl_curves_num);\n\n    for (i = 0; i < *curve_num; ++i)\n\tcurves[i] = ssl_curves[i].id;\n\n    return PJ_SUCCESS;\n}\n\n/* Get curve name string. */\nPJ_DEF(const char*) pj_ssl_curve_name(pj_ssl_curve curve)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_curves_num; ++i) {\n\tif (curve == ssl_curves[i].id)\n\t    return ssl_curves[i].name;\n    }\n\n    return NULL;\n}\n\n/* Get curve ID from curve name string. */\nPJ_DEF(pj_ssl_curve) pj_ssl_curve_id(const char *curve_name)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_curves_num; ++i) {\n        if (ssl_curves[i].name &&\n        \t!pj_ansi_stricmp(ssl_curves[i].name, curve_name))\n        {\n            return ssl_curves[i].id;\n        }\n    }\n\n    return PJ_TLS_UNKNOWN_CURVE;\n}\n\n/* Check if the specified curve is supported by SSL/TLS backend. */\nPJ_DEF(pj_bool_t) pj_ssl_curve_is_supported(pj_ssl_curve curve)\n{\n    unsigned i;\n\n    ssl_ciphers_populate();\n\n    for (i = 0; i < ssl_curves_num; ++i) {\n\tif (curve == ssl_curves[i].id)\n\t    return PJ_TRUE;\n    }\n\n    return PJ_FALSE;\n}\n\n/*\n * Create SSL socket instance. \n */\nPJ_DEF(pj_status_t) pj_ssl_sock_create (pj_pool_t *pool,\n\t\t\t\t\tconst pj_ssl_sock_param *param,\n\t\t\t\t\tpj_ssl_sock_t **p_ssock)\n{\n    pj_ssl_sock_t *ssock;\n    pj_status_t status;\n    pj_pool_t *info_pool;\n\n    PJ_ASSERT_RETURN(pool && param && p_ssock, PJ_EINVAL);\n    PJ_ASSERT_RETURN(param->sock_type == pj_SOCK_STREAM(), PJ_ENOTSUP);\n\n    info_pool = pj_pool_create(pool->factory, \"ssl_chain%p\", 512, 512, NULL);\n    pool = pj_pool_create(pool->factory, \"ssl%p\", 512, 512, NULL);\n\n    /* Create secure socket */\n    ssock = ssl_alloc(pool);\n    if (!ssock)\n    \treturn PJ_ENOMEM;\n    ssock->pool = pool;\n    ssock->info_pool = info_pool;\n    ssock->sock = PJ_INVALID_SOCKET;\n    ssock->ssl_state = SSL_STATE_NULL;\n    ssock->circ_buf_input.owner = ssock;\n    ssock->circ_buf_output.owner = ssock;\n    pj_list_init(&ssock->write_pending);\n    pj_list_init(&ssock->write_pending_empty);\n    pj_list_init(&ssock->send_pending);\n    pj_timer_entry_init(&ssock->timer, 0, ssock, &on_timer);\n    pj_ioqueue_op_key_init(&ssock->handshake_op_key,\n\t\t\t   sizeof(pj_ioqueue_op_key_t));\n    pj_ioqueue_op_key_init(&ssock->shutdown_op_key,\n\t\t\t   sizeof(pj_ioqueue_op_key_t));\n\n    /* Create secure socket mutex */\n    status = pj_lock_create_recursive_mutex(pool, pool->obj_name,\n                                            &ssock->circ_buf_output_mutex);\n    ssock->write_mutex = ssock->circ_buf_output_mutex;\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Create input circular buffer mutex */\n    status = pj_lock_create_simple_mutex(pool, pool->obj_name,\n                                         &ssock->circ_buf_input_mutex);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Init secure socket param */\n    pj_ssl_sock_param_copy(pool, &ssock->param, param);\n\n    if (ssock->param.grp_lock) {\n\tpj_grp_lock_add_ref(ssock->param.grp_lock);\n\tpj_grp_lock_add_handler(ssock->param.grp_lock, pool, ssock,\n\t\t\t\tssl_on_destroy);\n    }\n\n    ssock->param.read_buffer_size = ((ssock->param.read_buffer_size+7)>>3)<<3;\n    if (!ssock->param.timer_heap) {\n\tPJ_LOG(3,(ssock->pool->obj_name, \"Warning: timer heap is not \"\n\t\t  \"available. It is recommended to supply one to avoid \"\n\t          \"a race condition if more than one worker threads \"\n\t          \"are used.\"));\n    }\n\n    /* Finally */\n    *p_ssock = ssock;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Close the secure socket. This will unregister the socket from the\n * ioqueue and ultimately close the socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_close(pj_ssl_sock_t *ssock)\n{\n    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);\n\n    if (!ssock->pool)\n\treturn PJ_SUCCESS;\n\n    if (ssock->timer.id != TIMER_NONE) {\n\tpj_timer_heap_cancel(ssock->param.timer_heap, &ssock->timer);\n\tssock->timer.id = TIMER_NONE;\n    }\n\n    ssl_reset_sock_state(ssock);\n\n    /* Wipe out cert & key buffer. */\n    if (ssock->cert) {\n\tpj_ssl_cert_wipe_keys(ssock->cert);\n\tssock->cert = NULL;\n    }\n\n    if (ssock->param.grp_lock) {\n\tpj_grp_lock_dec_ref(ssock->param.grp_lock);\n    } else {\n\tssl_on_destroy(ssock);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Associate arbitrary data with the secure socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_set_user_data(pj_ssl_sock_t *ssock,\n\t\t\t\t\t      void *user_data)\n{\n    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);\n\n    ssock->param.user_data = user_data;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Retrieve the user data previously associated with this secure\n * socket.\n */\nPJ_DEF(void*) pj_ssl_sock_get_user_data(pj_ssl_sock_t *ssock)\n{\n    PJ_ASSERT_RETURN(ssock, NULL);\n\n    return ssock->param.user_data;\n}\n\n/*\n * Retrieve the local address and port used by specified SSL socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_get_info (pj_ssl_sock_t *ssock,\n\t\t\t\t\t  pj_ssl_sock_info *info)\n{\n    pj_bzero(info, sizeof(*info));\n\n    /* Established flag */\n    info->established = (ssock->ssl_state == SSL_STATE_ESTABLISHED);\n\n    /* Protocol */\n    info->proto = ssock->param.proto;\n\n    /* Local address */\n    pj_sockaddr_cp(&info->local_addr, &ssock->local_addr);\n    \n    if (info->established) {\n\tinfo->cipher = ssl_get_cipher(ssock);\n\n\t/* Remote address */\n\tpj_sockaddr_cp(&info->remote_addr, &ssock->rem_addr);\n\n\t/* Certificates info */\n\tinfo->local_cert_info = &ssock->local_cert_info;\n\tinfo->remote_cert_info = &ssock->remote_cert_info;\n\n\t/* Verification status */\n\tinfo->verify_status = ssock->verify_status;\n    }\n\n    /* Last known SSL error code */\n    info->last_native_err = ssock->last_err;\n\n    /* Group lock */\n    info->grp_lock = ssock->param.grp_lock;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Starts read operation on this secure socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_read (pj_ssl_sock_t *ssock,\n\t\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t\t    unsigned buff_size,\n\t\t\t\t\t    pj_uint32_t flags)\n{\n    void **readbuf;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(ssock && pool && buff_size, PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    readbuf = (void**) pj_pool_calloc(pool, ssock->param.async_cnt, \n\t\t\t\t      sizeof(void*));\n    if (!readbuf)\n        return PJ_ENOMEM;\n\n    for (i=0; i<ssock->param.async_cnt; ++i) {\n\treadbuf[i] = pj_pool_alloc(pool, buff_size);\n        if (!readbuf[i])\n            return PJ_ENOMEM;\n    }\n\n    return pj_ssl_sock_start_read2(ssock, pool, buff_size, \n\t\t\t\t   readbuf, flags);\n}\n\n\n/*\n * Same as #pj_ssl_sock_start_read(), except that the application\n * supplies the buffers for the read operation so that the acive socket\n * does not have to allocate the buffers.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_read2 (pj_ssl_sock_t *ssock,\n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     unsigned buff_size,\n\t\t\t\t\t     void *readbuf[],\n\t\t\t\t\t     pj_uint32_t flags)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(ssock && pool && buff_size && readbuf, PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    /* Create SSL socket read buffer */\n    ssock->ssock_rbuf = (read_data_t*)pj_pool_calloc(pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(read_data_t));\n    if (!ssock->ssock_rbuf)\n        return PJ_ENOMEM;\n\n    /* Store SSL socket read buffer pointer in the activesock read buffer */\n    for (i=0; i<ssock->param.async_cnt; ++i) {\n\tread_data_t **p_ssock_rbuf = \n\t\t\tOFFSET_OF_READ_DATA_PTR(ssock, ssock->asock_rbuf[i]);\n\n\tssock->ssock_rbuf[i].data = readbuf[i];\n\tssock->ssock_rbuf[i].len = 0;\n\n\t*p_ssock_rbuf = &ssock->ssock_rbuf[i];\n    }\n\n    ssock->read_size = buff_size;\n    ssock->read_started = PJ_TRUE;\n    ssock->read_flags = flags;\n\n    for (i=0; i<ssock->param.async_cnt; ++i) {\n\tif (ssock->asock_rbuf[i]) {\n\t    pj_size_t remainder = 0;\n\t    ssock_on_data_read(ssock, ssock->asock_rbuf[i], 0,\n\t\t\t       PJ_SUCCESS, &remainder);\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Same as pj_ssl_sock_start_read(), except that this function is used\n * only for datagram sockets, and it will trigger \\a on_data_recvfrom()\n * callback instead.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_recvfrom (pj_ssl_sock_t *ssock,\n\t\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\t\tunsigned buff_size,\n\t\t\t\t\t\tpj_uint32_t flags)\n{\n    PJ_UNUSED_ARG(ssock);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(buff_size);\n    PJ_UNUSED_ARG(flags);\n\n    return PJ_ENOTSUP;\n}\n\n\n/*\n * Same as #pj_ssl_sock_start_recvfrom() except that the recvfrom() \n * operation takes the buffer from the argument rather than creating\n * new ones.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_recvfrom2 (pj_ssl_sock_t *ssock,\n\t\t\t\t\t\t pj_pool_t *pool,\n\t\t\t\t\t\t unsigned buff_size,\n\t\t\t\t\t\t void *readbuf[],\n\t\t\t\t\t\t pj_uint32_t flags)\n{\n    PJ_UNUSED_ARG(ssock);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(buff_size);\n    PJ_UNUSED_ARG(readbuf);\n    PJ_UNUSED_ARG(flags);\n\n    return PJ_ENOTSUP;\n}\n\n\n/* Write plain data to SSL and flush the buffer. */\nstatic pj_status_t ssl_send (pj_ssl_sock_t *ssock, \n\t\t\t     pj_ioqueue_op_key_t *send_key,\n\t\t\t     const void *data,\n\t\t\t     pj_ssize_t size,\n\t\t\t     unsigned flags)\n{\n    pj_status_t status;\n    int nwritten;\n\n    /* Write the plain data to SSL, after SSL encrypts it, the buffer will\n     * contain the secured data to be sent via socket. Note that re-\n     * negotitation may be on progress, so sending data should be delayed\n     * until re-negotiation is completed.\n     */\n    pj_lock_acquire(ssock->write_mutex);\n    /* Don't write to SSL if send buffer is full and some data is in\n     * write buffer already, just return PJ_ENOMEM.\n     */\n    if (ssock->send_buf_pending.data_len) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_ENOMEM;\n    }\n    status = ssl_write(ssock, data, size, &nwritten);\n    pj_lock_release(ssock->write_mutex);\n    \n    if (status == PJ_SUCCESS && nwritten == size) {\n\t/* All data written, flush write buffer to network socket */\n\tstatus = flush_circ_buf_output(ssock, send_key, size, flags);\n    } else if (status == PJ_EEOF) {\n        /* Re-negotiation is on progress, flush re-negotiation data */\n\tstatus = flush_circ_buf_output(ssock, &ssock->handshake_op_key, 0, 0);\n\tif (status == PJ_SUCCESS || status == PJ_EPENDING) {\n\t    /* Just return PJ_EBUSY when re-negotiation is on progress */\n\t    status = PJ_EBUSY;\n\t}\n    }\n\n    return status;\n}\n\n/* Flush delayed data sending in the write pending list. */\nstatic pj_status_t flush_delayed_send(pj_ssl_sock_t *ssock)\n{\n    /* Check for another ongoing flush */\n    if (ssock->flushing_write_pend)\n\treturn PJ_EBUSY;\n\n    pj_lock_acquire(ssock->write_mutex);\n\n    /* Again, check for another ongoing flush */\n    if (ssock->flushing_write_pend) {\n\tpj_lock_release(ssock->write_mutex);\n\treturn PJ_EBUSY;\n    }\n\n    /* Set ongoing flush flag */\n    ssock->flushing_write_pend = PJ_TRUE;\n\n    while (!pj_list_empty(&ssock->write_pending)) {\n        write_data_t *wp;\n\tpj_status_t status;\n\n\twp = ssock->write_pending.next;\n\n\t/* Ticket #1573: Don't hold mutex while calling socket send. */\n\tpj_lock_release(ssock->write_mutex);\n\n\tstatus = ssl_send (ssock, &wp->key, wp->data.ptr, \n\t\t\t   wp->plain_data_len, wp->flags);\n\tif (status != PJ_SUCCESS) {\n\t    /* Reset ongoing flush flag first. */\n\t    ssock->flushing_write_pend = PJ_FALSE;\n\t    return status;\n\t}\n\n\tpj_lock_acquire(ssock->write_mutex);\n\tpj_list_erase(wp);\n\tpj_list_push_back(&ssock->write_pending_empty, wp);\n    }\n\n    /* Reset ongoing flush flag */\n    ssock->flushing_write_pend = PJ_FALSE;\n\n    pj_lock_release(ssock->write_mutex);\n\n    return PJ_SUCCESS;\n}\n\n/* Sending is delayed, push back the sending data into pending list. */\nstatic pj_status_t delay_send (pj_ssl_sock_t *ssock,\n\t\t\t       pj_ioqueue_op_key_t *send_key,\n\t\t\t       const void *data,\n\t\t\t       pj_ssize_t size,\n\t\t\t       unsigned flags)\n{\n    write_data_t *wp;\n\n    pj_lock_acquire(ssock->write_mutex);\n\n    /* Init write pending instance */\n    if (!pj_list_empty(&ssock->write_pending_empty)) {\n\twp = ssock->write_pending_empty.next;\n\tpj_list_erase(wp);\n    } else {\n\twp = PJ_POOL_ZALLOC_T(ssock->pool, write_data_t);\n    }\n\n    wp->app_key = send_key;\n    wp->plain_data_len = size;\n    wp->data.ptr = data;\n    wp->flags = flags;\n\n    pj_list_push_back(&ssock->write_pending, wp);\n    \n    pj_lock_release(ssock->write_mutex);\n\n    /* Must return PJ_EPENDING */\n    return PJ_EPENDING;\n}\n\n\n/**\n * Send data using the socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_send (pj_ssl_sock_t *ssock,\n\t\t\t\t      pj_ioqueue_op_key_t *send_key,\n\t\t\t\t      const void *data,\n\t\t\t\t      pj_ssize_t *size,\n\t\t\t\t      unsigned flags)\n{\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(ssock && data && size && (*size>0), PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    // Ticket #1573: Don't hold mutex while calling PJLIB socket send().\n    //pj_lock_acquire(ssock->write_mutex);\n\n    /* Flush delayed send first. Sending data might be delayed when \n     * re-negotiation is on-progress.\n     */\n    status = flush_delayed_send(ssock);\n    if (status == PJ_EBUSY) {\n\t/* Re-negotiation or flushing is on progress, delay sending */\n\tstatus = delay_send(ssock, send_key, data, *size, flags);\n\tgoto on_return;\n    } else if (status != PJ_SUCCESS) {\n\tgoto on_return;\n    }\n\n    /* Write data to SSL */\n    status = ssl_send(ssock, send_key, data, *size, flags);\n    if (status == PJ_EBUSY) {\n\t/* Re-negotiation is on progress, delay sending */\n\tstatus = delay_send(ssock, send_key, data, *size, flags);\n    }\n\non_return:\n    //pj_lock_release(ssock->write_mutex);\n    return status;\n}\n\n\n/**\n * Send datagram using the socket.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_sendto (pj_ssl_sock_t *ssock,\n\t\t\t\t\tpj_ioqueue_op_key_t *send_key,\n\t\t\t\t\tconst void *data,\n\t\t\t\t\tpj_ssize_t *size,\n\t\t\t\t\tunsigned flags,\n\t\t\t\t\tconst pj_sockaddr_t *addr,\n\t\t\t\t\tint addr_len)\n{\n    PJ_UNUSED_ARG(ssock);\n    PJ_UNUSED_ARG(send_key);\n    PJ_UNUSED_ARG(data);\n    PJ_UNUSED_ARG(size);\n    PJ_UNUSED_ARG(flags);\n    PJ_UNUSED_ARG(addr);\n    PJ_UNUSED_ARG(addr_len);\n\n    return PJ_ENOTSUP;\n}\n\n\n/**\n * Starts asynchronous socket accept() operations on this secure socket. \n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_accept (pj_ssl_sock_t *ssock,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      const pj_sockaddr_t *localaddr,\n\t\t\t\t\t      int addr_len)\n{\n    return pj_ssl_sock_start_accept2(ssock, pool, localaddr, addr_len,\n    \t\t\t\t     &ssock->param);\n}\n\n\n/**\n * Same as #pj_ssl_sock_start_accept(), but application provides parameter\n * for new accepted secure sockets.\n */\nPJ_DEF(pj_status_t)\npj_ssl_sock_start_accept2(pj_ssl_sock_t *ssock,\n\t\t\t  pj_pool_t *pool,\n\t\t\t  const pj_sockaddr_t *localaddr,\n\t\t\t  int addr_len,\n\t\t\t  const pj_ssl_sock_param *newsock_param)\n{\n    pj_status_t status;\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    pj_activesock_cb asock_cb;\n    pj_activesock_cfg asock_cfg;\n#endif\n\n    PJ_ASSERT_RETURN(ssock && pool && localaddr && addr_len, PJ_EINVAL);\n\n    /* Verify new socket parameters */\n    if (newsock_param->grp_lock != ssock->param.grp_lock ||\n        newsock_param->sock_af != ssock->param.sock_af ||\n        newsock_param->sock_type != ssock->param.sock_type)\n    {\n        return PJ_EINVAL;\n    }\n\n    ssock->is_server = PJ_TRUE;\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_start_accept(ssock, pool, localaddr, addr_len,\n    \t\t\t\t  newsock_param);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#else\n    /* Create socket */\n    status = pj_sock_socket(ssock->param.sock_af, ssock->param.sock_type, 0, \n\t\t\t    &ssock->sock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Apply SO_REUSEADDR */\n    if (ssock->param.reuse_addr) {\n\tint enabled = 1;\n\tstatus = pj_sock_setsockopt(ssock->sock, pj_SOL_SOCKET(),\n\t\t\t\t    pj_SO_REUSEADDR(),\n\t\t\t\t    &enabled, sizeof(enabled));\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4,(ssock->pool->obj_name, status,\n\t\t         \"Warning: error applying SO_REUSEADDR\"));\n\t}\n    }\n\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 2, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_error;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_error;\n    }\n\n    /* Bind socket */\n    status = pj_sock_bind(ssock->sock, localaddr, addr_len);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Start listening to the address */\n    status = pj_sock_listen(ssock->sock, PJ_SOMAXCONN);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_FALSE;\n    asock_cfg.grp_lock = ssock->param.grp_lock;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    //asock_cb.on_accept_complete = asock_on_accept_complete;\n    asock_cb.on_accept_complete2 = asock_on_accept_complete2;\n\n    status = pj_activesock_create(pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Start accepting */\n    pj_ssl_sock_param_copy(pool, &ssock->newsock_param, newsock_param);\n    ssock->newsock_param.grp_lock = NULL;\n    status = pj_activesock_start_accept(ssock->asock, pool);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Update local address */\n    ssock->addr_len = addr_len;\n    status = pj_sock_getsockname(ssock->sock, &ssock->local_addr, \n\t\t\t\t &ssock->addr_len);\n    if (status != PJ_SUCCESS)\n\tpj_sockaddr_cp(&ssock->local_addr, localaddr);\n#endif\n\n    return PJ_SUCCESS;\n\non_error:\n    ssl_reset_sock_state(ssock);\n    return status;\n}\n\n\n/**\n * Starts asynchronous socket connect() operation.\n */\nPJ_DEF(pj_status_t) pj_ssl_sock_start_connect(pj_ssl_sock_t *ssock,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      const pj_sockaddr_t *localaddr,\n\t\t\t\t\t      const pj_sockaddr_t *remaddr,\n\t\t\t\t\t      int addr_len)\n{\n    pj_ssl_start_connect_param param;    \n    param.pool = pool;\n    param.localaddr = localaddr;\n    param.local_port_range = 0;\n    param.remaddr = remaddr;\n    param.addr_len = addr_len;\n\n    return pj_ssl_sock_start_connect2(ssock, &param);\n}\n\nPJ_DEF(pj_status_t) pj_ssl_sock_start_connect2(\n\t\t\t       pj_ssl_sock_t *ssock,\n\t\t\t       pj_ssl_start_connect_param *connect_param)\n{\n    pj_status_t status;\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_start_connect(ssock, connect_param);\n    if (status != PJ_EPENDING)\n\tgoto on_error;\n#else\n    pj_activesock_cb asock_cb;\n    pj_activesock_cfg asock_cfg;\n    \n    pj_pool_t *pool = connect_param->pool;\n    const pj_sockaddr_t *localaddr = connect_param->localaddr;\n    pj_uint16_t port_range = connect_param->local_port_range;\n    const pj_sockaddr_t *remaddr = connect_param->remaddr;\n    int addr_len = connect_param->addr_len;\n\n    PJ_ASSERT_RETURN(ssock && pool && localaddr && remaddr && addr_len,\n\t\t     PJ_EINVAL);\n\n    /* Create socket */\n    status = pj_sock_socket(ssock->param.sock_af, ssock->param.sock_type, 0, \n\t\t\t    &ssock->sock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 2, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_error;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_error;\n    }\n\n    /* Bind socket */\n    if (port_range) {\n\tpj_uint16_t max_bind_retry = MAX_BIND_RETRY;\n\tif (port_range && port_range < max_bind_retry)\n\t{\n\t    max_bind_retry = port_range;\n\t}\n\tstatus = pj_sock_bind_random(ssock->sock, localaddr, port_range,\n\t\t\t\t     max_bind_retry);\n    } else {\n\tstatus = pj_sock_bind(ssock->sock, localaddr, addr_len);\n    }\n\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_TRUE;\n    asock_cfg.grp_lock = ssock->param.grp_lock;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    asock_cb.on_connect_complete = asock_on_connect_complete;\n    asock_cb.on_data_read = asock_on_data_read;\n    asock_cb.on_data_sent = asock_on_data_sent;\n\n    status = pj_activesock_create(pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Save remote address */\n    pj_sockaddr_cp(&ssock->rem_addr, remaddr);\n\n    status = pj_activesock_start_connect(ssock->asock, pool, remaddr,\n\t\t\t\t\t addr_len);\n\n    if (status == PJ_SUCCESS)\n\tasock_on_connect_complete(ssock->asock, PJ_SUCCESS);\n    else if (status != PJ_EPENDING)\n\tgoto on_error;\n\n    /* Update local address */\n    ssock->addr_len = addr_len;\n    status = pj_sock_getsockname(ssock->sock, &ssock->local_addr,\n\t\t\t\t &ssock->addr_len);\n    /* Note that we may not get an IP address here. This can\n     * happen for example on Windows, where getsockname()\n     * would return 0.0.0.0 if socket has just started the\n     * async connect. In this case, just leave the local\n     * address with 0.0.0.0 for now; it will be updated\n     * once the socket is established.\n     */\n\n#endif\n\n    /* Start timer */\n    if (ssock->param.timer_heap &&\n        (ssock->param.timeout.sec != 0 || ssock->param.timeout.msec != 0))\n    {\n\tpj_assert(ssock->timer.id == TIMER_NONE);\n\tstatus = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap,\n\t\t\t\t\t\t   &ssock->timer,\n\t\t\t\t\t\t   &ssock->param.timeout,\n\t\t\t\t\t\t   TIMER_HANDSHAKE_TIMEOUT,\n\t\t\t\t\t\t   ssock->param.grp_lock);\n\tif (status != PJ_SUCCESS) {\n\t    ssock->timer.id = TIMER_NONE;\n\t    status = PJ_SUCCESS;\n\t}\n    }\n\n    /* Update SSL state */\n    ssock->is_server = PJ_FALSE;\n\n    return PJ_EPENDING;\n\non_error:\n    ssl_reset_sock_state(ssock);\n    return status;\n}\n\n\nPJ_DEF(pj_status_t) pj_ssl_sock_renegotiate(pj_ssl_sock_t *ssock)\n{\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);\n\n    if (ssock->ssl_state != SSL_STATE_ESTABLISHED) \n\treturn PJ_EINVALIDOP;\n\n    status = ssl_renegotiate(ssock);\n    if (status == PJ_SUCCESS) {\n\tstatus = ssl_do_handshake(ssock);\n    }\n\n    return status;\n}\n\nstatic void wipe_buf(pj_str_t *buf)\n{\n    volatile char *p = buf->ptr;\n    pj_ssize_t len = buf->slen;\n    while (len--) *p++ = 0;\n    buf->slen = 0;\n}\n\nPJ_DEF(void) pj_ssl_cert_wipe_keys(pj_ssl_cert_t *cert)\n{    \n    if (cert) {\n\twipe_buf(&cert->CA_file);\n\twipe_buf(&cert->CA_path);\n\twipe_buf(&cert->cert_file);\n\twipe_buf(&cert->privkey_file);\n\twipe_buf(&cert->privkey_pass);\n\twipe_buf(&cert->CA_buf);\n\twipe_buf(&cert->cert_buf);\n\twipe_buf(&cert->privkey_buf);\n    }\n}\n\n/* Load credentials from files. */\nPJ_DEF(pj_status_t) pj_ssl_cert_load_from_files (pj_pool_t *pool,\n\t\t\t\t\t\t const pj_str_t *CA_file,\n\t\t\t\t\t\t const pj_str_t *cert_file,\n\t\t\t\t\t\t const pj_str_t *privkey_file,\n\t\t\t\t\t\t const pj_str_t *privkey_pass,\n\t\t\t\t\t\t pj_ssl_cert_t **p_cert)\n{\n    return pj_ssl_cert_load_from_files2(pool, CA_file, NULL, cert_file,\n\t\t\t\t\tprivkey_file, privkey_pass, p_cert);\n}\n\nPJ_DEF(pj_status_t) pj_ssl_cert_load_from_files2(pj_pool_t *pool,\n\t\t\t\t\t\t const pj_str_t *CA_file,\n\t\t\t\t\t\t const pj_str_t *CA_path,\n\t\t\t\t\t\t const pj_str_t *cert_file,\n\t\t\t\t\t\t const pj_str_t *privkey_file,\n\t\t\t\t\t\t const pj_str_t *privkey_pass,\n\t\t\t\t\t\t pj_ssl_cert_t **p_cert)\n{\n    pj_ssl_cert_t *cert;\n\n    PJ_ASSERT_RETURN(pool && (CA_file || CA_path) && cert_file &&\n\t\t     privkey_file,\n\t\t     PJ_EINVAL);\n\n    cert = PJ_POOL_ZALLOC_T(pool, pj_ssl_cert_t);\n    if (CA_file) {\n    \tpj_strdup_with_null(pool, &cert->CA_file, CA_file);\n    }\n    if (CA_path) {\n    \tpj_strdup_with_null(pool, &cert->CA_path, CA_path);\n    }\n    pj_strdup_with_null(pool, &cert->cert_file, cert_file);\n    pj_strdup_with_null(pool, &cert->privkey_file, privkey_file);\n    pj_strdup_with_null(pool, &cert->privkey_pass, privkey_pass);\n\n    *p_cert = cert;\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_ssl_cert_load_from_buffer(pj_pool_t *pool,\n\t\t\t\t\tconst pj_ssl_cert_buffer *CA_buf,\n\t\t\t\t\tconst pj_ssl_cert_buffer *cert_buf,\n\t\t\t\t\tconst pj_ssl_cert_buffer *privkey_buf,\n\t\t\t\t\tconst pj_str_t *privkey_pass,\n\t\t\t\t\tpj_ssl_cert_t **p_cert)\n{\n    pj_ssl_cert_t *cert;\n\n    PJ_ASSERT_RETURN(pool && CA_buf && cert_buf && privkey_buf, PJ_EINVAL);\n\n    cert = PJ_POOL_ZALLOC_T(pool, pj_ssl_cert_t);\n    pj_strdup(pool, &cert->CA_buf, CA_buf);\n    pj_strdup(pool, &cert->cert_buf, cert_buf);\n    pj_strdup(pool, &cert->privkey_buf, privkey_buf);\n    pj_strdup_with_null(pool, &cert->privkey_pass, privkey_pass);\n\n    *p_cert = cert;\n\n    return PJ_SUCCESS;\n}\n\n/* Set SSL socket credentials. */\nPJ_DEF(pj_status_t) pj_ssl_sock_set_certificate(\n\t\t\t\t\t    pj_ssl_sock_t *ssock,\n\t\t\t\t\t    pj_pool_t *pool,\n\t\t\t\t\t    const pj_ssl_cert_t *cert)\n{\n    pj_ssl_cert_t *cert_;\n\n    PJ_ASSERT_RETURN(ssock && pool && cert, PJ_EINVAL);\n\n    cert_ = PJ_POOL_ZALLOC_T(pool, pj_ssl_cert_t);\n    pj_memcpy(cert_, cert, sizeof(pj_ssl_cert_t));\n    pj_strdup_with_null(pool, &cert_->CA_file, &cert->CA_file);\n    pj_strdup_with_null(pool, &cert_->CA_path, &cert->CA_path);\n    pj_strdup_with_null(pool, &cert_->cert_file, &cert->cert_file);\n    pj_strdup_with_null(pool, &cert_->privkey_file, &cert->privkey_file);\n    pj_strdup_with_null(pool, &cert_->privkey_pass, &cert->privkey_pass);\n\n    pj_strdup(pool, &cert_->CA_buf, &cert->CA_buf);\n    pj_strdup(pool, &cert_->cert_buf, &cert->cert_buf);\n    pj_strdup(pool, &cert_->privkey_buf, &cert->privkey_buf);\n\n    ssock->cert = cert_;\n\n    return PJ_SUCCESS;\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2009-2011 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pj/ssl_sock.h>\n#include <pj/activesock.h>\n#include <pj/compat/socket.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/file_access.h>\n#include <pj/list.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/timer.h>\n\n/* Only build when PJ_HAS_SSL_SOCK is enabled and when the backend is\n * OpenSSL.\n */\n#if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\\n    (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_OPENSSL)\n\n#include \"ssl_sock_imp_common.c\"\n\n#define THIS_FILE\t\t\"ssl_sock_ossl.c\"\n\n/* \n * Include OpenSSL headers \n */\n#include <openssl/asn1.h>\n#include <openssl/bio.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/x509v3.h>\n#if !defined(OPENSSL_NO_DH)\n#   include <openssl/dh.h>\n#endif\n\n#include <openssl/rand.h>\n#include <openssl/opensslconf.h>\n#include <openssl/opensslv.h>\n\n#if defined(LIBRESSL_VERSION_NUMBER)\n#\tdefine USING_LIBRESSL 1\n#else\n#\tdefine USING_LIBRESSL 0\n#endif\n\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n\t&& OPENSSL_VERSION_NUMBER >= 0x1000200fL\n\n#   include <openssl/obj_mac.h>\n\nstatic const unsigned nid_cid_map[] = {\n    NID_sect163k1,              /* sect163k1 (1) */\n    NID_sect163r1,              /* sect163r1 (2) */\n    NID_sect163r2,              /* sect163r2 (3) */\n    NID_sect193r1,              /* sect193r1 (4) */\n    NID_sect193r2,              /* sect193r2 (5) */\n    NID_sect233k1,              /* sect233k1 (6) */\n    NID_sect233r1,              /* sect233r1 (7) */\n    NID_sect239k1,              /* sect239k1 (8) */\n    NID_sect283k1,              /* sect283k1 (9) */\n    NID_sect283r1,              /* sect283r1 (10) */\n    NID_sect409k1,              /* sect409k1 (11) */\n    NID_sect409r1,              /* sect409r1 (12) */\n    NID_sect571k1,              /* sect571k1 (13) */\n    NID_sect571r1,              /* sect571r1 (14) */\n    NID_secp160k1,              /* secp160k1 (15) */\n    NID_secp160r1,              /* secp160r1 (16) */\n    NID_secp160r2,              /* secp160r2 (17) */\n    NID_secp192k1,              /* secp192k1 (18) */\n    NID_X9_62_prime192v1,       /* secp192r1 (19) */\n    NID_secp224k1,              /* secp224k1 (20) */\n    NID_secp224r1,              /* secp224r1 (21) */\n    NID_secp256k1,              /* secp256k1 (22) */\n    NID_X9_62_prime256v1,       /* secp256r1 (23) */\n    NID_secp384r1,              /* secp384r1 (24) */\n    NID_secp521r1,              /* secp521r1 (25) */\n    NID_brainpoolP256r1,        /* brainpoolP256r1 (26) */\n    NID_brainpoolP384r1,        /* brainpoolP384r1 (27) */\n    NID_brainpoolP512r1         /* brainpoolP512r1 (28) */\n};\n\nstatic unsigned get_cid_from_nid(unsigned nid)\n{\n    unsigned i, cid = 0;\n    for (i=0; i<PJ_ARRAY_SIZE(nid_cid_map); ++i) {\n\tif (nid == nid_cid_map[i]) {\n\t    cid = i+1;\n\t    break;\n\t}\n    }\n    return cid;\n}\n\nstatic unsigned get_nid_from_cid(unsigned cid)\n{\n    if ((cid == 0) || (cid > PJ_ARRAY_SIZE(nid_cid_map)))\n\treturn 0;\n\n    return nid_cid_map[cid-1];\n}\n\n#endif\n\n\n#if !USING_LIBRESSL && OPENSSL_VERSION_NUMBER >= 0x10100000L\n#  define OPENSSL_NO_SSL2\t    /* seems to be removed in 1.1.0 */\n#  define M_ASN1_STRING_data(x)\t    ASN1_STRING_get0_data(x)\n#  define M_ASN1_STRING_length(x)   ASN1_STRING_length(x)\n#  if defined(OPENSSL_API_COMPAT) && OPENSSL_API_COMPAT >= 0x10100000L\n#     define X509_get_notBefore(x)  X509_get0_notBefore(x)\n#     define X509_get_notAfter(x)   X509_get0_notAfter(x)\n#  endif\n#elif !USING_LIBRESSL\n#  define SSL_CIPHER_get_id(c)\t    (c)->id\n#  define SSL_set_session(ssl, s)   (ssl)->session = (s)\n#endif\n\n\n#ifdef _MSC_VER\n#  if OPENSSL_VERSION_NUMBER >= 0x10100000L\n#    pragma comment(lib, \"libcrypto\")\n#    pragma comment(lib, \"libssl\")\n#    pragma comment(lib, \"crypt32\")\n#  else\n#    pragma comment(lib, \"libeay32\")\n#    pragma comment(lib, \"ssleay32\")\n#  endif\n#endif\n\n\n#if defined(PJ_WIN32) && PJ_WIN32 != 0 || \\\n    defined(PJ_WIN64) && PJ_WIN64 != 0\n#  ifdef _MSC_VER\n#    define strerror_r(err,buf,len) strerror_s(buf,len,err)\n#  else\n#    define strerror_r(err,buf,len) pj_ansi_strncpy(buf,strerror(err),len)\n#  endif\n#endif\n\n\n/* Suppress compile warning of OpenSSL deprecation (OpenSSL is deprecated\n * since MacOSX 10.7).\n */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n\n/*\n * Secure socket structure definition.\n */\ntypedef struct ossl_sock_t\n{\n    pj_ssl_sock_t  \t  base;\n\n    SSL_CTX\t\t *ossl_ctx;\n    SSL\t\t\t *ossl_ssl;\n    BIO\t\t\t *ossl_rbio;\n    BIO\t\t\t *ossl_wbio;\n} ossl_sock_t;\n\n/**\n * Mapping from OpenSSL error codes to pjlib error space.\n */\n\n#define PJ_SSL_ERRNO_START\t\t(PJ_ERRNO_START_USER + \\\n\t\t\t\t\t PJ_ERRNO_SPACE_SIZE*6)\n\n#define PJ_SSL_ERRNO_SPACE_SIZE\t\tPJ_ERRNO_SPACE_SIZE\n\n/* Expected maximum value of reason component in OpenSSL error code */\n#define MAX_OSSL_ERR_REASON\t\t1200\n\n\nstatic char *SSLErrorString (int err)\n{\n    switch (err) {\n    case SSL_ERROR_NONE:\n\treturn \"SSL_ERROR_NONE\";\n    case SSL_ERROR_ZERO_RETURN:\n\treturn \"SSL_ERROR_ZERO_RETURN\";\n    case SSL_ERROR_WANT_READ:\n\treturn \"SSL_ERROR_WANT_READ\";\n    case SSL_ERROR_WANT_WRITE:\n\treturn \"SSL_ERROR_WANT_WRITE\";\n    case SSL_ERROR_WANT_CONNECT:\n\treturn \"SSL_ERROR_WANT_CONNECT\";\n    case SSL_ERROR_WANT_ACCEPT:\n\treturn \"SSL_ERROR_WANT_ACCEPT\";\n    case SSL_ERROR_WANT_X509_LOOKUP:\n\treturn \"SSL_ERROR_WANT_X509_LOOKUP\";\n    case SSL_ERROR_SYSCALL:\n\treturn \"SSL_ERROR_SYSCALL\";\n    case SSL_ERROR_SSL:\n\treturn \"SSL_ERROR_SSL\";\n    default:\n\treturn \"SSL_ERROR_UNKNOWN\";\n    }\n}\n\n#define ERROR_LOG(msg, err, ssock) \\\n{ \\\n    char buf[PJ_INET6_ADDRSTRLEN+10]; \\\n    PJ_LOG(2,(\"SSL\", \"%s (%s): Level: %d err: <%lu> <%s-%s-%s> len: %d \" \\\n\t   \"peer: %s\", \\\n\t   msg, action, level, err, \\\n\t   (ERR_lib_error_string(err)? ERR_lib_error_string(err): \"???\"), \\\n\t   (ERR_func_error_string(err)? ERR_func_error_string(err):\"???\"),\\\n\t   (ERR_reason_error_string(err)? \\\n\t    ERR_reason_error_string(err): \"???\"), len, \\\n\t   (ssock && pj_sockaddr_has_addr(&ssock->rem_addr)? \\\n\t    pj_sockaddr_print(&ssock->rem_addr, buf, sizeof(buf), 3):\"???\")));\\\n}\n\nstatic void SSLLogErrors(char * action, int ret, int ssl_err, int len, \n\t\t\t pj_ssl_sock_t *ssock)\n{\n    char *ssl_err_str = SSLErrorString(ssl_err);\n\n    if (!action) {\n\taction = \"UNKNOWN\";\n    }\n\n    switch (ssl_err) {\n    case SSL_ERROR_SYSCALL:\n    {\n\tunsigned long err2 = ERR_get_error();\n\tif (err2) {\n\t    int level = 0;\n\t    while (err2) {\n\t        ERROR_LOG(\"SSL_ERROR_SYSCALL\", err2, ssock);\n\t\tlevel++;\n\t\terr2 = ERR_get_error();\n\t    }\n\t} else if (ret == 0) {\n\t    /* An EOF was observed that violates the protocol */\n\n\t    /* The TLS/SSL handshake was not successful but was shut down\n\t     * controlled and by the specifications of the TLS/SSL protocol.\n\t     */\n\t} else if (ret == -1) {\n\t    /* BIO error - look for more info in errno... */\n\t    char errStr[250] = \"\";\n\t    strerror_r(errno, errStr, sizeof(errStr));\n\t    /* for now - continue logging these if they occur.... */\n\t    PJ_LOG(4,(\"SSL\", \"BIO error, SSL_ERROR_SYSCALL (%s): \"\n\t    \t\t     \"errno: <%d> <%s> len: %d\",\n\t\t      \t     action, errno, errStr, len));\n\t} else {\n\t    /* ret!=0 & ret!=-1 & nothing on error stack - is this valid??? */\n\t    PJ_LOG(2,(\"SSL\", \"SSL_ERROR_SYSCALL (%s) ret: %d len: %d\",\n\t\t      action, ret, len));\n\t}\n\tbreak;\n    }\n    case SSL_ERROR_SSL:\n    {\n\tunsigned long err2 = ERR_get_error();\n\tint level = 0;\n\n\twhile (err2) {\n\t    ERROR_LOG(\"SSL_ERROR_SSL\", err2, ssock);\n\t    level++;\n\t    err2 = ERR_get_error();\n\t}\n\tbreak;\n    }\n    default:\n\tPJ_LOG(2,(\"SSL\", \"%lu [%s] (%s) ret: %d len: %d\",\n\t\t  ssl_err, ssl_err_str, action, ret, len));\n\tbreak;\n    }\n}\n\n\nstatic pj_status_t GET_STATUS_FROM_SSL_ERR(unsigned long err)\n{\n    pj_status_t status;\n\n    /* OpenSSL error range is much wider than PJLIB errno space, so\n     * if it exceeds the space, only the error reason will be kept.\n     * Note that the last native error will be kept as is and can be\n     * retrieved via SSL socket info.\n     */\n    status = ERR_GET_LIB(err)*MAX_OSSL_ERR_REASON + ERR_GET_REASON(err);\n    if (status > PJ_SSL_ERRNO_SPACE_SIZE)\n\tstatus = ERR_GET_REASON(err);\n\n    status += PJ_SSL_ERRNO_START;\n    return status;\n}\n\n/* err contains ERR_get_error() status */\nstatic pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; //dummy\n\n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n\n    /* General SSL error, dig more from OpenSSL error queue */\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n\n    if (ssock)\n\tssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}\n\n/* err contains SSL_get_error() status */\nstatic pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    if (ssock)\n\tssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}\n\nstatic pj_status_t GET_SSL_STATUS(pj_ssl_sock_t *ssock)\n{\n    return STATUS_FROM_SSL_ERR(\"status\", ssock, ERR_get_error());\n}\n\n\n/*\n * Get error string of OpenSSL.\n */\nstatic pj_str_t ssl_strerror(pj_status_t status, \n\t\t\t     char *buf, pj_size_t bufsize)\n{\n    pj_str_t errstr;\n    unsigned long ssl_err = status;\n\n    if (ssl_err) {\n\tunsigned long l, r;\n\tssl_err -= PJ_SSL_ERRNO_START;\n\tl = ssl_err / MAX_OSSL_ERR_REASON;\n\tr = ssl_err % MAX_OSSL_ERR_REASON;\n\tssl_err = ERR_PACK(l, 0, r);\n    }\n\n#if defined(PJ_HAS_ERROR_STRING) && (PJ_HAS_ERROR_STRING != 0)\n\n    {\n\tconst char *tmp = NULL;\n\ttmp = ERR_reason_error_string(ssl_err);\n\tif (tmp) {\n\t    pj_ansi_strncpy(buf, tmp, bufsize);\n\t    errstr = pj_str(buf);\n\t    return errstr;\n\t}\n    }\n\n#endif\t/* PJ_HAS_ERROR_STRING */\n\n    errstr.ptr = buf;\n    errstr.slen = pj_ansi_snprintf(buf, bufsize, \n\t\t\t\t   \"Unknown OpenSSL error %lu\",\n\t\t\t\t   ssl_err);\n    if (errstr.slen < 1 || errstr.slen >= (int)bufsize)\n\terrstr.slen = bufsize - 1;\n    return errstr;\n}\n\n/* Additional ciphers recognized by SSL_set_cipher_list()\n   but not returned from SSL_get_ciphers().\n   NOTE: ids are designed to not conflict with those from\n         SSL_get_cipher() which get masked to the lower 24\n         bits before use. \n*/\nstatic const struct ssl_ciphers_t ADDITIONAL_CIPHERS[] = {\n        {0xFF000000, \"DEFAULT\"},\n        {0xFF000001, \"@SECLEVEL=1\"},\n        {0xFF000002, \"@SECLEVEL=2\"},\n        {0xFF000003, \"@SECLEVEL=3\"},\n        {0xFF000004, \"@SECLEVEL=4\"},\n        {0xFF000005, \"@SECLEVEL=5\"}\n};\nstatic const unsigned int ADDITIONAL_CIPHER_COUNT = \n    sizeof (ADDITIONAL_CIPHERS) / sizeof (ADDITIONAL_CIPHERS[0]);\n\n/*\n *******************************************************************\n * I/O functions.\n *******************************************************************\n */\n\nstatic pj_bool_t io_empty(pj_ssl_sock_t *ssock, circ_buf_t *cb)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    PJ_UNUSED_ARG(cb);\n\n    return !BIO_pending(ossock->ossl_wbio);\n}\n\nstatic pj_size_t io_size(pj_ssl_sock_t *ssock, circ_buf_t *cb)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    char *data;\n\n    PJ_UNUSED_ARG(cb);\n\n    return BIO_get_mem_data(ossock->ossl_wbio, &data);\n}\n\nstatic void io_read(pj_ssl_sock_t *ssock, circ_buf_t *cb,\n\t\t    pj_uint8_t *dst, pj_size_t len)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    char *data;\n\n    PJ_UNUSED_ARG(cb);\n\n    BIO_get_mem_data(ossock->ossl_wbio, &data);\n    pj_memcpy(dst, data, len);\n\n    /* Reset write BIO */\n    (void)BIO_reset(ossock->ossl_wbio);\n}\n\nstatic pj_status_t io_write(pj_ssl_sock_t *ssock, circ_buf_t *cb,\n                            const pj_uint8_t *src, pj_size_t len)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int nwritten;\n\n    nwritten = BIO_write(ossock->ossl_rbio, src, (int)len);\n    return (nwritten < (int)len)? GET_SSL_STATUS(cb->owner): PJ_SUCCESS;\n}\n\n/*\n *******************************************************************\n */\n\n/* OpenSSL library initialization counter */\nstatic int openssl_init_count;\n\n/* OpenSSL application data index */\nstatic int sslsock_idx;\n\n#if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n    PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n/* Thread lock pool.*/\nstatic pj_caching_pool \t cp;\nstatic pj_pool_t \t*lock_pool;\n\n/* OpenSSL locking list. */\nstatic pj_lock_t **ossl_locks;\n\n/* OpenSSL number locks. */\nstatic unsigned ossl_num_locks;\n\n#if     OPENSSL_VERSION_NUMBER >= 0x10000000\nstatic void ossl_set_thread_id(CRYPTO_THREADID *id)\n{\n    CRYPTO_THREADID_set_numeric(id,\n                     (unsigned long)pj_thread_get_os_handle(pj_thread_this()));\n}\n\n#else\n\nstatic unsigned long ossl_thread_id(void)\n{\n    return ((unsigned long)pj_thread_get_os_handle(pj_thread_this()));\n}\n#endif\n\nstatic void ossl_lock(int mode, int id, const char *file, int line)\n{\n    PJ_UNUSED_ARG(file);\n    PJ_UNUSED_ARG(line);\n\n    if (openssl_init_count == 0)\n        return;\n\n    if (mode & CRYPTO_LOCK) {\n        if (ossl_locks[id]) {\n            //PJ_LOG(6, (THIS_FILE, \"Lock File (%s) Line(%d)\", file, line));\n            pj_lock_acquire(ossl_locks[id]);\n        }\n    } else {\n        if (ossl_locks[id]) {\n            //PJ_LOG(6, (THIS_FILE, \"Unlock File (%s) Line(%d)\", file, line));\n            pj_lock_release(ossl_locks[id]);\n        }\n    }\n}\n\nstatic void release_thread_cb(void)\n{\n    unsigned i = 0;\n\n#if     OPENSSL_VERSION_NUMBER >= 0x10000000\n    CRYPTO_THREADID_set_callback(NULL);\n#else\n    CRYPTO_set_id_callback(NULL);\n#endif\n    CRYPTO_set_locking_callback(NULL);\n\n    for (; i < ossl_num_locks; ++i) {\n        if (ossl_locks[i]) {\n            pj_lock_destroy(ossl_locks[i]);\n            ossl_locks[i] = NULL;\n        }\n    }\n    if (lock_pool) {\n        pj_pool_release(lock_pool);\n        lock_pool = NULL;\n        pj_caching_pool_destroy(&cp);\n    }\n    ossl_locks = NULL;\n    ossl_num_locks = 0;\n}\n\nstatic pj_status_t init_ossl_lock()\n{\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_caching_pool_init(&cp, NULL, 0);\n\n    lock_pool = pj_pool_create(&cp.factory,\n                               \"ossl-lock\",\n                               64,\n                               64,\n                               NULL);\n\n    if (!lock_pool) {\n        status = PJ_ENOMEM;\n        PJ_PERROR(1, (THIS_FILE, status,\"Fail creating OpenSSL lock pool\"));\n        pj_caching_pool_destroy(&cp);\n        return status;\n    }\n\n    ossl_num_locks = CRYPTO_num_locks();\n    ossl_locks = (pj_lock_t **)pj_pool_calloc(lock_pool,\n                                              ossl_num_locks,\n                                              sizeof(pj_lock_t*));\n\n    if (ossl_locks) {\n        unsigned i = 0;\n        for (; (i < ossl_num_locks) && (status == PJ_SUCCESS); ++i) {\n            status = pj_lock_create_simple_mutex(lock_pool, \"ossl_lock%p\",\n                                                 &ossl_locks[i]);\n        }\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(1, (THIS_FILE, status,\n                          \"Fail creating mutex for OpenSSL lock\"));\n            release_thread_cb();\n            return status;\n        }\n\n#if     OPENSSL_VERSION_NUMBER >= 0x10000000\n        CRYPTO_THREADID_set_callback(ossl_set_thread_id);\n#else\n        CRYPTO_set_id_callback(ossl_thread_id);\n#endif\n        CRYPTO_set_locking_callback(ossl_lock);\n        status = pj_atexit(&release_thread_cb);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(1, (THIS_FILE, status, \"Warning! Unable to set OpenSSL \"\n                          \"lock thread callback unrelease method.\"));\n        }\n    } else {\n        status = PJ_ENOMEM;\n        PJ_PERROR(1, (THIS_FILE, status,\"Fail creating OpenSSL locks\"));\n        release_thread_cb();\n    }\n    return status;\n}\n\n#endif\n\n/* Initialize OpenSSL */\nstatic pj_status_t init_openssl(void)\n{\n    pj_status_t status;\n\n    if (openssl_init_count)\n\treturn PJ_SUCCESS;\n\n    openssl_init_count = 1;\n\n    /* Register error subsystem */\n    status = pj_register_strerror(PJ_SSL_ERRNO_START, \n\t\t\t\t  PJ_SSL_ERRNO_SPACE_SIZE, \n\t\t\t\t  &ssl_strerror);\n    pj_assert(status == PJ_SUCCESS);\n\n    /* Init OpenSSL lib */\n#if USING_LIBRESSL || OPENSSL_VERSION_NUMBER < 0x10100000L\n    SSL_library_init();\n    SSL_load_error_strings();\n#else\n    OPENSSL_init_ssl(0, NULL);\n#endif\n#if OPENSSL_VERSION_NUMBER < 0x009080ffL\n    /* This is now synonym of SSL_library_init() */\n    OpenSSL_add_all_algorithms();\n#endif\n\n    /* Init available ciphers */\n    if (ssl_cipher_num == 0 || ssl_curves_num == 0) {\n\tSSL_METHOD *meth = NULL;\n\tSSL_CTX *ctx;\n\tSSL *ssl;\n\tSTACK_OF(SSL_CIPHER) *sk_cipher;\n\tSSL_SESSION *ssl_sess;\n\tunsigned i, n;\n\tint nid;\n\tconst char *cname;\n\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n\n\tmeth = (SSL_METHOD*)SSLv23_server_method();\n\tif (!meth)\n\t    meth = (SSL_METHOD*)TLSv1_server_method();\n#ifndef OPENSSL_NO_SSL3_METHOD\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv3_server_method();\n#endif\n#ifndef OPENSSL_NO_SSL2\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv2_server_method();\n#endif\n\n#else\n\t/* Specific version methods are deprecated in 1.1.0 */\n\tmeth = (SSL_METHOD*)TLS_method();\n#endif\n\n\tpj_assert(meth);\n\n\tctx=SSL_CTX_new(meth);\n\tSSL_CTX_set_cipher_list(ctx, \"ALL:COMPLEMENTOFALL\");\n\n\tssl = SSL_new(ctx);\n\n\tsk_cipher = SSL_get_ciphers(ssl);\n\n\tn = sk_SSL_CIPHER_num(sk_cipher);\n\tif (n > PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT)\n\t    n = PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT;\n\n\tfor (i = 0; i < n; ++i) {\n\t    const SSL_CIPHER *c;\n\t    c = sk_SSL_CIPHER_value(sk_cipher,i);\n\t    ssl_ciphers[i].id = (pj_ssl_cipher)\n\t\t\t\t    (pj_uint32_t)SSL_CIPHER_get_id(c) &\n\t\t\t\t    0x00FFFFFF;\n\t    ssl_ciphers[i].name = SSL_CIPHER_get_name(c);\n\t}\n\n\t/* Add cipher aliases not returned from SSL_get_ciphers() */\n\tfor (i = 0; i < ADDITIONAL_CIPHER_COUNT; ++i) {\n\t    ssl_ciphers[n++] = ADDITIONAL_CIPHERS[i];\n\t}\n\tssl_cipher_num = n;\n\n\tssl_sess = SSL_SESSION_new();\n\tSSL_set_session(ssl, ssl_sess);\n\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n    && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\tssl_curves_num = EC_get_builtin_curves(NULL, 0);\n#else\n\tssl_curves_num = SSL_get_shared_curve(ssl,-1);\n\n\tif (ssl_curves_num > PJ_ARRAY_SIZE(ssl_curves))\n\t    ssl_curves_num = PJ_ARRAY_SIZE(ssl_curves);\n#endif\n\n\tif( ssl_curves_num > 0 ) {\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\t    EC_builtin_curve * curves = NULL;\n\n\t    curves = OPENSSL_malloc((int)sizeof(*curves) * ssl_curves_num);\n\t    if (!EC_get_builtin_curves(curves, ssl_curves_num)) {\n\t\tOPENSSL_free(curves);\n\t\tcurves = NULL;\n\t\tssl_curves_num = 0;\n\t    }\n\n\t    n = ssl_curves_num;\n\t    ssl_curves_num = 0;\n\n\t    for (i = 0; i < n; i++) {\n\t\tnid = curves[i].nid;\n\n\t\tif ( 0 != get_cid_from_nid(nid) ) {\n\t\t    cname = OBJ_nid2sn(nid);\n\n\t\t    if (!cname)\n\t\t\tcname = OBJ_nid2sn(nid);\n\n\t\t    if (cname) {\n\t\t\tssl_curves[ssl_curves_num].id = get_cid_from_nid(nid);\n\t\t\tssl_curves[ssl_curves_num].name = cname;\n\n\t\t\tssl_curves_num++;\n\n\t\t\tif (ssl_curves_num >= PJ_SSL_SOCK_MAX_CURVES )\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if(curves)\n\t\tOPENSSL_free(curves);\n#else\n\tfor (i = 0; i < ssl_curves_num; i++) {\n\t    nid = SSL_get_shared_curve(ssl, i);\n\n\t    if (nid & TLSEXT_nid_unknown) {\n\t\tcname = \"curve unknown\";\n\t\tnid &= 0xFFFF;\n\t    } else {\n\t\tcname = EC_curve_nid2nist(nid);\n\t\tif (!cname)\n\t\t    cname = OBJ_nid2sn(nid);\n\t    }\n\n\t    ssl_curves[i].id   = get_cid_from_nid(nid);\n\t    ssl_curves[i].name = cname;\n\t}\n#endif\n\n\t}\n#else\n\tPJ_UNUSED_ARG(nid);\n\tPJ_UNUSED_ARG(cname);\n\tssl_curves_num = 0;\n#endif\n\n\tSSL_free(ssl);\n\n\t/* On OpenSSL 1.1.1, omitting SSL_SESSION_free() will cause \n\t * memory leak (e.g: as reported by Address Sanitizer). But using\n\t * SSL_SESSION_free() may cause crash (due to double free?) on 1.0.x.\n\t * As OpenSSL docs specifies to not calling SSL_SESSION_free() after\n\t * SSL_free(), perhaps it is safer to obey this, the leak amount seems\n\t * to be relatively small (<500 bytes) and should occur once only in\n\t * the library lifetime.\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n\tSSL_SESSION_free(ssl_sess);\n#endif\n\t */\n\n\tSSL_CTX_free(ctx);\n    }\n\n    /* Create OpenSSL application data index for SSL socket */\n    sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n    if (sslsock_idx == -1) {\n\tstatus = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);\n\tPJ_LOG(1,(THIS_FILE,\n\t       \"Fatal error: failed to get application data index for \"\n\t       \"SSL socket\"));\n\treturn status;\n    }\n\n#if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n    PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n    status = init_ossl_lock();\n    if (status != PJ_SUCCESS)\n        return status;\n#endif\n\n    return status;\n}\n\n/* Shutdown OpenSSL */\nstatic void shutdown_openssl(void)\n{\n    PJ_UNUSED_ARG(openssl_init_count);\n}\n\n/* SSL password callback. */\nstatic int password_cb(char *buf, int num, int rwflag, void *user_data)\n{\n    pj_ssl_cert_t *cert = (pj_ssl_cert_t*) user_data;\n\n    PJ_UNUSED_ARG(rwflag);\n\n    if(num < cert->privkey_pass.slen)\n\treturn 0;\n    \n    pj_memcpy(buf, cert->privkey_pass.ptr, cert->privkey_pass.slen);\n    return (int)cert->privkey_pass.slen;\n}\n\n\n/* SSL certificate verification result callback.\n * Note that this callback seems to be always called from library worker\n * thread, e.g: active socket on_read_complete callback, which should have\n * already been equipped with race condition avoidance mechanism (should not\n * be destroyed while callback is being invoked).\n */\nstatic int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock = NULL;\n    SSL *ossl_ssl = NULL;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    if (!ossl_ssl) {\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL instance\"));\n\tgoto on_return;\n    }\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    if (!ssock) {\n\t/* SSL socket may have been destroyed */\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL socket \"\n\t\t  \"instance (sslsock_idx=%d).\", sslsock_idx));\n\tgoto on_return;\n    }\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n\n    case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\n    case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\n    case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\n    case X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\n\tssock->verify_status |= PJ_SSL_CERT_EINVALID_FORMAT;\n\tbreak;\n\n    case X509_V_ERR_CERT_NOT_YET_VALID:\n    case X509_V_ERR_CERT_HAS_EXPIRED:\n\tssock->verify_status |= PJ_SSL_CERT_EVALIDITY_PERIOD;\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_CRL:\n    case X509_V_ERR_CRL_NOT_YET_VALID:\n    case X509_V_ERR_CRL_HAS_EXPIRED:\n    case X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\n    case X509_V_ERR_CRL_SIGNATURE_FAILURE:\n    case X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\n    case X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\n\tssock->verify_status |= PJ_SSL_CERT_ECRL_FAILURE;\n\tbreak;\t\n\n    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n    case X509_V_ERR_CERT_UNTRUSTED:\n    case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n\tssock->verify_status |= PJ_SSL_CERT_EUNTRUSTED;\n\tbreak;\t\n\n    case X509_V_ERR_CERT_SIGNATURE_FAILURE:\n    case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n    case X509_V_ERR_SUBJECT_ISSUER_MISMATCH:\n    case X509_V_ERR_AKID_SKID_MISMATCH:\n    case X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH:\n    case X509_V_ERR_KEYUSAGE_NO_CERTSIGN:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_MISMATCH;\n\tbreak;\n\n    case X509_V_ERR_CERT_REVOKED:\n\tssock->verify_status |= PJ_SSL_CERT_EREVOKED;\n\tbreak;\t\n\n    case X509_V_ERR_INVALID_PURPOSE:\n    case X509_V_ERR_CERT_REJECTED:\n    case X509_V_ERR_INVALID_CA:\n\tssock->verify_status |= PJ_SSL_CERT_EINVALID_PURPOSE;\n\tbreak;\n\n    case X509_V_ERR_CERT_CHAIN_TOO_LONG: /* not really used */\n    case X509_V_ERR_PATH_LENGTH_EXCEEDED:\n\tssock->verify_status |= PJ_SSL_CERT_ECHAIN_TOO_LONG;\n\tbreak;\n\n    /* Unknown errors */\n    case X509_V_ERR_OUT_OF_MEM:\n    default:\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    /* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\non_return:\n    return preverify_ok;\n}\n\n/* Setting SSL sock cipher list */\nstatic pj_status_t set_cipher_list(pj_ssl_sock_t *ssock);\n/* Setting SSL sock curves list */\nstatic pj_status_t set_curves_list(pj_ssl_sock_t *ssock);\n/* Setting sigalgs list */\nstatic pj_status_t set_sigalgs(pj_ssl_sock_t *ssock);\n/* Setting entropy for rng */\nstatic void set_entropy(pj_ssl_sock_t *ssock);\n\n\nstatic pj_ssl_sock_t *ssl_alloc(pj_pool_t *pool)\n{\n    return (pj_ssl_sock_t *)PJ_POOL_ZALLOC_T(pool, ossl_sock_t);\n}\n\nstatic int xname_cmp(const X509_NAME * const *a, const X509_NAME * const *b) {\n  return X509_NAME_cmp(*a, *b);\n}\n\n/* Create and initialize new SSL context and instance */\nstatic pj_status_t ssl_create(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n#if !defined(OPENSSL_NO_DH)\n    BIO *bio;\n    DH *dh;\n    long options;\n#endif\n    SSL_METHOD *ssl_method = NULL;\n    SSL_CTX *ctx;\n    pj_uint32_t ssl_opt = 0;\n    pj_ssl_cert_t *cert;\n    int mode, rc;\n    pj_status_t status;\n        \n    pj_assert(ssock);\n\n    cert = ssock->cert;\n\n    /* Make sure OpenSSL library has been initialized */\n    init_openssl();\n\n    set_entropy(ssock);\n\n    if (ssock->param.proto == PJ_SSL_SOCK_PROTO_DEFAULT)\n\tssock->param.proto = PJ_SSL_SOCK_PROTO_SSL23;\n\n    /* Determine SSL method to use */\n    /* Specific version methods are deprecated since 1.1.0 */\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n    switch (ssock->param.proto) {\n    case PJ_SSL_SOCK_PROTO_TLS1:\n\tssl_method = (SSL_METHOD*)TLSv1_method();\n\tbreak;\n#ifndef OPENSSL_NO_SSL2\n    case PJ_SSL_SOCK_PROTO_SSL2:\n\tssl_method = (SSL_METHOD*)SSLv2_method();\n\tbreak;\n#endif\n#ifndef OPENSSL_NO_SSL3_METHOD\n    case PJ_SSL_SOCK_PROTO_SSL3:\n\tssl_method = (SSL_METHOD*)SSLv3_method();\n#endif\n\tbreak;\n    }\n#endif\n\n    if (!ssl_method) {\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n\tssl_method = (SSL_METHOD*)SSLv23_method();\n#else\n\tssl_method = (SSL_METHOD*)TLS_method();\n#endif\n\n#ifdef SSL_OP_NO_SSLv2\n\t/** Check if SSLv2 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL2)==0)?\n\t\t    SSL_OP_NO_SSLv2:0;\n#endif\n\n#ifdef SSL_OP_NO_SSLv3\n\t/** Check if SSLv3 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_SSL3)==0)?\n\t\t    SSL_OP_NO_SSLv3:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1\n\t/** Check if TLSv1 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1)==0)?\n\t\t    SSL_OP_NO_TLSv1:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1_1\n\t/** Check if TLSv1_1 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_1)==0)?\n\t\t    SSL_OP_NO_TLSv1_1:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1_2\n\t/** Check if TLSv1_2 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_2)==0)?\n\t\t    SSL_OP_NO_TLSv1_2:0;\n#endif\n\n#ifdef SSL_OP_NO_TLSv1_3\n\t/** Check if TLSv1_3 is enabled */\n\tssl_opt |= ((ssock->param.proto & PJ_SSL_SOCK_PROTO_TLS1_3)==0)?\n\t\t    SSL_OP_NO_TLSv1_3:0;\n#endif\n\n    }\n\n    /* Create SSL context */\n    ctx = SSL_CTX_new(ssl_method);\n    if (ctx == NULL) {\n\treturn GET_SSL_STATUS(ssock);\n    }\n    ossock->ossl_ctx = ctx;\n\n    if (ssl_opt)\n\tSSL_CTX_set_options(ctx, ssl_opt);\n\n    /* Set cipher list */\n    status = set_cipher_list(ssock);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Apply credentials */\n    if (cert) {\n\t/* Load CA list if one is specified. */\n\tif (cert->CA_file.slen || cert->CA_path.slen) {\n\n\t    rc = SSL_CTX_load_verify_locations(\n\t\t\tctx,\n\t\t\tcert->CA_file.slen == 0 ? NULL : cert->CA_file.ptr,\n\t\t\tcert->CA_path.slen == 0 ? NULL : cert->CA_path.ptr);\n\n\t    if (rc != 1) {\n\t\tstatus = GET_SSL_STATUS(ssock);\n\t\tif (cert->CA_file.slen) {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t\t \"Error loading CA list file '%s'\",\n\t\t\t\t cert->CA_file.ptr));\n\t\t}\n\t\tif (cert->CA_path.slen) {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t\t \"Error loading CA path '%s'\",\n\t\t\t\t cert->CA_path.ptr));\n\t\t}\n\t\tSSL_CTX_free(ctx);\n\t\treturn status;\n\t    } else {\n\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t  \"CA certificates loaded from '%s%s%s'\",\n\t\t\t  cert->CA_file.ptr,\n\t\t\t  ((cert->CA_file.slen && cert->CA_path.slen)?\n\t\t\t\t\" + \":\"\"),\n\t\t\t  cert->CA_path.ptr));\n\t    }\n\t}\n    \n\t/* Set password callback */\n\tif (cert->privkey_pass.slen) {\n\t    SSL_CTX_set_default_passwd_cb(ctx, password_cb);\n\t    SSL_CTX_set_default_passwd_cb_userdata(ctx, cert);\n\t}\n\n\n\t/* Load certificate if one is specified */\n\tif (cert->cert_file.slen) {\n\n\t    /* Load certificate chain from file into ctx */\n\t    rc = SSL_CTX_use_certificate_chain_file(ctx, cert->cert_file.ptr);\n\n\t    if(rc != 1) {\n\t\tstatus = GET_SSL_STATUS(ssock);\n\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t     \"Error loading certificate chain file '%s'\",\n\t\t\t     cert->cert_file.ptr));\n\t\tSSL_CTX_free(ctx);\n\t\treturn status;\n\t    } else {\n\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t  \"Certificate chain loaded from '%s'\",\n\t\t\t  cert->cert_file.ptr));\n\t    }\n\t}\n\n\n\t/* Load private key if one is specified */\n\tif (cert->privkey_file.slen) {\n\t    /* Adds the first private key found in file to ctx */\n\t    rc = SSL_CTX_use_PrivateKey_file(ctx, cert->privkey_file.ptr, \n\t\t\t\t\t     SSL_FILETYPE_PEM);\n\n\t    if(rc != 1) {\n\t\tstatus = GET_SSL_STATUS(ssock);\n\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t     \"Error adding private key from '%s'\",\n\t\t\t     cert->privkey_file.ptr));\n\t\tSSL_CTX_free(ctx);\n\t\treturn status;\n\t    } else {\n\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t  \"Private key loaded from '%s'\",\n\t\t\t  cert->privkey_file.ptr));\n\t    }\n\n#if !defined(OPENSSL_NO_DH)\n\t    if (ssock->is_server) {\n\t\tbio = BIO_new_file(cert->privkey_file.ptr, \"r\");\n\t\tif (bio != NULL) {\n\t\t    dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\t\t    if (dh != NULL) {\n\t\t\tif (SSL_CTX_set_tmp_dh(ctx, dh)) {\n\t\t\t    options = SSL_OP_CIPHER_SERVER_PREFERENCE |\n    #if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x10000000L\n\t\t\t\t      SSL_OP_SINGLE_ECDH_USE |\n    #endif\n\t\t\t\t      SSL_OP_SINGLE_DH_USE;\n\t\t\t    options = SSL_CTX_set_options(ctx, options);\n\t\t\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL DH \"\n\t\t\t\t     \"initialized, PFS cipher-suites enabled\"));\n\t\t\t}\n\t\t\tDH_free(dh);\n\t\t    }\n\t\t    BIO_free(bio);\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/* Load from buffer. */\n\tif (cert->cert_buf.slen) {\n\t    BIO *cbio;\n\t    X509 *xcert = NULL;\n\t    \n\t    cbio = BIO_new_mem_buf((void*)cert->cert_buf.ptr,\n\t\t\t\t   cert->cert_buf.slen);\n\t    if (cbio != NULL) {\n\t\txcert = PEM_read_bio_X509(cbio, NULL, 0, NULL);\n\t\tif (xcert != NULL) {\n\t\t    rc = SSL_CTX_use_certificate(ctx, xcert);\n\t\t    if (rc != 1) {\n\t\t\tstatus = GET_SSL_STATUS(ssock);\n\t\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t      \"Error loading chain certificate from buffer\"));\n\t\t\tX509_free(xcert);\n\t\t\tBIO_free(cbio);\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn status;\n\t\t    } else {\n\t\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t\t  \"Certificate chain loaded from buffer\"));\n\t\t    }\n\t\t    X509_free(xcert);\n\t\t}\n\t\tBIO_free(cbio);\n\t    }\t    \n\t}\n\n\tif (cert->CA_buf.slen) {\n\t    BIO *cbio = BIO_new_mem_buf((void*)cert->CA_buf.ptr,\n\t\t\t\t\tcert->CA_buf.slen);\n\t    X509_STORE *cts = SSL_CTX_get_cert_store(ctx);\n\n\t    if (cbio && cts) {\n\t\tSTACK_OF(X509_INFO) *inf = PEM_X509_INFO_read_bio(cbio, NULL, \n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n\t\tif (inf != NULL) {\n\t\t    int i = 0, cnt = 0;\n\t\t    for (; i < sk_X509_INFO_num(inf); i++) {\n\t\t\tX509_INFO *itmp = sk_X509_INFO_value(inf, i);\n\t\t\tif (!itmp->x509)\n\t\t\t    continue;\n\n\t\t\trc = X509_STORE_add_cert(cts, itmp->x509);\n\t\t\tif (rc == 1) {\n\t\t\t    ++cnt;\n\t\t\t} else {\n#if PJ_LOG_MAX_LEVEL >= 4\n\t\t\t    char buf[256];\n\t\t\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t\t      \"Error adding CA cert: %s\",\n\t\t\t\t      X509_NAME_oneline(\n\t\t\t\t\tX509_get_subject_name(itmp->x509),\n\t\t\t\t\tbuf, sizeof(buf))));\n#endif\n\t\t\t}\n\t\t    }\n\t\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t      \"CA certificates loaded from buffer (cnt=%d)\",\n\t\t\t      cnt));\n\t\t}\n\t\tsk_X509_INFO_pop_free(inf, X509_INFO_free);\n\t\tBIO_free(cbio);\n\t    }\n\t}\n\n\tif (cert->privkey_buf.slen) {\n\t    BIO *kbio;\t    \n\t    EVP_PKEY *pkey = NULL;\n\n\t    kbio = BIO_new_mem_buf((void*)cert->privkey_buf.ptr,\n\t\t\t\t   cert->privkey_buf.slen);\n\t    if (kbio != NULL) {\n\t\tpkey = PEM_read_bio_PrivateKey(kbio, NULL, &password_cb,\n\t\t\t\t\t       cert);\n\t\tif (pkey) {\n\t\t    rc = SSL_CTX_use_PrivateKey(ctx, pkey);\n\t\t    if (rc != 1) {\n\t\t\tstatus = GET_SSL_STATUS(ssock);\n\t\t\tPJ_PERROR(1,(ssock->pool->obj_name, status,\n\t\t\t\t     \"Error adding private key from buffer\"));\n\t\t\tEVP_PKEY_free(pkey);\n\t\t\tBIO_free(kbio);\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn status;\n\t\t    } else {\n\t\t\tPJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t\t  \"Private key loaded from buffer\"));\n\t\t    }\n\t\t    EVP_PKEY_free(pkey);\n\t\t} else {\n\t\t    PJ_LOG(1,(ssock->pool->obj_name,\n\t\t\t      \"Error reading private key from buffer\"));\n\t\t}\n\n\t\tif (ssock->is_server) {\n\t\t    dh = PEM_read_bio_DHparams(kbio, NULL, NULL, NULL);\n\t\t    if (dh != NULL) {\n\t\t\tif (SSL_CTX_set_tmp_dh(ctx, dh)) {\n\t\t\t    options = SSL_OP_CIPHER_SERVER_PREFERENCE |\n    #if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x10000000L\n\t\t\t\t      SSL_OP_SINGLE_ECDH_USE |\n    #endif\n\t\t\t\t      SSL_OP_SINGLE_DH_USE;\n\t\t\t    options = SSL_CTX_set_options(ctx, options);\n\t\t\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL DH \"\n\t\t\t\t     \"initialized, PFS cipher-suites enabled\"));\n\t\t\t}\n\t\t\tDH_free(dh);\n\t\t    }\n\t\t}\n\t\tBIO_free(kbio);\n\t    }\t    \n\t}\n    }\n\n    if (ssock->is_server) {\n\tchar *p = NULL;\n\n\t/* If certificate file name contains \"_rsa.\", let's check if there are\n\t * ecc and dsa certificates too.\n\t */\n\tif (cert && cert->cert_file.slen) {\n\t    const pj_str_t RSA = {\"_rsa.\", 5};\n\t    p = pj_strstr(&cert->cert_file, &RSA);\n\t    if (p) p++; /* Skip underscore */\n\t}\n\tif (p) {\n\t    /* Certificate type string length must be exactly 3 */\n\t    enum { CERT_TYPE_LEN = 3 };\n\t    const char* cert_types[] = { \"ecc\", \"dsa\" };\n\t    char *cf = cert->cert_file.ptr;\n\t    int i;\n\n\t    /* Check and load ECC & DSA certificates & private keys */\n\t    for (i = 0; i < PJ_ARRAY_SIZE(cert_types); ++i) {\n\t\tint err;\n\n\t\tpj_memcpy(p, cert_types[i], CERT_TYPE_LEN);\n\t\tif (!pj_file_exists(cf))\n\t\t    continue;\n\n\t\terr = SSL_CTX_use_certificate_chain_file(ctx, cf);\n\t\tif (err == 1)\n\t\t    err = SSL_CTX_use_PrivateKey_file(ctx, cf,\n\t\t\t\t\t\t      SSL_FILETYPE_PEM);\n\t\tif (err == 1) {\n\t\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t\t      \"Additional certificate '%s' loaded.\", cf));\n\t\t} else {\n\t\t    PJ_PERROR(1,(ssock->pool->obj_name, GET_SSL_STATUS(ssock),\n\t\t\t\t \"Error loading certificate file '%s'\", cf));\n\t\t    ERR_clear_error();\n\t\t}\n\t    }\n\n\t    /* Put back original name */\n\t    pj_memcpy(p, \"rsa\", CERT_TYPE_LEN);\n\t}\n\n    #ifndef SSL_CTRL_SET_ECDH_AUTO\n\t#define SSL_CTRL_SET_ECDH_AUTO 94\n    #endif\n\n\t/* SSL_CTX_set_ecdh_auto(ctx,on) requires OpenSSL 1.0.2 which wraps: */\n\tif (SSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, 1, NULL)) {\n\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL ECDH initialized \"\n\t\t      \"(automatic), faster PFS ciphers enabled\"));\n    #if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n\tOPENSSL_VERSION_NUMBER < 0x10100000L\n\t} else {\n\t    /* enables AES-128 ciphers, to get AES-256 use NID_secp384r1 */\n\t    EC_KEY *ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\t    if (ecdh != NULL) {\n\t\tif (SSL_CTX_set_tmp_ecdh(ctx, ecdh)) {\n\t\t    PJ_LOG(4,(ssock->pool->obj_name, \"SSL ECDH initialized \"\n\t\t\t      \"(secp256r1), faster PFS cipher-suites enabled\"));\n\t\t}\n\t\tEC_KEY_free(ecdh);\n\t    }\n    #endif\n\t}\n    } else {\n\tX509_STORE *pkix_validation_store = SSL_CTX_get_cert_store(ctx);\n\tif (NULL != pkix_validation_store) {\n#if defined(X509_V_FLAG_TRUSTED_FIRST)\n\t    X509_STORE_set_flags(pkix_validation_store, \n\t\t\t\t X509_V_FLAG_TRUSTED_FIRST);\n#endif\n#if defined(X509_V_FLAG_PARTIAL_CHAIN)\n\t    X509_STORE_set_flags(pkix_validation_store, \n\t\t\t\t X509_V_FLAG_PARTIAL_CHAIN);\n#endif\n\t}\n    }\n\n    /* Add certificate authorities for clients from CA.\n     * Needed for certificate request during handshake.\n     */\n    if (cert && ssock->is_server) {\n        STACK_OF(X509_NAME) *ca_dn = NULL;\n\n        if (cert->CA_file.slen > 0) {\n            ca_dn = SSL_load_client_CA_file(cert->CA_file.ptr);\n        } else if (cert->CA_buf.slen > 0) {\n            X509      *x  = NULL;\n            X509_NAME *xn = NULL;\n            STACK_OF(X509_NAME) *sk = NULL;\n            BIO *new_bio = BIO_new_mem_buf((void*)cert->CA_buf.ptr,\n\t\t\t\t\t   cert->CA_buf.slen);\n\n            sk = sk_X509_NAME_new(xname_cmp);\n\n            if (sk != NULL && new_bio != NULL) {\n                for (;;) {\n                    if (PEM_read_bio_X509(new_bio, &x, NULL, NULL) == NULL)\n                        break;\n\n                    if ((xn = X509_get_subject_name(x)) == NULL)\n                        break;\n\n                    if ((xn = X509_NAME_dup(xn)) == NULL )\n                        break;\n\n                    if (sk_X509_NAME_find(sk, xn) >= 0) {\n                        X509_NAME_free(xn);\n                    } else {\n                        sk_X509_NAME_push(sk, xn);\n                    }\n                    X509_free(x);\n                    x = NULL;\n                }\n            }\n            if (sk != NULL)\n            \tca_dn = sk;\n            if (new_bio != NULL)\n                BIO_free(new_bio);\n        }\n\n\tif (ca_dn != NULL) {\n\t    SSL_CTX_set_client_CA_list(ctx, ca_dn);\n\t    PJ_LOG(4,(ssock->pool->obj_name,\n\t\t      \"CA certificates loaded from %s\",\n\t\t      (cert->CA_file.slen?cert->CA_file.ptr:\"buffer\")));\n\t} else {\n\t    PJ_LOG(1,(ssock->pool->obj_name,\n\t\t      \"Error reading CA certificates from %s\",\n\t\t      (cert->CA_file.slen?cert->CA_file.ptr:\"buffer\")));\n\t}\n    }\n\n    /* Early sensitive data cleanup after OpenSSL context setup. However,\n     * this cannot be done for listener sockets, as the data will still\n     * be needed by accepted sockets.\n     */\n    if (cert && (!ssock->is_server || ssock->parent)) {\n\tpj_ssl_cert_wipe_keys(cert);\t\n    }\n\n    /* Create SSL instance */\n    ossock->ossl_ssl = SSL_new(ossock->ossl_ctx);\n    if (ossock->ossl_ssl == NULL) {\n\treturn GET_SSL_STATUS(ssock);\n    }\n\n    /* Set SSL sock as application data of SSL instance */\n    SSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, ssock);\n\n    /* SSL verification options */\n    mode = SSL_VERIFY_PEER;\n    if (ssock->is_server && ssock->param.require_client_cert)\n\tmode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n    SSL_set_verify(ossock->ossl_ssl, mode, &verify_cb);\n\n    /* Set curve list */\n    status = set_curves_list(ssock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set sigalg list */\n    status = set_sigalgs(ssock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Setup SSL BIOs */\n    ossock->ossl_rbio = BIO_new(BIO_s_mem());\n    ossock->ossl_wbio = BIO_new(BIO_s_mem());\n    (void)BIO_set_close(ossock->ossl_rbio, BIO_CLOSE);\n    (void)BIO_set_close(ossock->ossl_wbio, BIO_CLOSE);\n    SSL_set_bio(ossock->ossl_ssl, ossock->ossl_rbio, ossock->ossl_wbio);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Destroy SSL context and instance */\nstatic void ssl_destroy(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    /* Destroy SSL instance */\n    if (ossock->ossl_ssl) {\n\tSSL_free(ossock->ossl_ssl); /* this will also close BIOs */\n\tossock->ossl_ssl = NULL;\n    }\n\n    /* Destroy SSL context */\n    if (ossock->ossl_ctx) {\n\tSSL_CTX_free(ossock->ossl_ctx);\n\tossock->ossl_ctx = NULL;\n    }\n\n    /* Potentially shutdown OpenSSL library if this is the last\n     * context exists.\n     */\n    shutdown_openssl();\n}\n\n\n/* Reset SSL socket state */\nstatic void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    /* Detach from SSL instance */\n    if (ossock->ossl_ssl) {\n\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n    }\n\n    /**\n     * Avoid calling SSL_shutdown() if handshake wasn't completed.\n     * OpenSSL 1.0.2f complains if SSL_shutdown() is called during an\n     * SSL handshake, while previous versions always return 0.\n     */\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    /* Flush data to send close notify. */\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n\n    ssl_close_sockets(ssock);\n\n    /* Upon error, OpenSSL may leave any error description in the thread \n     * error queue, which sometime may cause next call to SSL API returning\n     * false error alarm, e.g: in Linux, SSL_CTX_use_certificate_chain_file()\n     * returning false error after a handshake error (in different SSL_CTX!).\n     * For now, just clear thread error queue here.\n     */\n    ERR_clear_error();\n}\n\n\nstatic void ssl_ciphers_populate()\n{\n    if (ssl_cipher_num == 0 || ssl_curves_num == 0) {\n\tinit_openssl();\n\tshutdown_openssl();\n    }\n}\n\nstatic pj_ssl_cipher ssl_get_cipher(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    const SSL_CIPHER *cipher;\n\n    /* Current cipher */\n    cipher = SSL_get_current_cipher(ossock->ossl_ssl);\n    if (cipher) {\n\treturn (SSL_CIPHER_get_id(cipher) & 0x00FFFFFF);\n    } else {\n\treturn PJ_TLS_UNKNOWN_CIPHER;\n    }\n}\n\n/* Generate cipher list with user preference order in OpenSSL format */\nstatic pj_status_t set_cipher_list(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_pool_t *tmp_pool = NULL;\n    char *buf = NULL;\n    enum { BUF_SIZE = 8192 };\n    pj_str_t cipher_list;\n    unsigned i, j;\n    int ret;\n\n    if (ssock->param.ciphers_num == 0) {\n\tret = SSL_CTX_set_cipher_list(ossock->ossl_ctx, PJ_SSL_SOCK_OSSL_CIPHERS);\n    \tif (ret < 1) {\n\t    return GET_SSL_STATUS(ssock);\n    \t}    \n\t\n\treturn PJ_SUCCESS;\n    }\n\n    /* Create temporary pool. */\n    tmp_pool = pj_pool_create(ssock->pool->factory, \"ciphpool\", BUF_SIZE, \n\t\t\t      BUF_SIZE/2 , NULL);\n    if (!tmp_pool)\n\treturn PJ_ENOMEM;\n\n    buf = (char *)pj_pool_zalloc(tmp_pool, BUF_SIZE);\n\n    pj_strset(&cipher_list, buf, 0);\n\n    /* Generate user specified cipher list in OpenSSL format */\n    for (i = 0; i < ssock->param.ciphers_num; ++i) {\n\tfor (j = 0; j < ssl_cipher_num; ++j) {\n\t    if (ssock->param.ciphers[i] == ssl_ciphers[j].id)\n\t    {\n\t\tconst char *c_name = ssl_ciphers[j].name;\n\n\t\t/* Check buffer size */\n\t\tif (cipher_list.slen + pj_ansi_strlen(c_name) + 2 >\n\t\t    BUF_SIZE)\n\t\t{\n\t\t    pj_assert(!\"Insufficient temporary buffer for cipher\");\n\t\t    return PJ_ETOOMANY;\n\t\t}\n\n\t\t/* Add colon separator */\n\t\tif (cipher_list.slen)\n\t\t    pj_strcat2(&cipher_list, \":\");\n\n\t\t/* Add the cipher */\n\t\tpj_strcat2(&cipher_list, c_name);\n\t\tbreak;\n\t    }\n\t}\t\n    }\n\n    /* Put NULL termination in the generated cipher list */\n    cipher_list.ptr[cipher_list.slen] = '\\0';\n\n    /* Finally, set chosen cipher list */\n    ret = SSL_CTX_set_cipher_list(ossock->ossl_ctx, buf);\n    if (ret < 1) {\n\tpj_pool_release(tmp_pool);\n\treturn GET_SSL_STATUS(ssock);\n    }\n\n    pj_pool_release(tmp_pool);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t set_curves_list(pj_ssl_sock_t *ssock)\n{\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n    && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int ret;\n    int curves[PJ_SSL_SOCK_MAX_CURVES];\n    unsigned cnt;\n\n    if (ssock->param.curves_num == 0)\n\treturn PJ_SUCCESS;\n\n    for (cnt = 0; cnt < ssock->param.curves_num; cnt++) {\n\tcurves[cnt] = get_nid_from_cid(ssock->param.curves[cnt]);\n    }\n\n    if( SSL_is_server(ossock->ossl_ssl) ) {\n\tret = SSL_set1_curves(ossock->ossl_ssl, curves,\n\t\t\t      ssock->param.curves_num);\n\tif (ret < 1)\n\t    return GET_SSL_STATUS(ssock);\n    } else {\n\tret = SSL_CTX_set1_curves(ossock->ossl_ctx, curves,\n\t\t\t\t  ssock->param.curves_num);\n\tif (ret < 1)\n\t    return GET_SSL_STATUS(ssock);\n    }\n#else\n    PJ_UNUSED_ARG(ssock);\n#endif\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t set_sigalgs(pj_ssl_sock_t *ssock)\n{\n#if !USING_LIBRESSL && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int ret;\n\n    if (ssock->param.sigalgs.ptr && ssock->param.sigalgs.slen) {\n\tif (ssock->is_server) {\n\t    ret = SSL_set1_client_sigalgs_list(ossock->ossl_ssl,\n\t    \t\t\t\t       ssock->param.sigalgs.ptr);\n\t} else {\n\t    ret = SSL_set1_sigalgs_list(ossock->ossl_ssl,\n\t    \t\t\t\tssock->param.sigalgs.ptr);\n\t}\n\n\tif (ret < 1)\n\t    return GET_SSL_STATUS(ssock);\n    }\n#else\n    PJ_UNUSED_ARG(ssock);\n#endif\n    return PJ_SUCCESS;\n}\n\nstatic void set_entropy(pj_ssl_sock_t *ssock)\n{\n    int ret = 0;\n\n    switch (ssock->param.entropy_type) {\n#ifndef OPENSSL_NO_EGD\n\tcase PJ_SSL_ENTROPY_EGD:\n\t    ret = RAND_egd(ssock->param.entropy_path.ptr);\n\t    break;\n#endif\n\tcase PJ_SSL_ENTROPY_RANDOM:\n\t    ret = RAND_load_file(\"/dev/random\",255);\n\t    break;\n\tcase PJ_SSL_ENTROPY_URANDOM:\n\t    ret = RAND_load_file(\"/dev/urandom\",255);\n\t    break;\n\tcase PJ_SSL_ENTROPY_FILE:\n\t    ret = RAND_load_file(ssock->param.entropy_path.ptr,255);\n\t    break;\n\tcase PJ_SSL_ENTROPY_NONE:\n\tdefault:\n\t    break;\n    }\n\n    if (ret < 0) {\n\tPJ_LOG(3, (ssock->pool->obj_name,\n\t\t   \"SSL failed to reseed with entropy type %d \"\n\t\t   \"[native err=%d]\",\n\t\t   ssock->param.entropy_type, ret));\n    }\n}\n\n/* Parse OpenSSL ASN1_TIME to pj_time_val and GMT info */\nstatic pj_bool_t parse_ossl_asn1_time(pj_time_val *tv, pj_bool_t *gmt,\n\t\t\t\t      const ASN1_TIME *tm)\n{\n    unsigned long parts[7] = {0};\n    char *p, *end;\n    unsigned len;\n    pj_bool_t utc;\n    pj_parsed_time pt;\n    int i;\n\n    utc = tm->type == V_ASN1_UTCTIME;\n    p = (char*)tm->data;\n    len = tm->length;\n    end = p + len - 1;\n\n    /* GMT */\n    *gmt = (*end == 'Z');\n\n    /* parse parts */\n    for (i = 0; i < 7 && p < end; ++i) {\n\tpj_str_t st;\n\n\tif (i==0 && !utc) {\n\t    /* 4 digits year part for non-UTC time format */\n\t    st.slen = 4;\n\t} else if (i==6) {\n\t    /* fraction of seconds */\n\t    if (*p == '.') ++p;\n\t    st.slen = end - p + 1;\n\t} else {\n\t    /* other parts always 2 digits length */\n\t    st.slen = 2;\n\t}\n\tst.ptr = p;\n\n\tparts[i] = pj_strtoul(&st);\n\tp += st.slen;\n    }\n\n    /* encode parts to pj_time_val */\n    pt.year = parts[0];\n    if (utc)\n\tpt.year += (pt.year < 50)? 2000:1900;\n    pt.mon = parts[1] - 1;\n    pt.day = parts[2];\n    pt.hour = parts[3];\n    pt.min = parts[4];\n    pt.sec = parts[5];\n    pt.msec = parts[6];\n\n    pj_time_encode(&pt, tv);\n\n    return PJ_TRUE;\n}\n\n\n/* Get Common Name field string from a general name string */\nstatic void get_cn_from_gen_name(const pj_str_t *gen_name, pj_str_t *cn)\n{\n    pj_str_t CN_sign = {\"/CN=\", 4};\n    char *p, *q;\n\n    pj_bzero(cn, sizeof(pj_str_t));\n\n    if (!gen_name->slen)\n\treturn;\n\n    p = pj_strstr(gen_name, &CN_sign);\n    if (!p)\n\treturn;\n\n    p += 4; /* shift pointer to value part */\n    pj_strset(cn, p, gen_name->slen - (p - gen_name->ptr));\n    q = pj_strchr(cn, '/');\n    if (q)\n\tcn->slen = q - p;\n}\n\n\n/* Get certificate info from OpenSSL X509, in case the certificate info\n * hal already populated, this function will check if the contents need \n * to be updated by inspecting the issuer and the serial number.\n */\nstatic void get_cert_info(pj_pool_t *pool, pj_ssl_cert_info *ci, X509 *x,\n\t\t\t  pj_bool_t get_pem)\n{\n    pj_bool_t update_needed;\n    char buf[512];\n    pj_uint8_t serial_no[64] = {0}; /* should be >= sizeof(ci->serial_no) */\n    const pj_uint8_t *q;\n    unsigned len;\n    GENERAL_NAMES *names = NULL;\n\n    pj_assert(pool && ci && x);\n\n    /* Get issuer */\n    X509_NAME_oneline(X509_get_issuer_name(x), buf, sizeof(buf));\n\n    /* Get serial no */\n    q = (const pj_uint8_t*) M_ASN1_STRING_data(X509_get_serialNumber(x));\n    len = M_ASN1_STRING_length(X509_get_serialNumber(x));\n    if (len > sizeof(ci->serial_no)) \n\tlen = sizeof(ci->serial_no);\n    pj_memcpy(serial_no + sizeof(ci->serial_no) - len, q, len);\n\n    /* Check if the contents need to be updated. */\n    update_needed = pj_strcmp2(&ci->issuer.info, buf) || \n\t            pj_memcmp(ci->serial_no, serial_no, sizeof(ci->serial_no));\n    if (!update_needed)\n\treturn;\n\n    /* Update cert info */\n\n    pj_bzero(ci, sizeof(pj_ssl_cert_info));\n\n    /* Version */\n    ci->version = X509_get_version(x) + 1;\n\n    /* Issuer */\n    pj_strdup2(pool, &ci->issuer.info, buf);\n    get_cn_from_gen_name(&ci->issuer.info, &ci->issuer.cn);\n\n    /* Serial number */\n    pj_memcpy(ci->serial_no, serial_no, sizeof(ci->serial_no));\n\n    /* Subject */\n    pj_strdup2(pool, &ci->subject.info, \n\t       X509_NAME_oneline(X509_get_subject_name(x),\n\t\t\t\t buf, sizeof(buf)));\n    get_cn_from_gen_name(&ci->subject.info, &ci->subject.cn);\n\n    /* Validity */\n    parse_ossl_asn1_time(&ci->validity.start, &ci->validity.gmt,\n\t\t\t X509_get_notBefore(x));\n    parse_ossl_asn1_time(&ci->validity.end, &ci->validity.gmt,\n\t\t\t X509_get_notAfter(x));\n\n    /* Subject Alternative Name extension */\n    if (ci->version >= 3) {\n\tnames = (GENERAL_NAMES*) X509_get_ext_d2i(x, NID_subject_alt_name,\n\t\t\t\t\t\t  NULL, NULL);\n    }\n    if (names) {\n        unsigned i, cnt;\n\n        cnt = sk_GENERAL_NAME_num(names);\n\tci->subj_alt_name.entry = pj_pool_calloc(pool, cnt, \n\t\t\t\t\t    sizeof(*ci->subj_alt_name.entry));\n\n        for (i = 0; i < cnt; ++i) {\n\t    unsigned char *p = 0;\n\t    pj_ssl_cert_name_type type = PJ_SSL_CERT_NAME_UNKNOWN;\n            const GENERAL_NAME *name;\n\t    \n\t    name = sk_GENERAL_NAME_value(names, i);\n\n            switch (name->type) {\n                case GEN_EMAIL:\n                    len = ASN1_STRING_to_UTF8(&p, name->d.ia5);\n\t\t    type = PJ_SSL_CERT_NAME_RFC822;\n                    break;\n                case GEN_DNS:\n                    len = ASN1_STRING_to_UTF8(&p, name->d.ia5);\n\t\t    type = PJ_SSL_CERT_NAME_DNS;\n                    break;\n                case GEN_URI:\n                    len = ASN1_STRING_to_UTF8(&p, name->d.ia5);\n\t\t    type = PJ_SSL_CERT_NAME_URI;\n                    break;\n                case GEN_IPADD:\n\t\t    p = (unsigned char*)M_ASN1_STRING_data(name->d.ip);\n\t\t    len = M_ASN1_STRING_length(name->d.ip);\n\t\t    type = PJ_SSL_CERT_NAME_IP;\n                    break;\n\t\tdefault:\n\t\t    break;\n            }\n\n\t    if (p && len && type != PJ_SSL_CERT_NAME_UNKNOWN) {\n\t\tci->subj_alt_name.entry[ci->subj_alt_name.cnt].type = type;\n\t\tif (type == PJ_SSL_CERT_NAME_IP) {\n\t\t    int af = pj_AF_INET();\n\t\t    if (len == sizeof(pj_in6_addr)) af = pj_AF_INET6();\n\t\t    pj_inet_ntop2(af, p, buf, sizeof(buf));\n\t\t    pj_strdup2(pool, \n\t\t          &ci->subj_alt_name.entry[ci->subj_alt_name.cnt].name,\n\t\t          buf);\n\t\t} else {\n\t\t    pj_strdup2(pool, \n\t\t\t  &ci->subj_alt_name.entry[ci->subj_alt_name.cnt].name, \n\t\t\t  (char*)p);\n\t\t    OPENSSL_free(p);\n\t\t}\n\t\tci->subj_alt_name.cnt++;\n\t    }\n        }\n        GENERAL_NAMES_free(names);\n        names = NULL;\n    }\n\n    if (get_pem) {\n\t/* Update raw Certificate info in PEM format. */\n\tBIO *bio;\t\n\tBUF_MEM *ptr;\n\t\n\tbio = BIO_new(BIO_s_mem());\n\tif (!PEM_write_bio_X509(bio, x)) {\n\t    PJ_LOG(3,(THIS_FILE, \"Error retrieving raw certificate info\"));\n\t    ci->raw.ptr = NULL;\n\t    ci->raw.slen = 0;\n\t} else {\n\t    BIO_write(bio, \"\\0\", 1);\n\t    BIO_get_mem_ptr(bio, &ptr);\n\t    pj_strdup2(pool, &ci->raw, ptr->data);\t\n\t}\t\n\tBIO_free(bio);\t    \n    }\t \n}\n\n/* Update remote certificates chain info. This function should be\n * called after handshake or renegotiation successfully completed.\n */\nstatic void ssl_update_remote_cert_chain_info(pj_pool_t *pool,\n\t\t\t\t\t      pj_ssl_cert_info *ci,\n\t\t\t\t\t      STACK_OF(X509) *chain,\n\t\t\t\t\t      pj_bool_t get_pem)\n{\n    int i;\n\n    /* For now, get_pem has to be PJ_TRUE */\n    pj_assert(get_pem);\n    PJ_UNUSED_ARG(get_pem);\n\n    ci->raw_chain.cert_raw = (pj_str_t *)pj_pool_calloc(pool,\n       \t\t\t\t    \t\t\tsk_X509_num(chain),\n       \t\t\t\t    \t\t\tsizeof(pj_str_t));\n    ci->raw_chain.cnt = sk_X509_num(chain);\n\n    for (i = 0; i < sk_X509_num(chain); i++) {\n        BIO *bio;\n        BUF_MEM *ptr;\n\tX509 *x = sk_X509_value(chain, i);\n\n        bio = BIO_new(BIO_s_mem());\n        \n        if (!PEM_write_bio_X509(bio, x)) {\n            PJ_LOG(3, (THIS_FILE, \"Error retrieving raw certificate info\"));\n            ci->raw_chain.cert_raw[i].ptr  = NULL;\n            ci->raw_chain.cert_raw[i].slen = 0;\n        } else {\n            BIO_write(bio, \"\\0\", 1);\n            BIO_get_mem_ptr(bio, &ptr);\n            pj_strdup2(pool, &ci->raw_chain.cert_raw[i], ptr->data );\n        }\n        \n        BIO_free(bio);\n    }\n}\n\n/* Update local & remote certificates info. This function should be\n * called after handshake or renegotiation successfully completed.\n */\nstatic void ssl_update_certs_info(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    X509 *x;\n    STACK_OF(X509) *chain;\n\n    pj_assert(ssock->ssl_state == SSL_STATE_ESTABLISHED);\n\n    /* Active local certificate */\n    x = SSL_get_certificate(ossock->ossl_ssl);\n    if (x) {\n\tget_cert_info(ssock->pool, &ssock->local_cert_info, x, PJ_FALSE);\n\t/* Don't free local's X509! */\n    } else {\n\tpj_bzero(&ssock->local_cert_info, sizeof(pj_ssl_cert_info));\n    }\n\n    /* Active remote certificate */\n    x = SSL_get_peer_certificate(ossock->ossl_ssl);\n    if (x) {\n\tget_cert_info(ssock->pool, &ssock->remote_cert_info, x, PJ_TRUE);\n\t/* Free peer's X509 */\n\tX509_free(x);\n    } else {\n\tpj_bzero(&ssock->remote_cert_info, sizeof(pj_ssl_cert_info));\n    }\n\n    chain = SSL_get_peer_cert_chain(ossock->ossl_ssl);\n    if (chain) {\n\tpj_pool_reset(ssock->info_pool);\n\tssl_update_remote_cert_chain_info(ssock->info_pool,\n       \t\t\t\t\t  &ssock->remote_cert_info,\n       \t\t\t\t\t  chain, PJ_TRUE);\n    } else {\n\tssock->remote_cert_info.raw_chain.cnt = 0;\n    }\n}\n\n\n/* Flush write BIO to network socket. Note that any access to write BIO\n * MUST be serialized, so mutex protection must cover any call to OpenSSL\n * API (that possibly generate data for write BIO) along with the call to\n * this function (flushing all data in write BIO generated by above \n * OpenSSL API call).\n */\nstatic pj_status_t flush_circ_buf_output(pj_ssl_sock_t *ssock,\n                                         pj_ioqueue_op_key_t *send_key,\n                                         pj_size_t orig_len, unsigned flags);\n\n\nstatic void ssl_set_state(pj_ssl_sock_t *ssock, pj_bool_t is_server)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    if (is_server) {\n        SSL_set_accept_state(ossock->ossl_ssl);\n    } else {\n\tSSL_set_connect_state(ossock->ossl_ssl);\n    }\n}\n\n\nstatic void ssl_set_peer_name(pj_ssl_sock_t *ssock)\n{\n#ifdef SSL_set_tlsext_host_name\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    /* Set server name to connect */\n    if (ssock->param.server_name.slen &&\n        get_ip_addr_ver(&ssock->param.server_name) == 0)\n    {\n\t/* Server name is null terminated already */\n\tif (!SSL_set_tlsext_host_name(ossock->ossl_ssl, \n\t\t\t\t      ssock->param.server_name.ptr))\n\t{\n\t    char err_str[PJ_ERR_MSG_SIZE];\n\n\t    ERR_error_string_n(ERR_get_error(), err_str, sizeof(err_str));\n\t    PJ_LOG(3,(ssock->pool->obj_name, \"SSL_set_tlsext_host_name() \"\n\t\t\"failed: %s\", err_str));\n\t}\n    }\n#endif\n}\n\n\n/* Asynchronouse handshake */\nstatic pj_status_t ssl_do_handshake(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_status_t status;\n    int err;\n\n    /* Perform SSL handshake */\n    pj_lock_acquire(ssock->write_mutex);\n    err = SSL_do_handshake(ossock->ossl_ssl);\n    pj_lock_release(ssock->write_mutex);\n\n    /* SSL_do_handshake() may put some pending data into SSL write BIO, \n     * flush it if any.\n     */\n    status = flush_circ_buf_output(ssock, &ssock->handshake_op_key, 0, 0);\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\treturn status;\n    }\n\n    if (err < 0) {\n\tint err2 = SSL_get_error(ossock->ossl_ssl, err);\n\tif (err2 != SSL_ERROR_NONE && err2 != SSL_ERROR_WANT_READ)\n\t{\n\t    /* Handshake fails */\n\t    status = STATUS_FROM_SSL_ERR2(\"Handshake\", ssock, err, err2, 0);\n\t    return status;\n\t}\n    }\n\n    /* Check if handshake has been completed */\n    if (SSL_is_init_finished(ossock->ossl_ssl)) {\n\tssock->ssl_state = SSL_STATE_ESTABLISHED;\n\treturn PJ_SUCCESS;\n    }\n\n    return PJ_EPENDING;\n}\n\n\nstatic pj_status_t ssl_read(pj_ssl_sock_t *ssock, void *data, int *size)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    int size_ = *size;\n    int len = size_;\n\n    /* SSL_read() may write some data to write buffer when re-negotiation\n     * is on progress, so let's protect it with write mutex.\n     */\n    pj_lock_acquire(ssock->write_mutex);\n    *size = size_ = SSL_read(ossock->ossl_ssl, data, size_);\n    pj_lock_release(ssock->write_mutex);\n\n    if (size_ <= 0) {\n\tpj_status_t status;\n\tint err = SSL_get_error(ossock->ossl_ssl, size_);\n\n\t/* SSL might just return SSL_ERROR_WANT_READ in \n\t * re-negotiation.\n\t */\n\tif (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ) {\n\t    if (err == SSL_ERROR_SYSCALL && size_ == -1 &&\n\t\tERR_peek_error() == 0 && errno == 0)\n\t    {\n\t\tstatus = STATUS_FROM_SSL_ERR2(\"Read\", ssock, size_,\n\t\t\t\t\t      err, len);\n\t\tPJ_LOG(4,(\"SSL\", \"SSL_read() = -1, with \"\n\t\t\t\t \"SSL_ERROR_SYSCALL, no SSL error, \"\n\t\t\t\t \"and errno = 0 - skip BIO error\"));\n\t\t/* Ignore these errors */\n\t    } else {\n\t\t/* Reset SSL socket state, then return PJ_FALSE */\n\t\tstatus = STATUS_FROM_SSL_ERR2(\"Read\", ssock, size_,\n\t\t        \t\t      err, len);\n\t\tssl_reset_sock_state(ssock);\n\t\treturn status;\n\t    }\n\t}\n\t\n\t/* Need renegotiation */\n\treturn PJ_EEOF;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Write plain data to SSL and flush write BIO. */\nstatic pj_status_t ssl_write(pj_ssl_sock_t *ssock, const void *data,\n\t\t\t     pj_ssize_t size, int *nwritten)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_status_t status = PJ_SUCCESS;\n\n    *nwritten = SSL_write(ossock->ossl_ssl, data, (int)size);\n    if (*nwritten <= 0) {\n\t/* SSL failed to process the data, it may just that re-negotiation\n\t * is on progress.\n\t */\n\tint err;\n\terr = SSL_get_error(ossock->ossl_ssl, *nwritten);\n\tif (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_NONE) {\n\t    status = PJ_EEOF;\n\t} else {\n\t    /* Some problem occured */\n\t    status = STATUS_FROM_SSL_ERR2(\"Write\", ssock, *nwritten,\n\t    \t\t\t\t  err, size);\n\t}\n    } else if (*nwritten < size) {\n\t/* nwritten < size, shouldn't happen, unless write BIO cannot hold \n\t * the whole secured data, perhaps because of insufficient memory.\n\t */\n\tstatus = PJ_ENOMEM;\n    }\n\n    return status;\n}\n\n\nstatic pj_status_t ssl_renegotiate(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    pj_status_t status = PJ_SUCCESS;\n    int ret;\n\n    if (SSL_renegotiate_pending(ossock->ossl_ssl))\n\treturn PJ_EPENDING;\n\n    ret = SSL_renegotiate(ossock->ossl_ssl);\n    if (ret <= 0) {\n\tstatus = GET_SSL_STATUS(ssock);\n    }\n    \n    return status;\n}\n\n\n/* Put back deprecation warning setting */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic pop\n#endif\n\n\n#endif  /* PJ_HAS_SSL_SOCK */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2009-2011 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjsip/sip_transport_tls.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pj/compat/socket.h>\n#include <pj/addr_resolv.h>\n#include <pj/ssl_sock.h>\n#include <pj/assert.h>\n#include <pj/hash.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0\n\n#define THIS_FILE\t\"sip_transport_tls.c\"\n\n#define MAX_ASYNC_CNT\t16\n#define POOL_LIS_INIT\t512\n#define POOL_LIS_INC\t512\n#define POOL_TP_INIT\t512\n#define POOL_TP_INC\t512\n\nstruct tls_listener;\nstruct tls_transport;\n\n/*\n * Definition of TLS/SSL transport listener, and it's descendant of\n * pjsip_tpfactory.\n */\nstruct tls_listener\n{\n    pjsip_tpfactory\t     factory;\n    pj_bool_t\t\t     is_registered;\n    pjsip_endpoint\t    *endpt;\n    pjsip_tpmgr\t\t    *tpmgr;\n    pj_ssl_sock_t\t    *ssock;\n    pj_sockaddr\t\t     bound_addr;\n    pj_ssl_cert_t\t    *cert;\n    pjsip_tls_setting\t     tls_setting;    \n    unsigned\t\t     async_cnt;    \n\n    /* Group lock to be used by TLS transport and ioqueue key */\n    pj_grp_lock_t\t    *grp_lock;\n};\n\n\n/*\n * This structure is used to keep delayed transmit operation in a list.\n * A delayed transmission occurs when application sends tx_data when\n * the TLS connect/establishment is still in progress. These delayed\n * transmission will be \"flushed\" once the socket is connected (either\n * successfully or with errors).\n */\nstruct delayed_tdata\n{\n    PJ_DECL_LIST_MEMBER(struct delayed_tdata);\n    pjsip_tx_data_op_key    *tdata_op_key;\n    pj_time_val              timeout;\n};\n\n\n/*\n * TLS/SSL transport, and it's descendant of pjsip_transport.\n */\nstruct tls_transport\n{\n    pjsip_transport\t     base;\n    pj_bool_t\t\t     is_server;\n    pj_str_t\t\t     remote_name;\n\n    pj_bool_t\t\t     is_registered;\n    pj_bool_t\t\t     is_closing;\n    pj_status_t\t\t     close_reason;\n    pj_ssl_sock_t\t    *ssock;\n    pj_bool_t\t\t     has_pending_connect;\n    pj_bool_t\t\t     verify_server;\n\n    /* Keep-alive timer. */\n    pj_timer_entry\t     ka_timer;\n    pj_time_val\t\t     last_activity;\n    pjsip_tx_data_op_key     ka_op_key;\n    pj_str_t\t\t     ka_pkt;\n\n    /* TLS transport can only have  one rdata!\n     * Otherwise chunks of incoming PDU may be received on different\n     * buffer.\n     */\n    pjsip_rx_data\t     rdata;\n\n    /* Pending transmission list. */\n    struct delayed_tdata     delayed_list;\n\n    /* Group lock to be used by TLS transport and ioqueue key */\n    pj_grp_lock_t\t    *grp_lock;\n};\n\n\n/****************************************************************************\n * PROTOTYPES\n */\n\n/* This callback is called when pending accept() operation completes. */\nstatic pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n\t\t\t\t    pj_ssl_sock_t *new_ssock,\n\t\t\t\t    const pj_sockaddr_t *src_addr,\n\t\t\t\t    int src_addr_len,\n\t\t\t\t    pj_status_t status);\n\n/* Callback on incoming data */\nstatic pj_bool_t on_data_read(pj_ssl_sock_t *ssock,\n\t\t\t      void *data,\n\t\t\t      pj_size_t size,\n\t\t\t      pj_status_t status,\n\t\t\t      pj_size_t *remainder);\n\n/* Callback when packet is sent */\nstatic pj_bool_t on_data_sent(pj_ssl_sock_t *ssock,\n\t\t\t      pj_ioqueue_op_key_t *send_key,\n\t\t\t      pj_ssize_t sent);\n\n/* This callback is called by transport manager to destroy listener */\nstatic pj_status_t lis_destroy(pjsip_tpfactory *factory);\n\n/* Clean up listener resources (group lock handler) */\nstatic void lis_on_destroy(void *arg);\n\n/* This callback is called by transport manager to create transport */\nstatic pj_status_t lis_create_transport(pjsip_tpfactory *factory,\n\t\t\t\t\tpjsip_tpmgr *mgr,\n\t\t\t\t\tpjsip_endpoint *endpt,\n\t\t\t\t\tconst pj_sockaddr *rem_addr,\n\t\t\t\t\tint addr_len,\n\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\tpjsip_transport **transport);\n\n/* Common function to create and initialize transport */\nstatic pj_status_t tls_create(struct tls_listener *listener,\n\t\t\t      pj_pool_t *pool,\n\t\t\t      pj_ssl_sock_t *ssock, \n\t\t\t      pj_bool_t is_server,\n\t\t\t      const pj_sockaddr *local,\n\t\t\t      const pj_sockaddr *remote,\n\t\t\t      const pj_str_t *remote_name,\n\t\t\t      pj_grp_lock_t *glock,\n\t\t\t      struct tls_transport **p_tls);\n\n\n/* Clean up TLS resources */\nstatic void tls_on_destroy(void *arg);\n\nstatic void wipe_buf(pj_str_t *buf);\n\n\nstatic void tls_perror(const char *sender, const char *title,\n\t\t       pj_status_t status, pj_str_t *remote_name)\n{\n    PJ_PERROR(3,(sender, status, \"%s: [code=%d]%s%.*s\", title, status,\n        remote_name ? \" peer: \" : \"\", remote_name ? remote_name->slen : 0,\n\tremote_name ? remote_name->ptr : \"\"));\n}\n\n\nstatic void sockaddr_to_host_port( pj_pool_t *pool,\n\t\t\t\t   pjsip_host_port *host_port,\n\t\t\t\t   const pj_sockaddr *addr )\n{\n    host_port->host.ptr = (char*) pj_pool_alloc(pool, PJ_INET6_ADDRSTRLEN+4);\n    pj_sockaddr_print(addr, host_port->host.ptr, PJ_INET6_ADDRSTRLEN+4, 0);\n    host_port->host.slen = pj_ansi_strlen(host_port->host.ptr);\n    host_port->port = pj_sockaddr_get_port(addr);\n}\n\n\nstatic pj_uint32_t ssl_get_proto(pjsip_ssl_method ssl_method, pj_uint32_t proto)\n{\n    pj_uint32_t out_proto;\n\n    if (proto)\n\treturn proto;\n\n    if (ssl_method == PJSIP_SSL_UNSPECIFIED_METHOD)\n\tssl_method = PJSIP_SSL_DEFAULT_METHOD;\n\n    switch(ssl_method) {\n    case PJSIP_SSLV2_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_SSL2;\n\tbreak;\n    case PJSIP_SSLV3_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_SSL3;\n\tbreak;\n    case PJSIP_TLSV1_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1;\n\tbreak;\n    case PJSIP_TLSV1_1_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1_1;\n\tbreak;\n    case PJSIP_TLSV1_2_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1_2;\n\tbreak;\n    case PJSIP_TLSV1_3_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_TLS1_3;\n\tbreak;\n    case PJSIP_SSLV23_METHOD:\n\tout_proto = PJ_SSL_SOCK_PROTO_SSL23;\n\tbreak;\n    default:\n\tout_proto = PJ_SSL_SOCK_PROTO_DEFAULT;\n\tbreak;\n    }   \n    return out_proto;\n}\n\n\nstatic void tls_init_shutdown(struct tls_transport *tls, pj_status_t status)\n{\n    pjsip_tp_state_callback state_cb;\n\n    if (tls->close_reason == PJ_SUCCESS)\n\ttls->close_reason = status;\n\n    if (tls->base.is_shutdown || tls->base.is_destroying)\n\treturn;\n\n    /* Prevent immediate transport destroy by application, as transport\n     * state notification callback may be stacked and transport instance\n     * must remain valid at any point in the callback.\n     */\n    pjsip_transport_add_ref(&tls->base);\n\n    /* Notify application of transport disconnected state */\n    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpj_ssl_sock_info ssl_info;\n\t\n\t/* Init transport state info */\n\tpj_bzero(&state_info, sizeof(state_info));\n\tstate_info.status = tls->close_reason;\n\n\tif (tls->ssock && \n\t    pj_ssl_sock_get_info(tls->ssock, &ssl_info) == PJ_SUCCESS)\n\t{\n\t    pj_bzero(&tls_info, sizeof(tls_info));\n\t    tls_info.ssl_sock_info = &ssl_info;\n\t    state_info.ext_info = &tls_info;\n\t}\n\n\t(*state_cb)(&tls->base, PJSIP_TP_STATE_DISCONNECTED, &state_info);\n    }\n\n    /* check again */\n    if (tls->base.is_shutdown || tls->base.is_destroying) {\n        pjsip_transport_dec_ref(&tls->base);\n\treturn;\n    }\n\n    /* We can not destroy the transport since high level objects may\n     * still keep reference to this transport. So we can only \n     * instruct transport manager to gracefully start the shutdown\n     * procedure for this transport.\n     */\n    pjsip_transport_shutdown(&tls->base);\n\n    /* Now, it is ok to destroy the transport. */\n    pjsip_transport_dec_ref(&tls->base);\n}\n\n\n/****************************************************************************\n * The TLS listener/transport factory.\n */\n\n\nstatic void set_ssock_param(pj_ssl_sock_param *ssock_param,\n    struct tls_listener *listener)\n{\n    int af, sip_ssl_method;\n    pj_uint32_t sip_ssl_proto;\n\n    /* Build SSL socket param */\n    af = pjsip_transport_type_get_af(listener->factory.type);\n    pj_ssl_sock_param_default(ssock_param);\n    ssock_param->sock_af = af;\n    ssock_param->cb.on_accept_complete2 = &on_accept_complete2;\n    ssock_param->async_cnt = listener->async_cnt;\n    ssock_param->ioqueue = pjsip_endpt_get_ioqueue(listener->endpt);\n    ssock_param->timer_heap = pjsip_endpt_get_timer_heap(listener->endpt);\n    ssock_param->require_client_cert = listener->tls_setting.require_client_cert;\n    ssock_param->timeout = listener->tls_setting.timeout;\n    ssock_param->user_data = listener;\n    ssock_param->verify_peer = PJ_FALSE; /* avoid SSL socket closing the socket\n\t\t\t\t\t  * due to verification error */\n    if (ssock_param->send_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param->send_buffer_size = PJSIP_MAX_PKT_LEN;\n    if (ssock_param->read_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param->read_buffer_size = PJSIP_MAX_PKT_LEN;\n    ssock_param->ciphers_num = listener->tls_setting.ciphers_num;\n    ssock_param->ciphers = listener->tls_setting.ciphers;\n    ssock_param->curves_num = listener->tls_setting.curves_num;\n    ssock_param->curves = listener->tls_setting.curves;\n    ssock_param->sigalgs = listener->tls_setting.sigalgs;\n    ssock_param->entropy_type = listener->tls_setting.entropy_type;\n    ssock_param->entropy_path = listener->tls_setting.entropy_path;\n    ssock_param->reuse_addr = listener->tls_setting.reuse_addr;\n    ssock_param->qos_type = listener->tls_setting.qos_type;\n    ssock_param->qos_ignore_error = listener->tls_setting.qos_ignore_error;\n    pj_memcpy(&ssock_param->qos_params, &listener->tls_setting.qos_params,\n\t      sizeof(ssock_param->qos_params));\n\n    ssock_param->sockopt_ignore_error =\n\t\t\t\t    listener->tls_setting.sockopt_ignore_error;\n    /* Copy the sockopt */\n    pj_memcpy(&ssock_param->sockopt_params,\n\t      &listener->tls_setting.sockopt_params,\n\t      sizeof(listener->tls_setting.sockopt_params));\n\n    sip_ssl_method = listener->tls_setting.method;\n    sip_ssl_proto = listener->tls_setting.proto;\n    ssock_param->proto = ssl_get_proto(sip_ssl_method, sip_ssl_proto);\n}\n\nstatic void update_bound_addr(struct tls_listener *listener,\n\t\t\t      const pj_sockaddr *local)\n{\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n    int af = pjsip_transport_type_get_af(listener->factory.type);\n\n    /* Bind address may be different than factory.local_addr because\n     * factory.local_addr will be resolved.\n     */\n    if (local) {\n\tpj_sockaddr_cp(&listener->bound_addr, local);\n    } else {\n\tpj_sockaddr_init(af, &listener->bound_addr, NULL, 0);\n    }\n    pj_sockaddr_cp(listener_addr, &listener->bound_addr);    \n}\n\nstatic pj_status_t update_factory_addr(struct tls_listener *listener,\n\t\t\t\t       const pjsip_host_port *addr_name)\n{\n    pj_status_t status = PJ_SUCCESS;\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n\n    if (addr_name && addr_name->host.slen) {\n\tpj_sockaddr tmp;\n\tint af = pjsip_transport_type_get_af(listener->factory.type);\n\n\tstatus = pj_sockaddr_init(af, &tmp, &addr_name->host,\n\t\t\t\t  (pj_uint16_t)addr_name->port);\n\tif (status != PJ_SUCCESS || !pj_sockaddr_has_addr(&tmp) ||\n\t    (af == pj_AF_INET() && tmp.ipv4.sin_addr.s_addr == PJ_INADDR_NONE))\n\t{\n\t    /* Invalid address */\n\t    return PJ_EINVAL;\n\t}\n\n\t/* Copy the address */\n\tlistener->factory.addr_name = *addr_name;\n\tpj_strdup(listener->factory.pool, &listener->factory.addr_name.host,\n\t\t  &addr_name->host);\n\tlistener->factory.addr_name.port = addr_name->port;\n\n    }\n    else {\n\t/* No published address is given, use the bound address */\n\n\t/* If the address returns 0.0.0.0, use the default\n\t* interface address as the transport's address.\n\t*/\n\tif (!pj_sockaddr_has_addr(listener_addr)) {\n\t    pj_sockaddr hostip;\n\n\t    status = pj_gethostip(listener->bound_addr.addr.sa_family,\n\t\t\t\t  &hostip);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    pj_sockaddr_copy_addr(listener_addr, &hostip);\n\t}\n\n\t/* Save the address name */\n\tsockaddr_to_host_port(listener->factory.pool,\n\t\t\t      &listener->factory.addr_name, listener_addr);\n    }\n\n    /* If port is zero, get the bound port */\n    if (listener->factory.addr_name.port == 0) {\n\tlistener->factory.addr_name.port = pj_sockaddr_get_port(listener_addr);\n    }\n\n    pj_ansi_snprintf(listener->factory.obj_name,\n\t\t     sizeof(listener->factory.obj_name),\n\t\t     \"tlstp:%d\", listener->factory.addr_name.port);\n    return status;\n}\n\nstatic void update_transport_info(struct tls_listener *listener)\n{\n    enum { INFO_LEN = 100 };\n    char local_addr[PJ_INET6_ADDRSTRLEN + 10];\n    char pub_addr[PJ_INET6_ADDRSTRLEN + 10];\n    int len;\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n\n    if (listener->factory.info == NULL) {\n\tlistener->factory.info = (char*)pj_pool_alloc(listener->factory.pool,\n\t\t\t\t\t\t      INFO_LEN);\n    }\n    pj_sockaddr_print(listener_addr, local_addr, sizeof(local_addr), 3);\n    pj_addr_str_print(&listener->factory.addr_name.host, \n\t\t      listener->factory.addr_name.port, pub_addr, \n\t\t      sizeof(pub_addr), 1);\n    len = pj_ansi_snprintf(\n\t    listener->factory.info, INFO_LEN, \"tls %s [published as %s]\",\n\t    local_addr, pub_addr);\n    PJ_CHECK_TRUNC_STR(len, listener->factory.info, INFO_LEN);\n\n    if (listener->ssock) {\n\tchar addr[PJ_INET6_ADDRSTRLEN+10];\n\n\tPJ_LOG(4, (listener->factory.obj_name,\n\t       \"SIP TLS listener is ready for incoming connections at %s\",\n\t       pj_addr_str_print(&listener->factory.addr_name.host,\n\t\t\t         listener->factory.addr_name.port, addr,\n\t\t\t\t sizeof(addr), 1)));\n    } else {\n\tPJ_LOG(4, (listener->factory.obj_name, \"SIP TLS is ready \"\n\t       \"(client only)\"));\n    }\n}\n\n\n/*\n * This is the public API to create, initialize, register, and start the\n * TLS listener.\n */\nPJ_DEF(pj_status_t) pjsip_tls_transport_start(pjsip_endpoint *endpt,\n    const pjsip_tls_setting *opt,\n    const pj_sockaddr_in *local_in,\n    const pjsip_host_port *a_name,\n    unsigned async_cnt,\n    pjsip_tpfactory **p_factory)\n{\n    pj_sockaddr local;\n\n    if (local_in)\n\tpj_sockaddr_cp(&local, local_in);\n\n    return pjsip_tls_transport_start2(endpt, opt, (local_in ? &local : NULL),\n\t\t\t\t      a_name, async_cnt, p_factory);\n}\n\n\nPJ_DEF(pj_status_t) pjsip_tls_transport_lis_start(pjsip_tpfactory *factory,\n\t\t\t\t\t\tconst pj_sockaddr *local,\n\t\t\t\t\t\tconst pjsip_host_port *a_name)\n{\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssl_sock_param ssock_param, newsock_param;\n    struct tls_listener *listener = (struct tls_listener *)factory;\n    pj_sockaddr *listener_addr = &listener->factory.local_addr;\n\n    if (listener->ssock)\n\treturn PJ_SUCCESS;\n\n    set_ssock_param(&ssock_param, listener);\n    update_bound_addr(listener, local);\n    ssock_param.grp_lock = listener->grp_lock;\n\n    /* Create SSL socket */\n    status = pj_ssl_sock_create(listener->factory.pool, &ssock_param, \n\t\t\t\t&listener->ssock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    if (listener->cert) {\n\tstatus = pj_ssl_sock_set_certificate(listener->ssock, \n\t\t\t\t       listener->factory.pool, listener->cert);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Start accepting incoming connections. Note that some TLS/SSL\n     * backends may not support for SSL socket server.\n     */    \n    pj_memcpy(&newsock_param, &ssock_param, sizeof(newsock_param));\n    newsock_param.async_cnt = 1;\n    newsock_param.cb.on_data_read = &on_data_read;\n    newsock_param.cb.on_data_sent = &on_data_sent;\n    status = pj_ssl_sock_start_accept2(listener->ssock, listener->factory.pool,\n\t\t\t    (pj_sockaddr_t*)listener_addr,\n\t\t\t    pj_sockaddr_get_len((pj_sockaddr_t*)listener_addr),\n\t\t\t    &newsock_param);\n\n    if (status == PJ_SUCCESS || status == PJ_EPENDING) {\n\tpj_ssl_sock_info info;\t\n\n\t/* Retrieve the bound address */\n\tstatus = pj_ssl_sock_get_info(listener->ssock, &info);\n\tif (status == PJ_SUCCESS)\n\t    pj_sockaddr_cp(listener_addr, (pj_sockaddr_t*)&info.local_addr);\n\n    }\n    status = update_factory_addr(listener, a_name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    update_transport_info(listener);\n\n    return status;    \n}\n\n\nPJ_DEF(pj_status_t) pjsip_tls_transport_start2( pjsip_endpoint *endpt,\n \t\t\t\t\t        const pjsip_tls_setting *opt,\n\t\t\t\t\t        const pj_sockaddr *local,\n\t\t\t\t\t        const pjsip_host_port *a_name,\n\t\t\t\t\t        unsigned async_cnt,\n\t\t\t\t\t        pjsip_tpfactory **p_factory)\n{        \n    pj_pool_t *pool;\n    pj_bool_t is_ipv6;    \n    struct tls_listener *listener;    \n    pj_status_t status;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && async_cnt, PJ_EINVAL);\n\n    is_ipv6 = (local && local->addr.sa_family == pj_AF_INET6());    \n\n    pool = pjsip_endpt_create_pool(endpt, \"tlstp\", POOL_LIS_INIT, \n\t\t\t\t   POOL_LIS_INC);\n    PJ_ASSERT_RETURN(pool, PJ_ENOMEM);\n\n    listener = PJ_POOL_ZALLOC_T(pool, struct tls_listener);\n    listener->factory.pool = pool;\n    if (is_ipv6)\n\tlistener->factory.type = PJSIP_TRANSPORT_TLS6;\n    else\n\tlistener->factory.type = PJSIP_TRANSPORT_TLS;\n    listener->factory.type_name = (char*)\n\t\tpjsip_transport_get_type_name(listener->factory.type);\n    listener->factory.flag = \n\t\tpjsip_transport_get_flag_from_type(listener->factory.type);\n    listener->endpt = endpt;\n\n    pj_ansi_strcpy(listener->factory.obj_name, \"tlstp\");\n    if (is_ipv6)\n\tpj_ansi_strcat(listener->factory.obj_name, \"6\");\n\n    if (opt)\n\tpjsip_tls_setting_copy(pool, &listener->tls_setting, opt);\n    else\n\tpjsip_tls_setting_default(&listener->tls_setting);\n\n    status = pj_lock_create_recursive_mutex(pool, listener->factory.obj_name,\n\t\t\t\t\t    &listener->factory.lock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    if (async_cnt > MAX_ASYNC_CNT) \n\tasync_cnt = MAX_ASYNC_CNT;\n\n    listener->async_cnt = async_cnt;    \n\n    /* Create group lock */\n    status = pj_grp_lock_create(pool, NULL, &listener->grp_lock);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Setup group lock handler */\n    pj_grp_lock_add_ref(listener->grp_lock);\n    pj_grp_lock_add_handler(listener->grp_lock, pool, listener,\n\t\t\t    &lis_on_destroy);\n\n    /* Check if certificate/CA list for SSL socket is set */\n    if (listener->tls_setting.cert_file.slen ||\n\tlistener->tls_setting.ca_list_file.slen ||\n\tlistener->tls_setting.ca_list_path.slen || \n\tlistener->tls_setting.privkey_file.slen) \n    {\n\tstatus = pj_ssl_cert_load_from_files2(pool,\n\t\t\t&listener->tls_setting.ca_list_file,\n\t\t\t&listener->tls_setting.ca_list_path,\n\t\t\t&listener->tls_setting.cert_file,\n\t\t\t&listener->tls_setting.privkey_file,\n\t\t\t&listener->tls_setting.password,\n\t\t\t&listener->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n    } else if (listener->tls_setting.ca_buf.slen ||\n\t       listener->tls_setting.cert_buf.slen||\n\t       listener->tls_setting.privkey_buf.slen)\n    {\n\tstatus = pj_ssl_cert_load_from_buffer(pool,\n\t\t\t&listener->tls_setting.ca_buf,\n\t\t\t&listener->tls_setting.cert_buf,\n\t\t\t&listener->tls_setting.privkey_buf,\n\t\t\t&listener->tls_setting.password,\n\t\t\t&listener->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;    \n    }\n\n    /* Register to transport manager */\n    listener->endpt = endpt;\n    listener->tpmgr = pjsip_endpt_get_tpmgr(endpt);\n    listener->factory.create_transport2 = lis_create_transport;\n    listener->factory.destroy = lis_destroy;\n\n#if !(defined(PJSIP_TLS_TRANSPORT_DONT_CREATE_LISTENER) && \\\n    PJSIP_TLS_TRANSPORT_DONT_CREATE_LISTENER != 0)\n    /* Start listener. */\n    status = pjsip_tls_transport_lis_start(&listener->factory, local, a_name);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#else\n    update_bound_addr(listener, local);\n    /* If published host/IP is specified, then use that address as the\n     * listener advertised address.\n     */\n    status = update_factory_addr(listener, a_name);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Set transport info. */\n    update_transport_info(listener);\n#endif\n\n    listener->is_registered = PJ_TRUE;\n    status = pjsip_tpmgr_register_tpfactory(listener->tpmgr,\n\t\t\t\t\t    &listener->factory);\n    if (status != PJ_SUCCESS) {\n\tlistener->is_registered = PJ_FALSE;\n\tgoto on_error;\n    }\n\n    /* Return the pointer to user */\n    if (p_factory) *p_factory = &listener->factory;\n\n    return PJ_SUCCESS;\n\non_error:\n    lis_destroy(&listener->factory);\n    return status;\n}\n\n\n/* Clean up listener resources */\nstatic void lis_on_destroy(void *arg)\n{\n    struct tls_listener *listener = (struct tls_listener*)arg;\n\n    if (listener->cert) {\n\tpj_ssl_cert_wipe_keys(listener->cert);\n\tlistener->cert = NULL;\n    }\n\n    if (listener->factory.lock) {\n\tpj_lock_destroy(listener->factory.lock);\n\tlistener->factory.lock = NULL;\n    }\n\n    if (listener->factory.pool) {\n\tPJ_LOG(4,(listener->factory.obj_name,  \"SIP TLS transport destroyed\"));\n\tpj_pool_secure_release(&listener->factory.pool);\n    }\n}\n\n\nstatic void lis_close(struct tls_listener *listener)\n{\n    if (listener->is_registered) {\n\tpjsip_tpmgr_unregister_tpfactory(listener->tpmgr, &listener->factory);\n\tlistener->is_registered = PJ_FALSE;\n    }\n\n    if (listener->ssock) {\n\tpj_ssl_sock_close(listener->ssock);\n\tlistener->ssock = NULL;\n    }\n}\n\n\n/* This callback is called by transport manager to destroy listener */\nstatic pj_status_t lis_destroy(pjsip_tpfactory *factory)\n{\n    struct tls_listener *listener = (struct tls_listener *)factory;\n\n    lis_close(listener);\n\n    if (listener->grp_lock) {\n\tpj_grp_lock_t *grp_lock = listener->grp_lock;\n\tlistener->grp_lock = NULL;\n\tpj_grp_lock_dec_ref(grp_lock);\n\t/* Listener may have been deleted at this point */\n    } else {\n\tlis_on_destroy(listener);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjsip_tls_transport_restart(pjsip_tpfactory *factory,\n\t\t\t\t\t\tconst pj_sockaddr *local,\n\t\t\t\t\t\tconst pjsip_host_port *a_name)\n{\n    pj_status_t status = PJ_SUCCESS;\n    struct tls_listener *listener = (struct tls_listener *)factory;\n\n    lis_close(listener);\n\n    status = pjsip_tls_transport_lis_start(factory, local, a_name);\n    if (status != PJ_SUCCESS) {\t\n\ttls_perror(listener->factory.obj_name, \n\t\t   \"Unable to start listener after closing it\", status, NULL);\n\n\treturn status;\n    }\n    \n    status = pjsip_tpmgr_register_tpfactory(listener->tpmgr,\n\t\t\t\t\t    &listener->factory);\n    if (status != PJ_SUCCESS) {\n\ttls_perror(listener->factory.obj_name,\n\t\t    \"Unable to register the transport listener\", status, NULL);\n\n\tlistener->is_registered = PJ_FALSE;\t\n    } else {\n\tlistener->is_registered = PJ_TRUE;\t\n    }    \n\n    return status;\n}\n\n\n/***************************************************************************/\n/*\n * TLS Transport\n */\n\n/*\n * Prototypes.\n */\n/* Called by transport manager to send message */\nstatic pj_status_t tls_send_msg(pjsip_transport *transport, \n\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\tconst pj_sockaddr_t *rem_addr,\n\t\t\t\tint addr_len,\n\t\t\t\tvoid *token,\n\t\t\t\tpjsip_transport_callback callback);\n\n/* Called by transport manager to shutdown */\nstatic pj_status_t tls_shutdown(pjsip_transport *transport);\n\n/* Called by transport manager to destroy transport */\nstatic pj_status_t tls_destroy_transport(pjsip_transport *transport);\n\n/* Utility to destroy transport */\nstatic pj_status_t tls_destroy(pjsip_transport *transport,\n\t\t\t       pj_status_t reason);\n\n/* Callback when connect completes */\nstatic pj_bool_t on_connect_complete(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_status_t status);\n\n/* TLS keep-alive timer callback */\nstatic void tls_keep_alive_timer(pj_timer_heap_t *th, pj_timer_entry *e);\n\n/*\n * Common function to create TLS transport, called when pending accept() and\n * pending connect() complete.\n */\nstatic pj_status_t tls_create( struct tls_listener *listener,\n\t\t\t       pj_pool_t *pool,\n\t\t\t       pj_ssl_sock_t *ssock,\n\t\t\t       pj_bool_t is_server,\n\t\t\t       const pj_sockaddr *local,\n\t\t\t       const pj_sockaddr *remote,\n\t\t\t       const pj_str_t *remote_name,\n\t\t\t       pj_grp_lock_t *glock,\n\t\t\t       struct tls_transport **p_tls)\n{\n    struct tls_transport *tls;\n    const pj_str_t ka_pkt = PJSIP_TLS_KEEP_ALIVE_DATA;\n    char print_addr[PJ_INET6_ADDRSTRLEN+10];\n    pj_status_t status;\n    \n\n    PJ_ASSERT_RETURN(listener && ssock && local && remote && p_tls, PJ_EINVAL);\n\n\n    if (pool == NULL) {\n\tpool = pjsip_endpt_create_pool(listener->endpt, \"tls\",\n\t\t\t\t       POOL_TP_INIT, POOL_TP_INC);\n\tPJ_ASSERT_RETURN(pool != NULL, PJ_ENOMEM);\n    }    \n\n    /*\n     * Create and initialize basic transport structure.\n     */\n    tls = PJ_POOL_ZALLOC_T(pool, struct tls_transport);\n    tls->is_server = is_server;\n    tls->verify_server = listener->tls_setting.verify_server;\n    pj_list_init(&tls->delayed_list);\n    tls->base.pool = pool;\n\n    pj_ansi_snprintf(tls->base.obj_name, PJ_MAX_OBJ_NAME, \n\t\t     (is_server ? \"tlss%p\" :\"tlsc%p\"), tls);\n\n    status = pj_atomic_create(pool, 0, &tls->base.ref_cnt);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    status = pj_lock_create_recursive_mutex(pool, \"tls\", &tls->base.lock);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    if (remote_name)\n\tpj_strdup(pool, &tls->remote_name, remote_name);\n\n    tls->base.key.type = listener->factory.type;\n    pj_sockaddr_cp(&tls->base.key.rem_addr, remote);\n    tls->base.type_name = (char*)pjsip_transport_get_type_name(\n\t\t\t\t   (pjsip_transport_type_e)tls->base.key.type);\n    tls->base.flag = pjsip_transport_get_flag_from_type(\n\t\t\t\t   (pjsip_transport_type_e)tls->base.key.type);\n\n    tls->base.info = (char*) pj_pool_alloc(pool, 64);\n    pj_ansi_snprintf(tls->base.info, 64, \"%s to %s\",\n                     tls->base.type_name,\n                     pj_sockaddr_print(remote, print_addr,\n                                       sizeof(print_addr), 3));\n\n\n    tls->base.addr_len = pj_sockaddr_get_len(remote);\n    tls->base.dir = is_server? PJSIP_TP_DIR_INCOMING : PJSIP_TP_DIR_OUTGOING;\n    \n    /* Set initial local address */\n    if (!pj_sockaddr_has_addr(local)) {\n        pj_sockaddr_cp(&tls->base.local_addr,\n                       &listener->factory.local_addr);\n    } else {\n\tpj_sockaddr_cp(&tls->base.local_addr, local);\n    }\n    \n    sockaddr_to_host_port(pool, &tls->base.local_name, &tls->base.local_addr);\n    if (tls->remote_name.slen) {\n\ttls->base.remote_name.host = tls->remote_name;\n\ttls->base.remote_name.port = pj_sockaddr_get_port(remote);\n    } else {\n\tsockaddr_to_host_port(pool, &tls->base.remote_name, remote);\n    }\n\n    tls->base.endpt = listener->endpt;\n    tls->base.tpmgr = listener->tpmgr;\n    tls->base.send_msg = &tls_send_msg;\n    tls->base.do_shutdown = &tls_shutdown;\n    tls->base.destroy = &tls_destroy_transport;\n    tls->base.factory = &listener->factory;\n\n    tls->ssock = ssock;\n\n    /* Set up the group lock */\n    tls->grp_lock = tls->base.grp_lock = glock;\n    pj_grp_lock_add_ref(tls->grp_lock);\n    pj_grp_lock_add_handler(tls->grp_lock, pool, tls, &tls_on_destroy);\n\n    /* Register transport to transport manager */\n    status = pjsip_transport_register(listener->tpmgr, &tls->base);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    tls->is_registered = PJ_TRUE;\n\n    /* Initialize keep-alive timer */\n    tls->ka_timer.user_data = (void*)tls;\n    tls->ka_timer.cb = &tls_keep_alive_timer;\n    pj_ioqueue_op_key_init(&tls->ka_op_key.key, sizeof(pj_ioqueue_op_key_t));\n    pj_strdup(tls->base.pool, &tls->ka_pkt, &ka_pkt);\n    \n    /* Done setting up basic transport. */\n    *p_tls = tls;\n\n    PJ_LOG(4,(tls->base.obj_name, \"TLS %s transport created\",\n\t      (tls->is_server ? \"server\" : \"client\")));\n\n    return PJ_SUCCESS;\n\non_error:\n    if (tls->grp_lock && pj_grp_lock_get_ref(tls->grp_lock))\n\ttls_destroy(&tls->base, status);\n    else\n    \ttls_on_destroy(tls);\n\n    return status;\n}\n\n\n/* Flush all delayed transmision once the socket is connected. */\nstatic void tls_flush_pending_tx(struct tls_transport *tls)\n{\n    pj_time_val now;\n\n    pj_gettickcount(&now);\n    pj_lock_acquire(tls->base.lock);\n    while (!pj_list_empty(&tls->delayed_list)) {\n\tstruct delayed_tdata *pending_tx;\n\tpjsip_tx_data *tdata;\n\tpj_ioqueue_op_key_t *op_key;\n\tpj_ssize_t size;\n\tpj_status_t status;\n\n\tpending_tx = tls->delayed_list.next;\n\tpj_list_erase(pending_tx);\n\n\ttdata = pending_tx->tdata_op_key->tdata;\n\top_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n        if (pending_tx->timeout.sec > 0 &&\n            PJ_TIME_VAL_GT(now, pending_tx->timeout))\n        {\n            pj_lock_release(tls->base.lock);\n\t    on_data_sent(tls->ssock, op_key, -PJ_ETIMEDOUT);\n            pj_lock_acquire(tls->base.lock);\n            continue;\n        }\n\n\t/* send! */\n\tsize = tdata->buf.cur - tdata->buf.start;\n\tstatus = pj_ssl_sock_send(tls->ssock, op_key, tdata->buf.start, \n\t\t\t\t  &size, 0);\n\n\tif (status != PJ_EPENDING) {\n            pj_lock_release(tls->base.lock);\n\t    on_data_sent(tls->ssock, op_key, size);\n            pj_lock_acquire(tls->base.lock);\n\t}\n    }\n    pj_lock_release(tls->base.lock);\n}\n\n\n/* Called by transport manager to destroy transport */\nstatic pj_status_t tls_destroy_transport(pjsip_transport *transport)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n\n    /* Transport would have been unregistered by now since this callback\n     * is called by transport manager.\n     */\n    tls->is_registered = PJ_FALSE;\n\n    return tls_destroy(transport, tls->close_reason);\n}\n\n\n/* Clean up TLS resources */\nstatic void tls_on_destroy(void *arg)\n{\n    struct tls_transport *tls = (struct tls_transport*)arg;\n\n    if (tls->rdata.tp_info.pool) {\n\tpj_pool_secure_release(&tls->rdata.tp_info.pool);\n    }\n\n    if (tls->base.lock) {\n\tpj_lock_destroy(tls->base.lock);\n\ttls->base.lock = NULL;\n    }\n\n    if (tls->base.ref_cnt) {\n\tpj_atomic_destroy(tls->base.ref_cnt);\n\ttls->base.ref_cnt = NULL;\n    }\n\n    if (tls->base.pool) {\n\tif (tls->close_reason != PJ_SUCCESS) {\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\n\t    pj_strerror(tls->close_reason, errmsg, sizeof(errmsg));\n\t    PJ_LOG(4,(tls->base.obj_name, \n\t\t      \"TLS transport destroyed with reason %d: %s\", \n\t\t      tls->close_reason, errmsg));\n\n\t} else {\n\n\t    PJ_LOG(4,(tls->base.obj_name, \n\t\t      \"TLS transport destroyed normally\"));\n\n\t}\n\tpj_pool_secure_release(&tls->base.pool);\n    }\n}\n\n/* Destroy TLS transport */\nstatic pj_status_t tls_destroy(pjsip_transport *transport, \n\t\t\t       pj_status_t reason)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n\n    if (tls->close_reason == 0)\n\ttls->close_reason = reason;\n\n    if (tls->is_registered) {\n\ttls->is_registered = PJ_FALSE;\n\tpjsip_transport_destroy(transport);\n\n\t/* pjsip_transport_destroy will recursively call this function\n\t * again.\n\t */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Mark transport as closing */\n    tls->is_closing = PJ_TRUE;\n\n    /* Stop keep-alive timer. */\n    if (tls->ka_timer.id) {\n\tpjsip_endpt_cancel_timer(tls->base.endpt, &tls->ka_timer);\n\ttls->ka_timer.id = PJ_FALSE;\n    }\n\n    /* Cancel all delayed transmits */\n    while (!pj_list_empty(&tls->delayed_list)) {\n\tstruct delayed_tdata *pending_tx;\n\tpj_ioqueue_op_key_t *op_key;\n\n\tpending_tx = tls->delayed_list.next;\n\tpj_list_erase(pending_tx);\n\n\top_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n\ton_data_sent(tls->ssock, op_key, -reason);\n    }\n\n    if (tls->ssock) {\n\tpj_ssl_sock_close(tls->ssock);\n\ttls->ssock = NULL;\n    }\n\n    if (tls->grp_lock) {\n\tpj_grp_lock_t *grp_lock = tls->grp_lock;\n\ttls->grp_lock = NULL;\n\tpj_grp_lock_dec_ref(grp_lock);\n\t/* Transport may have been deleted at this point */\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * This utility function creates receive data buffers and start\n * asynchronous recv() operations from the socket. It is called after\n * accept() or connect() operation complete.\n */\nstatic pj_status_t tls_start_read(struct tls_transport *tls)\n{\n    pj_pool_t *pool;\n    pj_uint32_t size;\n    pj_sockaddr *rem_addr;\n    void *readbuf[1];\n    pj_status_t status;\n\n    /* Init rdata */\n    pool = pjsip_endpt_create_pool(tls->base.endpt,\n\t\t\t\t   \"rtd%p\",\n\t\t\t\t   PJSIP_POOL_RDATA_LEN,\n\t\t\t\t   PJSIP_POOL_RDATA_INC);\n    if (!pool) {\n\ttls_perror(tls->base.obj_name, \"Unable to create pool\", PJ_ENOMEM,\n\t\t   NULL);\n\treturn PJ_ENOMEM;\n    }\n\n    tls->rdata.tp_info.pool = pool;\n\n    tls->rdata.tp_info.transport = &tls->base;\n    tls->rdata.tp_info.tp_data = tls;\n    tls->rdata.tp_info.op_key.rdata = &tls->rdata;\n    pj_ioqueue_op_key_init(&tls->rdata.tp_info.op_key.op_key, \n\t\t\t   sizeof(pj_ioqueue_op_key_t));\n\n    tls->rdata.pkt_info.src_addr = tls->base.key.rem_addr;\n    tls->rdata.pkt_info.src_addr_len = sizeof(tls->rdata.pkt_info.src_addr);\n    rem_addr = &tls->base.key.rem_addr;\n    pj_sockaddr_print(rem_addr, tls->rdata.pkt_info.src_name,\n                          sizeof(tls->rdata.pkt_info.src_name), 0);\n    tls->rdata.pkt_info.src_port = pj_sockaddr_get_port(rem_addr);\n\n    size = sizeof(tls->rdata.pkt_info.packet);\n    readbuf[0] = tls->rdata.pkt_info.packet;\n    status = pj_ssl_sock_start_read2(tls->ssock, tls->base.pool, size,\n\t\t\t\t     readbuf, 0);\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\tPJ_PERROR(4, (tls->base.obj_name, status,\n\t\t     \"pj_ssl_sock_start_read() error\"));\n\treturn status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* This callback is called by transport manager for the TLS factory\n * to create outgoing transport to the specified destination.\n */\nstatic pj_status_t lis_create_transport(pjsip_tpfactory *factory,\n\t\t\t\t\tpjsip_tpmgr *mgr,\n\t\t\t\t\tpjsip_endpoint *endpt,\n\t\t\t\t\tconst pj_sockaddr *rem_addr,\n\t\t\t\t\tint addr_len,\n\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\tpjsip_transport **p_transport)\n{\n    struct tls_listener *listener;\n    struct tls_transport *tls;\n    int sip_ssl_method;\n    pj_uint32_t sip_ssl_proto;\n    pj_pool_t *pool;\n    pj_grp_lock_t *glock;\n    pj_ssl_sock_t *ssock;\n    pj_ssl_sock_param ssock_param;\n    pj_sockaddr local_addr;\n    pj_str_t remote_name;\n    pj_status_t status;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(factory && mgr && endpt && rem_addr &&\n\t\t     addr_len && p_transport, PJ_EINVAL);\n\n    /* Check that address is a sockaddr_in or sockaddr_in6*/\n    PJ_ASSERT_RETURN((rem_addr->addr.sa_family == pj_AF_INET() &&\n\t\t      addr_len == sizeof(pj_sockaddr_in)) ||\n\t\t     (rem_addr->addr.sa_family == pj_AF_INET6() &&\n\t\t      addr_len == sizeof(pj_sockaddr_in6)), PJ_EINVAL);\n\n\n    listener = (struct tls_listener*)factory;\n\n    pool = pjsip_endpt_create_pool(listener->endpt, \"tls\",\n\t\t\t\t   POOL_TP_INIT, POOL_TP_INC);\n    PJ_ASSERT_RETURN(pool != NULL, PJ_ENOMEM);\n\n    /* Get remote host name from tdata */\n    if (tdata)\n\tremote_name = tdata->dest_info.name;\n    else\n\tpj_bzero(&remote_name, sizeof(remote_name));\n\n    /* Build SSL socket param */\n    pj_ssl_sock_param_default(&ssock_param);\n    ssock_param.sock_af = (factory->type & PJSIP_TRANSPORT_IPV6) ?\n\t\t\t    pj_AF_INET6() : pj_AF_INET();\n    ssock_param.cb.on_connect_complete = &on_connect_complete;\n    ssock_param.cb.on_data_read = &on_data_read;\n    ssock_param.cb.on_data_sent = &on_data_sent;\n    ssock_param.async_cnt = 1;\n    ssock_param.ioqueue = pjsip_endpt_get_ioqueue(listener->endpt);\n    ssock_param.timer_heap = pjsip_endpt_get_timer_heap(listener->endpt);\n    ssock_param.server_name = remote_name;\n    ssock_param.timeout = listener->tls_setting.timeout;\n    ssock_param.user_data = NULL; /* pending, must be set later */\n    ssock_param.verify_peer = PJ_FALSE; /* avoid SSL socket closing the socket\n\t\t\t\t\t * due to verification error */\n    if (ssock_param.send_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param.send_buffer_size = PJSIP_MAX_PKT_LEN;\n    if (ssock_param.read_buffer_size < PJSIP_MAX_PKT_LEN)\n\tssock_param.read_buffer_size = PJSIP_MAX_PKT_LEN;\n    ssock_param.ciphers_num = listener->tls_setting.ciphers_num;\n    ssock_param.ciphers = listener->tls_setting.ciphers;\n    ssock_param.curves_num = listener->tls_setting.curves_num;\n    ssock_param.curves = listener->tls_setting.curves;\n    ssock_param.sigalgs = listener->tls_setting.sigalgs;\n    ssock_param.entropy_type = listener->tls_setting.entropy_type;\n    ssock_param.entropy_path = listener->tls_setting.entropy_path;\n    ssock_param.qos_type = listener->tls_setting.qos_type;\n    ssock_param.qos_ignore_error = listener->tls_setting.qos_ignore_error;\n    pj_memcpy(&ssock_param.qos_params, &listener->tls_setting.qos_params,\n\t      sizeof(ssock_param.qos_params));\n\n    ssock_param.sockopt_ignore_error = \n\t\t\t\t     listener->tls_setting.sockopt_ignore_error;\n    /* Copy the sockopt */\n    pj_memcpy(&ssock_param.sockopt_params, \n\t      &listener->tls_setting.sockopt_params,\n\t      sizeof(listener->tls_setting.sockopt_params));\n\n    sip_ssl_method = listener->tls_setting.method;\n    sip_ssl_proto = listener->tls_setting.proto;\n    ssock_param.proto = ssl_get_proto(sip_ssl_method, sip_ssl_proto);\n\n    /* Create group lock */\n    status = pj_grp_lock_create(pool, NULL, &glock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    ssock_param.grp_lock = glock;\n    status = pj_ssl_sock_create(pool, &ssock_param, &ssock);\n    if (status != PJ_SUCCESS) {\n\tpj_grp_lock_destroy(glock);\n\treturn status;\n    }\n\n    /* Apply SSL certificate */\n    if (listener->cert) {\n\tstatus = pj_ssl_sock_set_certificate(ssock, pool, listener->cert);\n\tif (status != PJ_SUCCESS) {\n\t    pj_grp_lock_destroy(glock);\n\t    return status;\n\t}\n    }\n\n    /* Initially set bind address to listener's bind address */\n    pj_sockaddr_init(listener->bound_addr.addr.sa_family,\n\t\t     &local_addr, NULL, 0);\n    pj_sockaddr_copy_addr(&local_addr, &listener->bound_addr);\n\n    /* Create the transport descriptor */\n    status = tls_create(listener, pool, ssock, PJ_FALSE, &local_addr, \n\t\t\trem_addr, &remote_name, glock, &tls);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set the \"pending\" SSL socket user data */\n    pj_ssl_sock_set_user_data(tls->ssock, tls);\n\n    /* Start asynchronous connect() operation */\n    tls->has_pending_connect = PJ_TRUE;\n    status = pj_ssl_sock_start_connect(tls->ssock, tls->base.pool, \n\t\t\t\t       (pj_sockaddr_t*)&local_addr,\n\t\t\t\t       (pj_sockaddr_t*)rem_addr,\n\t\t\t\t       addr_len);\n    if (status == PJ_SUCCESS) {\n\ton_connect_complete(tls->ssock, PJ_SUCCESS);\n    } else if (status != PJ_EPENDING) {\n\ttls_destroy(&tls->base, status);\n\treturn status;\n    }\n\n    if (tls->has_pending_connect) {\n\tpj_ssl_sock_info info;\n\tchar local_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n\tchar remote_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n\n\t/* Update local address, just in case local address currently set is \n\t * different now that asynchronous connect() is started.\n\t */\n\n\t/* Retrieve the bound address */\n\tstatus = pj_ssl_sock_get_info(tls->ssock, &info);\n\tif (status == PJ_SUCCESS) {\n\t    pj_uint16_t new_port;\n\n\t    new_port = pj_sockaddr_get_port((pj_sockaddr_t*)&info.local_addr);\n\n\t    if (pj_sockaddr_has_addr((pj_sockaddr_t*)&info.local_addr)) {\n\t\t/* Update sockaddr */\n\t\tpj_sockaddr_cp((pj_sockaddr_t*)&tls->base.local_addr,\n\t\t\t       (pj_sockaddr_t*)&info.local_addr);\n\t    } else if (new_port && new_port != pj_sockaddr_get_port(\n\t\t\t\t\t(pj_sockaddr_t*)&tls->base.local_addr))\n\t    {\n\t\t/* Update port only */\n\t\tpj_sockaddr_set_port(&tls->base.local_addr, \n\t\t\t\t     new_port);\n\t    }\n\n\t    sockaddr_to_host_port(tls->base.pool, &tls->base.local_name,\n\t\t\t\t  &tls->base.local_addr);\n\t}\n\n\tPJ_LOG(4,(tls->base.obj_name, \n\t\t  \"TLS transport %s is connecting to %s...\",\n\t\t  pj_addr_str_print(&tls->base.local_name.host, \n\t\t\t\t    tls->base.local_name.port, \n\t\t\t\t    local_addr_buf, sizeof(local_addr_buf), 1),\n\t\t  pj_addr_str_print(&tls->base.remote_name.host, \n\t\t\t        tls->base.remote_name.port, \n\t\t\t\tremote_addr_buf, sizeof(remote_addr_buf), 1)));\n    }\n\n    /* Done */\n    *p_transport = &tls->base;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_bool_t on_accept_complete2(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_ssl_sock_t *new_ssock,\n\t\t\t\t     const pj_sockaddr_t *src_addr,\n\t\t\t\t     int src_addr_len, \n\t\t\t\t     pj_status_t accept_status)\n{    \n    struct tls_listener *listener;\n    struct tls_transport *tls;\n    pj_ssl_sock_info ssl_info;\n    char addr[PJ_INET6_ADDRSTRLEN+10];\n    pjsip_tp_state_callback state_cb;\n    pj_sockaddr tmp_src_addr;\n    pj_bool_t is_shutdown;\n    pj_status_t status;\n    char addr_buf[PJ_INET6_ADDRSTRLEN+10];        \n\n    PJ_UNUSED_ARG(src_addr_len);\n\n    listener = (struct tls_listener*) pj_ssl_sock_get_user_data(ssock);\n    if (!listener) {\n\t/* Listener already destroyed, e.g: after TCP accept but before SSL\n\t * handshake is completed.\n\t */\n\tif (new_ssock && accept_status == PJ_SUCCESS) {\n\t    /* Close the SSL socket if the accept op is successful */\n\t    PJ_LOG(4,(THIS_FILE,\n\t\t      \"Incoming TLS connection from %s (sock=%d) is discarded \"\n\t\t      \"because listener is already destroyed\",\n\t\t      pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),\n\t\t      new_ssock));\n\n\t    pj_ssl_sock_close(new_ssock);\n\t}\n\n\treturn PJ_FALSE;\n    }\n\n    if (accept_status != PJ_SUCCESS) {\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_ssl_sock_info ssi;\n\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = accept_status;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    if (new_ssock &&\n\t\tpj_ssl_sock_get_info(new_ssock, &ssi) == PJ_SUCCESS)\n\t    {\n\t\tparam.last_native_err = ssi.last_native_err;\n\t    }\n\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\n\treturn PJ_FALSE;\n    }\n\n    PJ_ASSERT_RETURN(new_ssock, PJ_TRUE);\n\n    if (!listener->is_registered) {\n\tpj_ssl_sock_close(new_ssock);\n\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = PJSIP_TLS_EACCEPT;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\treturn PJ_FALSE;\n    }\t\n\n    PJ_LOG(4,(listener->factory.obj_name, \n\t      \"TLS listener %s: got incoming TLS connection \"\n\t      \"from %s, sock=%d\",\n\t      pj_addr_str_print(&listener->factory.addr_name.host, \n\t\t\t\tlistener->factory.addr_name.port, addr_buf, \n\t\t\t\tsizeof(addr_buf), 1),\n\t      pj_sockaddr_print(src_addr, addr, sizeof(addr), 3),\n\t      new_ssock));\n\n    /* Retrieve SSL socket info, close the socket if this is failed\n     * as the SSL socket info availability is rather critical here.\n     */\n    status = pj_ssl_sock_get_info(new_ssock, &ssl_info);\n    if (status != PJ_SUCCESS) {\n\tpj_ssl_sock_close(new_ssock);\n\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = status;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Copy to larger buffer, just in case */\n    pj_bzero(&tmp_src_addr, sizeof(tmp_src_addr));\n    pj_sockaddr_cp(&tmp_src_addr, src_addr);\n\n    /* \n     * Incoming connection!\n     * Create TLS transport for the new socket.\n     */\n    status = tls_create( listener, NULL, new_ssock, PJ_TRUE,\n\t\t\t &ssl_info.local_addr, &tmp_src_addr, NULL,\n\t\t\t ssl_info.grp_lock, &tls);\n    \n    if (status != PJ_SUCCESS) {\n\tpj_ssl_sock_close(new_ssock);\n\n\tif (listener->tls_setting.on_accept_fail_cb) {\n\t    pjsip_tls_on_accept_fail_param param;\n\t    pj_bzero(&param, sizeof(param));\n\t    param.status = status;\n\t    param.local_addr = &listener->factory.local_addr;\n\t    param.remote_addr = src_addr;\n\t    (*listener->tls_setting.on_accept_fail_cb) (&param);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Set the \"pending\" SSL socket user data */\n    pj_ssl_sock_set_user_data(new_ssock, tls);\n\n    /* Prevent immediate transport destroy as application may access it \n     * (getting info, etc) in transport state notification callback.\n     */\n    pjsip_transport_add_ref(&tls->base);\n\n    /* If there is verification error and verification is mandatory, shutdown\n     * and destroy the transport.\n     */\n    if (ssl_info.verify_status && listener->tls_setting.verify_client) {\n\tif (tls->close_reason == PJ_SUCCESS) \n\t    tls->close_reason = PJSIP_TLS_ECERTVERIF;\n\tpjsip_transport_shutdown(&tls->base);\n    }\n    /* Notify transport state to application */\n    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpjsip_transport_state tp_state;\n\n\t/* Init transport state info */\n\tpj_bzero(&tls_info, sizeof(tls_info));\n\tpj_bzero(&state_info, sizeof(state_info));\n\ttls_info.ssl_sock_info = &ssl_info;\n\tstate_info.ext_info = &tls_info;\n\n\t/* Set transport state based on verification status */\n\tif (ssl_info.verify_status && listener->tls_setting.verify_client)\n\t{\n\t    tp_state = PJSIP_TP_STATE_DISCONNECTED;\n\t    state_info.status = PJSIP_TLS_ECERTVERIF;\n\t} else {\n\t    tp_state = PJSIP_TP_STATE_CONNECTED;\n\t    state_info.status = PJ_SUCCESS;\n\t}\n\n\t(*state_cb)(&tls->base, tp_state, &state_info);\n    }\n\n    /* Release transport reference. If transport is shutting down, it may\n     * get destroyed here.\n     */\n    is_shutdown = tls->base.is_shutdown;\n    pjsip_transport_dec_ref(&tls->base);\n    if (is_shutdown)\n\treturn PJ_TRUE;\n\n\n    status = tls_start_read(tls);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(3,(tls->base.obj_name, \"New transport cancelled\"));\n\ttls_init_shutdown(tls, status);\n\ttls_destroy(&tls->base, status);\n    } else {\n\t/* Start keep-alive timer */\n\tif (pjsip_cfg()->tls.keep_alive_interval) {\n\t    pj_time_val delay = {0};\t    \n\t    delay.sec = pjsip_cfg()->tls.keep_alive_interval;\n\t    pjsip_endpt_schedule_timer(listener->endpt, \n\t\t\t\t       &tls->ka_timer, \n\t\t\t\t       &delay);\n\t    tls->ka_timer.id = PJ_TRUE;\n\t    pj_gettimeofday(&tls->last_activity);\n\t}\n    }\n\n    return PJ_TRUE;\n}\n\n/*\n * This callback is called by SSL socket when pending accept() operation\n * has completed.\n */\n//static pj_bool_t on_accept_complete(pj_ssl_sock_t *ssock,\n//\t\t\t\t    pj_ssl_sock_t *new_ssock,\n//\t\t\t\t    const pj_sockaddr_t *src_addr,\n//\t\t\t\t    int src_addr_len)\n//{\n//    PJ_UNUSED_ARG(src_addr_len);\n//}\n\n\n/* \n * Callback from ioqueue when packet is sent.\n */\nstatic pj_bool_t on_data_sent(pj_ssl_sock_t *ssock,\n\t\t\t      pj_ioqueue_op_key_t *op_key,\n\t\t\t      pj_ssize_t bytes_sent)\n{\n    struct tls_transport *tls = (struct tls_transport*) \n    \t\t\t\tpj_ssl_sock_get_user_data(ssock);\n    pjsip_tx_data_op_key *tdata_op_key = (pjsip_tx_data_op_key*)op_key;\n\n    /* Note that op_key may be the op_key from keep-alive, thus\n     * it will not have tdata etc.\n     */\n\n    tdata_op_key->tdata = NULL;\n\n    if (tdata_op_key->callback) {\n\t/*\n\t * Notify sip_transport.c that packet has been sent.\n\t */\n\tif (bytes_sent == 0)\n\t    bytes_sent = -PJ_RETURN_OS_ERROR(OSERR_ENOTCONN);\n\n\ttdata_op_key->callback(&tls->base, tdata_op_key->token, bytes_sent);\n\n\t/* Mark last activity time */\n\tpj_gettimeofday(&tls->last_activity);\n\n    }\n\n    /* Check for error/closure */\n    if (bytes_sent <= 0) {\n\tpj_status_t status;\n\n\tPJ_LOG(5,(tls->base.obj_name, \"TLS send() error, sent=%d\", \n\t\t  bytes_sent));\n\n\tstatus = (bytes_sent == 0) ? PJ_RETURN_OS_ERROR(OSERR_ENOTCONN) :\n\t\t\t\t     (pj_status_t)-bytes_sent;\n\n\ttls_init_shutdown(tls, status);\n\n\treturn PJ_FALSE;\n    }\n    \n    return PJ_TRUE;\n}\n\n\n/* \n * This callback is called by transport manager to send SIP message \n */\nstatic pj_status_t tls_send_msg(pjsip_transport *transport, \n\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\tconst pj_sockaddr_t *rem_addr,\n\t\t\t\tint addr_len,\n\t\t\t\tvoid *token,\n\t\t\t\tpjsip_transport_callback callback)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n    pj_ssize_t size;\n    pj_bool_t delayed = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(transport && tdata, PJ_EINVAL);\n\n    /* Check that there's no pending operation associated with the tdata */\n    PJ_ASSERT_RETURN(tdata->op_key.tdata == NULL, PJSIP_EPENDINGTX);\n    \n    /* Check the address is supported */\n    PJ_ASSERT_RETURN(rem_addr && (addr_len==sizeof(pj_sockaddr_in) ||\n\t                          addr_len==sizeof(pj_sockaddr_in6)),\n\t             PJ_EINVAL);\n\n    /* Init op key. */\n    tdata->op_key.tdata = tdata;\n    tdata->op_key.token = token;\n    tdata->op_key.callback = callback;\n\n    /* If asynchronous connect() has not completed yet, just put the\n     * transmit data in the pending transmission list since we can not\n     * use the socket yet.\n     */\n    if (tls->has_pending_connect) {\n\n\t/*\n\t * Looks like connect() is still in progress. Check again (this time\n\t * with holding the lock) to be sure.\n\t */\n\tpj_lock_acquire(tls->base.lock);\n\n\tif (tls->has_pending_connect) {\n\t    struct delayed_tdata *delayed_tdata;\n\n\t    /*\n\t     * connect() is still in progress. Put the transmit data to\n\t     * the delayed list.\n             * Starting from #1583 (https://trac.pjsip.org/repos/ticket/1583),\n             * we also add timeout value for the transmit data. When the\n             * connect() is completed, the timeout value will be checked to\n             * determine whether the transmit data needs to be sent.\n\t     */\n\t    delayed_tdata = PJ_POOL_ZALLOC_T(tdata->pool, \n\t\t\t\t\t     struct delayed_tdata);\n\t    delayed_tdata->tdata_op_key = &tdata->op_key;\n            if (tdata->msg && tdata->msg->type == PJSIP_REQUEST_MSG) {\n                pj_gettickcount(&delayed_tdata->timeout);\n                delayed_tdata->timeout.msec += pjsip_cfg()->tsx.td;\n                pj_time_val_normalize(&delayed_tdata->timeout);\n            }\n\n\t    pj_list_push_back(&tls->delayed_list, delayed_tdata);\n\t    status = PJ_EPENDING;\n\n\t    /* Prevent pj_ioqueue_send() to be called below */\n\t    delayed = PJ_TRUE;\n\t}\n\n\tpj_lock_release(tls->base.lock);\n    } \n    \n    if (!delayed) {\n\t/*\n\t * Transport is ready to go. Send the packet to ioqueue to be\n\t * sent asynchronously.\n\t */\n\tsize = tdata->buf.cur - tdata->buf.start;\n\tstatus = pj_ssl_sock_send(tls->ssock, \n\t\t\t\t    (pj_ioqueue_op_key_t*)&tdata->op_key,\n\t\t\t\t    tdata->buf.start, &size, 0);\n\n\tif (status != PJ_EPENDING) {\n\t    /* Not pending (could be immediate success or error) */\n\t    tdata->op_key.tdata = NULL;\n\n\t    /* Shutdown transport on closure/errors */\n\t    if (size <= 0) {\n\n\t\tPJ_LOG(5,(tls->base.obj_name, \"TLS send() error, sent=%d\", \n\t\t\t  size));\n\n\t\tif (status == PJ_SUCCESS) \n\t\t    status = PJ_RETURN_OS_ERROR(OSERR_ENOTCONN);\n\n\t\ttls_init_shutdown(tls, status);\n\t    }\n\t}\n    }\n\n    return status;\n}\n\n\n/* \n * This callback is called by transport manager to shutdown transport.\n */\nstatic pj_status_t tls_shutdown(pjsip_transport *transport)\n{\n    struct tls_transport *tls = (struct tls_transport*)transport;\n    \n    /* Stop keep-alive timer. */\n    if (tls->ka_timer.id) {\n\tpjsip_endpt_cancel_timer(tls->base.endpt, &tls->ka_timer);\n\ttls->ka_timer.id = PJ_FALSE;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* \n * Callback from ioqueue that an incoming data is received from the socket.\n */\nstatic pj_bool_t on_data_read(pj_ssl_sock_t *ssock,\n\t\t\t      void *data,\n\t\t\t      pj_size_t size,\n\t\t\t      pj_status_t status,\n\t\t\t      pj_size_t *remainder)\n{\n    enum { MAX_IMMEDIATE_PACKET = 10 };\n    struct tls_transport *tls;\n    pjsip_rx_data *rdata;\n\n    PJ_UNUSED_ARG(data);\n\n    tls = (struct tls_transport*) pj_ssl_sock_get_user_data(ssock);\n    rdata = &tls->rdata;\n\n    /* Don't do anything if transport is closing. */\n    if (tls->is_closing) {\n\ttls->is_closing++;\n\treturn PJ_FALSE;\n    }\n\n    /* Houston, we have packet! Report the packet to transport manager\n     * to be parsed.\n     */\n    if (status == PJ_SUCCESS) {\n\tpj_size_t size_eaten;\n\n\t/* Mark this as an activity */\n\tpj_gettimeofday(&tls->last_activity);\n\n\tpj_assert((void*)rdata->pkt_info.packet == data);\n\n\t/* Init pkt_info part. */\n\trdata->pkt_info.len = size;\n\trdata->pkt_info.zero = 0;\n\tpj_gettimeofday(&rdata->pkt_info.timestamp);\n\n\t/* Report to transport manager.\n\t * The transport manager will tell us how many bytes of the packet\n\t * have been processed (as valid SIP message).\n\t */\n\tsize_eaten = \n\t    pjsip_tpmgr_receive_packet(rdata->tp_info.transport->tpmgr, \n\t\t\t\t       rdata);\n\n\tpj_assert(size_eaten <= (pj_size_t)rdata->pkt_info.len);\n\n\t/* Move unprocessed data to the front of the buffer */\n\t*remainder = size - size_eaten;\n\tif (*remainder > 0 && *remainder != size) {\n\t    pj_memmove(rdata->pkt_info.packet,\n\t\t       rdata->pkt_info.packet + size_eaten,\n\t\t       *remainder);\n\t}\n\n    } else {\n\n\t/* Transport is closed */\n\tPJ_LOG(4,(tls->base.obj_name, \"TLS connection closed\"));\n\n\ttls_init_shutdown(tls, status);\n\n\treturn PJ_FALSE;\n\n    }\n\n    /* Reset pool. */\n    pj_pool_reset(rdata->tp_info.pool);\n\n    return PJ_TRUE;\n}\n\n\n/* \n * Callback from ioqueue when asynchronous connect() operation completes.\n */\nstatic pj_bool_t on_connect_complete(pj_ssl_sock_t *ssock,\n\t\t\t\t     pj_status_t status)\n{\n    struct tls_transport *tls;\n    pj_ssl_sock_info ssl_info;\n    pj_sockaddr addr, *tp_addr;\n    pjsip_tp_state_callback state_cb;\n    pj_bool_t is_shutdown;\n    char local_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n    char remote_addr_buf[PJ_INET6_ADDRSTRLEN+10];\n\n    tls = (struct tls_transport*) pj_ssl_sock_get_user_data(ssock);\n\n    /* If transport is being shutdown/destroyed, proceed as error connect.\n     * Note that it is important to notify application via on_data_sent()\n     * as otherwise the transport reference counter may never reach zero\n     * (see #1898).\n     */\n    if ((tls->base.is_shutdown || tls->base.is_destroying) &&\n\tstatus == PJ_SUCCESS)\n    {\n\tstatus = PJ_ECANCELLED;\n    }\n\n    /* Check connect() status */\n    if (status != PJ_SUCCESS) {\n\n\ttls_perror(tls->base.obj_name, \"TLS connect() error\", status,\n\t\t   &tls->remote_name);\n\n\t/* Cancel all delayed transmits */\n\twhile (!pj_list_empty(&tls->delayed_list)) {\n\t    struct delayed_tdata *pending_tx;\n\t    pj_ioqueue_op_key_t *op_key;\n\n\t    pending_tx = tls->delayed_list.next;\n\t    pj_list_erase(pending_tx);\n\n\t    op_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n\t    on_data_sent(tls->ssock, op_key, -status);\n\t}\n\n\tgoto on_error;\n    }\n\n    /* Retrieve SSL socket info, shutdown the transport if this is failed\n     * as the SSL socket info availability is rather critical here.\n     */\n    status = pj_ssl_sock_get_info(tls->ssock, &ssl_info);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Update (again) local address, just in case local address currently\n     * set is different now that the socket is connected (could happen\n     * on some systems, like old Win32 probably?).\n     */\n    tp_addr = &tls->base.local_addr;\n    pj_sockaddr_cp((pj_sockaddr_t*)&addr, \n\t\t   (pj_sockaddr_t*)&ssl_info.local_addr);\n    if (pj_sockaddr_cmp(tp_addr, &addr) != 0) {\n\tpj_sockaddr_cp(tp_addr, &addr);\n\tsockaddr_to_host_port(tls->base.pool, &tls->base.local_name,\n\t\t\t      tp_addr);\n    }\n\n    /* Server identity verification based on server certificate. */\n    if (ssl_info.remote_cert_info->version) {\n\tpj_str_t *remote_name;\n\tpj_ssl_cert_info *serv_cert = ssl_info.remote_cert_info;\n\tpj_bool_t matched = PJ_FALSE;\n\tunsigned i;\n\n\t/* Remote name may be hostname or IP address */\n\tif (tls->remote_name.slen)\n\t    remote_name = &tls->remote_name;\n\telse\n\t    remote_name = &tls->base.remote_name.host;\n\n\t/* Start matching remote name with SubjectAltName fields of \n\t * server certificate.\n\t */\n\tfor (i = 0; i < serv_cert->subj_alt_name.cnt && !matched; ++i) {\n\t    pj_str_t *cert_name = &serv_cert->subj_alt_name.entry[i].name;\n\n\t    switch (serv_cert->subj_alt_name.entry[i].type) {\n\t    case PJ_SSL_CERT_NAME_DNS:\n\t    case PJ_SSL_CERT_NAME_IP:\n\t\tmatched = !pj_stricmp(remote_name, cert_name);\n\t\tbreak;\n\t    case PJ_SSL_CERT_NAME_URI:\n\t\tif (pj_strnicmp2(cert_name, \"sip:\", 4) == 0 ||\n\t\t    pj_strnicmp2(cert_name, \"sips:\", 5) == 0)\n\t\t{\n\t\t    pj_str_t host_part;\n\t\t    char *p;\n\n\t\t    p = pj_strchr(cert_name, ':') + 1;\n\t\t    pj_strset(&host_part, p, cert_name->slen - \n\t\t\t\t\t     (p - cert_name->ptr));\n\t\t    matched = !pj_stricmp(remote_name, &host_part);\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    \t\n\t/* When still not matched or no SubjectAltName fields in server\n\t * certificate, try with Common Name of Subject field.\n\t */\n\tif (!matched) {\n\t    matched = !pj_stricmp(remote_name, &serv_cert->subject.cn);\n\t}\n\n\tif (!matched) {\n\t    if (pj_strnicmp2(&serv_cert->subject.cn, \"*.\", 2) == 0) {\n\t\tPJ_LOG(1,(tls->base.obj_name,\n\t\t    \"RFC 5922 (section 7.2) does not allow TLS wildcard \"\n\t\t\t\"certificates. Advise your SIP provider, please!\"));\n\t    }\n\t    ssl_info.verify_status |= PJ_SSL_CERT_EIDENTITY_NOT_MATCH;\n\t}\n    }\n\n    /* Prevent immediate transport destroy as application may access it \n     * (getting info, etc) in transport state notification callback.\n     */\n    pjsip_transport_add_ref(&tls->base);\n\n    /* If there is verification error and verification is mandatory, shutdown\n     * and destroy the transport.\n     */\n    if (ssl_info.verify_status && tls->verify_server) {\n\tif (tls->close_reason == PJ_SUCCESS) \n\t    tls->close_reason = PJSIP_TLS_ECERTVERIF;\n\tpjsip_transport_shutdown(&tls->base);\n    }\n\n    /* Notify transport state to application */\n    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\tpjsip_tls_state_info tls_info;\n\tpjsip_transport_state tp_state;\n\n\t/* Init transport state info */\n\tpj_bzero(&state_info, sizeof(state_info));\n\tpj_bzero(&tls_info, sizeof(tls_info));\n\tstate_info.ext_info = &tls_info;\n\ttls_info.ssl_sock_info = &ssl_info;\n\n\t/* Set transport state based on verification status */\n\tif (ssl_info.verify_status && tls->verify_server)\n\t{\n\t    tp_state = PJSIP_TP_STATE_DISCONNECTED;\n\t    state_info.status = PJSIP_TLS_ECERTVERIF;\n\t} else {\n\t    tp_state = PJSIP_TP_STATE_CONNECTED;\n\t    state_info.status = PJ_SUCCESS;\n\t}\n\n\t(*state_cb)(&tls->base, tp_state, &state_info);\n    }\n\n    /* Release transport reference. If transport is shutting down, it may\n     * get destroyed here.\n     */\n    is_shutdown = tls->base.is_shutdown;\n    pjsip_transport_dec_ref(&tls->base);\n    if (is_shutdown) {\n\tstatus = tls->close_reason;\n\ttls_perror(tls->base.obj_name, \"TLS connect() error\", status, \n\t\t   &tls->remote_name);\n\n\t/* Cancel all delayed transmits */\n\twhile (!pj_list_empty(&tls->delayed_list)) {\n\t    struct delayed_tdata *pending_tx;\n\t    pj_ioqueue_op_key_t *op_key;\n\n\t    pending_tx = tls->delayed_list.next;\n\t    pj_list_erase(pending_tx);\n\n\t    op_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;\n\n\t    on_data_sent(tls->ssock, op_key, -status);\n\t}\n\n\treturn PJ_FALSE;\n    }\n\n\n    /* Mark that pending connect() operation has completed. */\n    tls->has_pending_connect = PJ_FALSE;\n\n    PJ_LOG(4,(tls->base.obj_name, \n\t      \"TLS transport %s is connected to %s\",\n\t      pj_addr_str_print(&tls->base.local_name.host, \n\t\t\t\ttls->base.local_name.port, local_addr_buf, \n\t\t\t\tsizeof(local_addr_buf), 1),\n\t      pj_addr_str_print(&tls->base.remote_name.host, \n\t\t\t\ttls->base.remote_name.port, remote_addr_buf, \n\t\t\t\tsizeof(remote_addr_buf), 1)));\n\n    /* Start pending read */\n    status = tls_start_read(tls);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Flush all pending send operations */\n    tls_flush_pending_tx(tls);\n\n    /* Start keep-alive timer */\n    if (pjsip_cfg()->tls.keep_alive_interval) {\n\tpj_time_val delay = {0};\t    \n\tdelay.sec = pjsip_cfg()->tls.keep_alive_interval;\n\tpjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, \n\t\t\t\t   &delay);\n\ttls->ka_timer.id = PJ_TRUE;\n\tpj_gettimeofday(&tls->last_activity);\n    }\n\n    return PJ_TRUE;\n\non_error:\n    tls_init_shutdown(tls, status);\n\n    return PJ_FALSE;\n}\n\n\n/* Transport keep-alive timer callback */\nstatic void tls_keep_alive_timer(pj_timer_heap_t *th, pj_timer_entry *e)\n{\n    struct tls_transport *tls = (struct tls_transport*) e->user_data;\n    pj_time_val delay;\n    pj_time_val now;\n    pj_ssize_t size;\n    pj_status_t status;\n    char addr[PJ_INET6_ADDRSTRLEN+10];    \n\n    PJ_UNUSED_ARG(th);\n\n    tls->ka_timer.id = PJ_TRUE;\n\n    pj_gettimeofday(&now);\n    PJ_TIME_VAL_SUB(now, tls->last_activity);\n\n    if (now.sec > 0 && now.sec < pjsip_cfg()->tls.keep_alive_interval) {\n\t/* There has been activity, so don't send keep-alive */\n\tdelay.sec = pjsip_cfg()->tls.keep_alive_interval - now.sec;\n\tdelay.msec = 0;\n\n\tpjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, \n\t\t\t\t   &delay);\n\ttls->ka_timer.id = PJ_TRUE;\n\treturn;\n    }\n\n    PJ_LOG(5,(tls->base.obj_name, \"Sending %d byte(s) keep-alive to %s\", \n\t      (int)tls->ka_pkt.slen, \n\t      pj_addr_str_print(&tls->base.remote_name.host, \n\t\t\t\ttls->base.remote_name.port, addr, \n\t\t\t\tsizeof(addr), 1)));\n\n    /* Send the data */\n    size = tls->ka_pkt.slen;\n    status = pj_ssl_sock_send(tls->ssock, &tls->ka_op_key.key,\n\t\t\t      tls->ka_pkt.ptr, &size, 0);\n\n    if (status != PJ_SUCCESS && status != PJ_EPENDING) {\n\ttls_perror(tls->base.obj_name, \n\t\t   \"Error sending keep-alive packet\", status,\n\t\t   &tls->remote_name);\n\n\ttls_init_shutdown(tls, status);\n\treturn;\n    }\n\n    /* Register next keep-alive */\n    delay.sec = pjsip_cfg()->tls.keep_alive_interval;\n    delay.msec = 0;\n\n    pjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, \n\t\t\t       &delay);\n    tls->ka_timer.id = PJ_TRUE;\n}\n\n\nstatic void wipe_buf(pj_str_t *buf)\n{\n    volatile char *p = buf->ptr;\n    pj_ssize_t len = buf->slen;\n    while (len--) *p++ = 0;\n    buf->slen = 0;\n}\n\n/*\n * Wipe out certificates and keys in the TLS setting buffer.\n */\nPJ_DEF(void) pjsip_tls_setting_wipe_keys(pjsip_tls_setting *opt)\n{\n    wipe_buf(&opt->ca_list_file);\n    wipe_buf(&opt->ca_list_path);\n    wipe_buf(&opt->cert_file);\n    wipe_buf(&opt->privkey_file);\n    wipe_buf(&opt->password);\n    wipe_buf(&opt->sigalgs);\n    wipe_buf(&opt->entropy_path);\n    wipe_buf(&opt->ca_buf);\n    wipe_buf(&opt->cert_buf);\n    wipe_buf(&opt->privkey_buf);    \n}\n\n#endif /* PJSIP_HAS_TLS_TRANSPORT */\n"], "filenames": ["pjlib/src/pj/ssl_sock_imp_common.c", "pjlib/src/pj/ssl_sock_ossl.c", "pjsip/src/pjsip/sip_transport_tls.c"], "buggy_code_start_loc": [257, 330, 1335], "buggy_code_end_loc": [1010, 1476, 1411], "fixing_code_start_loc": [258, 330, 1336], "fixing_code_end_loc": [1034, 1508, 1433], "type": "CWE-362", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP before version 2.11.1, there are a couple of issues found in the SSL socket. First, a race condition between callback and destroy, due to the accepted socket having no group lock. Second, the SSL socket parent/listener may get destroyed during handshake. Both issues were reported to happen intermittently in heavy load TLS connections. They cause a crash, resulting in a denial of service. These are fixed in version 2.11.1.", "other": {"cve": {"id": "CVE-2021-32686", "sourceIdentifier": "security-advisories@github.com", "published": "2021-07-23T22:15:08.373", "lastModified": "2022-11-16T19:02:12.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP before version 2.11.1, there are a couple of issues found in the SSL socket. First, a race condition between callback and destroy, due to the accepted socket having no group lock. Second, the SSL socket parent/listener may get destroyed during handshake. Both issues were reported to happen intermittently in heavy load TLS connections. They cause a crash, resulting in a denial of service. These are fixed in version 2.11.1."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C implementando protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En PJSIP versiones anteriores a 2.11.1, se presentan un par de problemas encontrados en el socket SSL. Primero, una condici\u00f3n de carrera entre la devoluci\u00f3n de llamada y la destrucci\u00f3n, debido a que el socket aceptado no tiene bloqueo de grupo. Segundo, el socket SSL parent/listener puede ser destruido durante el handshake. Ambos problemas fueron reportados como ocurridos intermitentemente en conexiones TLS con mucha carga. Causan un bloqueo, resultando en una denegaci\u00f3n de servicio. Se han corregido en versi\u00f3n 2.11.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.1", "matchCriteriaId": "950960B9-2161-4AE9-BF04-7887E76BA424"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/d5f95aa066f878b0aef6a64e60b61e8626e664cd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/pull/2716", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/releases/tag/2.11.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-cv8x-p47p-99wr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4999", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/d5f95aa066f878b0aef6a64e60b61e8626e664cd"}}