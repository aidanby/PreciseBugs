{"buggy_code": [".\\\" $OpenBSD: ssh-agent.1,v 1.75 2022/10/07 06:00:58 jmc Exp $\n.\\\"\n.\\\" Author: Tatu Ylonen <ylo@cs.hut.fi>\n.\\\" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n.\\\"                    All rights reserved\n.\\\"\n.\\\" As far as I am concerned, the code I have written for this software\n.\\\" can be used freely for any purpose.  Any derived versions of this\n.\\\" software must be clearly marked as such, and if the derived work is\n.\\\" incompatible with the protocol description in the RFC file, it must be\n.\\\" called by a name other than \"ssh\" or \"Secure Shell\".\n.\\\"\n.\\\" Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.\n.\\\" Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n.\\\" Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that the following conditions\n.\\\" are met:\n.\\\" 1. Redistributions of source code must retain the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer.\n.\\\" 2. Redistributions in binary form must reproduce the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer in the\n.\\\"    documentation and/or other materials provided with the distribution.\n.\\\"\n.\\\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n.\\\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n.\\\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n.\\\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n.\\\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n.\\\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n.\\\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n.\\\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n.\\\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n.\\\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n.\\\"\n.Dd $Mdocdate: October 7 2022 $\n.Dt SSH-AGENT 1\n.Os\n.Sh NAME\n.Nm ssh-agent\n.Nd OpenSSH authentication agent\n.Sh SYNOPSIS\n.Nm ssh-agent\n.Op Fl c | s\n.Op Fl \\&Dd\n.Op Fl a Ar bind_address\n.Op Fl E Ar fingerprint_hash\n.Op Fl O Ar option\n.Op Fl P Ar allowed_providers\n.Op Fl t Ar life\n.Nm ssh-agent\n.Op Fl a Ar bind_address\n.Op Fl E Ar fingerprint_hash\n.Op Fl O Ar option\n.Op Fl P Ar allowed_providers\n.Op Fl t Ar life\n.Ar command Op Ar arg ...\n.Nm ssh-agent\n.Op Fl c | s\n.Fl k\n.Sh DESCRIPTION\n.Nm\nis a program to hold private keys used for public key authentication.\nThrough use of environment variables the agent can be located\nand automatically used for authentication when logging in to other\nmachines using\n.Xr ssh 1 .\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl a Ar bind_address\nBind the agent to the\n.Ux Ns -domain\nsocket\n.Ar bind_address .\nThe default is\n.Pa $TMPDIR/ssh-XXXXXXXXXX/agent.\\*(Ltppid\\*(Gt .\n.It Fl c\nGenerate C-shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\nlooks like it's a csh style of shell.\n.It Fl D\nForeground mode.\nWhen this option is specified,\n.Nm\nwill not fork.\n.It Fl d\nDebug mode.\nWhen this option is specified,\n.Nm\nwill not fork and will write debug information to standard error.\n.It Fl E Ar fingerprint_hash\nSpecifies the hash algorithm used when displaying key fingerprints.\nValid options are:\n.Dq md5\nand\n.Dq sha256 .\nThe default is\n.Dq sha256 .\n.It Fl k\nKill the current agent (given by the\n.Ev SSH_AGENT_PID\nenvironment variable).\n.It Fl O Ar option\nSpecify an option when starting\n.Nm .\nCurrently only one option is supported:\n.Cm no-restrict-websafe .\nThis instructs\n.Nm\nto permit signatures using FIDO keys that might be web authentication\nrequests.\nBy default,\n.Nm\nrefuses signature requests for FIDO keys where the key application string\ndoes not start with\n.Dq ssh:\nand when the data to be signed does not appear to be a\n.Xr ssh 1\nuser authentication request or a\n.Xr ssh-keygen 1\nsignature.\nThe default behaviour prevents forwarded access to a FIDO key from also\nimplicitly forwarding the ability to authenticate to websites.\n.It Fl P Ar allowed_providers\nSpecify a pattern-list of acceptable paths for PKCS#11 provider and FIDO\nauthenticator middleware shared libraries that may be used with the\n.Fl S\nor\n.Fl s\noptions to\n.Xr ssh-add 1 .\nLibraries that do not match the pattern list will be refused.\nSee PATTERNS in\n.Xr ssh_config 5\nfor a description of pattern-list syntax.\nThe default list is\n.Dq /usr/lib/*,/usr/local/lib/* .\n.It Fl s\nGenerate Bourne shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\ndoes not look like it's a csh style of shell.\n.It Fl t Ar life\nSet a default value for the maximum lifetime of identities added to the agent.\nThe lifetime may be specified in seconds or in a time format specified in\n.Xr sshd_config 5 .\nA lifetime specified for an identity with\n.Xr ssh-add 1\noverrides this value.\nWithout this option the default maximum lifetime is forever.\n.It Ar command Op Ar arg ...\nIf a command (and optional arguments) is given,\nthis is executed as a subprocess of the agent.\nThe agent exits automatically when the command given on the command\nline terminates.\n.El\n.Pp\nThere are two main ways to get an agent set up.\nThe first is at the start of an X session,\nwhere all other windows or programs are started as children of the\n.Nm\nprogram.\nThe agent starts a command under which its environment\nvariables are exported, for example\n.Cm ssh-agent xterm & .\nWhen the command terminates, so does the agent.\n.Pp\nThe second method is used for a login session.\nWhen\n.Nm\nis started,\nit prints the shell commands required to set its environment variables,\nwhich in turn can be evaluated in the calling shell, for example\n.Cm eval `ssh-agent -s` .\n.Pp\nIn both cases,\n.Xr ssh 1\nlooks at these environment variables\nand uses them to establish a connection to the agent.\n.Pp\nThe agent initially does not have any private keys.\nKeys are added using\n.Xr ssh-add 1\nor by\n.Xr ssh 1\nwhen\n.Cm AddKeysToAgent\nis set in\n.Xr ssh_config 5 .\nMultiple identities may be stored in\n.Nm\nconcurrently and\n.Xr ssh 1\nwill automatically use them if present.\n.Xr ssh-add 1\nis also used to remove keys from\n.Nm\nand to query the keys that are held in one.\n.Pp\nConnections to\n.Nm\nmay be forwarded from further remote hosts using the\n.Fl A\noption to\n.Xr ssh 1\n(but see the caveats documented therein),\navoiding the need for authentication data to be stored on other machines.\nAuthentication passphrases and private keys never go over the network:\nthe connection to the agent is forwarded over SSH remote connections\nand the result is returned to the requester,\nallowing the user access to their identities anywhere in the network\nin a secure fashion.\n.Sh ENVIRONMENT\n.Bl -tag -width \"SSH_AGENT_PID\"\n.It Ev SSH_AGENT_PID\nWhen\n.Nm\nstarts, it stores the name of the agent's process ID (PID) in this variable.\n.It Ev SSH_AUTH_SOCK\nWhen\n.Nm\nstarts, it creates a\n.Ux Ns -domain\nsocket and stores its pathname in this variable.\nIt is accessible only to the current user,\nbut is easily abused by root or another instance of the same user.\n.El\n.Sh FILES\n.Bl -tag -width Ds\n.It Pa $TMPDIR/ssh-XXXXXXXXXX/agent.<ppid>\n.Ux Ns -domain\nsockets used to contain the connection to the authentication agent.\nThese sockets should only be readable by the owner.\nThe sockets should get automatically removed when the agent exits.\n.El\n.Sh SEE ALSO\n.Xr ssh 1 ,\n.Xr ssh-add 1 ,\n.Xr ssh-keygen 1 ,\n.Xr ssh_config 5 ,\n.Xr sshd 8\n.Sh AUTHORS\n.An -nosplit\nOpenSSH is a derivative of the original and free ssh 1.2.12 release by\n.An Tatu Ylonen .\n.An Aaron Campbell , Bob Beck , Markus Friedl , Niels Provos , Theo de Raadt\nand\n.An Dug Song\nremoved many bugs, re-added newer features and created OpenSSH.\n.An Markus Friedl\ncontributed the support for SSH protocol versions 1.5 and 2.0.\n", "/* $OpenBSD: ssh-agent.c,v 1.299 2023/07/10 04:51:26 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * The authentication agent program.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <time.h>\n#include <unistd.h>\n#include <util.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"pathnames.h\"\n#include \"ssh-pkcs11.h\"\n#include \"sk-api.h\"\n#include \"myproposal.h\"\n\n#ifndef DEFAULT_ALLOWED_PROVIDERS\n# define DEFAULT_ALLOWED_PROVIDERS \"/usr/lib*/*,/usr/local/lib*/*\"\n#endif\n\n/* Maximum accepted message length */\n#define AGENT_MAX_LEN\t\t(256*1024)\n/* Maximum bytes to read from client socket */\n#define AGENT_RBUF_LEN\t\t(4096)\n/* Maximum number of recorded session IDs/hostkeys per connection */\n#define AGENT_MAX_SESSION_IDS\t\t16\n/* Maximum size of session ID */\n#define AGENT_MAX_SID_LEN\t\t128\n/* Maximum number of destination constraints to accept on a key */\n#define AGENT_MAX_DEST_CONSTRAINTS\t1024\n\n/* XXX store hostkey_sid in a refcounted tree */\n\ntypedef enum {\n\tAUTH_UNUSED = 0,\n\tAUTH_SOCKET = 1,\n\tAUTH_CONNECTION = 2,\n} sock_type;\n\nstruct hostkey_sid {\n\tstruct sshkey *key;\n\tstruct sshbuf *sid;\n\tint forwarded;\n};\n\ntypedef struct socket_entry {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n\tsize_t nsession_ids;\n\tstruct hostkey_sid *session_ids;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n\tchar *sk_provider;\n\tstruct dest_constraint *dest_constraints;\n\tsize_t ndest_constraints;\n} Identity;\n\nstruct idtable {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n};\n\n/* private key table */\nstruct idtable *idtab;\n\nint max_fd = 0;\n\n/* pid of shell == parent of agent */\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n/* pid of process for which cleanup_socket is applicable */\npid_t cleanup_pid = 0;\n\n/* pathname and directory for AUTH_SOCKET */\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n/* Pattern-list of allowed PKCS#11/Security key paths */\nstatic char *allowed_providers;\n\n/* locking */\n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n/* Default lifetime in seconds (0 == forever) */\nstatic int lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n/* Refuse signing of non-SSH messages for web-origin FIDO keys */\nstatic int restrict_websafe = 1;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tsize_t i;\n\n\tclose(e->fd);\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\tsshkey_free(e->session_ids[i].key);\n\t\tsshbuf_free(e->session_ids[i].sid);\n\t}\n\tfree(e->session_ids);\n\tmemset(e, '\\0', sizeof(*e));\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n}\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}\n\nstatic void\nfree_dest_constraint_hop(struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\n\tif (dch == NULL)\n\t\treturn;\n\tfree(dch->user);\n\tfree(dch->hostname);\n\tfor (i = 0; i < dch->nkeys; i++)\n\t\tsshkey_free(dch->keys[i]);\n\tfree(dch->keys);\n\tfree(dch->key_is_ca);\n}\n\nstatic void\nfree_dest_constraints(struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ndcs; i++) {\n\t\tfree_dest_constraint_hop(&dcs[i].from);\n\t\tfree_dest_constraint_hop(&dcs[i].to);\n\t}\n\tfree(dcs);\n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id->sk_provider);\n\tfree_dest_constraints(id->dest_constraints, id->ndest_constraints);\n\tfree(id);\n}\n\n/*\n * Match 'key' against the key/CA list in a destination constraint hop\n * Returns 0 on success or -1 otherwise.\n */\nstatic int\nmatch_key_hop(const char *tag, const struct sshkey *key,\n    const struct dest_constraint_hop *dch)\n{\n\tconst char *reason = NULL;\n\tconst char *hostname = dch->hostname ? dch->hostname : \"(ORIGIN)\";\n\tu_int i;\n\tchar *fp;\n\n\tif (key == NULL)\n\t\treturn -1;\n\t/* XXX logspam */\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\tdebug3_f(\"%s: entering hostname %s, requested key %s %s, %u keys avail\",\n\t    tag, hostname, sshkey_type(key), fp, dch->nkeys);\n\tfree(fp);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] == NULL)\n\t\t\treturn -1;\n\t\t/* XXX logspam */\n\t\tif ((fp = sshkey_fingerprint(dch->keys[i], SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"%s: key %u: %s%s %s\", tag, i,\n\t\t    dch->key_is_ca[i] ? \"CA \" : \"\",\n\t\t    sshkey_type(dch->keys[i]), fp);\n\t\tfree(fp);\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\t/* plain key */\n\t\t\tif (dch->key_is_ca[i] ||\n\t\t\t    !sshkey_equal(key, dch->keys[i]))\n\t\t\t\tcontinue;\n\t\t\treturn 0;\n\t\t}\n\t\t/* certificate */\n\t\tif (!dch->key_is_ca[i])\n\t\t\tcontinue;\n\t\tif (key->cert == NULL || key->cert->signature_key == NULL)\n\t\t\treturn -1; /* shouldn't happen */\n\t\tif (!sshkey_equal(key->cert->signature_key, dch->keys[i]))\n\t\t\tcontinue;\n\t\tif (sshkey_cert_check_host(key, hostname, 1,\n\t\t    SSH_ALLOWED_CA_SIGALGS, &reason) != 0) {\n\t\t\tdebug_f(\"cert %s / hostname %s rejected: %s\",\n\t\t\t    key->cert->key_id, hostname, reason);\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/* Check destination constraints on an identity against the hostkey/user */\nstatic int\npermitted_by_dest_constraints(const struct sshkey *fromkey,\n    const struct sshkey *tokey, Identity *id, const char *user,\n    const char **hostnamep)\n{\n\tsize_t i;\n\tstruct dest_constraint *d;\n\n\tif (hostnamep != NULL)\n\t\t*hostnamep = NULL;\n\tfor (i = 0; i < id->ndest_constraints; i++) {\n\t\td = id->dest_constraints + i;\n\t\t/* XXX remove logspam */\n\t\tdebug2_f(\"constraint %zu %s%s%s (%u keys) > %s%s%s (%u keys)\",\n\t\t    i, d->from.user ? d->from.user : \"\",\n\t\t    d->from.user ? \"@\" : \"\",\n\t\t    d->from.hostname ? d->from.hostname : \"(ORIGIN)\",\n\t\t    d->from.nkeys,\n\t\t    d->to.user ? d->to.user : \"\", d->to.user ? \"@\" : \"\",\n\t\t    d->to.hostname ? d->to.hostname : \"(ANY)\", d->to.nkeys);\n\n\t\t/* Match 'from' key */\n\t\tif (fromkey == NULL) {\n\t\t\t/* We are matching the first hop */\n\t\t\tif (d->from.hostname != NULL || d->from.nkeys != 0)\n\t\t\t\tcontinue;\n\t\t} else if (match_key_hop(\"from\", fromkey, &d->from) != 0)\n\t\t\tcontinue;\n\n\t\t/* Match 'to' key */\n\t\tif (tokey != NULL && match_key_hop(\"to\", tokey, &d->to) != 0)\n\t\t\tcontinue;\n\n\t\t/* Match user if specified */\n\t\tif (d->to.user != NULL && user != NULL &&\n\t\t    !match_pattern(user, d->to.user))\n\t\t\tcontinue;\n\n\t\t/* successfully matched this constraint */\n\t\tif (hostnamep != NULL)\n\t\t\t*hostnamep = d->to.hostname;\n\t\tdebug2_f(\"allowed for hostname %s\",\n\t\t    d->to.hostname == NULL ? \"*\" : d->to.hostname);\n\t\treturn 0;\n\t}\n\t/* no match */\n\tdebug2_f(\"%s identity \\\"%s\\\" not permitted for this destination\",\n\t    sshkey_type(id->key), id->comment);\n\treturn -1;\n}\n\n/*\n * Check whether hostkeys on a SocketEntry and the optionally specified user\n * are permitted by the destination constraints on the Identity.\n * Returns 0 on success or -1 otherwise.\n */\nstatic int\nidentity_permitted(Identity *id, SocketEntry *e, char *user,\n    const char **forward_hostnamep, const char **last_hostnamep)\n{\n\tsize_t i;\n\tconst char **hp;\n\tstruct hostkey_sid *hks;\n\tconst struct sshkey *fromkey = NULL;\n\tconst char *test_user;\n\tchar *fp1, *fp2;\n\n\t/* XXX remove logspam */\n\tdebug3_f(\"entering: key %s comment \\\"%s\\\", %zu socket bindings, \"\n\t    \"%zu constraints\", sshkey_type(id->key), id->comment,\n\t    e->nsession_ids, id->ndest_constraints);\n\tif (id->ndest_constraints == 0)\n\t\treturn 0; /* unconstrained */\n\tif (e->nsession_ids == 0)\n\t\treturn 0; /* local use */\n\t/*\n\t * Walk through the hops recorded by session_id and try to find a\n\t * constraint that satisfies each.\n\t */\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\thks = e->session_ids + i;\n\t\tif (hks->key == NULL)\n\t\t\tfatal_f(\"internal error: no bound key\");\n\t\t/* XXX remove logspam */\n\t\tfp1 = fp2 = NULL;\n\t\tif (fromkey != NULL &&\n\t\t    (fp1 = sshkey_fingerprint(fromkey, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tif ((fp2 = sshkey_fingerprint(hks->key, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"socketentry fd=%d, entry %zu %s, \"\n\t\t    \"from hostkey %s %s to user %s hostkey %s %s\",\n\t\t    e->fd, i, hks->forwarded ? \"FORWARD\" : \"AUTH\",\n\t\t    fromkey ? sshkey_type(fromkey) : \"(ORIGIN)\",\n\t\t    fromkey ? fp1 : \"\", user ? user : \"(ANY)\",\n\t\t    sshkey_type(hks->key), fp2);\n\t\tfree(fp1);\n\t\tfree(fp2);\n\t\t/*\n\t\t * Record the hostnames for the initial forwarding and\n\t\t * the final destination.\n\t\t */\n\t\thp = NULL;\n\t\tif (i == e->nsession_ids - 1)\n\t\t\thp = last_hostnamep;\n\t\telse if (i == 0)\n\t\t\thp = forward_hostnamep;\n\t\t/* Special handling for final recorded binding */\n\t\ttest_user = NULL;\n\t\tif (i == e->nsession_ids - 1) {\n\t\t\t/* Can only check user at final hop */\n\t\t\ttest_user = user;\n\t\t\t/*\n\t\t\t * user is only presented for signature requests.\n\t\t\t * If this is the case, make sure last binding is not\n\t\t\t * for a forwarding.\n\t\t\t */\n\t\t\tif (hks->forwarded && user != NULL) {\n\t\t\t\terror_f(\"tried to sign on forwarding hop\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!hks->forwarded) {\n\t\t\terror_f(\"tried to forward though signing bind\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (permitted_by_dest_constraints(fromkey, hks->key, id,\n\t\t    test_user, hp) != 0)\n\t\t\treturn -1;\n\t\tfromkey = hks->key;\n\t}\n\t/*\n\t * Another special case: if the last bound session ID was for a\n\t * forwarding, and this function is not being called to check a sign\n\t * request (i.e. no 'user' supplied), then only permit the key if\n\t * there is a permission that would allow it to be used at another\n\t * destination. This hides keys that are allowed to be used to\n\t * authenticate *to* a host but not permitted for *use* beyond it.\n\t */\n\thks = &e->session_ids[e->nsession_ids - 1];\n\tif (hks->forwarded && user == NULL &&\n\t    permitted_by_dest_constraints(hks->key, NULL, id,\n\t    NULL, NULL) != 0) {\n\t\tdebug3_f(\"key permitted at host but not after\");\n\t\treturn -1;\n\t}\n\n\t/* success */\n\treturn 0;\n}\n\n/* return matching private key for given public key */\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n/* Check confirmation of keysign request */\nstatic int\nconfirm_key(Identity *id, const char *extra)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.%s%s\",\n\t    id->comment, p,\n\t    extra == NULL ? \"\" : \"\\n\", extra == NULL ? \"\" : extra))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose\");\n}\n\n/* send list of supported public keys to 'client' */\nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\n\tdebug2_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\t/* identity not visible, don't include in response */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}\n\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t} else if (key->type == KEY_RSA_CERT) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256-cert-v01@openssh.com\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512-cert-v01@openssh.com\";\n\t}\n\treturn NULL;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSH publickey userauth\n * request, checking its contents for consistency and matching the embedded\n * key against the one that is being used for signing.\n * Note: does not modify msg buffer.\n * Optionally extract the username, session ID and/or hostkey from the request.\n */\nstatic int\nparse_userauth_request(struct sshbuf *msg, const struct sshkey *expected_key,\n    char **userp, struct sshbuf **sess_idp, struct sshkey **hostkeyp)\n{\n\tstruct sshbuf *b = NULL, *sess_id = NULL;\n\tchar *user = NULL, *service = NULL, *method = NULL, *pkalg = NULL;\n\tint r;\n\tu_char t, sig_follows;\n\tstruct sshkey *mkey = NULL, *hostkey = NULL;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (sess_idp != NULL)\n\t\t*sess_idp = NULL;\n\tif (hostkeyp != NULL)\n\t\t*hostkeyp = NULL;\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\t/* SSH userauth request */\n\tif ((r = sshbuf_froms(b, &sess_id)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(sess_id) == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u8(b, &t)) != 0 || /* SSH2_MSG_USERAUTH_REQUEST */\n\t    (r = sshbuf_get_cstring(b, &user, NULL)) != 0 || /* server user */\n\t    (r = sshbuf_get_cstring(b, &service, NULL)) != 0 || /* service */\n\t    (r = sshbuf_get_cstring(b, &method, NULL)) != 0 || /* method */\n\t    (r = sshbuf_get_u8(b, &sig_follows)) != 0 || /* sig-follows */\n\t    (r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 || /* alg */\n\t    (r = sshkey_froms(b, &mkey)) != 0) /* key */\n\t\tgoto out;\n\tif (t != SSH2_MSG_USERAUTH_REQUEST ||\n\t    sig_follows != 1 ||\n\t    strcmp(service, \"ssh-connection\") != 0 ||\n\t    !sshkey_equal(expected_key, mkey) ||\n\t    sshkey_type_from_name(pkalg) != expected_key->type) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(method, \"publickey-hostbound-v00@openssh.com\") == 0) {\n\t\tif ((r = sshkey_froms(b, &hostkey)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(method, \"publickey\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\tdebug3_f(\"well formed userauth\");\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (sess_idp != NULL) {\n\t\t*sess_idp = sess_id;\n\t\tsess_id = NULL;\n\t}\n\tif (hostkeyp != NULL) {\n\t\t*hostkeyp = hostkey;\n\t\thostkey = NULL;\n\t}\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(sess_id);\n\tfree(user);\n\tfree(service);\n\tfree(method);\n\tfree(pkalg);\n\tsshkey_free(mkey);\n\tsshkey_free(hostkey);\n\treturn r;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSHSIG signature request.\n * Note: does not modify buffer.\n */\nstatic int\nparse_sshsig_request(struct sshbuf *msg)\n{\n\tint r;\n\tstruct sshbuf *b;\n\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\tif ((r = sshbuf_cmp(b, 0, \"SSHSIG\", 6)) != 0 ||\n\t    (r = sshbuf_consume(b, 6)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* namespace */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0 || /* reserved */\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* hashalg */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0) /* H(msg) */\n\t\tgoto out;\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\n/*\n * This function inspects a message to be signed by a FIDO key that has a\n * web-like application string (i.e. one that does not begin with \"ssh:\".\n * It checks that the message is one of those expected for SSH operations\n * (pubkey userauth, sshsig, CA key signing) to exclude signing challenges\n * for the web.\n */\nstatic int\ncheck_websafe_message_contents(struct sshkey *key, struct sshbuf *data)\n{\n\tif (parse_userauth_request(data, key, NULL, NULL, NULL) == 0) {\n\t\tdebug_f(\"signed data matches public key userauth request\");\n\t\treturn 1;\n\t}\n\tif (parse_sshsig_request(data) == 0) {\n\t\tdebug_f(\"signed data matches SSHSIG signature request\");\n\t\treturn 1;\n\t}\n\n\t/* XXX check CA signature operation */\n\n\terror(\"web-origin key attempting to sign non-SSH message\");\n\treturn 0;\n}\n\nstatic int\nbuf_equal(const struct sshbuf *a, const struct sshbuf *b)\n{\n\tif (sshbuf_ptr(a) == NULL || sshbuf_ptr(b) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshbuf_len(a) != sshbuf_len(b))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (timingsafe_bcmp(sshbuf_ptr(a), sshbuf_ptr(b), sshbuf_len(a)) != 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn 0;\n}\n\n/* ssh2 only */\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *signature = NULL;\n\tsize_t slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1, retried = 0;\n\tchar *fp = NULL, *pin = NULL, *prompt = NULL;\n\tchar *user = NULL, *sig_dest = NULL;\n\tconst char *fwd_host = NULL, *dest_host = NULL;\n\tstruct sshbuf *msg = NULL, *data = NULL, *sid = NULL;\n\tstruct sshkey *key = NULL, *hostkey = NULL;\n\tstruct identity *id;\n\tstruct notifier_ctx *notifier = NULL;\n\n\tdebug_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (data = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_stringb(e->request, data)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose_f(\"%s key not found\", sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\n\tif (id->ndest_constraints != 0) {\n\t\tif (e->nsession_ids == 0) {\n\t\t\tlogit_f(\"refusing use of destination-constrained key \"\n\t\t\t    \"to sign on unbound connection\");\n\t\t\tgoto send;\n\t\t}\n\t\tif (parse_userauth_request(data, key, &user, &sid,\n\t\t    &hostkey) != 0) {\n\t\t\tlogit_f(\"refusing use of destination-constrained key \"\n\t\t\t   \"to sign an unidentified signature\");\n\t\t\tgoto send;\n\t\t}\n\t\t/* XXX logspam */\n\t\tdebug_f(\"user=%s\", user);\n\t\tif (identity_permitted(id, e, user, &fwd_host, &dest_host) != 0)\n\t\t\tgoto send;\n\t\t/* XXX display fwd_host/dest_host in askpass UI */\n\t\t/*\n\t\t * Ensure that the session ID is the most recent one\n\t\t * registered on the socket - it should have been bound by\n\t\t * ssh immediately before userauth.\n\t\t */\n\t\tif (buf_equal(sid,\n\t\t    e->session_ids[e->nsession_ids - 1].sid) != 0) {\n\t\t\terror_f(\"unexpected session ID (%zu listed) on \"\n\t\t\t    \"signature request for target user %s with \"\n\t\t\t    \"key %s %s\", e->nsession_ids, user,\n\t\t\t    sshkey_type(id->key), fp);\n\t\t\tgoto send;\n\t\t}\n\t\t/*\n\t\t * Ensure that the hostkey embedded in the signature matches\n\t\t * the one most recently bound to the socket. An exception is\n\t\t * made for the initial forwarding hop.\n\t\t */\n\t\tif (e->nsession_ids > 1 && hostkey == NULL) {\n\t\t\terror_f(\"refusing use of destination-constrained key: \"\n\t\t\t    \"no hostkey recorded in signature for forwarded \"\n\t\t\t    \"connection\");\n\t\t\tgoto send;\n\t\t}\n\t\tif (hostkey != NULL && !sshkey_equal(hostkey,\n\t\t    e->session_ids[e->nsession_ids - 1].key)) {\n\t\t\terror_f(\"refusing use of destination-constrained key: \"\n\t\t\t    \"mismatch between hostkey in request and most \"\n\t\t\t    \"recently bound session\");\n\t\t\tgoto send;\n\t\t}\n\t\txasprintf(&sig_dest, \"public key authentication request for \"\n\t\t    \"user \\\"%s\\\" to listed host\", user);\n\t}\n\tif (id->confirm && confirm_key(id, sig_dest) != 0) {\n\t\tverbose_f(\"user refused key\");\n\t\tgoto send;\n\t}\n\tif (sshkey_is_sk(id->key)) {\n\t\tif (restrict_websafe &&\n\t\t    strncmp(id->key->sk_application, \"ssh:\", 4) != 0 &&\n\t\t    !check_websafe_message_contents(key, data)) {\n\t\t\t/* error already logged */\n\t\t\tgoto send;\n\t\t}\n\t\tif (id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD) {\n\t\t\tnotifier = notify_start(0,\n\t\t\t    \"Confirm user presence for key %s %s%s%s\",\n\t\t\t    sshkey_type(id->key), fp,\n\t\t\t    sig_dest == NULL ? \"\" : \"\\n\",\n\t\t\t    sig_dest == NULL ? \"\" : sig_dest);\n\t\t}\n\t}\n retry_pin:\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    sshbuf_ptr(data), sshbuf_len(data), agent_decode_alg(key, flags),\n\t    id->sk_provider, pin, compat)) != 0) {\n\t\tdebug_fr(r, \"sshkey_sign\");\n\t\tif (pin == NULL && !retried && sshkey_is_sk(id->key) &&\n\t\t    r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\t\tnotify_complete(notifier, NULL);\n\t\t\tnotifier = NULL;\n\t\t\t/* XXX include sig_dest */\n\t\t\txasprintf(&prompt, \"Enter PIN%sfor %s key %s: \",\n\t\t\t    (id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD) ?\n\t\t\t    \" and confirm user presence \" : \" \",\n\t\t\t    sshkey_type(id->key), fp);\n\t\t\tpin = read_passphrase(prompt, RP_USE_ASKPASS);\n\t\t\tretried = 1;\n\t\t\tgoto retry_pin;\n\t\t}\n\t\terror_fr(r, \"sshkey_sign\");\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n\tdebug_f(\"good signature\");\n send:\n\tnotify_complete(notifier, \"User presence confirmed\");\n\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal_fr(r, \"compose\");\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose failure\");\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\n\tsshbuf_free(sid);\n\tsshbuf_free(data);\n\tsshbuf_free(msg);\n\tsshkey_free(key);\n\tsshkey_free(hostkey);\n\tfree(fp);\n\tfree(signature);\n\tfree(sig_dest);\n\tfree(user);\n\tfree(prompt);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n}\n\n/* shared */\nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror_fr(r, \"parse key\");\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug_f(\"key not found\");\n\t\tgoto done;\n\t}\n\t/* identity not visible, cannot be removed */\n\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\tgoto done; /* error already logged */\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal_f(\"internal error: nentries %d\", idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsuccess = 1;\n done:\n\tsshkey_free(key);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}\n\n/* removes expired keys and returns number of seconds until the next expiry */\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\nstatic int\nparse_dest_constraint_hop(struct sshbuf *b, struct dest_constraint_hop *dch)\n{\n\tu_char key_is_ca;\n\tsize_t elen = 0;\n\tint r;\n\tstruct sshkey *k = NULL;\n\tchar *fp;\n\n\tmemset(dch, '\\0', sizeof(*dch));\n\tif ((r = sshbuf_get_cstring(b, &dch->user, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &dch->hostname, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, NULL, &elen)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (elen != 0) {\n\t\terror_f(\"unsupported extensions (len %zu)\", elen);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (*dch->hostname == '\\0') {\n\t\tfree(dch->hostname);\n\t\tdch->hostname = NULL;\n\t}\n\tif (*dch->user == '\\0') {\n\t\tfree(dch->user);\n\t\tdch->user = NULL;\n\t}\n\twhile (sshbuf_len(b) != 0) {\n\t\tdch->keys = xrecallocarray(dch->keys, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->keys));\n\t\tdch->key_is_ca = xrecallocarray(dch->key_is_ca, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->key_is_ca));\n\t\tif ((r = sshkey_froms(b, &k)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &key_is_ca)) != 0)\n\t\t\tgoto out;\n\t\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"%s%s%s: adding %skey %s %s\",\n\t\t    dch->user == NULL ? \"\" : dch->user,\n\t\t    dch->user == NULL ? \"\" : \"@\",\n\t\t    dch->hostname, key_is_ca ? \"CA \" : \"\", sshkey_type(k), fp);\n\t\tfree(fp);\n\t\tdch->keys[dch->nkeys] = k;\n\t\tdch->key_is_ca[dch->nkeys] = key_is_ca != 0;\n\t\tdch->nkeys++;\n\t\tk = NULL; /* transferred */\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshkey_free(k);\n\treturn r;\n}\n\nstatic int\nparse_dest_constraint(struct sshbuf *m, struct dest_constraint *dc)\n{\n\tstruct sshbuf *b = NULL, *frombuf = NULL, *tobuf = NULL;\n\tint r;\n\tsize_t elen = 0;\n\n\tdebug3_f(\"entering\");\n\n\tmemset(dc, '\\0', sizeof(*dc));\n\tif ((r = sshbuf_froms(m, &b)) != 0 ||\n\t    (r = sshbuf_froms(b, &frombuf)) != 0 ||\n\t    (r = sshbuf_froms(b, &tobuf)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, NULL, &elen)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((r = parse_dest_constraint_hop(frombuf, &dc->from)) != 0 ||\n\t    (r = parse_dest_constraint_hop(tobuf, &dc->to)) != 0)\n\t\tgoto out; /* already logged */\n\tif (elen != 0) {\n\t\terror_f(\"unsupported extensions (len %zu)\", elen);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tdebug2_f(\"parsed %s (%u keys) > %s%s%s (%u keys)\",\n\t    dc->from.hostname ? dc->from.hostname : \"(ORIGIN)\", dc->from.nkeys,\n\t    dc->to.user ? dc->to.user : \"\", dc->to.user ? \"@\" : \"\",\n\t    dc->to.hostname ? dc->to.hostname : \"(ANY)\", dc->to.nkeys);\n\t/* check consistency */\n\tif ((dc->from.hostname == NULL) != (dc->from.nkeys == 0) ||\n\t    dc->from.user != NULL) {\n\t\terror_f(\"inconsistent \\\"from\\\" specification\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (dc->to.hostname == NULL || dc->to.nkeys == 0) {\n\t\terror_f(\"incomplete \\\"to\\\" specification\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(frombuf);\n\tsshbuf_free(tobuf);\n\treturn r;\n}\n\nstatic int\nparse_key_constraint_extension(struct sshbuf *m, char **sk_providerp,\n    struct dest_constraint **dcsp, size_t *ndcsp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\tstruct sshbuf *b = NULL;\n\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else if (strcmp(ext_name,\n\t    \"restrict-destination-v00@openssh.com\") == 0) {\n\t\tif (*dcsp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_froms(m, &b)) != 0) {\n\t\t\terror_fr(r, \"parse %s outer\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (sshbuf_len(b) != 0) {\n\t\t\tif (*ndcsp >= AGENT_MAX_DEST_CONSTRAINTS) {\n\t\t\t\terror_f(\"too many %s constraints\", ext_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*dcsp = xrecallocarray(*dcsp, *ndcsp, *ndcsp + 1,\n\t\t\t    sizeof(**dcsp));\n\t\t\tif ((r = parse_dest_constraint(b,\n\t\t\t    *dcsp + (*ndcsp)++)) != 0)\n\t\t\t\tgoto out; /* error already logged */\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tfree(ext_name);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nstatic int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp,\n    struct dest_constraint **dcsp, size_t *ndcsp)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = parse_key_constraint_extension(m,\n\t\t\t    sk_providerp, dcsp, ndcsp)) != 0)\n\t\t\t\tgoto out; /* error already logged */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* identity not visible, do not update */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tgoto out; /* error already logged */\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t\tfree_dest_constraints(id->dest_constraints,\n\t\t    id->ndest_constraints);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\tid->dest_constraints = dest_constraints;\n\tid->ndest_constraints = ndest_constraints;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s) (destination constraints: %zu)\",\n\t    sshkey_ssh_name(k), fp, comment, seconds, confirm,\n\t    sk_provider == NULL ? \"none\" : sk_provider, ndest_constraints);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tdest_constraints = NULL;\n\tndest_constraints = 0;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}\n\n/* XXX todo: encrypt sensitive data with passphrase */\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tdebug2_f(\"entering\");\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\tfreezero(passwd, pwlen);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsshbuf_free(msg);\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; /* transferred */\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug_f(\"remove %.100s\", canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror_f(\"pkcs11_del_provider failed\");\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif /* ENABLE_PKCS11 */\n\nstatic int\nprocess_ext_session_bind(SocketEntry *e)\n{\n\tint r, sid_match, key_match;\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *sid = NULL, *sig = NULL;\n\tchar *fp = NULL;\n\tsize_t i;\n\tu_char fwd = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_froms(e->request, &sid)) != 0 ||\n\t    (r = sshbuf_froms(e->request, &sig)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &fwd)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\t/* check signature with hostkey on session ID */\n\tif ((r = sshkey_verify(key, sshbuf_ptr(sig), sshbuf_len(sig),\n\t    sshbuf_ptr(sid), sshbuf_len(sid), NULL, 0, NULL)) != 0) {\n\t\terror_fr(r, \"sshkey_verify for %s %s\", sshkey_type(key), fp);\n\t\tgoto out;\n\t}\n\t/* check whether sid/key already recorded */\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\tif (!e->session_ids[i].forwarded) {\n\t\t\terror_f(\"attempt to bind session ID to socket \"\n\t\t\t    \"previously bound for authentication attempt\");\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsid_match = buf_equal(sid, e->session_ids[i].sid) == 0;\n\t\tkey_match = sshkey_equal(key, e->session_ids[i].key);\n\t\tif (sid_match && key_match) {\n\t\t\tdebug_f(\"session ID already recorded for %s %s\",\n\t\t\t    sshkey_type(key), fp);\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t} else if (sid_match) {\n\t\t\terror_f(\"session ID recorded against different key \"\n\t\t\t    \"for %s %s\", sshkey_type(key), fp);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * new sid with previously-seen key can happen, e.g. multiple\n\t\t * connections to the same host.\n\t\t */\n\t}\n\t/* record new key/sid */\n\tif (e->nsession_ids >= AGENT_MAX_SESSION_IDS) {\n\t\terror_f(\"too many session IDs recorded\");\n\t\tgoto out;\n\t}\n\te->session_ids = xrecallocarray(e->session_ids, e->nsession_ids,\n\t    e->nsession_ids + 1, sizeof(*e->session_ids));\n\ti = e->nsession_ids++;\n\tdebug_f(\"recorded %s %s (slot %zu of %d)\", sshkey_type(key), fp, i,\n\t    AGENT_MAX_SESSION_IDS);\n\te->session_ids[i].key = key;\n\te->session_ids[i].forwarded = fwd != 0;\n\tkey = NULL; /* transferred */\n\t/* can't transfer sid; it's refcounted and scoped to request's life */\n\tif ((e->session_ids[i].sid = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_putb(e->session_ids[i].sid, sid)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putb session ID\");\n\t/* success */\n\tr = 0;\n out:\n\tfree(fp);\n\tsshkey_free(key);\n\tsshbuf_free(sid);\n\tsshbuf_free(sig);\n\treturn r == 0 ? 1 : 0;\n}\n\nstatic void\nprocess_extension(SocketEntry *e)\n{\n\tint r, success = 0;\n\tchar *name;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &name, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (strcmp(name, \"session-bind@openssh.com\") == 0)\n\t\tsuccess = process_ext_session_bind(e);\n\telse\n\t\tdebug_f(\"unsupported extension \\\"%s\\\"\", name);\n\tfree(name);\nsend:\n\tsend_status(e, success);\n}\n/*\n * dispatch incoming message.\n * returns 1 on success, 0 for incomplete messages or -1 on error.\n */\nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc)\n\t\tfatal_f(\"sock %u >= allocated %u\", socknum, sockets_alloc);\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug_f(\"socket %u (fd=%d) message too long %u > %u\",\n\t\t    socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\treturn -1;\n\t\t}\n\t\tfatal_fr(r, \"parse\");\n\t}\n\n\tdebug_f(\"socket %u (fd=%d) type %d\", socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tcase SSH_AGENTC_EXTENSION:\n\t\tprocess_extension(e);\n\t\tbreak;\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tdebug_f(\"type = %s\", type == AUTH_CONNECTION ? \"CONNECTION\" :\n\t    (type == AUTH_SOCKET ? \"SOCKET\" : \"UNKNOWN\"));\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].output = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xrecallocarray(sockets, old_alloc, new_alloc,\n\t    sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].output = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd == -1) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) == -1) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[AGENT_RBUF_LEN];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\texplicit_bzero(buf, sizeof(buf));\n\tfor (;;) {\n\t\tif ((r = process_message(socknum)) == -1)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\treturn 0;\n}\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror_f(\"no socket for fd %d\", pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLHUP|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0)\n\t\t\t\tgoto close_sock;\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\tint r;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal_f(\"recallocarray failed\");\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/*\n\t\t\t * Only prepare to read if we can handle a full-size\n\t\t\t * input read buffer and enqueue a max size reply..\n\t\t\t */\n\t\t\tif ((r = sshbuf_check_reserve(sockets[i].input,\n\t\t\t    AGENT_RBUF_LEN)) == 0 &&\n\t\t\t    (r = sshbuf_check_reserve(sockets[i].output,\n\t\t\t    AGENT_MAX_LEN)) == 0)\n\t\t\t\tpfd[j].events = POLLIN;\n\t\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\t\tfatal_fr(r, \"reserve\");\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug_f(\"cleanup\");\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-O option] [-P allowed_providers] [-t life]\\n\"\n\t    \"       ssh-agent [-a bind_address] [-E fingerprint_hash] [-O option]\\n\"\n\t    \"                 [-P allowed_providers] [-t life] command [arg ...]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\t(void)setegid(getgid());\n\t(void)setgid(getgid());\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe  = 0;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}\n"], "fixing_code": [".\\\" $OpenBSD: ssh-agent.1,v 1.76 2023/07/19 13:56:33 djm Exp $\n.\\\"\n.\\\" Author: Tatu Ylonen <ylo@cs.hut.fi>\n.\\\" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n.\\\"                    All rights reserved\n.\\\"\n.\\\" As far as I am concerned, the code I have written for this software\n.\\\" can be used freely for any purpose.  Any derived versions of this\n.\\\" software must be clearly marked as such, and if the derived work is\n.\\\" incompatible with the protocol description in the RFC file, it must be\n.\\\" called by a name other than \"ssh\" or \"Secure Shell\".\n.\\\"\n.\\\" Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.\n.\\\" Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n.\\\" Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that the following conditions\n.\\\" are met:\n.\\\" 1. Redistributions of source code must retain the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer.\n.\\\" 2. Redistributions in binary form must reproduce the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer in the\n.\\\"    documentation and/or other materials provided with the distribution.\n.\\\"\n.\\\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n.\\\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n.\\\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n.\\\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n.\\\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n.\\\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n.\\\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n.\\\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n.\\\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n.\\\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n.\\\"\n.Dd $Mdocdate: July 19 2023 $\n.Dt SSH-AGENT 1\n.Os\n.Sh NAME\n.Nm ssh-agent\n.Nd OpenSSH authentication agent\n.Sh SYNOPSIS\n.Nm ssh-agent\n.Op Fl c | s\n.Op Fl \\&Dd\n.Op Fl a Ar bind_address\n.Op Fl E Ar fingerprint_hash\n.Op Fl O Ar option\n.Op Fl P Ar allowed_providers\n.Op Fl t Ar life\n.Nm ssh-agent\n.Op Fl a Ar bind_address\n.Op Fl E Ar fingerprint_hash\n.Op Fl O Ar option\n.Op Fl P Ar allowed_providers\n.Op Fl t Ar life\n.Ar command Op Ar arg ...\n.Nm ssh-agent\n.Op Fl c | s\n.Fl k\n.Sh DESCRIPTION\n.Nm\nis a program to hold private keys used for public key authentication.\nThrough use of environment variables the agent can be located\nand automatically used for authentication when logging in to other\nmachines using\n.Xr ssh 1 .\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl a Ar bind_address\nBind the agent to the\n.Ux Ns -domain\nsocket\n.Ar bind_address .\nThe default is\n.Pa $TMPDIR/ssh-XXXXXXXXXX/agent.\\*(Ltppid\\*(Gt .\n.It Fl c\nGenerate C-shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\nlooks like it's a csh style of shell.\n.It Fl D\nForeground mode.\nWhen this option is specified,\n.Nm\nwill not fork.\n.It Fl d\nDebug mode.\nWhen this option is specified,\n.Nm\nwill not fork and will write debug information to standard error.\n.It Fl E Ar fingerprint_hash\nSpecifies the hash algorithm used when displaying key fingerprints.\nValid options are:\n.Dq md5\nand\n.Dq sha256 .\nThe default is\n.Dq sha256 .\n.It Fl k\nKill the current agent (given by the\n.Ev SSH_AGENT_PID\nenvironment variable).\n.It Fl O Ar option\nSpecify an option when starting\n.Nm .\nCurrently two options are supported:\n.Cm allow-remote-pkcs11\nand\n.Cm no-restrict-websafe .\n.Pp\nThe\n.Cm allow-remote-pkcs11\noption allows clients of a forwarded\n.Nm\nto load PKCS#11 or FIDO provider libraries.\nBy default only local clients may perform this operation.\nNote that signalling that a\n.Nm\nclient remote is performed by\n.Xr ssh 1 ,\nand use of other tools to forward access to the agent socket may circumvent\nthis restriction.\n.Pp\nThe\n.Cm no-restrict-websafe ,\ninstructs\n.Nm\nto permit signatures using FIDO keys that might be web authentication\nrequests.\nBy default,\n.Nm\nrefuses signature requests for FIDO keys where the key application string\ndoes not start with\n.Dq ssh:\nand when the data to be signed does not appear to be a\n.Xr ssh 1\nuser authentication request or a\n.Xr ssh-keygen 1\nsignature.\nThe default behaviour prevents forwarded access to a FIDO key from also\nimplicitly forwarding the ability to authenticate to websites.\n.It Fl P Ar allowed_providers\nSpecify a pattern-list of acceptable paths for PKCS#11 provider and FIDO\nauthenticator middleware shared libraries that may be used with the\n.Fl S\nor\n.Fl s\noptions to\n.Xr ssh-add 1 .\nLibraries that do not match the pattern list will be refused.\nSee PATTERNS in\n.Xr ssh_config 5\nfor a description of pattern-list syntax.\nThe default list is\n.Dq /usr/lib/*,/usr/local/lib/* .\n.It Fl s\nGenerate Bourne shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\ndoes not look like it's a csh style of shell.\n.It Fl t Ar life\nSet a default value for the maximum lifetime of identities added to the agent.\nThe lifetime may be specified in seconds or in a time format specified in\n.Xr sshd_config 5 .\nA lifetime specified for an identity with\n.Xr ssh-add 1\noverrides this value.\nWithout this option the default maximum lifetime is forever.\n.It Ar command Op Ar arg ...\nIf a command (and optional arguments) is given,\nthis is executed as a subprocess of the agent.\nThe agent exits automatically when the command given on the command\nline terminates.\n.El\n.Pp\nThere are two main ways to get an agent set up.\nThe first is at the start of an X session,\nwhere all other windows or programs are started as children of the\n.Nm\nprogram.\nThe agent starts a command under which its environment\nvariables are exported, for example\n.Cm ssh-agent xterm & .\nWhen the command terminates, so does the agent.\n.Pp\nThe second method is used for a login session.\nWhen\n.Nm\nis started,\nit prints the shell commands required to set its environment variables,\nwhich in turn can be evaluated in the calling shell, for example\n.Cm eval `ssh-agent -s` .\n.Pp\nIn both cases,\n.Xr ssh 1\nlooks at these environment variables\nand uses them to establish a connection to the agent.\n.Pp\nThe agent initially does not have any private keys.\nKeys are added using\n.Xr ssh-add 1\nor by\n.Xr ssh 1\nwhen\n.Cm AddKeysToAgent\nis set in\n.Xr ssh_config 5 .\nMultiple identities may be stored in\n.Nm\nconcurrently and\n.Xr ssh 1\nwill automatically use them if present.\n.Xr ssh-add 1\nis also used to remove keys from\n.Nm\nand to query the keys that are held in one.\n.Pp\nConnections to\n.Nm\nmay be forwarded from further remote hosts using the\n.Fl A\noption to\n.Xr ssh 1\n(but see the caveats documented therein),\navoiding the need for authentication data to be stored on other machines.\nAuthentication passphrases and private keys never go over the network:\nthe connection to the agent is forwarded over SSH remote connections\nand the result is returned to the requester,\nallowing the user access to their identities anywhere in the network\nin a secure fashion.\n.Sh ENVIRONMENT\n.Bl -tag -width \"SSH_AGENT_PID\"\n.It Ev SSH_AGENT_PID\nWhen\n.Nm\nstarts, it stores the name of the agent's process ID (PID) in this variable.\n.It Ev SSH_AUTH_SOCK\nWhen\n.Nm\nstarts, it creates a\n.Ux Ns -domain\nsocket and stores its pathname in this variable.\nIt is accessible only to the current user,\nbut is easily abused by root or another instance of the same user.\n.El\n.Sh FILES\n.Bl -tag -width Ds\n.It Pa $TMPDIR/ssh-XXXXXXXXXX/agent.<ppid>\n.Ux Ns -domain\nsockets used to contain the connection to the authentication agent.\nThese sockets should only be readable by the owner.\nThe sockets should get automatically removed when the agent exits.\n.El\n.Sh SEE ALSO\n.Xr ssh 1 ,\n.Xr ssh-add 1 ,\n.Xr ssh-keygen 1 ,\n.Xr ssh_config 5 ,\n.Xr sshd 8\n.Sh AUTHORS\n.An -nosplit\nOpenSSH is a derivative of the original and free ssh 1.2.12 release by\n.An Tatu Ylonen .\n.An Aaron Campbell , Bob Beck , Markus Friedl , Niels Provos , Theo de Raadt\nand\n.An Dug Song\nremoved many bugs, re-added newer features and created OpenSSH.\n.An Markus Friedl\ncontributed the support for SSH protocol versions 1.5 and 2.0.\n", "/* $OpenBSD: ssh-agent.c,v 1.300 2023/07/19 13:56:33 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * The authentication agent program.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <time.h>\n#include <unistd.h>\n#include <util.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"pathnames.h\"\n#include \"ssh-pkcs11.h\"\n#include \"sk-api.h\"\n#include \"myproposal.h\"\n\n#ifndef DEFAULT_ALLOWED_PROVIDERS\n# define DEFAULT_ALLOWED_PROVIDERS \"/usr/lib*/*,/usr/local/lib*/*\"\n#endif\n\n/* Maximum accepted message length */\n#define AGENT_MAX_LEN\t\t(256*1024)\n/* Maximum bytes to read from client socket */\n#define AGENT_RBUF_LEN\t\t(4096)\n/* Maximum number of recorded session IDs/hostkeys per connection */\n#define AGENT_MAX_SESSION_IDS\t\t16\n/* Maximum size of session ID */\n#define AGENT_MAX_SID_LEN\t\t128\n/* Maximum number of destination constraints to accept on a key */\n#define AGENT_MAX_DEST_CONSTRAINTS\t1024\n\n/* XXX store hostkey_sid in a refcounted tree */\n\ntypedef enum {\n\tAUTH_UNUSED = 0,\n\tAUTH_SOCKET = 1,\n\tAUTH_CONNECTION = 2,\n} sock_type;\n\nstruct hostkey_sid {\n\tstruct sshkey *key;\n\tstruct sshbuf *sid;\n\tint forwarded;\n};\n\ntypedef struct socket_entry {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n\tsize_t nsession_ids;\n\tstruct hostkey_sid *session_ids;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n\tchar *sk_provider;\n\tstruct dest_constraint *dest_constraints;\n\tsize_t ndest_constraints;\n} Identity;\n\nstruct idtable {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n};\n\n/* private key table */\nstruct idtable *idtab;\n\nint max_fd = 0;\n\n/* pid of shell == parent of agent */\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n/* pid of process for which cleanup_socket is applicable */\npid_t cleanup_pid = 0;\n\n/* pathname and directory for AUTH_SOCKET */\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n/* Pattern-list of allowed PKCS#11/Security key paths */\nstatic char *allowed_providers;\n\n/*\n * Allows PKCS11 providers or SK keys that use non-internal providers to\n * be added over a remote connection (identified by session-bind@openssh.com).\n */\nstatic int remote_add_provider;\n\n/* locking */\n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n/* Default lifetime in seconds (0 == forever) */\nstatic int lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n/* Refuse signing of non-SSH messages for web-origin FIDO keys */\nstatic int restrict_websafe = 1;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tsize_t i;\n\n\tclose(e->fd);\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\tsshkey_free(e->session_ids[i].key);\n\t\tsshbuf_free(e->session_ids[i].sid);\n\t}\n\tfree(e->session_ids);\n\tmemset(e, '\\0', sizeof(*e));\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n}\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}\n\nstatic void\nfree_dest_constraint_hop(struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\n\tif (dch == NULL)\n\t\treturn;\n\tfree(dch->user);\n\tfree(dch->hostname);\n\tfor (i = 0; i < dch->nkeys; i++)\n\t\tsshkey_free(dch->keys[i]);\n\tfree(dch->keys);\n\tfree(dch->key_is_ca);\n}\n\nstatic void\nfree_dest_constraints(struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ndcs; i++) {\n\t\tfree_dest_constraint_hop(&dcs[i].from);\n\t\tfree_dest_constraint_hop(&dcs[i].to);\n\t}\n\tfree(dcs);\n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id->sk_provider);\n\tfree_dest_constraints(id->dest_constraints, id->ndest_constraints);\n\tfree(id);\n}\n\n/*\n * Match 'key' against the key/CA list in a destination constraint hop\n * Returns 0 on success or -1 otherwise.\n */\nstatic int\nmatch_key_hop(const char *tag, const struct sshkey *key,\n    const struct dest_constraint_hop *dch)\n{\n\tconst char *reason = NULL;\n\tconst char *hostname = dch->hostname ? dch->hostname : \"(ORIGIN)\";\n\tu_int i;\n\tchar *fp;\n\n\tif (key == NULL)\n\t\treturn -1;\n\t/* XXX logspam */\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\tdebug3_f(\"%s: entering hostname %s, requested key %s %s, %u keys avail\",\n\t    tag, hostname, sshkey_type(key), fp, dch->nkeys);\n\tfree(fp);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] == NULL)\n\t\t\treturn -1;\n\t\t/* XXX logspam */\n\t\tif ((fp = sshkey_fingerprint(dch->keys[i], SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"%s: key %u: %s%s %s\", tag, i,\n\t\t    dch->key_is_ca[i] ? \"CA \" : \"\",\n\t\t    sshkey_type(dch->keys[i]), fp);\n\t\tfree(fp);\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\t/* plain key */\n\t\t\tif (dch->key_is_ca[i] ||\n\t\t\t    !sshkey_equal(key, dch->keys[i]))\n\t\t\t\tcontinue;\n\t\t\treturn 0;\n\t\t}\n\t\t/* certificate */\n\t\tif (!dch->key_is_ca[i])\n\t\t\tcontinue;\n\t\tif (key->cert == NULL || key->cert->signature_key == NULL)\n\t\t\treturn -1; /* shouldn't happen */\n\t\tif (!sshkey_equal(key->cert->signature_key, dch->keys[i]))\n\t\t\tcontinue;\n\t\tif (sshkey_cert_check_host(key, hostname, 1,\n\t\t    SSH_ALLOWED_CA_SIGALGS, &reason) != 0) {\n\t\t\tdebug_f(\"cert %s / hostname %s rejected: %s\",\n\t\t\t    key->cert->key_id, hostname, reason);\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/* Check destination constraints on an identity against the hostkey/user */\nstatic int\npermitted_by_dest_constraints(const struct sshkey *fromkey,\n    const struct sshkey *tokey, Identity *id, const char *user,\n    const char **hostnamep)\n{\n\tsize_t i;\n\tstruct dest_constraint *d;\n\n\tif (hostnamep != NULL)\n\t\t*hostnamep = NULL;\n\tfor (i = 0; i < id->ndest_constraints; i++) {\n\t\td = id->dest_constraints + i;\n\t\t/* XXX remove logspam */\n\t\tdebug2_f(\"constraint %zu %s%s%s (%u keys) > %s%s%s (%u keys)\",\n\t\t    i, d->from.user ? d->from.user : \"\",\n\t\t    d->from.user ? \"@\" : \"\",\n\t\t    d->from.hostname ? d->from.hostname : \"(ORIGIN)\",\n\t\t    d->from.nkeys,\n\t\t    d->to.user ? d->to.user : \"\", d->to.user ? \"@\" : \"\",\n\t\t    d->to.hostname ? d->to.hostname : \"(ANY)\", d->to.nkeys);\n\n\t\t/* Match 'from' key */\n\t\tif (fromkey == NULL) {\n\t\t\t/* We are matching the first hop */\n\t\t\tif (d->from.hostname != NULL || d->from.nkeys != 0)\n\t\t\t\tcontinue;\n\t\t} else if (match_key_hop(\"from\", fromkey, &d->from) != 0)\n\t\t\tcontinue;\n\n\t\t/* Match 'to' key */\n\t\tif (tokey != NULL && match_key_hop(\"to\", tokey, &d->to) != 0)\n\t\t\tcontinue;\n\n\t\t/* Match user if specified */\n\t\tif (d->to.user != NULL && user != NULL &&\n\t\t    !match_pattern(user, d->to.user))\n\t\t\tcontinue;\n\n\t\t/* successfully matched this constraint */\n\t\tif (hostnamep != NULL)\n\t\t\t*hostnamep = d->to.hostname;\n\t\tdebug2_f(\"allowed for hostname %s\",\n\t\t    d->to.hostname == NULL ? \"*\" : d->to.hostname);\n\t\treturn 0;\n\t}\n\t/* no match */\n\tdebug2_f(\"%s identity \\\"%s\\\" not permitted for this destination\",\n\t    sshkey_type(id->key), id->comment);\n\treturn -1;\n}\n\n/*\n * Check whether hostkeys on a SocketEntry and the optionally specified user\n * are permitted by the destination constraints on the Identity.\n * Returns 0 on success or -1 otherwise.\n */\nstatic int\nidentity_permitted(Identity *id, SocketEntry *e, char *user,\n    const char **forward_hostnamep, const char **last_hostnamep)\n{\n\tsize_t i;\n\tconst char **hp;\n\tstruct hostkey_sid *hks;\n\tconst struct sshkey *fromkey = NULL;\n\tconst char *test_user;\n\tchar *fp1, *fp2;\n\n\t/* XXX remove logspam */\n\tdebug3_f(\"entering: key %s comment \\\"%s\\\", %zu socket bindings, \"\n\t    \"%zu constraints\", sshkey_type(id->key), id->comment,\n\t    e->nsession_ids, id->ndest_constraints);\n\tif (id->ndest_constraints == 0)\n\t\treturn 0; /* unconstrained */\n\tif (e->nsession_ids == 0)\n\t\treturn 0; /* local use */\n\t/*\n\t * Walk through the hops recorded by session_id and try to find a\n\t * constraint that satisfies each.\n\t */\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\thks = e->session_ids + i;\n\t\tif (hks->key == NULL)\n\t\t\tfatal_f(\"internal error: no bound key\");\n\t\t/* XXX remove logspam */\n\t\tfp1 = fp2 = NULL;\n\t\tif (fromkey != NULL &&\n\t\t    (fp1 = sshkey_fingerprint(fromkey, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tif ((fp2 = sshkey_fingerprint(hks->key, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"socketentry fd=%d, entry %zu %s, \"\n\t\t    \"from hostkey %s %s to user %s hostkey %s %s\",\n\t\t    e->fd, i, hks->forwarded ? \"FORWARD\" : \"AUTH\",\n\t\t    fromkey ? sshkey_type(fromkey) : \"(ORIGIN)\",\n\t\t    fromkey ? fp1 : \"\", user ? user : \"(ANY)\",\n\t\t    sshkey_type(hks->key), fp2);\n\t\tfree(fp1);\n\t\tfree(fp2);\n\t\t/*\n\t\t * Record the hostnames for the initial forwarding and\n\t\t * the final destination.\n\t\t */\n\t\thp = NULL;\n\t\tif (i == e->nsession_ids - 1)\n\t\t\thp = last_hostnamep;\n\t\telse if (i == 0)\n\t\t\thp = forward_hostnamep;\n\t\t/* Special handling for final recorded binding */\n\t\ttest_user = NULL;\n\t\tif (i == e->nsession_ids - 1) {\n\t\t\t/* Can only check user at final hop */\n\t\t\ttest_user = user;\n\t\t\t/*\n\t\t\t * user is only presented for signature requests.\n\t\t\t * If this is the case, make sure last binding is not\n\t\t\t * for a forwarding.\n\t\t\t */\n\t\t\tif (hks->forwarded && user != NULL) {\n\t\t\t\terror_f(\"tried to sign on forwarding hop\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!hks->forwarded) {\n\t\t\terror_f(\"tried to forward though signing bind\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (permitted_by_dest_constraints(fromkey, hks->key, id,\n\t\t    test_user, hp) != 0)\n\t\t\treturn -1;\n\t\tfromkey = hks->key;\n\t}\n\t/*\n\t * Another special case: if the last bound session ID was for a\n\t * forwarding, and this function is not being called to check a sign\n\t * request (i.e. no 'user' supplied), then only permit the key if\n\t * there is a permission that would allow it to be used at another\n\t * destination. This hides keys that are allowed to be used to\n\t * authenticate *to* a host but not permitted for *use* beyond it.\n\t */\n\thks = &e->session_ids[e->nsession_ids - 1];\n\tif (hks->forwarded && user == NULL &&\n\t    permitted_by_dest_constraints(hks->key, NULL, id,\n\t    NULL, NULL) != 0) {\n\t\tdebug3_f(\"key permitted at host but not after\");\n\t\treturn -1;\n\t}\n\n\t/* success */\n\treturn 0;\n}\n\n/* return matching private key for given public key */\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n/* Check confirmation of keysign request */\nstatic int\nconfirm_key(Identity *id, const char *extra)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.%s%s\",\n\t    id->comment, p,\n\t    extra == NULL ? \"\" : \"\\n\", extra == NULL ? \"\" : extra))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose\");\n}\n\n/* send list of supported public keys to 'client' */\nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\n\tdebug2_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\t/* identity not visible, don't include in response */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}\n\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t} else if (key->type == KEY_RSA_CERT) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256-cert-v01@openssh.com\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512-cert-v01@openssh.com\";\n\t}\n\treturn NULL;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSH publickey userauth\n * request, checking its contents for consistency and matching the embedded\n * key against the one that is being used for signing.\n * Note: does not modify msg buffer.\n * Optionally extract the username, session ID and/or hostkey from the request.\n */\nstatic int\nparse_userauth_request(struct sshbuf *msg, const struct sshkey *expected_key,\n    char **userp, struct sshbuf **sess_idp, struct sshkey **hostkeyp)\n{\n\tstruct sshbuf *b = NULL, *sess_id = NULL;\n\tchar *user = NULL, *service = NULL, *method = NULL, *pkalg = NULL;\n\tint r;\n\tu_char t, sig_follows;\n\tstruct sshkey *mkey = NULL, *hostkey = NULL;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (sess_idp != NULL)\n\t\t*sess_idp = NULL;\n\tif (hostkeyp != NULL)\n\t\t*hostkeyp = NULL;\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\t/* SSH userauth request */\n\tif ((r = sshbuf_froms(b, &sess_id)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(sess_id) == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u8(b, &t)) != 0 || /* SSH2_MSG_USERAUTH_REQUEST */\n\t    (r = sshbuf_get_cstring(b, &user, NULL)) != 0 || /* server user */\n\t    (r = sshbuf_get_cstring(b, &service, NULL)) != 0 || /* service */\n\t    (r = sshbuf_get_cstring(b, &method, NULL)) != 0 || /* method */\n\t    (r = sshbuf_get_u8(b, &sig_follows)) != 0 || /* sig-follows */\n\t    (r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 || /* alg */\n\t    (r = sshkey_froms(b, &mkey)) != 0) /* key */\n\t\tgoto out;\n\tif (t != SSH2_MSG_USERAUTH_REQUEST ||\n\t    sig_follows != 1 ||\n\t    strcmp(service, \"ssh-connection\") != 0 ||\n\t    !sshkey_equal(expected_key, mkey) ||\n\t    sshkey_type_from_name(pkalg) != expected_key->type) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(method, \"publickey-hostbound-v00@openssh.com\") == 0) {\n\t\tif ((r = sshkey_froms(b, &hostkey)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(method, \"publickey\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\tdebug3_f(\"well formed userauth\");\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (sess_idp != NULL) {\n\t\t*sess_idp = sess_id;\n\t\tsess_id = NULL;\n\t}\n\tif (hostkeyp != NULL) {\n\t\t*hostkeyp = hostkey;\n\t\thostkey = NULL;\n\t}\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(sess_id);\n\tfree(user);\n\tfree(service);\n\tfree(method);\n\tfree(pkalg);\n\tsshkey_free(mkey);\n\tsshkey_free(hostkey);\n\treturn r;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSHSIG signature request.\n * Note: does not modify buffer.\n */\nstatic int\nparse_sshsig_request(struct sshbuf *msg)\n{\n\tint r;\n\tstruct sshbuf *b;\n\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\tif ((r = sshbuf_cmp(b, 0, \"SSHSIG\", 6)) != 0 ||\n\t    (r = sshbuf_consume(b, 6)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* namespace */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0 || /* reserved */\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* hashalg */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0) /* H(msg) */\n\t\tgoto out;\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\n/*\n * This function inspects a message to be signed by a FIDO key that has a\n * web-like application string (i.e. one that does not begin with \"ssh:\".\n * It checks that the message is one of those expected for SSH operations\n * (pubkey userauth, sshsig, CA key signing) to exclude signing challenges\n * for the web.\n */\nstatic int\ncheck_websafe_message_contents(struct sshkey *key, struct sshbuf *data)\n{\n\tif (parse_userauth_request(data, key, NULL, NULL, NULL) == 0) {\n\t\tdebug_f(\"signed data matches public key userauth request\");\n\t\treturn 1;\n\t}\n\tif (parse_sshsig_request(data) == 0) {\n\t\tdebug_f(\"signed data matches SSHSIG signature request\");\n\t\treturn 1;\n\t}\n\n\t/* XXX check CA signature operation */\n\n\terror(\"web-origin key attempting to sign non-SSH message\");\n\treturn 0;\n}\n\nstatic int\nbuf_equal(const struct sshbuf *a, const struct sshbuf *b)\n{\n\tif (sshbuf_ptr(a) == NULL || sshbuf_ptr(b) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshbuf_len(a) != sshbuf_len(b))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (timingsafe_bcmp(sshbuf_ptr(a), sshbuf_ptr(b), sshbuf_len(a)) != 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn 0;\n}\n\n/* ssh2 only */\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *signature = NULL;\n\tsize_t slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1, retried = 0;\n\tchar *fp = NULL, *pin = NULL, *prompt = NULL;\n\tchar *user = NULL, *sig_dest = NULL;\n\tconst char *fwd_host = NULL, *dest_host = NULL;\n\tstruct sshbuf *msg = NULL, *data = NULL, *sid = NULL;\n\tstruct sshkey *key = NULL, *hostkey = NULL;\n\tstruct identity *id;\n\tstruct notifier_ctx *notifier = NULL;\n\n\tdebug_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (data = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_stringb(e->request, data)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose_f(\"%s key not found\", sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\n\tif (id->ndest_constraints != 0) {\n\t\tif (e->nsession_ids == 0) {\n\t\t\tlogit_f(\"refusing use of destination-constrained key \"\n\t\t\t    \"to sign on unbound connection\");\n\t\t\tgoto send;\n\t\t}\n\t\tif (parse_userauth_request(data, key, &user, &sid,\n\t\t    &hostkey) != 0) {\n\t\t\tlogit_f(\"refusing use of destination-constrained key \"\n\t\t\t   \"to sign an unidentified signature\");\n\t\t\tgoto send;\n\t\t}\n\t\t/* XXX logspam */\n\t\tdebug_f(\"user=%s\", user);\n\t\tif (identity_permitted(id, e, user, &fwd_host, &dest_host) != 0)\n\t\t\tgoto send;\n\t\t/* XXX display fwd_host/dest_host in askpass UI */\n\t\t/*\n\t\t * Ensure that the session ID is the most recent one\n\t\t * registered on the socket - it should have been bound by\n\t\t * ssh immediately before userauth.\n\t\t */\n\t\tif (buf_equal(sid,\n\t\t    e->session_ids[e->nsession_ids - 1].sid) != 0) {\n\t\t\terror_f(\"unexpected session ID (%zu listed) on \"\n\t\t\t    \"signature request for target user %s with \"\n\t\t\t    \"key %s %s\", e->nsession_ids, user,\n\t\t\t    sshkey_type(id->key), fp);\n\t\t\tgoto send;\n\t\t}\n\t\t/*\n\t\t * Ensure that the hostkey embedded in the signature matches\n\t\t * the one most recently bound to the socket. An exception is\n\t\t * made for the initial forwarding hop.\n\t\t */\n\t\tif (e->nsession_ids > 1 && hostkey == NULL) {\n\t\t\terror_f(\"refusing use of destination-constrained key: \"\n\t\t\t    \"no hostkey recorded in signature for forwarded \"\n\t\t\t    \"connection\");\n\t\t\tgoto send;\n\t\t}\n\t\tif (hostkey != NULL && !sshkey_equal(hostkey,\n\t\t    e->session_ids[e->nsession_ids - 1].key)) {\n\t\t\terror_f(\"refusing use of destination-constrained key: \"\n\t\t\t    \"mismatch between hostkey in request and most \"\n\t\t\t    \"recently bound session\");\n\t\t\tgoto send;\n\t\t}\n\t\txasprintf(&sig_dest, \"public key authentication request for \"\n\t\t    \"user \\\"%s\\\" to listed host\", user);\n\t}\n\tif (id->confirm && confirm_key(id, sig_dest) != 0) {\n\t\tverbose_f(\"user refused key\");\n\t\tgoto send;\n\t}\n\tif (sshkey_is_sk(id->key)) {\n\t\tif (restrict_websafe &&\n\t\t    strncmp(id->key->sk_application, \"ssh:\", 4) != 0 &&\n\t\t    !check_websafe_message_contents(key, data)) {\n\t\t\t/* error already logged */\n\t\t\tgoto send;\n\t\t}\n\t\tif (id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD) {\n\t\t\tnotifier = notify_start(0,\n\t\t\t    \"Confirm user presence for key %s %s%s%s\",\n\t\t\t    sshkey_type(id->key), fp,\n\t\t\t    sig_dest == NULL ? \"\" : \"\\n\",\n\t\t\t    sig_dest == NULL ? \"\" : sig_dest);\n\t\t}\n\t}\n retry_pin:\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    sshbuf_ptr(data), sshbuf_len(data), agent_decode_alg(key, flags),\n\t    id->sk_provider, pin, compat)) != 0) {\n\t\tdebug_fr(r, \"sshkey_sign\");\n\t\tif (pin == NULL && !retried && sshkey_is_sk(id->key) &&\n\t\t    r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\t\tnotify_complete(notifier, NULL);\n\t\t\tnotifier = NULL;\n\t\t\t/* XXX include sig_dest */\n\t\t\txasprintf(&prompt, \"Enter PIN%sfor %s key %s: \",\n\t\t\t    (id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD) ?\n\t\t\t    \" and confirm user presence \" : \" \",\n\t\t\t    sshkey_type(id->key), fp);\n\t\t\tpin = read_passphrase(prompt, RP_USE_ASKPASS);\n\t\t\tretried = 1;\n\t\t\tgoto retry_pin;\n\t\t}\n\t\terror_fr(r, \"sshkey_sign\");\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n\tdebug_f(\"good signature\");\n send:\n\tnotify_complete(notifier, \"User presence confirmed\");\n\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal_fr(r, \"compose\");\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose failure\");\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\n\tsshbuf_free(sid);\n\tsshbuf_free(data);\n\tsshbuf_free(msg);\n\tsshkey_free(key);\n\tsshkey_free(hostkey);\n\tfree(fp);\n\tfree(signature);\n\tfree(sig_dest);\n\tfree(user);\n\tfree(prompt);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n}\n\n/* shared */\nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror_fr(r, \"parse key\");\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug_f(\"key not found\");\n\t\tgoto done;\n\t}\n\t/* identity not visible, cannot be removed */\n\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\tgoto done; /* error already logged */\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal_f(\"internal error: nentries %d\", idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsuccess = 1;\n done:\n\tsshkey_free(key);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}\n\n/* removes expired keys and returns number of seconds until the next expiry */\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\nstatic int\nparse_dest_constraint_hop(struct sshbuf *b, struct dest_constraint_hop *dch)\n{\n\tu_char key_is_ca;\n\tsize_t elen = 0;\n\tint r;\n\tstruct sshkey *k = NULL;\n\tchar *fp;\n\n\tmemset(dch, '\\0', sizeof(*dch));\n\tif ((r = sshbuf_get_cstring(b, &dch->user, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &dch->hostname, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, NULL, &elen)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (elen != 0) {\n\t\terror_f(\"unsupported extensions (len %zu)\", elen);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (*dch->hostname == '\\0') {\n\t\tfree(dch->hostname);\n\t\tdch->hostname = NULL;\n\t}\n\tif (*dch->user == '\\0') {\n\t\tfree(dch->user);\n\t\tdch->user = NULL;\n\t}\n\twhile (sshbuf_len(b) != 0) {\n\t\tdch->keys = xrecallocarray(dch->keys, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->keys));\n\t\tdch->key_is_ca = xrecallocarray(dch->key_is_ca, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->key_is_ca));\n\t\tif ((r = sshkey_froms(b, &k)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &key_is_ca)) != 0)\n\t\t\tgoto out;\n\t\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"%s%s%s: adding %skey %s %s\",\n\t\t    dch->user == NULL ? \"\" : dch->user,\n\t\t    dch->user == NULL ? \"\" : \"@\",\n\t\t    dch->hostname, key_is_ca ? \"CA \" : \"\", sshkey_type(k), fp);\n\t\tfree(fp);\n\t\tdch->keys[dch->nkeys] = k;\n\t\tdch->key_is_ca[dch->nkeys] = key_is_ca != 0;\n\t\tdch->nkeys++;\n\t\tk = NULL; /* transferred */\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshkey_free(k);\n\treturn r;\n}\n\nstatic int\nparse_dest_constraint(struct sshbuf *m, struct dest_constraint *dc)\n{\n\tstruct sshbuf *b = NULL, *frombuf = NULL, *tobuf = NULL;\n\tint r;\n\tsize_t elen = 0;\n\n\tdebug3_f(\"entering\");\n\n\tmemset(dc, '\\0', sizeof(*dc));\n\tif ((r = sshbuf_froms(m, &b)) != 0 ||\n\t    (r = sshbuf_froms(b, &frombuf)) != 0 ||\n\t    (r = sshbuf_froms(b, &tobuf)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, NULL, &elen)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((r = parse_dest_constraint_hop(frombuf, &dc->from)) != 0 ||\n\t    (r = parse_dest_constraint_hop(tobuf, &dc->to)) != 0)\n\t\tgoto out; /* already logged */\n\tif (elen != 0) {\n\t\terror_f(\"unsupported extensions (len %zu)\", elen);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tdebug2_f(\"parsed %s (%u keys) > %s%s%s (%u keys)\",\n\t    dc->from.hostname ? dc->from.hostname : \"(ORIGIN)\", dc->from.nkeys,\n\t    dc->to.user ? dc->to.user : \"\", dc->to.user ? \"@\" : \"\",\n\t    dc->to.hostname ? dc->to.hostname : \"(ANY)\", dc->to.nkeys);\n\t/* check consistency */\n\tif ((dc->from.hostname == NULL) != (dc->from.nkeys == 0) ||\n\t    dc->from.user != NULL) {\n\t\terror_f(\"inconsistent \\\"from\\\" specification\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (dc->to.hostname == NULL || dc->to.nkeys == 0) {\n\t\terror_f(\"incomplete \\\"to\\\" specification\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(frombuf);\n\tsshbuf_free(tobuf);\n\treturn r;\n}\n\nstatic int\nparse_key_constraint_extension(struct sshbuf *m, char **sk_providerp,\n    struct dest_constraint **dcsp, size_t *ndcsp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\tstruct sshbuf *b = NULL;\n\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else if (strcmp(ext_name,\n\t    \"restrict-destination-v00@openssh.com\") == 0) {\n\t\tif (*dcsp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_froms(m, &b)) != 0) {\n\t\t\terror_fr(r, \"parse %s outer\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (sshbuf_len(b) != 0) {\n\t\t\tif (*ndcsp >= AGENT_MAX_DEST_CONSTRAINTS) {\n\t\t\t\terror_f(\"too many %s constraints\", ext_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*dcsp = xrecallocarray(*dcsp, *ndcsp, *ndcsp + 1,\n\t\t\t    sizeof(**dcsp));\n\t\t\tif ((r = parse_dest_constraint(b,\n\t\t\t    *dcsp + (*ndcsp)++)) != 0)\n\t\t\t\tgoto out; /* error already logged */\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tfree(ext_name);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nstatic int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp,\n    struct dest_constraint **dcsp, size_t *ndcsp)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = parse_key_constraint_extension(m,\n\t\t\t    sk_providerp, dcsp, ndcsp)) != 0)\n\t\t\t\tgoto out; /* error already logged */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\t\t\tverbose(\"failed add of SK provider \\\"%.100s\\\": \"\n\t\t\t\t    \"remote addition of providers is disabled\",\n\t\t\t\t    sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* identity not visible, do not update */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tgoto out; /* error already logged */\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t\tfree_dest_constraints(id->dest_constraints,\n\t\t    id->ndest_constraints);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\tid->dest_constraints = dest_constraints;\n\tid->ndest_constraints = ndest_constraints;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s) (destination constraints: %zu)\",\n\t    sshkey_ssh_name(k), fp, comment, seconds, confirm,\n\t    sk_provider == NULL ? \"none\" : sk_provider, ndest_constraints);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tdest_constraints = NULL;\n\tndest_constraints = 0;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}\n\n/* XXX todo: encrypt sensitive data with passphrase */\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tdebug2_f(\"entering\");\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\tfreezero(passwd, pwlen);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsshbuf_free(msg);\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; /* transferred */\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug_f(\"remove %.100s\", canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror_f(\"pkcs11_del_provider failed\");\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif /* ENABLE_PKCS11 */\n\nstatic int\nprocess_ext_session_bind(SocketEntry *e)\n{\n\tint r, sid_match, key_match;\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *sid = NULL, *sig = NULL;\n\tchar *fp = NULL;\n\tsize_t i;\n\tu_char fwd = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_froms(e->request, &sid)) != 0 ||\n\t    (r = sshbuf_froms(e->request, &sig)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &fwd)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\t/* check signature with hostkey on session ID */\n\tif ((r = sshkey_verify(key, sshbuf_ptr(sig), sshbuf_len(sig),\n\t    sshbuf_ptr(sid), sshbuf_len(sid), NULL, 0, NULL)) != 0) {\n\t\terror_fr(r, \"sshkey_verify for %s %s\", sshkey_type(key), fp);\n\t\tgoto out;\n\t}\n\t/* check whether sid/key already recorded */\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\tif (!e->session_ids[i].forwarded) {\n\t\t\terror_f(\"attempt to bind session ID to socket \"\n\t\t\t    \"previously bound for authentication attempt\");\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsid_match = buf_equal(sid, e->session_ids[i].sid) == 0;\n\t\tkey_match = sshkey_equal(key, e->session_ids[i].key);\n\t\tif (sid_match && key_match) {\n\t\t\tdebug_f(\"session ID already recorded for %s %s\",\n\t\t\t    sshkey_type(key), fp);\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t} else if (sid_match) {\n\t\t\terror_f(\"session ID recorded against different key \"\n\t\t\t    \"for %s %s\", sshkey_type(key), fp);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * new sid with previously-seen key can happen, e.g. multiple\n\t\t * connections to the same host.\n\t\t */\n\t}\n\t/* record new key/sid */\n\tif (e->nsession_ids >= AGENT_MAX_SESSION_IDS) {\n\t\terror_f(\"too many session IDs recorded\");\n\t\tgoto out;\n\t}\n\te->session_ids = xrecallocarray(e->session_ids, e->nsession_ids,\n\t    e->nsession_ids + 1, sizeof(*e->session_ids));\n\ti = e->nsession_ids++;\n\tdebug_f(\"recorded %s %s (slot %zu of %d)\", sshkey_type(key), fp, i,\n\t    AGENT_MAX_SESSION_IDS);\n\te->session_ids[i].key = key;\n\te->session_ids[i].forwarded = fwd != 0;\n\tkey = NULL; /* transferred */\n\t/* can't transfer sid; it's refcounted and scoped to request's life */\n\tif ((e->session_ids[i].sid = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_putb(e->session_ids[i].sid, sid)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putb session ID\");\n\t/* success */\n\tr = 0;\n out:\n\tfree(fp);\n\tsshkey_free(key);\n\tsshbuf_free(sid);\n\tsshbuf_free(sig);\n\treturn r == 0 ? 1 : 0;\n}\n\nstatic void\nprocess_extension(SocketEntry *e)\n{\n\tint r, success = 0;\n\tchar *name;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &name, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (strcmp(name, \"session-bind@openssh.com\") == 0)\n\t\tsuccess = process_ext_session_bind(e);\n\telse\n\t\tdebug_f(\"unsupported extension \\\"%s\\\"\", name);\n\tfree(name);\nsend:\n\tsend_status(e, success);\n}\n/*\n * dispatch incoming message.\n * returns 1 on success, 0 for incomplete messages or -1 on error.\n */\nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc)\n\t\tfatal_f(\"sock %u >= allocated %u\", socknum, sockets_alloc);\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug_f(\"socket %u (fd=%d) message too long %u > %u\",\n\t\t    socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\treturn -1;\n\t\t}\n\t\tfatal_fr(r, \"parse\");\n\t}\n\n\tdebug_f(\"socket %u (fd=%d) type %d\", socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tcase SSH_AGENTC_EXTENSION:\n\t\tprocess_extension(e);\n\t\tbreak;\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tdebug_f(\"type = %s\", type == AUTH_CONNECTION ? \"CONNECTION\" :\n\t    (type == AUTH_SOCKET ? \"SOCKET\" : \"UNKNOWN\"));\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].output = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xrecallocarray(sockets, old_alloc, new_alloc,\n\t    sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].output = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd == -1) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) == -1) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[AGENT_RBUF_LEN];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\texplicit_bzero(buf, sizeof(buf));\n\tfor (;;) {\n\t\tif ((r = process_message(socknum)) == -1)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\treturn 0;\n}\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror_f(\"no socket for fd %d\", pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLHUP|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0)\n\t\t\t\tgoto close_sock;\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\tint r;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal_f(\"recallocarray failed\");\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/*\n\t\t\t * Only prepare to read if we can handle a full-size\n\t\t\t * input read buffer and enqueue a max size reply..\n\t\t\t */\n\t\t\tif ((r = sshbuf_check_reserve(sockets[i].input,\n\t\t\t    AGENT_RBUF_LEN)) == 0 &&\n\t\t\t    (r = sshbuf_check_reserve(sockets[i].output,\n\t\t\t    AGENT_MAX_LEN)) == 0)\n\t\t\t\tpfd[j].events = POLLIN;\n\t\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\t\tfatal_fr(r, \"reserve\");\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug_f(\"cleanup\");\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-O option] [-P allowed_providers] [-t life]\\n\"\n\t    \"       ssh-agent [-a bind_address] [-E fingerprint_hash] [-O option]\\n\"\n\t    \"                 [-P allowed_providers] [-t life] command [arg ...]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\t(void)setegid(getgid());\n\t(void)setgid(getgid());\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe = 0;\n\t\t\telse if (strcmp(optarg, \"allow-remote-pkcs11\") == 0)\n\t\t\t\tremote_add_provider = 1;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}\n"], "filenames": ["usr.bin/ssh/ssh-agent.1", "usr.bin/ssh/ssh-agent.c"], "buggy_code_start_loc": [1, 1], "buggy_code_end_loc": [113, 2036], "fixing_code_start_loc": [1, 1], "fixing_code_end_loc": [131, 2055], "type": "CWE-428", "message": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.", "other": {"cve": {"id": "CVE-2023-38408", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-20T03:15:10.170", "lastModified": "2023-12-22T22:15:07.490", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-428"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.3", "matchCriteriaId": "BF546253-FE80-4416-A138-D79D7288229F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:9.3:-:*:*:*:*:*:*", "matchCriteriaId": "031E80CD-A7CF-447A-AEEF-EB97EB99A762"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:9.3:p1:*:*:*:*:*:*", "matchCriteriaId": "97FEC052-52ED-464F-AF19-3621775292D6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/173661/OpenSSH-Forwarded-SSH-Agent-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/07/20/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/07/20/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/11", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/9", "source": "cve@mitre.org"}, {"url": "https://blog.qualys.com/vulnerabilities-threat-research/2023/07/19/cve-2023-38408-remote-code-execution-in-opensshs-forwarded-ssh-agent", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/openbsd/src/commit/7bc29a9d5cd697290aa056e94ecee6253d3425f8", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openbsd/src/commit/f03a4faa55c4ce0818324701dadbf91988d7351d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openbsd/src/commit/f8f5a6b003981bb824329dc987d101977beda7ca", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/08/msg00021.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CEBTJJINE2I3FHAUKKNQWMFGYMLSMWKQ/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RAXVQS6ZYTULFAK3TEJHRLKZALJS3AOU/", "source": "cve@mitre.org"}, {"url": "https://news.ycombinator.com/item?id=36790196", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://security.gentoo.org/glsa/202307-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230803-0010/", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT213940", "source": "cve@mitre.org"}, {"url": "https://www.openssh.com/security.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.openssh.com/txt/release-9.3p2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.qualys.com/2023/07/19/cve-2023-38408/rce-openssh-forwarded-ssh-agent.txt", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/7bc29a9d5cd697290aa056e94ecee6253d3425f8"}}